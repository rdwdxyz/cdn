<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8a4c7ea709976bdad4f4f8cabacaad6a0c8def2226b1e00082684bff8c4c6cd6c7e433008118544e50e71533e0002e2281f08dec4d963a54d1a51e8b060a457ef2c3366a1a0da41f4fd1d8dff510970c73adb1ed42f3f2971825b29b76c51b48b20f195606181a955f530e50dd79b009c7233602708d856931a64b33d407ce93845d475da1d747d86236e41ae028d0170ff9ba63d3613de7cc189375cba4492d4f7a763157c0facd2a5a5b80720734296f5c83497103026a78f17fc5203e61d6c0cbd6926b5afe9b039e051831a4e61f5fdc0d0a667aa6d1f45fd563bcd73127164b83146f2298d30d0fb45252b3b7b77d397030480dc866ad20b4e3261c77e72ff74338a299e116e89030bc5df8a188202d2733efec6102db189bddfa3dea3bc9d598efef896b88314e2c4079f259051f968a5826d5d94d41b68ae69d20bb64f663981b73404b967b8c82338419621aee670e3759d709e9c5832a6914b50fc80fb187d886abe75ba3efd764cac0ffb3b9ff5609b33855ec00be360d1bad6a1b615b00243b86af5702a30e177d7ad86c2a519bb5ed877268b47c17e7d188631822603f78141d5caa634a6c704d70323fbad2083a1c6c776a719be61adef279769dc7dc24e52b1c93e3e17b1634ef7ee734a66ec7239eb609262a0091b5fd527cef0fb2f0a3ccf7280803ca1b8772d122928e2ddef4f9ee3c6c1c6c6d2b312c95cfc28789d3ba550327b6a0ad95d34a3ddc440ad52c12266c4bce2c3cd1b5e58b192fe5ae18092284e4ae3d284dd0fcee7f26ae50cf2bc81cb4b16713c6efe3753fc25233211b4fe40273c6478473d22f7e0834262e82fc33e1e61fcbbb84c4df5df81d4ec3a1416f1f63fe3abe8699707112db5cd6393fe644ed7462ea72f1fdda8fb5bc2d6964b804014b7968dc2146c80a863d5b0d29772cb52928ccc8e272a123b5ec769d8cc09ae22c9fa30b573171f5a9df14e3ac5b57d27df09cae1d77e604618cfc57aa4e5c13a4770f7793ee1c64543da7c3bcfe1ac550bccdb983e9b5bb3590cd54130a16555368933a5b89ca8c81ae3fd03a73c13424e1c8feb28c8489c1e1586dcd595454fdd8184350c472e2bc3974f8b40e668383ae99e6826c1396a2d602df441cdfc550d354dc8a19f6edb6e26172ea2e04ea09c00e49b5338b2c0babdc295a1eea95ac7a8eb174c4209b4a826f3c2d3e52959eafc3b06f45d7838005689dc864f0e0c173f7b273c7153437cae8ed0f9bb560c4b210459eaa94024a924c3cb658db8041e90829ac066def868edebc425ecad5eca61f690379c172e27d3a321fa1685f1a61af9cbcaba1f8a280194f1f40cd673191bd009737176e8e760f52bca5556cd3d357494f6d1f119f7ac68dc58017425b809d68b07b3ef22b5c148cf825aa13bc471b11e3a1077feacf805543147a4b75bd8c2681aa46d9fd133420e8911bfaa657e2f5ebd060e6a4e134679d37337fcc77755cf82576d62da2183c1d53b2f1b17ea18e84ebadca69bb1545cde42b1e06c85d5b31ba4f39ce180a89018b2a71d942a747656fcca1ae119fa43899490301686bc24be9c990a17daa0bc9e837a73c6093300f57869e415f16cb974c73a79237a8b1e12ad50b168944c5c1fb50849f00ecc97d28bb9f268ba3cf5afb0b7ca57160af7323ed0bed07d8f1e9b04df187c8caf0785bb131c8e7dc072a3b99f6a957c6ca8ecb25b16ad690bc0c6e10f8c66ed340bd402458e57826bf978cb857ebf647075995bbe8f623ac75fea5f51a9f76be017665286a1fd944d3d08f9a6da6b80e193546456a9933504ff313cfd5d01d92ba730add76464ee5d09b009514d9e02c362233886ef5745e912921995a366442d221c79d0e71f88270d1d7b2a3bf9f628a92267e63c0d3fc05a65f19e6ab78f6ad4e8204dd68e593f5e70a2c609e0919146e7d4395306c3b7328be7f3faac4ff1df730adb0fbf9c7d0e200f59f4f0ec1abacf391692e129cab278f57bdf7f78da3ee81dfcea7499092c9c0930fe137bd52798b1cf0ddbc9d51d2b55c1ed7e33b5384cd36864a1cdb987477e56130e777c31bf72cbe161de4985d43390b9ba6d1ad153d9d91b526f2b10c8d3272a4a7ae3b2f9e6ea2736f39dc7d70a625f5e2edd109d84388533fe02a0a09d49f52ae674504ea8721dd4e4cf4ba3851a4625b5609f88fe854ef05ae6a5dcffe5f4e708b6bdeea792464a0742a0f2d33b2bce01ced297c1f5d8849ca1acb43f54e7ce77197cb92ce877b0f8af14b5b007a8f3f24a2faee87fb4fee7fe97259c12e9855422d4734204196394154b9bab7e172d54ad4303d44bb9d71ea9e7cf315902ac0c0f1c44bafa16dc79e5d76cce5ee6ca6a809a9748322c1eb1ad0a92c1c171f8805e286e2a1593403a7c664507892e50f8264252867d3469c525e97f275a228baed0c94b7bbe96a7b364e0e31f4df303685ec40ab14d0b6ea9cf0ee59ff304baf8f5c996644a5ad376e95e6158d7fe444fc66de622c9ebce4075fcd5c22950498aaf959c90b59a86b0552aade04fc0e6f729eaee0eee01bc1dd811529b794e6aed06eb8b2410eac4f35a70b208fec294394d4bd66e5e7c553458a1c12fa7fe8fa011fe9ece14571339288a491b01c25b37d7d1b94f7371a66ead87ff388dc4c541dca68e52a7e54a7060171d7f7587729145ceb6589c8877c0f1a2e105e807cb3469c6be9f23cafb4ce4a5f3504602a6baf9032f98b6805bde533fe021e4c477e21786ef57714659a9f9a6840358bdd2a661807809455130b24c9a14b4057c26f070f3314df0ecaeb740f96d07a514adea8f05fc28383dcaa36dfa7e81a1ead09d19d45344133304f33b52b815e6c1f146418373e3463c7d3f9eb4e1835c48b1f0f903db8ec8767e65494a954c415456319cbed1fab3e1d160ecfad9759407c61b9f6d28e1d531dfb5d901298c9d30be63d4398b53f269b7acdbfe8e0a8fc6cedd9d0ddc50c32b690758bfc3ce71136d1bc8d0471cab665687c62735e5dc1e87a3664a17b6899dcbefd3c2994052e18d7838f937d44255832edf418f64672d99ecc43cfc1c5a9028ee7702241ace20b1324d0e382e2cde13006aec0df1fd51aa4ecd2197ee4e7b0d919c8c5e9aed4794134eb25462eb6181c7de9360117f848e69d08caf2c1f7b9160237ed607d678659247736abc0e66a5fa610e2cdc88c28876f80a408c85bccda5f1ef03d7989d7ddcebc69564b81e8ebf816ce64cc9b03e989d162cc99c7d22dc62477b5e994a7ee8e74669a31b7d7ce85b650286e55ca204ef32b469099c2558316823c2a27c648f828c8feab717d3e0afcb0c826bf2eed5af32d69cf54791ef6dc320b4ffb8300c11d0b29857684bb89b8577841ca9f18936e2822a52888b9a40e35a8b7d3f98d3a238c6cf2eea621bec3e3c1c068751ed1887c1d5a55082b794d00f809d34cecc093a647d4927f05d6af44185e888a1ba06dd5764d9fa0541e3abcd1c251e656d81fedbf3f835130556458790ee7dfd7697a9220d0827727ed4cb21d9d1fa0b738f63ce05c8b0e22cd04a78dab6b047704c8420cdcd3c3138fce9a331bd5cc4fda714d482a64b38acd0bfce9b943cf4220c6f451e53524006ceb43cae6bc1c84ba25948db5179c8728d19996f31d26e73579c5494193a4311ceee3fe25561dfc850dec1d4f78e81a55d513e41d21c1728b8715c94125827f5512aef34b9eed660acf9090b8eefc148f4b55852a64523016f360ede66a08faa937803b16839eb732cd6fa0f34ccad52ab893e32202321ccde633735160f5f7e0640625b0d18623a18626176f9f95357c0e616feb9ae33483a1ea1584d6271130939a6f059f346a75f5f50d48e707b081dc831eef016b398293cbaea18e35e743bea437e9bc354990bfe4bb30187fe4ec57e1c485258041c6c5bc54a65532aac977d6c6a7e489791189526d3c3c2e20384ce98c39f38fc1beec148eb65bff8096b4ab2ee6d62725c37b4b69581888a46ff0d9bf74ec6ac7ab09dcd57a8ba9e72475f57baba466d7b1539986ee94eca66bcb9c5dd45a7c0f5e7c8cb1894113ca1e151175f3594b91ae5e2c013091efbce0e969a62ed69d70ce4d4264e0de1403853aa8e2dcb9795d2e0de709ccea3add7fb04e77eb8f0ca28ff8fe89d4d091c4159e247d469751e1670bb8b9d4c21ce32e8c24b82b9eb4c0e57cfb8a2e6acb9d1f0eac2264bc97ace48f39471f6e9576bfbf0ea11b8437dc4d481c4d5f276750398204487350f730483c6d02fcc4a336c23ce9232d764ebb691323ab45f7e810c644572fadce7ec7df38d667f726f05d113945a17d3e9b4ac1b91684c536cc2b166683b18dbad6f450fc3868364bec15ae48b8d745c74758941c4c1c2817bf1ec69c6001dd5adb41403ab73c5481c111bceb3d9fecd2ab5ac0bf2f7504715f5d58315518d41848fdf5853dd0c2805f15aa14ffb6fdf46d0374d9a9ee70d60001aa1a1eaff79779f01957a1190fb0d842eb9a11f3f8206fd0e442982ddf389172350ae78320794fc18a3b27e7b40d0d7ec9ae960b4c050d0f793a719b305bc0f5dabdda7ebd2e9ce8a1f014f9992a5be151a5a82beb1917a268257a80e96c02dcc71707550a39211f727eab90586308a600e5467c33c0c62711b6200be8a11190c14d382682aca9efab728a37046df5852a96e1383c2e52df57d709e9166fc9a0e2b0c9c7fc0ff40c620f5b2f788f94f06bd114f81d386b99cdab1ea8fbb371bee28f6594094223e9b479cf7472524333d9b05b3c8e3c1494ae5d4f84a4446d40371e8fba8a1c90564948758e1e9266e1ae9fbaa32c3c72479fb9f00ed420ac113ad642c7cec427dc4bc517409f631848b7a5e813770b80f59e42ba8b988c15e91dc32b7117cbd2ffad47bd577d1e70dfc48ac2f09c05010999b51c7a70b0eafabc36dc8b04a02710c0dea838072237bc6170bacd426d9072cf6f3501f5ced8b6c7926cc3fdcd8d5f5f65020b3346bd539917eb5777b878b916ba6695604dd90e6b10ec3cd6c5a8dc1a5dd2123142830d4490a3e0e25c1fcbb82eae5acabc8a79a9149dd6f7db94ab0057a4d52276a35376e85df39f721855ed0cc7da9d192e8d3dee8f90b8c6b882df845b5ed7c7a3c6d207f8096b7f54d68d9a1fa92569e70596cf74720fe9a816bcc5600f76ce459f477028135ae0cceca89a64830b83622e9c2d79262f395fe737a09bd25bdeb9211bab4159eea150087a1ce91c62ea3562270ffd80f6c21132b250af887fbdd891795f8f6a63bddd4e43fe5796cf44a76877a07346ca42a85d3f6f2e0318d66de6467774df1f0fd7afe527413c98c750dee90c376e84ddc86fb19b98fba09d687fb20b3f7ddb3318de36f8974a4eba20cd5d15ee0f0b23589ecbcd71746950cc5819964578fb74d276c416858503358531959f021dd6b2c7ddc97561b9142ef3c2768e4bde4644527767cea915b26d87232a99d67fa404868e52d8d3dda64990ed3ff3c990114d9c68554ccafcbe10ccb381965020f476a94d2e26fc6843cf2a7ba1ded26a321b129692b627fc67d8cffce85be181d07536f0074085452f1c98eff9fb77609953ff1fb3f2e89cbb2f554cb21d31d4f78ff91ca7cb5b239d5f4f23eca2d8eec92cd20a9d591c858293b4d9b7a7769b3caa028323de389df45a9c7655122903668d237a04d844df432e54d810aba17b0cb9e1d7a877f4a3d8235f8f45b581305333a21705131d5afac8d8575793e5effdf50c3dbf8ca625d9f59f4320bcb9564e6cba50b9a7e43491f5a4274e343d5c7605d51a59a8777edc3022bdda51624390e8e776721dad80194455440a4538df167ba688c8e7b4ec78902b0709a7536268c2f961d341ffcd3ad6f4bb80b5e40983103b97a7ef87aa10853d7069e8d6fa0a6134650297f4739bc44ec9faa2149571d3a23be7a46ee894eb2c32c3be0de5cd0ef53607dbb47626aafbc27d9d94819beb9bd3f420d15184ac44a18b9d7f62bf2273a84f24c019342ede579f92e9b8b5fe1b282f534ac85f09422246b2747a6e688b6396d2ccac29d48088fc0439269dd8790d8e59e1198aee99547cc9ae91e15864d19ea456f98b1e83a0cd32fbfc037a25554fb72425c6e6399f972b288a92c78b208b346f67b0caca2f36a2ff682950a5a1dc3749bd74f6d65c9e976a1f65631a533928fd9d3d45c411c9f96e48ebdc087236535029192c5591432ef2950976a4faa949d7208ecfd902d326e1a6a4c434012d582b3d86488f4fd32c1d2f6bbab1fdee35d7f3e9600b15b737991646a38e8259ffd952cc1fa56356f4e4f28306b324775c6463378d921f913559254fda89118c7810abe23fd4784b6f2771900fb9ca043dd314bca348cd4dc23ad2120c42bf5c2f04c264885727efb81735a4a261ea224589bc12f7307efe1f6b603ee3584bec860f4e8a481e9c0156801b045fc180d682966e1f61bd85b550010d13516a470932265ea8386b8032c46388f866ae6469dceb1e866ce7421139f3b9a18b93f310e8e0d8398d62296af6120c56d3426ecaf9a69042df2e83b8da15a74189419b2d97fa40f0436cfc3e193987623bee04e9f2d1d592a7d70196e80b5a32644d1fc9a37ef460ae52507e982707be2d6188bf41e866d84345ba1b087e6576eed8d231164d1494ef645f997ea092460efbb18339003c87710ca1f6dd1b7d465d3b7fc0d785d9cdbbfdf32d38c69106d4288313a1dc06c0713aff45e232bfc0d3f7dbedad3b3aa5cb372d95d66364b612a006e308fca0bb285a0877618176c8ce2637407f45306a45601966167b2989bf6b981a243a2a1c7bd984f845cc601ef547017571575d7c08c19e6353d918cf85caa82a088974cd15ed8eced5e553c4c335116ca78698536eb7246dfa9f8fe32943f9e79f65610c6b1fba34a6beff66ec156f1cff4f0032454b3acd8af559d05484b1cf1e988395bf2cafb191fefbfd870ef25d3c99bfa124eb42d0a917644bb4c8f23c57cc3460d3d0b8e3deb77b80bab6a0abf570408cbeb3f61f47669b8e6b07f7e7bc60e2a4814a276e0719454ff0b66ca9b27d62a72536dd1654702569e7efbb20d9820bc51d88034538beca16ece8fecd033e56a040e71056c782af41d5c528e2645631bc26bdcc30711c0a24bfb36744cbef27a45cb943ca5793fbe1a5339c570346eac59deeee1751a6e406ea7bc8261d43a4b2c2b5e21a414278fb1f4091b73b2698aa5f0b1dfebdec6ef3e2ed6db88443887a26707ba4eaa080845c250a912082977a3193f3ae9d8669c717f25dc7319e3922fbaceb9c9641b8d1c1387ab29c067d351d1c932164a129cd563b7264ed67935788707635fa2880ad08b9d3600fa5ad8f385a7d0da1411fe65db100737f58d551d51f2217d34bf930922ed3832faa36db038b0eea9d9ee2f3b1ee686576347b2161bb3f756a242d0ffb7213b1d6e4a1ce17904bfa3661cdc844fd94663e74eb6c6258fdd2629478f5f79e6ba056388c381518e96968db0f1eaccafc6ff0c5d05e122fdac20aaf3d21eacd2854fff1950940f191be1d82919350fd8acbd38f489bed16a3733b842085fc08e9cfe2f709f153b62a32aa6a137e80f6490dbd64204b2e387fdcbc1e50aabacf7386e66849e03207802c8649e2f8457919b75f489f04651e27c99e648f7c26fe655fce9b219b22c87d7043a1937c94b38fcf6401c81c923d75a35af308645be6c14a9292b042e7ce0ecebd0b1fe7d050fb408c31c65be9cc996063e9ebc91f5ab226547525dc08cd67d2241d12ec8f27b786a727f6eca0f4a0cd19dd5394d76fda76d89faebbedb71479d4514cd81668dc1eafaacfa5f5c9cdc368493d16c7ccec7443d994cad6cbdf9d5a638e7f0c083f7662f9eb1cc1f6b87ffdd73c82f4c167b82e1ba88dc73c85138770a0fa8ecd411bda4ed9e88fafebfff8383974c332e25a0cc6adaa5526094e009278688af08c3757854e5d730045a612a3a733b12c5e7e61ff334cfe61ae02075aef834980543f2e7b5861a69eb09bdd2f38a7315f04a3897c8e54e2991b1c286cdc610690329b217a06be7cded517989e94a4386623478080a4818aaaec14d06767f8cfa56e676d491beb4bd9a29fdcb2fc64d7707607d4fe7b516c08b0c98e8a255a38240241b02883cf1e8d994ee229353e823abe40a851b29b59c0ce7392aac5cf4362c1877dcab01199d394645b0745ceef7cc657cdfc5f74392dbd59a2b744c0781b01a714a98c5720d92fc7b7fa3f743a50503a5465cd74769e35f8b73314623a3075978d6bfe0b0ad160c6f85a326ac107f551bf6e0d23961ee753239dd0d023da29ddbfdd96e6f3aa1ce5330b8d12ca2faaff9bea8fcb600eb3899f37ed0e38721ec582e66543e8204077bd7c6c588fce80a7558738107c95b5b6aa39bc6c3f49bbc1ba65a34b017da9ff4c174adc1acc986d01aa2156874d8cb8e8edf2b2604982378fdbbd8ae3d23d3d946c5c6c9ba2d9ccd23da69241c1e43ebc803e04a03d7f6b53e56e2a891e3570888452f2313a1ebb47985ba86a11ff2852f251e46c182c9fd82258cda78ee09faefff38731be0fcc207f594259ac546ca755770a984cb58e9212996d70808566737fa4464eb5b06c5bac721bcc9fa55b51458c67f652408a05b1578899ad0a65e204d2c2d36ad758ffc5713d4bc847f7dee624f83b3b768fb5eff9b0d3867df7acb3a874058c661cc24af50e24f293bcea862546e11371d027c4191347dcf7f7740aa5f3bdce1b9a224c11dd80feec87ae2958a83553fdc80094feea1612654d470bea56ae638d69796e928d8a85ba8d7a2c8e1d6514ed21963e1c5cc20ef5995ebb4d8bacc3d16493bf3f5f3a973b9992a11154ddfd72cdc0e771ded6c05eb0af28d2d2d98a3e11ddf92252cdc2e92ea8cd59e42b406b5fb527fe0a0b61d5f4a6556b21848d375731bc4a37a24401b748fbc581484f1b636ce0ef29b1341c402fd32b47f0fd5121feeac40ac350729926fabf70f080d6d95c6492a68c59d8db4284b02387f9a7f76328cab8e4e6941ffad8a53f4710a4bdbae976323b5011c925e9bcdd99e71bed295bb0491a649d05c5c831a9d60c82ebaf14d672127ab5ad8740007a1b54f157d2b45082a102388f26f7ba81e2c1943a55b71edf65dfb9f78d34fd3a1b3a0e7c39e9d5f7b1ab44f8f8f1033309345d7578a08d5d91d83d62bd483e7117eeb1f869c621f4cfbd3c2e9e94d4cc4f21765dc9eca94a0e596c28ee2d12dc319fc1ad9b3121d86f8050f44e22f2577d7e2301ef5738f60ab8c8c3e42f553471b56a5784eac54d1d322b34beb007537a9eafa1b91a04f2f23ec6d24b7ba0f33c5cca57aef6b2550f88681b7e2ad40b1b58a530be380e53de05327c5ae9d85c44c67c764c3101028233b2c7f5dfc4eef8d2e283e15e1f451971721f8c153b3be6984b8f243a23b31e9cd7165da8ff78b9b7e668771d96e669676669be73b73b8ab0e4c28e7abca4776bcf9aa5e9014c2fecc8845e5a8d8f2c3bb382b4688af552988a5411b8d5101c7345627bc539163d4196ada0ffb186144c9a3a8651bfc37bcdfeb08cec4d812fb0a81fe655c4aef78ec45565ad1bb95c3d15a8092efa99b55afc989373876f25359234e33ab32ffb5cd356de3e917a1c42a1a1a85284a214bac4db01ee978f3a464276c213518b83950e34e4f19464e9f3d0e57cc1f9930d25fc067a8128ba7dd4456464f758f07f5fe7dcd2c1be12ca2fc985e21be89fa170b902d902b36a53c9b2ba0287d57cb218346bf6875fcaf047a33aa62e96cad1ca1573d61460476168d12873b02d29e61e0a2bc898f9afa134f482aea57544e868fa90493bbca67089243f81e81f965d4f38c0799d09723c4acd9b5ab4d4104ca8b095c32dfbc9709791c4c93717cf5828a7b3618e6ef4c8d85c9caccdfd14effcf5391c84eea0a4150da40e38993a001e0b76f7f6535450c63247cafcb9e2d915a17fc54d44eddc79b68ad2a1fa197c5768b065fb8d33544f5247b01b5e27d6eba71dfa5537d40ea82a93cd6e9769a8fa0d895e8217fcbd6a60c62743500bc981ffa454efbc4794a414bed870ce26290ac500d40e585ece0de2f3472911816d1835988e0bed989b6dd1ee2b83c8253f02960989e0e481cfbd1403b5988ded855a30ed8dffbb892b38d781e17d294ac81c0977a9b918e70bd6b78d7189ae7e45992b2074a5d359b5154a33fb6c25478e71e897fc736b9d9ddc857936d5e96a6dc5a2f335215e8561a4cd50820a5e0bbb3fdc5ff005d95cf20c5dff6af64a6c982e86415f64dcb6a89d179f92ce4ef3d646f696e9de181a36b399102a9792f0e5a90451ed6404a22c448188e40886950af0fd6536b4fabf358c508f2a3c6195dfe4a445537133408b1e074621f0af3e4d926b9ab86c5d8d4b0d37220c86fd36bce02e9dcbeffaa21bab4dd22de19963dac3ffc37e1bd2572deb6cdbcbb19d690346be7bdda1b5ede273023e8f1a877bd600b53d965b241013d497868a201c7fbdc8ffdbcbfb7c6e0123a50be2712e7ca3ad9e8c3ffa1ccf81214d1299a5b460c3011ddc5784df153c2614de390553b94e1f223cc078da9725f62b760eb009e61fad8cece28fe53b69968e8f70b513ad323e0725e75e3e10e8ac8f4155ddd510f5b1e457bde48036963622dba5909be8d6a071864cd5be9b134fc34020abae585e7f65b48951ad1171a02ae2d3e3c854cc8407b225d9a0aabdce19093739d363ee8ccfca94474f8eaf3af0d4a882754011382dcaad65c7e738451fb18101da1640b18e147341cd21ffdd72b0d4d8e37751dbacbd46343548ca7b6cd8a21945a1c6777b4cb673124df31def732e11951c36f205a0a9cc9038eff21a44eb00932fbfb4af1f000ea1849cfb399c8095e76d5797cddf7c79ffd44d48faea9c64aca31050142d3050b4fdf6c8206b1ec0006b14b753a9a20552914db9dc137053a36e0577982106c513e1ebc93cec489f96db6659f99ea693591d71f3d7cb01ae212d995e79b48605647184aba13a75efeb8f2d179628e34158576737702e9cbbe80bd0d8cccf7e4ad1d3b1c53e7f13870e3071e0ef6110b4af6519020c23bce540e42221eebfab566b0b4ade448dd44d558d72ae08d383b6c2177038ef0a2aee53cd49007bdf90217195ab086845d57a017fa4293f67b916fd45910634c7b5c7143998fd4a10bdaf69528279d141a8d7e9b8df276c9e663e2a19115ce49586ac85b172fd08b816dbc238a056c32a0210435ad10ec397820c2620a5fee4aba9ecd414906b7a60957dbe273545dd7b7da31fd1773a99645f8c92c32728bdd97dcae1a7226776b762731dd53e5eedb0a502f9549097639c615917aeda4afecc28f7294cc9fd083ffe7062bb973d562f7f2de0e0615936f4042abe3e8475c0504c14c66e41725a80d24e1a959c2419efa74790e0224063a46db7459efcc99f74a4d472493afcf83981ae12c9eaffa48491d367ff7f2d6a012d807bc55275922c9073c0cd43c2ee58694eb5f01fb6ef4401a8fd10d4440cef2f0986dc4e17e7426f0ca046d9aca493fc668220319ee55eb51c4c2ef69960047d037776d39475f43a00334e9dad8a7a93651039071904f2ce87c624cc5172a4c4829c458775ec0e15c309dd83ebe5e124b0f84343532bbe4d2f026df59f8d4e51e7d3bad55107c1ffb41d3624d20fd7367338f86c04c0b4f21d1bb7a237c0d06a3ddfedc5e340488de10dc66fcca88b970534ec8a07596c232d36dac9fe25e5f4c0356da1093bc3352aed87c50a52fa380f2da8cd06c7fdcac311ea307f64c77665d3c8a8c8d6a86f6ee117e921bb0bada69048b43813d3aceba6bf5fbecd3acfc720647ee4921b3667f824ccffb11e682518a22c67f7a44481d24a652781328a5a9847b8c94f3e4c56e4eef9febfe392de6a2088533a87dcc8669190c163f8c3cc2215d316da2c0ac9a859cb01dcead417f5d00f2e7a6d0800cd0f12ba754465beafea46cdb2fb4c46cd8ebc6755ff43a687fd3ce3c188a0520ed88f5cb60461670df13e19308eae75db4ee96f8eb9577f15d836739c08dbf4e414049fbabd5df45f977c384795038f1ba202c526b1ef3503e9bddee37eef89fe2f20e5a99c835f654fc4b0462c6b129cb679baba5db5d87f10d54cb5b14dddf429cc611bfc8dc8399828c2699e21ae114c04d1c5ee7e1fa11db0e9fdaea401c752e6491a41d23c7819bcc4d494b6f8a5aa341dbbe24d77bf1de4f27af7d76c21d6196cdbc1e06bc0e4be724c9cb7c8e793578856733a2d6e461e29744dee41c33fa90b2c69ababf1de38c87f17da0c8a2e1e1af236fbf9ca7bcaf08a64983c2ad589d536a0da917ef79bc4c160cf8404e3238672380984bcb89129e688b8edb191286b98a39c9cacc98483dc3ad7a3764ee13a6f4a0e49f55c879685d0c669103623f7d4dd53e9b1218e2ff72dfc8730db38423671f9cbcae1f5265b1888576212f073e3ae51233f89377586bd9cfc70a6bc4dd8d623f817b7ef12966a888fda04181b981ebe3753288f6cc570bed61bb3f7c5c2210ece843c78a7e57f40a748412c4a05e93941904995ae3e29e958174d9bc5b403619d35fec1a377344b15d7056fa9b093b57a9b5745f9d37d1fc6f930729f9ce64a191ebaefec079ee92957200544d34206d7265d6ad393aa1ebfaac58d765a77bf7c9c064e2735e0c881cc5b1526259ab8910f6d1040000c0a5297a346f1ecf3f90846fea3ee442d6e0e9f9c5cef9e4605552551d6811209a4884772044b85be52e8785f846bf62019462354450b4d7f910b3f67870c157c7aef9e8a44c74fd8cb9de3eefd13cf22b90b9d0142a3a7660e4e82c0be0dbdbedef11d3904701ad2009f6e94eb4ec6046bbfc2df9b29b5288560bbeaa4604c5052fdd8745476d2c737a83d4cc600b5555ee60aa03af668b715de38d0a1b7dedff7d2f288d1bdfde77aa1d96c7d62afdeacf72a22a70596976d612df0c6613db733ef988abfca347361471bfd83715c36300b311444fe102c0409ad9edb0fc86d0e246a855ad797ea0d044230bb150e4fbcae1ebd102f5fa09067c5668cc3040c4f0e6656b956c07026c2e9753ffe027a609e2dafc6dde14a144de507f35808bec5b53ce7d55984033b114cb51d7672e1982b14551c97260c9c53a8158ee0fd34c3151e44392634620b9bf8d5aabb4da35b688a8038f526ae34a2f1a3aa7cd558a14f515a98a74d9b10083436c5a7c594b54cd282dcd582d4d1840a32bb874e6bf16a4ba0c653e20cece1f7a54e4112d98a66de0b5965907d222734c56d0562ac55be098c116036e56b2746b37a9327342e8e00b1d285947b96989e5ed9fb022a2968adea98b41802db57d0b55cf8247441dc6ccc95732221c81d6abfbe2ccf8e0a042f5dbbcf04e08e7c598a6f41853db34623ca50ccfd3591282f76b0d3f0a826bf0a794374283771047952b77a78a36ffac872f4c4f0c3877c6d1490d4164a2cd2c63d9351941cace6ed02318f6e771ba79f80a5370c52c3e8c54bd5f33e772e80460c3683de5bdddf4682404ca52fe18f8ce40983844b870a3ea908300bb91c3cfda46af06e1c788d96567fca287c61a68d5f7c3c48995e35855a5507848a66bb59266537524e0c213f2f745ee7debcd04ba7abc5833c4472b8b74e6c0993d220bea6ff5c01e9e99f75c5a1858a1fccaca65875ecbbecf83301131ada013effc82ed5790f6ed5ad30ce2da1b60d73ec6ab699c7444f03deb270a9d373d7c3d9898f02714e0886cc1e2b830485cb76a58dff5424b509f8fa9c49ad1f047524d967b8dd817f2a1928949a0cdfe87b0d5bfba0e9063971cac79a7c8c9288546c6992124cdc213300b1116622514a408b1b466d9e9a4d6568e8a7edb9766b728b60f5e69310df8f73b3d913342a93a0ca2fae28c4fe02098aab39a362d587a6210dfdc3224d9c115f50fcb1f51d74496060a0b568df0d6d55c8c74d375ee8862be746b57711c78f32129d6deb10eed70f761fc711f4f055ffb7d8f46a92b71c6ca89035e8576510fa6eba975e1b7007fac1f03b884a97844866940952b5c721163f14699e453f11bce6bd88f5bd638f0a09ccf98dff58c15465c3ae1e457421543f48d24299fa1bba1506068410a0cd5be0da6f2e69a696d40d7c818cffac16099da09d3d36550d18b3260e1c9c7ca7b657b47c0a176f094d6a840ddaa42306bf99c1dfdf1d4ce24a80bec3944bb752011e9503fc971e72a3f27b0e4889471241ee5444711b561318a275de99612d919e5aab92bd4ccde866d5f8f4f167ae4af4cc4f744c52c441a57357ce29510ce806be7b40d016785d47abeb83f04524b5683d88114e0107b234952fc05dbbbd294e29f233bd3bac8931bc4fe97f2aa24fa9aeb9f0b631403a1a353d88c8f8064d65a5a5bf5b43922daf0322ec631e76d2d6a43459921d73d4fbb95559676e7807ac2a5a94246efbdb9454424422a315008e258ce7e236e11737209c15dca781a36e1dddab46e391dc80c02328486f928f8c9beae8d7b931aa4635fbd3a9b1bfeba70bd35985a83ef291dd78fb05f7e8242b5a7a9ceac2732788e2126d0c061753d2f03d9f0b3045511e7389160f4334f2a6e466ca58a05c4ec028ab0ff5a5fcb7d585d079af4ac27a58a13a21fecd37f085fd373f1f6a872d06fa35d7d53fe080f5fc7c69bece899941b84f7811c1b4023ce16e6337fd41aebdae4976fe9f5688ee1c43e5fc6759d017d53a556b25bf005b7c1a63cc5d2b0c9bdf389db8246d487e13fda338e040606d6aa9a0716b8c66e154cf986bdbff08a79ada1a27160e5873955141b42eff6a1ecc322833a1bc2437581995c0fe014b6eb25f9c575950465c9f9f503859b728628d2c197e43f7d4645177c30a06b1a8d506a631619c1e767ef5da6ea2533d7edae4ad3115555b02f8a7c8ef464e6b659528d8da8149bfefa6b9cb3596359163bfca15af05762154e61f6af3556b9be56f5fbb2182ff2586a9088576a0b8b5ee4eb91950ed9188f7ab438f9072576c2841b2245feb063426ee7a434b0f9f7e9f4699adeb606d75b31649eeaf4a031433390d590d8bdddee34727c43a15176e1633b126deca2f49c7bd658cd64ca8dafae5285afcb1b959ae71432db28d255b4c1b3e6cabf91721ab984a4d82ec969d1d0184d1e38cc638763b08ee5cfde696e73fc5ab5be56f7972001a3dec89c38dcb0e765b1b7ba13a2441705b4ba1aacc5edb67d62a5d8009f5c418581470367eff1cdb42708e7daf604e66b926d95a0c9841691a2781d483943b5f2d8b9d82da9952c9cadac9692a3d848867752632a16ece297125dc634e45f2149a12d7cf2a178bad014e19fe7889692a103bef903c2dd7cd1297cf95c2940a594aa6fa095cc3e32d246e653946d1bd4db14f7ab09a70e771bf70768537504c3d4cab0110ede7d2c072f176a14a034c9236aba562b1ee06464b2743229664f52329d9bba99b953ed28ef24902a611726348a13ba13449f06ccc6356cf5ba05661f366c46f15098143ea0b7690bacd7224929e5d235fd1e16b8176777901ea76d488b34f79624196e51a9768185866eb559a8d3bbc203c5bb4a14ff855d5bb446b23754023ce5f42632c5c643f13608fe97956e2122f505cbb03e0d4d6983ad16699eff0d5e53d3904fb97b9347b0d05b959450696def8a6e11e62a1b8773ac636637b3a6a2ceaa99d246889b853887e563c6dbca3d4932d2abf4a9bad393acc491817ea2f659410f14774f14edc14c7d7d9751ad70ca6e5fb74da9aba9d952c3fccc7b396379a67d10f0822190df9199670448bf0bc8edaa9d36de33c2c71c5acc118b1cdcdb02b05b602303eede9ed9e10b6f312641f06d983f60715b09a1166a66109bd458d135c11b1c8f83f1765a4c4f1d837779613367737edd4a73271c7e41ac690b3e48ea37680492130c84addbe3519616c54972c933cf878cc004553a7adac456e3f0c8ac202dc275d146345e1d9ae92293d3377594c38e2d69dd76f1de583dc61a225fba3f51ee948ea25f53969fac8e4f2dc1858271eba411593746f9ee9d3b0603902973c66527bdbf19945cd6ddbb10619633497a054f790c20e42c720a4317a4a4e241dce768677463cdf07e38378d2762d2687d6365136490591d9b00e3f9d4936ee1a456c5ae6c4c6e20736b5c172e6ca7ed69d564363fca5310b258c89ba80f1d8b1d68c8e37e275800406c18a311677978224b5ee71f33cc8757fe6cdf87b647515b493d10cf4466bca4874991e7df22092002e168498cd64aba42df73bb3981274221abeae1cb50af4fc07db1ac21c9c2f9902563e2050095779a10996b20b65664272ed7a6025984fdace0a62e249ffd505f42aef5bfa31ccfa8973c14920ec0c8e25175208f08759af95aabb96942f11660ceca296b392c24e487f11926d699bc2321ab24df048508a910207e5c6c8bb7d3f4475ac522a86000d870e76ad5939ad0a2ddac66597a00f5321f8efbd6015b23e5daab7c87ff81d037e4ab6d4c69eba0b7f298421fb00e97e8647ac96bc4f0fa72f23591fabc17af34953aecac2fdc22e22a60ef63efdf72d2ed50b61d0f3be20d4a923649679becdc30116063bab20e8d705979497f7e672d049318b0174dc0390bbd6908bf5fe35e568b87a4c46702aec0f6c1c51485af44e2f71bd5863282f229e3f0e5cc3a1e6016470629812b633bee2afb1e429a187acf1c949ce0003371321c1a4d054d0c3e37974e40705dc1b6e40b0fb1283624727316424438a39d3edd210c61d27d735bc6a1d9c1337a52a93f239f92ffafda669b5cc01bef8f245663c653bf12ca806a1d61f765078cc43fda809dd8311b91b4070acd950744f50a7a5aac91259a6f6d2a27cbfb9db029bbe67c7d664dee77243c79d2c4c277aab09133ce01b8ad1dd86f138c142226d3cfec73afd61d7a82011c72a64524379fb708b306635a095e9c677a07240f773a1275c9401fca1d37039194a6c1fde51fb1585f999cde6ab30087bc1db08fe5139fba96ef49bd8172f2cd03fa7ffd0020671693a05241a4827e9cdd26ebc99eaaf94c3f15195802909a11c3a0ebd074df7851eafbeea05c9f07aeded38e5f224cd1b8af810dee309c6e70bc7413242f487c6260576147e97f54eefbe76b78856fd38c1881c98687523d2720781c9cb2f029d3f81c96241bccf52105040ed457775cfc4f76fe8bf82693dc57402e9ed0358d7fc68491fc1b964f46a47deb8770ad5c7c900e7447ceec560a626ed07b1cd57bb84d748de5f06b2ec97a09a9721e3852d420a9b37e41ed03322b18f275c6bd1fe724fcbf48884f7c968152883b931721f641a4af4f3bdbc56c0c0628f1ff7128ae7bbabb29d1ba31af78fd7da42f6bdd33818ca5763b8feffdd13c98c3ed55e22ecbfa463e3b32ae3314cfc7452e27b7bf47d7baf35c52a69ded71847e70512f3458fedb0cf2f756a8e07026f40b70230927d8d6ed1f46cd545b1bdd76138e55b11fdcfca787f59ca68f5cf8fa53d82726fde53e6b99be0a1a8afceb4f23192070306a0e99d49167b4c24238c43de81e29fff102b35a956ecf0bd564aa96dff8e1cf3e8720b1e986fd3458440d496b02d348f187d02b10ca5456c64d7b484441bcf0844a464d5ad3e381bf74c72bd59cd39dda1ac534ef85745657a65cd557642203ec5f88c19ab1721c82e624cb3ad27e80bbb51a147f234e8cabc8fc05b2d06b522788992de7ab77366af3641cd07199a5138f33f37a8a568fdda199c24ae82f5848d861d6c24b08d79776f93c6189459cf8a4214b80c61a024aab9ee1121d8bb40c72848a00c43bfc13df186e48471dcd69fdbeef800ef3e9b0f934c2dbba52df1868198ea056dbc1fa74e9c1c99b39fb99861dbec2b8b397942ad8be0918eb2afec18d8f1d52af664e19712e963412598542c389dbbd2df7e43d6afa1b00ea157231b3c1cd86ca598935cd6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
