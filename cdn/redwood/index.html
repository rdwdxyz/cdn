<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95eeb524a5b6a617256f3343ce86fa1a32ed954b21835cc826d1c54bebb096cc493f3c37da43cb567b29563ddb42cce0e8ff0fdc7f34dba991210d73d9098a9d740b4e41d254864a416d90daeb4c4dd8b04baace9b07d6b76129c9669140d1025bc4255bbf8eb73a2c10c0c97c502b56a30eb7c7c48090679fb68ec22cd931f32ea04908bc1b97c29c79ef41238fda82de2066e92b3eb080825d48773f4518db8b91041b02372b1784ca27c6bec0b28617f14165de09d86bbbbfd8bc3196b2201f8fbc71b79947db39c38c80ea0cf254b713a30152633e81c27ae2b174cb009d7b8e82e48509bb903ce89ef4f6f80d301d5970ef8446f4e553259863afd8cbf4f09be14b8d63d4a007f9600dd1df1de768f49956047bc20d14ebae0796816c74564a0db0ac42e52e05db9db254800a2c704f2d7110a45757c0969fb897dcf32d8b2a3d14d7f5e339daf10735966672e25957d2a5907491491a8cf5eed469ec42bd5e4476449b96766877d445bf2d1c2ec365574291e73ef79f62de9886ec7ae8bac7160a0d1b9b8a46baf57ed6165534ee148c5f69feb48f398adbee38c837b4b06917c102b903c2838fc46444186221eb98e40608defb27232af186fd7c72d5c19b2ff468567693bb7266727c41c0bac04d67e189905a9eb703c529518867b50ce860afa22d47c57a04a19d7a455f375e118a3474fec6e3dc5ffb97f390a7cdf940f471731c751e55d97adcb601c4f18536a495d3559f22da51d09829c5f25616941fdeb06f801ef1d5ed43e1082453ad6d67ef35305950b36c7e6d4de7fcdc35d50a991763313856979ad2eced9182ec370d6f7f21529efcef9e1fceaabd4ba459b52acccd8e55c9980aaaed0deb1d0605004d4b4e3b8cd21f1849be0180227474e80932b9c7b5c3c631c8a0475312b9d16d8a8b2348e35b0dc5a8b1472e9a076bd712ecb2cff194db86f58b83517136542c6c1a707fafc36159771698f163aa4ff016b61413831e6a66e89f69b6a1a72ed38d65d24be5d16076aac12fbf1131e4a970a43fc7ad21cddc5e3d6c064dc6281f38317b12af15968621576bf0b7ee16a25e7e9bf6df2146b5774c12118ef95685a90fbd187da5cb280273b86d42df6c852a4e6a60a70b464a7a10dad353bef6d87397b1b239665a2a5783151544452ccc8721d753ccd5e3fcb0832109681fdb147e33cf6f1da7389119f0ee5fc443a2cce74d1469b83602ac771529c2b18784f541ab8801ac5a193ddca377a2b0a5f6a838342e54817dd95fb4965e7e745ed4a0ee9f98d1f3f4c24020082fc529592554e389e32f9c379ee6dde1758c9d61203689facc791b3daafb765fce6dc6841b085ec4065e7ceefeec41925d1be6a638e0883ede8a3c410dabbd3eac45325644ed674ca7b22a09c99d59e9df6f507c8c2a9150d7598d28a4789e918cad3bb104ae3b7a6de2bce5e4f0c63a788cd545e657d182d78e539f813fe71addff6c4fdb4499802023abd9c3c9b59e25daaef3767b70531fb2e184a5ab59f7620615c1decafcc7c8d7acd12cd8559694cea6754a164f30905a1dae2daf58e10ed7bb2ec003dcadc205f424dbc4b96a7bbe43a78da8663c56db4ad6ec846022a06676953beb7bd97e8905003f518f0d450814f882b6260e2d14c38cf1b3729707e9eb5ba25df665e7d2300a010b24f204221f5970d2c4edc07d74adf1e559a6bc6b882f297d15e10c753bed8f6070e6e6dfe8489f5b17924b661b14c0e917363b39c5d94059276c5a5947053dc0cd2ec6b21590449ec7ef47af7818723d9a141580e6558a1018d84c9bd147dc7648e4d35925f2559cc1e38eb07a7eb048440023a9a28ba162cb992df0506818884bd0c6d961922a0e61f1766b5ff17c3abc7a6d6e9dcc1941297950de1c5dc6e537f72cfe0c7556cf5617abbb72fbd61f97acdfa7fd3e4a1156c4ce9cccc020d46c3c48a0ae4ed914d57f07c9ca1508b699ece282a65e2b7df9ce44e712f9a1df67c3f65e0a090d191963327724bf623b9d2489fb434904a5305ccffce686864a1b01ec4ca73d143161b86c137470f7441e422964200e2ff6b18c3fa2b736beedc339953c0563f25b5a870126c94042700db3a69479423840029cbc8976b4941e7f54d94792af97decb154af062bcff49d2367c269cc979972e6598850b7302e2eb90f076e58de0d3154b90c48c3423361bb16d34a14b42ae4f01c255b9fcae6f34669ad020374351f28ea4485663786a54ff5c6b839da6b4de00d555a44e2b02ea3fac80e4a3f455c1e429765ad08604db6f1e6363cafd799895c344391b1a8032511cad11900bc8d470ffa535911789dbca0f810d96c53701a2856417300cada16edc248fa0d6f97b765fcb37613d14ce92221dc985eec6780fed6ec4bfe235880cb3c9ec98a4dbeb516353cfa7a245003a8b697d3542852ad13a01813b57648a3c25cfe29f037e9b028f00806a3216c9578795f5b438d3ef07c456690f35e77b56981ab0a1968e5ccad6f31047dc49907992fabe1327c6d03b7d375e297bf6dc2b524d960723f2ec352443f29c511fff4d8523baacd95d7ba84af71c7155a6de9291d551241b0b47c4034172c46a55b30ecf77b48901321cc00125ef8ad98292d22b2f72af39680ca42879a02a9fe9e2c22c00ac644b3fdae5b4c06bdb1be4a0f46ff761fdbc0307c1d98ef93253bd996a861a70029ff581811c7aa0c28b2cb6a60ff6d0f5048353e27502ee46156275ba561289d2c78a1d65dfe15a267b34baca6e029940b49063e91c8dbb41b6b4f020e274ea594e295b2b6ba48546221e42eb3f1e7f03d178074f98beaff35a391eb7fab12e2dffe3d8679b62f3400b8cb8109b367715cf10451dba6c9b0469d6c7c9614e381ff6e404cc56f6d93352a3497ca17b375d43ff6497f16eb4c315ded367ba6af25d36195e1fd8148ab898380dbf3bcfafece348ed1b9a3d63f234159074b14c5984447ef5eb07265a2c4d804ef4ea767d8abed4fc8f459ddd00eb9b9ea399be3bbc2d1a6a7696b8d102107d7d61f072586e53ae9f86605c2c2f1a94bc57df735ac40b54026e03c05f32043d7e19d748f1c95ba1c9b6b65842dbe7e31434645c749b1a8418b6eca17699ecbda10b5e352f34b5d70d608bd215266ddedbc0847ba07486c355d198079c487219796434a7392bb50326a339f05f4ac12bc04ea6f01195e5716b996de2779a657ea26d0094ebf7c893b27ef38cda83705baf6f03fb421e15554dd93232f92e58307094da825e653b071cac003ade9b24d8427daf77f3c0f79086d3abdc13c0e8a250ac22084562de90aa0b3a0cdc74e02e377ebcbcd20259af0f983d8a9f8dbb3c3367028e7d2c6bc3f0b1457549f7db030707133fc47947767cde68968d7f010d82c3e40477d12260aea09f3132ff3c8ea14dba9363c4d536cc815a7029d78b76aaf0bf25f13b2ec4f8d495deeef57243e8c3277ead49e2426566ca87ac6bc6c986d8b6a47361a734b1dc2c490edb1e3f21a9c83d91ef8ef107a216e288999c68c5a0965cc915a2af6132e7e8acf30f89c7ca458c14d72489f071aab235a905fee0595ff1f5a7cda780f22972d68e16cedfdd3a456a73050cd422472cecfa1d9de105ab7107a73d16fa6668bfe8350499cf41af7862e2410507482dee48418d890a2aba68c02a27869504c7edc269fb1b32bd3764c492694d7d96b80e1615cb9e49f29358d282934b1251209afd53aa23d3cf1d431fc80d29b0b55929905f87863a95722735adb6fabd6a61b810ec74ddb989d4b2b05606c96334e6e416e5ca8fda6d3131d4658a22628b082c4406d1967e9cdd566545348e709f82b62973f19c8fb16d0a43d93c6901769d404f53d7ac00e5cc7e5a5a4650e1320f81cf0dda67fa50176f7a4f4e62e2b64cbe9d3ba4f05a8d8d3f04c1f9a8d03da5e7e6d873390a43832fae2d4c2d6f2c241dd8e2675c7941b9d57129b2f7173e5cc68e685c8bf30a930167b3089b4c7336e35b9ac61ea701e9aa128246ecea629f6eb036b45ae42cb1163e8a7ed91576b68669a76f9e53eff218af9e9d4ece2eed9066ed12c3d556a3615995eb08d3e219ddb6103715bf5ea045a6271240dccad1d3c2dc5499d70f618dc3e5415c544d4df3e907d046fc3d8231d4a478b503859ddff19205f611c7d5518e64448005716857dffc38ba95206d2aa929b7e423feeb3ba075939632f2821b3606243164708b7dd10302f167fe78b95683e62cc7ef99661290bba207f3c3877bad9b4c4db50cc51c102d147503825c618276182bbd83757b78c6b26119a666a225833f99706a53f1b4e7e46ac1759055999ddc106c40277760045522dc36682ce59d3530cf5873824b55b9c72afdc59747edab5c658e4af35d0fa47758fa229c3a0cd1db9ac6ef368e141f08e55ecc98c1e3bb4d2583a089656c86f4ed18e00a9a3a97f8e7188a67f7ebf03da81872f209294e5a1faf24cbb57ac5a6d29fe07f3fb7c804b2e4407df1d36164587e461e13fde75c252662f754374fbac1f7abe7ec2c6a6ee1d3a11bf217a23d73946ee76e2aa3e873e703956c9ef06886b611c45299ae408c0623b53089b0ea1dee7e3ae06da478b338768f54738b0eedcfd5201afbccde06fff9aba014d921808f7dc7b979cc3e3f4b8d77a1181e46134d5d487baf9e15ac2d5535e5513e91e714a736bd29646ce9d663159297a1e8cb0de62deffe40ec60ba91f1f07036360806bfcaa515713a2ddc10faafe3fc7ac72cf8ed3eba76b7e8fdb5d1026ce12c6d82b41caaf240488896b50e8f7389397e736186c7161d9e2f3d38d09c6a892d7ee3a2acbe96eb6fc0807802876de4ba093bd55bff7a25f9e2b4cb9d6c8f129bf48f8c8d49abb3db036091e06f3e513f5550ceb4f2327f042b0b04b023cc12faa0aa4b0763146e86d5e37b1752a113b497b0a54b1721494356eb102ae5b5618836a265b243c2af9c354f4b5e9b0197d7c2eeded63de841c9c2de59b13ab77171d7f1d42ee56bcf1d6b9fc61045db425731a0d20fa433f937de0ea5e457e8181d8a8bcee14f74cb0e46a092276ecc8b9495563e801af7e6c16042a989f15db90d2bfdab350e4974e3c85d5b5b921c7ac900c79a51142b9d6b5a1e239e32919f9b5c6e672f5d32bc629eb345895a9e5979d16d5bc0bb00a8eed605ff894e0f1ea13a4e5757b0f81c964a9fddf2e33fafa028cbeff7f042561d410881511eb454ed00c585249a57fb700e3ad9c10d9655a1d6bcb0681a659f7e96c25c920880a035bf42ba572775ed0b3732b222ba5b22997a05822163dca6c0dd6bf6adb26b0b13c03225976201424404c68ee551bb6adff3edafccfb8920a707e59f5e79101f64585ec24391a2d8d6666390c712cd3b98df4c3a045478fbc5bf901ff4b7f60a07e163cad6e8cfc042644b011f6009cec9879ae78b981744f4f29488d7bf4887c95510dfb78ed19360daa67017a3a3b703800ba72b1ea4f8908573bcb2ad18e3b6435bd6c9e45952deace97a262e4d371de5b47d83f94170b4c456b131705bb648e27ab8e29bf7315ff181e9bb5cf670ebd28e846dbbf0c3b4f02571afb37c62040ac29fa12afab2ea0abe25402fb25e8d875a9305d8033c4465d231e6909f438337b1e0e8ccfd89c26c92a7c62d95d67ee5a0b37b1dc6e25567c8387bcb6d03bf63575f6428631be083cf03287d2dc7b33c7daf66457b05cdc002801dd2ceb83f9653e5db7827f0ca4bf0c0c381d3d470c01252c959fb6a5e54da7b7d95ce4afb4cca492e05e28ab3d894816bf99c983eb54568e519fe44d409706459b638406aa32cadea3e999ef1e9855a7eecdae075bb41d5aaa3f26d16c679a4ecbf117f5b27efd9e885da9bb092a8a1facaddf8d43a1ca807dd01941ac0f61ed80862cf4137cf28501ab516dcc3dedf5801e1be922b12c6638dbc4a8f17a40b11a0841b293465e9d2ca4abff469da43299507d362914cf80b679933b54006be804ba36c69c358e634aac4b22dc76a20dc4b1d0e0f9c0b550808c9d827d756ceb2846cfc7218057d2f8433fc556a63eb35d5e167ee59d05d9888e5cb06d4e4e7ee9928873bacce17b0fb41f071ef80d064e27c7491a763bef9e98a1e01ebe104004da25289f013c0169034c438ce62bc6d8eae1ee53f1cd7054aa857188b28a0198527759f63c2eb62ab41e9d8cda17d69ba756fe09234357b6749dd30646acb9ab1156a43fd074933e50a1f4ac4542326aff6048a89471386c0786992678ce3ead4e48bb2242b60279a7e0fff338e8a0bd5815c6b381d6dbe52e9aefd4651fb7b72386a293415e92dea61cde0f8cd1f9fe126685ab3f4682f12ca467cb87c3429807137e232e0b685d2162cc9f15dc684e1b92f85b18f6d38abd29b7d3ec89169dac8915d0ed57957e67c075e6124cd28a612d8e46b187ec34537512423ef2eb0d17249743cb8ccf2f70160b4e0e6955fc3e92a79459fc4b0b5dee0ebf5a1799b262f21a48379b91b78a690b176034ab3ad8dd6fa99e5287fcda5633dac462706bc28e3e3cd30a04b5da866125f1bc71e55114b46c5bee8dc42921f5d4f7e403a874d519929900cd9aa5fca162dfc08a208276303a1b4b8b6f449a52c840b0551b9eb5bc6c5ad921ba13c5c3cb1e7a7733f76d31687ab29ee5cd9162b9a57c9a0382e5ab34fb0b9843fb06a522fa56cf94d1146e5f72a0f1e1929b349715ad31ab4ad2379e4a11d0acebe5e01cfa1d05a1a390bc80c1457132ad61ca4472dd4c96fd692f42ddc7e43519e2687de25b6dffd64a2291ce16febdc07fe8989fe0d8d57f0f52d8ebda4eeb055c78bffa70dfdca19c1d7cd1c5ad54d702c77dc98b37570ab64ccbfd02b0470f5ece3f1105a084907a7005477e8fa39aa9183039901a7b9217c415175976a75585c2bb994b79346a240206029839ec91d5d9b879096db192cc182dd743dd8799b2ee9b044896c1b5c8838c5e8dfe84e0ba1c432d7c5f0e2dc462ea5c17ebd028f8b3b4406d7d4ae5f338b209254af1bd0399f83af0a6490f08273aeec95288c267614bd6bea2000c7303d2f5d7d74afb06786f44b3b6e80de03b64511fb3b04320a94ba087a6442ea6a577e51b3b59547a998608db347a3d6c0989d181ada47bcd3f757915cbd10171ef0a124cfb8ef5860e339e6d9a40892fe4d9175d1dc8158bf9610b60f61fc7565f322cf45d07d4c77b179d21551370342ad99eb5430f403d5099016de155ab3a29295c1a25020bc6c961a3696c4a653723019ef884511b235eb5bf4deb90ae239a5d0de335e780f14d7585922b88ed6af38529de876bbff6f162aceb65ca41ffe74e7e789fa972193ed52faa8f3644b782ea38b994dd26488804e51e7eea3b0c095b2983c41b901413d698eb93127962f43ce2e601291f246181d192891bc85659a1ff678046c884db88f9bba332d30e10e4bd95d11bd6b8a2b329e0f5dc8f4d55419659ba335e6f858cad62c9e0fc7aac8d2313838dc13bee0bfd663294e095429c530a1d156da9261f51a9914b951bd306e6d02b21b528d77de7f8c413a12028383b5cd3b16aff945453d300b14ddbc7012b0a248783936522cac3d05eb13352bc7533e9f813d720aa6c76bacc26018f99c6dc7194342c156a24e3c4c237dcb2c97796dca370057c50f11fa5d64178d199eb206632e520e08aa5e9e320187317cf79b7c13b0a4ab91fbd77f6892c37ca75556cf8aff275ac321c316c2f64493f329cd44d4123420c3f0bc93e6dc32b492ef73f47f6ccf3f0b7090abf19be0bf3ace896d523a43e9f7b5ab5d8b92b2cdd7db039bd49b7cc369f71b32a3c63175389d685b0f6ba6afa303c4a748fb7a073400c24fad21ddb845abe6501f8f03551585bccb2f3050031413f8f5c1935cbcb4486c84576cb2bde2374df6e68b2164d439ee602a4a98ad61f78e2f1aad681d5e909f3f2120751054cfee60cb4cc7a086dbd4e3a46e96adcf4c607e3ed6ba111c911e34f17f5e9d3f6bfb2e538881df87fc248e914791f2782643eb08144b45e275a48e36eb90874f35a2f7158883aea4f33452f6892aa4c35241769684b6e81517bcde96db2ca48b4a18fdf4d049ea07d29ba8acbdb39e727c47413d7f24554f6d4f77f27d59da882459413f3b9ce597700e4618c57fc671dae34b4542098f97a48f67611f7f977857e4f0b04d539b7b63fb39c41ef435fefcffb137891547c3b4713b00ba9e3a36475f21696bca9f91db7aa6b9711a216982fa4832decf7c5863ad6ceb89c439d775e357f2ef8661f34a774008d0f16bbf4a6d6a8dfed2634d6ac26b4e739e2e72ffac6d731709b3786846d4bc4d22913506fdddba82b543b1d5393d63ed85479ed8edc1858133a92736d904b6dc8781107ff5232c9b61906c5f1e55db029204146abeed2c3fe1a64fa06709c5862df541185373e940722944478000a675aaf7cf945278f2d88fbe8c0f325a00f0a06125500fbdb997f5283572a0cb6a04088fb22f9e38b883b9047f80a0cc817fba6f49cd13aaf38a2ae4763c5c7548caa0da308d496f2bc42472847398185c9f5cdb37c93bf7156c18720a36781a8464d18a602621325856440aa6c8732978bfac45023c7e776a8879c5574229286f924b7504599ab36ec4aa8dc923bb539c830630499ce9a6648c30099ee2397df589adc3cdef87c3cafec235686499b594b96c961eb08b8f485baa64ca3eb23e3612f07fd551c301ee46827d8610136e61f9806a0a1870b1cb63ef3d4f23b0d7c0a3c492a400f1d418f600ced57fc5c214fd4d99795b80cba72d9bb1b9d4a1fa17b8991816f5f2d1ceafbdb870ac2d56afd87ffb9fe89e5e88161e3b35ad6236e1224814c81f44de22735895c77b02b6628efd576778f5c8a99eeb9958d5d42155b4fce0233994c4da43028ea285d2a4c10266db28af1770f2876a1661c0298fe3b2f6561bffaaee802c07c13f1ce8fface66e38677cb6ec563c524442df4fd46836ba7c0bf8f612b02ab8dd67ed4f76247d9e398f424603b9b9feccbb5ed9cc856ac2cd5e4a5c451ed80d8d30a19415bdb53eed790c1c0a5361835145442594a26359cdb1beb6ceb15cf55e28b847d7180d1536c75c19353354c6806302c363507bc6842b05b25d2cdf00190d581832a07d88a964e85c7b172f764d32872684beb9eb7d98a70bc14d4773f9e61921ac9bb20c50e894a4ba2783f47c599d1211d6751e64996438825f9f3fd58e9026d99d554e5038bcb4c80043d8639d9312d1f1eb42232e1a6d7e08a84468a8f9fe2f9dda54206bbec59aa7883f7577ad3e2b8bbcd1f41cf359a9b80bf0be7abdb11eae943598f47921b235cb7feb2e9b2322877525bf9d001524af9ce5133185d8b42ba0a4bc7dc222c688265ce5825fd69344af00385fff9e57ac51fd46c437aac4f618d700c572c306c1e95a18a08b2adeea490d0de8da7e1672f07598ce5d762ffb9a2b42559c5d68f45e25f54d5a79395c23365dae898ada1f6fc0f4fa938a875434723f9a63216fb05f77c1799772e78ef13a9614a5bfcc8b7bb33257818645574118c7705163cebf8fa9f7b4dbdddca033e85fde0b1900a49ce15a4ace407ca1cdc40a708e34aad1038b7f97b587f4aff064c9debd17386f5132232c9400803edee67c03a34c4e96b1c914d7429154cc297c98770fbed19b2b6a8f010a404e6cf5f435bedc7aee6bd2a10505ef7cc399ffb806b9f42aff4b11d2c7ad143646438e4e36b58f9f5322ab4020904bde21a08186db5fe11845ec04ee993c04a654b60401633017f77816fda7496ed8399066dea020138c8969a5d567970415c3bd0ca8ab20dfd3dcefba5ebb03cc10c21d14648d8d4d3b217a0876ea2272a9eb4bb2c3278826812a15c9850b8e7b985754371b4ae18b71356895a34a690c2c508652fec97c162c032caa6ae1ec4011c9dd7aad556f9ec41a11b5c6665746cae8b7533cf0133be5de9ad6e5ffac91e68f668e8719f326291b2cac2686a79022e1e84e79b43954385cb5087bb098c68a6fe0c50982d6cc9090e77aeddf7e6254b38fb7148d99b19a31a0adbe32631af1899894982f9ecddbae0dedd0ea204200bd6bafb66b6b8ac5f87942604bb6159d8515966786832a0cb13a870f3b99a672f6b5f6ef7343a7bb7535272159fdb20c9b75da5fabb8fed7a07f2a75d77f66038d4ad08a5c4bc19c73d5319b95f49ff5c0f9646496bcd242c2e0d9e752802227e375a9799ff7dfbff8db6456ad8a592eadc579ab017764ddb71737403d3a9457fb5f7bce8cfbaffce6ef33762ef082e8bd95b6fade766ab51921018797497642a59bca9743a238cf41a4517adc255b219dfbd4617321d410f1826672ccd88d31ca343710e5829c29e916c2ace31712f92b7a0c50a27077d94dd2dfbd20dbe2252e01896618f56eeb7cdb98f9b61dadd41ed455ce8abda0c4ce7cd26a15bfdb14bff27dddf7acd2031307ae0e3d6bca9590104ead95cf6cdf1479ead6f9dc9646f480ad00d67410bd5b7739a145112772b9326617a63219024543a95e8113f0f54c1630058711cc6af744811a3df0be67c245e3e76899dd6b0103d9eb047b8d086217279b7b6270014951bf522afab7f70ef5788a43ad3bb4df28cb781185fb5c1cad70a9bccbb55ad845c45f59f0d89c1446658e3375b7a45ef0c604cdbafcb28adfd294adb14d296540d854ab7ea83dc716fbc096a7ad15b1662cb903c15df4acb4606fc217b1f637049adeab4b3ebb48402f7bbcb293b7994ca2847cd0734ccc4ab1823cf984f9bef128fb1553f7fcb03246cb46db153d5e88f7a0c4e636016333fa584b63e9c3ae8d6c73daa68dd8b28cdf9547faef8929bc910a21b086dfa44e7b8dfce3db70fd2543e5fad64ec39963683970a5a0592989840546a7411522aecdf51991bed107ce2115e504300c2076693b855b824fccac81960151bfbec90ba75e594b21266a0886a5afe2ccf49d6750410d2dfd2bc34e400c5a0673a39cb7a811303b910dcd1038653850aefa5c7a68d07aaddbddc0aba6db51df1291f3c414e1b55f9eb3f90aa75e13d425d7cfa1ae44accabed26f3c09281d950114bfab26bb3c013e1ffb6a9580ab33218a843be98f895980f8c3bd6dc08773e3673acd0a7a28469233c853697813cf59d7f6bea60bc77e23656880eac4d822083e264c9fcda74f6cdf2394c69eb8bf1c428667e82f7e2656e6e282f2de9210800f26e7d4a9f9a64c0a74c729d4691818851a4c1341c15736efbc8b83cb6df18d9c19eb3863b3ce228a71a1bb695dc69ddbe3be27d38880f576fd7850ae4853b02b0841c60e6db9e9e2bbba5dca0cbc894c2663f39ec31169abce20b2fb04e9dd62cec5338f82c7d5bd6f4412ffce90fbfaaa8763c92566d68f5ec70891373f22ce1023f6f5fbb4767019b9177bc42fa0d8464afc191e591a3677e830d5e711f41e0edf88dab273b95e244f1d1484e48c452e411de38f0cd56a672d3ffef27a602d15b23fb847a3614c6a11cbf4895e9ea08c92db8b3f173dfd0a6b18840e6bb30e8c41006278f2af90f8d5c2932f1be0e4bd19c237457741e312ac7277ebfd55ac394a4ec9eae68dcb040462ce68d46854bcbc8d62a376f08dc3e6cf95bd07b72e3a9f7cac0df517dd8b0ed47ff6d9429b078a3efa330bdc1b8e5779b9f2f20de29e62b911c3a0e5e839529fdcbbd9010145d1e08d1f4861229c12082c444f081bc12de3abd1a16b89363d97d5707d048c367c3798284a10da6bc95b1c4d7abf9c49a7a0675660dd659e8bcafc5a96dfb151cedcf715967c1a9dac1016b079bdbb0fe28a7e60bab5ba39f06b4258c53003fc5bd9b9a61ee68d2807a407377a440e9caffb6fdffaf8258d6f0a2490766a567bf705e42d81512050ac19f40135a465843e4eb3bcbe0177ae9ac9ca17fadf44f01bb6f8bc5c2e06970404c98bd530c16bd9d6f5a81064b6034015baf3b54071e484ee338afb9bf0aae0a4b6043992bdd24e08f03f1b37d8129908717a2a1b8371704f32b28c84ea8c6e87e135b7fec837d4cd2129e9e45548127aecc54e30a547a8add7d2814fe7662f329f0830de441071b0e39d17fcae7f8fdc4bb6731ff2aa0c3d4bd7c5abe934b726df039795c29ecc498275fe97aa33ca58efd131e71d767fd223bcaaa8714fac48524756f0fa91e0fdbd91a1a0d299af0fa6f84564bbdbbbfdce4bdf0ebbdd87461779a0356f286e8301da3a3b2907932630a17f6ead976e86fcfc505ffc001f5b2109621a9deddd3fb7ab41a380fab3f56b0525e9e1bb8fa881f34495e3e8802976f15139efd077931ea71f9b3b15686adc6a76c7efefaf651af5a3e675a9140e73ef2e7dbef6788095e82300b2d56dba859745aaf4151ca850e1d5b95e8334479fa2211dee838fdcacc1a7c98620e746aad89f96c7a3bc8d65f703f3c9468fa0871d12575fb04bfd2a7f856e6907c7cf109aceda29f40407c8009d537a92f166326dc86c7ac1f78db2de285b5173bddeab8d76464a9da73c51d3a08b390276e3e3fdfc0bcf124cb5a6843223ca3b2bb4c8f8e537555bd4059a1530538187dee7636aa7347d3f773c10f7bd25a7fe01e36940989c9d584c2dd9a5b51a8df8a0df94a16ba68dc29728beb5dd9591331a4421d20fdaf6b08fb488ca595512ec6f6eee36186ad2d8fc39da041a1359dd5805a5b18b74ccb778dd6fbe2948fd399970e1f03a82feb283fc7fa29bff834d290d2e530d52e2c642cdc8077840eddd9d2842286c2d2f3a356ef638ab8ee5444175ca2f2b785f2f6b47e96f0bc9fef799aa6e5d49c8d0105daa273b61858bad4d200b0f2516a0611c88e30a482b776c3d9468976791e0562b9eba8b828ded8c451097302faf0534b9e14c49ed40b8afc9c48dda4e5a692b2b2ad2b7bc59c800565f77dcba6003de0f2581281daaeba039a0c502f0ba2e6fece04125907c8f4b668d75985332c130045497022f3a3915755d9fcae3ca5f4d591ce03b6d70dd8a55a794a1925f55a24d0cafa0efd997023cea7435d04eac1c3d3ffd7cf3880e3bd7162fbefc99aeab3d99991e30a66689a1d1abae8d937873076fadb518e2cdfdb438bae146318a5abb1c51179c85d922f9dee2cfc12c92ac8c6d40b131ac4450f44ed0ae33bb616ab16c9bbf99fa3a647d1953d4ee905c83bbcea1d7bddcea298b801ad6b729ee7ece545905bf77c8d173ca9a8b492c7736279f68b9956d1215b921d155969a228cf12ec7f85eb9fbd3785645ca925590227546d57752468acc7e217efa3a5474e9750193541611139e9eed2fb7b11c700935b4eb6ee97ea693446e292c4bd9fa20162074730cd7d72e185c4c6fac21088ed9c9d089afe47ccba1d6af0bf25461bfef01fdecf7da9a13bf4eeb2a2814dc05887fdac65cf80b4e99dd98992a75bfe51ecad67a93074edf1b32680521d0a3e8e4ad972f11be70cf79e951d8f62b89f6b6c0c45adc9f73ce5ccaca365dde18dcd6c6d49fdbf98f66034f2d38923bbef2335c327b5ad19118f572c48b5caa2007da3c9d713c7fd8cd88a7a507fbbb18af808bf07a9b5bc58f37a752ebf586a8d39be637e9b7c4a445184586f3ec50beeb54b02ede14737cbe920f1222a983c2f8b97460dbbf6276b219964883cadcc1f6c23138f43639484d8286a949bf0d4dad52a16f5c096fe4358e9aab89c7440e027a2d3763d57ab0e4b767dd0bd11d1d2634275f3bb8ebc38dc61e8f631aabb8db4362812bbe1828de104ea1df477a24d2c0520c21d4bba9a1c25f287310631da49a1c547fde9fa372e028f1e89e72f09c1e61c8a79072cdd70e79695cfbed853a16bf2f49155af5b06f79181fe1f534c033e4c78f26b1b5361ee81cfc0bd3523038fc0f961d9b3b62fdf89b03898a72d83220bf6bd8b2a3469da3acfc4a5f9ef8be1a056c184a58e5a9db5e00eb28301256a40b18bc3e88491dd56305b4723c6af83c5f95ca5a682a1ca6f46a67828e74c3a605fa8fb52a4f8de4ec1b539fcef129612a76f9e29d6a64a02c6655844fc79963928ca40f343d93c2cd7d2b00fc6ea4304de0a45a82bd04bab3acb27c75c476a29d28d9cba015da95ffdb3c8e64cabfd009a2070f944ddbbae324497a8e25c364dfdd1189567a9f26ea81147170dcf3602c5d6491a665c5ca6ceddb23e9b8c1b29fa83655efa4249c0cfaf92dde34d2c6a0a4b332036835b0d71dd845b87d0235d0edf98d4a581ed95fcd1d32f90f0a4dd3368a16f8f63dfbbab31aea54e4b1eb5ab796c083f65d8fb55fbd3de280e70e6ac12d4e0fb041955dab31c67ffec887d58451b6b11a0f157ff493a56a21967c1b4b314e11887a80975f4ed6025ec7a091d982be4acdb34294e5dafcbf2beed64912301d3e286da53eabc1c21bde261e32b823afba246f32f11ae59879f209e10e10ea03b25435aca9a2b0f46a01c687e6bc3af82945bc2ac435b35723286a9b4700b1ff36e439b084c60a8cfe31b9c30660a61953f84b6a3b41af7c788478f306d98a5f97352dbef0947663671a1f8385e1cec1bc0d50389e521aeb2e8e2a5f8ff836a4bce2a3305edb61ab2c4647562f94dce08d148b064ba16f45b7743d010bf1f2a5863ca1c1d0b330b947b6156981726d703b16d6733d889ec1619acc3d34b5aa66c5e557990f1e59959736fe84952738f9d7b154f861d8356a24f4a28bafd5c3d2208f64af412635e0ecabc3749e997b778872ad1ee94a1a7aa119ca171b4aab4bafe4372174033d47bcc15b407785e3bf6e71a9b8795bb37a636b7cb1d61b17c532c5b3380e3dad95e08e4665ea5c3428f8885bd8f2ad1d622ea4704d45b8ae416172cdefe8978cbae2044cd198d46088c1c338ba58a63cd713a10d14aed61381628619a164e8d95b1ffade6942fdd141cd1e98609342cfcb5c23c00c2371e684f164f9ff7a5f0ce7557e20326d69694d11861611e0805e48a6a730bfa70847f845913a8fbac60aaab2435db9676d7702f3a70d2b47e62cf2130617a05e115c0ebe0f4eec51781878e579547438a269c06990444e770927a10d4ee02d22dfae7aafd48e67220fb33c2da245786ea9ac19f9620382a3f5e63a9fcfd019f1f2f40c86e363be900c0d59a0ac07bad72011857ed094ed1d433ba65484a5bf5510642657686060df4ecb92d9149bf64ad9c0fd79a537b2adbaf02c0f02aed4519f9b0161e61cd3eae67eba6a876724af0fb1449fa8df8d10c36d507ac3e1e38741643d4cb027b909f607cee89256f93eaae050b13351db89f35b7f4e948f3c53ed9a9c6741875647d02ce686541acf12fe1a8648ce74370d424cbbe16876235530bf59a94c55ccf5d9994cd44b8d18413ce0d9f0be0c3f3a2097c36c52b97607ab3d509ae64dd5f8090ca6e1b791ee92517b37f4b042e78e8f60460da089debea9a5b8547f2386827b5b2dcba79b0a752b5f5627b9d842cae8c7206df666b9bf6b8b5e10e2cda7707e523d9fcd9e3ab7d3d1ef921a8f1c56385aa636e55e4145dedac223678cda6da4f5c6531b7f882eb660b250abdf543f7d1dcd0aaff205711705792be83b1f4c2bf5f88747d637e7d1794831e37ff243f7ad5d9b01a9a02d78aace07f282c618a9fdf29ab830b8f1f75aebde8a4272149c0b0ae8673b556b4cb07de24c57ba4b64d2b6267543eb87df0cbe4b75db6db138c85478b2757fdf7889cdbb7359bce3d053a7bd0d9f1637cf972bb39bee1811e8eb704c725be0e1166d11c7ef850248ed7350e1dfed2c8eedd5ad560750e4308ab2579b18d3ac1d37ba4f8d28425a97b3276d992e51e4fd3a9244e1d85e2cfb5d0de80ab0868159457add4d4cd61c03836854a9b2b58315c8739f06da83cfc797687b1c813d442409ce2270446f23451ff5fd0eef6bf4f7e4f3db3d5b354c55f8488ca5ae3ab4cbc60c1cf76303f95a35c0d080531ddd48475d130f962bd09e2bd21388fa95c75306301d29eef924173be528767d30e5ee29ceb040c847d7a51057ff230bfbc537d2ba8fa4bea5a04f1736cb0165df66c980ac05de8336de29feb0f5b1f1431038e76f3f521f5af6d5904b7e2b004003459778fd215607518d2f5f8eb49f3627f64179ddbc70a94aa016b80c9bb8461e685ac8d6ded236dedabdcfbf7c1c8b9c1e44a0c91fdad3c41a69ad7d8999379191dab446b5bd36f86ce20cbe701886e1e8fcca819633a5d379f953dd1b97174cd66eae76063cccabdce9803ef006d72d2eae14bf73068bb4e65688e67ff5b0cad468fb17f4bf42e72e6759fe97dd76eadd3c957c5330a95809918e6f2d69aad1436d1aa8cbfc72e3e7bbc502caf25876d33c795c75bd8961f99a62cc8e750b46fa351e3d3e5b25f0b1145245c3edce3646b9aa09c26509e74be7ebed1c4279ede97960915d9ec6b5abecf7c9dcc04c2a52c72a259aa8791dfeeaff43c7a44d6b2521d3b677fbc681ab8b36750cb4d2fcb10418db7a16928f793bb0baf4646d2b083ee0d59377382b551bd7dac90b82f4df2fb04dde9ffb64d1dbe8051a433ea79c82a654b6de60db14cd51c65ee5f61035f1ddf9defae54b68603503bad24277e59393c08d3c5f85e3ca07db77fd399b2f0a156dba11d5a4a0e6b2a2b4e932862e4a34d59860618f9347bed2227bcb28856437c725329eccb18e5f66f07392567beb8de2b44b995f1953f7be5ba22fe4ef2ed1a92276f19f60c0c69c3f4992f746e355a89ed0ee1e2701d2632584af07d576a84a7fa4a5aa4d02603ad1ea2670b722535af1c5759ed336fc5e3c762d7b16c28eb2d314df42a45c57f94541764d7813bc352f90ae9d8c49217f526ea40fa2cc91bbd3b860114c2efc87fd6e8dcabb6b834fb3fa40be4da9e3ed33eaa5feff81cd0e1b1acbb1a8f229740cf67904acd7dcf69968dd9bae4163105f9fc80929a5d7750b7f9675e4860dfb2c08b6989680ba2ec1c79822a5b60dbd0109c44b242d756afa06a200062c568240840112e91ed2f9c513ea1d88fad89f358eaf82bb8e38570337629728278f9d3bf74508d35938ee6d62009d91ea9e493243c5b08d3dc6bc8ed20eca152e05084ae39ef196d298b80241e3474d0ba95da66a9edd01ff3e8865db6fe2db82a1a671bc7073975b3ee690c7e58c36071d55c91fa06feb92f25b073f27b08169f7ab7185a0df4d871aabc7f9cd65e95ffecafc27221a3b7ffd61cd1e7a38016269b747e25dc184cba33cecd943acb8e7153c9d1794b2a389d6008c15aba02c00b48bd6e69fdbaf12e8bc135241d14f81ff2025cbb531981e73ddb3aaba8fe1ede7ef5cff928af05d89c9894edbbf1d13a6d0e44fba8eb49d3ef30cd498298d2be06f0378b75520c059da488fc18e51b96fb94d79bd868b8eb991b49f1ce104c84c338c0a08355bfaee06046c2887039fb603014145220665d32fe928fa41a76b3a085b5cfc8e4bc2031051fddaa7efdf34457f2a515fd7d3c9ecbc19a90d015dde86f955b5752d517329ea0364fbc72e3ec216467f9b9f613c3a6590ea44639fd1654d1688fabdb51cccac2276e30013a043a0f99768daa5c8f12dd858eb1a706d3d46b5187a1569a5694a5081bffa6917e4faacfe3cbfeb36af20cd957e13dc04f2446861213e6b6fed8cf315055763f6c1a8c37bc10eb6593f3e548a01f7fd7817a9298320fce66b0db1ea92142e6bf9be3f3464430123c1fee7292e0257d44a4bf4d100234c0a032bcbdf0d18d00247211862eb89274fd6ffb6f7f2b7fdd53ef67b4445e6d907d7d8cb820da716cfaa0a2273bf2e7a4970178d518b05490af8264ffdcd285aa7142e5a51195a3931de7eda577b49c8cde5008929df873189d67a2fb244135a7de0039b706629871708339adb3aca179df1b3ac64032779d0a8bc4e91836e7375ad0f4515fcaa28b2b7c64059342e98c3bad520989c0665d3ba35293ed4446b497898a3bf0423317b1484038c29e223e445a954271d5ecc292c2636c23892e9dcf4c707bb5d8f16854033e62c1a5c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
