<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c1503b5b17b23feccc2255ad47799652529468584fd75797dd3369fcb88dab2589f391e8f15152cc0014b0f53e62cfa2f2cf8f278d65b3fc940c56e833db5c7e9660bcc4efcfd71b5195c0157a2057dfeac827ccf3fc770038c88d7d0720b84e78ab7773f3ac01a5d186dcd9176d0537027a769866af87d545d23309c2519808ae2749be8dd38348f132d80271f0d1d837a34b3dc42f3bb25f5bc5d68e2c86457d4e24cc2eee70329f7880cff33984ae647e4a80609163c6a0486b08ae9f8cdc11cdec29567b217340d9cf7a8e252f6f394b223bcb6e4af7d7394bab629a340bf18b0dde88b6bbe708026cbf8234a9f1a99df4df49de29eb31f331f8b168b53159dec84f94373e8b7357ae5160a04a2c649bedb167ff50514c801b42e85b8a80d9b8bde056cef33693c568ea2d2f4857ed00c248e61f04b0834fa2cb21155ea839a9b07d704351e39cf4b39a18409c592d1a69784e98fca2a66ef4ea3dafe62ce53d2cb5135c7dfdf0746f237970b5da6324fa5066d2a7a94743df309e274f3808633811ae146171c01eabfee0ba6e496c96c0aaa3919a4532d8b65d4c647641ae6944411d9a303b09b770873a973479d85903967feccbe6305917f1dd0cba8db2973bf6d63831f724c17729e6e13ef6bf14938eb68ca7e41640fbfa9a7e69eb5a6dd29c8fe57c659b1274cf26a2e3f32b50cc068d3758dd0b0f4461f7a4ec3421b9156dc1821ac72dfbbfa13e8fd2c0246d016c052dccfdc1bfc28bcd1b2a71ae0ccc248027c5b66ce98669e098781a9c2f83218059e88dbdb943aa06e6ced6ebf5ef4d91d21ac3f4132ca86073da27a6502275da16caed8348c7289e482b8d0d9b51483f294e3380c85fbee4c92ea286cf91f1561d9ea77bc31f5e02cd43958192c436156eeaff6711c77362400defbe27c1119aae97c4a1d7b7f40bde393b6147ed638dc9b48dcc636a2f25e40d7de7604f312d575500d0f87e599548a1ae716cbd60231091bbe96865c2da9c7e3678d76cecf5686f51e8e38105f5921a6457c557e1ee8d57d32709b472a9d89624208e8380087f43e43dac219770c1679d3f69949557a4c33f927f237be728a5ae8fb7b16f249871abbc962f9a08f12334d5b50ba2999c81bf3b9327111e369c06730743c61ee489756147e3ba53ab150d7fa09e1ce1965cee616c0599059287dd8519aec73aba3479969d34aa45707efe4bf9e41e0ddbfde1e14d356b273633e75dd99ad831fa72b978e04b12dbb2503cf3b6496bfeca81bb1bfc063ef1dfca8ab53cc642d8ffbce0060f2a3d81444d3410e11046ca68bdf596dd2f6e3224a150b99f2dee3e3448fe4aa8339b7c9a9cf55a18c1d748e883be3a588858bb61b76fb7c0616a7b7482cc6c6c0da2c841764da7462b2841fe4011578f90e1863b1ada44e9ce3796c29900f74a1ee9b0a4af96bc4342fc9de6b8fcc4bb1c4da997d4d46b52218b7037295164b1febe73e2740a4bee2e1cf4a022ba6c36a5b3a5eadc5a443be32f826c3a15ee7d57d4c38c3b4fc6bbeddf9afcb71c825641a4d436a238043541cace7f0554b6a5415bd7f01a587fe4e26497d580fd3f910683d0b16b1f3c7643e32f225cb86b0761662a191d27024042212dfed0a22865bb84c42bc0e5202a513ae9192f17f418ff6cbe5492c702360e484e1e2e1dd88ff9e26563e8b0bf4ca4ec25dc577cbb996d43529fa424dbfc4d293d8ce5095100d01524569d8544d1c3de08abfae1bd5480bfa9e4e9417af87016d0aa803805c9d85f71bc8f8d63d709d8a4c00606f4a71c217c40ca8cd83302cbf7942af7229733e68e7319f041a18dbb3fababa35d8ab73cb3f440e8ebf2e8729cd5bd5ce34c0b597c5a72dd1990521d9eb07efd99cb1f13bb744efd26dca6d2685448b7093508964fc5642f574c2a5c2af2b214f734eccecc483c65f364173efd7af6b28d8df15dd54e390ade7ede4ee15ef55c4171b65a98e7f9f031aea5ba9ae73a0e83b21276f5b31028e366a41de184a7d238d20665b0cd83c92c02953cde21cbf9f2496ef9b913c604417e73a62ff5ffacb311771ddea36328a2f69c04590927d67f84c7b47c1f4a23f1616263d7b23b5cc6aa19d62fcceb3fd60a5986db87079cd1d569e0e496ca9dd3b02834841b03a8633acc629bb53d81bffcd9f978f3bbb1a1bfad73b76ff1df8a4beaab2883c4ba09a964daca3fc230bd647b188ba95df858a8862cc55eb638c9f954fb364deeaba321fa14efb6412a86296e394a4b66326ad1957419939769df54930ab5958d56b6b50f6c941a4c3176f348ae90a5e45b62285174b7d97317f38add0d4931293bdce19ab78edd059d42fbeaffe7bdd8e86349c59a286ebc820896085befe0e4b2500e50467f4ea274e8e76e2ec137f8bf72549338ea48b67d210e7aa58f384e2bc218769ef95f8fb79925fef331139495098fd7f7deec70ec464727bae8d4c657661fbd29e393fcac19c69b959dd5c2f8809c3f9b34d711d410abb88c01d9fd723a1ed904d0c374c36d333e807788b41ed74b900f2cc3a793f361d29ce61bf5c1ba9894db5a7bf91f766012742c417789afec7ad030941590cb8562437d520b7148c561f4560599f1aa49b80c494a20e5821fba85802cb6756a02f17d575bfe770360e93ce5e9311a2d9da67e6f421d31d9b6f4153ebe5f2f303b0fa9a52256a885c3fdca678af7d041b737f4956a8df76c1de37c7870f539f7e554a898309f3a51b21d1352d16368b98b6b0aa2fbf87ec106f752c82c5d7b094e8996af08cf5d2195d4e8f66ba6ab93a1c108cc225c5d2805249f5ef4921248aefaa656c473956d45175b7df8d2b10de407d19fada4e1da8a540d446fae07b3bc9104fb92cb8152e4ea8adf2e09846fd6a4e27e4045b472a3fb7825099c3de5b18f6064fed69adfc1c22dd517fded97452859d2077226dd6642fdfd44a983cd96cef5b19f4d3c488d2fd8f84efb11f5410149634bd4be84323cae891530ba75b346392c6f57664d1b6676edea852688f321adc57f6901262e58a979de98a0dadc73bda3ae00fbbbee03e6d36831b54778ce52cc86deb13a7491c1a48b0dbb8df878db461edf1f3911947c31eea46716fc2e1c8fb2f374adfdf23309358aa5f17ce62a26863731b0bfa73cb69c14eec98a1dfef6d956a1bbd545e5e75f0ce8b94f317fb1cc6134f95b702e77153ccbdf786a4cbf5d95f4fbd85f73b9320e5d3d94964847095403ee806a42b4ab2cab2b3e785c6d9743a2bfbb03111d811cbf934fcdaadb1a9cd049d57fadbc854f994c41356394a1407ac90430c3465ab797dbb634b9b03c790f2474532f007e12ee09f37635b16ef34f8986c32fb932e6031f1e7ed669c4a238de520a1fd00070f6d8a475f757106bd64689dfc46ef795c4ab06778a7e845bb967be193e323f92301f471fb893ec8d75a46c1769443664c04b516645d5159c1685b8e5559ec4ad7dac77e1399eb51ceb3c037ab04d24f2de08d4bebe260c1199cf52ed876794ba58f475f1e1a07e66d3ea602d7da8fcff0ac16ad69e43ddb54e7ad11da3709646aa50419e5e3a299a1d2cacee6bae968d78e6c7d4d09517c712853f7a8b53eb3f06209b55ad1cf4b58baf99d0e42b19f96a5fd7a05509342e1a36f7adf54dea4971c9e122ec9a602797e23154a0361baff6861b9f7e0ba779e654c82b62688dba030afde39c2ed6f66f821c306eb7b5495ae0ac6bfd46602d3f8b06369545b0b4b332e820b49d61e99c881ef0ac7237e21ac8e5618ee17a5d753e4eb84a39c2bb5f0a4b8804b71438e6c971a8c02e0ee0b2768f1685d970622bce25a40168ebcaf2f0ca93bf57d0fe019255de169feecfd1ad837714e6f1a5a23e534b2702d939c8171c6647c12e0c083e6b52cd21f6af06552e891b93c084f272afbb921365425baee3104d4c3bbc196574446673b7f42074b2bc4a81ebb0f2c7cc19c807bf6da80ba2947d74902a950383fe49e956c4a401512c0f75606359e94cb5fe530363f3cc95888860352bf2d8c786c89ce5e68deb46cc74018d686df880f0e93065f3506bdd109fe83fb4ea54daf6704827f67935c85f6018cb76f2e05a9e42c47255ae73b564e752fb4ff9262f4d9061e6060b28bbf9e581354766aa25fe8fca8640f68f74f71044cae8b708178b650dd846bf7f75c6b506ccb275c72b7d04be3ed3b2b4d051fd768c5ebb39f574c932dd2bb86ce4a71e8caee19b86d64eb794864698018901cd417f7bda9747654ea5f701f771cc8af5efa5ad340758130852a582634ac7f694c6e566917b74a9f2334919484015bbd333f7ea70d88056e73336e9e8319e120435bb09868592a693a574504bd02a9fd72429859016b519bd424467cf04fae38d359674fe2084c3fe5f54a85591d49abb7992fe70266374c1eae6ca24f0588000c4dbb17d717fa6cd215cf7bdbb80b252692b476aae62deb5931d9868a9b0162173c482a2077019f4bdc3154552b8d30c864aaa36e801d203cc894f552a2252cf6fca16405333a91c3232425f91eefeb33e343b121c5d1f60b03cd47ff4128a3ba42f766cfdc78e90ba2c04f6fcb99a2cd748b59a7a62501944079260f9983a6ad767b9ef0304bf8109f2cfb05fea0ca6bf4e358fa8d8fc8de020e27a919bc3089f2fef2ce90093e4b6df630254b629c5167a4f7b991ad091c38376508d227efd301f5bebfc255cb0e73079215ce81c5745e423b8914f2ffb0855f45a2aa38f3d598a4d6405c16830105dd4146a6205020ec188883eb7b94c4f5a26df7c8642f33a9938adf6f7bae3e90be2a1f896b2269860fd0b3245c2e5a6e2c38e49ff249adab2e29ac8139e839ff8279c21eedea7d9540e9f540cdc60242ba133b754e1ef0302e8df86b3fa34958056b8a80a941048ebe1a6898f6ef8eb9c1b3c867fcc6e607f2cf83959f8ec1d6a1fbe1289783f8e20cd006ad4bc4d360a1f8f6ac220cb4a6d06b94bce45b6dcccd372998267a1c82af5773d24aa306aa5024ce455d725115f3a9ce6531ac74496fa5e916d7bb7653079b83386b05ca6cca3bb07ff87d5df6ff6746da3061c99ed8ba3c68020d85e7a1e8a3d24c5d25c6719bef310c1290f29dae22307f8603a88e0690815784820720490f8d19ce9866aeed0649141823b229a4b4fb69e434a2a0639d34605bb4b1ab74e112ba1e228c93fac822134d62de45c76b5fb0ddbaa17737f83183be3d56e5456df70c99e3a34ab69d2c7955eb4c59331523f925fc3aaa790480aea93714bacb63d8a13584a6f20c1ce603a13d6a353d0473c1f2be2e0071d95cdb5da90337d8a1929dbbfeb1d24c6f5c2079407a61f337b0ee01ea7330691c53b9cfd2d458dcacd5331c27a14f359c8debd73cd06f256ade4354cc3213912d75d267b459ea9075caee12dcb01d8d2e1608173a9052e454c5f858953e50dba14a2826b0ff47c2b5b647ac45a63aaa1cce3a60c35587b466e6bdd10d66d83e6ae94c478ceda97d303ff311620f71c73e6297b75822416d79bf32d37ae26a75fe7afbe1e0baa54dec2da2243526cea67d21345458d92f1a31b72020da10b219a2de2ad09f633824435cdd4f9a7b56030dcf2b10b073837bf06a1cb6836afa0c5bd9786e695cbca5d4c1174dc480d97bed6b75bd9758acb59f513cfcba59715800dee5c4c7d2acc194140f2f5b624e2536e1b27da899b5df1c521f8281a7229ca6873641c1dcb3a3d4adafbdf67e5f26e693d4b8759299be47d04cf74977bd6217b7c6ac06826fe7df71ec045d4e9ffb568aa39e2366be9c5fbcb514db272c588dd43c768b400ad593b3eb75c84e2e9d4da386248d16d045ca11c8a072b71a42062e60ea507ccb471365f2c3210587e7852604069d458af65549be45cc80215f34bfd9d0efc2e357fd416d32f86b52861f227c60aabea94f4d20941dc28da98177844cae4639b02a0c8f73650a062aa7b25e26d75f2e90613ab257c9ac84e5339b0a51c5760de2c6edbd6f586f4c1d76f580ec3e4dd899eaac439a23b514e55d12860942e964afaaef27546dd3b176d0c34645e9c1744281110acac5ae0810e6c4a872cfa740029f147e615b8f7bf5c0a2a99ed4e657b49c1ff15b57a8000505a5becc60d46db767b27a1805432735c860c9d2a57785d9cb18e342245760bc0c3ffb9c65244d648aae299e6da69c560c3d2adbf07940cb927841982d4d9c39b9346f40c7f219abfdb7833e831ec6e919b15d1acc9bd00a5c8b42598778e17e09fd1518dbada8b73d4897b257c2e90842a1931808cf34e79081e679750288a3cd2bc1cc5de7b6f0dee0399694baae2646039f97ab2c233b3242be03b0a66dd7eb0bdae0d91f3e89dd601f59ecffe447413c86064edc8c235d3eee5da76275a7e456f413a808cf0f40533b6960469ffd5c09d296371c16ca9c0a71d4fb2446384f543ef7e1d8fc50e19010fb6f7c27af7d48c609558281f8bb043efce9def4c0d7123bd42a0403d606334c895f9d935b94c959094d07a865fe9f39046f1c219efd9da44466060a0fd2a81d0e2af3d0452ba31a1a4ba99d33a7553e30a6783f14407a853255f16c818cf9a30f5a1e6703078eb3b268cd1267f02803175a45103f725940af6fb70ee60612e1ae686d43ac4516fe5f51b3679350edcb1db8c8d7609ae583a4ee73c3d6a027e3cb9af243f49ac42c15f36b16930788ef01ac286c2bcdd4dcb655d5c003b9f9ad9770df5f7bc83293b275b3a10c7b676ab880619eb7549e5bc0ccad11bade54b5e1df43cc58ae070670b8596623df54cb5f43e319ec7c0a51deed5a0cb5ee0e494b0010c96de82366597193279a8b20b8f8b97ecd9a9c6678bdf304f87a48cf2e8eebcbb80ddb8daaf113096b510a8404c657a8f8ff193328b37665d56be53eddd24bf626ea1a37cc56126a1f59c9ae7f2449a9d11ed120228930aa33b449c671459f097cc4e0c07116dffb2f43eb9b409b1e24903f39ced63f38c86bd47ca2029ade75d298dc0ca0cfc2007aa3543dff05121828464b338442e636abfe6b059380968249137a40cd996eabebc0428b279641fb1292930e76157095227450c19def4505ccb4bb2d6d0ceb8126abff1cfc8dcc4a63afe6f01d2107bf7a4093bf45c7b35bc626a7cee10b2389ff663013cac80c7f2d95074b4bf8305235aaa1ecfaf4f9c84294c198bb58873b5a21527452dbf0d74e56e0e9c3b601e18347d7d573ecd4a3393af2a50c53368551419016ee3ab2c989ad3c567d79a079302ab2bbeb7d033f1e3c7ea05a24fb3aceab37d41975060008cb891a566c1d73545e552854d59b89748e0eb76daee198713315c8b2b135d6176b94f8228287d6785792049b119c4c0af913624d69a6757d504ed8e23df2fd49746ced7fcfa9e9ddcb500222d26d83ec12ebfcabcc88c97f0e4d3d169bf88a4e1a028f981cc82e13b3dd8c5ec849d3a223b6d383a11f5f93dab89bd149c2a95dc4c9683da39f49a401504a5ba1e016415e3f9b2f665348c9d4ad260a172b1d04b22e5f28888310f8207c9e85d733d1b4c201e34dc54071980aee9ae3a93a254b7a96e44ee095511c18ed93625ac62a7656b1933cbdd0299e17ce8550ecabea23b1e87593fc27da469803af489f8c860c8087b88ddb0d1e52341384b2714692f276889ad102374b15932704320b8fb606feaf2a78736ad4041bee0ecf38b5402c509db7d074d77e859713814da3ff3874346606f8a0dad55601dd9a7224b02d0a236ecd9806994036e6bcb0a442bf05cb3e080927fb11c22da19bc625427a78606b93b060a6f4e0137481acd02301d32899e46260ee9d684d09950b0f8b9a18a3a4e3fd90c6d198688e358738d93186a383f13971dd0f67a43b17687c49f528c3ff35efd2158baaf50c19c0581e336069f12b90952543271f8173a2cf16565b9972a71467f18a7b0d8eaf1f5dd6a44b5c53acc2770c93b660f4a49bb71022c5b9859eb8454cbc9354a67dcf69df2cddee81f3567219f2126f77ecfb5fe967e36a8a1972f800b2a02b06215b4d819a896cd9f95ab150357d7f45dcb45a6aad9a84b7b8c9f3662ae6f7125e165986bf241f81dd25e9715e56e1ca8192ac6676374c922ffc62d50beefce62f96d514bf08668bbab1c622b9db69c38a5575d4d7629055b0be6c12ff7e71f46ab84082d491fefa788b75e7a522d4a968deb843331440608f6ef7ba17003cdfafcd3e188cdfa8cc5d85b43efa7c60fdc822471ad920214bfc01875215c7c3f23325da3658c0cf367a1beaae6a383428ec041c00d1fd847a997d4ccb1bad686d54cc03ed353cff7b7ceb284e2231ef379df8a6c1f59a407e8212b5f79c1846952111b0bb05ec7176b4688374c058066e3fcbeeb9ce6090941c560cfd06e9ccacac15e08c3bc796503a10180bb35951548f0e8b283192e3513cbd8546a3034808c2ca86df398d23d01c95d6cbc0640acba56a6f400876423a2a5f6fe07758f8a95ec3cb65701cf162815d1f380aec23041ebd5d6389486a8319759278d64334204416f163781ad051f0aad8e96aea0d26e7e823d9b3ec1682e5db684f57141bcbaad4d1916ba3fe8b4bcf9c459fddd3519f7bcde619dbbd1076cd6e72f5757b6efab2fa65accbe6df7d185608a22e58d0e6015eede8638b563dff481908f174445620685b4559a682af55b5492b8ca1087566187bc27616addca62bb62e60df73dfbd5a8a448c7d8d39b657fa0f9540a4318a197ca4624a817c207eeb4d7f4a851cb87bb7951ce612167dda5e57cbab0da061096085167022f550f17a9da77bec28d94b59802fe7f583c42115142027b8e24cefcd4ec59a0af985b5bffae244b19162fe9c3f3c0d2d6f009faffeeef80bc91b6f8dd836dbbe325c23337e0863b06e67d42ccfa9e0130a38d1665512424eccb80cbd5384f691e41695afba4dde03b36017907612c061532b29f7123a4d18542d1bd7dce9198d3214d3af9242dd264469f2352a1dfad9c5d671624987eb7ee975a1db60030fd416e92c80820c096a6213432aa8c313ce1a000ec627710eccf7589e19d9813e76b38479492b8efa49195840b7c7108ed0485a4b80168c3211bd914cdb569e400264ef5b2b6ad00f54f2da3980ab3b2fb696ad8edefb84176674a62dccd86ae0c30b7573188e27687ac0512d6bc1bc969760b83c26454cec43ef30143d24a0d4ecc43b9e0f9e3215c4dd2bea7d41c72ff93a4dab581565ff88b47659dc175795bbeabf54318d41ad2c3d39b2d6eebd0e3a7bc8203c8081fe56ab2c0e2657eb5c073163b842abe3b8f724c3c5444168841f4e8053f5d13ce241c75b8276f39aceda16d5d8d974070ab29c3ac8c929eac535a46fb2f76a40dc1050b2644b0c98c25de3df753782b4bbf3ddb3cae414280616cc01058520c48e671bc7f84377729b6656fb355022a81e479065ccc127c79fdd501fd008c4a5e2e7fcc66b0e28c99fdcde07704191a67f7c17b9a8442a72f5ae2364d58b10d8be69f8ca3e2cda3ef7495c1dddf185ee856362fe3fa0f6a8bedb16051c4905e3d4d8ae609f91021f21234d1830bafa946c35efd0f2b290a2666d3af0a2eee82343c3e0a348a4995aa9b221d4db8061f64f894ae1737df63c6dfb0f289e9614462c38b8413a60baebc59dba9a22ea9c51335caac357c3b5a4f8c01419a98c9ea75f2d750ecded1e38f253d72e5d99e1b6746738df861b6c57f59be349e7843b942ec08ab5795a4f6a94bf7f9acf588417f9045111d0318eb28a6af0875ce4b1976a431c1db425f79222d0a35c9601479b0ef353904d53abc015c47a9e523cd346914f11e4d736bf9d5961436c965047ccf5d3347c77c6d516ac564f3cd23cafb8bfc81c4a15645b1cdc811527b55837dc3041ea34ae72b90afd1aa8562141d673ae5cb5f2f9d587d7a07c84c5ebb725f880fe34906564f0e50c74599f2dcbcaae0acd8ea7a8d2351a278b17cd09adbcf0db24a579fd77888b03096b7ae4bdd611423a05d33796e0e1919df6748f17db81a9fd56341192b9de79f9e0177d966721a2a433c6882fa922d7056c6b8d087b7458f926f40bb1a99d3e28be68bc17cb0efd175b5c30b010498e6befd49e8db3503efc44ae464b980ba38d39be1b00c7a844fe450e44abbd7fa202f16870382444f328d0a4a2c4216746125de0cf54bbb8b5fe404dc2790d0d49f293c535a5d3f6f9895de7efd392d2491620ce8f7bbec5bd02647b29fc75f56c2edf877dd37d9b7726278634b19d2d951dc97c353b306a8f6f363ec1436cc2097709242c999251fdd7b97faae3d54f3022f95deebc430abba1844d9fb1886c613fb57d2d714dbeca5b114ca2545f0ecf25caa57abc2e5de2e34bc1b0cc0a7c76cf28475340e6356c00a45e854ea8bc9e685852ba8b5b857666c86b0669a7031bf574bcd9be77cedb0babe36d073c1788e5caf86e07ef8dc6e431e093eb390ff98d7f0619bb463b6a1608eba916fa107e5a658c73604ad01f3b5966d3d93dfb1f0c400d0401dd3f4c5f93ec37559ab871681d326921024954ca97168c250e50d85b2518dcb247b7042ee9cb4529589b29cdcaa05c8c5b911b22c113443e2988c796bd862b0438b9d457f85c40c28782db0f6266dc27d61ef0a0ef082f63a660a47a75e563fa41f73e7f8b061bfb52fd36eee3c0698009486f4e4a1ef310ddf2227e4771e0e46f2f9b9dafc067bd8cef9ae929b7e6f61fb1e2d68262faa38f5a99a72b88b78e02594dab5ce850d0a5516853c9b7ef16261c0dafe22f4c45f04762abbb4e4d9a7a7247e1f81a10aaf20b0af690bcba32752169047870a7aea42c71f64422d0888712442a02c5767c5056e056e19462c338925f027ad396e239b6498da67aa7704c64246d466187a61eb41c7073d103d56ba976c9867859b5ccd73e526d58cacbded931d353b78f8c50a11d2b9121f83f6b3057c912e435d3537226bd45d4b76f6858ac97a4f7d0546cfa278aea2197af4ffb836eddd5e07ac8efa52b32f4801846e9f1292ec985521d08e2bfce938edf2ce04ef225af84262dbce5e397a389641d2bd0d96765765f3c04b3cd7fe692aed0f81722a1e953cdd171fcffa3fa2889f839d122f3c70c889eecf470815f3fdb760439ae280462b60e04f9e3799c178293a1b6067570c888078151e9001895cfc293020ba82317ecfd262cb724ee75f99dce5bedc2d81f1ba915fc760ce1a0985a0cd84079309ae6b1b189f87e86493696049d11b9fcdd23c3c0956c521b54944e75a2602651bff02fad390ac67a126a8d35d8525739d2b3c7d397da01bd74803b20e09601491d8e0093409343df879370ef96d42822ab2612c72317070f7bcb6da3caf7e26cdd32ae546eceb50cd4fdc524580fc842a6af00e0e9284659b65ae3a90af47a78a479f4725e5723f1dfb8591f0413389ee363b7f1654bd798778e07431d019c3beb451198329b5f77e79c91da5611572ec223532689743e76bf7bab3db32ea146593c3f4cfc9dfa03ce631db57fcdb9477f541717d16fdc602e5779d630d754db6b73c3c5782b499254282338ab72ebf235df866deaf82918c485b003697c051f1fcfc793611cee468856aef026415417c62dd6499e55d03a9d1bddcae9db609a49d083897a2b4feea671c384c39ed17159e2ed4745c3eda0500f06fba8f8a1cf94bf027f4b6b9eaceb5dc18d9d3e18171f89c4df5ae371f796d3babea234101f0f2a907fea1f6b748adba9b0b1970067ecb4d76f49e1d1baabd2103d095671db3d84e979dc871e6199e5fef30333d799ca5f203b0aac88164dc3e4a5b6f732991c59fb6ea0982be995a81b3f2a5cbe37c753a2bf8336d98a0b8083a77943c7886a3b50046bdb8ffd0bb36f862b888772848db4804c50640515985a467f06058c5a641496b121e5bd00977ae1a2c9d7aa2f391c9f976d549ab3d757d5a02bf51e62995edc54abdea684dccec65fb0f0df23def6ec2449e2dbc5d9d68c3009bd66d09dcb96d774fc3108fd3a588944e62463aae0a25771a9704d119798e6946d1cde9eea2d4703b69a3b8c22fd142927fd3f7590fe264c6a93251e521fbefd15b2130dfdb5360ff24f28befa4362c388e48a7aaab79be8ed9070ed81036ee18e6ffebecfd55dbcce2616bc7e84014c656776730aff425617495a772a4a4840f68b0c504516949de1445f18d828af5f40c9c1ed5d3c10e44ae13610e8d39219e1b48c4ce5ed7a1602355d8f6bcd6726aba57a6d47ff8ebdbb368bf3382b0db31cca4c53db469d96171fee20a420752ed5a78d1f35591c4a69a394d2dcc02578759676e377dbcd42e32a6bc8b946ecea684646163137c1282a404d5f6a345bb480222c51cd7bcaa4ab298dfa16d95e7974d751095942d3d435b865d36251b4e51b0134a00a5a73e2c966c2f5e92f104f63156655696400cc5ae7c4eef61da676428f7cdfe64d2f529e1d3b7ee57497a5611b0e6ed89990ad58d34a943f8a77c7594eb6234ec7be57756e0dbbf1e7766728f94991d48f74b6d7d22d6ac16dc4ebf175e4d0eb42387743c8ab8646b01dfaf03d63b5ea40b464f460615974754ba62bdcd898052a765239b57f555e33a8efca16965bd00e72146d5782c37b1a6895678646e055b9e08748a97f490803fc843f6875b8674f9b14394a6822a9cdc6e9f0c2ed46dda0fc4862d63738eca6d4902d6dfabe6590698eb8d90d72023b6482d210bea4a1c86955b9b6dc2b932a6c4395c1b228eb29b94c0e659480b7bc761d247f1ae5ef2f40db9d094493c5c9da2eb3e9decac8629d47d0330db16aff84cade91826435a5292bf51e2873fee73a9f98a599b93e340f313b7c16caf3388a1c31102f45e4242664f171a710dfae00e62f39e173f7dc5982d3bb198de8498dca3f902dca1bfcc6bf330f5199d32c6d1f8bde6d55a549b97af6714238adacc051204c37d2891d8046d8feea62c16cdccaa2f304d86f9f63c83e8d69a02e1dce1f7d5c2c63793c64ba686a099c51109c081e2e750dab38f42b3ca97949b0545da680ef1ea4fa655675da0eb093e2274f95914b715035199db0585d067f3f4f9f514b7a499ed6e5c8b19ed9a9ee5d341a8421786de7b05f24f89fdf47e3c28b01b2a33a024336196ab3a77d96350d2fc66896f171d614458ab98042da3632685cd8e3c02754111e8ac287a797caf34e4d6ab54d0788b1a82bef18e994ae8da04ca83babf0e887bb0ce0b41afb66442d45b27d23a0220182a3ce2b19090bd0d4ad1e4d7bdec3e91ee84e03f52d256fcd9d9b5bc6f0045a6a922bef884bfc6fa774955bd73691dc86048e58a115fa17ec942f9ca957107e1381ae68b0753b9d47f1f7a0750edc5aa5c32e46c441d0a2bb340259946006026268e2e6e47dbf87ed48cd2c03affde5e4c33d802fd529c8538820d99fd988d429d09032b6ae92eccd5da276dbc023eee501e5f48361406332b1fc50f4454cba90be1b87019597f55d346ba8a20c3c0c7847c26bbf04ef86cb94b8a6d4c89e5d3ac68c800ec6ce66f319a12e3edcf3bf35eb5fe1e91794c06200582f35a6f3c13d42a37e9f67881c4ef9ca8441609cb33413898d4fd15acaf72bdcb2ecd6aba647d078b64a7b814787bcc0af52609362ee3df5b539b21c691a67ad4d81ba871921c51751db661a3678fdbcf889e325aa907b9d56a75eee03bdb0df86d3e40f9aafdeda545104e440928ea74430dc733eff60e72e1f3a7a9d8df84c634a69a93da492b567d2755696955c5a7f97c4d6d69ec1b5f72e18261f1805adb0c59fb9113e3d11dc0e82f93d54ed0b1a354de6165227b5128552a7af0aa6e5cd1b8f849303821afb4766b25a7eb27571f411cc8b70fb19301e0a8490f020073e1e596eba3f480e13946ac10758343d223f99114cebf76e21f8e3fffdf9b531e287863b73a3edc271746b1011c4d69909db3b68f2d65830b46f1679709ab32d8301de883fd1a87975ec4b8f8909ebc359999f64d6d6903d169a2b5a5adb1c2e1cc075fb5773a97dfd7138b2fdf7654cc93e0ab23cdbf9b63ed6a9f2bf092c752bd98e0959ad25ca0bc862bb85d12bc04e66cdf92aeffcd472b7a0ef8c3f5ea69d9fcbe56e4a05ef087226f770da8f8ff24ee4c838d772a74bd7d4755f3a4d7992d0eae97ba706af75397355527a8e929348d1a575c47a6a82a8dd18525ad3a3bb50dfab02a3d8dfa77ca9cb05f809158b3c761e9903f91fb256e4eda6960673b2760e114c4c8abd38f144ced1e932b89f170fea6f387d0ed18e4691b12b76f70cf4c92331de8f5edc9cf5136542fa381ff4c83b88271992faf69a1a81905b99cc812aec4af9e1010cdeb5ac271e4147560d67a1de2bf2815f0ccd5b1cb9853f6468bc96879f5aa039842bdbcadff8e80f6ff4f2ab41cde7b37f17a75619686b1975f8556ff17d0c8924dc652639e3c9463c569c56f324eff93162cc3b392cb101d46df96b829545b2c51e78110de1030a2a8e6f3c2ab0eaee8b78c67298f98e19358d6e5f6bc58a922b57fe5cd16e211b588019f9e60e30d226017716224b05dd030ebe2f3a5aafdadea05cb0a7422b377f35b04b4f4aad33ae7ff48221a74c988cb28c41f63dae29348091654e78c04de4ff115e2e639ae786fd6b4cb291d97ec01897cbb1079eb3b997240bd4535eaf39ad6d298fc332d140c66abd00cc096766e562bb26eedbfe38b436c849edeb87c1c9b9c50430dbbb6cd1b8cc13a4e93b58d6c8eb514432a71c82f3b0ba6e0f23a2d371ed2aba53f58d07754f700a79bf618048854265bf3ea506c036f77aa4279487a6474f46f00f4a8d30cb886a562e34bf65638319802da784106dac1084e9b46562127125e6242be24f5512a3df0b1ab7d3649618d450333084d51944569c311a45c8e365593f408612dd6252b6bf7b9b61e01fa2b329896c4c8de7aed79f775b31d33a0210d7ec60c3f2d57d91312d0678a2aa64c56218e4d60082eb046f60e1032cb1d51103f5f51398aad3a3561acd8019abf96a5ef94ff998c5519b6c7a9ec908714a07d7c82944042d8b4ee6056c5039847241591860c7ff01514612db5867afc8400434361d9ae6503cd9eeda1f844191b79f52cbb3044199d7b8ce267d0f1e066a380c03e2a0dcf3c775d1f915a0a287743f446fd674460fd5d0cea084bb07581787d017521706e9df9c8296b1e4f9db5d4e1485b86fa394795e3437e04aef65da285094344f01d7d1e262ff4d25eb1b4cb7dc488dc3aeffa57c42908aa404a9cde26bbea81240f32904134f0c6670648021b02e0e40be759ba93460dc88a1c25b65125343424bf29450031adc7abec4d6cd769a50fae323733da14fa630d8140fe493e456bde8feec38f476b6ef31009ba99a42378fb77413ab156454cdc9d83c5265965d0edc5d43a7099a88852a846a3a501f2598e0b3203c75347dc54470f9c8c7871b57c4dae512917dc4bc25f8458771cbd4bb49d32125a0dc6984a4931553c416ee8c7796638b84bbcb405f8efee5f8817d80b809d434d22fe40a9759f7136891fea7fd9d295963f5167f497895cd510b76c3115fbab515902811599116fc381c30a6446bf9f5def7e149cc43754a79b2b7c3751774f38c8544bd54ce1a36d1e1db1d2447a24bcaf45beeefb8115cddfafa2069c19826f7ed6383b54ade671667dccf15bfe936ec10666b9ab92be7092f68ca9c886fc43986b6dd193b9bd66a1de2bfaf30c552d13aa8894f4b6c2c2f5bae53282c4d2e3a4318465508cb31d2b1e326bfb5e14daed982261e04b539f3413683f5ec507709c3a20705634a3ca41660ad8851a5f58cff6f84f7981e1c91c4eeef074061c668941c1784de132bfcb96182f690b0cab22b53ffed5691563afa7e4aa434d9cb3938765ace53ac81854807182632eecb4120536f5a91ea93d8d091168dce791d2f23f9c0f446a459d1ee8965dee49852f71c0378120d5f31be9d76cfca26d6d8704f3db182234b2db627c31cee705ad46761d951dcf6019e6c4c2afe9a0a4240321d4a24a2c018101f4a34ceb5129c22131e37ba07776f96a9df9664f13038960fd4cb4c290fbe370583a3194094aa08705907af134d63526747f5720f26c46d6cf92b378919f718dc58b2908553e635212ab4171b88be511cb89b5f2fe4740e5b37612cc987edad3854e548b2862f72743341bf7284c5d6dcab71338d016e4aab4487704b3f8a4b97491393502a250f6d4f9146abd5f017116ff69dc29bd04dd9fec4e45c279babc2123906f7bfc6170691cb78ffdde7d6358c5d928a5b8e6156469661e661aae53b0775b116bf433f77ecb880615aff9b079036242f1b34b21d2cc1a3b25e236bd771c87b8ae3ddec095a326fa03a7ed1e019b2b0b3809d0142a4f787a9d2e0bc32281fcf1bdc86bedc487e9c21286c2140832952575dc4c0ee3ba0d31cea76934a0486382b4c2ea3480fb216458ce301df4392ebc00c70e907c9f311d4f215d953484e82fdff1e0c858f2696204c194706f5b72c456f8a76a7d0065f475caa461430340592dff7ddd29902b59112e90266ab0530f9429c8ff0454f2717271a3ab854f7efff64868e391e11f4af09c05cc9e727ab717b7bbe343b188cf785bed60a1e169192810999dd763d6943f7c1130e96c2920b469c78537a55423c0128f30eb4a7b6a65367c1d01362330455119deada7f7f30643990ac77a4f15853887f258f4d02ad403478a2a2382693b560bf9ed5c46e8b28bcd4b9aa0743b1bf09714a6429b98b760495ea24c05085bbbb36dcf952f304ce6a42080a066e9f7ff37be5170f84dd23c9a019a6d317c23952356d072eed326814e58487001108c40235366b92019e7889b65cf6232d29be46f3da2daedd23567b23aa4747c15a6c62325ab0ad6d80207996624fc02f836e5259cb268c8fee0ca2a7ee5ea31eb00f57ccb084f61461b0c21bf997e022ad141e37a060ac352dba42dd810311011355916d4006765a52a2d5f51d1ac32db39fce446b78b350602b3278ae9d640af370d2308f78b12ae58f38ed7b244f6de810aa79a9652245bdeeec8088731ebc674007de891833e4fdb1b355fe644ae172d43801fa79af9998aaf5375ce3d053a612c1d4c082dd5b8b954fe7f04dc2949113a7af8ca9e5ccf5e018278be324087d037753ed88e79acca9c1553d47199f6dd52af99495fa0f12068eee9ed6c8cbb8279b1b772eb6643eb7649e5ad84633cdbb9c091c35713a4a22648cae902eeb27e6de405757c00fa03040eb50b0a83bb2086b5e1473e84f3eda60fb17008439c253cd9c5f25dfdfa1b4206899c35877b553e2b830ab0eda508feb060e06ba2b0b9a06dd43220b1e0e4e12419f408ba64d130310ed924d2f7deea885e8224f2f249823e89220e104e16a88d0256d4a19f5939edec1a76336c8c7578a9429bbccf9049439b95c00027b53bd359bb66a63d7156dbad9fff6a51e79276513ed9fadf2ff08b98b4b69a86c9d10958ea5bcb1139d96a0e64b5179492117e9e247b96cc65c963b9079a22ddeaa65187b8c51235832bc3fb86ac039affc2489ce470e5cb79882df2b608a6ff78a9b3841a792fed6329bb4f0979d120b732372c1d8d55d03acb81c28b4c7a90467db8fc816d7cf22d9d6ad3bc5722d2f36a7706d02b74e8106b6727a74eaf313aa9d5595a6c80ee8d776a43d6c21c9d003dd1c79640878c56412d0710f02907ead8fc6e12753b6dc2db08b9281b6f8af559cc63d66fc585d46ed7bbc61149fd3d61e9a3155e34f7767e7f55f7941bb0626f3e285c878a3e25e1a63df5b365b039fb8917fbefc4a1aa0c33324dfb198bab6aeb3bd80f49e483b6e85d114c5fd33b9668dee9399c274721dabf0a51b7050598c3cf5c9d7f5d20a90be902087b6306385eb6eb123862be9d14a4224e617463c9125c7eb7258761d24f47be86ecf3c39e3af002ce6655557968f8de061aa185d7ba602271b255d7de51e1d9b34014155dbcf7e86678bc2c66f45416","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
