<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8890f994ddcd90177eb29fbb51857894eda1aed0bb211d9335a2f7abda9bd73b440f0f423cfb96c396f2387f054866f1397625d1725be5d786e6f6a2df652a39ec1ab29483876096332c131fcb4a7e1fee7386f6094b0e070a10d49b57e709b9cff426804628de6c3cb7c0360cbe449d21520edd7120d753431b1b47bb8742613fa1be5af02194fd8e984cfa74d533776f985d3d9c439dac26edeea156a5aa15d8b65f83f5065005502a4e5aa5858bfa4a0c969926fab13b97e5e97f3c27612a694057a26e623c3bf75c586af47327fbbcada1148b57fa4b11f04fc727e725dc145ff1aff0676b0cf0bf9889611def883cfff1f22ca3eb211cd90d1c2321659603f08daa5dee1caae870c896a889629ce6e2258253ec7ab3ff3c8bcbbd82153f81a611fce6dfee024d3effa17acb07849e2bab69a593fdbc509215fb42e9dffd2eff80737fba79d60b7e4a5c16cb4303de31430109a5e9b378f59a44d74283c04de51afc48e06a05159b707ef40e340c281dc514c1749ec7b1897b6013adbb70289d2be10c1e9cf6a0820ccba0c85e619407087625fd996f6deeebee83836fb0c036694b9969227317f02934ffc31f34d982d06cea232a1651e897c6012b853580645f3cf91e9c259aab4bd256cffb60226db8ab3095d8754479f81be6faafb24c98280132e28b701efd76957dda950603a47cb6a2337d8d950e08578bbb5e10b720f75a26cdab52fa347d2d8dde508c52f92c0ad947f428045a84b4554b339a5498742426a0fc265d2c48642a29519743766beea74cdf766103aabda760c03db6e3a7ea1d19c4bd1ebf06a5292677d63027257a2c86690c7127115804d30138690097667821a02e81fcfcd8cbb511ed1ce54d3aa652d3ad95c0741f1d8b323a0371349988fb9ad1acdec57a7e367a8fd210b0d0923507ff9ada025e5691a3b0b5cf3fbaff016d9ea0fe05841b4625744ad12ab48e85d773b71d7053ddcc2504dde9fb52264e412efaa5e5978a35fc6a729cc7f48707894ff0b2138af37d5a88608c7513b8e1801f5b28c4296f6737f54c8cb9490df90feea71bad1dc7261fcc058b49d5fc06d44924a4115181100cc48757efe8f39b0ff420d6a744fa12b2e0003ed690cd21bdf6ec0c2697896bd236d1e2232104070d14394bd73813f00ba4f9bb0cca77e8c0130ee952faa0bcf2d0521ef3c57df480b4079a7a8a7b7b27f70286df50f6c8ccaede88713b7eb5884e4b1510e0baee3e544df4c528bf1c772229d0971154d5c0fc6a8edd242639c0d3ec477bab2fbdd172dd970a10bce5c4937a2a7b22ca86b41ad69f0b5f0977dc6cc4e440d62e065952092d75134edb3bb0f9d359a0fcbb153615b7ba69a4ce70a9c21f345ae9270172ccade4faaff1a1b819abece8c1509936998178dce8a6773d430787398e727afa288b3e11666f4ad67ca89a35454eb4257b25a0a24dcf13f1d51ef406d035b80e6e47ef68838d10369e6f53c9f8b1c37ab2345c45387c6db2acbd11db8c1e3f7c03edbe28c884670a0bfed8688d4153690b259d2b1de077c65a86eafa37cb395c01d7a56ab4fb8563792ca0125ef1052090d867d349672ecdd8796b91cccf312693b0c0a8c6c50737719ae00fc5edc0354b2c2d52749b784f92df4b73e550c51752faa2a16a68f4efd12a369a4d2aecc5ebfe1a716a86052137a3d1628e314aa4890b27d1dce67ac5e89f638b3fe30572d60d02a90c86abb7ae97b7e7e1e3b383bedbb49268f1fe77c43fb3cf5dfbbf5ba64732e30e124f447d2e9dac225a48c6f054f0edd388f53851d48dc724659b76e6f1101731ca96cd8c986ff9407a82cefd1238951291208edc20a8112d4131bbc1dde93467548a43a2385223014a045b6df402020b874a76bebade4762967837573a93adfd36daf2630a88dce7b4d5e2bc484f7566cf3e0fe04e41f952167c59ecd5afdbfaaa14b48388692ac60c3797ebbc11a31a650312fc6cd771d49c68b3e952dd12175349462dd21fdf93dfcc87a925faf394a4afef947a380a9c334c2852dfccc793b8542e93fb655836651c79bb3fbf78ea636862c760c97d960a2ac9b15a17c86a3ede57a652b02ec5a98a015aec9bd37614940c3ff7e66492dcd2536141471ff578bc3cad0fb269cd53758de0d70f58c463a0e6eb9d7e75fefa04bf75ae14017ecbde2492d7b76ab89731de7e3890fd76d45979cf2c921cb3b99e4df2c88af046bee90535a3d260dff19cc74e07ba87324b3a0ed2a89c3cbb11e3e19bbf41f963c15fd9a22f946f2555499f77db4927b304921317715e34ae00672c0f6784c9581476fca46866e5b7380ca7c9b0273e0ce58408a57673352be73090f82f60dd6434d1538fa79f1440e9097b91e845f602b1de4c6de2e42590aef676495cd1bdf0e03ab0331bccbd8343b79098dd19469f7b8fe1860126c49fa806da65c658b0b982b43229742358c14a9bcbb71ae0a9ec23b3b826f790eb1de963bd6bae46787a9ba44f252ceeea640c32ee070a2c0a40608e5fb91263709a9107dfbe3471be82e15a6d5e8638e2f364fbd5827bf26a74c42f9bd48517498447f3c1378516f983f6384e37ab22cd1329af775550e2a6f7827ce32444404b250c2c1492adb1bf346b0d4df326cfe778587e56489d0325bc48d34d6df664eae885e68ceae6ebb14214e9da2354efe3b82ff858327710911c9da9c680f168f1226b9ce823e76b455202a94ce9a2cd32a57801f635bf9ac876fd7db98939f871a46edff9d0822a11959d812a00235482b2362f9d0c0e13b1e8e0e490c8fd0476f9d4627e1267817e8c0b0afaaef8973e38df5d95c640b33f9f4c0fd1120b3e37169a9aa277b2ef4daccab4d8cd891c139f311707a696d0b6cc2c69df03dfd3d75827a7d6f60d566d2f75f68ea591fcfb37dfc8976c78e1343f732e3e1cca2310d7427a9e09dfa273caa51446ebba90d85f379070cb1231fe71d8d2c251d742df8f346cb8bfd2b17407ea6ed8f018d8391296fbb7763c136ef80a0133763aab702d1f002a3355cf33440346bdcd9659be1861ccb40f50c2fbf86659bb24c40c58513f948c404264005f9bdbfa365573ce2e80e0a9d6792c0ad73f956550a87671a7144fe31051f80e264703168c02f4db3adfae9c855ff3070bfb50c29da248a9774cb179d0a00650eced0d026a095fc4a23b0d932c2438f5de471071b6c294d333c02d140f73317382d595bbc01b28b7b03caf5935caf7bf978f208e09a5cac7284f272799b349cf160dcb7d55b02d697ed79cca1a7b4d0202c4fccdc43994c573f2c6cd0fdd53a1e5d390c961e0745f4d6a6ea00ac2f4901b7521e0fa9cf74928b818439fd7b4e87a60d8fdfe7daf1cb9c825175e3249b469f19670cd6270f507492dfd5f2a55e250edc37315620bff23e155d5d031c5dc54f92f6688bc1ec192822ef3170323e8d8f7f35eacb44a3e30e17561436e9ff85c881febcba872aa82311adb1c5fdd2bc5a0e1278f6e6bec3b5a13231b16ccb52874a2ccc1e213b159c34c955507fd36bee1b145df091ef5cade894fcf58ad394351ca326c970f5702f62e1b4585d5a4e4e6281ee8d575a7238ca1d538f673cde6ff7c5f4be5c7a2a8254ae7bd6fa89c8c34be34bf2402e7636272f90c5ee384393bcf10b31df21344794685ce8ba5a9e05086c4803fec15bd1dc6698146e9dc48ab5930eff7b934198248b26aab70d4d01f698af20fb05016b96ad6a6c310752308ca07bed10f6c55530009f51ace4928581d7069773a7139c70fa43fe3fcb36d18c03fc3fdf2da086bcb3f3cda9270fe46febe40bfce07ec290b86c76be9907eae46be1e3978c04bc5013f3a1313b6e68357e0ffbd0c6708e49356afbcc5ee3464a9383e4c305b17379c03240caccb9b6420d91859158555879a3d294864a49b5d5b3736822204354f552d7169504ee69b523aea426ae2fa81a1fde2cf68e2d8bbc9652188fec82e574e08035103e442becd15d95af634381170305d3a49c9051a152a8568b6587e2eeb1bd7eb943b60b07c4e0bc8cde01d5773775aceba9bed3df9cb75f7a49399f31fa442d05e70c324ca63f1afecb5b8b70614b9b636ec54963ca9b5f398e2278949453e5d8fb3f8625f699f6631e654cbccb842c662fe7de9020510556fa9043f4abd1ba0d59a525ddf8e5dbc8bc37964b6d82bb8f4e3889b517b2a778bbb919cab72cb74eb9af9747f32bace3bd1eb2517671d532ba0b0adeda5f1ce92388b198ba7aea2a1222ce8da401c809a363e9066815efd6eef4befe3ecf3f6aa244746924912ea23845628dedba6b4438288826ebc812557f74cbdf503232d91a2ee40a3c45bce4f78d829bdb11f82905f65d295018d0ee3fa247bd15e109a4cb51ddf44dba86a6a1fb1193c15197b22d7ba5b9417ba43355880474eec668b366f9e29718ac2ded74f88a8a9744e058dd99b81188150de7a1653582d955e7c2416a9f237b2609cf8a8b61155676931279c7a3e10ddccc7e2bf201d1620f7a9c9dd822d693c25b64ba13521ef5bad6ba22f9c7c23900bb9127ea1e1f4b89a99ad752706e81000bdfcff256955148a9a3c231c35f07c7697edc67f21e3adc283037125902993098b024686ef81385afbe727afacf3becbc5847318b9ed67f9b1faf356d02c8aa0734493b7187b6c8cf986b31fd82a5369738d550499b1c3572c2b93ed820847180ae0172630aa341020126f82a7f0e3a2f408af534e6cbdb4b09fb47b56efb39d85ac8eb3e643b0409dbd668387138f1ec096700f6b03e8ca3e309e311a30d289e6dba2b7e6336cc4aa54dcfdd0538f50ac69ddb8a617a9e98f4cf27c775e4c03068669829b8f151f8d0ddb44db027f839e1aea7351d7ed4f1a8a94b19b642c9ea2a91004962f42e403fbba475e27b9aec4103e86225f51ac4b8a2a32bf06f451037ce15fa51131f4f1b64ed3518aef3097018b089363e720e2c8e34bd347eb677100328b63670f447dd37d91995decf59f0805af4b9c8eea80d01b9b04e3174ea9bfb9855c7e500aac7d3c2a47b6c83696faaedd67a52ff274c01862dd810bb55d16753b1ce826703b21c8efe2217210e67c07d8ea03cc4528319786157c1908bea5a8df4f57f4959bd5a60960b9d40bc1f12b831407577e42657b67e02df70e316c127d6b028c64707fb209fb83fa502f9432dec441ff9ce601f849ec4c25abd544c2ec422f9a47b37b7594fa04737328067707b34845e38eca72b5ba050dc501cb49396f9b4ec5f7556a3ad74936be88ea5868878507be2a0042916a4502e0a7aaaa3a2a103ad3c95ad8d2a323edd4b70fe8fd64e33707e11531e7d5ebaae6b64bf9360170233d7c2967438af8825b1f3391a1727840465a9af7fe0a7db50697328cdd6bf3efa974961c9ad0a9256aab257798b738a331601376830b08a1ac444564713d2409f1f9147dcb62d938a6d61bf5d3efec59f60daf82de786e85765f8b24257578657eece84cc90112acec550796282940db841ede4d3bee6a1a7b9545ec7fae65540bdfea5cf34170057e8b476a4f84119f70316501474cbd897e779ce50378f94a23369b7141a19ea9b0a6d5d3b2adbd6991df007f3554bb4ce1d50fab72b3dab7dff7875a6ce97819fd3c23b6871519723cef28f262fa76e1b297d967de169221d3d54a1b8af0710dbc8ab89ccd345f52c0c59b75a6cff4b4165bf0b7fba7b139bf418cf4b12b485bf98fedc2acc88d09a9a76fd9bf0ed23dc9a36d2394cc4ead5770124f03e0058450254789027aebbcf39fe8dc89b634fe213d8e5a7566412024dbc17762f30b5e04dfb15571613fe1419e873d37e542e9c56cf82d18170f2262720e6008b758b78d1ae0be61cf6369935520327cdedb662185973a518022c79b7db3a11cf3eef27d630ce0f9725a5a6f699062a02ce9227cab27d8a3f129b0de8d1d7aea3205a22d8c89b53735c7469abb54d6d2cf3dd23e503bc2ad53b0805f62b453c13f8cb69803763ddc0011bf2b90efaeb038e8f51841a8c043c10d750e23b74f2265cb38bea2ecca8104e2b168ae77d302e704f7a7c0d1cd1abccfd86ff06521ef5acd89f3adf1977cf5f24dd4ce549c20801fc1dec82553d9a2bad7cb38e344df4250de7d25aa3060a5d1835fa0a05bbcabd2e7aa6e8ee586a4d75b7a951e22c899363814e89cb441942f2eb652197559088301cad270966aaeb4e567d4df1580ed2f639ba83b11eacaf4651c5f524bf92fbe6c06d0bf4f2a4891acf1f9f6d4f540a51abb7919c7cf0001fe262154c935f3293377d96149d24fb976e6018da3ccaef3debcaf2fb986ed866e727b0321bfe3290b3c2214bee87ba7eab6489fe8f42100de676feebbbf23d842857505ba5a8882a6480058083ba85d6ea35b9a1a9365475c3a6e8bb363795720a729fc6edbc227cb568d85ca2a6da38f60bcdc2080f427f436aaaff9404539854680ee7fd8722157042269ee51003845655185824f4fdc480973a443ad494b908bbf529c8453374d55ec9d04c1882894a8826c567d6162d895ab54fc85dae7fdd78be9f3f8034262fcdba62685f411d1bb94eea687fc79a3c1267d24be2e1d3353745ef31bdb613b6ed70028f7868a07850e9488fbc077537d86ffef6e64d732770335f023b109a33da9fc81775bd2fa3685b08496ff0ec0724adf132dcafd60a95295fda96aa46d9ca855a2248664bed515e0d6fb57e6caa1fc1f37501e35cf86a8476bfa41b4636b7b5d3a49673ffd1dfa61a20fffbe32daba24d30f0d342b6f0ef8512e9b094fca29ff8355fa394a0d1a500eba62e3b67fbc8550375102982c0c8b95e63a2f91fd59ec07f761382bf3b86e0f4d566cbe4dc0948e444fc8dd2fb677fe840733069ec988572d240aa6f1962b8521c107c41e096e483d44da9e57626e5fc654052a45163a10d5ccf98f7dadf21a431e51268625eccd8db33d78bef587cb7846d10a400a3f9e897abcc221ee9e82bae6c24bda08782ee52048c4fa205cff0664060c1cbc117db1bf0c3a75104407c2d5028aa7e69342ec0738d0828fbc8137f886a95e06b6e6f01a56dcc986441f6f381285330f093f72a7edf774d47fc1d95a07723bdcd3a5e497051f692792848630c4ca7dda83c77ffe04b902976bd0aa1113aae7d93d88c0bc8d36db7a1ed9576c6f005eff4ee51a71a05a9bcbee489f5f7f1670e4586ff59947204142738d6e91f6ffc47141b099fe0688ec175ec419937ad46d2799e0e8f28b9a9c854033d789a729f452961595a321cdf4ff910f4d4d997d38f1336d53dc70852ca4d7e5f53ebfcf302fef4eac3de58098a0af31f27181a6772308e8b9e1396b105ccd2df846616fc9c1cfd090d22405de8c52ddda29faf5fde986b4159d00a95d280c74591d263c3f44fa9a164b9b25c0688c2a5fa72b5e0e5e7c8a2fcfb0cfd266128b842f6169375e154dc386fc7759b57919396f2d3528a3aecd6044d699a9e2f88d834f52071364db670bf3438c80eb62d60c07ab85d524836cb7c6e357f0a272e29189536c1c7a29f8858d749951e98ccd766d116cdb565b563a97a3fd01cb273d489a32679e685a662c5a6f133cf280fddb80c6391a14239c15d2412cfb51d81f85a68e4ff441c2b2da3a724c7dd96ac7436fa028e9586355056162db9271f90e96ffa8379620c15c9e026b824cc6985ad264d81b48e6b12d04e8804832d232234bc68061bb8a98f35d5a925fbddc2c449664061e2c3beab3c29519974d8459641ad41a2aee6b392ae8ebefe58bff64583165d06d006192c08c47b73a82f0377cb2beecaa980c47deca638f4fafc51af1bcacf5f0da2fc1e34cfda4be8f5e68ddf957c72c1a75b61a933b2f87710bf1c44ca63929dc909d367136c20d1e6d90898a9ee8d6de86e02b4789e2aa70d29429e7504a6e0af9e7998f2befaad3382eafdfb0e05f3e2ae6d1a891a4227a0fd29505a206626ba1fc5eaa94fe61a14feb20d30dec0ecef2713360d6fd26c9fdd28a15de6d0a49636f696576daf892e097efaa18918ea620aa3aeefdb9267b522f46e3384697041c994dec46242b66f9cf428324d420c42068aaf0c48a9c1251cd991fa70fa96a9332e2b057104afeb10c6ab613e75a3fcd938c2a0d255915044973440029c79a04ecae421020422e049f401ef60d8861a8d3a28bb10911c9484bb5c466e9b45a425e8ad4cbf1a2ba20da6c41a5c3d583f65cd0c7cbe6535433d55d18936b13299cff7e2f05b24d4279ed3d19c366bb88936253e8da492456f18261ea0977d1da72bac77637cc50df910132448022bed95452f91b441ffe8527348216ac5dd07318f5ce9c78545810de21d2a025f1f30763c79a652bf603d0905063a5384bf795e823b1de65059fae55fc0a50bdae7e426752d3519973e661f36cb606827e0400ac769979b1d5b2758e8a8f9d0c30f2f5f8d9be03935cd33ae882dca0bf0705a02d9a2775bcfc2da1b42afead27b321fa0ea2e3a1c3d8327fd9815c80364197a8929a39b3d44750e038dd2cf9ffdfc4824235eeaeb38a5ae1d6a89c350ca7f4a8bf0f0a16ec5cfb2b8f034d759b4d33a0757c2b277ba904484005700acc30d92c360ad07c5e30c54d2fce04d18ab5a99e1243192226db3d4806cdbb215f1ab63bff7428da9c5d82d18986e8af37689a7874e9e85ae3e833808ff804398e403e25875ed6bb0a78f1989573947fcc4a1e0d8cd23b1d4112ac959c117dcbd34aa369ef9ad611a8df20d8bd3fcfae897bf50e7f1c367c683111478ffa9f8f7f8ed3c6b7e93bb4ae0eba395a905980765798dc402179380eb563d5e87ef2324e936e6698b85da441124ca64b593d85b58547c8cb93cfbba4f5e93afa155d5994f0573539ec2a3518cb306030118ad324e474251557d3cd60a08282e28261d0fd23c4f6117ba5a0985a471710aba5b32fe42fe24ebb54d05a4b26528d4401b5dca779a0892eacf887db5958128235b251a7fd98b9abcf6e35d243d6126d08f61444114494c8f26897e82481e0dd1e7b467ebf8dd2dd55d4af47b6506162d511ec9a0812604b601088715d7c0b25ceb6b04e2b0fdd22bdd10a9381c50ec90f2821ab8501ffb5ebe8077f815b01ff3d99f75242ff3eb3d626df7d3543cb5b6ccbe680b30bad52f06d90d7169fed088e66462d3e04de92067302ab5907db9af2935709f1e65d1fd310865f3add6faf40e3492c82898067940fe3ade7f8b4b0a19b18aa324b76a9f9ea636539cf5f6fd634ee34e17a838f4c75ea91447513ee5f35932dd20aa650f0affadb66239964a7cc8b3fb8aee1dbadce1334313dc90af8b0be2ba422c39074c29337e8c514095f7f221e56362a2a1e66a5e13545ec104d1484c1d09f36d8ae2e2026f0acc8b4dfc80fcd9ae089440e95ec512e122f6b32421cb736da9f7b7362aa8a196618eb9d23e20b528568660f6dafb519eafe02e11ddb5418595a3c737a7178716e7cf5508f48e8bd4c456e2d225cc31408c23feb2c5010c468e5fb96a419444ea81af138eaf3c510b2f7f5b7e95034b4432010a376a59ad49aa6a8f81b8b3317839be7eb81aa08b3148428e58a6b73e65589cef0256c323df01c919e184aba60200a98e5b5025e3fc40b290c71b985ebaa6c1488c95f2587b0cdcc599c3401f7430510e4e06854a7e4aa5532b4942fabc42f35345f2e28c23358f9b2692bde6330d5654b2e0701320454630ce344aafd54d522af6050d8d13612f762dc1803fd4e540ce9f6dcc62c041f1c4f3b0b2d5255d6f4c2c6150ac693204efc48ea4e6c1d7f2363cd7cdd84e1fda300a1c9beaee54164f3fb657105ff052224169e5fb321dc317ee9f35a38513bc8f4458aa3c5ada17f715bdb6b237e8ab9fe0430b2417747bf551678ddca1d59423307c6faf9df2cc393b458e7f9e54c87500d47ae39dc6e8b5a41ff8658eab3e65906c66e18c44dd33e54df0ec17bfc73eb3c08ae587ae64174bc858dc7efa396170b01e9bc9c2c0b76a6c6979c3d22ceb889302b289ec89b23a4398b45e8ec743342b1e24930bf502d29a1717cc63961011c3e710523efe3570199e4eb75c48f50b619e003de666299cc2a9e470c7d6bc1f9fff6b6fabf9c9f5e85bb37b4eae0c4c97255a9605058bac9c90c8b4eb9dbf071faf96e5e10cb3980e717368a451404ccd1c873a0c55877335622f764344182249dbd2ab76d8e786375fe4d4e6267214acb51ea5acdb579029c3b8df560b3ef56a0fce3a72272d018a801e28e91337dcce5d539f6b75b5bf30719969ebff1576a834fcd9d6367d4b2d9a5804d032508f17bfc3d419bd117cef73660b9c2ec1f246d1e4045c4de08d093ba6ed31cf1da934c0d5037888c0e9b4b1da3dfb396aefe6dfc67c2bd91800cb443753dd13fd057fc0665ecf37931ba8d1fa59537ab8e8693525c2ad55a8def2a6ba64ef06602a1058503f059ade397a9faabc8be98ca7ef9c7345cf20dd915bed9ab44ef7215edaf95a01385da08db818921ca8f101cce05b2ec903c15cbb127dd4c2925b3e7e30cd4875180634f53f62f0e485d278f39a8c6811860db84b6eb04febb33f21d3b3373d9169e465bd3ef13ac9d7a2a3484eba0e01d0e8cb2651fe9839d7de73e0c899c31903418e133e178217b06ee1fa0ef6430f6a06a6fd001d20de07b8d7ba4dd13615a07291dc02dbcdb1679be4ddc5cb492c69d346e6dc2a1466ccd6d6360bb8b7a2c720f88c47cf9c7414b370b293101bef7e2d35bdc76f563fa6d643349bea699c3d6b70e3cef68465489f2e508e3feb2fd3d74a82117d61770fc7a30aff9f4e0e9807255baa0522c91c18cc12c2798ac895540baf3c01f503774613df89210e689a28241e8ff56e2585199cb736cf6d27f57691af8c327ca2594cae1942bbe9b3c5f6093148192fbfccb9307b8fbd5f5cd519dab15dc23dde3de0f8a00428e92ebf66f4ea83cb448ed74c2992b5e49ec7a30445775fd1437a220eecc8bd9d91c6167ab00fe074eccfae0a07c96b0ae327b70c18ccc7d1c918e4830a1bbc505baa3f6832687c1973fb39677f63937468d880a04402690006b84ea0760ed494f811ff050c14642bdeaa3973850036a61c60edfd8a57b89c7e64d51d9b60ef98a787110b2c1d70155674288e2bdebafc6b0da6898d4f60cb6b610e055d6585581261ba160c6aa15f5978732d188b77b8332b52c9b296b34c7ef9172d4f51d729f36b153b02a292541e143f797c838903e204eff22103a519c11496d2033db2b9de0efdcdae2666b8c1c347e4eab47a1333026d5b3516fbfd1752878514b734e894ad82d57a00ef9b2c0f8fc5dcd20b4cb87cebdcc2e813c9836f6a5329a913426b150d837525e94bc2cfae755d744cfacc93b037531bd7b41fb3d07e9e90e3f89d00cb8adbd3d0dc3eb585efd282125b916e0e7729812b3af2f2861acdc84c658e0f193b0fce6a09fa456f60d2472646f9a08e9f2bfcdb52786b47c2ad7db3156230a8b7cbc04f87c80c8b81dcfc1a9ee43edd4bdb2ab137a7eebf92169daf739b464a84a9c5f11c488ea234c7d372d1a6f76a3fbaeb9edc0c27baf5d2b77be43c9b63c4f26bbfcfbf71e726a24b2852056c57492d424243816ab07ccb0b05da6ce2f5548e9800611ea169e917a80e6b9db8091d6c481e113137e638fe5c6359aeb6b4df23c928ac56dc65f16eac422188ab5be1c66794e5092f39ce554e928fa400ba514e8395b54d5f0ca0db6ccf9bdef10be676df38a89d6fa1d37f34bfea2531969e98a8980487b0b273e6ae44b45988f6acf25cd76b4d0c43ebd8a8c49ee83daf886f41713e1ae7601caaf62b71efb559bcac696edf15d85955e728292ef1fc70a3b502c4d66a55f8668bddb8e279f0b6ccb1a79ec0ee6261aea3446f1c1388e9f559bfb420c1940c55e872b47435858e408270ba08489c907ba1608a8980c812b788a4fa72d0821668e0b676a921ce8929cdb69ea698f25e254d40fd9bafd4cdd0b0bc97104db0386648d203d90a0100041843fdbf4bbe0322c904133f3df0391264e2f34e72326a701d26b8601205b869489133fe962cf5b77dd2fef428b7b40532d34a369d6746ec8172dcd3091606ea12ebbd86ed4eca8d8a251180f398810144a90c95b5693cceaf5feafb9d1919ded5bcca64760f588c91b18328eacc2c021f7e519e2edc2ced59f1c2b3fd61b047f09fc74be18c9c719daea35e73ae8ab40baef7cc1fa0b77b38c32d8b1d897b9de10f52d5d0afa05bd9b82f4b27c13e0f5a03117e106f8e661b0a780b4f4c4e2fc1244c880889c7517f9c4a2ceff89f28e4ee5a7c96ff2ecb3555bde0cdbba16b41e54c05d678ff353e2fa106a6445f0e6a3431c9961506e7bb95a626d16e52ffa0a4bb15a0953c4e9c228bedcaadbf40d2d52d96eca69da0e613cb6b9faf8dc33d4508f47ee535721b9de0737b374d48a944d11b041faca87f64b707a0afa4e6267d0c41c3aab493467c188834ccc7700ee83e6aa328194870fde16ea2ebde38ea957b2c22416cf132137681fbcf12cb5444b52a56ad07321030440069b893f1c196a0f82b7ef2ce1c6c7d7d8e9c1a20712044358d2da708110037441207a927c2f93fc8bb322d7224f788993e14decedb5b5f87b31e793a05b8731935635fd523e9d94d6c6f40a20825d9ccf38b08f53e8bed9d30cf8f03cc8ee077e052a61ab890b00043baaf545402ffce16cafc071a5a2b2461908b94716dbe7936388a321c15d15aad6fe9103457a0da099791029f6859a5f2bd6e10a77201b837e5e418660c643326e912877016605b11025b23698843df9dc96f736ce532544d54ff371000df21188cb725529ddedf2e08119dc4dc9c2ab1cf5f85845192c0adb9c67fc336f4b52aa8e5acc05e2d5733c18e6d473346c39c6cb4acafa55494c0ce4260f5b8830f9132ffe0aadf27b54e2fb9f29c90b6a8d4cfb6db8ce79610c9c025b5ad147fc1c3c70c1ddb43db0504c67a99c2f9bb117999584b35d81538e1de6b80551e6b2a96945bf4f0b911a638e4a607aa781ac1b72dbe176df2adc502638c85948a8fc589dfb28bcf70e0bd1cdd506c638a199ccbfb7f367c48588b2e8550e7aa842dc39aeb19ad7bf38f45aa70372e99336e9de57fd97ffca51254053ee4569ee871efbd98e99d4c9e93707aed19c939e048a3a7606b2b93e90d7b7f13680a853ed657bb94e3aa9179c55fcb644d96d0d7a240c71f9cda8a468248253bec8836d4b302e137beed82a615b5243d86936c69d2f731970d433215d3ef4b297bfe796065891f8217d120f7f55041a363516f50269aeb354795217b54da90732531a9ba7cc4f40638f42de83a62e4244d163a4e418c22c91efbbd1de989181881511884ea85763ff70f228cbde08d81bca164f57fb6c52a898fb252d2ba91f20b3ecd1d696f1001fa7ac4c8cb4a3d3678520617a93ac4d691fb75d5cc205a88d373dab27550747345c913378f24669d26a0ea38140f4424260d91b7d0f17b711bcc9c9e202a99f2e46ea3fb6506cb57f56b5aa8f49eb75aad6b2736aa9b18caae2a88ed551ee4fe05fdc041d82c4f5a5fd62022924534cbad0ba7a2a9af6b125800328947a153f3718005ef282b48971a804e65926be48c83e1955b1863f25961aadde7f5a4c372bd9c737b4dc8e74d0ae682f87485bacb832cbc6c03bda9ccdc4fe879a3bd92f38e66a32f4c712167d4f52537beebb5f586cd9e74a95fe852512813c659cbee6ab1f8f2c242e3707f783ec6f8c1a9a06b570d61c8ab35d6c6ebed36cd204fac1d94f98e71aa470fa1438866fb216dcb5e994fc49300b2b58e1e967bb128fbc9abf3e9ed9c3492bed2e35ac56e78862ea668f86cd6a18ff9aac55c6f40daf1ce5db408134a999d326961e1a800d21d43123ec9d3d28815bff8bc5992c1fc81746c20f50122f3179ed75a48e0caf20d1d2bb753c7bcfe44b17deba78a970a37c5bffb4a2fa10eb9311611d0dc6a62593f089aa67a44b4b54a513844a4e3874d0f6aa925bc6f0d0a54c777875d39cda512ae3a4e500a7ddf540adf71ed60f8a4e73a83ee21e0362d4b492ecb4b781f0f0db0164cac6e5b3934ac18fce7e7f34b3b98052bab7c7d471072edc794f94cf5ed73e3b705e18c351df1f839d08f0fc259dd6c756cff16739a2155a30fb23e251277816bb9a043e2ecd9fe5d11852de9563a9a186231e2d905ca3ca321237f21a74da4069d7c25daf3e86729e20cdc4ac9ae0a2358b454a599387d4e9af3d931c629e58b983ffe14ae33892b1688dc688509d0f3d875cb110a48992f3778375d2d3e1f89abdf37411e3d4e9b2bb296384a13319905ada487faacec24b19deb7808b80a2e45bc25131254f919a7cb393bf1696befd6a7c1d9114e0dc5b629dd5fcfcbc032b244bd6c10b16b26d0181630bb25fc486c3f68986b0c79d0e916904d0ac3dd0267cd2f0dc90b8a293b446e313036f84e76ad7ab54b5cd86970b9fd5905df758777b0ac95ebf8b11edc47b7f6ed26232e1568b82f6988e071ab3b4422534dee030bc8052ae209533b455970eed4a1ee232c29a93dc54b1e82c95406156a28bcc61d3353c84636b6df9421552981549127a89a0bfdf83fac8c3b854c68fdd6d0ade64bd9a830ef6f3e8b12769a61a4a5652083da2e0a3d7602a8561199f4fadd0f5d6b9a7fec1bd8232e40f63c7b515de67d1844e2615d660dd412334b65859653867551116315d18c7d42687304339525bfe0c96597296d51d10d43f0992573a5e3bbc9d4fa65884796fbbcb299016efc2db0b06aba8175bb88fb73fac8aedb3b4b801bfc7aa3a74dd218108f9e1174598b2312e303e001754ebc29f915600d55e5b0cc51549f4ffcb02c854ba92ac19b2e3c465a5171e8251b205c98135693473c1460d8f5a0489018b20dae0ff230a3a44d276ae7ff0c59ee21463e8d30a3cb2a0a9e95e32332fba5c682aac8e771ed8eefdd148f6166a4f1dea1882c5aa3737e9c5b232dbe6962e39cc245ee0b5c0034fd02d958962f60aa6c7246dc889b96230a54433a7fd1db6c58d4e60efeae071300f6f8647a835f2356e7375ca68e19f717c0071870e1530efd7a0cf99034c17cd703fd90f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
