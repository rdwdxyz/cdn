<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c004bbc29215afa6701412d3886d8e1494186a1735f7170c344f9d9e7af37802f4593856780f865aa83219b7dcef4073a90c8440b9faa33bc2f22b65f9b76d0e2047de8bcf1f9f14ca35aef46e111ab927490d483016cb52adb1c8da2a837db59e1de66e4454fcf652b623cf4963e461cda9095fb32fc849c9cb1cedd75c1bc16d6ae5d7b731a8ee0935bdf6f98a7ed91fd94ab6f86ffa0707d15f6cda245b9717eee96844abf668079c4c03781ee3aaf6158e302b5e1b4c248b1f12ab1178d5ff16518489752c835a4ae07bcbbe025b00fcd2b75c7746646974fab997aa018d566db2c1284e90fd841ea4c17f12fa1a1d80c47ebdfd02bcbc470a0165b1f52ff018bd6c6c12e6e5238887bbdb7dd351c39e7443a95b11414efecb276d7e8734a1298817855b4201117cd143db1e2e7fc1da9dce89ddd82b4e653458ca25c75323df1fed6cf0abc425e3160c1e4ba965e7a7763cc116303994a5774284a29493dcf7ff82ae015f6f13fccc38f10604c591ad6de708c9b49f02e5f45cd3292f18e1fd405981c2ad618ab0bedaae9c8403a4c50356ccecc32e6565e6814e459f76fd85676eb6b0ad4e2c4b7489b659fd18a434515fb206299146156ed9cc32d3cbe0cfc54aea311223ace344298878f1e093560347428ddd817cbe06bf452c3ee5d21bd0f82f6402d0f89196448483581e5c0d916ea8f6505923cff2e3c564b6cc9ddf1467862897ee1f563bf9fea0aa58e0790655d830dda5253e44ce249aa60779e3240fa92452761ee91bbcc40d0424f1face8616e168a5d4d4978a7b8b0506cd6f4b04069ead1de7e46eef58ade010cfc320fe1c324f921f08cc5f5cc9a3f913935c8b8c91864d82b625d48ba317511440e228ff32bd9f7706250cc540d2456f8858232c8aced267d044744af1441e100afc849bf6ed1a8b42713a457f8fc560dd6b68f8f3a197548e8767ab5f1afa75317a39f1611c3ae8c2c2a013a9ccbe4a54a68569a3a67883670b35c5b7c9a994f189e09c2aa270b61aab30a7ceae0bc2711f842f45fa417fc255f69921d4988922c057acda07bc80c9df0b9a4d480bcc212abe1c99992a297d08b5cd09e4c1217b6639851ba16a49452880ec4764c89105dc3fe35c4dfc94382c767917b9976acf6191e581aae239bcba997267e6c448b2c0e40cc7b01e1bd902d311c3f94f0e39ac6b100f5731382661aecc32ab4ddb95742ed09c7673ad62c0478f637f2e3aee66d062a4065b3c56458ffcdefe2f9c343e0428f83d5abbb00f623363aa8df1041894cf097fa85b16e1b97bfa84c88143751c7967f770935ac101ef2a893b7f312b5d8fb2ec4a08fb707e8a0f32ed60468b333963c5f300bf49fd1e48782ef7b1e312de1a3f64799ebb18e845742993735f4c033540b43ef7b77da1b4817cfea1c39e65fc3b519cabad384f06880a9ad68a11c8725cb196ff7eb1d9851c21574bf8b70c89a9b0050c30395b75c930b7f29e244eaf210e5c1e3a48392efd99a5dd4c110bc1f8c61021c1281779e5ca39876966fa0bad7b426713952387f8b6155540a4ddbb1737e345a13ca0445ff2889ad9323518711012b546489c8b9c73fda2d479489e47ac12d390feaa88e59b5f07b78ed01ed73dc6640017b4012a3df84a14a12411294ea10d0fd738cb5740c0857336b394840feb0fcc0ff68bc8b6d173f52a3ed49cbc9725366afa06820590e5252e9d81c82307aefd727f24ff4ed560586041a6c73fae27c62f3d4a71c5da4a172ed4f907c5f96a279e3a29b5b7d63a4ea38100f390c0f472d40d75b8ca49fed18b1be05dbfc286d34689036d50ee920e2431a17384ef89479e85370afc735af1ec33be1fc2f4593f8b2e8c204919fe9f3c1b935ff1727c044e5f42bbd873a64479503e653e6bed0a9f69947e932d03b322ad0408031b993a1189677a4a17ab21c50c69b98c19286280b69f120fbedfedc49f8d9c83bea115a6a10919f1d8d2884ec7adb9613b8ad4bd54570e65a5f4e2938a7b85943c11a6e1852ab7c612fde1ab8243ad646c00a02efdf7b7ccf6c852f4fa21ec7f6b7b1c8f485f6d944ef720269a5558ed7a5d4b7fb61946dbdea01f0842c9880c1bf28eb064a9c1256f29dc70f3e3604f885bd3c7da0d4426239fa96b89caee9e1b0036b6bc9e9277781d2f3ac5e8ae36499582435df9ef14c0290346b94e6789c58b34dad53171f8e5d65a32633b22295c5a7cb140609afa4adbfc4c6a1286a630b80fe555b3cafad9b7ed551572ae7c67c3f619c2bf8e643c0aa393b6689e375d3f89a4ee213db2967314a7aa74bf3723de378c4545f5cc581841074dd4121dea0d7ba7c3e0c368cd81f3fc690c424ee5fde6ca0573ada14b733cddcab2794c3eddcc8328a91721d410c06f880a4f816cbbd360b80dcfd21b81e5293290c836925e8396f350df1d693013f24b96e0ac8901fbd5a95583068aa0f8f6115e35a3235f36fb7e97434e6474794510709a14bb0ff937d3b420e6bff0bba43a5c561b7e6ef2767fd7641c4babf44d8b535f47cb1e7cb4ca8788f6cab35a33e3c748211344f91ebeaebdfc19f46ad9875758bd0569c774ca26e24a4fdce565148b83066e4f8ca18fab6197cefd0c1868369de3fa92ea0d7a5679e3172fe7618585a5b2f571f7e7bcc9253151c9df392ee94e9f134db91318683dc50cf3920627dd0f8e6d2170c22d93048ed242bee8272d2d6c2a1a1c51ff54bae6f8326862dedb7277e6a1cf30f2890859c26575db5757ddf9ab838b1e53006e21f4328a1ce8409fd991c5aed65486a023aca350ba1872981389491dce09d8d2ad09fbd93d48133e0d0543692f47ecb0bffab68f5b9c2087819b5aa1fe781840d79a81b29a91f47831ac757322b6a0430e4d1ad3645f6298ef5ee28238cec31645027393c84a7d895782ecf1e09e8798c0c4a7778b3551e1d461209ee55e61a0afa21d90032630893221c6a41f62f57211df780dda36198a9f6b5a1a58a36f24c8bead690455afca7e4692445578e360c47d83b0cd384524a4f406778737d77a19a561e1c0ac115c3f513b9e088a2e23a1dbb40ac6c98c4f9be883d44c2d6ca0edf758d5581e0d51140a509a6c4ee3c86d47862189160257cd7fecb788e77fdddac4feaa2b1432761a2f64e55c0104ab0d67c8ee305c816812178723cbc7127973daea2b8ce50d3442bc7e7904a3d1f34d9bb6bbe167c0020e8cddab5f36f74bf02611e122601a3d7e950095d4f74ab296208566a986376df4d4b11737842e49a820d9b99ff48c99a503bfb512b9bbad24bfe690d765490e1de0d07e1d0181c09c834c219a97b34f70c7b0889ea3992f17112dd3e8cfe351394df4f96d08113e9b5db4bf2a2491d66bad04f2760d762bfa938858e9498f19740df77cfe17746c120b10fe28adced0126ee104262b3eeb6da0f7a3c4321c3bbe823e18fd0345acc9dd5188cf995184f27d9f728b31395c1541bb6310b4122578a436ff51d625649663c70eac0b3472107fafeee197cb3b045c58803d7ab0f3b4a089303f0670dc99af99fbf16d74c4df21968f57f5c8383e0759140a6309f64ccc36576a8832fc3ca6a2c3f3afd985f1034cccb9432fe442469b9f6e59fbaaa9a77f99ec6d493a488ffb50ff1651a898e56420d15d46756029cda5e14207dc9e6f6b67dcae326d6a2a871d3895a0c4606bfe0d43ea87934f758d10cb2fc0ec99e2c9f42498c300785bd47ff3c9ca855deee5ba920f94846a01e992b8617811747afa8e8cd790108e98906500937a5b48d89dc5adab577e9e4d08d9ca1935f0a272cb70285a9c8f6deb19254e3fd58b450fc7c0b7820f6e99caf54222d349c034adcaffd9dc17e75beaf417d16b810af5817c67250a2592062ff1218dd64d6a180e32bb7c335cb2f7c6b5896390431ee62140fc967c56861fc12d49a9ebe43afeee67a0a55118700a61ed8d5cd102c3eba272b70e5019e18706b4bfb6f360883bec8fb8904079affe701bcc06a8469272bf054e761197de53a925915c770e477564bb87901fde0c2db29afaefcd910d229a5ddf729a181f8303eb838cd0e8b2ad0cbd55074320d514a07be71a87e288ee492b0c8a12aac615fa0d3694593aef5f0dafb898d17504b8d027cafb9e082a04d3d658d08b99e81d7dc12950f7884af47f6416a954c5724f3a3b72817e46cffb32ee348c041fd6713b5efcba2475f2312e7ff9fc0a951f5641ab00ad6c8119b1331360abf8977edacb65b5c93bd616b44160f5398669d5e748304a8653cbd0609c15bcdd8059f7878017141e17480c022a637db47713d73f0668dc22a8017c69c135d2b15c84d8b345f65022d3af6eead02181208c17c7d4b75060c436adfd879973af1d4739188d65f7bfed0ed79bf4a7eab23e62bb63c0c379cfec2a25a92f00d1225ddb43e0c6ee5d34a766ecd80defd3d2be7e727204519ae23243b6c161bfb14cc8ca96aa2103b85f3a441aad86c57d709fbeaabfc7b025eceb7fc0d948cdd0ab1c07e2602b26d77917d064547b2475d575b1ccc7948285d8f1e2eea0f9eed1c50c6006427531cdfc9ca3b2785ab397d0c3053c2e7e1da03ce5604f5769393c1421e5f62addc00d1dde5126301e6e2276b96529c190bfcfe34b00435682ce4775d7b989275b5c2b0060262ac2f22da51fc1dcd75e631fa8a29b66d4031e60929dbdbf10b8f6fc24b99c34e71a5454e1225b73ab58c797f04b379da777f2ad8266574dbb93dde7af2bb86dc8ae7c93cedf3b8e7f7e9e584216ef914e3168268894f2b2b0574d6324699155351c4394f68beda36c7a9b91ff68c56c84cb766ecac0cd808247ae085b403ae200c7048d83c9ae1ac3f2ed19676026d7263fec3eb6065e434747b7f759c2aa08a415f403cd33ae34d823bb24203da223fe0a3d1a9ec1caa9a84b2bbfaa1689ece3757ea52adda18fb421dc4bbf8cc080b44be31668f8c2e4bcd6f6917bafecb991895fb7a1492b0fa86ed070e1d385be85ab2d046a6d8e31968447154f3842095630dbaa5ce3b82f85464fd3fe0e8701727d83bd5f25317cbc9e932d473d9c3e85cf69a2126191abc525957c9f7825ed294f27a12c7ce07dbd190fd187f734e4d1e59dbb817714307111939c30e6326f2049ba22ab9c10a044a4215c3af7ae50eae3464184e25c37693055f63fd110d01c3d676cfd011606a10053b0bb4bdbaa44e030ff319c06a9c9e96510b59d4c36e5021d8b24049b69007e9488ff3b6d19180c9cfb6ac525b514608c974f55e13a13d4261b31f4fc6c176eda40b3861e4d9b7c505b65dca474b17d60e6b682681b628bf364306f294960eecbc6d1b84d6c2f77084c95ec84149c7ba179443449082540441cde60ae851d67481eae777033bd2fc8bda2eb85a91e9287af6c6fd2f328cb7fc43b108057b4349e5aa2fa474f3f42c419a5585d7bb72e9eaf22d7a85b0b50c29cc32a2c15d2fbb8390ff7ce3ea9473dffcbef46b8017e8495f4170659a4956a871a1e55fa0907a94cae5b9f217ebcc1bd7c000cb5c751d517477388d97a3624fab9a0f6a7d9b91e5f969d885bc58cbc3e6452a542090b4af44faa6b74591dd63dfed7dd0cde148655f542aa93e010516ebd26fb0a12a4e7651881dc348ebb0012b278a6ad68b8d0acf45eff7733e0e51ce71b19d20667957ca4394536a5046eda16e14f9576506b8ef825fbc696302afd935c3fccf35827c451b41a4029c330abc588a6bbe106a2911d084d1d2e79d5147c96d0abf7289c9f340fb87769902d5a4b503af2aaa525b16076d1915ddda8289ab23f51d308810ad293241486b5e44df676b387c4b5514daf8750e357245fd9f6dc0fcde211df3e2a52c4fb87c7a9d95d93c61262571663b9289ab7dc14b65b2ee86487fe6ce2ed5117a902132391e404a94a9ad39298144c03f7cd59d71a2288fb17a8512ce3584ecec3dc4174e237546b510bb7aa239939666c8125a09da631d2acea654d22ad6f2c5d6a094447c0f7a25824ccaf5c9f416fa3e70dcb6c49b71f2f1985ac4016da826da9d06c3c06f2e3b416d9b9a44e2fb41fba4ec263cd9fbeefc7c0b68ac2a8ba9786771954fe238b402278945220363c063a7c1a8a33d8bda5a5aec03ec1dbc617282cf684bef4fed3978125476f59c4848009d1452d7b398e21d6a35b97b0c1c06406ca7cbb248ce84b90de5eac550a6ec858296ecca40955f857812c195f273c1ded0f14d48c913934d505c231b7d9ec1a1b0f44f988cfd46b8ec48485811d99e1ba086d89349d97423a81cc6397f2fe6d964c3f1d60363615b42fa01e99422a47b295b1debecdc595e11e098b95933eb1fc4250f5315b8f487517fb39d1c2097c464aa2be1da4e952e9a917035ff6a0738a3c9711afad400d982b0991412062a8cf96ce28dde896039767f3229672403160a152ba8507cd8053fd16db57a3cc6f891c5cef8cb08956a91f5d44dc52c11615f9cffccfb676f5d14e97739919f9d58ec52d4c75fb0ba16d2de9aebee55f59de901f4d01f79298757b9ff733e0791b4af045eac55d506855780d6d8b0abc396bff19e63473c99bab55393549171dd8f4bbd6d6134f08810a770cbc0a56b362d368f68f5edfbbd0fc03841ac1060ece8e4515147b696f8d2db57393d7eff879549e3aafebb721cee610c5a273b303bf522329bc0e36039341ce2c38e1470642a7574cef8bd968bb5c17da1789f3c403cbea1491fcdb03e129caa815d83434d8890c6ac69029eb0b884d4e49e772876e01f3df002e49746d2a9c15e7a8b5bdb0a4968fa54000e39babf8f8837eb3bba51743a5200643aca898948b32b7a14edabd6b9a36985460dceb8210c4cec1c0b0e018bd7367a31d8203539fc89e77302060d139d267de55d23aa2f63caaf5d18f8c73f651609c05737dbf3ee80e53f9be0b215c15a2c255ad42c0c18049d4d6ac7fbe5bbd7f64ce83853ff57b64ed6f3ffce396acb2df06a5e6b18d5426e679d0d2e155ba42a0317f771a547c3c171b1bbe03d2e1c4a6481e563f7f8fd67bdc3602e3623e3568d3954ee9a8a5a9b97e1b17afa96a81642d317c5964e32be717a97b5ea7e58ffcc9da9cc76afe8260f365d4bda843fbc69dfc345d0a8a9bd82783ac7808cf50f7d6ebd1b5f6daff626282c69c6aadf5a35398a7ccb08fb0031340c9e76f12d8f826000b6cf2173edd3f79bb0139b3de2ffffb511de07990db9aa6f62296e355d8aebafed72cacad380e15974f04f6081464bbc48115586d288633fb591db4934707f5b2be1c3e8dae996ad8fb5fe0a48bb50de207b75c7dd3eee8f1798aca00f6ee268b208dba0c3e999d4576fa941acf9a968783cd443331ecc19c7ae9a40aa33f179eb9866911a6b8476bc3eeac21e8d41bce1cc5c5fe0db493c2e936dfe53b0e6eaeda27d5604caaf8e948519967f48fde44aece493082190e8c741f52165f561ac091ef9e562766b50ac965e8469dc9cc3b647ee892348ca87f432d5e413b511898c08b5285f98c417d9b488f0ccda0ac07bfe79a29b5d835761df4cedbf5317f53ba0cb168ad5fe8f0e9811fa4ad36a48068058315f8df76e073c8550229a7b921d3d1039d5f892741da5f5e6569e685557b2a391f0cb25c3a590addac9c6ff5dd0570c47d5f5fbe3c9727b5709cf059886480677126a1e5de3bdb6ff8575d31c57fc4c069c8c21f9b9bddf006c8b25ce4b7be36a6a5d397953afc49bac3d6c34b0c6d145efb83d60a88bfed3c10ce3e529159cfee3808b05e819b06457749382335b49b3d27172071b092bd9951c6a4e034f24f78090a562807ff8a0831e18b45e24e479ee518958e059bed55606e983e0c83e287aaee9006ac786521e2491395b54ae711a0ae2215feeaa873de17e6021812670732935cdf9bebd1b7739735d26435dbf4017eb9b8c5a8d825153f5a2dd40a345e57efcf2f9b75e4ab8ca4ce69c1602e5b440ab7dfdf91c45e8f99cf14772eb5973289d4c833efc865b9d4618ad775bceaa3df26f1378d08f2550cdc6a004b45fcb3a5b1f09eb3c5e78ea704a53a23e3fe6f7f60366888ee09ba9d6138ce306192792eab83b05c97f344b718f73b9c173671cea5421bba843a42472407947d90205023726aeb546997268354da4d9b2216415c6e7899d6cf2f416e50ad9584b3eb02e597ab41d7e47db0baa18955e937af3ad86e5309ba718fa3bc5836e452374cddeb7bb3995efc86907defcb1dd4e93bb4406d3170e7f2f8c8abf6c3658149a288a002bfa86569a610c8f6c690b499e25619d0b0cb1b325e8a5a5d2b80a10832611a80bdd26390321b7f3ad6329f4f1c0e7d7a62779a5aafc9a37cf1c50f81070a4e955cb5fcf9efbc6a85cdb774eee6d58b3bee95bc89eff3ef8d503345df3ab40b9cff0791b3048a41f84919a97f381cdc0f70fa43c25443de15bcc845d06b1d51733a46a3665644f5e55c2d2f91b0a5377c35c7a59da71d60f4e09eda2f7a986e290dbb73c0512e0859b0c017cd8cc07a4312884cedf14657fee8761b65e22fd94d0980a3f95fbb79439926069f8e0a1298ea6ec93531c776e5af5cf4f6722dd9d683699ee61fa45a38fd106b6cfadce9246b96beba916071f90349373331774ac34917880d67ba47729cbd85f67054bad63f640adb3ddedc177293c592a6e8f7ef0eed9a8d46be6db8a9660dd1170e0c5d8ea9b35ac0087d689ddadef4b88af4f655a420f4287c994fc151eceea62763c5a5da0f76084ad13afe20803b9ccea6a29bc9a9e252847eebc702c8c6684e977004a77937d02882e155f2c96e302946578cd302151c0a15433402c9fd81105206d2af183cc31c818d802182014d3f37bffb3bb2aa78298336a103d88bb46e542bc11fd421ad02b119f9f4c43d85fd0fa6a545153440265f33e16661e07f24b917e0ee730a427d606c79c7aaf59f614147000ffa8a7b2f9ff2a827a55f27ecf8a9bb92f19a1fd9a24904ec5dcfa19d8b9c07c93aeeec1224baade637bf937471096eeb83490c657d880758bab33f40b701c854f764aba94d42f2fac0eb5d65b12536818ab404dee06e130a13b9d82eb0449e2c68e0182d3446f792deae6fac90f36d29f20e100b49658e3fa576328157316b206e29a1e401dec6c4a9d4d1596d8099b05caa580e5b5731c72984bfa1eefe952235a81c7d43450b49f579f9726b09abb5a5901928452c045355b34b8bb20380d159776bf1e887bf135afb86644fdf7eefe3cea7452e516b8680b4cf894e91c8d7a5bb11e72238af09ab672a74dcc5f8d0a8b2811577a96a5c5fb2ea75c0bdf4c0103c848cc48d939b23c2dfdaefe528f580fc0c7630b33276335e49a7504e59fbc4a872494741962ad0d931d65ed44ce87340ce1eb26933bc5c68c58db71862a59d7bd29eebc3d3825db98f28e92524bfd3fcd20fa6f380711d88db0ef55212129becbfa607fb9180acec1c620c328aaa05f3365b4ce2d51a912f3968c2e0761a882a5d221fc4eced7d8720528a05c268138f71474c9dcfc3dfe3264ddc0d7c6333182d139c4c43fe7be05d981894cb7daf85284f7335e1901826a702249af21ea0d20026d082356fdb2fd0406520d9280d9a4425a12b258d8b8c1ac04b874e534e9d490e4897f417a5db60ada5418d703b9f5d2a381734f13635a5037541027136dcf8305ca45d437905d826ad307c4e3bdbeb07b3ac4d0a2de5614b8ffa68b701ea7ff72b57b081f3342165de3d33f614934ae1b28f87c65bfcc35f6720ec090d28e1cd0ae0fa9113ef8d8939c0a8467162ca21b11170943c7ef0ac351ccc82fd9aaad156a7a2538703d0809e468b2ec07593f5cade8f3afde20bd0f14ba53f032b42daa01cc774bcdde2e09a404077acdbc8d243dcc04667597207dd157d7ff885e47183561332e064dc9c6d32e21ba9c6d30677cac8c2ed6ca2cb06f28f01d73d852a95fea2457fcd00ac89ded325fedaa456b57f63accb39bf6bdaad8a890b78b4172271c657f0b274ff3823410ffe314bdfa73f6a6f066d78ac328d23a0f531442e1f1d05a66e1d9998297a4f58d71ad9add19b707ac10753cde528da8b98bd79816f407020cea7cf77311cf0caee7021d33fe1433648174dde2a2a2d21286e77e25d01734e33aa32faecc135871b8543f23a4d7afd9b2bd9d2fcc2e54271ce1736d8c14e3006e18ac4c2055f904e0b64931d8c96d4039d6d290db1970bdc2a12304c3df478d65bf5e6c02651fb275e69d1cc7d6f17505fef75ea12c2fc59eaa37919ee66386a7b1931a069543d00859577da8f4d1a124b878f368adca69ac73b51d084ce92e9067c320e11e6a724076abf55da291829a58840374223020b114de1720931586d5b7927dbef7c1923886fd753266414945e2f5ef0ca3d5da87ad1b4c9471f788e99624a3b2375c6d10afb67306b3f056da4b6bc1f16c201cf7b9c9e98163996b1a091c31ad3e4fbd0b18e163e9fc664d9eef20ce100de12bf3f03dc4ac3f7fcb1ccb8e2a902d243facc3550d9f848c3034298d689509d40920971b1fbad505a541a9a2ae908a7e800210b5eea91c573a6f0c7ce94eae25586477aa03d0f7f6f0b30b53b788bb06db0a150d8e05d44746ce24dc95522ec0aec7f90c41255b216a29f248c72c0f3a637a8b66596eb738d6bae5715fafecfcd7c1a7d4586775781c95ae0fadcb36ffee85c859b43e5c929ba70709d9eddbf7b29a24e851945cf8fb5500182171e02d7e818b504ade54163fcebced0049ae36126c3addd15f71e3b2562ae615eb3f3a174db43c9dfa778ed7a48bcd66e495305561c96acab4a346d600576b0c4aec2f715ac938a4b23aa565c4ae79cfec94287ab1a1ca27c11335722908c434b9aff1b004ce16951056f96661dbd8996c9c729446f223cacc54d54468176786e6019b38b01a00537fa108755f03861e5d2f5ff86af1e80d17727bdc3f461ab99ec8c239f571b7877f0b969384bf5691ee1600aa0b50e1f2739ecb11844fb3bddd07fab5debfb370752efea069e7c6b6fd3f5db005ab1a3268bb5c404ad96934d836e5be0526022f39523979b0c471eb46ccb1ea0608ba663a582353a84a6c5c0f7ced5f26d480fe9c45686d9032daa765e5cbfaa2530f571e0eeef5a4757fb91584e9b5ca866bb028f714b168917f71ff9b7cfb5ed8825a1eb816e2fdd21682e24cf8cea4b6361afdd594d8a1e994252740f4a761d2794b3b8552a57e7b41c15ee0c740c88eb11945a2d15574987ec09e55489a4e77a67c559a3b9d12ee5114a5893967694198bc473db7ad9305b35c22b580562ec4ad4af8b4a3373d32e6b598a423014f5abe57ab98d13714226571e71ec74b1d82bc114a8bb77f5e9e403d4ad3c328fb28c7d53acb7d12e292c7ddb5b17ae8d470dc60551618e285588d5f72de1a7c0a7a72a01ecc5984b739de632f366d25ab99864784a69b3f0b3aeaf065d093f6a8b97861e9c24f3d206012669fe067a200bdb2b6884c7f32a26984ee75161b0fb851f0503a7abfc8d30bb99d033a5242c3c9820de41c30eed4f01307f7fc889f1c7c50fc7cb43c64e9a5ca98da71072d0d901c417a221625db65d499e38e1f33316135e517496938f6935992a533bc300ec6588f4993e2c0b177f8fc07b861cd75ebd7c902c9b840d9bd6ff75829096536b853d6bbfc7809e83b8c047cca6e7ca8507bec13e1fac77a084a55034fefc8eb2a970cd2e4bac10c48edef603d20682161acffc87fcb4dc16971bfc7386f9a7eef50b7df47cec12786b58f877b974210029a3141402ab36c140de9d5fa293f65cee51de4550aaf442fd01378ae1f50385f468b0d0b7d57ddef0a1bea07ab28ce92d6d17d7818bbf6e2cffef429c5415a19fda1e4ca48b641359e244f2f5374c0fec00c823063378071e70b4131977fd360baf3f206dc1aed17d912edb2edd31ec45c7725bbd70b5fc6dd4b2701e103408f2c293bc275b5c5d2aa888f4ba54b32805c54975d261a9edeee149e0ece0b91777dbf2567748ca396ff0b1f53035416d369f8d106247b538010278815e631aeb7e7f1786d43635e806148a26bcce40ce0beead0a155bb2552e93de16f65793d6d67fc854e0eaf9bb56e61eb30d8d667a568157847ac99237ece391bd9c35bf42d991191ba92c3d9a1c7df0485b827146980dd50a2b8df9837766585cd5950d643116954fe86e0d39c4a7d86874a3bdd4aaf233edaa36479b2f6b5b57cf6ebf644b13020d5f0e05d69503edde19a9a02044f2f939bfcda381e053bfbc6351732afb86a574ca12f6e2d40c85abde2e8562054842b2dbca11a8749f42b3dd179124146bfed06f46cc7acf75fb8f97507716d16c6e06dfefcc3178a06f2eb1ce421834f822ae0fd9f3f73dbf1f6fb52d4e21cef8ccc51a5347c468e877604c15f92445d7f36eb9eeb6ac6476fafc41feb153f22fb9fcf6dec0c825a9924b88215afb9756d63f6e5ec9eb4c05be69ffe143b7bcfe57ab071acb41ae64db355bbe41a64ec478aab70c2f060353804bb6f5a2ac5e353c93bed662aa96a459578ff075faa9fc76a8cb4f72e1d38335169af411a3924d491831b67c40996f0352461419bf95aad8c6e6f250d3958755ebc805a87e8ea19b73d09f3a0fc5516441a08d3e10de13c9869697c11527937667334df9a7732fb2fb9ce70058e36bf137ee547c741aa527fe310d5755d46ad3069688ce5e69f5683dec1ee3eca09bafe0209895168667a4bf52967ad7dfbcc0e7f336a108ec4ad71dc1cc5ae5260432c24c37e9f4d68675d12ee809c23faf04a56c7dfdf2fbcbdef01ae3c62026b3e05906a3eab8af8675f4d6cbf53b808399207b7f6f5cdd136e0ae3fff054a183353a449b40852147f89744e92dc0cc55715b9875430070a096c41bc5e39f83d97ca0b08614136191ec788aef953fac6e167bf56b94dee2d3d7d06669944a80b0f453fa4496986e1341bae89efc66c12c0c00f612631433c64d6e3a520994c2922e76f46407c77bf4acedd62f42672ecb423ebca6900058ad678ece843c47b150e8e74af982fa1589d345942feac3fa35d5632967fe7dfca13c1b1b36c71d21b01eeac197a01da8e63a3fed90f19e72636ced3fcc8b76188aca8c595c477bd0d35fa4ffb437156fa9635ed3559cb2a0e9f0cfcc82866a86dbc00b7335c5d32b415557d3b23cb34ee558000093828cfa86242432f34c30fc7ced55080d2908c80411da7f1b8f9fcee18afa213cc9b9d95c23875a5958d6da6400c3d0cd004da551567ffdf46e074f01ffcf66155c5433faa018971731269119becd66f16b9d6fa0fb68fc06773dad2d32f8283d18b773d91fe1436941fba4aa5fe8211ac89bdec5c09d00b8c3c7a23aa369e269cddbf6e9aa6e84df619e941c5233171cf62f7299f4869e9741ec56d7bf658d69eb3417832965fd599f025b18b2c3a27246acf70c4c2707dc24544479f7f3ff5ab8f400d216bad32c8b26cb36595d46d9b3534d0806462cb21ab00d0173f4057b91125bc9cf9a8cef59e136174aa009bd8fb023b4f212f8eaf63f06e7b3699e1ea382a1a1f27c4920912e0a17eb99bc19aa17bceb4cc69b9b84772f32bb47596453aed78d3a291a13d6256e189426f127569461e3ac39bbe04091044c087671e395187742e977638ca4e46b0e13408cc5f4e04fa1a49b646a2aa14c3eaa3a5fee80879d298d67f979ae3e0a2182b0aea6f9810ae95746553c498f1411a78e2e4f12fb39b1b9adf7466bb9a654aef24896dce38de97be377b6c386f57d6613d652a71c574168265724089bb2382f89f6be157d350891e55ce919e9730fb6938074de70b25aa8244772d8f4ad8c0c01cf42f71cc53bc756d34ff9b09f0ada3c7bb3e6aa3b8feffd796ca6a91dab1c3e4e8cd5dc8d8d3798f5b51822c8c11df8f6f5790e046df61f1aa4b0af4728032d6e7d5e7f2c902230fca4794a11c0bf8fe5f16a200dd22d3839573f0f68fb24940388ee9e2cb6c5e496fcb104c6729ae01185d384595a6eb6fdb5efd7fcafcf0cf830a7b8fff9a624187cc752b3a8a360f1ba4b62609b9e44a35c628161efefd4a742982e91cd60611d8e03214c64a621169492a89a6ac5ec0f4a61fc3460da1f42de57aff60ccfe8da4a43d49f836f4c7061919c6086f3355a72dc1f50b0a78963f1768875a3786e90220a20df9af1a3af76637480b84fbd8e2e93fea83d228fbb9938b7fd887c87e91e6a4a66c955f55b89857eacdd5e3bbc87601a94c695def91ab232a46da6b52975233d5dfac9789cb2c2df7e9c2e442397166a5e01790d4ae845452211220024f89c5faaeca38193c66fbaadeb4b9169002ac933636f3156b6ebfd09dc3a007488c44f85a71f803ef486ddbc893249b170eb24374421696e54628e165679f6208c86b062570c02d42273d7ea730ee018f392fd179addb1b7df0a7d6fd60aa06f9a7768d3f9b98af6fb1ddeb6061e42ac38800d5ba0b9ff32a3f3ff50954ca2db837e516c40e7473d6b7f1f0c8ffb80ec332e220c43f71a344bf9d4253a1d54b8cd81a795663adb8a63f557a5e5d1fa38c4c89603f4df7e84aff5371655c6cb86479879b41a34320017cc3e820acd634b1dd566b173af63b63b3df0aa47b884605442fda84d49d99e5b5ecf71ea235ea845a52340ced8e3faaa496ee492cf89e480b799adbbc4618792d144ff91070b4e74e4b304b820c8f871622948ca4fb61c4a37001e176b440823730756c2adba886f4ee43714499a421897f8422a66e0b02a7fc16df847eea45b0725fe003b13c6e987a32fb7bd115cffbb3c42856902a821763a1983881648c7339ef0f6a207e9be0e69582aa6dc36ce407701f41c3e20586ca50b5a47656ae3032f3a75f7d9e45099822feaf08e450865cd8e8de50d61f76c965a5e03644395ffda6d9ba6c7e32f2d0c16448a44af1aee355addcdca9289789c0a7cc4fe6ec63f634a97a657f7fe79109bdb8329cf959d5718a91b2f8c49e8bbad0809fe88a8bd1492dc65a6419d8d2c847782e7e32b49c8fc241bc26bc59f89247d56b2343f48d94970d04bb8ba0c25a74adad7e9ceefbc9f6b5656e8dad7e9937e365c70d9d43af50049f7b59277388e7d2219848b04a01caa19e90abde787eca89c4e1e47f6e915631bfb0a536652172e0e74724213314f7e606e8af79a5f82c5f95db8ab5fbce3c6b236a476ab80ed8fad44554878f04d4f3b0f79a90e626c7fce53ca78303bb544a00cbfd02766c1a74825a39b19383e856755ceb0260f86a1c59bc1794e03899343779fbc72bb29ff8171743ad96d3a75da1ad3ae0e4f3f91875a04fafbff84aaf8a2562eb3e5355a906a1c54fab946b11306bbf97410baf65719daef16d4239a8a2c435d3f5869a4ffb57afa89b9d0084834dcc47809cd730f245e356a438923685ce6aa840eceefbb336e58f9c9e14c261971937bf6fb494fd0c4cb57a32d59351f5928ae6165418e62d5277c52504d2f75498eac122c04873259b0e4f041cdab1b2116357f9e589f1c667f0f689cc65bd940b0a86be338f96aea664b177bc6274f7f69460e9fd15a4f46fb93bb1ea0f706d4ecf961b9c8e496ab5c582e1d7d69baf17c60f63eed00533a8ca69df3c9c09614eca9a7b3bdb9b9b9a9a5ce1760e65f7dc0ce0579915a850295ca5d4719250ad7362c614ea015def55ddcc6982ed39726f01eff36d76711885554828a93ccd24c9c7f5104a449b0c8b1dc2687997aeae02a048423690c9cef8d6ab0addab33efda894b6ca17ee84c21f67ac0b16f4884a71e1401669cbbdf6b0de5ab1bd23cfb619dc8377e1c6823a7615bc50fa30777a0d6a367271a285d75ec421973a0a584377d153dd811bad55f4d723f874bfba46c66d3143971af4fee75c59ce8a3cfbc3df81c9f16ac950be30c4b588f8c387db3ddff978b353dc61d0bd311465315bb9fd1f69c0b2a053e1d838da110655738c606893706c152a40791a51659b68b6f35f7d5f9b85e6c8d49addd39a2d487d11000be3e768dc68685aaee69dc67fef5952dc429e018c8c1fa8b56f3120030b32434a649af159cdd678e5548e7f6910e1f7a97a305ab41e26d2d71026fed289ea172689fb446a728f1e693aa35a582be5420d63ab31984b4efd828f5de87faaa2f5f1c92f39fd5609408bfdd078b1de7f5841db06d309154186c19b204c0a678801d7c282ac821b9cf028ba9bff7f56bf669c33672c635e7d235cf87d93d8d6bfd618d6f4cb9de8ed4a99e1009be3d2f7934a3ac868f1235cbccf7840e2dbfce07a238768056680ba4016edac62b6960b8fcbd6eb9d0249feb5c4aba1a3d61e17087d619d74c6f6bb7b78b4793406eb27b838e46dca4a7ee78f972198c41561387cda11296afb06f9c5a026f8cded114db007c4766f0bc64b9fafe33a5267319d94fdf4ca2449572b48f0245a000867a807c7f19ac5c42540dfe3d935e47908815594beff62314b9e2f0bdc45f4557475b8823992b4e87c0993b046fb1cb2988e872fa246a6aa5b281ad85bde9e43e223bcda244d632f05a4b14669b9f53489cd534ddc087ae1a50f710896e78fbf971bf83856bb415e37c88aa0f67307a25bf8acaf80f1c937a3bd0e3eb3bc7a1e85265ae6d13458b03577cc8fbaab7beaa534ded5c7dc5365085ad67d91207f6883f3e16bc623b6a193243c1551324bf6713afea9f19ed655ea12e00498236da2fae4ed64e9d0d40273d58e50c796a7246d9c8a9746ab4b7b9fdad08317a9dd67e4a7ec5c168aeca74cf5b0d9f5957ccb9e58a6d2cc875659ee05f7f838deb0805a7be3cd68741e3a024b0e6cd2ef2a932d82cdf7a25675f1ee2c606bece6c823621a2bb34b6c7d3221736756d46181cf04d4433241226e3f6051a770eb3a4c86dd273e23797b1bd68a2e736da318a229e21b34a0d9e6e913995be6f025a40f7b992f7f00767e481b3d789484a86b80568bf935ce568e555275274c8d289eed0816a3a27d613ff43a66944ed0ca167a349eaab134ac09288a738fd32a677351a1e9790b2ddebaef7dcb178b7917dde51d6d4778174d9965177dbca8388494cac05e93aa31914e62f0b4de69acec6a3a6ab2e7c7692f8059f19dfc9f3544d35cef9bdd33aca790845f88fbc609330c64f0ec64b69654fd9263107f6875a9f66da09caad7bb566c93da3352ea009042d853a2266c26b0361c43a3905505b059c1bd5e4e84be42838080432f27c892b4af9c77a1c648081d17df00681d64697fa99cce60afabdb89e7379de880318e5371b8cf85603ce0d848b7b88974a511f2e973b018e2dc05f96317417e7025a494af450f6c59bb443bd5a480bb2c536f4291ea0e7935438dd95d7b5fa2dbfb01c26fcbc6107cfe7bf932ee7a98a2f9e2efb4bfd5523472be9ec5b20dd5214abc29c0f3c96feea60b5edf0f608bc8cbcde3a515a246e244ac0b04ab4be45d96b45c24fbf3ed766505e520475d63e3f7dd906aba4b7d6fd53b71c09e8481da6de88102e4e629df67a73283df3a3f81bbdee5f2848a864818d4f9304a778d354cffb5992f3c8a0e12d421fd79d815ea9b2f6ca563e35abd23d39e08daacccd4c7f1302b52f40a5401dbf6ad69b07566e483d8e935ff2979d9d9e3c7c2a11664f28a95b57b7992d18ffb3696e65ffde0cf5c585e4c413a059f5d4e6a478f44bd964f682016c2fbb30c9fcde76fdaa4d73d50a522c9d0ced167021ed0672c343eeab31020a88b253d1fcd01befe6d7fa4e93042131d7aaa2ce5bf6fec43d99f7e2e114779c90fe4ba150b105a7c9b8d6411c21ee8e9bc2b3d49ef2faa77408b543a9c7e9e6b61b4dd7c1f178ab56840763e5d1c3abe13b18e0074754324292854a6b81f38c7284828d3be2d542a13621ffdc78401540b8cdace5609baee8fa6a864efd62b65f044c98644c0d9e251d38400c371ecf40de8e758e7ff6b5082d35c165ef8ad536adc95b1c2f4d3ece5dd2edb5b0f9235d69db5f6480e4e443e81e0194e0cbd50ca00df0515566ed457b492fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
