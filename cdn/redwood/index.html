<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f307e02451695870c9208037cebc000de9e9aff41b462374226c3556a19abe8b9420f3f0061fd3612944e4de7e04650b1debf25047d5e2df142e2176657088087c33c4dbb1d69d7e334dc3dc72837594cc8150aa682562a28b1d94143be5bf544dfdeef82d354280f51853654b5ccf43829c1828d1e94696484d90b142795b120d9ae703b9111907ec943e84c4d1b307b93aab2bb82dfe8872e901c4ff339a929c3f98871c729389c5a2632ca8d312d4b7fcda156750821989ee1322aef5113ec768443a603418dafb1e44785958dd9bb3d82bae7b83e1d36fcc6600e26c78302b540993ee71d5dd4753137a24bfa50d8309e0bf2efa4efc1afdc531791d97f7cab644b8ad1a5ff8bdd2108da4610aaeaae95efdb75730e70b3fe9e46f630b740799cc6246aa6ccd40cac51f7e9568c373732cedbdbdc2fafc855fe07fe16a7bf08366e0549d0f36020a4580573cc078c2d17f78b36e2ef723f2b7ba573b7723123a39dc6c499e2eb46a074c73c55d3b8109dd0065313decca5f629c6f6a97a1908c1dbcc0527712da00a8b9536bf3d5ef795df2b8807b44634d39c6624bb402824dc2c90c025c83b102e893673da47cde7fd20421ebb10b8dcb89f19a3f8a6d8314292755bc0f6a287b89db6326eaac7ce4ce405012235dcea5f96e38ad1df02ba1b580dcdec61949c1695df7731adab42e3610252363cc5b2aea2e4bfc1cd65df0b381be212d7ad20a4e29a26c477af371016741f6362655ea6fde5b5ed42d9b26f6b4923de9ce936855b9f97751b31cd8d66b01c33c671a962a3b4bccfeacd1b200db5272d0cae9687f796e54f5a9b091bfcef05bcd475b536c2135c56cc333d577af10bb4cb52397f5775569bbcc35007cba94f93c39ea58017223534ffb26f53923079dfb7605269023afc741704f95efd47189dc40aa2823fb0f447a7fcbf569441e728747cfc05b2aa74612a4718e29fc7124d983cf728a68fb2cd889fba9ed90701d1ffefd6d6165fdcd424b06e92d9009ccfc6465f214e5453e4df7891cd42b918353d765adbf6f86df906eac7848108bc76bae0acec9712a355409e65dc2d66b7fc771d87531797c3b125804b89dbd1d28bd2dc6c2a8b87818bb2d87fb96680c381fd2a0c040db3df072a3642e6d49222e847bbb906bca4fd948c44123dd45c27ffbf6872efe8c2c8c06db8d25dc9b769c7eeea22dfe84b4140f4672ea1f8b3e51c2924c1fc9156ac71a3879d3e7f4cb3cb097af77cc5bd8f3da8793117894e5b8c9a90dceb68780d5776e8e6819bf2a261cec633c1f50bd8082468423fe600a79031bc0fc797781e8cca972bfa052071d6b4ca29087c3c2553415417974da5137923737f1a52579cb44f1349324b2c9f24cb47a32ca92e24aec46e9219664fbcad876c3c15eb52aff5d1b63543e2fdc10aa10975c0b3fa9e597cbadb0a5dc170741beaab64f89abd8385e2538c444bc1450ddee488bbb842929e406c9ab9416e42a6a54f146e9276dfc8bc44c74de4bc563f891f22819f52fdaf914575325c925859b5d21c7c5ad977f2dac6ac180aa7245ec20c94cdd4cb541ba78d5f1448ae24d1bae5ffecf64ca8c5a7d5c316abe34c53b4dc9eb704341915d7a473a6366d63e1e29d3bfed7cffc9e9c50b1d8d2f69cc77ab4ed467991a718808b5c64fae6c50a2bc58ad51c47e8366e824c5627643e2ef5cded480fb9e3821e2fcbbdc64f351eb4f7de6678fa1b71c99dc3dc9a711b54369cb0d0c57348497c8e59a098dbd459c4f1ade5710d30c62ba382b34088afe1fc8e23ca3edbf3ee68eda20b10aa1931246756cdcc3b68870998e3a316bfa8cc75798ff1e1025afc20efd0d88acc7f5dfb38e101b51c7b8ffacef2080f75a52582608d415669ce3fc50cf75ebe744f61ec13259ae167e0e442840dfb0e7d3a8a4920c48d0eab063ecd4201910d3a771f8bee3a3d1f25490b2e9b7ed00627a39c18e422b051900a2f9d40786b6ee084630567e284319f9bcbcdda2b0720d50ffb21d066747f98f754bd8ec5e8632455c12fff74e3c8d3ee42885d7c7e9ae4e42b3c0ccef9498ef123c62c9d3b13c9999c709057bd2db38eb58eed9d6b69decf683afa1847ff5676663ff190dc889572c41ce106cd9a7eb10b544d0fec3cfe370ae813d9c6e48101efacda674445f5c15b702099e115777cbd9d9388e445a36c80548eac3843dc82631fa8cc2c6066ab72e6e6b7b544bf06954446e225844591e4f9780152131792136fb96d5cc4f64d5ca771350d35b3296efc3863e1eccbe3bc517cfca7dbdc276676385f19c3dfa5b3a874c7d95785877e1c37f5e69a7531fb88bf9f36f7844cfacc5c06adecb8398e86bdafd5e5730c1f1a4e07de2baa82c496a1a4a493368f795ec1cc5367acf3e47ccb1cc807d56e5fa57dc14f379f3e40b82844c509ea89b32c6843b916499f804ecca7f562a8ac7178faed775dd4935c4e574cfbfaea8f442b3ef8162bc70f536ef31f0cc1c0a9710637baa6701ff2296c394c600ea4a119f99369840617da3494a786c8d708d934a981be38e6af1ff46c98840668871eab4c6cec8c8a5834070256b9720b18484b974ba135c8d3ec892de17c88821041f15acfda49d1fbdd5ad4337ce2d0232cfb3f76e812815d6e3e15874eb9e1ad19e13b9b77788c5f08ab778d3833ec676f12802b2ce4421fd98c5452f6c2699dc7e6bf515811d84944453c9eecf21efbcf4adfbd248f937e69550e94640ffda280c121b694e797d47102584c1d0a415061619604a8325dc0649be701ecc68f4484765c98961257b1a8063a692cce3beeddb978c43296f17ede2ec52d031415aaf10a9b5e8676fb9994b860039d9424b8fe4b0edc0d8478240ba37f7fe38efaa359f3dcc2880321f9c1f61309888df2f615d221e84af2231fb9a8213a3decf2d8720d2c32c0c275d10ced1e5ddd045ee736be77e04c4aaa6a7760684cdb888eeba4e58144e5c19fbbd20565e842a041ba2d469ecd70c760add043b39d8f103842bfde3eda94c329004d13675c2836ab4be006b9c0af445136821e8bb65b8ca3b6ddf4cffbb26024bd53f5f0a9866fb747163dc1babf9918fa36ee7d413eb18587ecc257241ed3040b4536c0a8b80d2528272de8cbd1e3604d8e8992fb4615d390087d83581bf52c2856752d539538eb18d126087199b683d4c6dca7b1cff7d8044d7fa64bd87c0c2f46b870e0ffa34c64a8fe6d8af8f38bb3b73c8f3e0ae15893cd66f4c916502bef2aa45f38d7f80d7b19904e2f9d9f15a39c9ef59e346f9ed38c2751bed6584ee8f24d77dbba56fa6171836e5601dfcc2cc50ad2d03fc05e927c855693eced40a0e5a06de5491a850d1a21c635d9a4aa7423219d1693678143cf5acb4b9007e2992bf48d508c26a7f25deb6442c40bc248b5ceb1a7fb2f2a747eb290dbd2b75f04f5a03ed5c81f2982268001f796b27b0245cdfbe484192135d316c3de1f0d50a56e789653e617ce3b94db7b86ce8081ad31bf0a0470daee78c1a7e8f5575894269ab1fa19bd2e6829f3f997a54370f87f0066afb69c97b48eb377ee5c60f38b4efcfc6f782b63735f4550da0ca2968a7047a9970ae090ed9d5dafe09c1927f5d22d388cd4ebc04799e035ea9b852c20403d078543546a363c6a20c79b04cb738075b14ab2658d2dff64769f3d1a561f4a1cb395b6ba053bb34520d01fcd1465190da9093826674370d3c2ec356fc478165d6f8458e38b189411aec6f1c70834412466a10319033ece7a4c75a372972b1d6c438aea20089501f0f0790faf080823de1607ed04505ee959fd19fed5f28b44c4b075a319df79fa0ae698efe7af97e83de28ce1d982ff5bd35df06d78b051fb1346956f788d965706dd40ec6a11a5803084cd4ec1b09d7f53188faedf237e0e1613263f3171ed1c599257cd502fb7be28698d0cef0c455718f6507031628327af9896f89f0bbeb03aa36a16f31cad976c7211dc500ff4a2ce3d300eca7f23802cb5d668aa6af2f305ef1f955654c3cf1b0d0880ecf5492217f83cb95fcc1272869782c7f9a82c11fbea9a76b0029b3d12d93b8e921a79ed9ed71e469904885b1223933308410c3611d436dc9e4fca6b53c03b0f21dbd6c6251fe3fd6ab69b846e5bf3c7e4f9a60d82568a5c2de45bd4a37cd5b8fb75234f46fb1571dbd2ec9df77b6ff74c55ca06b10777d8b92dbf3848148f18f357f9c5ca34779a60d3c658b01cfcd85d56dd7be06a13769d8a93bf612c3044a8a3a7c072c98389ee0786cb84a5f2b159404e7dec04004015fef431cdfa714244b972bc0c7d6220d270430f9d85daca6be4f048136489a91f6a2c90d8ce5f19125fa99ebf7d015f99b85ef93b133579aa2615ee0a5ee79f3b965a1dd7dd16f8db2374225f36a7493cf7c24e9f64efe53cc851c48ec61f6b0778658a64c48c4a0e152a42e5980f867db50886a447ec90a35dab3129545a3a42e3e6ecc5bc86f7388f6eb39e1a34ea95e22aa10566cc937b9c3fe6e235172a70efbbe08ca0f4642a1436deca203cbcb90e182047ac8831be523fb20a4e5ac3f071d9d137fd24cf9ca71ffe8c4b9cfbecfba7229e75e3ed0500b2f6caa1008dc0e22f3ad00eb641cefd684d3ededaa432df9b64998f8f90fcf861b0f9a314fba779be654acb192559f153a2742ea0c8ace20004d95737f51621aa9832d20c314068fbb0a19f0d79e292eca7820e2aa6a97988413a77708995dee73c2ea166e98ac1f51f5adc92468e2c7e379e7f08be0497431d082805a771c94f288387cd072e7a32a40710c2d6dc5c4c63e1d2d795c79320c23a62420a950e5e8c52a81270e38059d08b7d9c6c1fc33dd10f5d20a02d0b8f88fbd151ffec78c5c09bc4b18f71fbd78918cacc9bd6b1ce69c4af0c68f40b57f39afb4bafba743b63de3cf8fe87c447c4198505e1e581857015c13cd0688f67b785159a8ca1df290312cc8b997f615ce71764b08bace9f98fa5ed421115433ef29ad174212d51a0e8b064a0ceee820f63dda9088f2f91c866ec0e014a5c4c4d32e49253eb77234dd45c10396387b53dc790354bfa94a05d30eb6f7db3c7b5be79130f5e5e4b694ea9e9f1456fe7ab16a7d5268bde4f45bf9302aee6b7599ece251c24684dec60d7c40c274301bbc835263b734e5648ec0e0f7353f4a2b7ab83d032d33ab8c8f1cfaeeaaa566c58680f57488bbaac38ae272689afe5b3527ce51bf44e8b2418697d71992fccdc90f312a6c64c6202f188bf9263ba68e409e87b1d7b333d64f3a20cb9795ba662e2b4acc12a3945061340187b18541ec22e135699ccf21d6af62becf24359858e983769d37bd4c4279689d3a29c52a0f711fcf1c57bee07baa1a1fd2e1397d2b9cd72a1811cdbfc9df5d5a3d37c28e0ae2d0c8410b093b23c2eb81e4579844cac28049fe2f14298514fd5393ae31fbe8c46329e7a4c4e5cc30e868faeab12cc2204dc1b1192dbc8323fc990add33382c16ec831877fa399061fea1de482e62a4d93e0c33807da8b726faeb4270110a9dee06aa3b1f5be7e58cfbf9cea8cd4d2e018fbec8cbc4eddaf680db81477e71252fb17227582c21bf0a820b3ae64dea4e6037f2b7a9a37c45b5d332afefbae076e30bfca744b5be2306e360e0e213b91b85b971ff6b66ffc07201e2a999f9218a12c75fe750540db0746140438f7629b9c748cd848323d602a9540300c79ed9258aa38ff913d5822375bc874bf0989a544303a06b455a107c98c93181a20bc8ff98ccb3cb58cad13b8b5d8c3a3235c540476ee7ab6e7ecb64a0317391cea22fa63cb8e1680d70dfc9ea9031c76c4e3c3a96171e2096458b3c748d2856f0c4363655fdd2bfd1bfaf69451ad35a186b6f968c4ee5b4a1ffd51866b4b8e606c4d0138711a7edae622cd7f29809e56d2646003ee94717f0028e45e145cfe695abfd549503fa48f5b2e1e8668c9894591963cbb42bd5396dc741a63b51a791aa405b8cd871f415d8120dd4fb8689a58407f98d0b745b00d6aa3de5396c2545befbce0b706f7847ab604cdc2a648e9c1be0ad58df52ee4c92a79d91d620cb98ec11759a4e217039b1adc32c5dfe4653c753f3c412911e0d3d7939e1c1f690c256eeddd31dcb026b6f0b05d7cbb348ff2a52875228326ed0edf73ede144c0233de95394f3df905b110f797cf2f8242d3b0ace2803a64e11e8b0440c4cd3dc3c5829e1899cf99ace4132ad5dfac6f0cf885711a00f045d0d7a49ea43c958d96840c368d69ac5070eeef779d88612759d97910056d12f988df7f9045228e1d77a886e34e404f5c955e4be89d9c3e356679321ff664fca53ee6ed410f1cae29f4b23861403f34cdef4b54271f742434cbdd01a19a9847a3eac0bf6e4544c07cccc7ac14fcf1deb032b36fb318d1b8a03dc4812c09cb626880b9f3cc195077fbbd4ac13bf15d066b7d78e5bf3a4fceea4e9d176accba22a4c3159ed1facf3c34ca627b55352742bfb8ae8122f2a5a862981c6c37999a8cf33f245e463cb2db7958fe175b87b3d63c879a47bb63e8f49a873923fade9b8cfc2bc47859cbe2d912fc00aecb41bd7b2e458f127186d489bc647d044e282deb99717f26715587b19a3339cf39c97ee03181ffc3877bce7ba1f52cbf72862a97679de50980be8f0ef7b61df8f4456adfc446937fbdb3927a5d889fb70a7e997589c347961351db9824f8d43da20b8aa63dcb483b38b3dc30c22224144a81e72c41c6c2ead521e8b379ade42b0c9102fc151839a754cdd86d78c602650c52f98a8a16a2fbe7036bb464b8c43546e65ace578e07819788ff46dc9a3137028b9713ee6e68883cad02ea2947ce0e7c7e47de2953a5ef1c89d66e02c4e8c0bbac79d14ea3a85a2342f8e99b64a6cc8cf5c7b355c1b0f077d7fd79ef8661b89e9d26229cb83537e66d0500cd8cae3cada082e06d1146dbb7df5b14dd4c41689dcaaa221c42e6708e2175ab905bd01a74f2ad879deba03a5f1d2929e4b292dff25f643e512f37e9f7fd39730685d1d3cc6971501ee8c8b936a5d8d0428b487394528cebe4f56902bf63dbf7030324d5a8200c50115ff779e89b2134b217abf9b7ec7b70ebca3114269918fe6966807d6413c5ea4494e4d6cabd01acd4a242c87841fa9e2a2c6144d4553ce9894d114f7e87429f12fa94ac9b1c9e2e84379ef87ee75150eb606855651eb4441b7f4c9c4f2dc4455dc70f5093589742b846bcb239f2b820355cb518e24d484621e607cbb3a8efde092aa03c85579067f33b8c979539ccaa013b07242f17000b67a361b69a986993f5f07903a8c45e73fa2af609f28080b97ad1d3c73f411ffecbabd09ec8725d9f5de13fdf4d17be10a2f55b32bf428adeee1749f218b813a75be511d6891d25629cddea3010caebe3789162f48ddf7a96f8800532d405790720b886d71f0d0f4e52ab533a5a12b05d242a7577faa3dfe15b3a0f9f0b4f89a1eb77a21298824a432955083bec48bb94817a0b469b3a7d6c1c859b5b04cad60af4b635ecafdef6a5a6e9e1e171da97737a14d8d3e279ac410dedc17b5bb0fed562b0f8bcfab89c4f3cb73e242a981bbdc5dcbf164bd931ad5ccc913710f06a32372414f97575ba8ca463c8d5b5563fee95a98461f087d75b7ced950ab04f835f266d753b22026c787b355263fe8b3389644d88d96479b1861054a796077da56f3d68c985c542c7c9b0c2ed060905752a40a729c36d3c5ac1778c54e23b09a6f770940e8137c63b6666ddded4f8960256567ec783b3897ce486eba1e319d7348f1a07f3c83dc759956834b9fa88bac9b15cdc2d50085b1d6edf051b54ac255489b433b2aef4f3c30e66f754b1421274e9e6e8595089af7074aafd245ff32a0e2c67493b25ef1ef92bcc0dd7e465f02dd65d66be5d871ccc0960ba4144221f4c849747080873e9076f778dcd36e7e44deabce225d75c41058de426fb7d0e5ce1e09fa5f47860decae144a7d691f5289a6c0935d8c7e8dc2026a1bbdb7a1ed9e76bf3ef8806e69c554639f1f1ba5d1fc48b3086d5b6740df35dd654585caa00bed49b1aa1fc49340e5f3e785c1624c6b220bbac027822781639d87c84a303556c88264d2fd04dbc231991ba39531ef137235e193863eb949adffbeb434ab5db7f247eb80419929e0fd8a541d0138f306fa168a4843e19ffd5f4bd0081bb1f6e5527cf496bee84259d71aabc80e0152d97eb983e86fd958d6c9cf2f79fe9d5b3227ada1fd362ceed17fa4113e5a3d1e296a89d0f5d8535fdba2ff5ce2b7be40a211045e4dd37b2ab8cc21d8d26146677c5800f13ea76c4a8c434fb28992c5a702e32f4049da054caf1832978d541c2992d53854eb7d7dbaf1a98e1314a2899fa8cf3ba6f00a0cf916769d975fa610c581b75fd2acd6c9033014b2977c56d54c9321eddad3875dd7ebbd5bf0dc99d7ae938c82bd4495db6c38ebe02b58e04b0cdcba6e2ad1a6bfe027bf93414c7c680534558e41682efb17678ab8851869b10e5f361b19feb2e94c5bbd456549bdbea69d51470df29eea1401be484fd2b7539b42ba45b3a360828173e2e0eb98e49c9bb404ccc52a4fae5d7249fb9588a1b429663e86098159cc1ca3d71a49c46026481c7d52d83fe0f00b7df1c263e22d0047d85285e3bd4ae00699caeda41b73dcf9c1b43d0d22fc8a2729a0a35965856d1cc5748aea7c779901332d984e201c5e111cd6e43dacf437aec25fe3c16a14956c7075a94b9c88a73d88c57d167d563392f5b5634c014444cd12168376ea8597b428d686ad8b9cbebd7760e01d868a58c655a67c9e4589b30d5d9cbf6a3622c02ab6b80b6cead7fdbd1c6d916d7320522f366129a589522f0e45ee4a3c2acbc20421d2b6fd24b910afdf35058ab8f0f6b2e2863da465e2d0da42dd70613af3a83bd477e329b08f74a9ae3d9b4dda0059a3667cc8d556cda9751938639dcaf4d690a6cb7ee0b299e16c4fc63db4e4c38a5812fa2cf146e01acd57d9960fe432eaa256c4e5a124ebcf5d7ecf613f386502de8681bec22d26335d084f021c29ce1c787bee52917177437a7ca1ad74607976fbd651598034a08d11433400bf187882f2053c09263519e5498fc266ce17a29f6829adb369a3ce3eeb9fcbc99d88826a3cb54573b2ab75c75c94b607be9fcc114af585fda3a7ebad922209a4302efcc048811deeeaa32cedb3f41ba50661fcd7d94e56b0f56cf8c183d734b1a3e31e821cfc20e8d55486206cf692e4d2d56db6503417f184774db3c829a92c86f4cb5f9dd61787d2f62bfdd476b6252c2ad2dbbe8d9bf7324669c66457dcf9bedbc83fd2994470c985a40fe65a43653155297095bb2f6679e6c46e74baa0ad0afc3f232fbded6601f89c4e16ba9dad949518c8245ebe37791153b7d9c624a06e27789ac636f5d384fa7df96216e659eafe4a93b7361c043583101dbffffdcc695f20eaeb67aa84a08a43e3a775af8a64902a1bedd25c8a574d7a07bcca814a5472e1bf904310d64c28eeb72098008f8ae875d4fa04edfd593c6ae8fd172ce64e9c1232a48de145f15683c98919bdb4a6b348265835a0f7423b75a2b1f21c0dbfb341684772432c22f215fd07661585bf64b82f17c9cf856a70a2dc2e57857fe14c6de328e3f326657314ac935802ff96c62ee9840078c2c62ae933650e57baa993eaefeff207224761b7d0d8ae8d280ca948b4419f4a69b7e03ea0653062c8999bf3a377ba0e197058a248445b3d5f6743d1d295992a15e6b5bd9982ff5d3856bc7e141f51d70667cc151601fce81878c9634774698f944d528ce7b0549534332142500140811103c7a2bd628bd7ccb0bb154262f0cdac62bc7eb5e4c67b6aca65d3382efc3e441b7ae4607f2758664fd2559bcd9fcf42fa4cd532b796d3742062f8c8f9787c1a3c2cbbbb4a2c65ebeb3be27782bc166d0fd8e0616e195217a5f5be3a4f5c63392cff4c1b7c6c1105ad55aeaa8e81e769128a34592ff7d7f88555b24d72540579287fa061ad207061721ab3bf1606af51fabcee0e09d3d60854e52c720f41d2220d26e1b90c495e632b5dadc03efa4ef0dadebbd66799ea18a8264386703023aee4a229f4adf25fdde424b85074ebbdf70a111936d910a35396a151bf40e79e15342583aab4125f891570090ec6e41bd06b9bf061c3183ce4cd549ecdcee67d51cba6157e920ca29e2f66944a6e364f2408430a16719021cceb5a3c8ecd05f402ce947d945bebf8fd1925b7a89c0e7be2336eaba0c9dfbac741cbed027d2bdb5f1e6c9ab67b0181e478c5fbfad5ba4a9eaa58eb5c8aa741b4b24720169491bb5ce1e2422455aac64fb036c4786068a6eba4f65498379","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
