<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39748d20b5293adc5e0c1f71a112c73d035877a59939aeacc5c07a16c4ab6584b8b4efac5014f883a1ee0b41f47f408911403d58d7eefba151f16b383f950d425e86326ea502fb58f11050a61554447d35d184e814f2bbd60cd4eb5e9f0064d16d58846adb643416544376fe3e01e5ec11a00ad1942e356f928a7ae40b519a67a4bf31b4ae2aebafe1da78571d3ddd80eb381a93513aec5bf6b4ce02981edf5c4c6f1fcf78cc650c139e4a501cdac492708518c537cfb03ffe3380ff5c35e635e671651ad43cfa76029200b63e2e4bb46eb7fd5d90e21d0d62b17c228b5b03643e8e0a7266dddd4510ff561481b6a60832977fc62a687df807530912863ca3d984f399454295c51f4a73d4fe59a1b5757aad638b280779ec5edfc4051ceb5c9223328d7f935c57e54a55c9c660af9da4bc36d9476088c0168a8aa7796c6b3b3b1a8d94d2cafbc9881216003f1866035878fa94aa616d83952c44d90cbd20ec43eaa523a961888e2f21d202c930c22f3e8d9b57f6f194116bf7a97e576917af646bafcb134c4dfbedc033f2923d0c7b302baea0d1ac9d1085095a3229777ce0b4c138730e19c239387530b62803e7be78a06d0377f9117eb1b6752560ba909a9950d08264c1afdc6681137ff5bbf25011c80d402f76e2b1c9477c3c2c397ce7cfb3f67fc7f312f225db7939f42351486e2b5ea8add4670416fe23c8f8b4ba0aaf484bd54b3485c9386c39dc35c0a20380555e5d5b65e1dee0a08f35036eefcf91f3d38f6539093ab520fabb3fa82528bf02e4704d1966195bdd823c38c2c851c324033a6f7f27be08152e783ed53bf60a6741347c01f43ca25eb1cee87f335694dd2d9c2c061b8a41ad5559a12fd42ac1dbeb347fd15f159079b3ede19fc5d58aa57e6654e055176ffa69de771205026a992908562e7db32c9ceb066775ca8a139a27f575c1f7377835226c5046065b2ae50f15cc7b803315d91c665a10766746245005b394703f09d271a88c2996f83d171c9ed0a12d682dbf1c06014cb593e9485efbaefef3bafd53b43d7319afd1b893c433d9144aa4c84482b5e1aa6b8d3527435d9114d3289611da496ddb6955bd251048c68be31bfacef44083c5ee30750489b1f2e88acec8da1b30908d569b10a83d268ca61b72b00fe1d9e583ee44567eedec8bedd7c9f6db6badda8dbb13d2ba8159a26c2c93f3ae76e127c3dd8e11732d3465f02e503686909a95857e96463c3084f8319e382f70baa692afcd0f18fe4429e523b4e0d2efab2503caf261fa99a6fd93adec7391268afa54ec114b6d36389c13c2811bcbe2f5dded4c28ef672c44f383da55502e88a64d26e4d125e7e5445c46c026acd32c25d7fd8c08f20d55c23eeae355a766484e8831fd6fda214dbf8081d9f237ac1ee24a5c506c514e4ea6611d6f67fac749a2593cc5b860062e942878c9f149766bf38650dc23bbc7a2a6330811e9ab6437385a1964192c7351700da1dc4ad263fb11804e1cdd8954afa7de9cfb7af9346404331431e52c3841c1ec694db21551b5502e28aaa9cb7002a20de2ec178bb779c0fed87b89ccfd45e9d2e05dd8abf07f04ba577254fd6c1e339ccb3d956f3c6a73d67c36350ad28086eb039732e7d265d247e197f88fc99e30a271bfb649d19152f11e915a8e9e5187f86da04ff6c68b73a2cd21d7458451f857a87c466ca44d0bcb9067f373c66305c9044046dece9e3e05477c3c40fe64ec4241400ce1940a34a9e8fbce815d84249382b7f3751557eb3f8d1899a80833139cab5a037b76118e29227801cc5b80c2cd740fde5b00a84286796d776505b0ca23f250bed1288242e979cf650669896a36ab8cdb08c12890df25f59ba6d0ecb4d49d85f6702cadeae40d860d220ac561f2338160119d25e5b355d78a8e599078a63db8a23d170f7e06f51dd107aed3ec8df6fe877edfdf7705f2141f1d37be7dabb4b4354f66019ea3bc2fe352c455d6e756d52e8c6fd4e73c376cd1c96ec5ca87ef528fbff242115cf2c08900299addd1068619ca5636d832fbef714eb73c0d36f90cc49e955a5ff7a5a2162e6d2b11268d093d3f75dc3515181728ed6de8fc287c29bb61e2d5aea2485ffd4fe113a55fd9368fdb54f51f182571f99ab531c0303a9a14ea0a4beeca92ff9a7af7ea9949910e3206dc303ebcea01ae65aa4898e8e119ec8fcc35cf594b4a21acf815e4cb94376241cbf828ceb24f43ccdddef41584d7d8543735365cdc78541a840e0cbb82f6d13f23973e77c2c2b1e12057362aeab9c3fd6a57b5b797adf701519308a04bc67a24c69f6354d3312749a4c86c9b0252fba8a5cda8fcd2667e3ef9918ac68be7c036d779cb1456c7b087d71b0dacb2e5c53b696fac900bb61a36a63a7f3c7835bc344eaebf47198d4f671a42a4f636bd86f9c612e766382d8a7cb05e4e5cd23d8f76029b46541d1bae9f56f7ac563de3de5a29044f8064e25fa977616602801cebd948cb20841c034e60ab65decd5ae18c3de6abb4afcc7030323676004a5202ab29988f8d2dd304351e014376d0c15557b5dfaed4115610bd5b08be88e34f2c4b2fb1a19ec3147cef76fd2bbb357168249ab2336c2b47750a7ca49484297f3f53aee430c65bf25909d072d344669967ff9e301b58bf143ba5d33a7aaceb45fc0492b8e83bbfd41d345e5cf71fcb022a95497bb48df01f17b9abd0824eee77bd1922717e792e065c04a17505efaec8190c29850efe6e7a4a6cbc802c96ee30348278e63471212c047e6927c655e7d874e704d1bc6d151c0dcbe8a5248fc97a1ca576dd490d8a146e09f5bc4c56d0e36a520ee127d43d7248d52fe8e73121d19ce12ebe0d2a1d668a7fa5342464c016558ccad81e1989c4e6a0f3d326ea5aef7b9ea98a5df7e70ffc58a6e058bce6ad12f7fb081f3cd18418d7acfb3ec6d5c598dc5bbd257431c14ea9f47f966ef067c1bb62ac3cf22e2590d0d95affd3b9f469c3ebf9782353f2b2644cba8353eaa5381263c2163ecd58b82428a9f4dbce6eb0f74af0d6d41f8cf15d15303536226a04f0028ed30e5258838012b99e91ee2a5b545b5d7f83809ff7692e35b2a57aeeede95e52c02cb1f2d1314a6f0f3fecb27f3096f698554547fe6834bd8abb72d29daab6ac298377d8ac9f844d3f5870c9fe2ca1f4ebc369be1b85bd6455df5cfdf4d30aee9d384113100d27b29ddfc28085dd55969fa1b05b1d6c4ad6d13b1894f89f4c7ea0997d37e72060ef78dfceeb7eee1c92c84dd9904abee9b72e5bce4015a047057a712a2a4c754b6646d8e1a1008fdf2c7059afd997212194e20c743e9ef039ffa822b8e6a302ff4e832dc1396b1d523e37a3cb7583d16020f81f53cb0fb67ced5e44f3ef9c6e0947bd7ca45eb8f6701efdd09287f236cebad2ef9131efdbe2083a0608042c6cd4b7d943a4fd073973d46d03a4d0adf12f1cd26806b872a095782b2caaca91614a67b03fc1bed3bc88bdfb8bfc8fa1e6f9424b7df910c99d0afe9ff093489ceeec446f45a089ffbeed1c11b14c68b7b945da3b149250fa72393a05badc5a0153ac90ea31563718216e6706a750ccd4ddc964d6ce65a9eef00f4a38636eaaf857034ba2b9a824a6c7b1067c23fa510af7adb562eb4e47a86698aaf5eda30cbd2b3831d0eafc4c9e0d5a2117df196ddefeb6c3e8ef4d69ae2f7d69b84f4dc1f05a08ba66564fc3f7c5b378681be97f294f9cc69e6640c9cf2a8087460149c0fc98fbe8f7136a755fc9050cb87c92f235d9fc74e236494a7838c7187b9d0138531a25eed9dc64e59aadcd0fb66d9c2d49344a478d033a4c2b712ee82b41d3062e62fe90b64f667b9631ca6fb9f1b6ebab5a2800f9cd8530c334142f79ce036147d2e20d86f665f0191d778516a25188ba0875fe30ad04c1f4102bc3615bafa1cfc23de1b905efa998448b1c6aa3b7c864b1fd8ab8b032e7bf87eba96a9b2816aa90c8fc5cf8559e908cc25ce7571b3ffe1b4a6167f5f1fcc2d5eb160537e69aa26617777dab77ace28efc9048dafd9f56bea97a721a1aadb8768a87e774df315045cafd4d2a963268275ec39c0af1bd5f233bec08e98b61a932099cca38a866ba770d6e2716978810ef13dac57d4b334f718a3ef036fd02e35469a0517e14059ed758b66699ca8f9989e271b4cebc7d43e80959bdbca2418ce79399b85da20a3bfd23795b38cd86e324783d64b863f88e1711cc0e97c9f7cd0090ec46e191e0463c9df33d7acfea0ce30d6d48d1560b6b243f542c47e0108323929a3ca45d97a4da3af63d5ced27372f082e5664b368f91e993d51e7c232a70a90236c593ad277788fc1c62aeb74ae5f25a490c5a8d82787a2756215d257bd5fc9de6a33cde1967a1aeec79af54087508cb69f11bed3707aa5050e88d56a59263a20ebec4c14365d135db1f5f03ff722e2e70169797200cfa689e2b7b33d91d8564575a64ae358dda7972d06ce9727256919f6ec3a2a1fd479d5d28085ba222c516af7b4fabacbfda80d0daab6630648978c8fe8ac0428280bb4a19f6fac9f8161f60c3716d8e47f22e766210c5e3b1ec476f429716ea5903f7cdfc9df25f74e22b50420339710eaeea0bb11225c2a835c9a099a4a95ede0b63652555e38c194f2626c4dccd9b2eeba65f2c3b6315fd72d850471dd8b09c4c18c6bd6f2cdbe553b4d01aff3f92b3d072fb64c22108fb9d76361153b1c12e5d958a0965c5ed3ebe241c0ae2f5c78df7c437ec8542c1ee49132c829bb454e85ddeb09a790585e27c75e4daa76be123e328e01829de196f78046f8271a97fb796028a37240fc02f2986248d1aefe4f5378efd76776461683a8315c1f828eff3a6edc56c229a371f9cd93b9e3f615aa6930b0710300bfa98b1b384be3c376a516bf273991717d03539d02150e48b989cffa9e65bf6844bd4ea42091614700a8c5958b27c435d4d65d91715819caf1c4f36a4e517ec90fe19bd9b6b4690702b70fc7763cf23ae1a1b542c10fddafb62f7c2fa98973098042a395bb1222f92f605d40bb07e4526092e70af1923d91a091625251e51c188cbbd3e830e68c54edd6d9756fca0a76e285778946d22a2f5348363b23dbcb1e164149d9cdf78d51cb52b5b819af759fb5e6ad2d49a1b67bac413c0c915b139e62f396aea4563d5e963a932d27f7d6603ef94e74d181084470170bca7b79316308381e97f5e54121295e5842d205d96c188e19524a55cab7fa7af3809c3922c33e272378648aefc6eab5cac99e4b13407c58a92326a66e9895dfb63ca027515c0a60d86814122c3e82492386fef68c1ed55c3e3c5e606b1e72ee14b880cb54d65a17f22122a04f34f56126e2315efe9a69603ec4fcbbaae535b5ea00af0a90b659eb93a021e72e3bdb844451cfe135961797ffabea1f955e792955a1a42bba84ab4f3b5bc40b6ef5a61a56b6600ffbdfa61c01a5dcfc2285f60a2fadef8a84e8ada4c5cd6bc7090fdf72fc7d4a7728591201b4fd29468235dec888a08e44d0ab7d205322ef3df3570d4cca1602e9074e591739fa57044758f99ddfa7d13e3ce124592e8dc1fda17c64f47df11de32c149ef22a2d3f9ee797d0e9ff7f6453b682a6661f45e248378b8adf911c5b099bf476aa02fc804835dd9f347156cb1259e9d0e0029ec42c087e7a933c20bfbd78962458d8f5f76560efbdfbb10f6b745cbfe8278094428b543a16950e17539b49f2ba98e443ec9b182b260568f3bf84f39655759cdfc6dd3f4e1c17ca377c221e80b8b56c8571e71d94a9153e472a7cab7a9965efc0d3aa320dce4354b40166b4b83f43b6a6bccbd0b7b2fd40bea99ebd7732932b2d4b97fb09058882616f0fbb9a46cacd0fd5d58ebb1a6eacedcc00b8eb76b66535e6b7e8b6677f3510867fd84bcd2cf26deb7e8435320edbdfad0368c95c16bad3e3edb97bfebab6e1e5ccaabfb7d8dbdec9327dcd59a7cdfe8273df37dfb8ad5a7b765df7b1e2f537a17ae7db7b6f615cc08957b137eaf745149897f4d9750b3bb84ccd04ce5c520249b432269666d4491804aa780b1ebae810e0f6101b7cb46b183484f9ecc996ec56354258f5e96b62415497b44f04d92e150efdd9aacd47bd21839c8bf9e68b5311390bf2fcfa8c487a4879bbb93b0d32a4d5425ead90b16ed7905ab593309434a48fc6ae4f8be00d055d4756f689d7d55c2bc34038e809083ac6403596454b08a44c0eaf3fecc1d6b539ae799cce3088ea3cba5a92d95140ae4cad54f27eb8e08351943ad88b981659b6648f8c0de9110ce2fae67d9f8dc9aa25aa1e34e1d740386debd2d47a9e41ee66e0abb14123578c95117a7440a31c7171503668d5bac8fd33ea9fb9429ed4a5d0fc8f0b6314334b3c91676a14fd9bcd11f2632c55faff768392f7c2daff075fb78acc07c323a7be95cb80201af11f0d169caec7326aa2c50bc1eb17e051a0526bfd2f8ca4fb8a0484b24e1af2481f10bcb8f259df4d2497b4bfb3bb2a1fd894d3113f7aa3c2ed92972aab67dd08aa9c425e9b4d2f9b8dc1a59c2614252304837ad59ea810b8735e3c6c44fe128808dfa0c787abdfd61e5c03ec82b1fb0ffb91a154eb0dce8d554e8deb884bef770bd3fb900fa05a63367bd3b4561fa94ce06aa2e05310d9c0ff583dafdff1e20870d003ece865a6a8fec6f9815c4f8f9fe8b67e49a2558d535df6b49ebce58751a736df5ff78413693e9a1a04f6063f5af97f2f7e0a9c2372017492579da9fc46678f28c4a51538499e8f8fd18e2acdff225150a49cc32851de93a1613b3c215d25046274bdbaf80fcaddd0758de3d094f9d521743701c494da928e9d040624186f43c99cb41643f020bee559bb160330663625acea9d0b346f909d7714b2317b0762e9eb68c1c450c6f04e85f256b5c9e46efd16fa0166636360d1352cb9f07b3071c43dc58d97c09931c4bacb68f363676f87e5a0d7079ee9616bee43c40897a8c1b61e323fb0f86e4d0af0f60474d2b265698c44d908d8f2b8976c45b3bd314428b0627565d3c6f564394769611f73cc25efe8a7eacd6b765e34047d97dcb89f45ff0530b455e3adde4815e9d013ee8191aa3540c037db9c9c60af0dd9c0f4caccbfd03231acc5c1a3780a261a4dfb1a67e2ae697e1408fb521fea44cf49e98ec3faff01aefa6d1bc77901f57959955e6ab89a4683eb257967ebb78e52e8bd8f863d6df3e7b9def745d89f76883c6772ff4f1a502cf0073b9088d04e4baaa4f5d919ddde3c367d84fa5537c0beaea7ce291a2b5850c789c04b4b5c4c38f2907ccbfca9d996bd9bf132f07017c3c4099ad78203a2610b2a975a760645f3883eab9f93d4191138338be2e727a17251aa09776044964ccd97c0a376fcf01a3a007d50890756f137bb24466a12ca883d063789c3e13d4c2de40408183b90491ed21bd2467eb70372fee4c60ea14227ce0e55bb537fe167603bbd8817e00efc25ea4c3fe2e0a0ddf1626b52e64d1aba012c4cd9b31024de372e295b1ce91710c55430da56e484ac10f29c83914f21ba2d8e558e6fad96891d67c9f6a2bd0d599e01bbf9794d18622978d2a837b105ca814c469d23438d63b7fc867d4de285ba5d17d2d87a8dad8f8f1d065863c1ee011cdb20ff508a4f7ccddbb8d1e1149611dda74f3a5c1ffd40ef4c48189b1caa2c1f7ac8688f7f1080ec9235b9f93c60166987abb1bca227b8a265a9f9ff2c246bf6d4ae6785b9d2a44024590b1bf8345c3677b11e427fb14467f2c60014eb061a1209c058d6b3e6bb6be35d86ec6eeb3b0a6c6afaffff78fe569c2e26599cd5c930435dbfaa7ded2614da51ed5c4e44d9bf1a7d31b5be7ebd74671881156959c86cb62e9a39fc77ac24408d1f34e0d21290ecb92fc221171ab5e854426a824b6f8b0a6e2b68ba8544d7a7a4a1c7bba8498bcba1b62c8ace44707da7db3f3daf0579b0b4ce7634e9f1d0d27b8036bbcc0ed172826520f491d4a7c7f1c0c005e853b73907eed103b6abd4616fd8ca7253d5a64e6635af0396ca1980cb7d71db19bcb2a06cb554c24ed447eefb9f9697c2bce20c9304ba3f66236749e6d6ad13845a3d6ec3fe3f0858fa21b7e7a1bf802c076696c6d7fe194411f2cc86fe7ea381fdc02035f8ddda60baeb2c7091e6815acd26757ea5c9135b1933d9884085c9cbcad8cac4b691b14366c8389c0e127f95aa43a93b52b71e06c56b4cac5bb8fe91161a9441c8ac14cbb54890b83cfa9949f0ee310de1fb4e6ce04bb9bc5118bf4b9a6ed4c38d6aca4a7b6e95beea5d46ff6a764bdd77a80aaa2374295ef49ae31085ddb11a85ba4dd71df9203756fa02271a6150f68b15d9e3a500d6c92cd6823b9597b4837b29b03b8b63786737ab25d6bc5f96ee04c85dd2ef7f0e3dc72828cfe79c13e188a71b0885981ada996e07ab094f0409c7ebb88cc0aae19690d060d6e1e4e3e90eb10a7905500d280883c80019d0448e5b0ec90fa6012afd02b349cd44fd3a4af8ade3a68f0339bfcc4a4ed67edf9e7c0e651aa42ed6e453718cc8757d390c882dfa6974bfeab80cd5fba2b146bb6db21cfd6928ad3890d338c0857203147bdd70fe1e8dafb037111b9c5a8c0df238f850d656e40afd91b6e369939790f9eb41e16ba072fa2677cc7ad5398431ce1d300e426b08c29f40e33cf237bfc8d9537645d6c35069cecbd43ee678a63c4d8e42128048cbcb78ea6c0aa2684eb8a01ab5207341cbe4fc8c80bc75d9cbb315b2bfc5c8c042a5ca68ff942a78fc6c791baf84e939d6efd8711207dea03a3811cbb303ee873bfb5c72413a2915fa6da7fa200e9b79ca87ba701d4dbe8602727fe765fe876ebd9aa2b9a4b884ee3af0b92c021b917c0be546e7426073e04f7bcb9d3eda91135a0d34bbda3c4e50fbd5913c94a25bf66bbb688ebd277e01b76c66005ee19c64d4c95e0cf8ad9b775a02ef8585280155c29b6e373658c41f68633d4bd85c209ea29ece4c8c3c8dbc8f7057f356afc8025b2f45c40b5c3ac7fb16192eecfe9cfcc89c83dc744d9bb818228b0e3f791e86f19651bebc2a2674653b6ba658cf7d891a0469268b20a997d8fd8d997e49ac1694f788bc2da3b4ee7da461b838ae1bf9eb1821aa0cab36be35c4ba01e7c11677e6b13c84bda322e8518d77c27188f27ad06377c51e7f3f7f6f34fe5144d3ae10bb49c67a2d8158478f5e2bf6556a256e7f51f78a497900ce634a82a592961e9c0c38b207be601d67cf19d5560425e29ae9a0e30bf6ad6e218c8028cfbae7e5b5149cb7ba0fef2321be946c3924589c818c828fecb6fbba059ecfeee4919d955af77a07b316e7a3d350daa01b60b0e68a8f173d3d7bcb8a587966c2ac4dd7bcf0992dfd0c04223a80bfbeaa7b8886eae0b71176488c6bcff51497a491b8b0f4305d298a5da8fa8c6784eb55eb910380962d2e869af742708127d3d12987d59399978887f479a73066c9cd2078c6fdcc4ff3a59d03dbc2975f0ac5377836e6ce1d1ca3cde83e7160415149bad4a4fc139216bf4b5c693ff03d0129cbad519edeab05c3396e4dda7498e8f9c3f88c9bbc0bed3b518a67e1a66aa4396bfe18827a17fa94ae0390a8e97e824d9f0b67a23d2a2e4d0620149c5dba8f70e7408833a45cdd3b2004be27616a0f4d4cb56d42fcb7ab3c29c4ff0bf3375b3d7d5801b769996dce831800b1e42711e32f4f912f49d0f3a2bd03791dd0ce0b4fe7a6e5bdf91803807623fe452bd1b6e568417e9200e0037caa1f254aee43199c6c60c7aa7d3dac8540115faca2c07d86316e25ee6f0cfe2a2f1d05d96d4a92299e247a81c94794003324a4acce319dafcedf2a4f2559ba080663520dcfa145e55dcf70473e20b2706d602ab804d24d093fcfd7ea3f10c6a158f7ecada73f832831a935cbcd0ad2ea946c86bf145363b07121bb3adeac46ed856560dfe96186ce883a9f245de04017e10db0b7075165740594c504dc879c8656677e1162a529ae9ae16b1c39b03b62998ddb3acc9f9ff2f4de159d6695238297558e445fce62a7a5232477786fb72374f01c7ae046c816c6d0ae61a70e098b1e18a2a0238350afa05d50dfe7a60aec287bacf6ad0a51e2892a0983a724faabfa5a3d1815eaaf247822fd1ef2d8650854c6222cf2b38f9f0c69a0027a5d64d703830f0f86d8ae38c5e17f9e0130a0565f16e262ade61c08c6db4e01bbcf90f82ae402c7c78ada2775021dc4de4565e7dca44acaf6ae60aacad318c3e0e265f821063ee39ecbd9a5ff29c6b25783992520d54e35fbc67a8f1b3b275c4e4c526a41c22bc194cc24fafe14051c41e3d2281e3c9c6c56fe6ef60feb15142524245b17c2342dc4c0fec827708aa9ae9ff42630e08bf81aaaea181bc2e78cf7a7e96df1554e8058b7dc62190acc0b62e8a0f62df4b7d6990d63f2b446ce1c40281fca7789d5de64c255e04379412136eb449f41fdab41cd9d8643ebeceeb9012a3a864f1450734013a8d8d7c0da6e1a80e0f84701241bcf9fa8f104f881d4a9b84fbe8c51e3fe56384182deea486a371f0d53262ddcd9a9878096533e37ef62d521e1570cfaf786203ae14ecd30e03aae73ae8315d7b03b877987451ce0dfd8da86341cf86f251fc8496fa97fda6f9f0270cdb25c8547664a6357f99b87cfe7646a33e112823a31e44e9f24ae7f9560d1fcf9e1353aac3b5f324efb39d47ab5314e12d7f8020a88b9991feec641878ba562bf7b58bb1cb04f44236c4a13db270dfeea40968e9a401139b2356ee9fb5ebdf396b625d55bf03f3fe6bcadc3eda4373b5b1a5e079d6c7270f335f6d146d6faa3c70f59c0ff40e6c74dd3de6aed4b11ef0a2aeec7a67f186a98e584a401d222348b3d85abb5bb1eaee88ca84197f341459043b514ada52df96082b5e870fc5bcff132b4ae43b5ee736a0370bcc21d07fc4ac2d8d7312d53976eea018757c425bef4951917d7038d9a28ad31c8c0c80e08c1f9cb3dcf76996d405cce8c681a0637742d3cb46552e8d1c9087f8576ec2004bff4352eacd35be223ee494796cb723f76ef2e2b3add6ee0c93d06d7bef61abab026dc0a11419d82cea07b9c053c413b4face3502170ab0ea1ff3c648556ecf727fbb4a24f267c4657f827a8975b7aba06bf2921c6bb894cbd5d23fa5e200f014a2fb28cdc92152c30eea870be813fb397f001e75065ace26d4505bd53ab8f71fc54992931e22afb39ddcc1468d80af0557707433be06295ad2fdc0318aec9e6fea1a66aedd773b03330af1b64a6488977f14030c15f6d98dfc88fe73d4c31ff95e1f2940fc3b2ecc75a6188d047a3a071254b489a1b0a74dff3b4e74e8e8274a4b06dbc2fa9659be1b70969425a87840c7d5274ae2faebbc328b9e6fb5e0369416ad3689436f8c3c105175e39ec71ed56bc8382b26c34ef7948f4e62da4488bc8c481c7974c4c5205c0bcb06fe85126701529e0e5b288c2e8b1b575fb5de7a51d38f50127476c57d59a57b79cbe8a29d7848107eaed0dd98882d597a66cff20f1e02bd0e70f1a7dac403999bd45d2c0d85212073754f5446e8c8e6fd0b0487ff96d131352705e75c2bb8cafd55ad19f10d7ec10dde22cfa4a237ac88bf757cf7689a0f52f75ca91a6da59ca352e25d1f80f619490171f8a588aed156937ed5b1fed9b5bb83dfff51fdc2faf95e72fcf02baca8c751314884898a673472e95f0d6016cddf0ccbfcf1bfab72912de2c66a84d62d11901ebe43c9c0be17ecd72ebc481c6c405f6371afe76c12b36ea7bf395266502a3268f4e60aaa04dfd8a395b1ca518159b01a3d525812dda577ff35c7ef57741f901fef27ed170051ebe8f639e217a7fe382eebb58a4e189fea3eb811aad9eb9d772dd8199d09164671b6f0a9bb76175e5f5c1e62efbc8187c95ffba6e146555be5b0aeae2bee47a2a627ba6233e5afbdbe7a770dc40a8995f7e495af5208b48d7cbf3984b538e9822f94b0bc39cf4a3603ccb7c34e8a6ed8794a500ac1a23a65a75007ec5970e7ab4863d3199332500faf90b215c7368efab2d7115a9bf9ece4a4a7c835c8466fb0e957bbc1f3dbd703c64ab62f729f9db281f07e301b6c5ab25a1782fc568573e2416296124e8aa55188691523731f425cc3bf5134d070d484c0a415d129ea17bf5977dccad654c063d612c4e022e9bc38b4c568120981c7a0b7ee51b0fcbacca1222c3c61de0491d75e6d2c2cae75d45f87e9ce1180c34e6f1c811af560bde89bd90a5ce9fe0c3a16ff1fed5936bbf2272ff3d2ca48ef33f7906e95c440e5fae9eeb867db9c1538991ba4cc7360e92ab8013087fbbbccd044a3c41f403fc890fda195c769dda38dd97b57c10bbb01aa738a4a7aa8c18e2941aa9fc10c527f5833ee7bb645e32b3c77a2b610158776009162f83eee18a5ee388ee431bc418c47396cda5e7a74e24c76b69a67c0cf512f9ff3ab34f3b9faca67f96bedeca4b7cf2a5a7c285a88471369e080b69b43dedd29144ae28fd90a31c741a9cc26c4299c80020155d66a8a2ffe00bf96816306c0a0bfdedd55771db0df4b6db8467364a3f5c80c18e210f517d146c85c2a9f9ebf37f6600571278881974ec697fd5a6539a14282cea1c8c421432057747609965138e6c6039d2ab4f13f04983280cbef3d5486096e234b1e8d9b2e691b0d8a4bc172fb5aa3d067c734691135bb46667d4174e1a0b6abff5f65e87920a8ab79c4fbf7ab849b215b403223fc29df6e236176bc245be96f7a05802bcae22bafdf7a3aa6ad1a8dbfeafedbe00e8d9aa28b9d86ba02b16b7b7a205470fb9ff3a7b6e10a88776d8be58469c190d93a418d9dac672df7b07b2d9ded480d716fc122178a7f7369a5db7cb07a19823040fdc5dabf88edc93127f83b11ca4c171338e960fb7f840197f7230f4760303c17feabb94cc78b5d074b81379c3ef4c7d14c8a86725160c9278a62cfc64f188556a40d4c79b8943907fc5521f16908a8468ec411edd2efd8da586bdfc14ac0bdd300ba7812a4ad6c3a5ba724dadcdda9d4009b843785641e8f33f3f95afea20df97c82d2a841764123a6964528cdee626818655180de25efaa3ab5095f07edf52450233b6e25ed12d5b66f0460b4c68832851825b8ef855f403ed0ec30666d342b0cc448bd3076e956cf0f73fdc62e3a69fe93b12c1b53de827fddd786e12c02388edf45dc9fbb67d999dc787d6c1b5ec3188bfe666770a392149c769e6277aeca5054380a7f6062b015928b44a4bb0da1cdb26b2b260ff4729282f58c1e87494931e1afe8019da57359e320894d574602db50131acb7f9f412e6e0ce3a4432b64f8b140bfb7a83c7fccbd0cbb3396f0a5819e5bac471029d4a90c469bb741544ce72b06d988492631b375639a7e2b79af975b6d515e1f6b2ff4da175be1264aeb1536a7617850903ca8d399f00baccfc6b2d5c8c27615ccb92f901c1cc8f493a166094dfff94a4e01d71cf4a018fd2a8258a2079b712dae6b9429983cfef00cfb4f148b33989d797b4c2613ced3fddb069792def910741277a251a1f787c14a56e254b61a49cee0338caa06cf00fbd14718e80f1081cf9359bd1f66b07796d0d9f535c67940d29fee64e66fefad50616f3ea6c8a0117fc1cecb99385793ec13605e96d647c8a065086942baf1ff252f43aabf0731eca29ea0f743d232c9736bbe9386d34cad1dbb7e47024f855f2a4190380fb005e18653f1c748a1cdfb253d71b3636b23428c62ebaa55808940256d283432ccccc03e2a176c2ee3a2d149749ff1d1aa3101e86eb57db1e5be4ab1cd5e50187b8aec91973c91e433f8fa722b2a4ea9f1935c6af2c084f1b5ca408d609468b2dd54ce9d574b9032e6b1ab1dd8e4c62858931fc02186ae97e707d55dd0c140118c3bd55591839553f98c1966943aafefb9de412c1f0f5a82f7715e96c2b56a14efbbc523299263d9f7ec5c4fd7eae394281b556f55bf2aeefc00936ad9d838346cbb4ec3fa698062c8f05737a4590c928ed1939c1310e913392c7b9f34a23a6cef626877ee8ee60fa12f1e4ecb76111f87602a800fd8c95c74b6b6a140e1fdac4b45f3da1751b125163e13d3841e56cb941dcff3987a5849a5ab4b2639113469e1de79aa38a3aa0834031446f9fe014a740c362de86da37d22463e4807fb7dd3a3ceadae0afecfa9ec59f0a08063f2172597ec9e4b8b001009f60a7fef0946ead977aa27bca398d043d754dd4e22cec5488c8f33376c56f734a89e5dfaa392435101e78125ae00fb4c1b8f92db39df0ed5606daa0955776da206ac93d0e281ef638f6b33e84ac7bddaa94cea6bec1964d62469d64cab4d75b75f053f04556dc51e29e6faaee79d442480090be9141c5ef62231bb9795828efa863602b898ec38e22e3017e3d0b471b1daa1ecd4979e0a2377eda9fca44f94fac3c99edc17afe5a031c2765ad1cebf3c9d40dd39e88caa897d99b5fc7025b255dcb689dff3719a2758634714e5829cd62f49b163fda04140242978dd3bdfe6ae13b204bbe50a51a539d292775d763d50068ba967a968fc8e6ef3a2971469fb19d9b5f58b9667cabb84aa55a14f135999619baeefde6d63be8cb5350406946ca559b621330951818906d5b242b66ec6fb3452ff4b1e4f0873805a63dc6309968398de064f759f865d4614de6ff10df56cdfb7ae21fd5064661b9c9c9d674bc8ed48c997c74a30b7a200c5dccd8666988a57955e6e73ab7f3d4e92a6ef35e519ab56060c559eb010eed3ce4e3a9f3ad6f2dd37f927cdad3619078a60e448eb30950719b9bb00faec4c9768d1d07ef1701e2a234a46ce34037a26c330aaf557d1e0de62baaed07e5eea541eb61303e28168d0c5019340e9eab0deb3e34a56b330ab08b577b21879581483881ef8f384eaf7348179ec0c23c0de340e43e48fab2c9930a5206680a92f318cfc7f6e66df6ecbfa80affa29aa8a09c2edbfc3887f356735810f992b43446c6007a2951cc4d989b91865502a301b70c5d485ca0d1e32c50f933d071d813b5ad879de3258a79e3c02556475222198865321690a7ede766e8cc6a45b146f8af9d013c7da6ec6450ef494876ef3073e4541734e6ef8a04d40d080524","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
