<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e45031047d59e65a54ad2bcc31b0adc000c1d05ebe0bada84afe8ca1d301fa46292460a68372c5617d5bf5716545616e9271e0ff1f47c88e9aa56a1974f634a3dcb34c7b4acf7cbd373ed76c9cb1d3217ab4701670034981b7a0903ad44723cd181924143f9490fd3cd119066c07e84164be053a335aec81aab26f0ebed8c2c107ce20724254928c0cdae56a3752b34f0705945ee4f84e6d9463c85eb3c822d31bd5e41317c71b50217480045c63e4c06cf2cf187f2188b19e7429f397fa3712d9a4980c3ff444718cdf82021f9238a81b6aeac82da78eb9d795c25fc827ee2fb9b5b7ed33029e1057ba83e982530bca9d6d6ac3132aea647f6e058b526927567b5db063ffa830067f0cbe4d5d2536d4caca25ed64048c0e0ba09d18cb8142d49145e47e7abf0b4995856b6280cbc1968e5a24e5bce31567dde59a176005278e02317aab1196a47f160a6e160e337bc7c908be8f8cf8f36c7e6466f037a91ac47fccc391c957a76d3a19c6644c90108a777b04135fa2944fad249b3b46fdee494343ca0bf96741151eb8786981b8e112ffdb69c5668997d0a572b1afec668e529fb226b5768cc53aa3b20ea19d2671db3b22b22e039ad72a0b450f25fcf26c7a8574de46f114a744404681830eefd5475ea111e87bd1e4bd2cbe80d1f0b41c4f58d155f0c01279085653d5376f04fd390a0a903f2ee86286ed77ec617530c12e39dfebc216e4359509909a272544478cecfac051201ad822c443e0b793e06f6fd73f7f815f39803be17a4f098e7c13efd33377cbf671335b33a1f05ab38a83f79c8560e8f1b6a06bbc91fe6d9bc04e09c89b18f28b2c8ce7cf9254201ab70d2544bc7413439679565b29b63d862507b241ef526aecf4e4cb39127754e9323079b9bd9496ef19ccacf4b342c2fdb601769039c4afcc1b6f6b14953b5b25210dc39e90df6df9eb5d3726f1436908b5b0403b4e0a7c0de316c3c83682914bc41cc0c435be6041e5fe70585f7c79baaa979163f7ddf218c2504da1a71eb3184b8c6d89b6e1c1f0db6ebec6a4ebcf8ff8d76b548831b1d977d7d2b3a2b3a2c8988284d2e8daf1c23c44fc9ce5ac4ad9e460f016b9be3d8b59b3f7177480f4933a3cca8937827b3e1ef557f7680953e777132aeb5962965ef0848c3a65c7a9b600e0e7ee2bd037e93ec2210ba976aad30b57ad8665d8d079794e4c193ae17f09c62198695360180c83eee8a5a459a6335fc97c69befc52846d3f571bd88829b83164752dffa26e611ac859396931db11e4ff39c17c3544d45d3dee0615460beddb816865d1929001d48a8f28fbb16b66fc5dcd5e88974d6652e8f2e0e09fc5a13720a521ef1d63dcaac68399021cf147dd6f18a4b1133ac140f24f470012d496596f0fb13f0dcc3c297099bb860c4770d3b5f0a68675deddc6f82dbffd730d592b967ba4ba204446b35b08485edc9b4a731f77c90807231ebe41b9f4a0d79914fa0ff68f99127cef3f1fbf0df95587739e33945c1f8475097604c44970f371bb6ff88a4e8c6a041904f778695fb10584e64f0b016746ca75662cfaa2dc0c1e8a7ba3b027ed2d705fa5dc0ff043d1afe1a540172e2b3e2efc538d650d17f2c785a4193c7a564eb5a03737535a45dad881a2065371858337ca6a87fa04196dd16044b515f56e55487e8b65122fc3c069c2be7d1b39fc0085e02f2f8e279696cef6d6f28701578f72708153f3b082ba0d5bb67f54feb547dd4cfa61a34894c08e3a7672cd72a269da9946501edc70213f7342598c40c2c58f0a685f24d7b7b782334cc15f0dd06c092b0a5d8f0d35b286978266da6bfbc40b470610fff2894e4e3110054109e9acc7e8df856059d85dfd63a8f39c8af2e91e8d2a490e317f94945d3309390eceda50e4918fd94c42bb42d1f19a2dea95478359cda548e624809619c1ed5f6598a7d439dfd59ee1f8b6f823e243eac11323124166f2f720d25e7456828ac1d6cf602ed0e3c89e368689cddcf1320b3f24c9703a6559ffb95563374b3259321fe02cff1f90a44c699243fc0704040860ddfc64eab33b93cfa500c61cfd8f29acbd647af19fca5297f59a036564ed77110bd13b0ae3e9890a6c9ac21b81cd5cd5590db6932fa032ba773b70794c576d8cc838457587dbdc7ca9c340a2c873211966fbe5975abf49968552d888617d5546895b27dcec418bbaa15b243d3ee0b0f0040c6c0fd89f2ae479a0840608ee4ac67bc4fd7c13a0d2e77fb9dfa87568e70002e12d3bda8106506062e6fedb0765b040a7df94c5af8b4d1acfc99b1c2443f4984b18b0b7d3dc0b6cf7549a79d9086ab34527d5c7c8d00348c759dc4b901ce838626adb09607419c004776fe42c34f6882b3048cfb62d64acb0d177f43d247cd4e05e4adea407e457ddf6a3d4fd9aa2ee8fbefb6bf6c65e9295ddee5d9e26f48ceb2ba7fb8f7680989bb2aaf7db91d1acc945ccf638bbd74f86c7334c7b98a1102969ed19c45c730112dc110d5b4e002d2ff9c75d7f6e7500a643980bc9c7f16860766f627b3141e21f322b566196a4429cb8c7c08c20f2429f5f911c2a7694b37c52ec2055456251849df7712f539b376c7c14657c40d79c618ee221622f90aa279a1259baac8104ecce9654e44bda05cfb054c29cf0271c4c1ce2e1c1e9700c1b6981ad1254545ecce0893498f918e03628c393e3ecce7ecdcfed3eb47da0658f3428397687e8d50274fd455873de5bf6598f88b8e962c6c8629c5f9255438f54f82e8d8e163ae2c5ff3a7b96594f70c2de2fb44180b60738b8af75f960e6edff4a62295053dbf7b8e09289306acadeca99272705302094fc9d8adb032c399adcf219e6dce21b03053156ce1684640cabec7ce062606bab0acd720358419a894cc15e69af9f141bccff8398ef06011e7bbc920d5ffc5a53aa01a2a8834a7cd82fcf4964635985ab1d70829ebed4358e088988147dfde712ff0e0cfc3327134e9a2f4a34468b674b3c7f0810b74e50f103896309464fe64124916684b673a8d391ec6f173a1066ca2fe279a1157610f08b1ecb76389a9a06ae990a8faa071b2eb3d68ecb864e91a1e063600f05b872a36f5f9dcb6e1933ff377f7cd9eecc98ba23099dbb56dbe4ce43e6309e16fc621b5b116c23b89adf7f4d984753f14b1c1b035d92e852db3bac526a838c907e05467dc8891e24c1a05ca50819da0389aeda10d185a7373c4c2e78ad24607b9b70c7cd1c8317852a0cc0721d1917e020daf079118025a42fb04fc8465e7f581f7d65bce66d668a9362b5f27d90bd94abfb6c6d6aaf8bebadeaa34dddb0a9a1d9a1472b3672b4ff7952f96ed4342a251a0489f8b17925bc3a1b55edd199af555a452735265626fc980eabf8b6a208f80f6983a17aaacd26931497e8d618c937199362e2fcfdbcee31cfc03a852a41f8e642b9117ee2cb36f1edf5b742311d6ca3c5916480f0236625d435f7f61b8e4d6199f37e8860d092c68f81034970d3e8cf8d231519c8a1e4fe60e4900c6eb7e1030b65e40c27fa8917b78b256ce8af50aad868b4f956a41fdc1c6be68c520a90fee867c16a8429a01c67d3d50b31a74f8540fa12eec668284a18df604a06055ff93aac6c249b108e68d6c36d5c8756568b70673ecc284fb89847b9c6c5542c78cb43daacbe9b26fb93e3af28768cbfa7aac08bee0a3894b62bef3f201b7fed77f419348fcaf0e74aca714a2b9012f1d90713eb5fbb19b1595cc9ea321f1f46368fb8a613e4fac7efa45280384b5ef7944b46a56f43fd8895a7fe2ce35bdb418187342ec8e7bbb7072abd0c21e13abb7b63846c12f054b92e76775864c64a6978e0cf00a11b38f0a2a8773cae3330956c5daf6e2e80e9f748909e30843071beac9fa4ef13054136dfcb341ecb614767fd30c552b36fb913e52f27e9fba52c098db23ee0cc75bf09ff9efe7052ba94b2f87742d751494b2b5f60150532b46f6c42a0cb00e0f383b0411d88054e27eac2e3e6c84a86b66974d544c7223e17a149e7f084f40463e3f485d7ce35010d00953911ea5d19e84f7c2e9816ef948aae7b59109c1557c3e5405ac78c9655c33db646ba24a6d38f3f1edf88bf093d1aa5515e727778c33d2c68e7eb0392e7423e75d2b1ed5501cdcae51397a0449e68cf18093f2094fda96eecb16f6d0cd1764c991ee49fabeb9164d23a4a470a1a0eb9d8b1850c41052df457d76147c3abce377d772a0910a3d8417d369b4b78af423293f5388f4ce895e0a1c5570609aade2250c12096d80b859ac06ef0ef03b7e2a51bb61ace5635d087c20145c439bf7c62c8cad3b05ede2aa92881d75a7c2cc5c0df287fd71af7f8552de2612f8615ad261b3fc6291fa0e3e2dfc312c13eed1ce8a39fb92f3eed4aca989d1a4e3eeea23553615bf2ef1623ff12ae6e7130716780f28111e78e3ac7c27964b3d40558b2904802712a615d6a25d95483d52ff10c296b586118b63ffd99da9abca989ed3ba58ecd089edc0ef8f34060314bbfd210b8b9e073bbb5fcd1902181feda0a6382290b6162f60ac67bcf9b2cf1f123b36b08ebc4b3ea6ea188e3fa19c433b9550f6770aedd6a27526c4d4ace1b517963e341ed6fac932ba87877de81d5b393c948b3f64153a8d1b3c4dfab2e60df130907596b62cb53cc8bbdf2346499d190f087084faac3f8b4a6844f745350a1e186e8a5a7e2390cae5ce6afdb170d3971c36d2d809916ae8e6c8883662085d660a5b21674c5169e3068d85079bd2f1e0fb24b2fb164cd372732e1f57057e5333acdc6a4f809330e755600bceb58a99204ee6380bee52773f185194db869077068e94f782df324191acc0062e807c29476b90d77bc7b735c94f36b20702c603084325bff667b2169e3170e7529f556f77d81915d71115f79a93796b61e73e837098702bb2fe63b35b044d70e09624534c5cfc99cdf048e0e7b30d9d55627ec66d9cba2fd440bbc60f4a1ee008dfb577f6bc753e23e87986f8d7a6c0dba36fc3a22d596056aba18bd37b5bd00e45135693c47f993a0cce438cd9013baf496d7eba7e7bd6f144ebfd00fa14a71ba9f6fbc073dbbac13c67b7ad589ef3eb6f4dbfe3f52e0a15db052d4ab9df5d57b61263e10c1c92b77229c0cbc6fe185fb4eb05fc18a609569a50f076ccdaed9bc6398db6a1623e731508dd9dec9f3c9bb83ad55ae8422a724c918023b4ecdf9cdb2668adba6b62535fae99b27294f06f217c38c310cbf0dd45ca9e57838fccd561dca7c2a1c1971c48ec40ce98225db74cc94b7374b8da1c2b78d7e93b963ebab3887abee9e0a71751dd88ceb24340620fe08cf39324159b7012c018938d32e5d5a30280789559251fd56189df1e518cd4326362e658537ec5549a88d5111540681aac8a364762ecbddd0121db886e2cbd08296b42b181408d7b7e45f24cf67f90f1d00fd9893d38493fa2d8ead649622f9a1802ef17b7e5156d3828e2691eba7097e5d40449484ec598d5e7876a10b815aabc87c6ca9f2c4184cdfe9249018847c80d79b19e46af55653b288b8cc682c8db2a695d8f2c352daf47ffd5228219bd006b1cb0da6ee5043f8ad0b37c1c6dbafdaba525217e577c82315c59504136923075d6dd8c38f6d4150c723865066fcef4ccbc31fd69e5e1cf0d06fdfe88b1a53d2bf00998d3acdb9282e136a670ebdd64e75969aa3c0932287d7d7b6c9d713c3b37aebb86a82daa4cd72961b6e84442ff2035152257b6924761387272a9054d25ce0f32a2cd216de9406a12241967f9e620b2bb43267a25ba59f42e1ec1484aae6eee60afbfc218b5720cee15b6ef7ebe867de7dafd97bbaaf0179518b52acf8841eb9ade45055859373a15c95257f9763984f31f1ff3f125708c6c6a813a0f46bee06235245679befb4ecbe27b464462d9e17d06e5a71082b3d8a6d3116bb7f4fb085bef7821c7f7f1ada7d94557c5c55428952729f990ab423faa023adf2cfc44d4a134dcc5a1fbc71c667c4db26f5de5b76da16d6e465a859d51775340a19ca231da3efdfa35f22ca9313be56ade5739936660fdb515345286962b19af5db220d4255be16a6254b217ab1f0c0c6f99fe1df587dc7b98abf1f9a46a1bad3665dfaa1665ebb49040835b9f451fc92b8137a2a15523bb07b02cdced3018cbdd16118506ee0c0d6e3bfa4e27c5c062cde5b8cc414371a371a47467b529613d90fdebd1552cff82cd1ec2e446906e3c258ceb3eacbcba0d49691cf20acd7bae68a988abc7e9d500cd4c218eda50a1de6c7c31f071ca9d162fc07f3a01f86b74560aa1c5479b7d3761b7cd2a91aba7b160595b36e4ad1d58215071837716be0db605f28be119b0d222dc965bd50e34bba94ce2831714691af0814eb78290b9f1e71ad48876d7b546fb5bdcf9f2f99be930956695252de4b822894fde87eafcd1fcf67abae5e4f2f5e0383210d456931ef56e351d5622777c46a3fee7936b432a2380c7c19cc4e4ff1d2ed2f639bbed9970604e4a313a8d662b6a11b6fac32ce6451a005e977a036adfe8ac149219416d12f131a36820a3278c28c1b2a9cf07fc04d769005a1e2d97ac488407af9066b0b55b4b5d91b674383e60eac64881d1d1bf6833fadebcf1335c77e614aae38b6ba7440b70b7bb1b11c56c9a2dea6d294b83d39a04e249329ac6a83cbf92dc947168bc3c6165eba8e7bcd159e109457516374387b13b30e0fc028e75636d13d6d97735dc006b30e0ef66aac519b02639cdbe40f7e248288830dc22822327aa47e79a90b962c403a663268679385960653abae2072735b296743620c87351f9177f9c3baf6da6fcf6424d5fd22d63ef14c026ebe475e0c1fee08585a77d5967b65acc631ba8c3e46e262b8e578753cef85aa8afebb7e96bf50ce1b01c1b390712163544eb2c76146d23202dd7eaabe99c26aac788339bf1ae0d8990da427cd7423cac99e577a401caefbb2da1583429e59e25fbd4b1ebf78269d4416b75f151c2975dbfbbf922bbeb8ea1cf78ef5d9d94a23949f6bfb6fd365f8e6529d376b84270db8c8b2c89e90077fe77f2f4d76f3d19f962e58c7934471da552976fd31c16068ae4ea11f59cc3d0c19eb10f2c331e83717cae25b1923eb0555f7096b80c9b212a79aa1efeb50b49dfabd838b4fba9ee973f3d4a80fcce648a4a881db3d9270f478f519b158df89cf5dd53ab9451fe6c5fae1cb0b15dd2582c8d278e9eae4c65334fe418c5d8f26cd413d34f71c47071d785bdb1a5e667c46689f3bf331d0ae0cfaee00adb31861ce57b3d0006414ebc911940d6e5a60e91042e902ea9acdea9fc30745869816986b501b3d4cf4a1a6d78c5b2295b7a2f52147c88e55e0026adc72a524f3e4ee2acffd524fa3481322362086e01b8488f81f2b049a48889ac8bfa5f3b28b111d542fc38bdc8a80615efdda689ead9defea0d7cc8b53c729e50f6a8cae589d7c6418993c52b1cf460f11ab46d93c26e249a57cc58d4e222cf9b55fac91bfe6bb524f951960a09c608f9df829dca5fcdb546f025801c859f49c72641f215721218001de890f7653aa83142468f15e6e72021728ea5f925a005ecad1319ead6faa6eb7828897f9e352cb86160e3efd116b0470b028c59ea3476a85cc535198e4c93cd799814564816dd6d918e2cd89d1ff9d0878b0cea497921e9694cfd96bd3fe80f8f62aa339fc8965b1ddd7b3ed3252be4986b883b3bf90683e1bfce1f6e4cb8205117163816f47b9f4186485143576c68d96246117085b61c489b458f765c30f4787cc16887dcfa31b09a4b3b94d5e3fd47726c8706161c38bb5e1ff4c378c6c7edf3922f168bc4761e78aac468bb19e904c589bf0ef8a0a6877fae69dd442f8fe61af6406081a2e69fe69cfbf513f47aa77b2e2ef0a75b58871d9991ec15547777cabd1646d0b38c28d70a92ce152396f15c8cfffb70c38b994b292a0499c10f5eefe1f3fb6c48f69c8694ecd6354adb1aa9aa8f53a14e07750d0cce0dfd33b3c650fe87020369bc482f6f5d7e300cabb3259be899909f58b2a1506b990d1efcd29b342848f12544ae109c91e2002cc30aa0b69acbcc76ba7418d211609e4a3a5fe7a2c16b8f0ddda35f51f7774cbe2455e8a76b5775f5c04dc317f1f006accdbe5f02357952bc62df61648fa7803a1975dae218adf261df4526f3977de40eec1863cbee22586d8af0141105ff1602dba0f502d468fa29d2344b1e75c0e28cf67ec5355534d9b8ea8130f3b32d220b0b6ceb7c2b114ccabb3cfb68f77dd96f8c3f9a619b90bb3fadb0bac63a6f159405d86c83a4e40c7c2d48a8f4a7c6ba23642a202139dd879123a45233295827db1f896bfc170380a4eb01f4d50523bae79745fdc637f01ec2a5a8a1107d8a8d2bd6fa70e79c8c61c9a94d688c96cb098c66541a96ea4075f73e56b01a7bfc0c305022a3e10e21670efba348ad0c0297e688571639a5d923008c2198ed440984e63baab2724b6feb35a17e10ad96e71b5fa581cabf4dcc964dc820f9e3d2fc71a73a662cefcc1e06db8e26c5172f0d2b2711b41462456400a6fc1d9f1c6e1f172b7f59270a2b50029779b175b6e5455261ffd60fceea2af98348f50502903c598db2a64024ef6f803aa07c7ab6e8daeeff40763c1746301dfacd24816b6861ba3031e9c6c804e533ce1a35f87f83c511c53fab51b59506880425ea093afef3a8f972850c6f6d1017630fc46fb8f37b8d1a586fab90f21d6fb9bad49faa340997e4d2759156cc8fc2b2a0ec137201dc06d93d590cb0ab4ad17f594025ffa1935f83940ca1c797d6417e5d5a0dae62bb38f8d5de9eda3e847bd8db42fe460e293146b4545a9abd275bfef3a4353bc953d988bf6f605dd2fff47921005de35ec5786cb0ef29284d78d8338f4462c0cd27085c9d5ae977a4c7efe956927120c7c9297dca40d2155f4c4a7f23418bee4c51c39d1ebf450f3e112dcb8069443a108c36b9cce269b1cd65fe0d237a9661bdccd9f07ab7757e1e2e38cef885191151a09bbb96baac20a694bd813ccf538d1eccb4ac764c239effcfb68d1b652625169b349d30387461c297ca7ec11f14c11d31f60f1a50dba9a01ee19bd6a09bb89e353d34e03791515c2f339b69c89b5751fbb01b8dcdb9cacde6915f38164ccccb72a73d40ed20f0dd7e196fdf792e6147afa224156d5ad0def0326ab39f04ea40909207e5824b1f507437523272e2e45a388d0803edb6ce242fd75136112c9bc78f42de5c4eece607936f713996a78f0e10595d6b710e074fa16745995ec77519acf97650238f7b4a66be6996c281dee0e102b6a007f7a21bd1e731bcacc7a4d366380cc93e2c7d967db5e279e4b3ab78b3d3b1db6da798b1c6ad4cbdb84f9a67a958ede3e0b1b20631e174eb21636aad17b878c55f04cbeb96ffcfe7d468ce87b5f26bdba5c1f02e25701a3d5dd20fa0e00273911bca35610f3188803a67359f5af8b59f6850699f4379a451d81c87872ce41149429dcf1a39bfea09f7f301e91e93c5e429cc27d8a601646794d14af3d06c4d66688f95db2fb362e1d4371292893d3415519f948ea02e842bdbb1cb761cec47a8e932a32634932a12376e7b99983cee7f6d6cbd7262043a9c5dad1cc3b49280207cc4a79a59b31684cabb8f1b13e97842546f87dcf806f749eda8ab1fa04f0fa3ae2741ea17c182f4b06e5198f3b1076e04096e9d32cc9e8ae7710b63ff76204aac2e7d292f7b5262ed9c149a5718a36a16b83e9505fa86a71327ba44bd2a0e2dc00fca85b44e9a637ea18e50b863553f1e6857f6128f186ae1b215e8af59304e28622e25639f8a7ace83773e277b46bb8236b8a1e88eb3d1920be426b4429e05c0d1df32a7e57ac56aaf0ed96bb477cb247a5d8af31d379edb90b262b04c720ebf35a272b72dc7ac1c4c2e3484148dceec939ab21c351c34513a4d45ab032f163eef4707c331e6c8bd757396f902d38fd98fcaa57055b9175327e4bb4e96a32260c39154ac72ed3066ca2cb7d7c9a2f6e260b710d712d0512526e1f4cc670d755440d129206d0ece2d338a3562383997ed6c2c9392f2b765f0e0219499e3408e14d142240515fa07b824e8493dfeee8e99f3b528df5c78ab06e969e1bd7530fb92e27d4f9ce5d96b1476e7243f43cfd650f4a898bc4de105050e4cbfb54eebd8b9b2488512dd9d035a547b12a6c2c283453b3216529829741748cbbbe5c2b208c60549525f931ec9c366e264c55a86f6c1aad9bf3d2f142ef93b29a44fffeda1717987242a4938dfed548835a95705dc8ed504ab3854c8121059ef7c1e61cafa019f00a84cc9620f92a6c8b6dd618ff9546728eeba7c9fc3fc76a9e26307711920b7b7083a73853abadf9c452d6688190399870812fbf3bb60befcf1a76c0133b21d683e54ee51ea7a2e1937a99d975b62d4a8b4d9fba02b892f5247b921382e11961992153b9cd02b07bebe242097a83a8e1b9a7f2c98de130d0fc34d2e1a36eaabe52733d689c482eb463c28b7bb1b6df96686d5a1443ae2825b63a4d3ba6fd8ba00b1cb5b0311b8bb92201b1c72424f71d8e72f8d7a4adaf5c07e363aec094ccbdfcff9a1b24eff65bb4765f309104f7ac799d71bb0e5633e4bcb38c805bb50dafdff20fb4f34417b1d7c1d55894a3d710f7e8c37992cbf8f602338ac2c5bd857bc6d702a85c90686c70fa26255877a71dead23d9012b4ab468f924a20d5c0c6b4776f21b50a193b5866a3dbe391a55df095f8cbb55d015cf63b833ff3e76f95a22465825e85a7a7da2031c997b2445ff8a33c6dfb89547c0a82e2fccddec77a48bb6ba60470c684315ac1d5ce507fbbd64fc446e566f39924af1cc310f8e11c664e516dbfa55428c2d610a48e3cfc848a86b0c784089da966d8d21a8ca25728746388620c05d11833c1d2d4117df89bf71f72237b666ccc187913adc5d6723a4f058efcb5415e914ef15b81a2201b0ecdec9d6a9d2b31f3333a9a7396aa3cdf2f03ffbcdbc882bea7e013b240031528639d78a062a0e6beb3ca6ab2b0fa6729424d511fd794192d17af824e607018c1cb42f14e9d9715ea69860d67a198156e8179d26e17ff5aa2d5352bf6f1012f6eea94257dd0145cd4454b61a5ea954f74a3d9ba3d8ab92444dc657db5acef8974a35c5f66f6b36eafae2f7166b82ddf41ed693f7e4c5fc628cebc902a82659bee979f68f09947774d5467eb28492e181716bed07e157e8ec1835a69b0eff9e480a1e50a9debe38c1de6f453bcf9c7eef92596fb5525e499f43a461d5685718afae2164b350f886ab55bb8563b096f7ba98e3d5a6aab0c1ef646e3362728894fcd7fd6d0231388265699c6e2a451231a97e1a7116c04b31155ee7bc67ea84a6fc5328348b2c1c23cbb6385b3a44e6c50dcdae9f96d4d8f8cfd6c484552029f5245e882fd3a42113806538a0b497ed06470d9d720505ae2ca57541c722337bfc36e05479fdafafb40fb7938aab7930d622e3f4aca15af734b8c5ecc48c9ddc8ef264f8e79d266ea5294a6f66026fb5ce3b4e537ca2cf35236d8e56e1d7135abf1e34d3d48cdbfecebe0cd46a22025072e1f8e83dc0ffbaf4ea7244fae3029894bc232b57fe259324221293f4ea38c7bcd9ae49ef355d38487373d5988efa55192c5d56a14c7afb41c1b15220a739008d4e92d49e781d273124129ce9671a6cd919517d95b90c7dd6efd8b4884ed1818dd8c88cc98ae812da0e974555088dd58b712b644e16359f6db460e36ed688ac25a53ac0d12f790e116d822bb8b830bb7988062f3f452781f9dfdf47ffa2f75c0087d323eacb119bdc598c96e4f4f47aa5d3591dd77b8a9452a7463d114fe61d30ec42919c373cf336fccbcf7d1f71c1abac44459b3d07827e74a8de34143bff87cabdb3f5b31e49e034aadb6a15e702d74644aff86ae99bc11a3a58a912bee3fc7835351bc3bad8c1134fbd2c1376eebc6dabfd0067f01171f80417a72f621c082508ec87f3bbbf015f6ea31ab7cac765a5f7863cd24c9e8f8e1ac11d2cd2f6c33f08bfb86620a1c6c8403969d15cbbef537f357dd9cb8eb626190ca46f71b8dc32ad331e6489afadd4755c12b48182b1c69a219547a72e49a85a363b6146a62ed4668cc84cde71d3f64dd34ffff2c95c2a4eff3a137e63186eaf149b50a819fe30a206c74d6276a55d8938d8147367d028c76356148589f37f2dd25b6bbf6ec8af133c67cbb228f4d239edfba971556c86b918c04751f8cf8c627f5b4d45dda06290cb6a9043ead23254c91ef9e21f225788b9510a861d50830a220e40e26536f740cf9cee07357d5b1c0d5b97ff89f98eb4772a3def026f680eb77ebfcbd889d759a0e81ef850416512d8d1e41175ee0b1c9baf2c7f49fecd81968ba4908d56fd5b62e8352891290c924738cb0554b38bc3d643c7cacbb4404c71d4be9ec34d94ac92a98f408e424fdfd1dc1ca78aeba315960a9f487a79d03b47158ce04510a3a6b324ac157027dd2667092a7cd79ef48e1c7ca72be6e2797f2fb88a54f70859192a7af33da12767415f3db9db88c7fce788ffbfbe392a99e3048ba04818eed409031d073f69742df0c66d7c0e03076acfaa5530de984880829f389097a493d0d1ec9fa89a6993412154fbe76f78bd7d9c769ea9c31d378b27bc741dd28fe272248af39de12b16cd05dba7fe4dff49b38a34eaff181b557d6b8e15144c005e438936ea3347a5f65e5868e5169dfefa01b530c5c52a3f3e2cbe0a8210551e2da0828c38d72b347a3c458f96d88336af1fba7f13face2f2e74f7569b9140ff83d7feb559e3d1cdbe691c65a6458fe2334a834349c677329daf573016bf1cc8c147d395518ee3cc2669726118e5ff94eb81859550300f39fe0f6672b907bb05e9aa1b66ed9bc0b2a4942fd2be92d93145d7d971eea83fc23a4ef0dcfea48d268a353e91bcac39518e2045648563b10e2e66faec1065c2b0531ae133e35d67d3bdeb5c18566f4b6dd30c57b3dfad3a635a156935a315c7cab29c2bc9aa67bcc30bbfa92d4a5e64ea524295e75f462e264c04e5882ea7081b738812765e2aa88efdc83ce22fece4a2d9b0f0c87670ea04e3d5959a70c9c3b610c46d1f014c87e82cb1e4ac3f44c2af69fe381021db77b490e9350192377569b624d04862ae625da7e281dee9e89a421373aeb0978f6efc6744b7a0f000186b4918dafcd91cd8b3461425e74d9a5be9876269c64affe8f12079ab91ffaa4b395afde6cce31454269e625fe247a66330bb568796867b046db78ad76d231129b4474cf7a60f510efef4e6a80aaeb565b3277fd646fe2436639ae4589c9532ec4b0803f32a9774d90d8b517bfc0f01fee4645b688bcfc56a04d3513494616e0a04b93d138fff7fdc126eea60477f959c34dc901dc5dc6f9b7b0ab34b3a15d4e5458bd1c0f363666b3135225bb13a8045dcab151378e22323b378a65459ca413e2292b6648205f082347725a5f0da28eaea85057fa7188a66d02fc946dc204cff6d185e40573e4897499f29aab82a37eff5a61635f1b2b76c1a29d136a93f793485f205bd0752300c80d28bfaeebedb774e3b5a66a4ff67a14efaaf753e47afebde275ccda317e923f040b1c84a209f265c0fe5ebdab707f788aed426399e0f058ffbc72637b52ea6ac112aa960e93bd9c06885cbefc193aac0b17d64f5335413cd1173d3722f78c72c593786b98215fbd0681473d9dfe2365121ce1cec468e5778a9c53217195c500ef9f90bd9c2325c20583c72f60b54d105572ded3be75d68f227cc030d7dd9ed4d8ed94f9377edeef0d4722cd1792707f83c571fce06925f5066df032067e37d87fc17fdd2cd0f8a53a4abf2a81f28ce1edd5adda04b3af84fd9689be94f15c04aa134161b8dcbbe2a982a67abbae1c82aeff6f79f1b19b49cfd2a26bedaed5bcaa52da2987974f6864606663176719ba58563541ee55e05fbd3a88d474476ce4b700b2b95dbd1b2acd5d7019b426b390e34661b3e16cc62813ce4a96aca94b3d13f3d917c8e724bef625745a1a24bb5e5645ebec905e917af65d9504d51b71759cbdc30d9751882c57c60c006e65f94d7db3eaf68c1383b0c1e98baab188a750c9bf7a3ad42ad1c8c9507b812abe4971b9586962f2a563b41a7130ebafe097188ad0338d105d9f10cb97a8c8809ea63f849cd07f66efed8851d3a473226a1d0a4418b37d694f90a600b7247d2fad52fa74cd7f48c12abe1a5c021f58be6905c297b4278f9e5cd94d4f025060337820a1a751e631122ac18202339f257bf9134ea5dcf4db8da0e9e50e31fa374ef6fe9f68eaf2c31c47d149f91a1b440b0b68c0717fc9d39d514715989f30561ddeb9c75f45e6ba1fbc3e6d8620970471d70cf2d3098fce9e98e1b25bf5f2f44deac297e362c08acfb811562f31308060a45fc2211a5ea015a045ce58166990d3e0718acf50052385021dc81791400d52b9967118dd4084e2456f8daaa207ee2738df2a9d1b21e6a3cdd7af53bc1da87e37e19aa148ec46fbb94fc0f4e87e8793b0f846cafb7755199f79a1aab712ae8b540d4092194163f8779d77c1eff4cba5293c72c3775059084dc0c6b4482e93a63dbe69ad3f9d45f9370ed25e23e8442edfd4b84b7b4a237bc7dc57df7ea04b923071162e966c6a3ca1fa3c7e19dbb0f6de84adfeb5eaf68374365b7a20bba6517b1dd1aa446083f619e6fa641768e3eeefb00a68ce7d043c0cc1656ffe1d4710c5e15460ac1fc2e504da9612dae2bb656afe70e5b4b28d9143a4629f66addb686a3f5f8093f741e895f2751bc12702669e34ac6c99ac7b4b7ca1883b38c746433d673864ead9ee195e9dead97790ae5a3085271f5402cacf906613c045d00221eb85599256eba279bc40f9757dace0f67a5c71311cba9c2eecd03a948926e1830967f4cc0eead31693ad4ef73fee25faf5639548483398a4b5eba1b7b60a9182b4ee3e540420876bfce6e1544c0cb4af2ae0a2b6a10ac3b57d8f235c220c083ae96370f1e29435b42e479a6e40fe216632990258908f633f2e60241b0c36e76cfcb1b7db5ba83ebf15dc8d01a448571e096a81f0c09a703","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
