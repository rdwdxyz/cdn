<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe64f8dd8119aeda9663a5ce5b8ff580e52261f33679024d4c3e6692175482d95753f33b93af96cd66985d6f3d839eeb97536ea12a51721f56c9a6826e0f58db3d0d8b76a9ec97c5c248924984151d35bf16707c5d9eb63ec4119b994ad382bbd0a4efa0f11a904d027dff4baedc88b32076c563ad1b3ee07cbcaf12561bfe6dfbefe0f03e886361d93306e5f7ef8486d355a701bd33c2f8f632d4bba3299757e9914c80c428de71e136550a514ed4e57ca579402ab46dc64b1323c5d8108e5e6258eb7cfe6063ecba5ba58f31362da7fc80c3b76a136bac16275accca68775ebb9ced114d18bd07a247114b63e46564ed15285a63f835996d54d49cfeb2517387a92cc60c99aef090850ab71ea95e20d189604214267193892453343a6ae30314cd0fec5ff87465be128268ee1b61e0d19c6988779e03a9370f406dc8013391ad10d858b5dfce4f3d258915288dfe9058db6d9de2d909beb5cd6dfef6f558334ff8997f7de6c1309fdf4b80a566c4f13509e4d7c7e477739c2135d129acc149eadd2191d63a7fcbd0ea4e985d141a9275ab3056364b0575f5d192affe8bdbf812dc248091da7655ea514b6dd4bb8bfa240a884f72ea1b0ffb65ffe15af145c015f83e06f78d06565f2772f45c06a7bbd61242fb81721c30bcbf5d68a9a28bfe72194f404206d6bc0423baa19a0b1aae8a3e4880d2b60826e32f7183f8163b744a63380644cd4c40c7be457a3dd70003c34cefaabaaa71bb9b82f514e8676375814f2a65dc6101cd68ac749a52338d09a2681abd32c9a9cd2bc56d661a8a7781efb7bcdd80ce35c39aaa9f4a1ff0934760de60c92328cb5a1b77169995efb0f2557bce57fe11ba0f31340183f79b42a98c4b5c269849ff3a83adfb2b936f55304ad9c49b3d1cbafdd2f76584e0758e3f9dce15abcc8bdfb77170f9205d0592ab9916826fad341b569ce6db10e3eb25c02545ce0ce07ba0223dfae1835d29bb487f7fa9bbb2bb776961fe2d0f13663b8d129d8b381875525f19bfdb7232f843e358dadbe5770e317487f268402e5cefd08f60e456b76a166a0326f5300597e9156556937fed12e27ed0a52b151346454840bf21a790bbfaf074cf80f396d4e556dce729defe185eb7fdc7123435d9b1f1517a3397e09f23d12ea00b5a20e45621d9c0bb4a7c0ee329c53a50f21c6c36093c06b05dbf1990011355ed324c5062d65ae54477d46a64123605f0844b37fc6d77486536a954b63b05a20603cbd9a9b4137bda4065c0e273f4fa682993fe600c11ed04245f8ee16f276361ada7a31187f02ca9c2ac99456c24a51227125b015e2b63d79d4f48cc6ad73e6770576f92e5b12dc0e8868904da24c88abaabf8ebcd2dd57b143eb75898e938f3bc1405f07b1e8772387b63535d09b552543d09ef2adb44ced44301315b4e370e0a08f472cfacbad67aec68c0a93436a03efec717f754e7119e7fd51618a996853b4cf787b175a1a2bcaf2271a217d0c7718658d88c2de3c2ade777a749ccb93dff0c74c7fb86a0c6e174606f2468fb1c0f0bef53709a41034cdab693389616ea67ed1878b2f839191ff6a374217b527b47dcfc2aab85ad848d9b951e8f8bb590f38da832a748be2d5f240ef63e48847f7cb0229a45d61f30bd56d1817a45b49fda76fed8cf817af95e369197bb7d8472b3e61bfe99c0c07f7e3fb6509fdcd2da9392eb1c91c5ff88333a689e1adeb73d46d4ef33f59ee9b020fff9aeaf69705b2fc3b71680926327dfaf1c6ba246028e2e2df95d7886240aafecf3ab22b0c8c1d5d65da79c4d8997473c1bb56bc88e5f52cc6ea904998f41a7cca82c1d3c26164ef03acc14b4417e4b9239ef0cd2e9dd50c3b6fb89546c7c7754f2d0c801110235ecf15835fe58ab5028a511c03934167f2a4f37b7e653e53795f409adf93f904371d6d3191be07ba0edf317cb461b4961652f2200eacedf6a20e3fcf2964a2873642fc3929d8ec380aaa8fcc64070aa239ef20f22c4e2cb0ec7f88013505cfd30491cbbbcf22a91bd41d3a6f32db77eb7fce711b7f95e77850138b23a4b33219957f300f451effb31af07931438a9ba3ded492cf7f30249f4b602c66c65ad077bff6cafd5adfe4331de16e57a7d2dc8a1b6617251aa26ae3f29a880799fcdb8c531336b13b2feef85e14a74dff364870ca72ab711e785797b3e4e2596bac7df40cd042415a12a0c95ccfbe0af30d322fd6407dd15fea151f1f8fae352fd996e3b1048e71564e94b4a4ac32cefecb2f1a188b08e7e640c8b6013705dc5dc84d0e44ebf38de59b00e867157dbdf4ba71c5b81354cfe446fdc29e330994faf28c24aeee2077496606950b20dfc3c4f243473660c91a88aa7657ef9699acad4e3f9103c9222ada1ce76104733436c882af09ae705bb9664003ccfc1d19b736b5f6be62b793f85bcac84154b670790a9d2a62d42090c82cd24501b76601a2551f23dd2837f1d90ed4aeabfdd475045047e625d34e48e909b5f599a185d856dadaae4a049290526b7183c7f2bd5f1d7b044ef5c3b4b0878f68ca297d1dcb6b888e540fdee8feab649bd6ed653845445b9ce9aa91161ca8f4ec9e8f6696081e8aa26772fb8e636f573e61758184a0328fc11dac98885df42c6d7ed5590a587f68db7ae77f723554bbfbacfddcfce8de98ba45e2924c0730a3f1f986487dc59287858aa300e25fb6b252c3376904d01ff09e35af14def5e13ffceb4708ffe61a4515c921a43e1b655d46e42e49952b00ef1f8198a204f1aa62ad8cbe314727703420c4169fdf4197c6dd1bb4103f9ecf38b90053d41d22db159d1902be6b8e269ac89ac4b4659fb0c7b1de519d48869619366fdee3f3b3651ad51bd827b101ad249a1bb4440e6d59c1a78b28fbbdfb73cecd943ae56fe64e701948aebd1117dd646f87a75ba08ddce91559a81f9a2e35ac087a815fc4dfd8b6babd4e5f98aea425e5a26c0912174b02da7e9032bc10b523dc5eb56d7b90da9deadfb8e674f766d3c907ab195e9db28191411d04379e843099549a27bbb196d410bb7b2821f9e868d81dc97357d3b66bffffb4c1c2adc99d3da7508f11ce32a1d0eb4c23eba21e668212384fb08c6391d297a770cddb0dc1c5c9b7423f5cdd4c49b4b5746f7d365dc632300b72e851676cf12b94df3f08e9116c2c7dafeffe55a921012071b33dab35ab7f9756dfef025bc81943bf2fdb3f415a1eebc124d26c3e1fb1569863e9ba5f6145f198f521fdc44eeaa9f1d6cbba8c1339a6b6c2c2e3359d250de706c126f7de8f74e1f6bbfb916e0d3a29309e6d5f94411ee7d3cd9facb51ad9757b3b9b7d4488e56c64d39a43da8633e69a36a36c9603506210345200547be1e7fe21db0dbdb26d510183aa32505e54f81d323a9216203c81beea0eddf92c8b4779cb7b0e6b922d5079027b70759641deea5b350c0e1c4dd2ed52d036b43df776449cddab28752db44d857a98d1343d50cadeab955950a3e895ce92b834dc4455cb137597b06b7114a61c48223b3fc1dad6b3de91e4628b42356109b1f3aedbc6bdf68bead3a99c6c4958141553f4850af0f2d93f77c189e49b040d76e71eec90251fcf0ba4880d161d26aa91cc379e48eaf713c3cf2980227fcce50a69d8955a21ad13ee950e06b34d5f41467b504512560607c30fa2846570da444b325b70b9d520d1639f16c567eb606bbf726c0e118159b426f45cd2dd2ea0f2c68664bc79cc1da902f99080051d3950eb5755aedabdf62b87aae72a3784e47d32390ab5366941acc9b04a71016b23e08a26f253d747c59b12b55d84302717b792e1dc3fe5e0922040575f752c4bef5926bff31793340f98791d5a47b13befaa1bb6b17f90cb9019238fd29a15647c2f98224d750c7b4e586e30e37a69d09f2bf65d9d8a60fb4e8350a3668414425ea7a5ffd2dcda3455b86f0cbf1e8ad89720ecb7fab61e28c718845b1570b7b92d4b5b5f5ad5bbb69001b57801a2ba3f74efe840d1704946d8a45e6a63ba1063a27cd5b8aeb94b5cea90fb47e4b960825a3ee753266fdefc0567a5fdb119e62e42740d0600280cfcc3a62687f8d2bf3d1b7285cce289cd0820e1e4231ba2bf20084f35cec5a20243e8e459dcc9d1e6f70148186601829982311edebdb0fe0078d95236b1258effcdd864f936b6a5122a66e3686e2e57b74467f3171114213961ea0ce741b777c0701cb53cc1e72d411c592f99c491f6e1eeb0da5a0f7ea158791df4722c7c2a51eb21c9df335c1a81e5353cd5678f5eca28106a2b8f3c422c58c94249a71f0c37ffabfa3e0934b017b47cc0fe5b7f8e6a81cd2a8239b2a9f13087b6af7f2bb2e91cc4cdc30d4e4a59264e820415a998634668995305cab424e410ca88474e21e3022564d8374ace2c09864e2a1954a277aa78e7a269408c6f14658c8ea17a75b8f62f312475372eb0bb78c031d3a6d7ec15408513faad7295dca95f51042f7ccb62f087541c5ac712b5b786c462df1ecc58680ece332f93a36d4d8807f80c39bf8d0424e34c9a02f6e600ef55c11dfa7453d9b57c6473bb5dba0bee0e80f07ba5928f83aa40a75a2f03b488551f748f884b822a7b182cfe9536d43ee419100f969a116f202f5c20824868a200324443eb97fbc0f555764a4d6b35ceada06759fc2e5eceea7b34104c12b8a5c9af6b6ec346cce2c5d921f209f4d8be9c905dedc866fe565bd5e5bd06b1c355ee2c5a8130ba15c1b7833d9ea6770c8e691959412a058c521568d75975fb8a47b57b036362dccd2a3de58dff14f9cd6456813b17e27ad06e6a7cca35ab7ac4312c6911bbb0fb9b06feaff4fc2dfa86992b1b44e72898689d94bf490b515d4f5d9af8848935201205fa0fe1c4358509af55d847bd6397fbdbc024b2df43f6e041af1483ca2663efcb6c2dd4b5e4ce1c0e01b910662e61965d9ba09072886b6e3ea67bdfa356778e39ed4461e43ed82edb74e0b1fdec8b56e81d66727e05b542302cd6587fa056b1c18fa4b158d057d8aecb32813f7961d508bd6d015329c05a744f2ccfd7137b90912f74059e78d072f464c11b3b192fb1a69643fd7770330c5bafc67b3d2f98fec9994ccd0b0b24a66c2d9beffb07c8a65ca7402a609d7d85e06593d6af74d62bf7a355431ddbd4aa4a03ba88947b094f9aa5b341c48a99938a118ff6fa330e2123e59f422e626980252bf4246380b1fc12c1b7ac49d79b2f96952238b2a7b30fdb313236d452750296cfa44cd842e01407a5e1acb00767e93704a679be8dc7d3b31fbecfc3c6e3a7c8e19ce3faea6ece38241f22740d05f30292cd7f6c73b4b0aa99c07d594429a4e682f227ef77e2de70c2746095bfd9801234c61b178e1b85d0b62b3f59997a98a94e4af648310642ff04802f73d9e5c871dec530b30b87d600bdb795c5ccdc0270062c0fbdab610d428b4af8c7e510b5f88141ed0609a5edfc8b9a6499ed1fab2bdd39b4b04cb2332a4ae10bd855d2cc920233a5a54ce685191cee0458c6eb7c2cc24d3ed173d1146479ce4196c8ce21988148094796b1c5bf15d2ea72289ddf2d22e0351a816ace61b1b54630bc1a5bdf490f45d3e0222b2078b066925682171dcd54f60c0d3a8839a13a1ca63e242a7c68067ee4d1cb2f33da29c70c962ce45f41eea94dd3901311bb084541ea8408a1e30c0f9cb43f3cdc800fdf13d4cb91a1247335ce6a56ecbada0366f0c91f1a2bf5687510077887ae8e82b1b6bd6d5911b6231081f07892ae7df465ff2a065f6d650af7489054269ea1d18110ceb5ea24903ded730ef9ed0572c9bc3e30835081f10e46f931f663094912286a5c29f6b2ffa7c842ef59de527e15c67b650e4f0d873f87fdda2c045c1ec48cec477919c06be1be82aae978356b0128d3fb05664f5d311ce8fdeac86db664ac1f8200e9e2255f2b46e27225ae21b09f828fb57ef4b91b28c092f3ed27953423aab8457eb258e38ab60fa3976e9473c6974b3fab59c2720370c48bc25932c728058c241a33e039a47c8e0026a494b5b4f1aec1b764376dbc221f14f8f238b09b33cc0f1e0545c09b244a00b1c09082c191ae83147525da6d108f99061d9a124b84e9a264590e6db8d3cc9162a028b862b02de492c461441a984ca62b5e3777c40f3f0acec033b7abac875dd80cc23d9bfb3f7708a06583ac768c6ff86984038bb127438ad778a53c803305d082cd127e5a930d29bf86d2c3ab79569d7f16d54ad7156e54565ee1842ff8424eb35e5be535cce4103f8e36248b1ed9ab0a4f245d277a25d077b10f9a954c44c686bf172ef85281014f7b529891ed2fc9f53c9b90240fd0e818dffee2e25bb38e3b4ff31739c225fd6626b944f005a258cf151bf3857c8f128866b7bd9d6ab7bafbfe8a816928b1814277af734b79fa8147c4f146bdeedf520a207b8026c457a5ada8115b9250371e886820246128550082f744e65ea974981b201cc49bc1e13f55e993faa496ae7c06a049151182647ad74eecbee1fb773247780972e111ce277ee6abf668fc5364ef53b0d5f37c9889aa5fd538795484b670b18af200381efc118ccbab6b3b20241c8f15763394a0e51bc6d1fe286f1af9632902f39bea6fea6604069605393d56571b3ac0911f4e57a9a10c40095ec26f8170bc64f8022f4526d7f09af851bfb4b2ac39a10524c51a92bb02418acad524287047bca17d17e4b3163adeff824fa30c101bc986d3b41c529d45f27bff5d28cc84c7a1f0deaa02169ed2e40ec07ff20e45c05eca8e8769565978afc5203e9831eedc6541fda63229bf91acb97096a1c048d92bf8627743ce412801c32650e15f657ef2534dfe3edc6f29d325d4853158f9a719233e3f0090def50406e04c4b46f7c786ec7136c89bf1dbd17882a6f4fc83a2198b97ebae9efee581533f7ebbca8f8bd1c6d70a87fbde46608634787a64fe772904327aa4d54c70ea31308b7766022c865018cf47abe40dde8da23a3931b58c93c7c436e53f283168db1a2e8c047fa1e011a3e9332a92c644a44fcb89feb26dc821871ca7e50dddd62c09f84df3fe994b88fd5d052c8271679225af4ab20d34603be2a51a6556bb7570b26eff14004394c11beab7b3d4b28a09392f3b616dd5fc9c6d375f6448cda10ab3a0837279a34245b1da43e018fb2c4ab1b1ad046cdabb00e44cc8de60504079630b2bb91eb3e686bfe4e0e91b281388083d9d8ac97fcf2493f18594fb8b53418f20230f88a5f34c746bd7f0b8f36bef1decfeeaae65db3816fa2c54bd88b0000ca5e2a46f2d36c30c50a5420a4b38b12e4526fdbfc0e2cfec027cc298cfd7d8a62d1dd15ca873568c976957ba173323c11256a78277ee23396d1de85462a49996e0afa97136a75c99086619d1790027e6ab166c6b30b717b9997d29f8b4ad9412bdc1b148a6dd143b64c56daa8bf0b41632f756081a3f466a88fc7ddc5eeb13a6ebd6570e5a991b158af26d187cbddc640c15cb15f9c27c65019e3cf6f6571f89b0356dd41b1dff4093f8ee98df28539a09155d2cfa343e618c3e4e8c21212f6ad6aa54eb058e0bca6bef984d0cdbed6a9f91eb31fbae1f8bc36e5e87da37dad61cc3c42600947484e28ba21b55386aad715f53b74d757c15de9a6529037d7f59b7acdef4799cc348e91b3113a678f448d806e320ba418f9ba287cf0cd5ec8d213862cbdd7c8bdfa4077a6eebc627ab27c5843dd620389ed03b8924588657c97a6e030a22337fb91db7561910bff31d5e5d8cc99a486be3e38116e79528e3e3994dcc77a1fbe2905dacc3a8082add0349ba8b38c8e27dff48aa2937ade80a2f776ede17279be48fb7eddcd1e267e89d5806cd1863c65132b4fb517260ac038243b940084fe43682971df0323004f5567ca4aae0d3b5413838bd8a008fe96300d7b9db1281c1d1058d7eaaca51d3640cb95a76b13a58c5994d83e2a161e8457e1df97cb7649c3a65cc2f99c4bae3a2d6e66a48c4c07fb60457758414d035b5bbce8587fae477776355e5f28c0e5f2c12283718ab58db53bcf323466ab5e9f101fd54d389ddb5ce30ca7dedbe28f1a5f58002e68cfb25320d17ca577fe2ed7f2ec962771161797d7f66817a47b5f3ffa5510088025e56426fcb808ca8eeee88c91374588d4c2dd71d96e3ec51564b9023f3c5ec23179f648f58ad0b8e175ffe027ad2fc836402cd627d8715d8742532e44e3057a8188cbae68b0268a2842d02a5dbc1b472d57003c448102ccf83c4c04874a5345b9b1f84e68cb42dae74394d20337da4b3b2f66aa0a5836efff69d5fcc4f6b4fa073392c6b8bf40c1dfb9e5d6196bf7e8fe177852fdb40a90c11e58dcf413a20aba0b26df79778e8f75d2f3576540db3fff4d374db755028ed55acea9f6e91ebdee204e115d30e3eaa0823cac5f891e6bd6c535c4073782f9dda8124577bd12c27974183e1c65321b8e6a29d89a893ed325f4ae2cb96fedfc1903080a636dc96e5e26c8edc6de1b3e978a4062c6e281f5ea3e91f5162c3538243b4cfe4e2350c799123c67d10f499888f0b26e812c3e2c10bea08bb1df8bb3b7b2697f9580d13aac58bc7f74a6ba5296742bb127a02a38f461aae733254ba5f330ae32a87662883931a0fafcd19bdf97963d276081f09f2226adc597a3d2e875d0bcec1fbf667f24612b995d3b954a9e9ad0685715d5e09f36bc5dfbb0e8f13aad70e7255c129e5348ac1230d185ec35cc072941b039bdd2301d293cd046a5af10ed1b89b2fbbe08324362af993676b38d25be5548499033fa53c6ab4520c28382737b2798e6448d1e1b529779727adcb5ecdc5c77af73a6269b678b4be83a72e1a84fe3bd2c3f6e4155b1d601e8da1392e121debe29bc780a22ac04399d517c529ed8c135f5e3edd9fdfb9b8e3030b8a8b5985e20f236246f52bc391c0f1934a3021951c1ee4e466a62dac7c7d91c6ad5bdc6f4e024b07a5b273b6190cc1339daee74150236b5e8d0f293f5ca3287bb26150d12a82e3a1ac68cf20a0123e3fee0ddd57d4e547c73d3c7699c924835d0765a4e78b8a8e2b62b780d7e333eecadee81a37f5ef5b6af3c0329b8d44cba1f8ea809bfda7fc908cffefc6b3b72d5d5727098201e24cc0b8fdc8cca3759de4a0861341b10256dcefef636b62423bcc2424b9f292db90ee1e82fb4f9661ebdce74de9c8519bbfa3d1f3e1b4b7598c33930b828eac6fd5c940ede4fecfbf10bc10f4383a99441ce17d3943e98901cef4123251308aadf3cdd06bd86381c7b7da0aebef9755aaf3686f8f627f74aaea790d886901c34d87739e30e62eee2c8966f268285e7255845e14471b688a0325b0c87b260b01d990fdcef45c0522782c625950ec66692da4b7562612f3e6e898f63d8490ae07f796c0c0af24360e71ea0ab2bee1a89724ccecfdec5c7a5a2eac8b68ccf520dce979782e7471baa325c66025f6d225f40664306b84b04433c173e70c87e5554fcc74c957c5a797de0a7f65f2ff9ce080798c3b8384249ec09d7d51f3a02d15425a2e18f632fcdace362153819c8c4296234b2cf40182243fb2c4da14584d9e9c2b614837793849a486be1f86d569f659e432de46e1cd570dcea8ff5ed6580712c86c5caa34bedf4d471f144fab666a6de6e35b9df1b80499cc530d241d0c0665d29e85f6ac11efc986e3780a923b55e3ea84502cd3fc787f5d177c810500042ecff1089771871cca7e41601ea07fd5e37bf85bab7bac969b0178c87d01a3059ce270eec4ed595074298b415eaad761173781b54cc922379c7fda585dd1b6ebc17956d34ea2a588a5041c77e16f146c0c0ef882748b6b8fcbece3b15398ca2a2e58f653ec368cdee425e9f43f8dee547cb3edea47339bbd80bc7a1f84d3e40a22afa50255178f9fb0841caecc5fb57b451631e161d56f13b17b30584823a9d9699a0496c1bad1e46baca581b4331b7d56a59579ee541f885b311e0876b0dc91aa372221d8fb24228eaa268ab1b3a58dd46aa2fa52a4234fbf1ee52fe054624d221e3f64ce42bebff711fda790d49e5dc1e3e0e1b1b1c79dd6a5c20b05127ee39dc8f0b96974da98476c418fb422795768340a6edc7921246a3bb8ecd53986cc1c46888049fd37f3b540583428a34b42b8e26aaf1b1a813c1847bd48928c32c06781f675e9b39fec8dc699d3a56c551e2d6998b80436f061b8e8c240b0879127ef547ce2d0a021d70605a8c2a5b6f9c8c43ab471135e2c00481ba6db1f7f5cb9805366b0d90e686164f2994e10aaf65e1b1784aabb8a79dadc09b35e7a6b49e03c354d7fafa5986ec6fa44eecec6e18cc55641afb4912353caca4c77e290f2fbbee370abb71500b54862b251f2fed311a56cf3bdbeeabd6dbd7ca5e4d8fd7da90ed8da31c8a66b1a2c837e861751beed2ddb14b15308e3673296491cc674562b2282b16834f45a2642a4633bcdbf2ae9a98373c412247e42d9c1a98eb1bb2fbf8d30eb4d89661f3faff5474fdef96b57b8c9c86b1fe5bc2cd683898208fb952844620c799a4aa1537ddf15b9aec5e44d508c046d8102d6f617ee63f3b25020d5025260005c8278b0609674014fae5e19b5e8c8aafa5fe37ada91e1b0c49a1df707f5512ecbda30fb151143ddf0b575022973502432dcd1610a7332e5dfa3477053b7d5236fec1dabb736ed4795db3eaf8d2b9a0f11878a174437ae6509005429c2bff81f02dad5d9f32e474eaa642a3674d5b97c108625256e029dd328841e7a4aaed1b88f1bd3725bfcd2ce5350d816f428a86a25f5a24a891b5339c73632282cd902e55e847f8e0e0ba09a652876cb1316fb5debe34bf5615a1a1bacab329b9ed3f461ef15f847b6d26f22ed7d017015c451685c588778ccb33290a891a71c286ed9a0c55bac5f671bc4a8e3552fb3d9439f7a23eed48c9d5a8723b9d0b4f57ebb4a09cdfca572d7ba16808d6c04e8062922318675aa153ad843e2311a5c5f01a9a608f011c244f0fc26e7f3f02c69f57a68fa60665aa079ad665edf94622c8f3aae1a7041e876287bf4d9b7afb85a847315feab42783d307effd196fb8ef79a1cf74ea08a9cc394545ba38bf6b1857af424bf9fec74f897a451986ae63155c02cf5c7cfd085384f349abc6d7a442869015c1980ef1a8741c880401eddb05bf97b8e442925e24a2c9c907fcfd9b9b7ab192720a911059f6ded1b2691c8fcde7324d27c472d269e122014ac3fecf69a5e261c0f135ed8b77ce98ec5e5c3cd404498b2cc1575f2d6779ad89a1559d97c0f12fdde755bfaba0d719668bd7a29b93f7eedb7db997875fea968b1a03b76f2932826a01c205d2afb05b178609cfb96cfe02df1d12b2f3a796c82288e47ddff8d4cc27c678fd5aa95f6db07b4c304c91e9b3f86acb74d83fae07982142215a30b364d39ade2cc14f01958abdb6704377d0ac3c7ca0994e2de19d8c706f18674eccb8d49131e6e7431dbd795e1198998dbc7bef377502d25f75e3bceaf5084b1223de644135e1ba286c060aff3ade9a089b38641244c01151f8c39b15a0eefa6e587d6857b62a6631ae2f5a20572c7fda317f948c49626c5ce9bd2c16c58cec68581fa92f135c1388b336e679311be8c81856f5c84c719b3acfc067624ab60c285dd781f22ee6e5b3229626a8904f3cb3f78817c060e236afe94fecee14aca0bc7f85cb37f6a337351420f1ae179c09e0e8c2710b84083a55c303b3b042f54775ef49337bdf2c402005413bbb8bac410a1c4a12f21829c24cce7c85ca3f93ee6f18a2edd0ab8812187da7862ffa89c55d71e1a612fc4b4fe666499b7d28c3d6f8d665bd430d9793f0d779581a07fd7fd50424dfedbb51c5d84de749d17f39eae08490f8c1f6c61839fda86a63d7a4b37819068e1a91b7c19095be0a621d0471f84562159330d28fd4ba61173e91096a43e6960088f59b6ed4977e103aaf5af064891089233486427a095a30deb7589575e3c28131f52cfd82ec747dde4ff7c6809937bea7e11fc6558d13d1675f07d130042f3de64a975e5162f7491f63c4665a5fb4bc4efa36ed7a76d52e416456354b14ece666675872ef12e32f7089c550f4c8953ba6f9f2a47288734983bf36afeed01ca1789b4f01718e4f5ee77301869ad6053d70eb9b53dddd7917d3e17e8175780e775d588dd78f1e95891082a372cfa2cb225c4e15640a5a225be3bcab556c1a81f1d3a8625e0ab5ecf7e78d83ca74c2ab30da3f0a82762269a4da023b5c01af81e9577707e46a024740c9264f09d653beae91c2a66d82799a7785893483d3088728eb97f24f0e2e3985d91558c103a994d98ba8b845befdd4579a409f6090613351d96bbd6941dc0a9662b670fbf45459e48248d7bcbc7cc6e3470793555a21e44293cb4c115eb354e361badc4273556b0dc50f19fb0a16bb60a5ea3ce96cc261b7d5e1964d36a6964fc78f20779542f2efe5b4fa72dd9454515fb4c604ba27c3e2926f9043cd011cff244c7e2e911a1989cdb996b708c5fdc13272d91a9729cfb1c68c9030e78f41710b494290f9abdd1eb7ecbe66a1cb81b9c5accf8f362d7432335b179999496ef18c7df3f32618a0f0a023457b6ba8ea57feb2d12c49b3adb707c1d000d8bd15486b0e8eba49861e39208dfebcadadad88073f63d996dba836125f89064d0b394e026d901225a2d7225ee2dc0f673bf585de82438387aba2e1879b10effa04f8833beb9e61a4e091ff8c6312ddd76440a76141703ab63cfffb1e58bae68afa1de5898a7e46ee940f79f63f7cc7648a80df720e4add07d2b03300a7f2cd406cf946e3c1f56199f7c64f6494c909eb57f2e4aaaeb0e884222761c7b691e7ea2e2a7dd262bffa673331fed2cb087b00822ebda7c2843e67d75fa05e989df52690a93e7f5030e87a101aad0822b24f595b6afc7d57827a664bedfd9128468f06de7bbfed2ff122263575cfe1dfcad8d90124380fd748b11c0fe0564280c2bd628401ba1be2151c61ecccae1283fcfa477cbfa303f8a369b3d257ac24796198cb63c05db31044ec2d83d374a689635a2b3f0509f50a34f0ca8aca4e3f08ea7a6f62f39c86eece72ced995a18743bd56f276f5aaa7d0e02c066aa3335c740f7e2b1b5b7c5cf5d68297aad3fcf507d1f75b8da5693788dc79e2ed9f34e58eb18564828c8f8bacf803abdb982abd5f279f890066bd6f104bb28a580d1ac7b93ba2166963a745b8e73ae9a84597045955058278fc2e8bcfbf88270fedb35aa94a13c0109ea64944c5a5706ffdc2eb76247f5b3a004a30ee92abd0494c24f6cb739afa004f25497d79bc6651dc21c135c1a2524c58c8281be5818a5e49a7a7395f8c9e17a5e864548f1cf2e09f5d08a530179e4d03132b9a067abf35f448e85db6097495740ca28b3ddba4a1345adbfbc3de7d5348b68243e0d057899c8b501ba175cc84ff9f944fc306f93d41434f57a7da3bf851e04a763cae1d39a6fb9e8ce7efe4f5bdb60d23af10af95f3ac6ad8b11837943d1b7ad1a2f6fc73e99a852b0b33350514d2d3d3207c6690c0973674c9d5bceed96cd3b2d57835fd8f1fa1cffb84448bb9fc57f2b950b2bc169c7991bb3325efea7c710b4a6553cef5015c050d1b07c66d1ead5e19aeffbaaba603e880757bf5d09e04ffe92b613868f83bf8c0d8898ec47d8398f5b8ddf719a7084a965dc550bb8e3a48abdf4ffb1d0b36c1450c472c9bb29e6e2194552b382046037a535117854a1902d76f4067da435880698914e26a91c0733d50bd247d973a490abddd235e297c68c1e3e800be10752a115df0fe8f854c24b620710103a6a50c11491ce4a007b9c220690a70f7928f9f032d679a70d7ded6a9ec73aa6c9e2d86a19827adc3f00a61bd23e43e2e9a61fc7b7c2ba27f3dc2059cac8c66601b653d91de46b84e8a355dec59c3aa4e800bd2708f013aaea50da3edb49e932f80f68ca5b858607b849d0de4d1b35c166d2af192bf96324ca35e8153de8328afe79a2f37e4aac41788dadb135f9198ad727b6fc0bf4ed402515162c5c61fcd1278b1ae7c83560bfd6b1390a4878adfba60fe169a1dfe8a40f26712cc9aa57a60f20f8e779333a2a4897c10914ce40480197ca573f7d1f17634b94789e57ffca9bb88733ae86eb6e6cf2b9bdc21bf729761ea2cdfd0a3ec0b66f7d7ba0707f5015257928d83d6e8fd79d53bda663a8e4bc477b74bb87e912bbd3b728727ae8632889644b23e299663a6b76b4eb486a67a1e0e16a1422ef0a08b3e1c06443293dcd724ede5a37883ea5da23a836896226919c63e2a3f4f78e8c52f012184deab304c89f4caeb5ab0b2533b71f1964b1ded91294f4f8f5c43fcc5fa53414e7de80200458fd17e6a335429b5daa95f7d245fa0b8c0987f8699bbf03679c1f7fba9d75a5560399ba7798b6d6eb877f29fec679c58ee94551538cc23a9e931fe646258f514b02a3b9b150a4ea393db69d1a658c348694b94add54f85f89ac79d9e03164c789b6e0419914b93d02d042cef6446d44d9577f138351035b3d3ef3fae3dd0210b327f769b0766a287ee630efc8940e045422cacadc3149709e79fe3de4d44371aa4945ccbce2042b6d88e15a33e147e10b20a5ff2a843bb36dc9a59eeb2ef1cab352f663d352219a1c46d72d1a71d4ab8ee558877c833dcb28a56d97136315148d980b54a19643d6b70afe48b81f75b73b998769f0408f9de4c63bc7ef55faecc6808ec881ee5a06f677b5c0a3097f794236503c4c5bb61873d626b779407aac5b66bede7f10666d4352b6948dad1bfdd6f8b7b899dcaa62cb27672dbcf778f8abf755b9ad1542e945aecb7728b69ed8db290dffbde07e2b2ce3a772ea83f962a117b1e5d7b19ce698cebbd7cb2eb63cd48ea4142e62fba484c1cbcbcb236c5ef8ebad179ff89f17819db78094eba2ea7346fd1e8938879a4a4f758cf9d58e98f8e8d17fbb4ca4aff83b98e8204fe5d627d451ad626ccd2cf86b03283532b37423f14975b51b7e3a118d3cb951f8036bc4d1bccd746bbce100410feb0fc9ea69d5341dca191f4d3c6c7e6a93d908427dc46bd2cc15f63c8451f16956591815837fdaebf2917e3689fcdb21bde25c3e54245ad48b8b6e54c0f20c89dd2cd9b8a96c5a735cbaa965b95973f0cc024808a0374fd35f82c800b45a7b927b9f01314a5c475628504e8bc243245f42ed8ffe7881cc9792f4b2ad2fbacabe862aff0ae2127fd4346f868f5e12938aaf5db0448d2940c6a2dd752e099198d06e9d155a8ede7498962cb6b54d6720e1f5b4e72df161b7d07589c0f0708c999df40574c9b501b2068a5cc45c38b5e3066760a46b66048726f10ee6670dc08b16d9cb83f8e73bd29ae37961fe9edb8b64d1c2a8b2e40c2a67cad88835c0068b128edec502e4b3f0ac366626d68ae32ab0e3204b9058fef31d2afc413edfe6c78d325f96b4f2f5fc9c8e6f60eaac7cf79a41c27693c2b50dbc67617bff04edf553e93b4bbec4bee9591243319278f5d1e857f92ebd89c3a3a264b0e7bdb29b935665c0ce8e99823da7f3fa63ee35f29e77d44e86a2bd2beb252ccc2d4a24f9ca479ba7857e7783a55d3cd340abf27ee03726525f65e1f3fe216e4dda2fe7bface50d15471c4cec266a257c545ebc2477a868277b0071f42885223e4ac33e60ad2fab435d5c4864a89bd11758ca662dc00e096fd9d6e793fcb6c032fe76429cd66b7afbc7bf06234b205bb531c25d23f48c0ccc44ce46c0e1f499a1b827e51c2106f5a9faa34249d7b7f2218a615e8bc4fec6f2bbb234b5ecd3dccc7118f7acc208ec56d778b8f23db2e6249a4787234bf06ce6170ccac136305b0aa60f64103ca7f804e85e0ffdab3341afc0cd2f5691464efa56e9e083eadbd18b07bd50985bff05285a28cec8c774946e1dd90728d07e7eec56562987777251d39b04a4c43f158e979777938ec5755f2b08d55a9093c203f3d7b7a0d6777f6278b39c33083445df8061012bf544144b02c547a56c1025cf33a3d536eec0ac84eba6602dc19b2eb1e2557902f14393de7990655deeb911aca103e8624db73f3003ab80ed85a8a7a024b06a94742b4fd8a83fad30add4395314c4b34094126df7e285954e7edf8d8dbe649639da6cc322d44e35ce44c37969cc7f19df803c3b4426917a7450af25b495ae9bf01012fdd60b0ca4936576e172d8b99c87d44640131dbcb0dcb9f57a894a74e5906384951dcce41967097916f3e51fc4319cd93309d4cb018a43dd9162c63fdf6db3513eae3db6a4457faec2ff0b39fa0c1c2455840cba2a32c1742fcbf8553c5430be02c33640682dd10ed2a6fe713772f5ad00e268aba3be38e732410a960f6434710678dfc657bb1a7dcfb9d7420b973e6678f7ef2dc8424df5575d0f77bac95deddf5e9a52395121239132adbf588deebb5a75eacdbed51dbe560d43dc42528e9baaff76597b64d575c89b83f8618bdb06bc52d9921ab294d20619399e0a4ea5a7d2305d3782ed87418b54a1993c32f6362b9dceca48346881ef8c5e27c205ca86933371baafd9194130a08e3f9bbc7e6841d441ebd1e7587872c2a59c420708a3be19093e0f91606cdd565f706c3d3acde31bb25196013993f0beb7d6bfd9933f524bdd0093bfda808e480eef4fb19cd48472db0eaf6db671296ae6380b70c0332fa3705865c86d31ca85e22d4bccc4c1a8356cb194963c5503df99276fe1b9daebcdb46099c1cc85cf1c0c7280750dfd8ffdd9c4ce5ddef51162348e95d617215eaecb06578bfac79c2fda98b5fd5ea4558564488f352f7e2529f72bfa2c214bdcd921aa05fe191c647710486549f7b6520fed6e25370bb12c58650575497c34b0f576345c09bdce7cbce7184a1367739ab84dd1712836baf139ee6aa3e3f10b6ee71acb1af7d78da7865c98501a09487e5ff9db9bdc737ac79e0af62225819c6c769043680fc38d7ef70cdb30c79e59d23bb73738187e5f5759cebbf68297e237959c19ccf6e1b72f84895994047b2fbf5dba34b11c4b61c5f1d716f2a3f73138e22e5ef7d03f3257da0d0352e562334776d25c47f811da6f901a389f7dddbcedf28c0d15412a6370de6e31a26a66dc57b0c03fcb5112b593d6db4beef7807f9986dc1189ed5e18c6f1fb641b4d8bfe2dc728d52104fadf17c684feda6384c2e8b93957733bb20a957b86f9ab1a0bf1705f754d869a266ebfbe0045b91bea7c7d6c5dc5f1f1c412ba4046cf96afcf78a77cc7b89bb1b77f9483f4095c7900a97c271a1ac293e74326ef47f6ae73785fab01a754451083b5c24feb2b007bebc16da239c2ab76d4a9a49cfa3b32a4d50a58e3f0e400f5379f5264256f9c65858f65426254417f3c0df5436866a3781b695daff353ff3141f6ad07fa6f38dc11a1d8309cdef092455bfe4474771f3770281020f36ab8a9c584e4a282f59393c93801117f502f3c4ff2cacf4ab1fefb5348abc4b55600f4c555f715f8dea90f3a44335001b16e20ca628c045f633dd75d70211cff3a11c774abb6815fa603e737666c980c4df8c3343eb0fb86cb230f29db902c481544bd5ba120adebd7e90acfb7c8768a1db61912b3550f3c83e4ab4f23383b7e8e7c2ace2b31cd63273ce9a226f3924548c43a32916482642b0db80cd96cdbe979787fbcdafdff7f1ceafa8b492794e0709bae7a00f100fc559c0a88552a3344676d41beeb8cdb8a78aa961ec9bee00da8f0005402a7c144c987ad6b5396b40051fb92b1723bf667dc0627b1c59fbeef3b7fb6fc21443018ed1ac4caac7135c367475699de4e653e971a194f8f51eea6554810f1122eed29f3508a75c43564bb3719cc039008014381e2c587c6fdea8aa50c5593355e4ee4de7016f55cdab8be799671081a5b4342c72bf2a26206a10130d8a8021cc0d44a76d0af9bd3a74cd78492dd91bda043f0c96dddffda0f0b9f9ee4f77f84a835355ad25b59cf07f0b86f473498e35b5cfd8ae5303331f33f080b3e3c176c23f12e654c34e8b3b0239ef2a2949d42b83b631ed16","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
