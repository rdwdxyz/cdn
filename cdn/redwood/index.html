<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a72463889da32ca80730cd83602425c7bd26f4df81f4faa2dee350a9d408d5398f5685b8d8248b6335cfb88f87bf1f6ba7f0c2c9eaea19c04d0e1f674d08205e2660593c2c9cb152202f76534df40db83eb72407de2405680670a1eb0d27601fb590a45622302f4a234c90595a6f60cd4eb36069191474623012e401e0ae01eb0965c14238cfbf201315bf626e3924d9cdc9708247bacbb8851b968b6d508054894b20580a7b937d55ad35b47100891901d1bc1e72401e463992abebfd40689db671d80621345d7df0075293cafe6adcbf228896e7957996b9ff2921fbdf0b08a4a13595c0a6d40bfda70f471b603fec657c39bdfc23c2943658d7381dcf9394f110ae7897592bf3fb76aa7af13659029360e3bd811fb97a4b02265d6e4e99f3c1fd1af59b064ce8d2392f0663b0d17e43865551b25718c8a4afab2894821d5f9c574638bc4276a75c886c02c24ff0eaace8a2c82a20eb652ae7c029553f6b91c2056c9b49c3681b2f13e9e30a271163fe8ca338d712bcec67d6096b339fc304b001735068c4d0df8244a96845ad3b2656841da310a2b5b54ed6f547d6143aba681c1943945bcab146d228c382560035acb0d22d11b82f4a21c43d10200ca90fcb2f721aee1167616b00ecc81f3d6a6446627026e73afe793895d670dd87fbca2f33b5048289589379bea3aafbd468008bbaa3036bb174ae816b8a703c70d04b07f74088d28fd511226c0ecf83709c9e77685bf43de8b671ef94140e7139f2f99ea200f893e682d24522472195adc0b9f2277cf48bf79c28623383c20f979784ef9eeaeabd2f18a0223a3e8cc3dbfae210b3d8bce3b2ea064567db4546df65f74167b6456001a767811fa53c79028b16f5e4eb7182efb19cc18dc21e4dc0aeff5db76a3da6109538599b633ca8dd19f7fe217941cd81b1161a3eb5963b1b4dc7a3a5b6e71da6c4d4c76ab4701b5771716b38740dc2d85227277ae48c9c1b380ac682483ba39cdc7f8c17894d1d91b91414a8c38bed4f96cc7fdca26a6fbf4a9076d738828393af71bfbd000bafada6079e3a8b9a7092b30ebb8df64dd1e04cf9a13956634795bc71bf6ff35df37c72f26c3db7686cb72321bd35205f9b4b0b8a6c17d3e31540a3969d7ec4abe3fea9920ad9e27f9bd07a89704b772204348d45e658aefe1c2c243699f98ea096385674285093fc369230ec264c876e0febcaf690d764e015a4d50e7ccd27c8dfe49adf3e0e6a2973186c9d46ab52998cd38c565641575eefc65fea995b8c613f188dd837a9417726314acd29510ad62c1ed1c318107395bc7cfe079168ad3c53a84fac7bd29ea16685ab5e0f90dae3e523d26bcf64df7fd530d35f52da57da2812f23a459fe7b3fd4e9ef6426565f10d07d779f1b3972f33b0ec489a38f8d50f7bdaaa88b6993c1b6cc9a3c6044a6d8f5d28a2b691cdd084634b6cfef59949a5009fda35cc3fcfb7a9888973873b737b74d56e86b96c66399e30662d019643d352b9fcdb96360eeb974902063d5196a2fbebc92bb73870bfbc8052b5958a8f71a9b6c29b9656cc71992c8907ed07f6144fb5d7d46b88addacbe92dc11e22cf28768b1632a8565481df6fdebf356d25570b0316880a3ba154d016d48ec5f448b8bc7c463398170524a3f475b26109dbe85f00495c24a811ca6578eecc6c20a00bb457dd0527716d2ba0cfa80cfc2d95e4f7da22a4f7471624fe0007bd13e95493596f115ecfc6ff7d06c05fb674f2fda72f25673506b2e24a2762c42715da0556634e7279401377189067cde8e1dac841b291d3e11cb2a09d40ca19d7ca537071988c00a63650dac0699f3d16a2ad6610e0d24917630f6b5c3f7182ec073f74a8061c86c7c6dfb266851f2fd0bd52382ad9a8f17cf5e0ff55be2ce16d30eb7f006a82884b10f5472fb333b14cae39681971db281a34e77f1d9418cb8525ae8699e52ebfb82af833d07ebcbf704a5684120110bf8444f8c842827816867d5068d38e7e1ae9a1c7eb5437a3569f7225db62ddcc7ba987a61fbea02ed9f2a789d90b88677aa6d55b0baece12c94bd3fde6503001b54973a85791d9b6f13560b8b283558acaa08a3eaa382a8a0523a6237f9df8f669b09bca8b8abf2bb922f318d799be223d1d92b77f7c9bb2a592c187bc772393154b655d67a67b61f414ce1d6972428dc5ff4d6208f7f887e980966cc63c29971ef2f8e06e6d92e68ee7c581959daf3dd10f5931cfc14373c89a04c02ae1e98e301f0fe3a5713944666f8a798bb77920089efb3a92bd7d5b7b383875006e93b77711ec5e53aa94d8c3ef815137a96ea1ebc531c95b264b591d5a61e8194598f937f0263ebe40371a4ed3e8731d4354016d356f0d1fa79688edbc922e655c6678b8b5ed3716ecef8b6f21f11e49b5b063780095c486714184ddd7d3a040118e64442573520518a46c6a17f055cf3c7451b7c99f3c66a18a6fd43fbc8591b39012cdd6cb3ab547213c21d33cb58904a6eb147507c946bbb4995f40e6209abd0067eb8ff1f87e6ebef775458edf705d30daa9adbca8d88aad30fec4d743532883a6764ade9a01994aad144814f2894ec055f7452551b42aa2e535a0a0478614668de9455805075ef75111e4bfe3a2857df5fdb5e83862b52d04cbc05aea6dc0ddf6ce8331d1c26755ec84d878978f654c03e2f7753f0d6823780f05667057f92e8ea41196682933c3cac0e752ecba4aabc642ff8df41a8d99dd258da220f5ce733ab242c7ae19088961fc6c9030829da51cdea4a00d11370c201bc611de780cd7f61f3d6fb3cdff2ff6b292f6239e400caffef066f95d069f6c76dcdeb75f4fa0cb69666baae7dcaf5d5c8346bc0ee32d5ab337452614e83608f75f61eed38b065f825b6d9bf512376d7270f8003d3372973745dfc8c14e01cb3a523356fb81478728f8c2c6fc8755c235008a385fd3376058f1f4a7d5e9ed30669f6d9afe3a77e60cbacb68771523c27ec3bc70b71566f9e64761f04c5dad67e5cf2608183afbe920a14e801eec80d98b2ccb14c6b997402504bba0624e6f8d5baa736cddbca54e86100f3f7e18a79220c5958d07447178a35d5d93bd83a380346a1dfd98f35346c8743c198652c28ac469a238f6da3503d4df6fdfaf6028cdfb237a1575d3770c25f0ffceac953ef750fcad12a97d9e0221d808e9c4c1acdee42fc6c5f5962581354ec346131580763b80697bdc6b08bbbbce97066c581db3cc4d320ff6b451619f67c1a3efa2ace95f2e843156a2499b48457db4e96d216a971bd001c83051287c502f53f6aff7184fb9c5de56b12d20845b2e63ec58c4a5dd518c0f04d0564f02503b8c7e8bade207ae962c390e02e00e71a70e4d650be2dce0b0fc70d43b717af69d39ef910e1053aa7b43480d986e02277545601421daa69161e628013668f963e6ac47b35302609bbfcb400940bd0915078bb8b7d4410a372338926752fa5264ace2787d1de39bb4286addfc6e9124fe86478ed06b3b4bbd0bfcf573abd33da7d4f23ee84b48f5e643611fef0b00814dc3f9267a64f3f3fa51266f0bbaca1d1959a20ffc0659d3b7d6db6e60a10327c5de04c3ae66e05d4e4e1ea214e1833b631288a528f2481393e8b541909f05a4d092befb2dc80cc8d009554e10578e473548f3a7878af322d25b92a9820e86bdb78ffeb1e177d6281d42f87276b1effd5dc394111b670f0162ebc783df95572128c7387a31f636bb1fe6b7111085c74694062e83214bed8bee9d42fbdce6f4689c62091b4b27a713e4037ec9e611c54d6ba7cbc57b980634adbd52677f2945bfd3be0145ba97947f8e8b3cebfc6c9ee034b5995b646ca1ebf92cf8b3a9605e2347edb868c5eecbe871739de813fbd5c30e3e1c73efe7b428e93a752d4d85ad98d954d43baf76a8557f362c151522ce48031a62b4702465d12b4889d743460c7355e28d33585f9fa728d57eb65631fbc68387d4681880a64f0eae62fa39023f23e826b2541e2bb7643b5d8c9fa7b33f2a3538bb4d306f0df383aeac976a9eff3b2f8e0ac49acf5df2bc4463047ba0fb3cd1975073440a17bfa44b8e07c5f1490698f94d83225579f556c5710d86e9a34314f2346d0d2e1d52c3ac79a5bd9e9d5609d85eabcea4c9db83c7590f730e0d7709c9c6609d789bc55070af710dea0e308f84a6841e4708d52c6b61346ca409059e1c03d38889a494348c10afb62f367c9c380e42f01a1a770124fc65a120a8931364fc5522277e995099dd84e20aa36f5d7eaeb03746a0267ec85ded05b531c7c95e1fa5ec1eb6bba827b06d74989a83bea8cc24350634b850fde2aa9090787a786cf69cb7774c989a7f2966a1187cff8f1accacc8e586bcb2d900f36b238e410489875632242d5f1c4d672b717a93b638f12036745257d879f751000c52a46c5e66fe006d7b32bb2b630103dc6a1f57586ddb6e1384b562a4dadb5f7d28230aaf52cf86b878656054713f52a716abf495a7fa9a624e6d00175e14dbc5791c38aee48b25e66605c0fa2f88a68e269d578a44280fb1d6a4a35209a02fa1d61e6ba6e4af95440ca6013a5f43b1594fefb53946fc6a87e1c36d9ccfc82f382ebac5d90539c3460a39785a63c26c0536aa47017dfbc8bcd3b478831655a2f812c6972e869802cb2e9fbd21d428872b39031fb7d35ad1d0094e3fbe78f9c112c10e2972c67d5a2417ea30aa4fd033a0facdc24ff2ce4b367ad08b034962d73fd418c73cf01a15270e087f26acc13c437144a6e828acf8e07d1841b9b4fefe938b35fcfc42dfbdeb07c812b6935b207964a9310d9e1335eceacfa5ec74b946bcd5e5ce136449867a428340e396b651de6c751a6c3db883e438f5156e477993bc45d8018fb8e93084978375e5c2e76a8f860e46d701e8b51cf602ff8b20bd01f01add331b3e410faeeb7ed77c8b072b2476d746b6fdbcc0b435a792cba72305275f0640dcf35455a9b1c60864d23935aa380ff4d28e3f2fbca6e5d676a995e79dd3e5292765c2b6f5ae81f4047314e1ee8b38d57651b1ec32ad12f68d394ead096235649f94eddfe37dc1c6a50827749cde975b27a79e1b7f92f400bd104109fa05f59245ee47acc8411195e079851828cc4a4ece03a1bacf4d23696ff56ef99d4dbb3f4261c2fe1c77f9e03ff3af35570df619bba6ec54ef9d2aee27297f2bcd64eb7f8fd101db51bd5c72a722d2dee20216842443651bff3da15fa40abb899c562285aad5110372e42e01cc040bc20ffad70384f92fdeb75303e14c61aa767e5bf208924efd155347ea2bd2744c728c19680adddc1d570a1298deaebf426d30b9cc5f34ee9c74f62ac3371f0d07c358a83516497bdeaf480d72b265a668f865153259c39c0cda100df8fd69dab2d0360243c922eec26cce75045adc606cdc59c7dd362e9e6e5468d5ffca78efc0041c2d7b2ef008dfe519a0769565742d1a9c796080dbf9da38c1dd5940c2175b24edc583e9ba33ebde6f228dd841fc8bf3351cb77e988cdd32e161f0c8702da3641a6d82c55a1252aa923c5dd203a610fcb6c5f03db1284e6d9b8a9687f9124136fdb6bd8a045e002091a60cd7f140a5dc3af7701b48d37b0e7714f13176826fc2220922c761a4a7a515569b15afcb9f4ed7cd845a18410b7bd9a7b0004e216c5c717c6894e1e1e6a9663e3d32fdd20d50188d2ec1407609475d918e27cc67ca630754446fadb695237e92a0afe5518fa2bd856e530dee23c43920fcd09cd822db968f5a823bd372f77a43c22faea8a9090746716a73a609b49744dd7093cdda466ec07cedf463dd600e3104017ae9e4c73277848106c55706cf26dde9ade9838138b2cad8aaf42ae23758bd237f1b448875ea00b1468fe7761416e8b7aa199b8c733c92c934b4dd156fdb51d17afb95137653f34d2f3ee2486ff98200032e0be3834e456bbd6a3ad8ce1e168985227412d7bfcca57972927f7c9a7c4a6b73386870ff1425ae38ba28a93fa6656629c34e88d2070e1d8fd5a6ffd2f5f7f38c218c814e648fd94c60ec6d2daac3a50dc2296f8fd2cae5d9cf429bf87f36d011e8acd46f76c7f7b26e1210a8df6ea11774a6880e3362f6a27f10c4ea55cb487e4cbd2e754afd5fb5e8a1dfb7e1bd010af9a370a3203036ef2fc0500d4cac85a02d7063e102ef7e106f9f6369a3fb1df21c9a8235d0389658716f4e1a02324c6af10a20e9ed1f305658a6286757cb1e0f2e36e2ef66fde32f7d02afa90952b8da3684fa5fc81fa39c5db5dfd39c85712c0e69879d93d309363963380bf1185c5a37cc3874faff881350f0c6fad75f683f831d90b3e64c8c389054aa135e67ecd4d9216d39c38c43689c5b92cd2cff11d887012e88e0f9601501613c2abf9008e30469d50aa8a7742b25d9526a7163342b646ec5160d34337e9b06fad23c65018f1be2d3f1da5b3b1bb6b734e40ff83ff76d78380c9101b15f20acce8586a78e1be86cf28d79bdb601d455f06569b3cf321ddf9fabd77ef99bb17f48122ecfb4461d74d31f87b5f52091826d51d22b0cc0940a03a8ecae50e8a0f23070ce9b97c91f13162588dc3e4411d2f93a35c9a0d74cd0430646952448cacf2518626a884e0b80ffb69f398ac63f7cff5c6573c5a90cff8201b8c7791e95c829b2ee665976dc80d1fece68b970db7b5f86f21b8efcdb58991b02db532e02e52710efce548975bdac365474f52bc5e28adf3c39237f1191f805b674385cd6621272e39a0b270ea3fa0016f291c4ad94bbe613344205ceb939bbf4bbe45003ece7b8d748e3c3693c1dacd8cb265d505b0c1028f20ed37007ad45d7454c8d71633dadf025bfe8ccf4f6155b7adb22b49a25c97efc44d9e8fa36522fb57ba659bec2b312757a969a007640707dd6ab8417e5ea35c1bf6071a131b4f73e32975dd4a495acbb0807b2cfc231043c109ccfe52c8b8c08d6dc95176d3709855d9af9bef185af89b7261cc09b4f72739acfad0bd75cf0cee2a41a52f0dc4048f976a3bc9fe6b8514975e7b2511ca453dc8bc3b29c57c806ab5fc2e2351780566c28a653b78c3ad3aa6bb831addde9ff1b7e104f684fdaf400914ece5c48d292c3239f1fa998f9f3b2b32c02282550081c82af2b7c621c4797630b2e7b5485c2d6d0963231e3a6268d1e88eadc7b547eb2aaa1538259606f5f3fd4b2124bfa264ba685ba61925a03f170f5b1c4421c712304c0d16720b4a5b62761ee5e6ccec844ce44d59b84962dabfc3874761ae35ce468b2e07a776501518233abc35c6c120cd870e788a9ced43e5bb9c0c291ad2d6ca25d4ae98b9e94b1d4dd99f4e81627f598569da9a906d0f4668c2d3a5dc0009ef428a7d591bd72c5f8d3a09702aecd8f499e3846b9d5e08e274b787b2d1b3ec2d5325150cbe77dfc0416a6e7b2e3c06166c1f23bb2eea8d09e30c31d6c96a48ef7df4e1493c603f310d72555f6df167b2f3645e67bfa38cee73e64350e65613a2a049e4587e592bfed6a6aeeee6cbce5b89379d31b078f50f83dcc3b396a817046e79bc154a0e35a3247ed0ab6c8f7656cd805ab474229b9f3233a2c49ad16b372dc4270fc1ecc6027260161d8fe9f540cd1bf8c79db768890012894600626d251534b6ebd15dcc0c355f4ff44997133be0771f372c3019508b072302a0aa29ad017fd2cc83efe9c1ff5f9eb5c8934aa81ef7355d8a5f2756b7948ae8ba9f96b00b2f824d8bb0bf3205a5df80922894edea2634d65d87b741db1540b39ab64e6085c216279b8140fcab29ef97e15964d833d067389695a017cf1ebd424427811023aa191e9a1abb374c3ed5818698cd39a0d241dbaa4c2100717fda086cd49cfdd006e56f902acc3e7b33d952b466cd810c233787113925eab9bf300bb2f511fd4c6a5ede7a1223159cea31c6db5e621b49af707a428d9345a832994e53dc0c0f3da7cb6c3918688fe75cbb862017fb126c5d0f475ade5999ab7368b6c0c5ea4213472a9ec4cde8ff79d9380d8a3a2e8e9af4110e1baeebde9808ea66eb40389484acff8afdc34f66bde5eadd275165bff5f9b43279b17f11a79af1aa042b48ce50d927282d01f6fdddc49db4ed6057f084f33973e4bc012a1db10ed85b39f83b67cebc84d7be0bc0c10e5fbf34fe8bd3eda43ec1d0f331e5086de47fa5a72e2be107983e224db54f1c9fed5e796c357659333241adf121b50402e65134b1e32ce1582d2da1bd408222b0b96e10c83e60538851dd6bc70a421d486ba1da7704772ff23a3a639100b32a3da69569924e092b5256a47c859c18e4e7d96fe19e2507d0ff82b09f10cb6cb90881407417490588062ca4d6c813e5a23135d993724b76638cefb466b3be7052f91c27c5ad89e011731d0a065c7be55fbfa0d3c57a4cb3b79514b5bec927690f8731cf7110b6c246fb471631c4eb505fd90dab97018be8fce1e75c73fadd57acc21a9a887e1fd373f11fcd405e2c9bcdbeb75ed6027c525e4c6090618c2c2d7a1985fdfb95ed862801ea37b6f19f64c87af963a41c7dd0d90a11e1b4e292e978a3fd4d708bb070e242c3b668028efed976237a45d7e6df8b8c7dfb6735e7ca514e72c5d166be75dcf5196df4512ac07e081d90a47bb9acb87444250c81da3655f36304da7b31703fb7ff3504d63287ea8c320500003edb7cb8ee7913afa56629baeef5ba3d859031cc2c04ea519f2db971026c2287cf7309892a0ee55630d904b3b7ca03545be009b38433316b102b2aff17311815c8cb238286a73b2b5ba9a996baba7d84848d7938d47231e1e1060da970351b5e6e4dbc348e21d160895c6157b6a10369f61630096e4ebadc337f6942c4de51c78df09cd626098719cbb7f9c71812c6f6b73fbdc4f15b262b0b19698356b05f4a902fdc3a5deba8edbf2f172d9bd25bb742098283d2217264801ae87d2c17aff2e12c0b9e38c1aaf3f9fd0447c22d7bc2517744b07e37329f24402ab1cc079190ca493ab21ddf3422fc229158677a8695fa2aeb1b3a6ed0abb3aca623bba72fde7db5f4cc32488d3fef3982f188c74a9da7c8dcea8273777ad6216b4f243b26fd712975e26ad4be86cbae5f858d7b559ac186a5ef0ccee113f2ff6d712167c2cc3664e9ed9b666bf6c4c3ba4da4b0fc500f3c033f3cea319e13ca24d577bd3e7295bf7fb1e1ce01cc7f8d2868394c5eb454283af598263817a3435c211b564d1b8ed15136f73b98d562402d22fb25be917722e3bcd0749b17bfc92798e513eb677f76d6aacbd0972b95c3f04d9e59aa5cc9ebc512c8f486eb95efbc163e009650e8a8d1eec800150b616823d2b1e3589abc65c7142a325645a482a88f8cd3882432791ec101089f60d245a37e0e3fc6693c8524a3be3b854ab7bce3edc09a66a51527f1f5367a76af01e3437f37dabdd5ef97343669e81ad891def2c32af38b131d0cf783dbfb6d278fbc892e8e43ca8fbe402ebd224628a795604d3209746aea95a5ef0ab9590dc22bfd545f4b34669574f4858be75f4b7434322316fc81de19a69ee58d9c690eb02e6ac01bda4c9ffadc143ebf2aaaad09cf87577bb36e7e9a3c40633325cd05e531685afea775543236fd5d9021b0e71dbcbb36836059368bf7abd8801cafd67f9cd609adc89dd81bedec2c83784aeaa15c36baa19aa9ca833a2064f3aa9c0cf11a82ae48d4fdd4c1514c9e4b2149664c2eb7bc5dbfa38e54992bef070d71c4ad91d3b752dd5008beaf15db8681a90d12292af0f1de56c025bf03e0b9216ba30345416eb53af6b8e603117452fee8dc6aea91a8eaedee16d70172d4862129eac429ed9a195bcfe162d66573197cac20b916d25b5339e06485ce533568e51ad30275f02e8c5c0f9e47d399dff3a707e9ec1097913908b528fd3fb07422091e5a506375442f0c10afe7e4072e8ca8cfe3f9c050d4c03c5a0d870eb7155f2ef3db6572a22b71b79b503eef2693896a884b0513e9b2ced8c75a0e3df44668c4f66c9cc2807184a57382cda924d1e7149d9f8f4312074778faa2402d5ef6282b3ba35883f1ecb57dee7ac9371e0c2142b6dbdff7600d852b087808d87df43c952513a635f35c02f582f91de43f78c60c20c4bb3bbf238bf65ca2f00be51281572eb7c7b12bacfe8784b1cd2a0ddcf8bf2834cd07a9083b9f5d082ba0212eda75e9dd49307dcf5bdc4fd7a64e60f42ea143c303a0c7f48a226937b760c73a8531e877cb9279f110dbea190a46fc8275114cb050410e395872f44bcf454cd3bf69a7c5fc957e28b18b3116222df1c7e30ccb2d7abe6299a3c3a71e83f97c589b18e52b0a81cc79d866a16cf16574c7efc89529b43c872dca6ca99b252a58b03b77b840c186e6c51e3b79f82c9bc4859d35eadff81292cc662d9fbadc44b3d13f2c776e6d72a93637983556946218a45de4a534f49d4b9e9c436c9780fe5655e70cc9cdcd5c49e2e5c92b7ae8464c3c7828dfc50544624df1c167f74e9526e3dfe06d3d403750eb9b1266756cb4f628431e1abf241992df55a806f1b498aa7d9d14cf28656c65db7d4609f8980d0edee420319c7df4f583ec976d97ebdda05ab1d636f0f3f879e8e73fe0baf065d0f01e54035efb151f1e18a9f69255f071f3b80746f362abb452dd0486ed31550ce1689818d4fd812de98242573db080c17a11b22d07baa656fe1592be1fff6510e91e1145671108c0237936a60585aeef176c974d7e4fbc9d4f53bf20d09166391f3baeb60a50c8b2864b5a03edd3650b4af916642c17a5082d23c34330a48dda0cbe1afa98ef203e4ae07854d3c67e1907146c80be5bca87a53758784994ec702c38c15a8312fa354d07bbccc441ccfd9997cf581358c3b4cc3a0861837f75bed5c599d328d96dd1a1ff1f965ceaa9670182de056977de233ee1f71cd7e5f2b2b654bb987f9adffecee70ba463e59848a339f5b4b9c6fedc7829ec4d56e471c3a4efaf4db67d3a95da744e33532f9cd3b6d9ad5c9135f723e20c3b3e620a642b91b9cc84f8481a8c6add3bbdc269763f3f4984594063874b56cd64ebd23a78d13d962e7f0a4384d7a73679d6418ef5c83452d799d8fdfece171fc5138a4aeb4838ae1c1b86f597391ef6b60c25d3a5400555a21076de1eb6aa3bca54705e8b37dad4fd176d24bebf5f84b0f7b39389fa2f0befd122b3972de7d6bcca24368450c5ba0e667e6634c14c6951babadf69b9f895d12b906339069d5638e0f535dd8cb448eafd3fb4e9758f18e45b2dbf1d157b58901dbba4560f5327a2714158d8336c78271e2c6d653b9c88b6dac599ec90313b03531f4f5135abd501ac476cee6dbd2a4517efb6be64375f4f133852234ecc0a3e1887244d9f9e1880eefbe96ec02177cef527924cda6d64dfd924fb1bf1620e50722c6189d70c28c08be93da6073ec09c9428d4e1959fe0b3f0469029938a0be0f736954312b9f47fa8f47949dd7796ffc4254a604c15aae162beb7ba2154fb5bf9eae5300be05a455d836d7f313de3001e45bc88841e8e2b88435129fceb4101e4fe033583acb71226e7f2096cb88343dca098f8507ee24043a4f0b6f15adb1ca73973dc4f673675cf57344f7e6a50e03004f43b1e34be9e9bae8693abe405b32e2423e5c5d4b2e89853079dea68fec26a794a1dd924307e446f3a7f6e894b81c95d8385dcff71b9ecb61f09a5ae97ccb55ee478a2d2da490e0a6b5d833b9fc988c0217d56da97956839bb67961154ea90a371c43f595d5eea71bed46190f1dd7905aafcfc2e6084f323682c795e909f51eaf4f1bd39fc8585de79752ebe63e18d3d0e2c3cd1ffea344f691b2ed2665a71ce1bae77eac909e4370245722da741f613bbaddaffb38097e4291d1a5a031165c2f1aad7f19ca5c170cb7e80a1353baf43fe1e24cb8b53ca923c4fd5141926844beebba940e8c6f885679e42dab573a71a25c8c725b9ab4ac95b4a455dca414a82beab705c5d42b38ed95fb5ebb0797d36b3f83e884e53c7fa51820525cda8e985d5ede196f82bb0261c2964475c25926141bf680d4e164043c2555a6d06a518e1ad60c7b8c6f282eaee96405e4d5492661262872c7d4fb41961de37fd743e2ca905b3dbe89ce478059fabd88bab8da04f768569f5dbc207c12aed45d3599c6ab3c26f72c442df0566a1c652a6240b1d0808a4fe84af6b0e9de1d77f0727042f82d32f246c24ff7647a2979a374c590123b0bf88b233c645a062ef1305a53ac3bfe3e524f47d7a7a1d50b7c689666496a239984f3475452a3771c7709139a910d09c09c428e661ef72ca9e19b4ca5f9346b8ec79d388422d893ac40fdc3d38d3900749934acf603a208fc34e1b46f2f6f54d86acec1a08dd2befe4eff396f08d1d40d150a6f8d7716c71d288cf16f8ad678cf16cf41f1a7e37ea0684e04a9ac37c0678dc552166dd3b28127c7c68c0efe1f3d247edeb0abf052f67a5c56523db078f529b30dc45d00064f1d4b40d63e97011604c86a4b8d332774a956e4b46eed6f7a532a9c10a5c3950eca8f56b71cad8e64654cdc70601781346ee56b575edb171ee21460424bc9e905878170e4cd5f202201d785f78cc3f095acb28cdba0d607c0ebfc251a7246c8386c7a31451ee82e4af4ba91254d3f1098ca0906422adce123170f2392fe2ceeb0db73232d50bbf720ac7a149cfaab5c7a6408c3a3d3b8700de8c26235004c8e69e6d8590df6e5ba85ddc07568bac86b5f299e601388f1ea91f81dec738ccb0261dea38d1414df561ff1f3be79256b957f520c5cc45adfd0ed3ed56223578528287a19b16be591b8a9a62e591b8f442f8d450fb5485fe07feb7bf0a5c15dfcd7e922caf88d320b9eb07f8894fed27d768504ddc3c7dbbfd4f9cc1224ebc352e263a995127f017f9574cb422d40c500e07bc3b2583444ac005e8b9c9b73035fbe5edc9d4d6b11fa1e4a0ef3164a9bacf4ff78b8f1824a4ca78a22229ae7a3053c0273463a73d39f6576ebd4bcdb20c050198c0e95c5c98546b6edc5ea9b26a883b80e05e1201c09a56b1ed3e386d6f01f44a5adb668d318c280583f7d1811351ad6adda9d47726acc113977643944b6af4c41c860a20f3cb926e4a55e262e5335baf9d3ad2d07c622a98e90d54a1d4883fd56c63ddcc97c21d17a1910972adc4189b39519e43ef984ab6db27380c6f535981f12052b747a56fc9ed264de28f9b43df2d9c28090ec3106d609f9fd9a7da3c06343cf01bc78e6aba6bbcb8bc785e87ac09ec73192db6a76165e7b8e5471c0ae6c513db7ee118164545635e54ded8f3ec66f67840fddf8a15f4f7ef955962439eb500bd1a69dfeca49843ebbebf8c765031bb45cf775bd3504bf00039c64ae67611affdf7b4a3c235f4bb7e92ca5ecc0a27a68264347101ad9462da05c35df5628211d7796290569afb5ace281f93ced5bef96852157d07d42652be4bc5d4a787085167252c82a5e720c84b2e36ee80546fbf62a561c3d7a242eb3c4d04f95e60ea4aca2dfd41be2d25c415b364e04668142f1ecbf28a6395949437bb7349d2752220c689e4c14668742ed9401097d6dabc43ef2f67864f2fd4b1f0303ac0e5d6c11f47183c18ce04e7bb50fca88ce180cbe367286a9c2b5387431f172d4e7db1ddfc1834dc2e3010d639b5db03722dea9bbd46c3795672c96d244430c17ef02aa3314afec0c33fdaaf35546629f2510ad03ef4e41538e02443bf2d56968c221f59f7b4e100a766b1cf825f2849e3934960d683d7e48d04042090886512f5cd78bea4520dd35b3533d7ffd46a4d424bb484f210255eca004aff122a7070699c15f78cb4252bf45600e9b1de6b0ba1572b99cc2e2149fb39a05ecf3dcb6d726bcfc3151f69aaa64824c56793d584ac7e10f9251b691be241242128d8f3d94008650ae331f8d1e658343c4c51590c0b4843f0fa1dae3d907a2ce81b76de7c2630958fa3c9dfacab7c4c00f5aa7785fe442d9322740f8aa64b201cc0c2cda29c5e0f4ea8371b84b4d85941879d1b1afa3e3430bd8ab7da9dff6196b57501691ab275652d9d0c261171779e7558078f491f86c2154db181337fdf010e95b19fda754c1a05ebae82f082f2d30eaa136abb6e2fc0edfcdfbfa155c423b954989456143b1ac023c4b2f0d91900ce3ef4eed13e914aa89ece1b7e4fcad73cbf1edafe1e8dce5ee942c00800e0c06147f7f3b885964849ac9607a8fe321a9505eba0bd07aab9bb7e04e609a4c18a1db6f69e9fc67863542b925bd6e70d1a90e31e02fd827d2e05a06bd845724708a05a07c6bd7c8d0504562dab39a6353954093d005701586bdcb03501ebc704db649673869525b18dc8865e0f208719f7d68bb154596b8dc7f5c9e00b63205021ca250cb20314f9fbddc74d66b5d9a1095bd57863f3fed56573fe7b3a380f0faad77fcceda124f30f37c7ec907e14b94e508abe8b1cf4451c7a3a487bbb9b8947d90ed7f98bd87b85d36ee0daa139fe1c80b9251b5de0b984fe60262d631133cbada18d8cf2f472122090015e2f6d25d968094884c7d0c83cc980b5064cd4b4bf0eeebac9dfd62615503bc61777ac6c653cf22ab623edcfa4e1027b015aee5ea9cdcb64d9964798ee291e7668c376b74f3b42038acd37e347120528608653f09ef0088177834a3aa5045aa42d990f02bb64ef708eb64892f9ecf8d5712c23c2729cb672e5f50936650963fb00c386d32592713f5de83c4fbc8e665cb9561e5fc275391c2506e273ecb51b3c7800249a547f2b00a1747aad529bf6a5d479ad34c4633da8e458c5a671ef3811bc614483199fe6e698ab9a707a3886f497222fa6ff35c057958257d2e47da8ecba509258a4e52c4119f9babfaf6bb1a9f7f3b2c6012f90e892f21ca6ff083011d8a74935d350cb9bfc94e11563ec2b03cffaa93e27a6b48f561f6585fa472cb5e381089327eb1e38d58bbd8dc2755c55c9a8b3507ea860376b4aa1d596eec8a86d619b587d3bef4a2e72a0789ff75f7e562b3fd62d64d6fb41a2d8243f28db29b5601d3d5ede0f389800e89910b7bc693530f55cc7a412d0461dba5e36ca939421d5774788ebf9ac5774b85ffb77b9fcf9c618a4b6db24feb1fcfd8c9c76b51253b38161c804850033b885401569fa2aca36a2451a7be8071a69d289a142a485db1d8e83ad5d95f640b569e7dba19349f2ec575e1d1cd40d84c4e8b5bd1cc55f015620ed21647a873b0cc2260fb591aaadc57959a92f454f17c40eafe48bde66b20d834752e8f2ab12fa9ff05f0e1046005a354456db4bba242dcdb1f25a5849cf8b353b961be424694d320a70b9a3ab5617fcdca652fb0d9af048e9d614f7024691af1bcb74702b6c045300a0f1e665b0dd114880d4ff02fb25fd94053975ab586d0996c531d008d9aedfea36b95df8a498b5564d69e40320276329f2b6ca4330552830950435f10149c6f9e6d0fb67693c5f75d95782d76fd094492493190390f926dda1245245f3a3bb2b236fc3307d309cd25b71c00003d568438bc6e1bc0629ea45e2a07e5b3d6d992b0bf9294b96055cc74f8d9d65bed68a6c1f889b6ecf808f9721a20a379f1bfb048ef87899cefa557cd811fd76538a4255fd93421467433fe1c3b481ad63916c1c870d7774d813e7587a57d3d9b7dab27057ae119669d32c00129a7e25e29cc2b6f1a54821ee9f24bbd3939742457ad73d63516e6a4deed6ab194fda8004d49de8cf783369b4a3982f07becea3cd3243017dbd3cbfbf670cce4e23981cde96ac785c2cfe5f9bb306a3c1481924de076ddd939917c900232a18e65cd2c7c60149ba068db29855093e77df3d0126b5c797c79281514b8ff8cc238c9bd80032523b4e39a5fdb76b00e8a3000ef61d52a23c8426d1731c4c466ca7570a202ba5ab98e344ebd1b670481890f2e5786354c71db556586d4705964c798deb3a9ac3e1da9934435648f78d702137f36cd6992e6b3265f8a0dc4da82b48e5fcf5d25f939b43e7be0d4b390399fb249098991145c14d5885054c1064d517c5f286391cfe71a39d476bde3c80c9d368708581315210a47c1b3e2f08859b5a9367eca11bafc735ac7f2b4406bbdf4a96c4875f8af522c1320f2b1feba823a64b06b788bc30f89ed9d157db1e365c64394db750d22cde9635f0dc6214de56102d0bf11052d2d1e417af3e2dcf18d60a9497be87e3926521024d78d81c5e3ff89e8e1614a2b6013350b752e5477663045e18b71bbb86ffae09b0141ec0004b6fcbce6ab1c9179acf9b75236feb126c60f3177b3483e96e5182689054d5157308bd0c6f2f79b5eb5a15ed4de3c33e03a93876fac33a86ccf12419f834ccd966c3bdf4c3787e2fad27eee1444a076a5cb7b9c0b1df809105aa020e123ba25e411f4e774f3851cea7f95781a8bbab13179e732c2a87223f05ae23d0af73cb33928a116dd34bef8790c1a2eaae10826e0296afb5b79891c4fc086154d0262a82e02e11cd73e8a357557ccda8dd39a04ebb4b2261e017557d6b6b08a589886144dd7ad332033e4d07da567a7f8295671627bbdfb93a3eebb9f81b432fb7372294a2a07adac0df390931d43a81afbd6deb08f0ca645cd7e727090e3122dd80360981efd149f1225c28c6aec9db88d9184de5e5d8f6b77871f154727369f119ae704f40e3d347b509338e8f806055604c50de15e223e0cbb85ba621c532fb98cf96fc6882fcb38339b9a43d3fade4723530b598944e6c3acfbcf728149fa347ce60340cb936f6c106e60c233eb9704e20e1283801a34eec57258fd4df1a98ae6481b2c1784fd6d22d90e9f277e16a9a222bfcf812d9b629377074619fd0104daef78bdac3c8d67cbe03fc1a9ac4757412f5ffd0c2cc8456ea4c53908cbb25e808db188a161420eb055e2faa0365714f37e242cdff793134b5f01b60bbd054ddbe187817128226a23b938e9061ccd77775fb45fe1d217cce81d705a8df602680f48c291657c88a229cfd392b5ba8e4e6b3845516f105cf1440bbaea425fc732cec376bf8533bbee58aa6a33d19e5bff75cd5a4e40c8c35602bc09a9755b959a7dd0ccb749c9cd70e404ac43eb5c6bc59bd885ad952b698915304fb38e4c7dda7ceea59ec3c3e3608a2323f581e7dae454e4ca289c3110cb3c7fb4401d256d3c0c95cd36191d4d488b92d186ab770d5f890811a3f1c9bb0dd68df92ee74d4743b05685749f74be03c4f8071136b11b46623175b15718837a840f9b3be98b78f125a5290e592ce0e015dae7a032aaf2b50531c0f2f50e0eb38f46dcd8eab8b6d1740869789afd67c956b925083ee33a927803fb5a88e1408f2cfe2acd38fed3ff2355d88e1b8e17d4e7eb720d4bb99339316370f2c057cfea451078bbaf6d9f51a989444d79e154d78cc4fb1d984628b606f22c1dcf5e20dc1ee1dfe731da5a7b0a46ce38933de4e7603663456412595616fc72b98c2568795f60280a8c203770fb7a3b16843ef5bf2ef44f97943400f8cb2073d2bc3d2dcbed07ace24cb10d65ac849248acdbeadcd15e0e675d1eaf280d1e76066d5e94961ecf4cf8506d54d0a77d0f092c8c8f9667b28ffec51d7cc313dd6fd529ae8f80588855e4cc19813dc884fc6b8f2143aad8432384df4bd69ec69a4cef234155fe8404371dc27e891a59d94863b1c076bf41bd3c948b8ac37b8359aeb0f5200b4f98769191624ad8266568e8e79f1d61434729415c2d5bf4d99c300f2f1c91d820f5100782af9d2782421c27168310f948153235bb676533bc0f49a7a25c15219f45777133a29ba82f01fb353170110da0806504838e4ef7675503f403ca82db6d5db4e8e0f9e6b2b032564a596b36dea0a6f07b289c0ea88cf6bf436874b481cb0af00e06d190e6462cb79a19d82553cb19594b6873146036f8ce7dc1c897f1d41a0d99357e3b8cb64a6d2e30442e4cf17b00040dffebc81433447b3ca335ee009cc208efbbbef5b574f3c7c7e5359877a023cde72962b962fb0ccc105723c2ca814d7cb3ad3beb5ecd07abc74340ee271adf1150","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
