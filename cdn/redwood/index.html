<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"372fe823af92aa4e930d860ee5fe24b481ea8f5ca465bde7c73209d67140a774cb7f47671d7596a918ba69b795d190ea7d9bf471e3837a07be2873d0372a8c16c5569bfaf075be9e7e35e9360fb8c02e3833b949234f67fc05cdd2ce9f444a2f7fe9f2c49f815c68e4de0255ed909fc64d64798609af675698d3f7613b0764ca32f9fc9f75e5f5b5e7dd3b7b7f99771c11c26b07f31273b285e86433ef6590c1e6cc08465aa59facd97fb4b890c6c485e3d22893c381df9a4c778e18c9c0f5c5f5c843302c30d277e07c9a6aee8e94b2763b38671b14421fe397a4b5cbbbf8931f2c107e1f55057bb077226367bb3943a14950cc25d13f475dd4f99630415d1922d0dadb80d6c32610a94e8e9425034404d69b0340029c70b4317f50d812b6527764f8cb1c9690ca8928f6aca4925972841e10c1ef35f97382227ed06caccd108cb76b8ff4926cff2e97dff542cffc7ef5ceda0ebc6bcd79caac0616ade44ad6eae43fc04b885f0b3149679fbaf45d7f5b935e8a288cb9987a72d57c183bc078d5ab72e292a90991de199b098a1905afa7a7e807576f148f7789c00576a628b9a8b7fe65829b7a13ddfb2e87bb7342abbbcc77df44154b9614ba4f99083f2109983170374d6434f0a444b9cf7a11b724ccfe2cb55796d1906fe431938357fafd347934ab6af28334600b4735a1a49575357a4fac622898310e9d855983f8fc5332ac72ed0b1fdc4cd4a05b2e9b1b298679b73ee66aa2cc997dc016ef5febb64b6331a79fad6f7d6fb4161bd94f4a4dba4e3a4d28361335781b6baf72151fd203e53ac9470bab8d50931bb80f5483ec07bd05c5d5d28e45fc9945845f24302d3048fcd66a7edc89f767ad9716c38238b86eae219e0eb359315201c14e3d17189fbc90c690a93e84fa24ea7155f02f0de10f41b7c257e20e98d0725eadebdb97e9e1e220f5f23c7e732ddc5465ccf4b017c78ec29358ca3c05abcbdbe95e56c7ef0917ce0b3acb8a45273a7e63e2a994ba337f07b72c26bb34df95467a48d3ff95b60cfbef7e94215c7fc21400d8cc17ca75d08d7771140a511ea82292bb6a55e1950c8666d642774838913c32e277dd879323f5c4618005c02032bcc5cd22d97d0da0e96d180dd974b60fa0bd109e608c9dc56c123322042e31f3783f73c45a09e576dea1d6435170a131437f79ba2b1a7ffdf81947792741857616e32ae5cd9bdd8fb102e8c2dde4aacfbe99b4e8761b08dfd72a00cdce40b20a03de0194b79a100d4075661fb088c175770c60876985aa2ad99bb47de7fa617c0105722403db94c070de478ed08ba1f50bdac95134865fe81ffa87a865f9d83b0dbd1a2fa7980229c1faf2d3fe874a3b26d26db9e6833818a45effb8cbdbf41a3a61c203cc7b3f70431f314a02081bc7a82d73ed3b2d8358e557414568f3800e7707c774e71f12bcda4e9dda683cfbf9e1760fcc34b4d4126c7bd7c3c4ee32ee263773a4ca34f6af99f030d945e5649220eb829881270079d09aa29b39164cb102eb92c996d737766bc9e4ec4bda24a031786396ee19bc83c21a0661e74f4c6cdc1804e3fe2159f7984c90dc699a7dbeda1c6d47150eb5f10569726473ef3915852173b6a1bf1cfc34a9134f30dc13150922643a7225f51e1c6a08941a0d585f1dd967559be0e9f5d9953f63b57f72adacf955998730c2d1d6c6429c2f98a5d71dc427b5d670cb893e24e754c8604688fe670057f40c08a09a3a4f35336834fed1f2aef9fa671a7ab8e10693c0886085a19f102dda0aca82db8066ddb8b33468aec1833d35f045bbc281c408b84cf0f24059a2b7b6f43fc432e93232a791fa4dd3bbdb8e13db128abd8da599d255a798a63c6514b64b9202cc301cfcd8f2f9719bddb3bc554b007f37c3e7dea5602d4b0ce08280c2983173ff6254329e76d44f7b453790646e3a22850f754f2b5af680a9d12989fd94c2ee06a1106e6be5a2fc0978e64b29f3c2b052a4765b08141638b41c7c9b2dd275c13eff76bfac5fce79a2bd58ac11ebe027092088b12dc6f2e19d57932137c8b8aadcdba17187f5d48fe220d5b2d4cd656a2696e39fa02effb9df247be6ba64e1fb6610b9362cdd9cfc4d147468b0512534f97e99258f1126d7568715b0bc2c57bece6fc1a6efecd276987b721ec7843a50d28ae8b5f1c1d4e689e876cf42cf4fb8298422e1cb41b7c32c0fbd46c640ffb08b0fa267be0eba5e16a4ee2c63164c8d8cf12bc378b5e5711d69d79c2ecb8090857eb88a0863ad46a3f3817f749376e756d6ec6db1da3e5bfa23c78de2736ad13087d3e32f74545b42c0061ed7e6f4b70b45d4cf36c41cd28b94e03938b2cb5f7c90397a816bb1b7df4056e9039efcd991b66ff237aac753e3cc5fd3dd3f56c64183552bc422acbadd3129314436727d86da697c91ce4a3de972762162409df72db8c45761eb31bae0d73d8452c506e6f36cd2a4cc64c0b10a3da92a30c9b038f2848ef2dc4058ade4a951a270d889b4cfabbb90d392085d3ae98987885674a738d31686cb860e55e6aec05e46bd3ba36c52d57cd5c915c0f793cd0d4e1107e32e61e42f34fa76ef2a9cf7e2e2e8b3fede9ef0be2ae485e38d49090458c2cc38cf6a72f95039de07ca975d45a97ac5bd7f5f494cf3ddae8588936fb53767bd03dacb1f01c1be3092dd94a8db5736cce6fd71b44bacf79b6dc1b75537331a75e466a8c48c5b0af965864e954996eb012ab9b4555cc3e614fcb48f80ffa135f703ac50622987ace62a5be3a154019dbebfad90c862aeeb9ecb1b9d86484bb343d8fed0f519d7ca41248b87df34e45a3e5888e62c440ba6730a27ee02c79ab409866d5ada2b6d020373f40994377a0103920a8fa64410582d17b64387fae870143582df5b9f6fc495f3500632f5bad9a65c198144c812aea23c6b3dfc329fbb996ef01cdf2d50f4a72360ec254e7400bc6c8b45a7b52c2a45683b730e83cc9686b50a668e31337e5671af1433db19c4428e6792b5a9b09835051db1005f4a20a79b456a9b25544546febf9c245b6e21babe575daa219dd5382a6338c7e8fdf66c86ead241ec19892f5f9eda6ea3c0964c45d40c468137cab2022a30b2096e3cf871be3dc817bb1757d2dd881d1979b61a120db0dda033698d43edc7ed128d9cc015a0c72bff6ff81854a1bbacedfd87ded3ab4566d5d3f75bffd0edaa52e1e7ccab7065f02001444471d667e79985112f1395e2e08739a1e02a447f6047f263f72f8280022d7c79dccaea6f6d9fd2bfb641c5427288ce7ceeea35d040f74880531afab34ec04531b58d8c4bd2d5ed79a1e5315c2c454e97d37c83bd540b3a94938ddf3c1c45657be94569400208e559071c7e4b31be120092b5a970dfa2e42e36e89224e36a3969670b5ad041ce6a46f1bd4d1120098ce9fe7d22b8c8d9bcc60b9b53ebce77e4dbeec3a791aa96f5bf94a5d858399e9256e18b4bdb9bb3d42c81dc0717a2ad167b8ea9d04dd40e3101061065fc29bec4d3406f93bd2694e63a89467a70d64e98c216a719f93a7f0bf4f86bd50c33487ec23a5b2d321140fc9d3a8585c335356bb0def36efc5d8d36509b511126883ea87dffa8106eba36fe021e59eff52a1f50a603fc4628c9d766758d268288cf31e2140ed09dffc5555ad039a7d3897695ef31bf861cf7a6f4571d61182fb421bb155116f375743d5333c737f69d78377e5621168f13d9628f924c26c7b3eaf0feed9ab8d91c487f6936352a7c0d4b05752e438693dfc1e4f75e5ad6368d2e46374af19a56158eb87c6917c19a900c9e6a14ccac610445f3cb2b0006b858c38e0ed7c62db4ea47ec0ad23e69d45b31a5036b49e54723c3a2095c69f12055798e082f90743527847afbc2dbd8427264ee7b6f0dffc5c8bd5ab20a0f16df0b26b7505e7e509be83e71778d3ef0196db95eea8a818ce1d0e3f3683a0747c14b610b1c560f267f13c28d89b28cc75552ce41ff9c7c09829766d8fe00752582df5bfb3401b6cf8bbddb1f511a4b997330a1bcca4b6ab975e410297a5c74f9cf98fb786241a72cde16fcfe1f56c9ffe776c1a1bc96e553f9ebf8cc5cf24f7200b24c54a272c358ad4f7fa080b77c5ba1f586c4df9814f1582acc6ee28b0ab62247745f65ffdf3ee6500a30cdc4c69463c2549cef88fdf43681709d394d8707ed128214b76fea05c3c0658d0eb73f7a4b1694f721044df605ae9e6fe6bdeeb03641a647da453ff47850d0cf27e6b5c3b601685a8f16fba208df595700fb5516aa7710c7ff4107fe98da1c0ffd962a7566ff18152e8927528189a163af017cc97ef3551b2ca45deee69ee3777df9a25b0eb2cf6964fc40d81144f97016d2045ac00e059df5b4d6ad6eb737a47be2588b0262c00f5bf64087d98f6ee043c4ca70332b4a37b996587faa5d33e54925aab7980f76c1a5ebe1d9bd643f311107250696b12e8c54af10a696bd85fe9f5570b69af6f98a89b5f93d10af867b95a2e120a3bcfd20cc0d75a18fbe0af9977fc758cd412f18383a93f5db84de6568538fd9e88019dd657f81710e9047c8177b98b5b1e0c441b5d625bc0edfd95e67bf4b7e47eaf038c07271ad37294b19bfff901ea4cfc108d0826f7aaa779eb42131e079af534b66c728c99ce85742c865b4bca64cceca83e1d9472c13d875b6cf1cc46af201210fd64986d53458a4ab7a2abecee46f32f340ae8851db69710c94348c3227b67a7c30514813926db683292a705cb75ad9f44519d13b10b65ccef1fe5be8f2a61d65fcb4bc0dd0ac49f61ca3c28fb23d4e2023d8ae1af22b0d4f17368960e291ef73494514743ee71d8a52ae01f784e515571683ab8db6be30f527d768c703f212581452b3796a32469ca01095c3473e0bf5d0bbadb8edff6d9715b049c1569a4c73d7aa59a2273c695c2938c17e220007052131e14923142b1f33081b227f60ea383c3ad990b5668cccecfb016a2d40ba0408a1c77d00bf8b592e8e34549bf00a2824c05aae28acfd68b4c7b118818bcac25505d92e04785d77e39904237807c1f832c2737abdfacea5c3b6ccfbc036274bcc8ccfe164488f3d23c631dc5c988ec196dd30c668a0d76e72aa0616eb68170f7ebd4541caae9bb69f5294cf63e0abd4c20fdc7f0b28727e7b088b094bb299a1f17a6d7af3f9c77565817eedda7490d9f880c69e744f7886fbb3663aa6d516d8512661f6d55a1d785b36d1e43cfa21d699f212578c0eb75d6144339566205318445437874a27072abe2b43fa682161dc9fed7348b4f3cbf49d9eee14db8244089938e94865a5d91c83010a5d8264b3a9d715a93dad7802952f19d96c0bd4f4f494218e99c3e36842cd43ec03e01254536191610bfea0807b567fe178a6ad807335f2ac5fe830788500b2d3de50329e1a8b86f33ce2a3be95ae149d7ccde8c6ebf4deee0690500f0d88ec08e6c3cd7f804aeaa4083b846c28f80917f7568def9fe1e59531bea45a6e73e97961cdea1ed42001ca3370b9e0ef3f09feb80ed71ed3c15b529271f321120a120e7056e0fe99a2f6a0dc6ee3e32976d20f05cb6d5d3eb564d3ed0f7136e12b0ac059a0d49b82072658ed30ff1d4918960ec3ee13eb18aee3892836319c80e9f35b2d2e92861f19b5e841492b0888aaa9f9795c5ea16fb574e435f1d92e36219ff8ec3bdf4a37947f16101c4feb2c568cfcd420a14ad74c0ba96a781768725e2db26ad976136c5e2f2b58d6289eb7287139c29b78da1708d1ebfd96bdb3e0487efe4432fbd780878608fea0d0c25b083c5981a86244d3d9e005552f48ee40d7112b662d7ec74346341be362aee44699bb961a18c145ddda89e2e2371847415cdf616df270b8b7109c0d3bdded961b7d159bb6cb421437dd09ba7fd9bb3377eaf0b69003931525ec1b3de742724a11417111c3aab2a8e75352a5c72b2a14d4cd2cd2cefb540bd846b2adbb19542b1fbba221b8c30105be2ab5e8d38d4977a273f1478588ac0ad922b9d88509a8d103dfe5e1b596aff0301ddd19f21f4cd0a12d67c268f5912327faa5aa996e21ee1676f83a416043b480ec7f47280c3ec57deec9f6031274ac5ed4adde11a2fdb3f018f689d6527d234a22a9db098b2f5fe964e661613b8be0f156eb0b412d3d5d7d37874cdd808d2cd5dcb1478010f27176be00a01f76364f0a56c771a1fd53ee04a69eb96850031f4363bf9f4c7b228be4e7b5873f52bf103c6c0976221533db81c0631ca4deedd4a826046294dff5461e00a1cae6743e884771d6b31a3e7e29ddcf6d2deb50fddb69a892185751de34aeda3a45dc87811b5c32365c69f0082f9a457fe49b250537ff9ed220ad9c8206566b4692e556468c006ce58c28057c0c030f31cb9a82a9588c7c0958cbfe0ec5775ba7d72ab2091ca4866d68abc315acf88f7ff616949e67be59e14ac0e821a757cc31bc8fef2dd43d888776d909ea47f538e9c5cbf1e4cb7264a5a4f0e5e9e0d9beb9c5121d7b9e005db4b83bdae22fc019b851d5e148c3796bf1bfa9b1ede70edefe28136be3c8954588a1db907de7ed79a4b2f77dfc65201d2998aae0e0370dcaf1474e991455c7b97cb65d8b08c3358c4269d11a24ab45d19e206fc74e5b2bf9645ce762c3f1d9779b41331d85637efbeb3cc5ef33b091788fd354fedca209b3812cba7c5154021d4ff52888a101578bb76eeb13ea862136a853f3998526a68e12a1e0c83011486d80b14bada234564cf04648c246e0e94aee9c1fe0741c353efe9eed6b857bb01fb8422c664ca91ae367e90672ff14dd1860c38c3e2d44e8cb1863d01d1a2fa220fecb68480d3f0c2085cfb7cfab711e71d2c1d5192128900e660b11e4bf9d8d9a736144dd78f4601cccf7a9c087620f332ff2bfa651405efedccdbdf0f2510a460decc35f5495c6535fb7eb1d0d3a6db857801d4370d1d630e4170524f35df392eb587a944e0aa7f44c5be049442cd325ba27cbdcf54d38ed2f3c40b3d056b808f52456eb481172a5a7d384c0ea865a20e67736665421f60bd270e3f57df3cad1122997780b58cd0b99a39a0025130aa204f8bda5452b846552caf3eaef7ca62888f319417467e19458935f7052c517673b35cade02896d479af319e64608a0622204ef321d91f29d3de6949f4876f1332835acc2bf67372ce8546990d2abc6bba9b145a310f87348e38ed7fba46883b6e19095ac24cbe5c1823e12743219ba7d58927d9c4c5978a992eea5618216bfb299efd58f4ada0e021f3a099b1d70bf1a5e421a06a9ecf08393290a855718761afee01f499c7ba14d146b8674ac9df785b1cb8604581919f6ead1a90e032ab760e8360b8993c61c6508c03a2af3226f76813062e6d8269114795bb89e63be5f8f9099a5c5b4a9e207f5d1a68bfe8f033d763e02d4cdf5cb6b7957b4c2781c2f57b50fccf8d0db376cc47449302f1a0abd84269d1288a8e08c25953fe04aa2ad9eecf6bb53f73b1c4d05b07b96e64b1db99f2f0bee5638301035a2bdb99225b644b22be67bcdbd0cf584d0bafa85fe120c079c5ff36f9ff636c7669393a148b150ba793daf8a39ac860ff51170b849e79a85492783c2ebc91b0ca1570fb46149fb1e8dd9eef235a2a927916857db30176aec5b3a0151958c01b297e2fbbf2912f190e27fdce2a99956bac9755f93d2227f702029380cf7af50e403fdb3688c34830f43ee71e6afa984a6539e29e442569c214378b9221f84540041d2d27cc194b8cfd6a6b43a06d82d0b289512075e32c4de46b2d73760221dc2c021d79a6d2f3686c17d8c21a4df130f72e9327c4283a5348c0cedc64065201c39558fb5b27c13aa4e0474def4088290696f1460fdd6a13dbd04c620be8bb8da3cfdf0eed5279a8b97ad85bf4911c40cb82806dcb1ffd0b8e818bb9341eec29d4526a12fc245748ea949dddd99d5b159056266af752ee81e88cf95fb4628304641f40846ecd4c42470ba3ded8f3cfa81e585d46b2067c501a82b3de0e5cd877eaeafa0ba5b0b0921f17c763c62b8ccd0397872c2f419f36600d52b2aec2669c08866936890b4f67632d153c3d4ca70e9ad321aa49d1a6bd480853eb67eba1e9cd9fea8c65eeb1cbe84022855755f939cc3a10a281457a22908161f3caddaaff58ad2a84d3015261cb46f968ffd10e33defc49718f0c337ac1e2709abd689101b93d600dccd2d80cafacb664e7f4ee7acd72d5079513b34bf2ebf17a2f702fc2a5c9b2ed44fd3b9bf854d3ca5bfd50a71806e1a5fe8d6e8fa9bf127f5133dda2a05910b2c8d926ef63e3d40761db6cfe9b951fbbd8f31550344ca372e31f710970d57c7498cc2fcfead0ec72f755677f32b7fbb0036be608f306ba7cfda8961b68529eb291068e1efba39471817f58ba30979ed4c3afccbe02625f0f57ffa74276b7a1121ebaa04b96bb8b3eabc90d5db7d839d1ac9e3cb070a731f7d63f01692a1b6ba8ddfa6ba4a39cb6af10f8e2a80939f148baf787b9aa1fba92dec7ee2b6f0584020e0c23f237c9f836f3fba9d5dc5761b0338bff9a2af9482b2631a1f88ce293b91c4bd92da0a2c6b411bf8b6d309210ce53c815ae8da4455c75dcc40d28bba827f9195eb96e4c4fa31979925fcf061aa5cb70d2807343d229fd198af15827ae5adcbbf18ed0ecc9dbf4a3fe8c32be9c22773fff7fdc8250954b7589a5fa7eed1a9a65ce7d4b54342fcc85eb32f1537416a9b71ee4291d30752c7d1501ffab202875a03ccb2118953345c222f8079f154a3f25bb07651d99a734c0e1002184a6296b2b35e201f49c2c00b512621d53224769039a15ce88c6a520a647fe2f96a62d4707d43b7938e0cafdd5619170ea92f054d208c26f3e860689f89ae56c5c5e95fc7030526f71ab6a0c9ea9d94d46187e2afacb04803273367179834061d7c1b3c821f5b989dc9b826a737c3cd29a5341f5ad357361bdc607609c31689101516c47278142909ab768541815133f4012675b2cfdf2744be3bea4497111151f568b1ef227be9a37774d5a02d4f072809cf93b7f2842c738b48b66e7cec7c6f3ccccfaaf2d22f6a4d1f8d892ae0c7046693adaba3d9a483196f9ac4444dae3047f920adefba0cbea18169ae0f971710dac1e8355dd5d52890dbeb9fb01b389dc354699ddbeca31c0e44ecc202aeeaf86b90b58ff5583743d5a76384c8c6649be9c2a6e79be795323e296ebc985443a313f6a8cd75fb94b647e0070f225b655b7c8a988b2d98c091f4f77670a50e095ca5fbe88908a7afeaf9b28ad3a1d55a7107590e6e665d3d1e39891378e5194076c733399be52fee549c5d2e233f3d03ee280620c42a7aaece03fe7128d210e3025760619caa48cc0662cc8554647b4bf38551fcde05069802aed6db8da6428477a111914618cfa997cf6541e3dc1d594d4db1ffaa691e1c910216366e79e516f62fb51fb83a650a3a4cc21379af07c513a21dd9406919fda7a52585fadc5ff19774a553d34a1c3d9f452028e7e345b1562c7a83555d8449f4cff7503598d3497ee8586bf5ff0de77a738fc69416e10f2cfeeae9405d3378a7896dd2f9a99321685d28aeee12d3a81cf00ec188a8c7f328ebec666686cab0bf80fb82dcb79146e8b08e1a1ff205a4e45d624354e37ec9c76520b572580b2ca754b64bd0bbeb6390d11c44a5d92f654c92e70e629bec6b2d5cc1522cbd255cf09e1a17be9453fde4acf867d5de24e0bdf7adee053eba5eb9fb445656f4ff011ccf257d68c731022e8ca1b2339bc1b3e9feca53743c37fceabf49b08252354bf9675ec933c86bc52fe7136d11f1f23c3bcbe357551d30b3e5251c756892c8105814b8fd5f490669e9c4337e6f7a457c24f069fe8fdbe66f7a3de6e533327a9b3b5a92e0235ffab03a7f810c276c4547e9179518a871c8c8f5fb1939c52e2f3bebe3fbc6af74d11512b913177296193f1076db09d4037c8e5c372a9364a8708d6e608cb746c4ed3b9f50953a4ffd0b785fc5a532b23e961f0c654cdf4fb00aec2c63b7ca5f4e31e65fcc58b826df62ea9610e29022a5142522b300fac4ee950699bd116dbe0c518180ada9b6dccf64eaa6eb4913521f25a3202411cc101be986adb6b7cdd0ee8edcef82e8415781c07522b6a6685a2a4c05df7310cd27b57bd18c8c1555a03b85d405ba7ce96428a01ad8d989fcc104753caa1fe78304d47e743b2856566494c4391d01342b1b1746f29c164c1f584c662310a3f74e8eb7ef061d6249ef495eb6479bd2952145a4ad2e4efd431b710ae51d3b4edd86ee91b3dcf8520313dd558618589e5dcd3f1a03d8856f288d23504cc7e87b54198a1e0f760f4bcb9bf2df45eb635b255c975ce105cd3c4f395c397507e676383d5b77439250d2ab28f9414de4b952456e28df3a079f1efe7a2a993d4d92b3ac8c80c92180134c891c51b3c37e4fb6bd798f113a540b49070e6a2d2b3be4cb3fbea06674ce865ee9d6314de23eebb98fc17fc428530c858ca7060dea2ecfbe7c395db37936d2c03e2e1499b904afd5891c435f35b133b8722b4747480110efdc42c2bc73dd6e825d0c9b89ebeb1a8ba0531ec09994e101a2e5175c042d8dc65b75b58c65e7659cc0024d0f01360a6c8b01eac7e229bfb805c93b2e9205003afe9ee556b790d04eb9cf9cd6cab09da4a6205cc94f91298060669d9607e0502fa8770c201388abbea8e95f2bef29b2f009215b3f2f9bc1c0c2cdb857a5da8b70f9d3b1dac8e59f7ba0a84de3bf85a20bd277c3e0fa930e8ec3e456df6a5d04d7504b9d682f3c64cd87aa3ca903c37664f0dab6b23d6193aedd984c0abef2fba2a3a1c158808bbd7913ee609347421bb97f5eb7e7e536ee073f9a35bbbe6d11e185a76fa07f3bc86b04124caf758d0b4c5d1f81877c41b4db7e97611d91b86540f90a56765498978f8c7091c3ec2efee11c37a5e31763e2503026a9a6a9fbcc55ea17441eb8118084e3c0a392917af6bbb1a94d65878c4ace2fbae1c974b15ad3dee5ecb29d7031c6f003b851060cdfa2cdbb3f9a7a3ae6f95c4d61313983bdc3c0e07e799f030ee3857f63dbbc1fa9fbf9ce0fa3130cd0760c6d44f8599a2543dd92e33fe134b981e0dc9e9c352e30efdeb32ce1ba53f26f5d616664052ce29b36e199c4e69c598761d09e8ca1c97fb9a567281eef17382f8acde8783169e6e3abc85be44743ff77e255ffcdf09a049f858b66ef676e9c5ba595c8ff6b522bef666966c9cf2a80f566650a3b463b80754b738e0d74f28338907acb1565467b949138cece7a2b86bec66a28f36fc5e2facb7bf8304cee4645208ce703ea010b2a8696fda8bc5161e00113e7df4e4de4d065f09b43de6f9f95c6fa60e0a24e235bdd226bb171aa6aba30238a68317aa75796c5fe278a34a2a7e1ad02234f314830dcd17119b7d8fb86ac88c55e6865f15f88953adaf05d4bd13aae0a6db385103c0b7de5c780b1b5972f384b705b74c33045b1f21779f27d9e495bc07e6e453f58db66437df5d2fc68fef67d8389d0046ece4f4f861e664e825a9f127b64f538ca9e3a6a9cbc2edda884e8e9181f7cce2114b750934ec11bff47aa2ad90c1a245746a6098bf1a6a2f7796c3b3782ad24b27c9d416f13631adcf8140204cf51c618b0ec862ecdfa23fbcf762fb79ffa2252b36a97b66cf16dfe68485acfc3b4b2ff5a1f5dbbda34d60ae749c00b9f324c16d223762df6cb4d14073ccc84170e28fb45fdbeedb10d21580a2560fd274d53dd13ddcfa81ce9b933aa10d7347603d31a8b2c7dd9d64ddf831bd23ad6a8b71690efab1e555a2b0a41286a3ac0f078bc668b2b139fd1abdfa7255509204fbe54a2399c7b5e036619dd6f4861dd783f3fd2b22afcdc96d88abaab52327cd31d11d29a9ea7e9ec417ff6241fb934811b8c8281e469207fe983af18cdd9784dcec45f5ec56cb7a5fb56af287dc67166688380fdd1b1b9fad0fe536a8311911084e86f0c05c2bd60398579bff8b99d714d14c6f37c2077817e399c350d9aae9ba554061d8c558933e73fc5c0c848497c50ca9f9ec5b55c2a0f696a754be87bcaf46a63ac6a98d5067d1785be44b5defd1d1963e077fb316830e409c4c9c5aa2fb9d55de941a9876a4cda14b3e7b971fb630b567db3fd4c7ebc2f80d6cb2f5dfd4e7d03c6a86840b39a232c3a89bbb56af8914f148cab2fe394a1513358a797b915a1248bc10d78a0fe89cade358fc120a83c24eb6e47e766a4215856c50ba981aaefdab1d4f3563b8f44c5e80781a50d41814a393800aa041855ab865bdb85c8806513c1a0ec6b86661b2beffcfd5a830a98231c51fe8e420571b3f7715dbad490a898baeaad9c6fce779b1438e40a57d54e846353309d1b0835f1deadd0c52562b9acf0f3953d44088c14efcd47658f39fb83cecdd2c3a91574c141f306967a34e5277cb2d56771a1bee5c6f6756f1e200214132435ee6a6bc8c5e3a7f33a7a92a6751f2b7a14fd9563232aadb486944713daf78a30b10d4ecd30a0604b0e60c9dfb40704696cd63d6c43d7bf248205b0a01700ba2817f1925d7663fb52b01c486177b00496a5149e41bc5ffd29a32c559d6abf8002193c4f07beb4839fa593c92a28ece8e610e00386c2282abcac1931e82497ce014fd07b33f8e05e764ca9f3ef4b318017521459bcd22146eb1097bc3b4ed2676447d4a6f0d2e471caa6daeb36b853af10030e245a3c9a9333a593f70a2ed87976628a661560efee3978fde43383bb11ab6d06f8408702086eddc7d45d769b1f532ec0d98bf3e339d751c64d7f9cba99801bed3ed2d2eb80c0268b9fed728ec904309079fa98583ff77b2a670d89e785bb85bf73fad34ab0fb3ec195697a44b1ceef8e9c1d26153e23f294c1ddbe931d72516c375231e77521063ce2abc983b0d44d1aaad28f64030213aaf4d50d5b8610937313a749f944528e3453a45d926976086bc38b41a19030b462661b56d6fe496525406812adea68795c5cb17d99e4ac22d59ffc6f44839e4192a6c1e25d5b441686c24c66eaa82bf8687acad5316e092796a83eb1bc0573d618ceeab74048b2d6373956411fcb384e14c40e747c06f06723354ec5811b14c054089272989c9cfabc49539d4c79343b10c8be65136e57cdc50e39d1947d2abfe0bd23bfa675c3dfd590b8dad1e64f79c478674b08d3483d87701138d1bd4b497e9ecfc99e333cc68b31020fcf8c993d8c3740aef83d0b0e0ddd787d8d06b92afa5cd0818decf6ca3481578207d934a452b3ddc8d1db09fba093987b026080ddd94c9b729f5e0beb9e69f9becb43036dff39d49a4f65ea69b95a2e2bc289b98a13a6954c80a7143c6a552fae922681893b134f97c04d232ea81e91bd869030d1f3ff9823c35d8df1297a4187500acb9dffa6960e6a2013ee7a837f8ead688bc7edea83621c5642a6b5a8dbdffb76faa58b7c893ca60b50bea9a2339b856f3a55f8e61d11b124529a877d16e95e949f57a8ba29e645dc5fd3f4b73e256a109fb71c453cd60248e64f7f4cf78f38506111f7ea1c66c62126aa2767cf34bb0aee23e37b8e6bf172f421fbf40254f1f5ef6894e975fe8aa6ac771b5c113cec680430d3c05973e608eec32da8e9d5a36e5bdd727cdfab8ebeb05c8193700da057df78d11d6f3534ebb3e74952c03bedb3f3d96b069032484e2eab0f18216076575fb49ff1ceeb0bcf93ffc066351f6bd23fedd97328840c1c917966213ae92b26517c37770265ab4fe3b730c85230986813d62f37c6432647c7f8ba611b7555e5bd9e63bc67d6d914a84125b0d84de532fb21e1ab1c6e67c19aca283710562b45f0380211b567385a9ab125cb42e316feb47d094d3a75f1b7d4a96742aeef668554d5f7979bac442a9f2868d2724aa0834589d6fb99c928e53256dbba13cc3dad8219f1f9c41e6baf97301eca1a04f1c78802d73cfbe1985feb633ad0064e517fbeeffe7ed1314b2c904c80a41ae9e116edcd844f397e7e8295770506b778b1beb849eeaab3d876fcea230aebfe48a8ad91bbceb55e6853a4490f8430939c845f50d5477f4ad1f5334f31cdcff02c92fc03433cd411e07c7711e89239efbca413bbc2409ce3308e770004482301a4dfa7b3a6e79004abafd52303c3ea566d9e5ff6fd456295ebec7d27ad8bbae990ae68f7d7efda1c203bde8cd18c3ee0e0815f4ab11713d928f710270a2b54cf626afe44efc7d8936b713d40d8a9b2bd1a95648f5a3b050741080c7bd1fd0c9db778b42ccdafb8b280877c5c9e4832c0c7a341f16f8fcfb58a95769052ba96934335feb0b61a1859d8dc76a7fd0a21846844e62f15dfdc507c02401df5ae5f2eb55089fbb9c07dfe165064b03e2a1f7557a3d5811e823585c21ef061744fa731cfc5a69817aa77a24092ccadcefdf8728f5fce914adbe49155dcce5b13068df4b4834a78c1281403453e4a3fb1a606fee7d34b7e6ef5ee21319803b025bdf4d693376e6fee900f817d9465df98813301c8fc065ef0041f38fd9e674a4f3f1810736d83f7edd34c9212410bfc9457d21ca82e88b262a1068f5ea854195f21de30c6fd14686ccc3386c3b28f30848e3aed34d9b43ed019125c541b89a8fea820c6768fddfc681cf8ae92b225d1a798d97db54052d7901ed8a801ab0bb224883f5e5d8ebd0b109c9c0d08a438eb3b16bf694f386b262e0e3cfc7c9fa40422d2a00b62436fe26200828f81c96d8da65ae571b4dd59a38a9ac8c6055209dec3d0a45954907af70edd1f77247a06313cee11cab8d78fa04ca80bd55042aba0e51ea4d50481c196f12431935fd8e84352ef22cd9ccdea8ea0e59983fce29b5534ade5e270c6be754326e3e5e3b8a115c070ae77458eccb6c8bc5f5631a4c1c41300ee8f58d178a7eacd01a74aa7a47b2e3b3ce55b22253523263dd39788221ee4c0f0d068c286b8dfc67f5a9d5db486b425449948bfd05283d2dccaaf6c1d67f566a053ce3af4c749c51a5704867a4e1da17861644f784a1f9c1735479831ed8051a26d82b7b6f3d6541bbebf5bfff619021fb01ea814cd206dd3c42adac021bd9f3f26f561477958d810e03751acab38410e2a6adaa4d9f384f3b2d2367bf56937ba9ef3704b7a2b67d1f91b6ee6717a7909a9fa6d32368e158f4c5fd884596be24a5356d895998db6033ec806986c6ff1dbd7997869269fd764f8d50344d85e32c5bb235f100e238d07e356cb730f84869a855ab875a06243c9f1d695439cc560d8f196f1e92bb44f79aac16987611fb3210e9668239a91955914e0c4d1c3decf2b15f738bb7c8fac550fd041b284911e754851a17943ccecf6c921849d1962ce272dab043aa4a086734d00a4b5fc8d185b24168fa393b5e69d78bcb7c137f417b66b9555a8fbf2b67cfb4e51af9cc0060bfaaaab89d4a27a6f4781d2babdcef59aa6c3e624345e0d3237f8140633595968e6172f077a4cec502a6c8bf53129e8c9c55f1cf665081404b493e491a4121a8fb186035deae9106b7b0fb01e7373b4063359acfe4a2dac7d7ee7759164f199a48a307ae0e55b3ac0622dc03b38833e779666dbc640fc4c3d7087466f2de34796f26f7de923b99840d69ad4cca4c748091250507395d800f436874f6a7b9d2bbbde3f1b27e82ef64c5b2d0d005e3ee0a47b9fe653251048b2df154bb7afcb44f0996bb3d1b744876b59e3ab28bbe0d3efff35c60c9cb2e19320d337f9c185fecefc91cd847e6da9758de7c8ac68656f9514e936f9f94962d2e093c3aed055beb4323a6bee29b894b826ad306808a936b2f1273d1562e28baea334454d594bff835603402da99024074c17286ecc0b6ace67d8da9bd0f2f50a1428a6395193dd6323c3a965ba93ffe8828df3ced0d756eeb31941f877f06957f1df81e21c654e639ca2cadc4a250761555b9c5c58fc311efd30097245ed1ef4a47a6ad80f48f017370f6f0ba49ab3411d77d4bfa794a1fb43ff1d9b803931ffa3348d77a444b5285730e7a9d1d7bbc624ba689b195ba150163903b6ffac6238f15c3322be4cd04929d94b70f977ee38402fe847c5c291cbc06c00117fea8fd6cc0e8f6d0608eceb12f1f202a22184cd19668ae81ed2a3e1f23f9e219412e9372ad57954f7a5484106127edab5509b14d4569b49e347ebdfc6fd79434fcee597695102237c39f88dddeb153390ad027a6e2b3897386723b97584fcc202ed5d3e348dbc0896a372e36a05838a5f11568baa124a855aa22cfc35c61621978562f7884a2c51bd4722d09fc6b3d792043cf7ae31dff079ec5b3f0a573beeb4d4b6b25a0e1c69eb380e52c0d9aac5a8fd044e720021563f1fe5e35d736d2359be472a6979464031d97fae458de0428854cb692d9494949c0b633a641fbbd40a3e8ac9014e206771bca15f462295199ec86003b106dbd7bb326becea1c36eac53608a337d13e7dfcc747daad8ac3bc29460db01142336e588e441117072328337af7ea601dcf88d71b87b063c06457fc4fa577cc82b2764ac9792a264b118c52d6687b6bae99b9fe8851e41184f2f1ce3a61cf880d5d3025547830acc375672e89b4bb2b5a79de8e64f55fd11a5a4d0258d36129bf5eb77e6be06a4da4e19c6066861d170cfac37cfda63c626f3ae437ea3e3586292a1d2734a57ac558106e4f9e6f4e2362c7e25ae9dd6e9a78e35ca81ebcf124dfab017eaa4a21fd07760d26424c061ab2aeca78f87be830c81737237095e87bd2692d7b1160945a106fcc1bd64bb0a070e35761456a333c1ad2ddf077dee0634d43099cfc47cd2cf5ef9b5353c644581e5984a94b7041030de6ce7f01d11f00dfecd6c03a97d705bffab39952e5ffcfb61cf62fa844bbe5f619893291bf5a3a76127b459bb16d199bf29252a9888c3d23377f285099207276f20f10fe0c9e695904f050a298b4b24882b90e0349b3f120b6198c4dfc4aacc71063f78aca542302073aae464c985c8a02cf6f3569496b5774b9c8291f894c9f66b94d4e37270aa761c9f3711b7d4adbd34197d7602fa2d0fd1df16a375a8b7ddeff54c236267914360d2208eb984fcff871a510b8819f84b655fc1433cb66e99a683d7a5d1286f0902953f23a22bb66507c1b14abb25875232b17ab245364913b642b9e6fef46ca5e31c824508f17bd1c0dac7085ad3e1a0485a43633bbd12b99c8cf429cde89756264f220cde87ea5ff4fb3ad50823cc09e727fd0e5a6807c7d2dde3065fa1a86e9b4721e410594f1d1b40d1389621dfd10ef588ea3ae09bf67c05cf16c480cbc0f1ec76c8fad97bd716353942872931c8ce5ef782baeceacfd9643a02bd4bc41a4504fe6a0e43ae96abda4462044025a55c12ae33e81c43ee006e310fe96506a90a00fdf46e3b32dd12bff1e58149f94f92fd0f162d1c5cc91b66719390f89e80952351621545c755a97f31a60f68b215c7400f2165da06431e8f5363b0c93ab77a53504c4c963dafefc719c490011d5d97c61586bb1c560de74364dad23571ed347bc6c058d1e879513377733ae0dc19f2b07f57be914e28f7b99eec4517a3abd3fd420cb330d046d61e9462fc3630cd9892ad4e033a0d1b0e27cacd7dee8b166e68758ab91047d9890aea4002b0150137818239828032fd0fe57ef438bd103a4ef137a76c4fa230734165b4adaf4ce09db9c3dfc25ca4cb876de1b527205bd498414582651df502ddcb7818f608f422138869ed33fd0b977273eed7a0a51f76c334ef20bfbe77e1b8238e464d54836f384665e3cdfa208592a92fe54e2fad858c2b117e35eb73d19861c67875d9f22ef5159b168263f845cd6a0581c7c58105855258d9111f09603af4a56b17143d11b84b54f36ab7eacb939e347e387a5660988da9f666770ea4649784e637af63ab6a5c52ba76eb3ecd7bfd6854705f400ee6d5b2736dfe89f67244c7dfc018c7c72fb5ffb7e59e63d8624d238d0ec5eae12fcc11a507c071cff95fc67c605e3f8b7985d2adb2c1b2cceb6a9003926106b1ad280408186b83f3b9db9a25e27ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
