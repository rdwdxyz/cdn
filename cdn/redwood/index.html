<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36c4137079857ca71b301659a2fd543819a2b2e49a7c3fdb61a55e78b85460d7125552799ada22bf967e308fe95fdc1d3b0aa2b1fd0e709035b0fa00596d70d0be566205a165717b6a54990254c74e9ac48e0a051fae34ac39412a872db62727434b39e097295144010bc04a1442d55445576b7314408eb383fa888dae1ef9465efedb41314b748603d57a07015d09c774a590e8772b8e8232c8fdd9adff8eea673b331f5fa85e8b88cb4977349180c4f9717e73ca03d2ecb7452b3ceda57c041d62226b14c7a95e0f05acecb49a19c8d6fa7e3b1cc3523dba228e2c793470c0e155b319687db93f4092a18f647ece95e05da4ba8b7696ba3fb0cc626cc294fd2ca37013d11915290d8d286f80f14b763ba3385866829fc8820d33ff57f1757996148d1bb09ca3518b2421fe342050df6c0852251c84aae21f248cb195b50dd51d373a0cd5ccba7346e675328c4676a18c4416fc4ea808ee763374c0fa1b999cc79299b99e18779c21ae42574f9d86a0a4ea128895ba789b18ca22027a7f52ba8907947cff26e22643112dda479d32ce077b3b61b61baf7f5647cf893cda34ff9edae280b1c6a759fec441802a1d185db0cb9edaaaf9599bc10c4444f5095317fc2e2706b974d30d76960229c4a9333af46d102ac4b984118e524d53839b77eb19616d2b403eb8e9d48ab945f8c6b46af7fb09e77ba7c0021c4c285467ae1601dad3efc5b1fceb4217ddb07946b5dfd662eadb23df86d9706bdd9ec3f096ef1c3ee3b498f4bb4368daff694a08bd7deeacc6c002496f75cb0ce290a93888f81318a66ef09756a97c2ef640d4959232372efadc6984bf0a0da2937d53a31e62d40ba63794f0b02feb313e8c0c535434d5e6f06077011903890fb1c6a7f14b19f65676a950f5dc9bea5710c8989ce974b392584cbdb8feaa7ce94d4f123c75e9de4b207b7e123c0cee8574bb09743fa8eba00c45d7000ff54746dde8e77d450e52cef3ee3c6b68310d4b865e105b3d25073b0f54df643e57d5e8987a0e711aff599e37b3a45d8e29ac5e6ca0cb7fde8511327dc73cec959c2bfad32eebd75c268713ec26fb62ff64a60574628f21ee868ff1610fde62526677050559ca6239c4ccef9ba0f5a8f5f192d4df87543aa5b6efec7b4f1b64efb1d7f199f2aabd4a9d4d5d29d7ba966450e1662925099ada19bda3c7119ccfe7008a55841b1ca946fbbc3485b683a3399b106f16ff87f2213a5fd6deeed34e44f30f54a6728075f5ffac72e35971507b78ce618d260f0a045d7b3983f0be4b4b3cae165a81a523c423a853f6941a8005dc99c58ef65b1c41860490c5769b1d83bd841a305580cfc6e88cc5d9f7269d8469a3f73a5e64f18796b95349ed59ae432c897c1a976a0f03e249c921f9db0df8b3061697024f9351729ab3a5d7b783420f83caa62b0d84367aee39cd82011088be587eebf5d7d18b52dd084ffc53af49b4f9ea2e06897374d976cff7cce2432afeff6e92861cbce1842623a7c2aeece13ed4c81eb13a1dc63d9fe22c3cc43aae3b4deafaf784bbc9bb033601a4d6f4c03cca3709b89f1775e1d58c77df85474da0938b59b9d8800c24155cbe71d807a0ecedfbeac8e45332df998571554f88958d55b70d99c03c8262264eeab0cab2a17280fb67438a8e020215dce7fe467dca6673ce2c13ea524f561b1663b1b977726f2c7d08ff241ac2e0869f1e7e99bae5fe1e12cd49751136fdd9306258f9a583223249ec61c6979b2305a722719dde631701a9e5def5a5e154e9c75b04e0f80b53ae9b0c25fd224b5597fe70d7ca1f6e9472e0aa2e638435e66a19591d68260340a53b3ed0d0f6cf070b8040c389299986101f0d116784d8d0b3522b8eaf90a8d42c5cff3d9a0b59020ad4cdd77b36cce28d1c6f0a4d726bcd055ca99355d7993d752618f4ea4ac633ed3c18bb8eb150d23c92ab2e89c10cc7cc5f11851bc3d25026d4857a0a7f0c715052e91ed26daa0ddcfb8649ed95995d6cd834d4d89e44a4f0ed8e5225c7270fbdd2951686204c4d80fcf215ef56da46feaffbdcc45a3622651510d72ca3fa64a7f60fb1060d3b5563c4c639b5b19d651dc85f83b28b2901252891211908d6cb6059abf3539438b411471c6b5687b5b2534399485bfaf1a32d749078825a1ae486c32b3a18526285bc2c395919007c84baadcd16cd4e910eed7eaf0949eb2b9f01681df89bae53ef84b0c668da9472f31aceb4fdb03f4629e2471cc0515e913c5268d5aefa40d8d626e721f9445879b9808b94361b64b52ced5ab2637786d30ec6671cadb7e62571281eacc57d4bc066ce94580f460bba6afcd26dc59e4b6f07306a7af8b293c78b723560452829a665842fca73c10702cea28e0958c9dbc76dd1ec65b7bfda4b8a8cfeb344630da9f74d3a625dca15524386e80588e069fef28c4856b8cff74b48dbfdaccae2c3fae86a37b8e8dc1bcb9ee8c53afe2417a793a7cd2f794e258528ae50fd47ce116ab54f3670f7c05ac07f13bc60e811e6162b4640abd71200cb553bdb6ac68f5b77ef2f3bdc7757cebc66c06dad8705fcd52fc7fbfd2bd8efa8d96a356a39cda2dfc0df6bcb3fb700e92b3a5acc2788ff8f32d1634e46fda0476b06dfd778fd14845ce29f69f1f2c4112ebc3c20dc4f6d5071e3277b9174b1e07126e1a7bf12885ea8235985fbfbe7471a5d21dd8ad210cf17364a2f7d787288bf39fc8e4bea2ea3c54cdf5025ccb7534cf63d34f7097bd702169c1b84aa07bcbc8e1dc791251b9ec1dc4e42e08f5e6194cfb3dd1b705ed41fa7ea1996ba02bd960d3660312ede3f689ef94dc9bf77ce446b9abaff4447e8802c125fb9369cfbe4e092ea13f8bcfacc557aec4f5dc56d458ed59438734252c862935aa0aeef2a1e55017d9b934121bc58ec418f62b75d7c2c255cddfbba9fb7f473974fe13cee3d775a9a26cb8ca31918f03abf57a6d4db9664cb6c749e9abe5f2f49c06503db75174707fc2d4b0c8897d68b077f9862bd2e2dd47881173c061fac65c3a73762c40bf49a90fc8c99e79df4dfa87f49c7c4a2ee5e728990cb4675ba3fa5844758818b990d344352791076de791d951af8bac54a8aa8551fac3bdb23ebb43b757f08940c67e41ff3916df15972ebe8255d772c66257377f9d9ae22f97de27f036d2c67b0a8fe4afbbfdef7fc6ff4c59f49f4582ddb5e2353595a2540e30f252e9df7db50a17cdcc8dfe69c28bd198396fde572c7e4aa56ea437947dafd6f53dba500073f70cfc1200dfca20602e9801fc9460fddd8d2bc9f4d34a73830c6017e9b03a38bf90815801b28a5cc6003c29f19e5f5721f0ad9f84347f9589b0461d6d4bcc545e2e4dbcfc01445884ff99d4179cf3b6fc5ffefcb3ad5f4ff4b7325daff607f90496878396ed62ff536341d9f0ee3e40f13f1f0a01a8ec0db79750416cb064069e0f9c1f279c77c60b58363faa6ccf4a4f68c7e627356b6050dcde0ab0e240b94f35338a0e279bd37c00ba0d824466c81e66b894880da0852b38f75e6087eef8558db6b2f9eb4a7a2e1347763c1377dc7e711047869a021fb550e0a8b322118cf98b6ec1d7bc0d8db6b07fb53ad1f89bf6cef29ee11085cc0469e081758559378be97f26db62284c916162ab14c199323b525efd908fb5dffd9bec60f7c02badade1d129583b20fb2b9a740196b41d0dd4d55158c47613370d64ec1c86b3bf0233d23b24e03f1c434278971baa80002fc3cdd1b9b4476f93fe063fdeb9606f9680735f36c622a18286af1b13c49972f64acfadbf96cec347c27aa31839b6a2d84831447a686ef85586fa7e2dbfe2f4c29fc01710b3a968564b341e4755f4068881c5643b426a1c65db9162a8d0657bd1d0b01113707803a64c7e3fdb70e642e813dee017754e7d70972632c860e5575b8be4443203977361e5d85f78da86ca29bad588a520ab1d17788614730b111eade9b6a736c64f9a01908d551c3e2f43fa8d44422efb5018c378f7be5e648d676f138bd3a20c383b6bca9abc357713534bd865363424b9d961d68d82a2aa90048ac5eaa2c9872521c02d0b266d92be6796285d4378dddb221a7cc510fb3fdcef85bd826c51f568ffd0a3d867b492cd415481c10f8e41ce38e6d1ca63054a102d3b9627d2ba599aa5293c9ed0b3b48c5ff6d35f0596e2d42a47fec59778d584ef55a08a5bd7b61b8965869daabf7a0261918afd5e84f8331244cc5ff1a55e36005f019655c4bd500e2537b05aefd5112759aad15c86e9fedb9ccfd1ba94d4815b4d2b27ef3970aa82e441f960072d5976c7d9fd9e17fe9f827142e05125cc38738b1a7c2668480eebcc04f2a75e989099f3449c09b53e4a10845296788e50956975a02cddcd5c1757d823c5d3558a3e973b304697e99705e641f7296b95046e28f4d610419b579b6f15d456ab29d03dd1e258f696ce334ee6dc6b2a4dfe74a0c21c57d5198bc89c56212f416bc8ce84e4e15cfbde9d8ed663a70687a22d16d7b192d4e8cefcb9a6d44ad40cac9bcfda000089c5f631d2e56cc2015c4dc6f29be43f710165547e843c56eda56cd049f07e9488d05909f5372ea67471951f386f1af1cf673a8f2c701e94a0416ab140e7346267594108d167d828ae08e9b2cb16abf3c8d4925b379518c9d62915dfbd9960ae4eb1e923ff9f8c9e1a0e715ed7587e51993e230d2e202635c69d20466a36d96d15b14bb57f0e5412e3fd37b2200b7ea08bbda56a2feec8817a907bfe44cbabda6ccbbd18e5a88a5fbc46ae4d2518007bc8e0de86153f6d44c98ba960d09701c0d3aebf7b93a5acd0d10ac7fbf99abd4ed6b0089c22075948b21cd44db88619afa6c04738c9dad7467e77d008dc62519b659b03cdd5b51124e6ce9d00ddc362e2f6c25d26b6cbe3640f0f18a27aa60e3001406c69e679d2e50deb705cb3535f1c08644b3084e4ab9c4e4423f89c62babecf39b99d784edf7ec4375cde20bd534402aef34f35fd5d9f9b23b844c9b63d626100df0d15af8e44758682303690141160ca5f6e8ab7ca17e8fdccca29cf2b0fdba2029a71bff0d2089cae56f005c1d12937ebbfae6dddf48b5ef6added05066f219643cbff8cb266ac468ef4bda773b4b21a0eaaefd22c471ddc3270f8be35b19061c91a28aaec126da98a3cc60105ce65fc4a46ab046f0a9d018d039c412264d596579b21c87cb5cc4f06469e85a2d87310e384c463604e4d6e24020bb6392f64226ea224c9d6975806f671acd5902dfc6217656ef1aecc61036d17f6c5af826d7b592dcdacdcdb21c23d4edabdc70984bfd04c1a13c75ede3616f0a61e3d89c646dc6e78ec419ef962dc218a7b2620bec7b24fde373e94e983e28b4d8484a7c6032e25b8edd782e34836d4ff4ee89ed33b9b57a8719e613005c969ac39cf14de9756f6da0fddef9d99e9709f9d85f776540576db848a1a7ef6d639a0f81c913722d66b647470dc63a39f3a68ee8c771977bbe8530ae06b8fda86979201394cef895099f5e8c1a072433325fcf9b626bb30a880af008e987239836059d3672ef39231af514a627f36585a543448bd4fc62671732c4ccbb45f962f89067c8228b1bf797763bebbf09d32bb97a4208029134b5445e7ad8ceb600cb124a1f421907d9b468644443b81dc5ddb92aa613f98150c6ea094f180fb3e974e95d554faf6673c74bc605016de3a88d22b078653d84ceb97831e39e462875843b8deb9f902b9ba3f0d6072f8a4fd647c5a080122e20593c3f14a0a09f7a0b05970a2d7a753137aec23a0a9db34456fde401dc940841484325a198cb8935821fe76b04d4be0aac9733b94ca38948be5108e6dbf09f0b4a02ebbe4ed9ecaecef51bf2563dd347727e7fe5888c42e09f0cfe46cef32b5afe64dc9b8d3e87c32f49cd25e400017756648baa44310ab44c3cfb6db404f50fe14bf568372c68a3c5eb0faca9b99bb1a2da5fe391296ef90612abb4614772e4cb7766ff21390591f64bcebf8f7fc8b9d8370824720a3732e2c763373b21d2c948a01e565e6317a0071276a4876e04462413b67798499ef936cd13700384132b83d00f2b2393b8b3caae603dff0bc74530b58c99a54bf2a16ca96d71cb5ebaa4fb26fa18361a7cd81c30d92d0026e290ada297bc18616283d2111401c0526403f3ca98354492aea3560396c5e2ee5afd336123a22049c674fa6ce3dd71e428133e3b5145cd844893c3c1192b48099522eaf3e44989415827c4968f22dba04548c72ce4134061b7782c5f71eac35c6e9853e938a95cbf4dd969cf9294828478cd9aa7ac6468a43cc6f25ef02117f9a38124719387aff2a5522f37eb8edbcc3db78c2165c29b82671ef9e809a0ade89152d0af2c6e93e9405cc55ba3620a78d456abbbb40ad200fab29185a3ccb4269da62014d0929b1ff28c54e350263b14b3048bdf42aa38352d87b0f1096975f4c4651ff2a1581c1922984a2dcd590574cbbd0099acb299deaef8836a918defd607f64c2fda7f6f678dce29135b162830b14fa9b247816888c07311fd55e2a5e84a9c51114eece8e95e327238a023e2b6f688176edfcfc70c6d1fc85bd72241de9c7998c6ed974cb008bd6a33175012a0e7c64d95dcc7f47e4f77bd2e352b829a6abd0d475699171ef3a451545e37d55ff0d4aa9592e7e403587c5484abd0cb064e8f0de5783364767b34fa9d97371bf49de35924d3c2de5cda4dcb8c54f27ad9e68f11f8cfd933840154666cf219d9d943f4f1fc22c57f24538502f1ce689e45614aaecea99449ca3b88877c0133b79d549c3896775425b89c3a83a41f633f2940ce6057f819574400149105f86951e4d550861a06f0b10a68edc0a978e64cac9543e3789eabd6a5166b19447a13f3750f585e897a39a9775d9a16157939fffa03dcfafd4d2684466558b96adf70aa07b1983da0a0d2a262863b0649d8b944cae1b0701ebd3566ed11c6fb3113a2a7e6f92c977b1de88750cb99e95849800836fea591640705543fb53d2b0019362cf6260fe9d24c364725fcadc628e5af34cb1ff41066a7502df2565869bf1975e7cd293c4f20cc04762b49f2c72c10d835f644d6e1f8b8a02ce0375d61bbf1788e1c9f7893c2267157a88b5fcd4201be9c5d9be44b6c2d9077415586f7ff8c52eda7baed997498132a4a300edee996dc78f92308d7eb76999217df19ab92f3d0d4de5ab31a85d624c206a80b2811ec675cd01e4196cff94d429800006f6c85364be20478d7ca217523e983abb4d1c8e67c006e694603c01ddcc3e63f5c635c8e35fd5917ddefc7e88576b021267725cd803e3255fefd51eb07cce4eff2f3f09e7753da327214d3ae5080810bd549917a0bfbd6530c32311b5dff015d4fb4725968ac719500004709daca81c81aafb22e8a419bb5da89e231b7ee448309eb1bca6c298b7ab93c5af16992ea024294aed08ea92587a0504d8d741c85c4db416198a8880f174e1ac1ad3cafe08a23c717e3d852f2d43cf1e18f069f712586f4a45b88c43fd7963a26a82e7062c0d1204953b057420067472e836a6ce3839244bed9f7b47aadf4653b3e25ed51a262997727032456244d1f9bd450f0d0fe4f55947ce34c357438fe80f75d359d465da34eecc7992e6f07acbaa40bfb5badee179dfaf210c901ed34a92cd5977a84eae615a8c42067be5092ff0dc730ecdbfa5d8d5ed99c5ddf4bc954d5ac3b00ba0133ff8c2292c0606aa7706378efe8729bb80ac52480180e4ba07dcee34b966f1917bd2c9a8ec867873f4d2bf4e1e264e66ac330bfdf1c60e22e647a67fe985f79cd5e46614edd2b3303c31ff038f942515a767bc125270208285cf6ecadb6ae709085648f89b378f783f8e0c106a9a2a394cf0ddef2e212a2981a0e62424b1fa6c9404109cbb2c4fd6d07b92e101e92166186fc78a79bb9f27bbe19d1f50d80f3e3d7a30c4a301e816ac2714a52e5c61e4a297a2fed9cbea25aecba10d68a61a8e9d8e85e7792dfa6adbd397d43d2477cf2ccb16bdf6f4f1ede0bddb0959fea72eab1c847dbbe5706771520903f26b289f4e5b7349ef3b49a8fa032952963ea67ccbe7365bcf24fbc799ea41f3d760ebfa1bcce719c2e5d5d0eb78224247d08241af44ea1fc161a6f46bc065da126428b1cfcf828fd21e3bdac33fadd4aa030da9500266925b6a63f316508c6ce6927c98a40c5eaf9dbf7049990bebb36acbe89038d27553bc3350326ceadd183f430a45503112d93e354dbcb387fd2f502c342dc795adaf7681a03471de0ea9eb1cedafec67e2c10629bc4d1ac33c71c6bde784701967e3d63dbb8c51ef7c4a430d6a9bf307f3d16c41351fed144124710cbe861c906d2589628dd1622fe7d85fd8423ce15df1db4ecf4241b623a6338425e72d6960b98e3104978d18b2813a2c13348bf50b34616c48076beb410543c640bb38c34f52e6bde33c2ffc217c4047bd3d7eacc738417873e01428d518b623662d39f26832b1d765c0b274874ddfa01014cd2b88b36bd86bd284245100b8e9f4a1296080f66dd705f1dd01e06aa7dd2358e4269d9e7d267f7b6ff09131e543404f78888b896cc887f3bc48941cb3e198a9d28be4f13d9aaaa748e90c94f44d05b109388a6f65c6d513e1639be8d62095b84a5c404ca0b81ead42bd14f8d7e293b66d599112f4ec47a8d65c806ddf1f9516dc6ea30510d856001810d82f9c5cfeaf0c7cc0bf4e1decc7b4842490d83a7b959891665bc605a513a7f2a7d60bbc67e2c1afa578a09be12c4425bb40f63bb7d0860335d271ba2b0761c1ee4f0a52b695c8bd3fb677e3535db09b0903e6f8db5e64ffc0366ea31494af525420bf11de53db1daee59e871cfb859f0c451c93bacd15f1387f8823ade3ca4c5fa24fc250e1cea3da6df17c852c517557b0cafc4bb2acc77d5eae4299ad86781fbe16a947bdd186b3f04003c0167e706f0414013a979b66e5607f0d791454d568eacf8d1f523ceb8e1e20dbe5a78e1f0a11c5f6fdae77b1f330f825379461820b6808f033130957d6254074657f3446a51ef81c069fbebce4805a0a8e0a2a2b758357e92f0823d19b225a96bb6027077e86f19aba3082f3e2e5ef7839a638039137664bb8889dcfbed3fc7e3a0f679622f026ead3edb753bfac3e90078e2aa373124901ae7e0dd0ebb2c0566a0d667a2ee9a3e8c9553d45c0c0526ba2f57d43230e76cc99a7313465190a572a070caf8895be959f17df1cb773005bd460a6946605fcb9447de80d8a3b909e8cf41c920b45867f0ad0ff586cd7366818245845ec74bfdd716d0dc515d3d40c94b47fc7b8d5af640fe96950bf9d49b2b9c685a6e253da639b3b273379ce43e736dcf53b95cfda86389283425bbf8245cc82217843e8efef0ea75aaaa165c227ca4f23b4acbc74cef4cc4fbed543ce396eecbe739d92027e19f14cffcf33eb11c82a3a2e47adaeba0eccde7a2e47a67ff3aebb22454c7ea5905dbd3270bacdbb829c59069dbf31485a581d5f3f934dfa10bd401202fa839e5aab0ea94492313f29a4532538763d2cd40cb5948993d28dd9bb099846df738de88ffc0b86159c919c996107772bcf3779bbf65b62567b3f148f624bd4887029a036b7668b41185d42b81116cbe96126282db2140724fe8a614a15f9ba017323884957b53110db186a68fdd7ee4ed24a745af5295c8f5c51e5d359493013dc07c646a74e8557785291e268e078feffee68dc391c8e1058edca1ad29bde85bf2ba820962f18399e87d227bb5dc32dff49cc5fbf4b3e1c4b55313d89c6e5f1b6035f946443d7fd726f58d44903bfce403a120d31417a95e837da41ea59638cf741d41cde4b171011564a21c970444893c6977fe9741fddad96c4c79b182b3e39ad8aa7bebc99a7570dda4fc68961c73ca2d9897061b80612a956249865ec1ea9fbfa8b56017d8a0c1fdce27aca844fe367d4821f045067f62b383ced1728755da70e6609f692c5a3cd889eaba2c804ec013441019808af5e050ae638c44f5f275893c165464513501a6c37829881220e7b437e35324cccec8343b1ffdf744f8e6c86c7d76e13739e25a2a41f46826a374413fd2ea65e841cef13a450d853cff7e805105297e6d7aaa8ba8d4c3e99e2d33a58d2e9b4659f0a0d240d578e1468c506b3338ae5c993f68c1a7f1b3d1c346f7764da95eb451a65aef24de1b22fad8920f83f723eeab2fb95f4091bcd41197a333d6a21052e60e47a2082957befbe6064828356c167dd236f98c64fb964753d01769fcc45d36af82e1c2510220bde680660c99374b9996a20420c9318d80d80c20eed8b5f12b4b239dcb768851f045388089e56dc6758827f347ccf191c198ab7a98e174d9a0780d6572402c974f8afff0319029534d17292bf222a2d7bd8aa2b46f1b292833f689c2cef5ceeb853a7252e25b4a6ef8539f247e67a9c874bac2f4592864c34035887c7d5ab57dbd74dc5886ad53f4b3a8d28db12862cfd2f9c92385ec7cf421db86343c7e980aacefc7facab9280944ca438d00d3f26af9967d72a61b3a7418c325c2e1670d2fe4fd26a6585adb519a1c230fab8bda69ed0f830164ebfc294f6e751c9c00e3ac14225d9c66db4e086563bb84361af6ceaa385813e4418bbc2f77afd21d24f1cbf1a8f171559ff2307091c6a6204e9327a7b132ce5504c24c1262dbd268f6a7c4bf43ab4396d018cb227a42af91bd87a498267221fb8d945224055ff8e749283a3a9daf41cf8a4f3c7bcf14a638567aa710d0c76de5bccfa04c6776905c3f09163ad03d13f768a085858bf27174218d301e436b935bc264a3fbfcb07d212b72b1ff3dd18c0e94b3a4ef5eeb716936c32589e2c1b6ae305c0b0d49a1838ade9426368a91a4dbddc2024e82d03dbb2394e4f7e36fb69d822cb1ae0f21a1051b1208e72e77d265c093f74b77f6e6f9aea39815d02a5548571409ca1bb52779f5c07a76c2fa2cbf0d492400e72fabfa9c5963bcd07dfba76947e150f903e5ae2778116cd3b5eaf9be2793732c1b0ed252f71e4273de695f737518704d43dc84e7afd50b6c1f5a2f90aea178ba206279217169ca0263bb0ce24615e9b2da171e2eda05a505608b754c5d5c2e87fdedbbfd429aa1fca4331af3c4413f771ffcf2baaa72c532e0a6a5d196b0c78cbfde41527a0a03708c757bafb4db2948a2836d47e5f14261d41d7a0f02c8baa8f78c3d4b576cd80016faa7c437e90c379e0c11f7d7f908b4ba50d89ee4925faddd4f18c409b29642309222b390ff0ac05ea4f0014bfad990efa6514e304a6aefa15c170b11737763e7398f399afd6ad4c16946dc2b9cc53def1bf95e1f6be79c0b26584f4d9dba9a5efd2a45852be8dd9deeda8f9b1bf4162e4232033d548176df2b86a48b9bbd69eb0d5c69515f81367296f8ca0008095f17adfca1358bb2c24c5210076008e8b1eb18f25148cf6cb28008f26c19ccc6707cba12907a032fa78feacc3d121f0785d21aab003630d772bfb5142ac792f8567941842f1b91dbe5d153eb62750554ea0066d13d53a4473e44d9502a18b523fbb2573f3df95f1a3641e30a98693b419705515d87dcf3f17c758cd39bce16744524c04dedde61ab68bc2e9532bcb078b180519b026dd93281643265fc23c0dc58966c910e6eec6ed9567026890340f8158487039ac03f917fa0eec84dc860b86e19a9cc55d780f45fcebbfacd3552044f27770b0c44aff3b1541e922cb59fb2904a40da4c42e1dfde4ba9ab9396af312540f0ebfd3f00da67a1fb0602b059f82aa32ddd13d68a2b7d38d7d97a5181b1b84f410c13767f31e9816756d8a61fcc2b3b5a9bdb84daeefa63ddb8c0ab0e08cd606c0c4f6b98c1aa5451e5c949d92f375c7fc96d65239ca913788ecb963458e82ce7c91a12cac3e41b8e82347b82bd7b9cf5ec8c56d10b3665a29fff9c2c0de067b9d08a7d9023a24b83f761e15e950ee1b006315b59777715f2dd668de7f8b0a008045fc51e072d06b6bad5675d18063398be8c8bb7f7f8d3ed4c6ab956f97743c88fc4fa0f2563587c7a6be8e527401c806603f2aa578ceba2568501c190f3f74c1527abf6bd2b0a6f3140b1a58838a95f8446102f78f92eb7ead09e75c846908c9665e367cb59af7faf0ac7603bbb36864e133ad9d2ae95453fd0572aeb284639273d69c9a8eb64c862f97e1ac39f421977d60a7f72a5dc70678d9df192eb188b17ad3bf85b3ed7119883cbb6accf694c7d6b4de64aab9c42978eb5aa6209f6bb6cee6d235d85256a68e0b9ab7091f94ce8ec99f67901f0e01e9d0b6c02db4fee5a5f9b088678a7627c617f74a368ff942fd17cbbb9f906beb3b409df7cae2fa64c37a07ec463e972a6b57290a44c686b3717a55b0d00d418f2c7d924c157aae48e2e184474b778d337edd561c888623c935c6d8e82607e9de674a5c601d0ced6f0f32a7f488feb82a56d95443e3e46ed8f9c620fefcc9048001fc39048185ca130915c12fb47001fd18ad3c9c17509bcb29774c6ae6b8ddeb5bc895448da9c461ebae230cce8e8a3dc9d08803ad08ee087d6c8f90bb7f6af1e45da7f42c2057e42d8040307ef87dfbc556285b77d9e6acd7da38c0de39aeb34fd67eedb01f493c28edc12b86eda253c38d903181750f8e8b3d7704f42a68019734c1244181f55aa9d0255d09fa9caef4b797b264c239c8351e6fd9ec05983a8d7755b889577e0c1dec30f4a4c863502f004eaf4f5efc1c093ed5f5e88b9bc6b7bff571597509b27e026eaea7e9967c0ebe60772f276dc4df835f885787a9ebd34596c07c56d20418c06385b6136d2eb86aacf8d708ee1d9f6336a6eba8008fffebcc30347504189f7b3da17332f927d9bcf7f1445b35936ca433d12289ee1b28b81b20e48db09ba492eee766a2bcd09c78f319069f78bbe8893dbe2835e5984cba85f66212a3e15e5a2bac54b776fa26efe1cd18d017eb0a9e0e4c06a658138f949c8ad0930bef486e46bcad0c8268dbc8d945e521071257b7afb84f9be108014b1f27474dee71adc508db41f758cb1c501c02fab080d814bdc922d6ed14dfbe03f185a3d416be6daef26505f9a1dd3ae825931d8ca317aa85d6e59321d15bf858c14971e823332078a037b309986447779fc4cb69b1fa81d8547ebe425980d4292ac633149f2e4bc041ef68d6c01bf43a671fb9013f1277e49f59342ae460941aaae9bd3536e9e0bfd68230d5dceae074a60131de8b7d385dcc245fbea57b0ce10c97a5157c0a85fbb0af4508a1e268edf8e915638da0bea9b5dbf41c5e5ec48552e86986195486537a7f7469fdfd6f433cc1d916587c6112760eac79cb7ca69182206466c44b7c17d69989983dbbb9adb2bc8e6f9c82fdf0d2984ac58e2942887844bacde67184e834aab57636968d0a56e8d3f6878ad74ffc5faae4c31aa840ef5292d6e785b3976a57904ccaa780bbdf005a2e228640ba8cdba0eb91f2466adc291912b9e48c6817106956951f3299d9933d851ebbc868ae79b671e13ab73e3f4aca90a52d2d5a12d7dfa3831c0572f92e96181a227da9653b7b2e70892c5b687e4a0acd875933d3064b638f13256edac2535770fc3a20e669fb0e98b9658abf0166b19efd6b6d1f6576936f4a9f6e7f4d711d382ebad4b7317dcd77c90bf4364b5f083e32808ff77662048eda974ec0cbca9e3b9d7d021898042f0e776f148f17bf1adf3f9dc5300f8e038dc255a96cced31b849c1f0ace399cc3f885289650dc6c77c364531cf79c4f2ec99c52eb1c7652376ffda17e8960c904eac5cc5968d03a666897849e90623f137aff29c5af9c43c5425a5520a992e8891a3eabbe6f822dab4a2f8b0e29dbb9a52093cb13415ab95d81fb8fcc9499d2375f0d0615e235aa2c1dd7fe22b2318566ac2194b4a91692db9ef99528cd204059ba1f90816c58f32548c26fc4a4fb7bc1d4e5bcf0767a2a4727babb42b8ff5fa17b9d8d177ebef381e11748d4c6f6a407de2ea65be07c6c6e81114b365066f58be10931fe039c4071948e99f552a696261387329b00920f30262a02ea84593c12254f09ed978a78a5f483c24bb8d09d518b09ae8f650f5962ae1961563b2c3c7052396c90a9b7dd3672a525c8f10ec167118559e7728da710e23cbe01e5126c960041385b0b70bdfd1282618220b030f919790dc326de8113123a7a572060e00947c8ed48a42dc4e2d1112eb338e6186f2678b05047dba9b43020c5e3b5e7a9524817b4e10adde11c73c3ccc123841154cb3d3434e181b56f977f304c2f62509ba141c434d83ead87694920e7fd5bf12a8c0e5bf44685c8077a3b042ad16f094ddd6b594b6e59b5d323650d564887d975bd536148da5f43ed23c05dcecd8fd554ce2f15cb53c24fb3f85bf84932f95b7cf33a7554efa0c5c6772852e45245c1ab15fb242422a43d7f6edcbbf7c2d921d48cf51a6d9730fc12500faa6f5d7fce9b00d39134166e3b4f653dd7a464f6909c32dc30aee1a9a7678fd324a3cb9b55e45b4f9057db5e988fec47bf5b1a399499abdcd00a6769e0ab4976183c8d6e2f6f8ad9f3493dac958389fbb8183f8082583521f9ef8e7866cba920d2e049fafa3da12547b50023345d88b045baf1eaf096d1cbb50d39315e8150a1dab84f1974f1e24137fcfd4b6dbc9893b27b187f305854a4e5930af750f9de8a1b7e1a464680df790c55e692cfcb8921ffe863b60ad549c3d440d5d54058bff241070ab82f2d69fabd7ce04197ecffe869767c48925e757ba4e4672a6b1456e3207e6f81891ca5b905e9c1390603546080f5f3d242c50a697e1d48e0643536c9b7e3f60c0def0f9106d3359cf91c05de090e896d00550e3ec89e4cfd386898f108ec4b25a7384820ba0de09df8dee43af16a52f672828e3d594c81fa56197efe1dfb9092aedaaca908f82243f811b1d957650f9dce98b1a6cc657e4331ad50b3176716f12a7c538cb4b5a8879c6294d46fa5c72f84f0f3fb06040107222c4cc0a603cbbfa1fa71d44fa8566a0af8d31aec5793c6ed97e0c0c7f168617ceacf2c8b76baf74766c5f9b1fca3d413221299de74401961827fea3f95ad7780b43dc62f4a144cf013272888a4617b5be75407f3c70620d70513d22c414f3fe261cafed2abfca0514bf3bf144b9cb096bf81a2d28d6dc630c12279fb639459a1f56d8652e31e283b5f343c948e387e6cd57e249b6fb4f738a62d63ffbbe842b8a2af54891b273d9e05bfadb93ba439d9d6153d97320b800298d95019b39d0360ec9500ab7c1639f0fa379af41bf103ce0af93f96a7ae7e2f6811da2fa2f88468d071747cd39d1b645cd69ca9025d90f413583e297b2f19a72608ff81057cad55eee2b0b694de1345cccdb16f7be61dc58c870d3fe9e85a8cb3a572cbfac4861e597a06f43cce2912ff593c2b3ce271ac00a62f14ec4e03e29bbcaa860b19299fc84e31393d7b1b5386115afc78514a63198aff6d28266aaf3016fa93c0b07d51800a7e8f7e24eed34d60dfc9258e0a86178b01e9476aa9f59da0adf1bce9999e7e813f133f3d82ce1b0add64e3c9efd047e3c62b86033a5f7076e037e9e47f0f3424db88cfc0f56d586a5f2a064555ea57a9d8e448fb612957285a546a78853a939b986357bc0042ce161aec2d696edb758146ce958df63ac12a2fff6713c405ca15c0ddaa9e4981672239a455d9d40faf57a3dda5b53ec30ff0879715d105bfd07ba59d229dd93399a45775962a3b41d90fdf57fd74350819eb7b9c80bc5d87f2402993f9d892f685592f53a428c042ddd5c1b1888f6100d7975a77e332f49722eec142e024c2ca9928447b8a5f980a16d976c57aacb67cef8f56f76a17d2b6e8b30c6cd868acaf88437679d2f50a955d15c166f82b1343d4fc8c374162423483723fe856886d7a6d088d4d068bf2ea2d35bf9c6b8516abf6c6a0c535bd0d7e0ea8cc5b18bd1a04ca9a6daba2c6d2bba716160941fbeb5aec433546b471009843e01b37a3e628fe7850dda2046d123fd4e6c6bef2c630fcb625679b9be76e10442522df14a3d1d7279aa4331c62465b211a437fa8e06473253581e020aaf7819ae5f9580648e361a81b548245889722d1f496a1924dd879ed744d1e969bae527c95070547cb2cd4a6b8634ff1ee723accd23d58c4f626e06156fccbaa4151a5e1aa3cfb8d09377f49b2a45a3a90e7d073d0103fd79d16807c1883cfe91e50ff865f03594d5a75d4e1dfb12372c9076c6babe65771edfdee751c5d21cccf0d2df2647e99d9fbf716ab307151b4508a04a9cfdf672f41cd30a0950dac7ab3b4f22c5e10d6d8be4d54f37001c3b009286f704b1d9456c0049267e91796c39f118c910bdc288e38a0032829aea3669f5171df0843636319ddc5b1bb604a28185d44e5b99c523cba02f59807ab06ca89dd446dee321fb4ae1bd761593cb590c183f25fdd9d9db088ddfb699e5631e2cdc777978b237015678a65f3c726185d19022710325218162fdf9dfc5c3569749db2b0ccfd74eb048d2d6487477610dfbbfb410270469169b3afcbcaf3814b2cda16a071158162db119c7c814f1f1819017a735fddd91262fd27bfae02bad6ac2c28827abba79e086644b21687cc4eeb6010bb1f0d68b49f6e4985730d5b9ea09c0c1b3a0fa69f16f68a4ae821d77dc779f5ecaf750ef17216a4a2b42293bdd7579a99a18e48a31b5a3d9bcadc10e837a4d4f85d749aa7212a197bc2eff08de518b4e2f50b58d1bc5ed52a6fd3dd530879c6bc2a2bcc7a76d85e0a7510fbc6d8d1b5ff6153a07585cc2cd204465ad0f78f4dfac2a31cec99fbb186b30d6bcaee9ae93424fd241dcba179c99029f17d51e11379281801d8a40afe6f5cd9e41ed8212acc500d55747979944c4b192ee17d27541c1121aeb148245032d3d2b5ccfd817b072c85d781669b6c160fe7024f1889ccf889e8cd5be94fd0b04d4f80aeb60f49f90b38843cd663e6adeb267db02fcf7c0461bf10e8c03609e00e7755afab8e1b4b8dd167adf5ed4449d9bebdffa752689af98ac319f498556d0c586e7818363fb730c7e021336497f7e932d60fcf90382ba1ee56fd894a53c20275800f400b99e35e374d41cb86ae80e3244ceaf539a6d3f2d2f92ce15d3d2f30f4bc9150999f1ce48eb14461cffd20f8c2a9c389ebf04dda6a038429dd5e5a6ca25cd7274f9e576bf8086883de0c0aeff38b94508fa255175f1513acebd8bb2e3e24c755c174acc0751565d228c5528d6c88f70187d4f06a3a6e921f9943dd53328bbd6729fd26e2aefc4ec30b345102bf46411d6477a6d4ee8b9d17f4f38e3b2af0206e01ec284915b8d41ab71203bd88cec6c7f830abcddb374c1c6c00299c448c515bfacd2e5f3de5e6bd9ec57174af94b917221087da6d8f030d888f4d9510c220f331fd3dc7aa6403b1f81c75fe834fce4baa23458e07e41e3274b93f1b789f029200487ccac63b307ce3de05102f19157eae83ad6ad6a011eca9ae511d142b845bb430481abc7b0b313f11502fdfd9b66a17c424849f0e6e7f4a73cef03a3158a277473a57dcddb9071db38810cf048569ad4b0445bc08e8882c0129105b33541d57e4ab9f52eb6146cb2afd5a1cb7001cd03432fbacea065d1c1a7288ca5df2f4848accf345c724154edbafda62afd4b8b87a8014a7e1549a89839fa01546c606d0dd3252971d2859489dd137c3e59738a27de38e3c631311a70a007b5faefda2665fd80dd46db7c0905f54c0cc5e96be67f1339ac775eb2fcf7d96094580e13d0b17671a1bbbd841c12236caa3851df20bf2f58209e649f0fe8574668741306dd1138eb486b40519fd6df42a0725eeae53aa26ac68d65e67e9a9648a285d9480e6f5b4cae8fe4888dce47c3ce9f9d181e980cc9a44609927482cb92a1738db33cd8f3b8d7bd4b09a59002c4ef1a763b627d98fb5957ad51f914399d32f2c5a0de99c0335d03b97e829f7575fcf2961e3e99cf6d2d17728e36c5c16bfdd7e47237dc0709a85","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
