<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a150002cb42c7a11d35c434fa51e6491c10716abbfb4e6442a165612bdd26ff08324522b73a77fd6db4061dbb44abe17b5e213e9530348656384a84dd4f19c026d96b43bf6dd7730f3fc16148bc420aafab24dbab5eb584cd65b8e9b3f21c819d583f0b596f0c5e6ad404fdbcaa8844504dfb046540819b1f8975dcf285d4864f0c0415aa2a80a93b964f8590a3c2efb172e39c95ce26737da197ea98b5add31ae1100365924dc451ea99ea2b07ad33b162c24a7167d664142699e6ebc4dc725957362c5920e037f472f4e7928d798b207dfae17fc8ae311d70514cbfce98de9be39629cdbf58d3bd9cbb43c8b791e5654e61d6f7a29c6c28fd6ac21269d7b8d84089a8711a3db7e2ac0768505959e978ab5546c7ec3a44b9e8f8a8b3ca75eb538a04c7af73eb7193004cd0145936a8d5531cc6b3205bdb8bfbe2443203f351051bdf2195cf375a9df605fefc8fba3d6a6efbb598733b47faf9282e4bf18c03238284bc7d081786c4c4c3b656e0f92ec963efc0b762fa7d1199501455532365e022d83099a0b9006db47333f4609090a751f32271e466b063d2123a3a18359a0a3d9ba87ac163a8d61787b3d1e80b621411ff3a298a8a02559cbeb25e8ac02639898ae4e56d44ef95ccfc107ea3f1a7d54786e977b8dfe91ce7dd52b2ff1cc62a1508685b9e8d5568207efa1fa1b2676138f7babc4892b98186c8b50beced3a02b6b458d678048d57dfeaf0f650c185ea998ff26c946dd854a3967597a134de1eb29e680df36378ee1683fa5071227ba1b47643e138e98e9d7278c4539dd65e94ccda65530103baa610494b133469cd477db41a03e42839f80db7405a46e77d7a35001760c84a24f5a72b7ed9028258de040ec53af4635a2b51cafca74e20d2891cc7491836883902382a50f9f260f1e5834791cbb9d019e833e204cbe604106deafc658327adbc475430a66f3f67849f94ef0eb1c0ae6b1c8c279ca06e75f45fa79091e65af81a60c0cc6e0e7f24f96fc8cc878f2e385ac97ad8540614df9f7b20278183e8e647d146140f1ec8e2b79cf5e298152335283d9fb86a34ad0c9182070edb59b46c7b0cb36b1b5b91f2ec183f8b12592e982b6b8b518ce2b1aadcc75dc67c580da96d10681400813b44cc88ff66635806e5953caf7d8777ff6b111f728e813f24890e31186961333f08f19c4fd89acd138225ffb68fdfcb1aec172b6c64513e768c77d01caca187aec865b5262e1c563c3ec6b3f8d9f3a3b3fb00e04a8e81d33730aac6d1c1f241f8a5a7199c6ec1f8a37b05eca50dfd11f7a812a45ee2eaa30855c3858cdf943fbe172149131286532a57c5d6c7a4bc76456a880bb8c4da94a90653a5fba287cc1e29a4832ad9bf07942ceeb629cb6867552c7f024ad3482a278718b0c17a8899b9ed5d11fa03931eb3a853389524ae0c940514b36c6cf3ae7394bb11d4f1c3f6b4a7950f0d730d94a8e28425544a8afc26385bee35534fff75b6b6d86ebc2c0053e49f8c91b7ba478b3016cee455f41d936f99a5e30201fbec4d351bbc6e012d59a798e4118377706a1affed4f7ef875a6259c8794b33a12652842680cf9a40867896aea486523a56e2beb7625907b469698b736112a52bc4c52215dafc82714a13a29532999fe64f916b8141baf7c3d9af92e7a49e337bad01b0a6f6f65681268c1e6b7f6ccb89d74dffdeb216093d1913dc627c9492318dc0f2fecb1829e124c3e9112c7681d5ad404c7560440b6ee56b54cc21d9b98afa9ee4af56f4bb1caa6e901bf6dcf0447282078065cda50616e9691a8bdf6cb07a6364c4c50214a3d1c7af4723639ec6491a922879ecd764dd7fb3188865aa349ef55abad1fdf1826c1d6ac5cfa0abc672b3aa0806e8bd567801457f39fedb52dc009f3296080c7b08ed082eda6801d0657cbbc51f5c18387fcf8f0de5c3b243b0290304ec49b1f413b1caa44eaa2ba053d79578f0a7d9dbd1853e0a99c39811ca1b17c2a09470bdf5410e202e3225fad7b364b37882ad403fe039c2b5c4405e2b2c3eef088b8e4a0b660fd53eb2b91394431d18ae63c094a1d696db747ed262e73a2d997407558ae8bc566fd80918360283a77edff471805af458ce23439c647d17988df84f9dfc7cdabf9e1aae1ab5a03b36aa47593eaa425376e752aec96b9e4489169925546de1daf00099ae5eb68e97138dcb6a914d2b2642345f59f1a886d8e8a7ed06aad56fd72c453f261dcef6313e1e673a1d6999a89315b9a2245bcd680a0669ea303ea52f6ab0e9b92bda54d40f9d86fa784a84d878fe3c4933c60a69a8afebe6e562187bec1949e770d3f681f4a7676c5abeaa59b2704c2951f46712a4fdb0cf8e5298c9ed76e97e7967a4c4af6c927f6b2c17b00b70b86d66f9607d64ed021311f2c4d57d1d37f4e9e62426a9485bc41a3b209c908bc326d40a025a08f7958e31d9798b602da0f9f3768085c6e3de959fdbea33729101975695b517adda65d1ce02939190ca71f86f44b029a45c465b705c87879eec0e203a552ec93013e17316c2b0f15fd9274e34f08cd6b7bd6d1f5b885a4b4de3dfd1d95b4519df62d6f89782147e5ab0dc40a74777112ab75ac4df1d354949244f27ce5433bd25ee4c8e297ac14c3ad6ec1f33778caae617ffd9c8a0ee39a79c3af1b97dc2fd94917f18ce07d3684191b938cad45436e51c6a3ad0bf072f2a93353918ec3dc6c4fcb013005b8024941cd9636c691a89e650ae96a716368f86a640095207ec86112ad870b5bd349901acd849899f96d408f9c3b0ce21b7836adca1d7fcbff6fc947509e234e1f41009570c82d707cf5552a4727817aff86c4441cfc4e80336187e06b43e0df2e16e3446a48abf2daad6645826efe6495700bf77160ad4bab2aacad4f79395ebf8b5b58338dd8acf95a0748976fe373a43241fc6621aeb6b517a9231974c9b67fc625014540f589f30e9ca1f3520a6fa470502616abb9b1584d49cd8d563902171310b26fe79327d340b655ec8512f248eb50addb96e5f5cb2623f0e229137def56b9af02f26b78fdb6fc4498e29977d8f2bfd75c02331c42dc028c5e3f84e152d388ce3d6e3e7b959213a97005b2a5cf68bc82d329abdd7472776202eeacc58ae0438fda942de93702a5c8eb3422b81e65388dcc15a794364adc47d3c89466e9f53e18a7ade8c121aaaa0547375befd7aeee46bbdef9636ff1c21a64a0291a8f0f3818c2bacd2d03119e1d7fff024619cbb67ff325e4b47a08093d704403c176af91cc5fe69e4fac28ec11a7e05af1e06dac461b4dfe74d5c40417a2f7984c03fd824e25efb6ecefd5c43177c81291eb1da7882769ea710fc5df9cd353680c2a061bcfbc470109a8ff9be6883e3ff03c6ba2a498081b10e34804228ea517b9081ecf3316b8cd6ff361d0997aae669665cf45bc6cf6f2954b663cf77753c34725b68edb564b03e75a846437eadcc17efc8cdd504cc437e95cbc7c5cd27c54491f247950c5d306f11038a0a2c487c9d0b373e55a77b2c0af1904339b8711aff43c24b6be69ec2da7d242ec296d379236a5ba12cbb9e59146d4880562463f6801051e91466aab430747e813cdca408b91f28b68c04bf036a2d51c5403a8ebf78c56ad7b5e4b37bc7a18cedcfdb80acb39a37dcef7b7bec3f9cd6965b219b65a22f157fc7cf3bca5615f65905061e822956ce46cafe8e59e0de86d457925758eef01d553759143b3886ff3edc7023809b25d3eef2706366cb660cb4f90c39067ec4ecb395523d5f8b7fdab567480a6825ba0c9f648000d6b20a05d9b362f9fa88002b3b122ef9484f6fd38932c390107f58e57c538db9e316714f757c96b5c1a81fe8354d3393d6697111b18838487737abed70fc81630b2ec267a49909ab9686c59d6899879bd9befd18571dd41db2741886dd29464b3aa445629efcfc66c8e37cf21ed01b1f2a501a7cdf93e98094f83953b44a70bb54575c08018c3ac3d1b37c64d6a7ae0660c830dfdf9cc72ed856220bfb1b1e1778a78c7f47b30573c4cb473c5c81627b899a083ff7553d08e73ab27b6ee310322a6b5192579b023e42794a46655b8e24eceb0b95e788920ff412c667dd057e4b16bc3aa1aff662c41fa03f16ceb0aa1064fdbe5b255689be86b227d19e5fe25cdad83778f657cccce9b00686403070186aeb8f3ba5668b1c8e8897b15a8d6ad783fb86582650385124db0501ff84db100aa6bbb836713446e5b5930fea8a29792987030d07cb6c4b065f93e64bd42044e169adfe025f7de97faec5c9effe591a3f7d1641a9cfc556f9c4c4da03c1e9cd9509d7aee3e4dd84e3b84c044ac9f46afc3aca4f01de978d70f73161c9280f61228e2f6dd2def5c7397a80044e62e3c455ca2c3c8d135f5f4ff41aa4f8f5fb51f30e7e93280f22407629e50b9fe92eeeef588d354855e8d0ebe559891d16b618e25d90abaa8152b95247bab03be7ea54e71ce6bef0d867a6442c5b633ec94c9e078da997a871f43a79e14c52c4671fc8b8e21907365f7623c8c1727235dc8f13f6453ff2afb70c06eefa07e4b4dd7078ba243dc5b49124bdcb9303d28314167a3dd072d544d741f5f5cc79e47fa2ce1944852097d9cf96017b01f4a0d9445340bbc55a41559d856d646ef780be972ec0bb934e8cafb0f503ec70c9d3ec6c6985438e2ffc223d5f6e2fab544681fe7c6c339224dcba878947a8900779fd1b2bce70324c2e4a3a782f8c38452fc75f5ee37278fee88c8b1392a176e49611274954e35281e110170bcc5c704a5b3172144cd2ccc2fa0c06408418358bb93487663f69ce3482c6ffae17fbbb9e6e214d945c9ec8bb253ed68178492fe712fe4191acb8e09bc9591b5bee8baba14e659ed16cf800d594c46af9b5d185c723222509b8f8378037b5fecc45effc1b86cc10fcbc0b39bd141eb4b650530a82bd8aac7543d0b85eb6cb689f57010bcebcff816423c90e01ca95f3aa196331dc2992a7c7f4614d868a53532b669c423f7764be9d6bba8bd79e3f06fc001a5a42edceee8bc7f744370e0ec739d59d80d78f3b27fad89d2e421f8f53e1cb807ee9411ea872d47504bcf339d8a1fcfffd8f15d2611e48cb45e2f2426af1ca54da1a2e8159bd3bb8572a8b6bee96916873fb20b9bed0018c2799bd65c26ce1752ce3bfe64b5591d6d4fe41c73b826463493c5c01585f391bf7f9cdcc2a7cb56f9f35d60debab40e5750c5f237373ed2f88c97d6eafceaa1a41fd3e0213b7211808e763dfd69f48bbb146d4abb851d62ea308f2fb94785d36b54c5be61e49df7ad56778e9d28df63cf0a1c810ab35faa1a424a080e278a953be6b382dbea02f92b3128a71f0e4a26bcf0c6fa6cb29a43bb250d36db759083978a6ce3e555a3b81fada62a83b5129423228100128cba5bbf1ac990e53dd8d367e6f276a6051f913928bfd6f16e96e313862fe34e7d9b5548657bbcdcf0303b6a41683bc1a8125e1aeddfe4923350f528f70ccd4a25eac40bc0d5fbe29cf27c5c1387d8633c77e215ad45aea2075a66a3f25dcf41e9d42ef7f4c46040cfbd206dcfe372a579c3ec8fc1c8bed5f24f7e833496c328fe2e6f791115763ae8c33b0012d112421691a7fc5c203d7966e34219576bef345f851de0f905e3b00ce1019413505373af0b9c6c847ba40bd1071d6a413a8de0d2ae3688637999b0649894630e1fab3fc5a9d9fb7f6ee029595cf31ca5fe7b895d3d3026ac60475724ee7aa78f9a82c37722febe4bac1a12e7831d53ace3c05973ac96bbaeaf4a241c993b32146e4dee6a7e771ddff771d5ed84deb76fa3e685b928cbc52755a60f259a4a5bfa35f5d651fd7cb1f0cbbab04a32159a911ca0562626a4b2a7bd04de92d6c0d66b8cf6e1e1ad69aa8c76329ddbc16c7d0bce526c9f5bbecf580cd9bf51910cab0ef340bf276c98d39f57f1041517659e9ee729fc48bf6dfffdfb08077af63507c8420b6a3cf358029138919b91e88aceb1d50d1dd2371a81d53d5dea5b3e412aea04cebb7dfc7518f960aa508bfc87b85deeec7d6eef042c5cd2573516925a35541817fdbcc0a7890888b76de0121ff597994a4c07accde910bb7742924e95f936c57000df7635844b0f4889cb71486435b06aabc2e6675e507f2f3e025cf86b87e48d09d0815f8221682f8656ccd218cca1d1299910aac5971611b9ee87addf5447ec89fd7fe8005628c376c4fa37d788f641687f36b9fb39939613f5dfb41792f706a05dcfea4d47e92feaed5d67a3627e718445365663e21b35c69c4c6e3a2cbfd76f0019b17154b9c3f7811e8dfa66fc0527f85817a4b99490512a044367af8cebc6356ecf54f841abcab17d14c96c152397ac02d3f0b7680a85cfabf0a14b2072b26601ff12225186b8b5d19c6e278ef821d64c713a5aebfe1cc22da17ae7a6f238010cdb97c4c0cf0f77b807323d1aa6386f05c1080602b7fbd4b32e8e7e0e506b46f2fe2c4d5de8e8fbf36e91a338b0924175af518a58330490d9ca2013638cf07dc45e9fa05740953aa0ba5aa620cc1eb6ba8349f576139636e5c66541363dd35e04f9d98193b41215bb7a871e8291156747ca233721de1869e2101bf6427d5213be20c126fadd46b14dc0c14aa5cc84c6f525230d92a483f28824e686452ca6465bd64a6dd0dd316e3156a342ad6d10c049272a6bb9ffd2ee77655c9bf02d0fd6db2318eeee93ba8e23087fde5300ee14b005688010f473d1e952285eff84bca099f61570ae684d7c882325b650a18a3206f9bd0bb816e846274016224ac01b9bae7dc07881914aa894383f45cd3b57a0083bfa0ae442e9b40d7211bf2b1ff45b4a910244804a9ce43c32a413db0a44b8f14438943a9459ef8f7112362a26db3e934a18d7435d6cc7304e10170d20024d44021e1201ec7b1e44de9dd1e4e6d60f5609ff9957eadc347ec4e2df6adda92fc157cec9246c2ddd9eb45ccc868acd20de9326f5c0afebd6760acd9e88fec019003fe6bf1050e72ced3b01725aa1ca543808c7a83027334b3998d2dc87690bd1f23d6e278b297657ee9a841cc95c6c95aa08479b41106d6e58c04e01f052dab25aa714b650d4ced57b5cadf42f9b2100a55a54ce9e6fea91903c7b98c0c2944be0d93ef614b53fa39769e2c1c003e31ae3b2d3f96df0439d08316eefba7b6cf54c2408287b0d7038fe329ead5228b7b88fea71bed3e82295e21ab115b6871dac6451eba8f8f2f368ca625e24dcde83b92410acd3ede1464d91ac6410634a047e297830fd9f0ef0c585943e0335642881a722631ae9ff97c8a261de6e193fd33e05dcbc9352183030d5a3572c1a305e957cf6cfd376bbdfda5c25e3121edecca1db00d95c0e5e4f64b41459870ed1aba6d9365deba872bd897e4c4382fa079de50ff3178668cbd6597569228fb17291ae31d75f148f97f0b7b3cb434bd3d079cd1e9ca8ce5533f5eabd50fd237832709428da9753a97c83fcf300e4c138c5981acc3fe39c3cdd95519dedfc47ab5275ef7782f8c4b03d369325c7c41f2ca00e3db4a64f001f35216692bb3fac8414b951013797e5a7f3d9a77b049a1f0d62a1ccdb07c881d08d7fd83e2d87cca5dc4a1530c545952f16f56df8de2963450758d977c81e55e7363f60052568772dd3109f0ca721c2d2d2aa8c7a14b424109b55464048402ad552869368f373573d208b4c208339520e877632d5b0306e7a126fda5cde65e023ba6dc6cf2ae5db325cdd9e157c9ad2824b70d296dd162b985f9eef588fc1ee63ed43f94dbc191484da78963ef5865a678f1803d8d3ae96b4897ac3034c276593c414803f8bdac095eea30364c248666d0dcb2910ecf8f213cf7abc5921dabdb353a61d3b26315349b6a6d2965bf5dbe898456f1815655d8efd3e62cdc4edce02cd511e68ce0d1b70a303bbe813bf45ac738dd86b9353c19fa1a6f56e55cada30bb3b0a8be40762dda158d7f1b7aef7cd822ce686b6ae8015fefeb0f59b7a9a0f72c9cbb3a222a1d87d8d79238e5c75eafd3ca998b19411600bbf0d1a2fe10e5daf317f688bafeff3e46a360eea9dda8a2a9e7efecb88b6da0128e931bbec8541d0ea34eef429dc4d36100b11c705ee845557a1f3facdec08a14dfa26cc28aa0e254b77369f1f7d9bc69d5d78662d94ff1353703882f7be464d96da8255c458ce6b940dcc67444cf7b623c9a7e763cdd7d66735e84f9ac7f6396559293ee21c9c0cb6543dfcc5b883a781107f6b3bb10cfee7897fa0bf643146c2aabe719a8113ffc3b2580f1b50d7a25de5ef4af6478f92bbf229c4bb8b6571d40de40d177fd8268b59e09eb8a55dbd7d5e75afdb4d897ab235b068fd52de96a09620d5c142cbc0eaa6fe2a425c3e09283a349aaf9c9ccf06a03b0506b79ce7be571b92c472bc2fe2a163b97890529fae1311e20dfa06595cc6f3340c13c6a2b5e482eaa7b539946d3595e264218be7f2cb4e3ef8cbb5e2634bf5ce01a56ec4dea5f5d4583e022b97619a0ff2b179f79922132fd760d14e41e218f8e3f4067b9df5097c68cee379c841363615404b17bb66c870d636f19cb35bb90c9ece1ef47e82cb81eb57d6d64cb4513bfe8303c33415828c4246a3a512794ee33fcb8bb0dfba07be20a6b045fe64bae9ea9add066675ae7e10572ca73a2fed3ebd5fe0ef80a85a5c4c678caf40101de2ad88d769c5ee95b01f83a06eafec2a70b5320115b116cdde710475c396c9b726aee613858934f08650a0680635bc4e674c4e4685ac1c1e0b0cb64beb7bd49ce43a6c725928b394a523ccac1e481540346c6bea7fa9e52258ba07d0db731312b3fda0a57ffee5fdb2a58628824d9527590b008cfcbcb8b935abdaba8e9c5a045df7455d3521f282c7d81e5a98b569e37e533369d730de959a2ed17125f417aca0965943e164177eadaf8d10d166ecca2558b897649cfbca556e14427a157d0146f0a512434291fbb5dc07183a5d6631d0af697f193f2484caec268e9b7de63a6e77da0b1a2716f197933eb490ae7878172c252ee7abc35d7d6498a99111f99a25891faf704567f282cf27a2c8364c7065f7faa3152114b7528c9dacf41328800d7b599dc188fee9d4ec0ddaf73d2186a83fce17ed41c6c55e1c97e293dd3c4db4d5365ed37c029a161294ddeeed7bd2600bf778cb24aeb72cafd256166ec312d1406ad9321048d3d15d15660a6aa292427013aed072d630a4bbc256144dcd62664a7a240548f6f96126f2b1097889e970a8d5951e8f6e0e84dd78bebf1794325e658d9cfea7086df2c995e09c9919128300245720619bcfe884bb686db5f71c909b2ddad235ca2793b906bbf3847cdbb36d1f14ef2c0584e46a725d99eee629dc2d09366510d04548673f3c32e6afc1a50a1af8554d5530487eff7310aa829fa4b36bfe851ac67536dae5689f8b71b524e2588a4797ce9d92a3cebbca9dff5aafd3fa6c94a8ef24caca07051f4c75169e2779d307a66972191c6894e6e8f24a6554202a57b7e5594691575807eb713a3f793c46bb2ba783d835eb03edc7a5b07264207248c558dda734965729e108d543945aa638f30551801bd56777b9ded04e11bed5423804197afd2d2f40490f37b188ddfa7bf23b559da51d37372d0870012f403e20e7966de8b41830b09ecdaa72c17ab99f419f6a4988ba69c1358cfe2200b35ee660cde3115913cbb4b1af75b9ecef0659d13407f60a440e6e04819da21f52b6dabe8492da2c386ae51851f74fb2548dde27d3db86423d16c7828633aba8259615089dfefebf2a997e7449798543d3272a95bee046959b553ac5b472d6bc0c5a8586ef065fe85a7be704ee1400e3a996fb51e0e577de6099cb84b9b3af314e45370741e56a92a54feb3efafea51af42439a83626f031cc4cfaecae403a16a32558daaa049a4dd3c38444f588a30ebf07a2850ea09ef922e417859d909969f621e38546e26a777b85f46707c299e648458b5c2d6cb103069b629dc30a2420a3ecdf9e4dd54e6199df253663e988b953a04735b2d3e0bc3dfa8124a2860f4c2c6338653726be539b48ad68445eda0e637c09fd8e2a83a05a04760fbdfef6c994147da5a2ff684254196cb46187cd1209ff9defe38d2cd430fb2651ed97cb25beeefd59c3a08d524ee2df83adf5878de92c71b8f4e968b1e99d8315b2fc278095a0d6834edc1830f7169036fcd7a5321410bdbeae1f94e078fcc4f68f5333f3741a4a0b95c03729a0cdd33bfe68d95a56345ebfb611bbf367d4089e881d16b42d834a8f5c44c392256aec4971a6d906c8d0afac3ce9d52d860d7961731f3b801163fd00184ff4f9c84adb36eb89a96a9b1ce7c77e49b1ed1bc642d3f7e89571983ce54e2343a5ef05cf6869e9a7f120034b77e28a33c1ebae07158e3a239661eb21be6b302e08dc4d58990b6bd8a669245c4da7c44bfdcaa2ec4c480b69760864e151eb706c0f05b7c5a0e4c93c2217452f574eb070a7f1803eb3e084548b30ad7054086e43a1ecb64262aa66a7f3dba39042252a54f1d56c59c773226f978339c14de65b73894b484e75cc89b9a7344a5c9ea123dcb2b9d66af9451559fba6d72f6bc3699192f8f81a0d30af9ac5b80ce042b4b73886f2c7ae3ad8b643bbbff82093deb50c7a86437414ced7ec2dbc3431998feadbf9305179e4de9133d5d947dc9b7c6f4a9b4983070210bf84d368d37dede1f18f6b295710d1e00d869692069f1d76489b3ab277e9beaef753a5aaba0c87ba1ce44a2ad7a60ca9d285f98c1726d20ac362d5b25eab3afc35a07ec30b264fe7879500276250833aeea7b1974d55745f003a6e549200226d2aac7b971c5edeac998764827b7dbdb1366b9f90ee3c9d1aef5b51a2b57e6e6b85e312731dab8264da07972732b99f1aa35372a09d697771437bc63049de4889a85b6c6bb0e8a8c3a448ff50fee1a541820b5289db4ca164e26dd81041cd8c8c1fd9b80f628b00ef7ee6fe9545f6bbc67c8549c78775dd9f322e945906aed43db18998d1c7e649397425996fb5edf88383a93fc36afc142f678eaccc5578537a6c035826cfe92ab87a3ffc084b5f129068dd403f2a07556b648d7661d572c5dcba3a957f3067e486cae91710e44770c78084149eb8418909f33b5ecb905a57e38a140bc52112276df8a58df65c408844cccf84550886212ff62ebffe58f8220a410bd4486b1ecd1507012992f4536e9c21f3512b4a4e574cf3d65f8b0b9bef87f9a588b7d9197f2713f489c0ffd6ee3f58a8ba09508ea8e9c2d9fa10d9d2cc9d5dedeb26429106922374708b44380ffb29094644948c3dd835b17c85d7095a4197d01546eef482d5c851b7089b8b5678b0a96d94db91d7aae8cbd1eedc34ab37151454644049f64ce7164759ac8a6d2efe6a62fb7460dab4e0357e2fb7b6af33c39c445782f0dfceb243b68131ec49fe4a491504b42c2d320b5caf65c2a43d2fa677bf61166909e85efbd95813b8f3d73bf6958dd779af55b301d988af96caa32ae782bc4281fd0ca5d506adfcb9a668bca961b85891d92b0bd631138b18bf6fbf0f4e1da57c10989e022e4b2df31411c8da85f758012c25585540ce1e76e2252599e55c15b066dc5852e79f919e6947b73317973603dc6ad313bbbeb4a3f01cf5b9835be805a2d97e399bd92bd3bb215c8a71bcd1a4854f3f6d5f8da8dc27aba97a649ce4812353df84c9ac43a473d2a88f71e0c86ed1c28c6d7d947c22f8439443a2643d9e44cc0606ba85e268c049316b9676bc5a53970e730989a2e00193ad8221789d27b337746ab8450d2cdae165015fd890d2ee4f59b24bb8886ab77c634ea80b80d43a52f466f506f508c6588cad1c76025ad6cec1893f046f4a0fa9088d63352ea13839fb78ebc876e414af7ac29ee3637f00742114359e11aaafc67a852f067c9b111fe11c9f022d041a101d4a15e9e09df9a3c0ab8948affb342f1135daf39d519cf67c8aaa59ea99bc2ee602d07b643dc0aa4f19bba38d9ddd9d57a7051ce9a7057cf3351d262673a47fbd996d85d07a2c65ca1010b9ae1e6935d863b053a74d4426b5473fed7d81e56c99d1a88d1eef639a294ad994ca1059de34f1dcf7e8b00183763a224d59f8eb86f13bd85eb5bffb86833fb113f9ccc5281b61f9ad9e78df47104324c2b6252cf053177f52102fb6343ad3c4fda2b0da90b2ce88a0179634f86614645233d1eef54d8fc58df35708a231cdf2101ab8c9bf21dcbf3674368b751eb1bfb028cd4c90d267d355a2d61ca1eb3e28a0d123f518f51b01249de21453f71b3d55a776ec23325e97e30929fd5d2e216b15f891e89b43bdcce1281d0c9fb5ba13c9d0e7bce4cd93d4eab6258bb52f65c3f085f1121afc78f9db9635f7051a9b67a46c2b0cf271a0262bd77d7d72c47f8e4a18acc5f6d9fbfb66d4b49fb21e7da2e817fc2c26b367a1dc188dabf99e3423666bfedefa4aeef61150fe87f6d02b06eb3a4f1bcd7d90a97b9f8a192698dd4e82a0297039db77e5c84b939a81e21a7fdf1422173751086f0f9615692d7e846740da20498511b99b1e8814db7af9cbbf3a5b80f250a740b4ec3ae0189614b68d99027cde6efca09da0979a7c9c901b561a42b6d3104a6be8497cc6c99a82b8391adce2ee0db673c04bdfae46e79ec7f6f47c3ecbe2a962807fe6cb5592a71fe52dcc7abd312a4c148d930b50a3b26630f481c5416ee0c8974b467162af71c27f85529a3be363b4cad2673ec7fb3bd0c34b7313e2d7b6a0553704f7d4842f5f0dc22714733c7ec631d4b726a54623eea7070df16946024660f3a0f4246603df4daa983cf8fb08055d302cd4408279c697991f711b982301f69b8d652568772d88b44aec5f95764b633335005a30367edaff003b87a0daebd9beffcd1c5ea3047bab5c87731a9537250994eedbced4226c2ba0cce9e2dff1126339f78fa8f81e4f56388df0f3c9bb548630541d7dceea04c608e2db78645fd0633f2604e45fbb672d9b9db7433e0eb621d0301f8108419a27ac50425c8c8a8a82c08d6893692949d6d88b1a69fa3f0c985197c6ca1cc1992322b99ab817e61075ad00afb85f8ad2705d258ae3183cfbcd206cc2ab4ad799b7cb7039b039449683f41358b54ba73a6d19c828dadfc4da6eeac7595b9504c92cce7763c7d9f4dd7131de5f2788e79dc8046a38c26a931238a8da0a391e248a6a97a5f46aa04f5072554c5afd5ca4d8ff90cc386a2013a7a69086067ac1efbe6ca26ec513c0b10ede487c994d275d36237c26d0fd36d105c0024889c1b28e5c1fe937e9c15869abac44815ff7573ea6c52427819d4232270085b2a1e52cf07510f7b80ceea57762974e70f002f9d7d613307f4e44bb37ce46f400e18429c654ed4a5fad9e7906904d039f0ae41cc4870a48d7a30ddd20e7cac5c0c16d1672fdc3539586dcf67e211b13c7246561a39fbfd6dc001c2cbc59b8d1a2401639633005bb196598fb1019e60ff5bbadfc1422596d023cefbd49049990478225dec82f61cf785541065793bea16e30e2bd3df165a6c46e2abc7b92cfd3207c2ac00ea7875fd0217babb6410774e7241453cde47ba4e735ad74136f69063b4f2bc3f25be2538ec303db320bfe0bc7062259e245845a60f6b881d0778728446ea5a3af4053dc4dd9dfea4b6e95c2c337bd785c7be53affff66d15e112d47aacf199416f182520334578632b72263238f10c1e6c407a51a91f44894c6a02fdbe7346828b188ec6e2f914e0e7001fb019be0438610d73dab3314fdcbdb259d1ba57633b49e91678a4b10bd27d0d086054cb4c978f2870ae4b0716a9e53db40d4469f87f6241d8e29b91deb25613ed5dc8dfaa3b84a43c3f8ad493dc38d042505e9f1e087b5f15610ba0c8015c200d1eb55d96e84e10dfa4f4d5f2088dc139474185d11bcfd6260858384396d1a9df9533aaa9a9c92237fe82c2eccbb202000614605e627fab79cfa545dec5b162aedf6e9d9e22ddbd14cbbc1834ddea13d3bc2a7d086892dcc605ddc863ad2ce2e8e76484045b59663dad7415833af869874f8e1068f8c5a7ac2dbf7d4ca8066b7e7edf8a9fe26d0cb2864a1598ca61820d2dfd5ee5c361602e55317169e8e94373cf345fcd2f8474cb96c22aa0c47c3bb72814f3c95c47c618ff275dee732fc4ec11ad48833e3a5254a334375c78254388d8b70c35fe364ff8a0dfbc4813d32e147f7bfd1b0e951ed6f3380dabd1a283f21505860a8e5024b8bbd494efd5457c1cb8c63309921d4823a5cf08f68dae7ea86f4d1f30c129bcc0a7f95ec2a2f67b2e45ebc8941d4abf3959ff0f6ee371f21434b8725fd17611b874d697d4b1c4901a6f530b57d628c6e460ee65f7e2de8267f699efacc929e028e2ea3db46c3f2d1234c59a0d62b367aa53ee65b633593cacbf2db32951bde914be1d0e70a8ebb15f5f1f8dbfaca73510beed2156cdfc3137588ca248bfa65e5c4ad84572d62994d496bc196cd017b5f0d85a573025ee8124eb8415f1e8caa014f393f89cfb497db89c6ef8db2a1744eec3883677c9ed8e5be99d79cea1228b3b338df2d5289394f5e077826b45f9d8b1f3b53a7c9fea271fb429ff6e15faf7d3b4860c06cb30392128e4fd4f074a960acfe4220ae1a4c9c158ca9e37170954ee3355c92fc210839c47ab7e674c6bf3002e0ccf75436f3097d1842ffd20423dc999966a5ef8e447127217dfabaed01412dcbd2964010f10ae228123a01d9170f19a2a3a589e5b4be6a78714211c7bf8ebf483d0265e223f7a99dc6e0c5e44f3122b14e22f0d9a6c4a6cbde346683458582d46989c591bac9d59b3b37d65a338ad025419eb96419b82c914a6f331f427ee6d50d201b69efdf48c3e394c84c384568c02fa11b9a74142ce87bb3ee712159f4f53af2210bd3c2b4d22710fe39d902b9d09cf088e92c175c50e17257c255e7c3d46efb4f7cf34550b7bd5600b54275a6ba595ff92e8c04ac9ca889af091ed176dd06b38d2b6759e3e95c8481207ec032c1ea683704c2310de6fef860dbbd39e078525644a026c4b093a8d6b7517e42355491fd4746c2c621e2465a4854cf2aadb36330c64e9dae47c70e145f912fdfb2f293b68036dae36457f34b278d76372f4887680ee6efd475115347fa8c6b32e413b0ceae5c2bfbeaf907ee8b29f16098227f3f690fe8f91e9af3056f86f5767272f39b220dd6c6d936a7e8418f1c97ced12ad14be1099f1932f62bd32c3c66b978cc332f852663d481886e990e5eafef95027c451975ba4a3b0e927e5fd49095f9eff4ed2ffd1826648c437c3535bd95211be5da00f62aa2d451429dc9fd34144926430c933bc843d7e5a6f927fc734a171dbecf46650718ca7442c7ca0783cd7a79277f029319855ba3c792d68527a1510e3cf3f828460f07a2fb002cb9a4837f259bfe28f3cb4c5583df88617ef3821998ed51629c278c35071006bd91918a193b8119b0dfcd7ca0a2da3adae186eae852ba0adc9c39aa3e06b3a082760101bf4a4b7c323c1b4bcd9356384c6c1aba4e5556d1b2240e6b5a319bb8ec4052cf9ed7a862cc0f3ac22ca87978e30379a36ffbbbbab1d36371db07f34cfe0fbcdb430fa48e425cfeac6cbc2459d6840f874d8c1fcea7b01f40c5623fe75dcb3f0820e117760c5137e25fdbab25980a88203743ad57c96ab9eed9d908a67c63a8243da4b7d0abca2fe71cdcd94398305f982b7ada250b4a64e0eb9e8efd0cf0bfbecc8e4e272ac9a1bf6f531f8c6693cd68431b7dfd1172a4ef241e2c6314c36b8f9935b48d29acec02a1d340fb2401bcc102de976bcc096e7059d8bea427e2d45f522ad925c75875469cd6f9e228a43b5f97a59ad1412af99d6f05b148cfe53d573a8a3d769353f5af0f48780461ded0fda76efe1565424be11f39798246fea139d60c97cc38f2bc97dc3a285bf575e4d549e775a3d5048ea5bd91afd6c80d21efe213abac0dfeb75aba1d458e19ae0282a3ce1663728d3e56fdc7e74626a4b240bb46da740cd6614755747310b842ecf631b944b64d115f2d09ec254ffaa4624721ca2db2c629f97aee4626209a0a3031dc3f4c818e5d9cb08951081fc1b6ac86a0414c3872ec808e0aab55b66e64c441d4256f38e36f009572ea9fa57ca8e20cb4008b3e7826ee581e40bfb3b80c1de1a5d0541db200658f27639cd222bae673dbc9b40c4322ab411686cb83c99e11a725d6188231411730f2c0a071759819a39f4670bd32367ce76ba912c04f775dffba3d4c42605ff4f584c2994e0533b81d721d576d28110f623875ce2a230108b4824f3a328f8fd8a1779d7bc52a46891da874fb4f1011e8dfd97aa3ba79e210d14c477997e33f793bd22d929e07cb94ae97f68e012eb5e2aa2787bc01f8b17dd25899f64c65ba38c7f95783531ad1b3bde233da80aea11350f7f202c27bdaba931cb5fae47b376c07e5e64e9aad78aaeb76db7bec0846f442246e2fe5f6ae747d00de7d20bac763db9dad98b042e6d4ac0406f830e5138c97b3565283f13fec876edb20d7f56484aa8440fd3eefb38b113aea74551f03247eb5a79fe93a8c2a20c4134e13777b010c1343379803f921ee06a938f66b49f65a6e998f32e66cd1ddd3f44d807c2218a0d70dfe737740d5474bf4f617b6f99e9ec9572c580de644be87bfd1148c89c467af993469e932cc6b170fce2b1db4d9f26bb6e1574efa0ea96c1329ecd1cf7752328c735aed74f7c3ff4e0225983a7d4f89b4dc2f6da37d7e35a52cd22c1f8c0c9df51487aa067c51352ef58373c3fb286c5f3c04d4f73447ababea4749f9fa99a1533d4bf48c7cbf6c32d3b0afa53f37517c3e94ab687fce9e532372c5b768d6967ad471926ee2c8364f05c54510d123d7a1c6ed9ec5fd7c8b341e71a95d33d00429502591a72facbeb8fbd5e8bdbbdc065cdd052d25f22b700155800201263d985da90fe1ad30143a7cf81c11f03c9ee2f79c58d4f2743489f4778c3ff77840e2c46d3fbc0ba0793ca008ab6da676a05b88736d7de07adc6f02893c2550d95fadc59e320ee23bf2af7470cc1879ea9caeceae8a7b6a276048ad125c8c8148b2af56cef7f22d0d8f54f02e11ddf1ecf49d897fada80fbee71f0abd9aee077619937cbb16f97520e8aa80ff73ab674e51fb902e09e57c22ae12498a9d26213701b4b4f36edb9af383b569b66e69f71420d9274f0058a086b12882c876076d155bea245c197eeb27270d7ab6d5e3b8c03ff82e6e9e47774a95260feb934b67a4dacb914638f793b7916fd8884a8d91c2a52599ac5b043a47f6b0831a69f70af2fe58f61245f8b782293cff7523eb80a25bb7a04b156a305a05166b452c6249318078bb00cd1834535cac8111157450a8a2c61224d4652fdb74129fc92fac945fb59b76779fbf0f2084e6b6e2ae3959130651221f032703dab341fbe29de87d68b371588d7b09fc8d2017f02af4d17b8ccdd88f6ca95c21500b3ec6ecf4806a7c7f80972a4c5b2f5505c5230ad3b45bbede76dc8221014b3d409d8870a07a6510e26b5363404d246d3625e97ed8e8855d7c9b4a12bbdd48bba27a0db576364994074126e095216de369b486555258e84108a90434ca3c1573490c411ba2152b99232f5626f58ecedc9b30a1750b886def74b192aaa10384737d148a62326ac117f1e0cabf5befcd4fae951d3fb25bb539e336be7020ebc30ba03780c5ef98a0f8cf3940033770e0d56f3f723afc365a8b9bea83a64b01d1014f00daec4c8d7db96f108ae933495780d6990f0accca79c03e8ad39b204fe078082ddd58ac3ed7a45efe98f9668f75736f20f659d6df3cb27bb877aad11416f1f4a03a02fa1514aa2affa7623c5b826e7f5dcf3ec83f76be5eba9540c9d9931cc63a4bc34c488c5e23678cd384f7322bf9900c6c5fbcfbee4a101a40e5fd00448512382b8aaf08e3ed432efc54036f004d108dc59699fd7a2168fe6a0adaa8afb83be65364b5da21cc899ee7879614ab6ad45dfaf1b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
