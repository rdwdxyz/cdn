<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aeb4e66ebdc3e4131a9866fd628055b52bd2435b395deac438f8f1612b820e370cda44a1d6c27a4a1f09982461d5df7bfb697bfa94f6706a2ec50c0826f076459eea49e615acbcb9176adb14127c46812b647bdba97802340ab60838eca2aeb418aee6aa75ed0baf7ebebbd52fb4fecd2a30be958f7662e1df63902bd637a09f0754d0249fa902c3c2aca6022f8f01f1288865f607a65690cda174b34e9dfb79d8ee1676c44c8cf0d8f6ad99bcea62879310ec082522306d436304665c94313a0e389a442afea84366ac0c84cdd45544f02fbc81f348bb9089118274daddd8df0448fca97828593e43efa6694fff69b49390f5807f7838d3f8be51ba5b9ab7786a8d55af92476dd39e3ab88dda6502b20e82e4960583bd2d9b26d05f2ff9fc6515a630cf457e42faddee1bfa0b4caa589aa49727e8123249a6a7346520284281ae80913afa678162243672cd0f100079aacd578b24f041f73386971b71886dd7d00095b38b6ee95c088d5888663f6cdfba87f05db0e0987a94719b6fd546ed6c3276362f89f519a0a56d2edbe30270b119666b1edaaada8cd9bdb6a9a7271d438f4944981b865a2df0af235716f0004f7d5a7eb0920d2868eef1e882c3b949c5097b2764e062643b9f3905ded48dfad9bebf4b28cdc305c458b476750509f847c83287741f5ea353932eaf91a84d3e0a821bb5216741f9498ed1d939751ce57dfb99a7e773a0d70136458cf6cf11335c613f1fe0b42697a6f534a70bf58c8770dff6f5b3e433488400317742150298017ae672f52d4bed8d63ff8eb2737f1c8e0974ed4a50c179ac354ff12d8e82fc40ca59a58813753492583fe5d4442cebfe54fc6df7444c070380c8bb0403b0107a5d41661b808c59ef1c57d82ef4f56e05e4a5f9fb0c8ee3e7c9d2015ebc0257c8a4e69a41b54d0d51cfa07cd45c5a5e91d988008ba07ef6e1527937a7a81d90175b7925ef4cb05c8e8649393f1259b64af430f3d16224623a37b34aed23419bdd833c6cb3480b3f8e8a2667eab702f43f1a6b26c8ef4364852210712a2e9bb66de9e435ceff701758ab7d47c1e4c4e1ec2fbcff00ff9a63d54bba513734c943ac0caebfaa27b462f44a1e8b34159cd902103fc325c6bb35cbcaace15ee9e6ec57236a315727cfcc2c6439e64845cf9c62e4b344fa4dd6a10567dc2f2a3ae7d9616ef34880c7f77d834df7bfef0e5de00aed3fedcbc1836bdacb482d1d1cf3b9aa4afb11e8240932359e701e26bc01f4bbdc8e775ceb94b3a216f1577181878c1db1c8e983ce9916f656c8ac22b284d0dc09b37cdffc510ed02e25bc133b6bdc8f9ab6fc510f92ab69d6722574824b72a86001e21270f4674b7ce449508cc8b4cd74a99c3af3347231f1e9a9a99a6430cc9ed2648b8989921bc71f5d95de60950c31740c6b9e41f937b36efb34c0e9c350d3c64bcec82f9ba7d19c907a00a723222dbc7caf64acfdb45983cd2b9e100c015b8f6f351e153b67304b19b7a9ec571f7f6c94ca1e27ca9e62407c7c3d9edbc163d26b8e9a3589da5c6d275d3b5781d5f11467f72d31a8a86d2232aef24586843da459640e8feb245cbb2b9097069e27af15dfa55fa3375137d34af4654b7b236c0ffa5c9a5006fa02565211296e469bccf2a084389b80070631de0f5b90e2f523cad0bc90777b9b6d07e0af1957cde503e01586e19cb8b6a8ef89cb1821e405248502e84bd60f78d391161a141d628dbae001c58e49d6ff6f6c0082120ce5e9dff1588cddad636ded5d0b9071b9d24fce162e2b78aca479d2f20015938a2822a8e0fbce9c5475bd993706e2079d88ab70ff99cf152711a723e15f7b4b3b101bccca970b0de8e77f223bfaee4ad73e0137780a4fb0c083bd23423f0cd52f1db1fc552296c804b5b819d5ef6ce034c9509e5785f0fe24d68ae3eb7e4721e71a5601cee874ca1fdddd50c51b9233ddf5a598e29dbf5ec605e858991593b2dd60aa4be92caad0c76d5fb78b0573a305c1b5c29f6d60862b00e59e9550977b5fd15d41927f0b9d5f3f6935608cfdce9f9bcb11c620f15a8d2e8e51b7314fe177df0775307f96944cb81781bc5200c6008c6af30efc7a2af74675c22767680ec7689699a3cdeb4a56aa7e654b59545db11a3d4afac13a02ee725bbd665f37b71c7ba4c26740904334674ecd086bfb6a4a9dbb326f1f7667d80a232a5b800fbc7ff80d5b1948ef5218fc899ddd9f2cda4555f2b7a212ea67406d2c6c84ae5e8adb6c0d2612ad1594e5b6fed609e42b30a2d01692268d7b24cc1d825896378f64f5e8f9933850dd30aa76ce7d240341cd9bbaa4f10f96d9b72c9f4360227c6843b694715f2fd763ff9a92895454490f393f567be0fbd86559df61678265c2335ee323838fb7509a20636c105f8b4960cd6e9d505d6afaca162df5312f9bbe2758069bab95cf844e480af55d03c746c5e696e64780a5f5bbc1a5070d230df2d1446dbcc2dbe4ae3aa50653ac41cf3ddd21033b69af48174207941dd53e5f903435ffa261bc7ca2395f84cde3604391d5ca2e58380f77dc269d7f82dbf565c0dcea8b1c93db118a6f5b58c5730f379de86aae0a3622d3e5de7ac53b09a85315d3b87c4931a57d252aaa7bb79ed7ae05ca59d0fdbb83d11e54c7b8447caa30985a1cdc625f700d7b1d355bb7849921ace74dd8f7b26e80785e46d54c463f707e2527d2e2bae1c76f6846b06e0dbb64edea8c882a8c62631d6cb75b6b87b6b5b6e05629bb9e2ff7464aa9e43223239a11514f9a5d89f93b5464d234dc662581581b60041515583f3e8fe8a515fc30c6aae57ff163510ee55a096aa2e01d9582ad22620a11d99131c0c67458647548eb05e3efae5f4c5e35794d1e8ee9da4172fbaeb92e611e47ebe99e74c4af7c68193ecd9b5c827c2b60b9d5a3e05e19edbd2be77560ff918badd6ed78fa8f0e23b4362b48ab759a68d9ab6672c19bf7186667564b95bb9a32217c8bb7e215582e46884ee8440e0432c7c3cf9891acd882d2035c7496d916057a45c7920db1e892e2a0fd87441028be5d2eab0dfdc273aeea3754dbf910c47b8604f32be8b1a8eac21fc9590dad7c8fe5fc390320aee5cc15002e22bdd5091571a5a53782bce2ceb335b9d876a2000d289e09ffee5d2661b2beb89bedcf417eb01613f1eeedc0e7002e9992a753ccfbddad0879cec556b4d257b413f72c00f063111a1b3e771305f502921315a0e05bc18e1e3bd1cfe05cca912ed44e2847aabf3b2a6e1358ad1f273898bbfe9fcc475a5e007267f5b4b80b31cea71ad18f32f51e3b47bf3a873cb1da4d82e07853d23a91e4a6f0bffb071bc21ea7fa4a6cee4e4f96f704cb5c25adef7b3a4e68aa1c54a959eda79b686b2d8e4c96c2d304160b9bcfd474516e368b36626a3be1f22785a23610c8e13d2cb84cdcf6db8daa3cd9584a2cbb298e205e31daed12b36ac5e4d814357d1f8b4e8eee0f44f30ea6ac638d83eb3a532d6f67eff290c6cb27f88061f5381c8d748d5bcd98f0ad0e2b6d6899ae56524f0292bed939070d8ea5de44e3d5bc45f6d9e8b9c99a8e27e22e81aecda989b2f92ec9009c29ce2c09120eadec028d09cefe1c9175f77fcdef2b35ae09e8c737dce8cf8d8fe6d6cf2bc86267a3c033366ef53f677153c76dd6394afe7360d89dbaaf42a9d1a28e17477f5a9017dcb1637a899c2ce7b588c86fc6af9ad635b64c8fd0c33624c95d26b41eedf3a130f9442ab3abb42480293cb0c78514e9f61103be96337d78f3cf15c511d573caeae7d6117eb3f1f8ac9af827bad7b454caeb486e881f647dc1d297ce97ce7e2229dfe5bdf9e6075047deeff0ef858c1f35efa0eae36ec27883ad96f6ee886e3bd77646d3b7d302bf66de876b41c01db75860b109bd40177217bae093176b164388c43768cf60d6a83a80e235f97db47e7ae9bf3b8daf4e7e83cfe6501f86d2d9661d4d82b1940054e57e76332aa39de2b201b6467750fa683002e2ed862eec7f9605d048965e803bc967d79e6509fc2e2d67a1c4947584e10f11d03e0bba9b9d40acfda883c6588314974df0bbbf63b85848aad07c276b972cffabd820bf6b89031b007560d89db611215beddf638526574d8777cec270249d4f1624fbf974d4c79612157509fb8d95e587aceda28d0900a9da3ee4df160e76bd1ac3f6ba7c0c778bd1da5cb816cfa7a8da997ce1a2d25928d97d4462ca0f772b524c5d4af853bfad5cd65867b1dd64686356359a5e9264abc99fce775db9698ca6778d28aee7517f48f505b024cd672cba9a1c25cf4f6bc5c34563a87866880a6f061c43b0c8f0832b395b72c24e176f759308ba644ca1c9fa280dcdc6456f2d430472f61a1d73a93ecef2d495264ecfdcac17a50e97f497c8d811a242bb83b967775c785aa03a04f880cabb55c1884c84980d82be2b940a6b19d7262d828d437fa2cc6c16c60165d5abbc2b99a4bffd711caaaea21527eba7a3fee62fa042a83fd24c93e3df0dc76b4babce928b491930278487e5ed1306531c565f87acfca9de97b7348db75824b51e71685184b76372455dd18069c3a887f13f3abf96cad29b89e423382f5ccee18fb6e2c4672246331e3eeeaf3e22d80083945dcd86242414f538ec9f1865ad15f1f7c2e0557b09e5f77bcffc42e3f0bd30dbca3eb1ec2a183b2a936a936b9f800aaffc96a539f0e2e4bdef4fda626f15443b8556ff93e5ae766d46061fbf78aeb5a696881adba5f469d576671ab74f922d13337254c9a35cfdb19800c979608ada4b90b7c4352a06d743938f7dcb1c658ba42b42428be04178b02be1417e83ee57187311599adcf25c0984febc2b04237027f1d36dbba5c6346a7038ffc66fa965a9ae93061ade02d774a5ee2b1a8067a110cfcbf11bdc7b8b55be67fed2679bcf7f240a8d4dd35af6a530efde1faed0cc030f74961fa1cbdd88ad2db91edfb00e832b840faa32e53076fd83e59f745f41684c346834edb78ae28e64b5988dcbe0210c6cd46ff055617230ec0a2a4b896be81b12d3b020a00900c9846010057bc33e48fc3f02a6419073b3425d084473c8ee240b8172b6e228389712e3749e063e11e59ab9cb3b6104a689dc93b49cf5a597b7aef7c31afe86f2d39361ce7284ba66fe6ba091e99527d551ac366ec6c770856f0a8b973f313daeb2934ef9ce72d54290b8140ca151f75e8ed8816cf4f2a9edd6adf42d99434cf5e56043dd9987acf4193dd2e46aa38500a6200f4be092ac80b82fcc4d79779b7b37c7dc7515ffcdcca865f7bf315c24617ca493a2016090399f621847877d75ae0ce6ee9d978a7b97412d730e8a5341a2e6f56e1851b8d85a7dc242c520f5cfff0aee2fcb9a31f01877ee35e874cc97b76de7a9f160771e3949a0def266ced9a1550855a4419bb2981086fd2f7dfad84a40bfabf1cf71ebc6765892059b1646dc740012f8a6f8eeb7a39c441f88e32e1089139c5ba1ace95e3a06bd443e23aef9bde23afc5353d560ce70285e62fe23575c4e956df0ef3963cdfd25abd70f832f14bca7481baa9d8b739072a746c94b0e600c4739913eee3804823226e0f9f8d66d1175b73388f47bd3d6a70f63ba03ad98a954aa7497268503af8e446d16b5ab8f89fd3b7e4fd7ab89177fd961785fc94703ea7af6f4bb2d7fed83eb88904977f236bb557503c851fd123d37827d9a9c9673d76773efe02fd3e025c6c40ccd955ee6aac853994fa6f21be57e808a865238302eaa44ead70e5c40e7f1f2228031bddd54e1eca20d3f4af136cfdc9f56d3e3c66e35efc77e2fad7e1b82ebaaeda4ff80e5804fb2ebb44a0b7eb0e7605820e4fe1a8d1e7ac7a29245ecde40b65e5788759247574477b60918c0939b4b149dc33a66d54fbaab8563af654dba90935de21f0c1c8a00afdb22ced00fc54f1012da9c116e1091d27de270144f3336306db5cea12a72c219fa8fe7c4305fc490b920b69423f58153d69d000fc77b13416cbaaf0f2e1c1170fb62f9dbc5a2e43894fec971efe11212a90c703e1bd5d099874603ff28a7fa2b4d4ff10db13e557653f87b41e209ad5e0681d2474c16264b8436692856443472e41e02cfd2b3584fdc815038f616aca3c01f30a29b2b28da54d18aa9d65c634ed3036b66775044aab6f2d28ac56ebbe8aa59e0cd2f6ce0cb446e0a6ca8bc257bdfbddea5ef8e9870ce8f462994c5245a1833f22bd80aaf74c09e05d301f7753d700dba8cb5d42804681b0bbdf0453d8df3404555a37b256c77df39a4ad55904f4cb88839d0a73f24de013859cc8d077362ccbbae940f4eb031824e6137ff483551ff7f28d8e5555252330e48bf9779e156f03b9fe3ca22a1b1fab6f5bfe5fab2117511050319864247f28563bf5a231df157792a20546668c3f8a27f2b718f9ecdca7fa088699e4673199a9e13e7a0328680ad94b9eb6a5ef96d7ea7dcbbf85142aa11185c076c573d1594bdd72475e5f44fe3c50baefd5fbd193cfa67bb7d1209a2bfc422019def9ec948b58a26b4d3c3bad417223a8c2ada176d803671d00f35a65b46caba6f6121f5a75d06e2c4d582a3c6de8b75dbb112f19ab6ede47b991799ca441dd0424b77ae45cd3e204b7201a32b0904875912c836e864a865110e0d2607994bb65c4defcc7357a3bb60cd1061b10c3b0145b1f376ce7984699497ed7a8802f545417a076d7f21b909b851e525e50036cf50fd791e287b7efee9435030f3b8fc128b2f1a526ac7fb4054eb2da960b07e645fd37ddb7eae23708a8ab4ba343033ac7214f7eb402f1700dd1d8eb690136919107398932cbbc1adb588a30db53b659857d1d1e09d1317e676644e94fa3c8a5efd4b4be35b9197f05edbe2db13f02584f5c17039451036676576b8e00370e7309747f1e833b520591b65d122a9a6e74434a6bd6a249e1301a86d003f1bb0549c70606ac34d0d4d160d0d42cad09c900d64ac65c1b53557279e56099900e14f9dfb097060c36f7fe3e77795bac44035a6edc914a3689a177eaf477ed5af467dae3d0e704dfa0fc0cc47583594831f2c2c3c9574428d2809416f2bc9786c0877e11b55553efaa5850ce5437d23423d496f067ce8e78ae720a6ea0ee4ab98d34a7ac6e7e08fc18fa99d2e1662448dc7729b08b3bd00b572b71aa1135f96caefafe34df8b954c1be5cc6c2eba9602b8b709cd223e5a1c34b7f7b2f278ef74bf2ca7a974f5eec3adf2ebf679b272952302a188dfc6f5e77fbfeb95e17be3f6d6e3e9f4bcef7d015c54ba3f52a83ce279f2ac53a62885b25e00951d3c9c93288880e8ed5762bf49bd7b4e09e210bb9da772f236cb2e268e9897c9bf64634f80a56ca8bf854c304b4a7886b6db3326e17aa6a261296b3d5583354b4fca9619846414d0caa441a2b7b954a04c012692ce9c7b735e6624e884532a11b7a1375c7e0210b403c57f9b58ba7b30061951284984f02c25b8cf099a2e65e7bce76653f3edd6aa64127afce48a0b3a508f9ee79584c03e1b4f97c8f5bd36c053dce0242be7f738ed4ea8a0946fc9d5a0302bc390955f7c6ab0c080eba7114370674a78a91acc61ae65559841837c366bda12036c987c98e2e59f44cf9be45bc7d6a855ea31dc76ff3c40716053045730fa04814e08e0b5c41ed472df7ecb197735e983b2a059864fc3872e93a3cde3a99095ee1886f3b89415ca1b99b44cd064eb863f60baf21f131793edcdd423e5cbce385eadedd05b35c02ef1db20239b30681065b567b99c895677da08ad50a331e6e12c28791e9a7b8b3a9cd83ae749f1c4f9c96b10741239bc04e6c29807712aba12e52cb50bd263092aedb651567236490bdc046c6f13d6b204befb60d5c5c81f21d09b4b94858b108263a7b6c5752d31093bbd3681c936135940c5711a17e6a45e42e58c2696c789939d7d62b353a6c17add30ce736b72d01780d349ec7c0cf4cb61931ec659b11b79b9102e1e7e89271656d3acf7967a5a4547ae95bb483ff8f4c9d8fe9571750eb7274378925789c843b5b6c53926bf93e912986fd75497774c2db7277f18ef250c3144ea1585cffce66970fd7910127dd71b3724bbf1abad39aa263129e5116a7408cae9c84dd72236df6d79a20dc73e829088d64574453676a7ab96b2fa0c2d9fcd799ca8a5c1d626246d253e635b41c2b9885cbd33cfca6a494d50befcf9c16ba743a3c11d62e7c69ddde76e786ca2cd58a57bc208909c37425d2d75c77c115219db4fd1a29edc69308a09e9ed734b8855c00764bfb57577213be24e8ccb2ddbd660e7047aaf9ac563c7d66a11961c881cae16d19b7f2f85f4f9fe3ecf38cea44e39acceef8209d1c34c7622af593a7a5ae59ba0ad7ed437bd16f6446ed44f189607ff4f099548966ac35e3cfcd8923b58b2834fb271313da631a01a7ecc2246c23a880edb0cfd60835e01ac9289e7b44269a15049e7ec33f0043c2d5545074f828fda0e861c5dbaaef7f64a6d0a91a966a263344bdedeaeacffb1d768146d4b9bf6aa637bf3dac9589eec098c4606ff4f7750d7711783901d1f2d7e6fc6f9fb31724d865ed84dc36d6762e05766c2acbd508a97d582749fc70a14ae167f13bb633462bf49cddd07180c0c86e00fb64b81bea9c70e4d0f452719b9207b627d6d215266d90caa39ac90059567b98f217a224a13a0f50758de82e9f1c12bfd4e4318792b778a559df14810c6ed44932b081139644d82c490c15b3f0c76a25ce5ce6910a5d433edea472cb1ac47f605e88a2b061a06dedea32be2d9c800690cf482c7b4db73cc8a6abb508b26aa9eba889d56c6e430b85e1e0519067d2f5e8b94c40fa8823268d680eda18665819f50ef122b7f19ffc54191a54171a03bbd3d762a368054ee04fdc4ac5524886007d5465f045433981dd17c5bd29856e2c2cf9f57545735e51d4c22a8640b570c50c69566cc66ae0fdec86421986a4f908c5b0bfe916c93a6f15fe3e03336bfd09995dab4379801d18609758ce83b9792aa5582577bec75be8b9112493426379b7fab3590b8f683f2d2db3aec7cd96e157a563a120f059e8d30296255bb3a6dbf33022e9f419dff41d47506f84d9813430d2632710d321aaf193dbeee20923b7d02435045f01c951baa788de115b1c43b452918d1ce6a69db521d8a0827e75d05e3506adf407a2e73ea10cabb4b8ed5042f663075278720d10bda1ab5d62cd29888fe069b9877fd7290746da5676d35e2bc5963fc3f0cdd04ef102f44c1a25f742016169063f4985307f7ba8afa3a5d08e4e39786611c969231b0d146edde684bbb7e26082b2d67a819b6117e6714e852b1ad45cddd4a35936e20a32d4c1ede2d9891195db9281e17005ba0798f47d80610ee0daf0682b94621959c487027d4d9dcdd836e4b17067e2f60b2f45232cc281b8980dd7f511a8f9b3969ea9d5ddac2f2f40432371c321b661d345bc80ff7d911934ef45f48853708854d76398d5c8673fe74ac1f57a94068fef74477b7350b6f12340314242839b9aac5f642abf5376578c707955ae2cf59db517437c2c5caa2158e78451f53536f79292ce47e04579554e3329ae55340bf254fe8f068614d513e41e94fe95a548682eecb04ff31ab11367bc71145e60ab5a22491d33b466ddc47309bc886f389ac72b19df5c652e730153ed16f9cc27d8e2f7c7d3752fd6b9b9d859559484091fa91f515572a6d2189c88a98916fd660cfe6ed47be6eec756a0f85d0e94b9127a3dfc1619a763853e3c8c952a858b8e171853f409712270db9ce4fd5e9b465d6049e38718286c462e9f9d8cd9ac16b619934acf4b6f149c05e7dd0aa1a9d389ee5f3ce864ae042d621a24527fb4647eddb956627b161de4450149257b1970c0d0069b7145f7d20fbd86be38145fc10b1e09655fcd11a67552b8a0b0f022dcdab3112b12567191390308e803245905c611bf593bf8c3612b32e7b14e0a055fd59b396123654da8c95bf87f3e16ead6801ed5b264386e6c00b06970f8461f7d17a76fba01a4fccb5bcdd57d9586d14c1e95ccb09717a554933868ec628ec220d85e28769f0280646cb57b2c8072c9254483e8a5760972fe6d0b70b400c76d8eeb1f2f5a9f6cd885b95dce128ab187e1e49d2338635259020ae98f029083bfe582231915cd5d55840fa0b7288a5f2285957a87813ddd8fff199b5d5071d9f7359895e8b4607e779f19775ac01135314c3149f3844dc77579732d19ec10f28fe58ee5ed30bc2cd32c05327633d75cd37496e54571d3f2656884d88a402e60a8da4366586c7b7f97df00358993a0d043173e6cbe393754de5f2b7018886c320c84240ac99943a52cd894172f0ce1586d4545b4981861f1112f9ba3279e083aeef90913230864e6d596894ab69c6af4b49fa59ea51ac07346ec44a0aaa40053e373cba91d31d8a248d81c39cc1db6c3348e8a8bbdf83b5a6c1c041568ee2a1188f477483a302afa1bb97c28b5cc27eeb3051c855686d3029e67fe3b0e5bbcc8039e03b154aa3c9224934722e3050b983f93d28ac07ba454bea112a373949523da840b0cfd5f5cb4dd65d5aab980d03c7c3afb1772ee8fc68e2e2725fb3a4d78de0cd9ad8c923bd88bf3b5b3ff5bb03ef834e7a534cf5067e6d877c98ddf87daa5cf8365f4b966ff6167a672cd7176006183e3389f79ea8dad44990120617cd21ad99c84c9f997bdf3a241b59c09bae60dbf04322bd39747710ae8845b114aac1784137f61e5a5c629dd0c3a66cb89328fda627050d05ac4ae8952c8781a4a56577e1804350c28a2158fe65d61d8479e21cf25eaa777e0448a02be4ad1dfb5e0196f936fbc620e45c2f2a37a382dac1719cee310630c2f339c647c5be16103145653ea7c32eff27a4bd685c22427b544a985b8e2e9631e0f00ccccee2c5d3335c07ccd00a205377f5340dc68cd92b670b6747cde864f70eba23e2bf466333a10e4844f8409e9066eec9fb1bd0a4527e5b345a6d14390fc19b4970cab372de28ebad8ce430c93768cf17ae38575e870543c96aa224a8cf71c8096f9d484f96ec0ce9e76200ee512165233e4ee8e5fb9936ea1ea25d37472492fbe57acd30a789fef727aa468d822d825788c8a2052ea45c437021ccdbf7667d96bc83836bc66637095c714f2f199fce892b58f5fd64f1a94e37a59822d9f62711db7e9a5b207e6d5bda5c1f54e0c00068a56d00b669dd254b426f8a429f591795f7e7129b9c931c8b90a706af65d64c472984a91fbdaedbf70f9e8f4c009c89f5b711203460d6269c2aba920eced6c12bcc56eea7a1f02bdaef25606be7fe6b3360f8480c094ef673d1b3a8e3667fd2a14e03807d2138894f4cb021d41532a98a7914725b3a25dc1ebbc85d38e3e787600b80ad45351a54a592e6fff26469d2fd7766af8027020521976909f6880fc2c09ed0a66af4fbd76664ce69156f03f9011aa3904e20d595e41a3f748a457d175b647adf83fa2748a4930c318a36ef975c76f820247a4f89c9ec5a6474b9f53acf68cf0a79a3e170327f420bc0a5ffaa5de3f1918a73e31ceb6a038e27db4cebdd1a0e3abbf27b26a311b1de4d817ebc7af8641f069c6b2808c6aa2457c4ad2b89bd08c18207388c0f79494f793bbf936ad24a83a63c3fdb9440480725093be4de818e54141dff45c69b87ed1acb71c491ef6935601bd599e5befa1fa434421f4c92109b9387c0f4cade4323cb6e2ebb41457257a5313819b5e5c4c1722a5a5da2d1a1f83c124adde979855d0e29d08d9722a9832e4e4321618b1c2c7225a0404436e6405873eda0fb1d3d6254dc988a88eab5b1bc195ba88ba2af31430521ac26490e79dcc76fb6dfde7e682e9e1f35cda9b7552aedb9af152da566b87ff1fe4076edc68d25c72c6b3b48f00e1b307395d3b1463e276131dd4cb9ea4ca3ef1ed9a0a4a0c486e9ce9def432a592593320597c59d4bb8bddd3c8b1bd2cd576a66622464375006995c76e9e60a445673c9ea66aa4eb46d3c2e47dfed683aa08dc68194ecc05a59ccaa8b732cb0e293241af6abf17b2337f677a18563086a8e4ef193bcfb946bac70de226af3dfcfd1987562a437c04e8f1a2f9e04d95b712f4ec4614a87e87fa6741ba88fd2b23e1d1a1ca523d122a103bd05ab5d96be7d491462dee5caed6b04f88a35984c1a6bb95a90b17c99e877f3efc75c62067efee91ff70c7070f00e51e90840f29b7fdd0bf03a93fa536921da9c35e57b505aab188dd6c44bd6e89a24d13495a0be1a2bb53a7aa3e6efc842115b5401870527c94d9de5698c11071539338ba1887a9aecac573b12267fdcde1d30fc48745048fbd8f4ed340d0fd0109ce317288225ae70fdcecc9af6725e27b221ac60223f9beacdc031afab21683e106549e4971fc1c216f9de64a9d6ba7ec4a30493d9f2c1fe7aea69cef57e67239399b576e26b8dca950b3f170d3b4af5912979823fdfbb945bb59960ab0e0d282e6bcb90c890efe30d74a2b4027f6bb9b8e7212b1717d8c91dea4732a1b5324353d48d7a70ef2aab2865e36fa892d459a41307dfd725e38cebfea6aed614bd48ee04f20ca4e06b98dac140f239aa6e77fd135a284738336f2741efdab4d6b180ec54edafef036067bad463e8c912da0743951cf4d73f423486dbcd3c91b3addf4ce53df10b58d3c080e5ae0ba0cdd0b6c87f40b2d23769cc34cad673a54e66ac97cf7f214610061fd335723bf2352d7f6090c3cc96152773b79a24b34435ed181024e4557480c56e9570e1584a6968880e39871704a763c31fb596c45a491066906c4f31f77577502e783a4f94b7e228278c12d48073906400945605e3d32fdc1ef902209761fa5d9c79bd93e09a47d9b89ccfabc226883512e20b161ade6f2ede498d34988015215659f52f90e30c6aedfbb03cf869f253cc7ffe596739d73befbeaed74912e0ff1a9b99cd7c9962621f13afad36e1184032cbf02910ac24bc6fc8f02a5616ae0b87b3da731d6ebabd2ab817969b58728044749c273bf3640f7ab30d880880fc5bd7c2a9cc2cc88cdffc8678f3f5523c285f19c424aec6b203b510365cbfd42faa1fdc0fd3ba6e339948e2190ec61b9896816559e3243d6e52d2c10dfdf85666aa47149c7823d1de7356233781b94346ea2ae2a79f3aed72125b65c9679b7f29675946c75cfa88bd1a079e4eb5cc774f7caaf0320334fb4a00c30cd857a251f1401df19b9090094ed2e467624620e2b863fb1ff1fa881796e536295bab693edd9336b5d1db8a6963e3831dfd42b2922fbf7e1cb514ffbd5a78ee294727555ac2a6ca283147d5193ed1c83dc2077cc2a0a8dbecb8ab6a4ef7524db8a62a7495d364e8057fd7f4b8c443326bd43bae3dfa875fb83f5027e687d6b78a5148be50ac0499fb212c51aa3542ea4451bf8dcdb01d011213b414bcb7f87c02a073e71404406ff2997fba3c3c077feb268332aa743d36341e770b45b040084d6e3f2cc55df31cc696d42d8a020254881261743f1c7524f52696a016c1d6fd845fb9634adb23e94f66b4e1cc190058a2682aa91bdd52584c7c9c9e405745c4e322534f878121c0b780d6b82b434cbb1248b5e01666e863fd54098d43030433fd653c8c17a1eecaefe93390f96f03aa3d3528c84b4fce3827ac4d54483333b6fa8c86c94ca8eee01ab1a61dfe55196238a0d829b45e16eab42e4ac431d88e10ba06f68f029243f118e2f7ced9af9fd025db0643db731437e7ca47e85172e2d71f86ef368efa785c095d5d6d3ccc7027e1acd0c3834580192dff033b2fcd2ec9a56f439325ced406bcb7655780e32745dbc0a75f0c78fc444cf6404b79364f68609c925c83be39d0a0ce21c73d66ac86ec278deafeb46aaf72bc962f4e8a29b2df3bd317a82d4973d1650693453d6a9d8c7094667130dc4df1ef5a0814cf34fa0fbe263f3a1e14faa4321216078ccf6dfdfd7518da02d7c5695236b3a4c560ad57aeca8f6a16daab2d6c4e559fd9cb7b445036c1f61b81331722f31da0abc3e395a079a11491bfb6f9a1b07c7d1614632f3d8ef140362b378ac33982877460cad0a94a708535d395c3cf21ea8147c8c9a73e7504a6866941195091e307758b9fe355c391e4e65f0702ed34b3fcd803226bdcc2cc0509f288a3430f60abffb3d44829dfb951004bccebb1307b0570a24c023d7ad58b9af47c8531dcf7ad503a6847819fd543e2d7faf669029a002ec029173138782280f6c3a322f0b0835bd451536c0c69f044b71f03ba4543958da2bcefe7ae5730ab3213fbe0a4646432b5d487f2ce34ad0809e9c12e96c6c379cec0867661ddd9cbfae4e3349809a5951144d4df3956a1b8a70e7e7953a6657e7022a044b5e3e6ad091e82c885fa8ba3a73844604d402a4919998239db88375fd71113ab0112b51ee242310994a8e8d73b0d50d01afe80bac98fdf530a88d9cf5016a6f02bda32438e55a52f8a2e10cf5680902cba99bf4924244c7e7f0c66e54685db092f6c1925e9176647b3b9ad218013de353e963ac9ab117396b0e6da8fab4bde53c87ad71ecd5517d2033b97aef7a5beec50ef5b958142d3d255178d385437df9c4acb22003dfd859dd934dd58cd7856f7b255bd1d42b5984e64f0ee2c27fc40d70f866ddeb459f3bb6ff3a3e2d71898fe66257955cafab6edea6bb81be95691cb9f0a6b6ec9b446e5d6c00ac35a99a704db8587d1a87543afe316f3db4d9a175dc9a4cd2e442c1f159c35437d92fc1de494f81e1fb4a4f4eccd4874f40d175813870f531cd7bb3eed62a75867469de7e651fbabb19ff95587761e4350f1f0ea97ec85f0c21c8e0d73fe64cc5a5a443ba50765126fb3be9339c2512dbfe1c401159597549470a825ec2c11593e7fe775f76f92875fc7fa52170f29debe20a342376437cbba1c78c7aa075fbfb53d2aa1cc8b372d27e013067b4491a06b3b417da3f8df64f06b6af3a2ac6f40c5c7932cf074cf304830c6ee326e835ecad62095810a9eb6b26ce1ee49d47bb60b4cfc26303efa33953f9d40d81365715a0e0b3c264e3ac5a6cbe83d04fa66544fbf08be4b3e4e1c637f49febbd18eca64634b3f58717887ce4744e6fd366c940c373ccb9c95bff532bc9484f5a9df6830ac9df194990e40a9dd4489aff79d69e56bbec89c2b9b04ead802bb35b0c5430186ccec8b3cd44fab905ab223c24645c1b8af10d403a4448c98cf04aa69f1f1972bd5f637c7b034aac94b20bac7b556e3ddfa3708d1effba97da113167387dffed88658e834aa6da8e0cc3b9bfdfc200646e9b684db39501285b60426b80609bd2f86932313efd22210b3eb50e7b23db5d5b343ceb7195a12e1f974ebd4e98e1c83c0b565a2004b6aa0ca46a506054293ea50c845e47a38afce853396b974567b9a2bb809f98221cfd5a96b8c3d084d1a6d4c79a08db5d0180a0b123d3e9efd63d81d0b9ce900396879377083ab0d0b55cae494ee44f58bdc5acd4377e55841615091f8f95626c535962005d3f03d2b3295df89a80d1f0630baadc1bedfd7efbb23af830c15f551f4a9c1ca349d4d517e165fc28bf31b463389d49c3f2e2a8c6852d23b13f3cc412414e453a451cd3a856ceb766406ee84343c3d02b2f21b3e3819e6473135870afd6b0c1966d774252961d38369f8586bf807f28bd8cb972af2886bbf72e7d801491baf9b5d7b52b251bf2dcff91d1adba92a353ba2145be93acfbaa7b16895f79e506fa9579a1dcaff3edffbb6defd932c5cca0626dc006ea86c83d787281fc722373f7e22079ec5fcd1417e80cd0981b79f5e1de8a2fe3027807fbdb1f9aab59455e9fabef4a55e9a9c9d1c9810b24727c05c6647799650e4adc49f3aeaf90666085d02a778996cebf65d2a10243d407b4737082e516a2de54a75000df4263c4f7305e4d6c64311d18aa8cf02cf89cb248110d4438b4459bf4e9f07ba8a26c23bb5b473bcda5401eafe2583d7b5de15f5fa959cac008c106e55710ca21bffec284d15f1f589a4c2872a4e1a75b0cd75ed1138febb479e91a65916435485812a1f019d2816c1ded3d316dea51641bb7ce31f4c27993da083098d8a52d4cbd6b3c17aebacfe5818fbd5cd4461dca4035efaaec8d0054f1523ae6acc532082264d20c3244a07be449add7d12ca0330aa63380d2287305444a4ec06a7f15c2c8ab02cca5c10304a930335b4e3c9b98dfc08f92c544e43a8985838ef373b4b440a4275329f2220b2c58fb0bae5738d1028ae4f61840d6c973137fcf7ea88aa1118cc558ee288c251fe3f5528d6fca8833ac401c5925c03dea7e594a7f38f024288a08fd76d2ca94d49f95c01d30b089a641ff2440b5098dd4bdd720f4390ca31a8faba7a244cc447de302851b149ee5fb09e54a7ce8cb0cea665f435e807cad3689fbd931cf20a80a0faf49c722457351c1068efeeceb93a1cbf944fedb8ec683a23d87005268fa0037fdae39869633db1f8b32bebc3581a39f10bb571f912a5ebd04cee21750afa4cb45596919c381f90a0acc1be41e4c86d1efd8680d8b8a67098c55b22aafc99be7c88106037efa7975b82da814136381b4c2f322725dce3c82100241fc3c2881ee1817337ee2fbe06868af80dec13be88f1d9bf8daafcc6903b1f2c78d5d5f19217cb3a9ed47be1ebdb652c9b38c78738b18fc43faf83c270e822fc50f1ded3f1111f210a36a264cb8271dd28738aa3a96a0cd7d4e3b0960b9d6bcbd938541417ac220dfb8ffb9513d5730ece2b2a52c772aad33152185aea52dc8573fa901e39404a9b40f1df0079e42af2e4b91636f6b25c752e01db071d6027c8802f793a5a5b38aaa56078819c1c32fedefc33c19241d10cad686561bbb57243eeeffededbbdd2683f6ff43d19de19da8354463799bc10791e36e386802fd5e15b44ffa10829e133855c074f7316cfbbb2a3d19cac58f548f4b2dc44ad668816f928c36494eafdc880bfe3d2ae281789432bfb1d7941400b4799e25ffb92a573390a1a93790997b018e7be1e809799a7384c0ca9cab80b039ceacc5b1b4a8b56a686f73012c8550c585fb1d995a6509ce6c7efed177700cb3c908b2b1ae007ff7b9ce3322c18e34bb769a8d55dbd4ae81b91c69a93ffeef91ac9b62311c4d645fcdcf01c08f829701d0fc3f912f49c49912673eabcf632b8a7be87ad8f94847aa3bc1f39e9b75c1b4d67845eed4b264e72bdfc63a4017a4709059437b6ad0d0252b6882cb8cdb5b06956c12ba2decfe01fbf4eb527d81a20d426e2d1cc37ba1a099818b9942b581b3656b452c40b4bc6123e603bded5e183d29823c81d0a38272795330d3af68a1b372285c0035cf5137de502abdc9246683cb98428690d6bc8157af83618065122266afa06bfe4aeed1b1a9019dcb14b8ff0c823ec4ec81804fe58e40a4aa03250dc115fd9d4b0fef96b74853a633a3d00f8a197cecb843c22d25a542e68cbb477ee5a9fe691c13d9e5a871e432f321af92476ce9fb9e9aceb407b235e8d0b9b7fe1717ed85059f12f3850bd770e26b37816a7f974dfb183519e0a60f83cc49129c3d373731c4f993716237f748a0c098a5072afd2f3123979db52342bfaaa9309dcf6d0c429408167bbf8bfbe4b6b84b914e2dc644472dc721d93f244161010d2c67aff20d29beac2f95bed5c4897856c4d1c39254215c2e294a5d32a1576d4c457636961268bc63658bdbb246b97c2ade87a723f7a9beca585381549a84cec32d79a56edb4934f102f3832e4055ed6f7fc7ee96fe8ce098ac116adc9886ff1391bb309e76fe1804b70ded59e67c7b26fab29c8f8f529e2a6e43c4e22ae0387b9555114dcb44f3dc1042b13c638242d4b8bff846342e6b595864eca69f010ffaddd50746b4b0bea5beba1dba50824cdd4b5cfaba7ca853584b241525c5a7cf96122e6e98bde9cbef1f20f1499903e889b4c113b0430469bb1a8d5a5e2d3c0acac7d6f85e1d02cf5178de8369c35bc8edb142740cce0b6579f39113788e59dcf64e08b46c9ea4e888578547ca61535ef298a457","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
