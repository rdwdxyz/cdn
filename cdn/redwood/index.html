<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f1ab631659530c464cee311667842b2ad56d73394f080dd216e233ec9adb1308cb77b176984f762cd4eb59f2a93899c584194d8aad8401d91744b468a7222b662c14dbabe9df77179d7d5165aee57e86e60970396e5fdb781d54731f8756abd59decacc1d0b06c8d116025ed7a179f5ee91684992c5959c1120b3fa2675ccf4acac7eb1fd73ac02cf08e53a180f4ee9119ddf88040360b5e6b08b63587682efee9373beaad74b3b61eb79030f4141019e7c3d4080db4a14a03f10376a56a518cd9fe4c005949a6164c909f403e905c7426436e07247585120a3870c6b33b40c36e6dcb021bbf957faf0ce5a7642cfaf0e9d9f15d51b777b34c67fb7f6537c501cef2d3086b97f39112445cc582f44e1ef20368493e002e67b2d3fe25f8749dc4d1edd6ef193602dd7adde325656195bd855ba0ae0b4fa9f5aa48b80137a42168e2dd0a4c9fc823d42e7810a800ae0f7cb744efc403417b85b63dcb97d3e741fa27ecd15f99220c7dacb33bc80b1beabca50455a10167a657be669eea5f11c0129fb8f2352733317b7c3c289d5b40eb1859991405f484a2fab7f4c888d73e797b1a182b8bd98accd0a6a8563a750a23322b3dedb3e6c41e0c034bfc72b0574482582d0b9a5548ec3625ee2ebc6611a1aa326b289575113c70ab84da7d54fdfaf312bc5732c26384de2ad790d19b71803e0b837e9baa79079a643b814ce67bc754f28c12cacb3e83c0fe4515519ea9662ccaa46a1a6b6d03282ef44b811176a145c76f79fd760825bcbc960370c959ca13a237c3d0095db4e8402d23385367d1bcddb7e2fe0aa6bf8851c1008a3c375633a20d7bc5bcbf019fcba2a5fb9ec616a553fd99dc6f519434e269140a3c6eb7cd1b3c0db7b901d94fe4b3afb7648c6375cadba608531f87d16a7e2c730dedfa81450f630be84ee2ef406ee58913f8534241bf407a3b1cdb811456e03590d1acfa0020b6fa6f7607c653b0e28da3365e6e55bf4e4da6afe936d392a5667b350e0ae6eca081b97b8ab7d5c8f6d1820e991e41f6e51c32ab0bfe1c9ca3fa445586e2a7975fe741538941104b1292874d95ab271645c91a861e486b593c5576eeb7c9c4b78ad12ae5e2fcf8258e3c7a42fc7d2ef1a05cf75e193d8f345f2570719a3bdbb018c116f14506a755b7c9764e0c8a382e232a6b1609fb8c0e14f90b40b402100822353cea030d12955c83aec83a7685c528692ee101db82f2ccec8ad7707067aa1f514726c1a6902b3484c5b97dd394cc6ec3ca6891758bf1bd6a4ea7742694cd1ee8d593733a0b35ce2880214836280d79a9456138c39e2e033f437f009dbe52b59a2aabab9055cf3438c02820a114d51c09402c0af6329b514aa82b577ca048998ebacb9c6a4f6a288169ec059f83473617adf908f4aa7d678cb8046e5b375b1d34212c54794879e4cd123f148323de8d69c84321f9d3b947659e78db526e261dd07376c37e26d1c9ddc8ab2066110256c16ab1a6c3b959fe701d383952881ab06dfc488e41e851bf10824765647dd454b86922f2596f1d5792f604a86bf35644dd58f6cef4c7e5400cc6828ca87258254eb4127eee4b0538f4d4fa3d019189cb9200e639953f0751b4c389a43f4cc4ef4afdbe02e0c43690b1a4866c3400fef2a9b39201515d637a2f23028d2e9e65d899a8a5a1656bec1c05b1be52ebd3d42801c11fb78680faac44385aec5eb83f1a741910193c13c60c19c58fd13d6a4fac4a6be12122bf6393cf9cb7564fbe09643d402cc36e756274641cd339e5d90bfe45fb85ef9457dfcdcf8feade317f0ac62828122fbd47c54a2514fffefbdd417f086bfcc2b05c30987e71ea9b74e74a41e73f23f28b12011d1c3b9507d35d508be167b6b1fbdcdebb566642140a6f15f8c57caa7a2a3a1c33511bfb02bf928130e4d90c5f5e86e874bf5e9f449fa4e7dabd9c90ece70144f05d2a4e3a78ab2042f6bf9a2e7ca0de873619496c3422f3900ced066d00a31d6c1342cf2dd9ed6ed77e272162491689d386bfb0c6571b5c7727bc4cfff6982fd5ecb08df0994bbba78e1eaa2ff1e1f2bc5245241ef6df791fd1435a4db5babe227ee4a93470a91b0d313c259705c578670e7f1dd63e7ac08ed6843feb12a423b077603b7c76decb5e02946bdd3f34cc460d32df0fd82937085b5761fdbdb7ea0be8b9cc2c760aba2e99221043d7684f4c53044d189f5e77b247a6a476a7c0f870857d1c5a6ad71dc61eea53b39be691a41dbe1e143f06444b5a72be9d8bae6d12215101eb17c3168dcb8a66793c41db8074edc9c445667ffffdedefe58f27cad9c0897d9fd0ca0a90a60cad2fd70433b3ea4170ace0c21e421488f5f0f265855db73335eb0282f4b392ee5d668f34d1ad4da81667ed86ebe1b42b64e1d46ab980af0a7aea0305171fa5e01235d327eed995a6109fedb3dbff54cd29a71a1394db541b82320c49e531fa52cf918de7165d683bbd1d4355bfd11e371b9f7fca22f5c49100ba243aaf61659051d2490c8de4db5dfdbdc780e7b9a6109ae87b59413eb71bb3483b6130b25d1c46c18b7e1e6b248c370ba66bb46abb82102ee895cbf2b3be690234faeb69047a91b8fe086881bb7b03ffbc03da7ae123d176092de7cf56a835665d3a29e961e7759a43dadb9637ce78a152f64415e9178b1c8b523a1022c08485522e4ce0c2874850eb6e92c4ec0079120ec47745491a85290e9e972a5f4e6b27cd9fbe3b86051d16ab74e643f2dc07eed61d7c253816c7fcd1cefdab6db9a907a7e4cfaf55a86d9b96e0636fa0318834203dfe0c9f4def5dc1016414053de110aead03eff3e5dc98e79bc0b46ddec3a0705ab5ea3de43c4679b21bf62882ad9e2d9feb6bb05a9ba206cfe171627077b89dd1a6cbe59142f191bbe056073eda9176cc35f303ac10a72c139a197599a9755ce5cbb6ee76fdbb438246603f647a2632f2993fdecf70e4a97663f5d291324d7d658deacf500bec9d1d55e02fe73584de16d4a59085b62542740786260d82ad3f37f786b0a3471f159d1f13fe93e1aa30acad8234f04b7a3c76cca23c66898ccbae9c244a3eb554f38a6cf18992344990a5b14d81624f04344be83862a598d4661e9a4b30e6bfb3480e8b5e3210c9c095c93fae7f673e142197369afc53f9a7e7bbd755fb9d2aafca17ec08f3986123cf333145442c1635504a0ec2921157016a15fc9c8281542953ae5eae8e20d2a3b1e47268fc18ac202ccc9783c4d0406172b9fdd6852a52adcb19aeb59a3f89fc0ccdab60ff89f5b60beebe2e4040fe5c34d0cf8724c6697c36b9b862bdab3bbd708d0484dde83ef45e8e7f4ab35a02daec17eb6e49ca7554e922a1cc4754f3f47b8e275a08b9b992760dba413d350dc133e782ae8b201494bb4f436194752527fe0048dd0c71ab66227d4f73203bf002988f7221b6d49fdcf868343d4cf81580d3eef29d475ce169086f26cd7b75835c2ba860b9b97988077ea5a14fe9e84b84a02baca199b5f53f188fa36b02eadbfdd45e01c9bd697c280deabae4ef2e8d1f72b12c5ef8a2f9c180b78abfb56a33be1afebb6e9f7733737746db6a18fec49edaf96eb40a965d47b76ac5c38f29d30c794a67b05d889f8c23004a330028ffe4fdc34604c3d5a27fc45e67c42afeebf7ffdf41d3ddb8281237996ef443222a9001edeb8339a4b7f270df649ab8731428c858f4caa167b4fd704e18bd6fd3edc04650e3bb99805af121db2f1eed3f671630aacef87631fe9e7b4c263c27b5c6a4098269edda2cd3b2d64f2704579f82d466454d62f0aadbeff0c45bb0f2501c42c1cf0ed593122d7ea08b66988b97adbb868bbd05446ec7d9e50dd6ec5f91776f56d3534f17b538b423a500424c211c419672443d96f5091c965e9332e0953eae64fbbb4e530f30a51d023ed663b1696790e54fbc50080c44e70e8afa7e439122a4c0ea57f2cd2d60c7728475b4787031fdb3e946fee91c3af5609074c15aa4e5d5bdc519a22e83aaed1cfff6af3a058e33d70de9f46ddb7b21a2aaf6be33b83d8e642bf6d011c83792d425ed3e10add2b59a0c2cb044d651362d1c2ed97fa6e9774ec2f595ad219c6a7f11e34b6efed488be8f8434d188e21a801d0750f6a27d70da12700f164ffbc6b8b17aac68bbd4a17f2e2b333e173cbda3b9133d5a9a6aeca8299351d5250cafa2e82a21c93e425d8065e6983e612f8c537133674c61ba284dcfd377cc3baf33d9fb3521063c4de034f3ab4032e361e71953600521d93541d5b0555674adc686bb2de01f66b4194d09a0734b81f518dea769b80e66ef897e0f4a681ba11da8e7f8a2e62a69748ae6615e4c31b5c1a9402f7bed11b5f1d905a6fcdc10726025c665b71226b7fa2a63b412ce4ecc776738657db2df29ca903f587fba70dd85a9478165bada351479c3aa4f585b437adc1cd2f2348e274871af59284c368b05d7f67c94a682cf869f0463cc96bfe3e1d50c08b0eb24e9cb255ffd7152711367d2927b990a536c978cc4f36757e48fd1dac9c94caacd5f99c8f8d224c1d06bc419c9e4048a065966ba129153e8131608ee1a44c941f9a7ca74379db583cc25b8fd724d63331260268613e19e3261038ae8e44d799af97c01fdc69d1049f551071ea80dd9f65943a6cb1d0067f448acc3e2a180c43d206d1e5035d35b2405fd0ea85d60a2f1798edec5e95c4132c4b533cedaa8444f9de33259cbd90483bca7ea6a6249c38528e8ef1497e69384fa6cf298ab27c25c524c3f9059491c635a3a48af5e3dfaa48e3d02fdb28708f085873383545495da5da7cd4deb6582f39b060f2cccd6073ca3b9a7f4951218a97058027188bbdeb6965ef90d78e4df6442d00157e7f59c8bc21c8473fd596b4cc75d48e1d5173e99b462ea84940ecf00b6ee3af1a1df2f4b0b8f180d7c380954d15f4103ecd359699b0903e79cfe417229edddd510e2a59e91707759363bfea18acbae7a5393f9ae195b00ee72ca7c6c923a73a4f75ee2b26e8dd6251308abefae2fc270a563ab23e194b3a6f8b64ffdb82bdafc0688465b00b51639ef8879255b0190265d0c597bd9d93d11d428d576fa0591547f6c16f8566e56c2e1d72c404436b484dfb0a3d3cee52e30143529fdf4c8de7c4b3a29de9da2f285476880e3a9173bdaaace8a1e50655df14220dfebf56a01a2525ccb9eac80c73c845b318cbe80ae26dadf31ee238dea08e9d343f5519bb1bbfe746c8cb4277aa8ac0d56f6e0fb26d9190d705d3b733f87d3ecfb0cc5b2f11792406879e395de4265475b347a38933cd9cf821f3eab62a6ff8b2d9dc1f69ca9e66076c9001b814455c668e4f4cffb1936ff09d81f3d228aadbe0beb375294f55d445158ae4c7483ae169a69c1122bd761f43adeb44c8bc6bf8e598933a52a80ecb4ef6749fc284a1c28a96e30c032f19b247146835dd7e7287c08175bb3f908f6f6c8dec7b2d98e28e2df18d74300ecc31e6b60f4e8aa77de8f8851013a986b3c049f9b376de22bac3b70ab02dd17aeea3bc7eaa408ca821a2a02f39c560c67589c3a8932a60741294c07dfa96ffc591b4674a3d2131f112b313946df022fe1f7fb3c16ff5698a28d70cacad30fc52820708a6abec4afd5167dc3056604cb8448bf9f14da6d3d25eaf5bb46add9556508c489c0ce04fcacac18eacd01db0309303f5dd02458200e8e3b39979a7ab2374fde041faf74aa760ee69121e6ef4b744dc0da1cc39d3edd55c575e47eec688cd46fdca14e82f9a1bd9396573b9ea6afbb40470aa7bc3dc0dfe41c598c17be503c42e2743a743a3d37ae18227d71fa65002a1b826492df5ad7cfde962de86eae916ae64ff527c64ac60aaf93acfa1d7e91d5cb5f7cf3eaee0791470799be4c3bdbcc2dcbb2f59593330e123168a9fd45fbe222cbae3dd50a6734849c0e45fd0670ec0f81a6b606a964fdf7d0693bdeb3002bae1a7e673b84186f941679bde34162fae0666700a8adf744423168151f05933bc0fd294643a14c57dbcb194ef360cc1f005096e95978a7a86a28ba4de2d9917231f6729de072c84b24b51b490339ccbbcb0293521c449d4a1b9aee03e40c34f290ba3d653fdeb980239356e16251ef91256d00a490d5bd83d7083038e837e1051a665e6995b61706ca240641356d325398500128ab1c2cb0ac2937357aa1d05d3ab01b0a17b277af1b5552bc633bfd9f7bac0512308974020b709b6b5e35bc1076c8c355664922b1ae028842f9164cffaf962a41ca76ba6a67a7b1541af6e2cc34d588b82b7769f50f49bbdfbeeaabcc87be25670ee76b608f95853b843f59a450494972791ed2550f9538282264948dcd29289cc04cc68db516ba6b6b9a09374a2d0e016bb9c180fcdf7b18314252ac5f60e38d8a1206c8e2c4da44ad249181c86146b7d773e6d827d0bf50c9fd1b32d18f6da9732b0f4253327b388f0d64a467f1310f30fa69d105e0289b3e54bbe549c9ea8c0e06e4f3c8e03a2c3ff29230e3ebf5e33cb4d18827737bb941db246f6c83d0ccc4f35f2a7bd078b04130cdd061068bf12a27eb92eedbb52be3d089fdf590293851171c208276a6e5ba104f005df5a985488ea61598a6ad2c572ca2599e378e3b5b843894abe0d6fcd2e11751a93114963d1d5ef3c035f69160b6fe93624c4fbc45749bcc8eb1852fff0235bf130b13cae75ba046d9a517e944dce2feee27c2860cfd7ee43a2854c20b5253442b17426862daa54666b67511e4eaf84828f4e44e4b53388d15f68f737830986c4105b731babd310c989f77b25df68ff4773a212753b6afd45f082ab75424cbbbf5e889ecc4bcb20e14ff770f5414fceb9f590d81c786072179b4808c03a7912775b9f26d211fdb41d5bfe8af01380db9716a35e4b6741f04ece9a928bf8df16734ffe3b57912ff8f34315db5e4beb743f57a4e8197c1025ed255c8efc361f6a5da3cafe365bea85f88459a4ded54e4d00a7e44a1b24832f09e587d72ee409f7a14536cc4dd34122406aa7ee291d738f5d93f44f2ab661841deb3f26d1b6675a3fdc75751a59d9f71bf669fb9fe77f9c7192e16827e2cb72db224e9aa788e11bec7190c228517f9613d5bde7375c4972bdeb8690c83224ec235927c6602f55a0a3729a104707d43071345f7ddfff335887924bd5b1c7494e4a80552582063d98601dba17669796053d62d5f8fcdc4f0ae5f4b368b45be725f63cbdf9f72d20ce8d98b86aa143bc9f4e61a671cb31ce52f522c4eddce72497308890acda3dcb26cadce7cf8f448bb7126f8545a45a320032b5459a7314cb16a4aeca271d4a3f62d44c10a84790838d40621fc689619ff45b85458971cd77ce1b969e789a53f6a46e0e7bfee2d056dce37483e8c8effc6acc098609e11bb339dc7c355c910f35a0e30595e26ff394697967ea0fbff158b6053bc9c85922e72fa8b8cd404de69a01fd9ee2e5ffae6341a3cbb854c6595e06696092bc3edda6f185be32b112ead7c3e0520809f7bd26f61a0af3cc4e5c20da4ed41a8ca1d8f57475834bdbac30cb4efaaef62630e0be5cfacf3443f76d650df1b51a40761f717abff1bd904f192b882df46fb0f7d1e717bb8bb32e4c6c82faa8f9f02ed3c16ef4693e734504e348e99e58ecbb110b09194938a4dd607b37a2f029f73aa77ae2c07f9cf51b3a1ec90888ac372dd1821385f3f42bb962ab6134454e703cfd129ee03f4788ceb2ddde5a937f7406b5e85d5fc29ca513c70241dd6e4f7666a180458f487cb057198e6e1e209fce5482d702e0fa901eb77f7a21b1d093908d8812816f75a501100626144f7247d130694797087ef76e03916391baa33ae8eecd1ffb01b46f8a5a0324cd9ffdf5133fba96aa233b4976cb1dff4c13e395334fa914d18950cce5bd79d831bf3b3c4662dae7e2818847db5cabd07cd4bd320548f3d58ccecd4f4a72255b70cadb5e7a3b4ccbb927c1959807cc64649fb5a3203049760e2f79e75c527b1888731e559c9293954cb2b40d67778cd33d55aa0b2a4e0c43b4f931493a50f5ea465aab7dac4faeb3bde44313daa2b33fa7a4bd5c31dbfacb5d8f20b790fcc6d0f35c8965714c737077fcc733a886d146c7eb4b8258fe775ffcf2eda17838a5dc45d17e67076b354b1543a44be440662e744c4f32425d72a7accd94d696c7a2813422eeebab7c381bbd58cf645bce058234463d393e0eb21a847d3548cbfe40d70316b001bbee7d463758b44c6ba34e37fbb1cca0d6153c1bbedb54560a090a5f69ad573ed7cc076443716ecdfb1706af3b715f008e16c0c229fc78820e6d1119f3c24161cae62f6c0f151bfef60f6b91cc5ad3ba707a0d9f6dc44399236241ed56b4221d39972957abff98af7c58ab082a9ab02e4d40a16b8740c91aa7ab9253cbc453fb87a7b419031b26ca75fc4bce188d6b35367deaded9670a1ac1b2cbd927b0206342ea2bf23856d09363ce76e7cfe1b31da2a0d096030bf454ec84a0f81863f0703a0dc284a97905156b4813239517ad0786d15fadca51fc3c5dd5290e4648eb3b7390b84942ef0182d165eec2fecafc216fd0406ff952bc5d4802fc02cb39b81936a889fef8228f17a0d9957c190cfaf4e6ed653bfe622cded3d2a13b8b809fb40f3a8582da91e5ce1e610b013cfca3df350e4cf75ecdb61a3886f42ee67eb1956f9bf72634e44b3c1f86a65105ca7b5a985f07180ed814f5869ee624477a527f03c85182b5af4a548304d4de1fe83acb5c5c15954741b60bd81b9c0dfe7c8e01ee94a0eeade5857f233f7de9c1774c28017c323334dcb323fdf62ac56dbf972e817e3d5b39fa954f13a85f59b9c0f6938d4bd44a0bf5d7a0554eb1215ffeea89e1a8b09256f11331dadc80b54961c7d959c192557e7da6af768aa16170ddb8bf8bf480a66a5b42bc4ecb5f68260335f17109d3d21a07d642e6c60bd998d22a178801e16b3785c8c346d046b7cd09ddba255733bd8c4e17055af955982bca9f4c477033da2b49888e661badeff3d8237f74b694493e131799d1959d3e9a8a12dc947ddc86eafbbc09528d2b235995eb4a4632b4a46e2d2515167d758017dd5349b2eb2339b21c6fb60117d32f820364eb95dca51126b8770333752d756b8c0412e3bd5fa35bdfc31349f635eba1bbdfee05baa815c916088623cf7e9f694f262d05f8b19390748663c6656447e7367d435651f5322b141de87bcea8aa201d2337e827aea22ed6440f2cfe9e6ba10a68c27ef37032cef33f2578e2545e578839e1891c5a59a4ac5b4248bb83698525c87cea7e947af477d979a2f36b1f90a5f13291fe0882e0886f1abebf0eaebbcadf587b595443c4808628d85127b57d792df33f0553968edd0a4db86a2bc36905f477eabc4b9bd927ea1e815a8b2f5deadc041406d0826c617be0afd9bee3a12127bfc368b4fe2fd3ebf48084336eb7465cf629312f845b904665e65e3e02ebd01dbc53d225fa6cfbf11e456cb7f6995e5b8b62eafb524213cee4b7d6f4b46968a605bfab4fce19a94ad7e6870a9c3073424ebe6631364cfc42adce9aff6c0dabf943b8abb7d78b73dc82cb3d9cdaf541517b64ed924079dbade344c471498cd9a88d543e68ee16e00cc21fec55037b74219ef63177b0b7a27dc1b19fb642db9ecf4bc460325a5b5329b882daacada2613bb153afe50d8e99eaf94bec5cde84b136d41cc4d579a3712488e5450a281acb470f66edf67c1e89692b76a39ba5c34a2fba4c5fd687dc45f220185bb8096664c5aa174d7450d782c069ddf8eed0d6fcb1b9ba1f4cc525b6cfb6d42a74c75b6359cff8169111cc694a20339a7d090a0be1527b2026c653b62c4dd1c40e1bc822aa13bea4ae0b054e9458d429e17c1c6a54bd0f95f8a0e4707a3c180981c3731011d06a8e908db1d92443c70ee8df284318bd1c9b6b6e4d7019ccedf77040ce643a611c9ee81b2adc4c6980bdda8d413938c3109f18f6459e93eb0c39a818d7eb607fe2ed3b3b02a26e2e64e5978289d1bfdb09b7f49a6820f1e584bdc1f648193bfdb0e6f546099c11b197fcdfd9e1986ab1ab8478975ec1c69e3d228243d887849abb26fc9842e7868e79918e33836ae5b3a2c951e1056db9fd539cc1533ff130a0888730297d61e891ed064b2d75a8749bf8c0ffe5423b2fbfc301a3e56b9a940bf031b58d5b4ac18697dadf7d6bef9927f2a7c265e0e895341ca6f02d6dd04f9a0840d0fa1a84b496587dcaadcc278d709127de980f6a473c5fb890d643e02872d4c7936ec9911436e7d8fd39ff99f7468ef012aa20ac73276943ff60fa2213926203d2b2b29a4d0ecc31b363d17ac15a1b8f5eae31a41f9e3844df3f9563a48689fe8eb45683e4a8533a89e1a5b300e0a726c3f57cc9a6f452a2b42f4bb6a652b08e39478716bb1001235246b2b750416351e36957e6d02aacdea8498c33465777a77978f09902cf08b6dd6ab3126c3f84965c6e5b4ebceaa0b2e9d4440d994abde3547cee3137751f0928d92c827b9bc65fee65d659a9a977d75ccd3fcbab68e2a10f580bfac4d5589ef2e9962b1ce98bc09b32dec6c67ae12765ed39667d0e28e672cc5eba5c82f3d0fc2702b2ddcc63060453ff138597bbda26fc10180464d19613ffc1373f7f5a06785395f9345fce339df41b9c7744ae6ae12bc27c6cf495cc9bdfe5048a0cd5cf73f6a46a721c058c33830e4e5441a165e64a48ad0b190eee3c2f1467e874b1a55c9719b323b1b6c1bbb0b7254a3f4b451535b90463a46883d2b94885915519491593918af45c975c125dca1c6efc277f5836ccea3fe30ec4d8a0498bd1e7bb21f14ab93d8eb9149310cd71ad38b67ee1e00983b530a31a89443efbd30c70b4105f31fa9f3f59cacf117226bfd2db385d011b405025de197a24d83d6eb306cf26f4648c52d7c12faba80a4217890c33000ad598cd16b79f7dba11d5152ce61b0f79b2186a4b44c5120be020343ac94ba905f58bf9c0adb83fdf184c696f9150fe91a7efb3dc03cae66df3e44e732ae08e62c79a0a316a2113039c7c7961e43403aabe0d418089120344cba5b2ef2afba271bb7b332109c2c2552b420104b7a866044a9d7e1c04969d645dd637c3ab77363c74260d549c57c5e68a84697e94236a026c252d96f76513ea321840ca8b82be1c88c96ce1e8674664c803bd49f0092a6792859fdd586bf604edb1a0738f87246187c6ea7d36d5ba64fa7c2bc50068c542d42ac8737e6f21fe9df903c5e3f2531796150bea7fb4bcdac64ac0993bbe2af5e9d051b0ea1a45784e9953ae100421cb118ff66ec27d2073a826bbd50347814770f76971ae76932fb940f4201509f796788666ae811c15ff3beba2beacfeb9e7991806654194553eb3f160f0f4e923723297ea273b384bd983a5cb61205c993375570f38505320c85f25951e1455f5a2d0656540c97e0c983a235b1ea9ee38eb3187c5f4d52fadc94621d8ea9e1c64ea72b241f5a97f211dfc68e45416b2d1af205274f1e2b6a7c00200403cfdfb2ad892e85dd3dd49bc3cb6eab60019ab69c54d77df5035630aa8fa48fd0d6adea16e884432af416dd9846f464436e42bee2b812946f832fe7561f82003ae662bddb4d527e29e134a9d2ca6741c259a01c4da1de0055bea6d64ff5f869f031c75a0de4d522ba4adc71e1da44e3ef008e484836e0147e057c32ee69d18857a64f5df72f02a874e88ee38f3a2e2063be2f1a5547198a5c85c14cad831c17d82be7a3698e00cc949dc8b7caf91107116a877860b3eb766bdcfa4abd759c68a5c65ffd603442e5472db75efb2cf30f5f8fdb7b5e4980ed1a857115d659c363780b54f858d5ec9c18490db3c40793e3531ae2cc09b9c9db50feef44c3af122f0b61c87630b9255998edb9da27a2ee6ffa982bf0ee64d81e0cb84ec9a0dc032fd33f82f51d307ad9c84c491e904b4650f078acd7b02d7752a8092b80177d0e8477fb7f5498c026bef079eac99cd1de355b990f08feaaf6812acea4a27e5232f5d444360b3cedc18c6d944c8fccc787be0aafdb82a0b908d693e5d68f4e61ae28b55f57fcd69b46c68f8c02ced3493dac13afcb92b5d27452fa479da9165e9356182d10e249c3f031987cf06604556a5ebd1b86cce0b8021ebc67893bcd5efc01f743d73aa34389a45f6e4b95fabeeb782e1853af46dda6c22329bb76c3d2210c27ae41e89ea7e744733dbcc6b42ff5abdc69cfedb2b2ae98766df487a3cecf160ee6dfc7f43c6c37a4a06310ed1b3876f370be327fbb80ae040dda7329ab3bd8b99017422bd46eb53423d8f5d50d6f0349930956bd806ae9f05ef4c29184c376c896994af5060576a2b169627f43812a6e1e0fe7e9b080c24f5392518e3b7f49603fc5e1c0d71eb7c8602a28a1dce208dc9959f5267c4b30cbdbb1c5143db202bbc06baba639b28a4519019c3cfc1e8c8282ecd351ed65e90026b355c3c3982454aba71870b3c058b1503948c460e1b479beefb94acd5da05caadbbc2817c4885159f6e78576be31aa2e77bfe408e17736bcbb3c5a94e90c3f44bece286b035809377fd9f06d5f443dba6245e984c9f5625dcc5c38ca890fe8dcddd3c9d67ef681596070e2bcf9db03bfb72ca5f98df730b41a070942552a9972f6ab31526e2cfdf8bbdd6a95fac09e0837a46c8a5b37cc929d124a719362150e04070cd2a3a430fa329113d75393848d64babb68d5f033144d43d57a431bfd2c1b0f1e3c6918ab5f0468be727eac10e699124923a8e22d9172ab9534dccec5a0b21d06352829583e7b33a6c0f9043e2757739b3db9f184d0dee8b60bdd10bcca7ead862e7ed00a5d9fa138a68b988dfa7e91f5a658c87f56f77b8899cf3a136cc0e78d2cff34986f30136487995414d406d4d8e1e700631703a75952a043256b3c210c8b657b0faaa713a0509036c74d7730207aa54cf828f45fd6315c4a4d772b26e0c7435846dfb68a034e46e33051196ed30eeee49b78708805aa60f65585a051182797df8c74d72cb281f925c0ec93ab9f30d15dc3d2858ad35882b0e05a504c9a7985a12b443a93d8415516dc84081d70cf86efe42409f6ceaaa12843b8fa013b0ccc75219427b2d6858ecbf0facd6b8bedea4f55c36fe879f73a93eafbe3bed43b2a255fd15985e12e0a77ab92827174cd2528ca0246b68812e36db12e0b6d1f4da724939754310b1b46bb7f6d095eab7afd8709b9e27547bf42fc1c3ca03e167a72352b0e2a99a672ed582a3b85342eb42c38897f88c22ab87ba7b386aba7dc300bc2a81ca2c4dd2fcdd11b50d1036c6e2c8700154793eb1104e7257b72e6e1f6b3e04c76892e96b25cb3bead5aae906554654fa0b71458bfcbda03e0df11ff403640f4aeab2fe08145890fd952b7933d198c242d409cfe61dbc01b472f419c7111e7dfe9f5cf2504d62de36806672672c0e25ef2879646f94b34ee4e730806a460342996e1bd139d3710b5275a433b84b0762acc7f193b2f1b2d55433a12498c309773a931f9d67fe4dea98462ffdcc5a296af957e0856d9323060f84baaa9d0ce5f8f1280625d1f523790eed8dee93e526a0479fded521a2dd2b4e83e85dda3ba6ed87b2e16f95243f4894ba2fa109ccd15c71d2e420cd1424af4693a13ec3586b4a0b93a3ee4a391755abdd6f382bd275b409961935ba9fc1bdb551c852e84f7ee2674ffdf700cba35eb0c15ef79f273599a0b60bd73a305fdeec4e376a6f31b229cbb7b562a2c1e9918673a11f1b42cd138cf885b3a26292c6920d028b10b2da87db7e99392b63e257590deba8a943a9f857df8adb09d868cf104cb627d9f386ec1abb5905b1a3d3f41709ad4cd9f18134fdca0996dd480dc6f1619afb964b9e1df56fb0b1a43aee7e7278cb155e97c3609408434ab4539d98201da757c187485d0953bc82e4a709678298c574a85ea13823c19125a2e1d64146ea8a6190e9eb31e1b705324572b2c85245aa82beecc7307877011fce8119b66e7bd94dfe3b2af498fb1382145ddb55df46ca94b7810b9de0d99136664cfcbdb72799c9421708fca0de760f7e183cd61f53ef7eaccf922cc0fb6d91a5b8b260b43587ecda5a2e955166b878bb1101ad8adba55ca57ffe4dd44b3ad7954cc8c1c948fa9eef79d60218b2365f71706da64dc197a50f0d4b93c83e1f1e3552ebe78239c7750864d0f0caf465d7652cd200ad6cf287302ba8701875bf8c9121273ae62ebbea6bcc2a48193f5c820482426b1d523f2a64e3b9106760094ddcf8f526c15e1fd57846c4393153a36be28511bc2eb6a35679ce6d2acd952e3ef19cf53487e7deac8c1d95d196fed8178fc338a137897122ce7efd912e3eb8d63b483298067f8a74cd23814b86df5642d99aecbc9ce2afbf0a4741fac7f368cbe9acc451ea25255cc8e5af87ae06acad6aecac4f9ce3747a68ba860160ff5a926cea560c54ff858f467490292fa20ac6522ce3b8a326e57100ec485a72561c9173bc496b6cf5cd6b124456bf0734a75fd13c0ea375e548e3485126f17b42ada31376adbe9e192b7adc6d776333f0d893e040d00f44d3e13b315b9549dd62a7ca3450531b27bed45800c66660466ee0da7948d6b7f84a78e190c52763cdb65d19caca9cc1fad2791228afefb9670423a11e32e3047a72c0a7e384f6cec26296e7de94b76edbe37cd3107a41ddb39e49c57621342e9ab1e5283f068abfa6b6c975fa02f6588f86003e5e8fd53e448eefdba75b7125c98ba1bccaf8c8e578557198c17867d02edff562ef5e29bc73016cefa06d9402d5620f82c61cd735e3a0c584551765be77026e0923a7e82598928ff939d71bf28adfb8cb8c6c79ffd508fee389a36b5a5bff28e0e0116a80ee2cd1a9f4afeda178473f10149efb6e8636b8046edc0931155df33339b4b4675b42af26222959f212d6b8d1f6f65f0b01c2c360e98b4d1830ab0b0790563b7129d3a68c746e0e6360afe0d468e8d5edd4bb8681da94fa540c663632252f445325e21caad781610110b7538392c7929c6c4e13916e2875576f41be21028b6cd409ef040e915de3cd5319f9dd01e05b48daeabbc07a861e75531739b78f37a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
