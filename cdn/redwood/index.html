<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7bebdc79fd182cf10b676560b166f42918c2dfaf7b4992429d9d4d70082e415666f24445ef7d742ba72de4c6bc3f2ca414dc5ace26196cdb20a081414a2b0a3a57c7a80a072e9f7ce41b08dd4c08bbb1f80b9f24f4870716336c8f0a089223d88f2b60a4a176e883afdb91c03ad21a85436342e4e479b0026737bb324224b5c5a37eab2dae9e046f250ffb7961082dc5009adf6a8d0c1668efebcc1ee3d06440d9327d9eb41fbf3e76c4d6c699e25c1d5d427146e6632e4b9beefc0435298bf23d9bc74e7b3ac167e120b3116ccc1f95e367ba465c08925482a78e078572b0e143f1e7def8016748e6f0d7ef3a714fd9fbcb9269ab75752ed5e0817b34195b714cadc6bf746c6657efe95a57296975cee77ad9823ac02e19f1a6ab3b55b878b828ad9ebb1ee6855d6afaab900e7cf26b7f8d9ae289a94a096b7d2700e72ab83e18052c45af9b518dff274103cf95af73f046adf4506484645ff87a448e3d9ad36166462bd51b1d020cbc3b8dc910548a29103e51f940ac156f6a740ba94bdcfe4298474c53c88afccf1072027b3c093c9ffc1d1088d4d1e391e2e8feebdfb822f96e8a7861d6a61d9531b20f69da7061c163094f052e84517d457f03810e26e08103985c1c7e17c0d2efa1ee79ffd9875d6acd62c0e6f41ea815b4897e209cbc2bdd79c4386ed684c17d482419feec60e4616495fe2bd9322a48ce6d3750f8ad5fc2b3c18d58ca3ccb463f1c35b5ebf73a94863e5fa70175a34c0cdbf0f034b6ddcd586468852906ca0c44c198af68a226d3dcdadc8a17f5cfe6912680117c8608014309298c818132921bf43fefb1fdc1913b540b3b655f936e826e89e14cae9f13278276a9ab81fdcb02eed8016f16ebb6ed8472432144754e0c2b61658cb280e84d4f3ec6ec04ba3c41614887d45bc5ed4d98cf699796f9f14df3cceea24647da4af50be7edd0131e711d44c8c41160b3b8db2f633c32531fcaa1373e4f136887cc1a40f78b184f2c7775b60f5a45ad75b722d0a63a768615033f707cb210ab7980d018cf5a5de04b834ea4375638aed67839155ba4cd689f42fdf8a7ed8cc916e06493edf259cce80dbdae8de916c16c28d779345e45917642048a75d4ad26f9e8192b8da0b3b9f3778b8cdc253e4f0f2bd7d4899a21d3a3d4e9560c9a0dd0332704f5b04e8cb86f952e291386b7c45986c6c387213ac8a6bc1c749a514c2e1975a3059d6e6b2691e7b01572b184e365e992cbc631233cf3b827b926b46922c0582f5325040f8a887869d359ad789a3d6728e6978daa81ae5c9fa8367745f0eb09f3053eb71a79258200456de57318eff3a919a50e1becfd5aef615babf95d9bb42a16dfefc4cdba087135a9c9dadf014e7ebb5c449cacf2c05c5480ff4769535c80d84c34768843c8360555c9e67f6a1c8e60171d9cec5c88e8eab46a4cee14e896bd1e53a5c2586588ec99acc108cf082dc6ee9c8e9d828534c6c779418e44641dce8597a16b6ef2716f51d8613a15c2294a69db7de56c91c54478a0269ab0d0460f80042e46706343b781e460553deb31e5dc87fcd3c0a1cc0dd95b918827d8aa28485bda4ab9f88361995101a65be85d83067accce0a025b5efc0010eeea58bfcbb9d5f2f197b5c3a12d855d88a7adcae4d6a1ae90068960a3eec35f4b129d84250e5b57ecfc0c4ddcba2ac1414afeaad167430e9405ebced914665b6d0a565d3335933ae375d7dddfd2569573ba34110e226856ceb54c4516e6af01c57da49105807ac26c53531300120acc1586939fe2415d0e14aa37cde1e0fc9354e9dfd6d7258049fe571aefd16cffec3a501f5908309361637b020b0416054119f7b6e6bb146f8ad60108ed147d79d312134ef50bb133a34064bd6b952a2e5aa3d2fb70a39ae7086c5ec2191774f633ebb4ad59be0f3e6b58251b70b29edc2c5f85f4fbeaee3a1323b321b4b2e53ebfd470a29023b1b78993d511d8486eca4f5dae8ed483e4c99c93bcb2f1fefc4e270fe3c7d8a00e58337071e57adb1c443a3e01d40c694019b5021696f5106cb14a80197d4c8ca4c0aed153e2157aff5fbfece33a26e091a53137b3585ad07ccb3bd0f8e7d02d602c4edfa46471a0791f4dd406286f0dfc1bf8e49cda8a3dbb1f9bf19e9b9b9c26833184f0153de2c9e7e3dcad1b7964e9b2a77797c2e49e18ac66bca72c03d5e6a88cd97c607006f87009c682534c33e0624422b29120e781d91ba4fbde629d7592c37f595f1b302d4adca7fdcfd42b0e4f02affd8f53fb52467aca5a9cc3cd3edcabae971e1c39c3f04d3a2699a5689d0646740ede14d90f3de2de73b9bd3a734cae8bb6ba518f8346a79996f5b074d3bd55ab3c1498467840ca8c1a8968f3b5f1333816820e9abfd61dfcf3a58c95895302cd7b97bb9c9ab2c76bec424706594f99c637def81d4f5eaf279ef47932bb432ab38d226b8d5dfeb675d14a55d02978e237ff48b1f6dd9f82e8e7b24ee0bcf859429eece61e7ba44ca86b532cf0c95eb2c6076ead95743bfd1f161bfff8f25a2706d783f33f86681b074df7041ab13debf011dd8919761c5a4e30b7fe63b08977ffe4750a0aed688a85487030794b21f93acf610c775c2bef95cad27454b758295fe03b7655e65f6e921998ed850f89cecbd80446e409f60654970cdfba07fd6c4670cfb5b35631c601256a22b08e47b7513d6494455a98492df7e483513c95cc16cb0f5936520a45bf459383a9c4c0ac2a1299ebf7725f00fc0ff3516903de3fa7556d38d7388b06e1ef9e4903012ab74daa28557ad40a84b248b83bd419bcc1ecc5149ec4535d22a487e596e6759125358622d0bf41e7b91634012e97cbcf87b6d8c343388c403cf7b5563da70f7f0b1e20723aaabe733d89e41bd0a7b1f8be44e4e76de742b046f860e32ef98c8f980ec074a6bec589ea6769f3f16f49dd564c759603addfa821a223315e84d21a0f3b09c7fca0bcecd188c8996ab8fa47f8f9f72d1dbbef8acdae29688e4aa5ef4e22bd25e5b198a15afdd8aa30426dc26dd32d16171c016f29d10bcdd93b69940bcdc870906d5c4e3ebc03dccab216c1415eb6c4ed417e0cdc78fe60f5687a93278fc8c09c3c8d8c13127d5aa916d24bd37e2bc64bf27ace2fd68dcaf0019fc42a0e1a0bf8b78e807572e875c494436eb342a41525ad25186f996aa2b3a62f1c3df77f11135c2732807f66b26ba0080c5bc1a173d8b4da73d164d6aed532dac77da4679c0c83fccd08820ea51b1cec1ebda280041f2866d8fa8c55040a7044edab5bd793c59d804db47fa6f940f59de450509e28e8793f0ae017f11eaaa7770c31409ff145d8b30ed94ba62ce4bb1ad490d420ff453d1fa9ccfc252ee919ca7f26fa924a7c3f224894df4628b3ba00cbd0494792dd0a433c3fd24d95b435f16f65be9ebe5f1f9461ecf8213350f1933afb336333dba2c4bbe47afc4cee1dfcb0f504894b8dcea270b2714a0be3e1a9e9e5680fdbc701f1d67052747d72eb6e42339ac7009d592ab572e1e46f76b2a960625042973e77d12b0803b90ac2dd9ae5c87cdd72eaeb86cf0cf5fcdd1e6023d01ca44888ff6c74cdb2d32f7df30ef1bae02461f40434a66947f940b7879f1f0c6f523d41b7b4e4dd83c7993931f6fb6cf163f98c947ec0852ad766dec56a2dd1df363051766d011099d2ce664d9c4d4b3a25bd9a3ad173b3b32075cb68ed5f177a6dd50a31decfc5377a44519ac693db431063840929aeba2247a1daba435aca2af4aee75bbf26b843228a7640307f548ff63f09414680eceb3a29e8dfb490cbd32c0a7d87c27e5884f3cf33f769ac90ea81e5d02090669b0d3168dbaafbe3e2c15c8d97c95107150a673a95372f35ede0e05cf454e4ba543fbf005bc0826a9c1a0596c6834c9f4cd952de96f418a884eb4bdee183744e75b274bb0c1e049045eab2c29e24a08984cc727edd099d482be119f12c65792af8d2873c31b6143d9d75ee54f03e23294eecd3de2af8ecf1b41c77c80d5e63ce06d399dabb3d91c0c7cb29d285f7184a435abc7eceb6c8863b02c241098779e1090e8607eeae251dc637b7e9efc57113277418a0b066803361cc7a84e2b4d4358444aa3582ccfb4c4e63da6e09d65961e49276bf7d480231079c5f57d9f976661e44c4c40a8d9bc260bc5bd604b409330c58502f739e8a804f657a2a2a7d3473031375a5c69d24bead2258232d2423dd178977af0918f4421f4853cc52141e2ecb7d38f4a2fdb7a45b52e849e63b61e25523ae5d4adf8af2d317055728f751e22df036179cd77f55878be79017ff3a1f7627055affb6784dee4d8c629d9c6f7d53ef8dd664a240c605f2d47ea9f5f8de284cc584491a5eaac365c7693173d1a0682647de8b2d664b1b839e4ad8586eba1911429b5b92183056e34c68e35f1e714db73654e072994e209154bd7a2ce161bce051921cd8f4ee0c48caa2c0f2a65670a62370bc591ba698affa9609d1a3da9c1fc34fee1854bb59a81ff067a9aa4d5d49add016d81bee2498b3fadb2d04e8ee812e1a01dfd6e56cb76c6504d6e5bd078fe00e3d6f48cabb01d36bc7f1d332da701612b44008472b48365dfa6e70b7b1338254f2fb42202e05eba6abdb972e75ee4f402027397660b412a1e67de4634faed6e3a8aa0fce31ce05c26e1fa18bd1dfa6cf0d693c778a1384de962e562bdba0a607eb9483b3ceca7030742c542ca8f666bf2bd81fd3b2398922ca601237aafb9aa825912ab5550a9e358b50bfa6914a532209223ca2653162ce29bdb05c2258251e27d8e13957c83a0ed760237fe275e012e582879564a208a841b09e1d6cfba903c1583da751a85a9bcb8e5072bd553089c8734f0dca3e563eb6243468a553984173119c7fae8fc6c5756ffc1d9cc9e409d0d97403aaf723c8dc0a7718e1aabe412cd2dfcc36dd8cab37787b2d285ecc0bc635aa6de86343351d561478e3b79933c63b7d2807a9ef8c4b55ea3bdce81706116f474d1b3bee19be01f03bdcd09274ee823b5d6541eb9745e6a3addac7877742ad08a5d817eb6bb151ba00eec2ac1ec001b98cf62ea4c09864e0b7c5a7bb2c329567382daca2a9801adc8f4dff8457a286b0c938949ab499d66b484a49be570d0bcd2c78be819ec7e16ac27dc3985ab507163b1951db31812c8883b18a4caa873928e76ec8e40790f3c308cb68a23e04ea591ae7552a157a8cb9d0a62aec99726c896c5761c59f7966bb9a03d52088f140cf4a6b2550154abc0bb18ed7438008f2a974830ec2c9838bac7c8875947cbacb814431c3d0f8be9dbabe75b8566702bf00ec08e67fbd31b62bed72755f8dd44a3fbd42ead9c12821f1dc17610a5d90b4cb73974715dfffc6df3d9185360c8ed412c55de6146116a960efbbdf0ec7020eef76bc1daf79518386f4427f5b051e1bf2b375c732ab079b9e47ee64545c610dde9e66c8a11588b5330221875168c38ddff9b9eb7f8bc50a375292fbc58bbb29c081c459ae4ded2bd3c969b4ff47c5daaff5197fbb0535e39e9b3ec79ff54d75453a89503517009ce838edcd3ff8784a501c63a8dd900c5a2c795444d46240dcf3a42b6e1f1b700258f643824b94e4cd0765e30e290198a9f2c755a63ac671ac00f138cb6685dad1ad23cdd9be40e1ce03855b1d70b247cddec5f798e5d50a93a5410e274aefe2faac67af9aa26a9e26903bfabd2ff3cb5a767588726ee8b8fd7814c7dbd674c8f7fb7275f51547883369960b676c7f9be3998638b1a051a2df6df2f255454152a53f360960c7f3a790150de0e515b49ba56173dc2db2a7b28fb9994699ee6b02b3191e981bd9203d6e3b0bc9ed3b63f09a78f14904eea9e86e98c98b14b39da988fb504070475879d2d6f9aa3bf564dbc58a8ecb70cfe6b2867da55bd54fb2eefb455342f3e5c7abb02d63b1addca08591279fa4d3b5861d59ef93bbe3ac4bcb336645aaeab3af75919c48657e8a916e25ea410c82c337cbd74d8525c6e431a9579e4817bcf586fa2207159baf6d3750486ab005558a0df87c8707356ddd9cf13f0bc2ef83e7edc6eaa4e580765e959941e4039f46da06246a4427740d8b9bc749868822c45c4149ac2947d0423e44bb174e43a58337d05c27ff3b07861c7203a807aeb7940045f65efefe3e9360922fe0e6ee4ad31dea0ca8a6dc406026eb61996589b283915798ae9b657bafb742b9e0a2029b412b355570edaef3b46b27eed88f67a49a4918c67091762d962ee670ec54cbc31f538793295ae6fc85a8687dac6579dbb5c6683cd80305637e2ff2056e2117b8c560a062366b60f8c42862f71c299dda5cb856c1b7abb785bdd3db6a997d1b6d84bc4b8d4177a15297cf127b39d64262fde2c80e685fb3c43c2fe24cbb7e05b736c1879c0229a37e0e56981c11c71353447418f4ed6138e254270e86befdb66b3f7d1e1204a3c4d1b97066ac03a12c13898b8f9f648b98248c5e5bb0814ba1cf97307eccd9fe01cbd84ebecb0dc196c7d4bb9a349e38f6df0caea0a78fe1d1f769770ec11a7a00abc3a547464c47bbbe6440e53be5951dd79973fc42fcdb82b4b51f04baa99b9a47587dfc4a97f1f2b6d205f461d44a3813efe686352df04fc9939bdfce2263c18cf5f8641dba3db02ef989298688cb066c7c1f2a50d38b06af3776c64985ed1e7a3f815ade5f7d66ea4ebb0237799d97ca2e34ab0207d46bd9e7c006c6cd76a61e2871842d2a9221068a04f20c17b0a9c5e69d34d6753d11a36fde0b334e17ce65c53a2b91a80bf800fa2d9327a7c75342808d80e2924726aba169486a601a78df44916494fa2c08aa7903d6b5f4a51192c54b3f44949e1e4f7da4042e972258280eeb16d2fabdf074ffef292bb3505dbe092057f9693fb4acffa9c86c9a4fb579ca75b1a6a4644bbc76dc0f56172d33fe70bd94d40bfe6dccf4a53f7e1c650ac757d6713bb71f4df647ba36c2923ab507cdae76043d704e37b33f1d5f06e148c78ece0b1808d6cce55fffe6dbcf47d2d6fcbd3d343d8fdac117a49a6d7848ba6ae1e933e3718abb52d2fd62ac905e2a94b514d3f5456bb23ae71a7eba8d8694ee88cd63d568cc119da456d4b35a886683b737fc937153db50df9f9733ed9ab5bcbbe92569c799df78b7114daf1d748c01c901d1ea6a79a2ab2c80a8b2e3b869c410c7d39bb3f3e5076c2aca4fffade04a9deeebb95749ec63557b6225934f2a077da8590d0b02f80d5cc373be3147bb2b4fe381355bb173bdbc76491a47a70711ec1e61b5a75041ce957443597dffd8c2e6af77ba4a8ddc4f18428dca6039d75f08220bac37760a15778ef349eda89f3fbaa79fa7c27bc3be5184d664a76a49cf6c109b3b31eab0bcc301c166bbb452ebf5ce0ba2b4b3dfd926717f74e934e721b5e31dd02575bcc3cf0a449a062951805809e1c05c87e074fe6c737ef1c91c28144a97859d97dda58a04f2e69fd3c9f3df7608fbdde4a0a9cca47c8dbc2bb5951b5b19012d4d90560a889c05943ba562bf408d2aa46832856db8bd6cfcd40d92421f874dd89bf44c47a9905ee7482601ddbc21e8277e53d48c158eec258713637757267fe6b86f276e0e213085ff4abc9f1ad20f4d9d7ef22cbc5790403e2e4cf99dec5a99be83e24df08cbe863dd7ab2a24e3a269a9e242c94db0e8d49c0ec11fc29c0530a710946ff8ddb33aa2afff502df877bb5acf825a60c91b2f462dcfd3cda21a22ac261ff95b09953260f5aa94b3a06d9e5bee0958dfeba55255984cdf8cdf4ee07af418147cae3b35d6076be2dca216668a48fd651ac8dde4e049f7d33102451a79e6ca467f1c5ce72d0ce656ad8bc5ad36c2035af03abfd97397c4af474f54b5ac838687c24a0e1fb16f11864511f59ba02cf55cfda9d8839ce3bcc9815cebe20f520567c706cda2357e5bd1339b2773d31247ffdd5c7416d0764cc40d15fb318ba29f7d08a018d5960f8b61712dbab82e15b0ebac10c1408adf5ab67261363675e02f6a361b3f606eb198b70047e15bbd98af12c0b7f2f8dbc6718706a954f7c776ff8ad571c7df5d838d07a34a8a604035558f1318d4ae782efc685782744051648493a57f8007fb06ba114fa332ac54d3fea6bb2a3cf2722f4928972d7bdb53d04c3804ec07a0f32fc031968ba410e74c69dba9e58763e9232753bc1a91b70216ab68d30ae2b2adbec8cb3e303ecde6f225103f52e2afc804693c498d0137209c8c8376680200f75ae7c42efb7a98b7e07d4226a05ea78c0817a15a88b2888ec211a563f3e7f5c83ea17d40a5ff7835dabd9a2c55f83eb1a223da876d0705fa03199553b0a07dc4ed48700a615f6b49e25c8fd23e6f2f782fc9adb41bfd210978206b10b7c61d329972c937eb95f94b4933fb2a86f0c921175c3d9324889b8c3dcf581a442cc58499e05cbe53a1327ee0fe7818de6269cbc096b36d1528924a173e9fa7c3c5a7583191b12dfae50be0710d167c2b05219bc40e4d8282377b610e1aebfdff67bd7a88c73908712cc8174b3860a392e77ea34037e34cb48186b9a0835654d2c8fa9448a263cc660739cce6e43a06d9882cc85505ea8ebd272787bb7825b16786bc3e732a9bd54fbb3daf40211e424ae8b6f1b60ddfff275e7f36a7a0462a5f9008c0460fff537e09814bc43ff196b51a64bc2de97253ac6e0e9e8aee8c3bd8c88011920732108b412ef8a8290b6ec2264638b3b1febfb7596b1615a6f1902e8c7f12e4c2d39d6bbf53611c3af4c0e11e2c301272c6988f44c10ea026eb9f6f68e1c2137f80990cf00513270accd02f532cc1075e8051e874ff23b867a0507b2990e77f336b84e5e6c24a6da4bcf9103c3bf27a81cf12396360d479077a713f11ce6e120182c2697d413458cf10b0e9a8c1cb462507038a16176efc2ed88c5af12550ad6eca25c1037676f53d62fcdab72aa7cd5caed5160643149a01b614c098d97de0001ae9784240e78b120671ca4185af95048066dfd0784ea133e057f9a4947183e14a1130e31df66d5721d1fdddc9ca18d811f3300fa92e7e1b2651890ca604c5c7ede5266f3156701ca5140bdae852ea3a078a5e12f1a16c9c71148970e3b6de59927428fb3b7cf9318c4bf37b3008f2fa215ad80e24b499858dafd817f2aae80a3b1adb23969542082a6677684258ba5562a06bc9c0d1204e7ddceafea47ae25e47af0928c16f61665874e622c5e240498e9dcaf987ec16ae026bae0cd16963e17fee4039b8923116486d963c6f41108a12596de22567fac841051e0869e8798178d1de5433324b74f2a5b12c6e288342322e57be400e8a5f736f4059f0c4910e790f72afddd976bdd39c6db7edab7acc7b01f030829d24a282c52ed525c9510beba5d4ec98308bb5bfe94274e52313c4add757269deb36c56da1076921eb26a4ce145818a2cb668c25fe22759a559fc95e0f59bf47afa655104d1bca904f4cce6b06a20ac65c73ce7596d7eca8e3f5c6cc0ffb5067ab07becd61c2f1723466d905233e88e7f312a94eac1a9e642f37e01ef94e4f92428d8201cec0d1f63b10aa9766bee2eab68b2655002d8c1becccfb40aa63460437015117e22e26d542be10339bc2acb659f5936f40236063f93966d898c2e85c5c670d9ae0af15cb74100ea1128490ceb3997c388862e3ecfafe310ee2d7a302ccb62eb9f2d30fdfd9c9050cd58962a876368768d84727d18c79f05f3119bcccee283ec23cf6364b0ecee354cd5c7d01d14fdfa373fe2cf28a096bd111bb6f5a70b3668b300494285081f97b36afb90df074f575450a22a007a78854fcc3c92db6df082fcdded3c71edf79e910f624419fbaa1d05cb86f6aee641a93b000e1974a9e36c7953f779b13d8a99c99b231f2cc7b19045a52330d4e00b28c927a5666d963fb28d1062787641c1428273df8c47a97d74a1a598fb302edac9ee409a46b7ab27e8f90ef212a19eafb7a5af2bf7b5fee75ffda6b90be662a9cd5cbde55d0747ae9889bfde5b808f8ec688a36168b442aad44140315403868532eb65849ffb69133559300292740faf8daac13616b510f5b44d5e8a38ed7a4bf9c4a68c02d11bd495adccb02f244f687009cf753fa4fbb09464c91d4245e685b1bcbfd1610bd78f94db43ee764abb2e1fca0ef8ef8ed00e246bcb394fb4ad1314a416ed2bb45d46f3b5a351379da5c1a4e5f38c66e6d837236f7270d791ab38995c805769e8708ffdb1d370b86f5458a9e307033f14c426e5e785f49cb8b3db5110c8f26c2fdb3093d480c5c5b9e05c5c8022e555cc1f0e51e2aa9daa0384d1f80a97621dc0352dc93778c557db64bac0d95711d028de9a9d0230d10243cdcafaa2de9c160391270ee80b90482a2920799e7c1a1125e80d4adbb6d1b892888564d5e5d7a867bf3f235c32dabd741aa5ce41433ac81adcb7981f83e0edb31acff42cf48769fcd2a0f140472c7290e70d46e23e3adbd29dd432d7c396bececd20fc851dd120810011411e86fca0e3ce074b867aea9b73f16cac55bc6d3de88f2172299f58ca7496ddd43b28a57670a642ba3b8e37a734cb4a758dc322fa4dcb9ca8fbc61c43ff5e749cb2c67899f62c73f1cab121ecf2a1dae6b5a2cfcad4e004cf70ad8b376e0defe59a92487919284d678e913dc2cead6a98f873d69199c2652a10d15dd739702ee32c3f87cc9748c4f98aa7feb318379a10501f7c0d059c49298b210feaf5c9abf53a46782e99a68c1735aa93ab253b1a73628e66b810e0c224c166ba2fb3ee35e31d1151d0d92eec5a47e1a3e8b7053cf78aef3f4a62597c28a5becd6db51c9084686dc02511352e2c1e4c643b331a3e8c2fc67bf3d4736fdc1f78ea1bdbb46b0d9158426baa2fa4ebc00985bd328ec5e9f069542708e814631e75960a57a4d3fde99742fb1f74caf8ce2f350d2fd51b2edaff9f7c30cff944d3480ddc2ff4c3dc2aea986509210d7fd1222d84d309b82e665c8c47b80650a854da5485986ad0b62a71e64c1d5e3d8800d1c769afd4491f064a88873311dcf6f15bfc88287e966e3f2b8ee32813f0775e3c244a66261bfd158922ec20bca35350e96149073016daab08984385c02d4205cb513aa11f989a6a774cfa4622a209c856694b77c6e43c995bb537cfb2b48037c99e719de973c4105621a8f26d140334bb13818f0c4de1db272ea8014d02dc658aadcb00ce6c57afa95de378283214c9f883bfa9ef3f59d91009d0304aad906459e0baeab735efbd62ba562c04edf0058172b6fc4cb50f6e27cfa0e948df1165ebda010385959099de9b13ab1877e1cf9805c91f8677f655be0f73ce18bb8898836544cacb196ac0ee5260cd0c76a1bba39dbb15150b641a44d3581f22f976622e345ec866fdc9e9eba5d5b551d3749a11c17f1b677d43a5097aad2adad8a53601e7a6489d3a1019153ba0ccf59dc78428e6533024d7c629a9b09f9bfa3b60138399c4bbb0ba2d1f5889cf2b9b392c78aaf5808ac28cd5843b6bcabede5c7ff6bb54d10cd9ebf410f27ccd684de5afcb92ef4e5fa034d841c42c0cb561a6042b5e3da7f44ba80e00562edd549c4ff092b4850e06ad8bfd203bcf808003eb933b607d41ef090a34f83fd505327739506eb1741e17d90a0be34c749150bfcb583702ff1b342de46025b3b9cb8b2ee92c80fa68ef6d45da6a2447563eed6c98a7a95e60c87e59b666b40ec77451298f1ebee1fa5087ab30f34ef7cbe29ba1006c4a6672c82d4404593f29f20c1e17956a8ed250079c092ee5dd1caa0ca5ae230f95a01b474ccd5b641ed28b66470dd19aada85dc83d4029dec9e616e743e2357b1d708ae00c7458dfac141ea141774e3492e38e7ab92227c6c0411cef6067d371a83f853e90abf4d3130ffdeeb5ec2593c05e3eeede66acf5ffd4694dcf7b9504d40e68814489ebc7e65eef7f19d4dde854fe8ae42b9677d64bd2776c158597d067a9836ba95f9e92e92140324f6f4f3c17681ca85bda447d367604a61923798904af0de07238e89a2222ebfbc51b5c357fc267223ee17cab98361dde72cd209fbaf21f36a1a1a5d4c32f00d1bd41470bcf136def9e8495b2363dbecf74312a1137a827f47f5a69f7ea2c81c95bf71679261ac2bc9e703e76b62279c1eff2fbb0ac972384b645a3403fdceacbad36102f469b8cdfbfc8408873762d35048ba64e9f1821be4b510fdb14e8bd37482b91cddd13498b286c10f1ab8d7fbeb3e962134aa1d3879f99db3dea16f1f2d507b353a8e34174432c60975edf6c6af1d8b8c17c2900b754d44db91e91c96b9f4232d8b45024e57e3883c0e3b10a4179659272597f1734fc8c792ee49fc6c16296c8a977fa586db01bec18693311720eba1754a97f1e5aeeadf780dacebadcc95fcda54307a31c94b19da9fd6ba74593904c9571dd129d389b9e9188a403c74faa2df2ce5d7ebc20871d8ff9f20537083636c3b8fc0318cebb255ac0a632741a1070f18440644c3c1de28e14968c831972d1567efda6d7f5114012a1e911f3829571cc49d5929179c828dd5b64afa21c47efe2388a9ea8e385863d960ac9ada74b3b1631ac842af553fa52aa9698b3c97c89f171af0c5d42e6c8fdee0f75ba713f3372502c757b6bed556f4ccfe7592ca121d0f4b24804372e6b5a4449f2bb1740dc81b33f5690b564cfbbbbeaff2640e5e0e8305819351ff56f89be4b7c4ddc4d830cbccf43919bc428c6159db315241eaad92496e6fe72d35092c48db81b20da651d86862fb6f39de6c43004810981caaed36ac725d3a32c4b2b13e30f1bee7591e984817a6cf0e52b4bf196060faf8b1cdb532e6cf9fde5e6d1613afe447aa812e9b5dfb8cf7da232775e3477706eb509de97748708133fab97bf7294b7380a96b3ec4224e4aeeadd35a77010fb0d9eaa3f147e11bafac8e1c0b161f4f6a873134c4f3103e0f8dd4b6c4d154e7606db12e4216941f02ffd5f1b25ab4094a008314ead4a7a738f08cd8fb4a15807c84664050f9969ae4cef116a29fffb419477c3c0201db4ce8b5c938dc66d5cef9f5bdc8bfad9744f282d63ff90283d1759816c3eaa890f9145cfe24030024df03e1b400df0eb2c37ab5fa772d3c35554523e1d3686a0bd02315721f7a36f3050c8ba2c2eab2f89b84975728dadc044fdc7042c1f8f017f337b5ca53c4a0404d2415a26f0befcf0edf434eedd2fb500a8d53ab671e51b3f3ceef13f659ee063ccf3588de990fcd0d805c2fbb3eee9986d5e66f0f21aee133651ffffa00144677ccbc1915a7bcfa0ab60d40ca5a823ccf533c40d3696a00b9612730a0a52c860ffdc715d03c43a3e046e15b0ab9568ead48c973cacfa008454f2ee13348c385e270ad5cba84779ba92854e945cd369cc06446123b5c825b1a9351ef3fc7c1318518a535b49c19e0eea46aeba9af1e97d3ac9fe44daa7c0acb0c8dc0f662bae6eed233bb2216b31b03438f997feef26e873880a3f47cc6c68f4a396434ff658590114e34838d9792b6024d5c507b992de9507fc7cad7efb97017b75675db991684efe06890765f4bfaa5c399e316e33dfba45f745ec44c51bdf3ce3bfa7f53267f60bf40e4170ecd014fa074fb72631b9e963d56a174ee668fcdf92039afb10212a52e32b97ae7f5c9d827bf0094a5d69a489c85023767d05089333ad09ea31522d9e521c527b6d9e4d0e5ea0587166c63be75ab02dbe13f1797c894580ba1835e9cb17bd2f939fa951ea458bec850128bd92c2ad9caef6b6e87be76d30e3f137de7ddf81572b1c0e471a829d74230fbe946aa63161dc8d01135251eaeec6d0d88df86d988e9cb3495772f20164aa18d7e7c0918dd83800ffbb3d1938b477431111aee7ed7d2f190cc782015a979a078d42e559a16e56c55d00d2dcf44666005d684148c468859415e0465f2a9b4b714ed16fe6cfe8b7f12ae99f0658fc4b372e33be0203b8aa21251f83b4f35686d29c0bbc2de85aa43a7ef88b83a32a13e11e67d6c61796a85b212100ee0ea3a285402a19d68605c0393356d2fd283aab4c983579272b69c59e8d8506b080397adb22bf6f89d377544c5dd6ccd32dffd393eb936ff0ae291fdab1b7923322d86cc0abadeed73b8a94d802b14ff9892cb056c6349bbec4926d876a04816fe2447e46fce196ceef516eb59a94afc0c5ddd11b1a8df736384c39fb6469f300ff193f0d4cf0f086121d9c2ba12ebab2cd5675c6c0515f249d40259d86eb567419d4103f777d9ee758e2eac8ad4a5695e98f8f5082b4312a25c0797813e7356522b9dc8491fc4445cacd99f3bf52993bd112da76b1fcd25d7a1a68407f1083b8e2e2c5b21ee4037e389ffa048776a46afd4c814a1285cac7b0f3416b10f009ff0a4510f8066c9af5590acaa8951326743ea0ba3688d8ff1807e232d83c3440eaeea1365f4de4ef2d7cfb80d1b94b197381da1e7c375ccb50d6c8201b556f1761c8399720e81ca5329eca16ffe0f57075df5addfeaaa065d4bc50d5d775a5f30ecb604346b2170611836313aa52c8447ce1ca6aebbaa3167dd834ae8f81190d803a3c2bd2b2ecfa8d9541e65240f2e2bdadc25f63b7052d410370a8276d68376641ca9409f97903eaa41d4b7fb1713b17057f71366f611d23c1b20158b0c7f0c222ddf8df3c70a637f8cf72b0e6876bea96d8f0466c72c246f764c05d9091aed2efdbd3611f55776ca44c850fe9c537bd53e18fede4750b310fc0e726f0533cc2007c2d35af4bdae6e17193705f9b8dc5a4b3606c3f2a121ad5e9dd3cad8205e1f8857d1afcb130a281a49f99a2b465c0a192eed6318ed11fb27f4e994b441d6a41c799fa9a1162ba599b56549a8de53b773751e4a33a4b6ea3ad0dac0148db87a9d0f8d51200214f40b22e67fca9dbf0b61d1af8d3d94fd6371fafd1ad72f16bf545478673d283274ae94a23734aa07bbfb9ebc94565e8d860596c49fbd3d988b1315d6309107f682c1239ab85be7580667f937e74f2afd0514304e6a46301b6b1c8ed2dbefca972d14d813fca3580bb5fd74a3e03d2b1501b0866390bfcd737c3db8bf214b59d2c3c485d9d90f24ab62c4056db9fe11e5174611103699a0e7bd37cb358589201b76ecd52ab033b00827a53021a65b97624a9140fcde89a2bfd68421e2e22e52b0f45bc8273285f1cb65e35afacfeae1f172deced4ff7b877e29274ec262bd2b3716e72e16d0678c7dad9f769eb8d80449519315785851a51fbbfc5190f02407b1890541b7924b9455d368d406857f25a3d9a5f7f6ef9702015dcd4d0ca2e5f9a4c2feb31cbb9a2f13f46b57e9fd5a748045aa0a656792369327ac94a8bceb225afb8734cde160fdad29af65fed80fdc5fc6a2bc45187f6d06dc82d98827658c1f220c64854cae93b3218c9d0e814fb2a1bf24359ea8d7f0be4a43ebd2aad2700c59b627219f6144a8cdfc53b4541c0ab0eec6fe97a8800f8a5ab04b42b38352df85de619f82eb0840e495cb9ede68cf0edf043257650ae374fd13372020500bafe9653003a5b3b2b69556371b37f6d885e9ee791e46c22be5e16e1e977d76944811cb5832ceecc5299a68cf05fcc2bc834637aee60fea5f3aca4099c7ebb8cfe66559cb086c9a2d2f666e7cb9527859708316177e781b3e3e9d9685f0ebced849609385d78637066dcbed208bf0831554b4c4e868c6214288c69eefd6585a4187eacc278cc61f32efe0be269eee85948ee86f257beb1c31e9ecfaf8ee26bc6daba3dd2309cfc46f88aa0ba98abadd7a1d6b1c77639a537a0a91478061ef35654823dcb31e547d5170250d54bad674943fcbcee5a6371058ba49e7a07a07b2877085f3580742471629efbc9e739f389a4031cf28cb874fe822bf264636db34313922bf5250de2790d59bec8975758d53d2973bb3f9057bdece3e97d5174a832d77f5e8dc933daeb7125fc2ff1bb5e1f71686127079915f3f4027d87d63d06888d20350181ca510200e1c967767f28f79e4c81c85a3127e9eda1e78dadf8b6c563f9dd8088fcb897243e95955349d166037c21c4926ea94c4f1613ceb9334d575a926cd26c9d23a90ca472048595035e55328788f4053f1009fc25ed299c9e8865f3cb754a8859bd8431df7ed844aea90aaf41eb25202b19036e8abb6f91c8ad676999ea8acd3cc0f9501fe6c2d8fc97ac79787399a959e3e79cad56ed08bef8a12f51383477de374ac79254dd870cf2628088e0b32b91c8b60dca46f84c7da705ddca352dcd89fe276c8771210586a02ee2e9d1694b699283c39288bf5e478a2c2c5d37148dbe119e995afbc657f9faa825c0333d5609e2c1a7a276f5126353c7f20c5243a3fa66daf1bc1dc2c5b12f8dbf474668f291e16bf38b74a8b620e65b505569111547594ce65c05ef64e40d1184207e2a6a197c59ab20c810364426e081b04b6dce23a7e9952ecaeb3cd7933afd68587ebaa4e302eaa4ea3a21748b577dc8520bc70c927bbfcaa17dbede9d61e7c4a4e591115747c700288886be06edff75a4c38a6a2b2900e8faf35aadba0e2e8fcb3882d2c0f60b7ed55e03706d195e5703c63c97a8b6abe996d42cf9288e7b15b512c63532d67de2936fd978fd07c930d38f09e57b6f244741403540a30e0dcaade47d22921ff854e958430c25a059cf289a2ea69dc60dd8bf250a356a59137764b5eaea5c90d4cfbb3e77995899557f94055a5a3c67b7ddcaa9b76a84ba5300cdc0f616e292e45685da1c3da068d2807260df4b8d9765050e632acee63c55251009fa4560e2f70c79e7feeebeb8b77595700289be160da7aeb90570cf414ad32ca33dfeff920463235628880f6abd1a12c8b66fef651c4a626070c17dbba6f7a219e70cd33fe572812600e36c2451b90a34854ce4f00c3cf3927056af22047ad04c4bd5f858acac01ea04f66afda9444c9bfe81fb724abffd4f29de4fa718d45cd7a388e3442b8255139bcbbb4db7bb0040b51bd0c7980f892ec975cdf30ae816711e64f1ea260d4656c0b11f3cf5cf0d51124ef27dbceca5c36908daca7efc9f2a49b75d50df8745014ad287d337141954bdebf7a8f9de46e1ece0fb85a55d2acaeed9876fc2d493a5a7aa6eaa1fc430b1096c56337795bb3ee9910c7a1a984a642d8256ca4023d66415ad286df5dcdd970b4624d973d045aa58fa3c1d4130b8188ccd8e6dc6701c2628ce809f55d41d978050b114bfcd00b4ed24e721be33933e83d96864e84df8d0baed506be865b5f50d8eb46d08f494183bd4e01cb1dc4ddcbf7f4bb508e9bb036599b221359af225d863683f848831a08d3c323669a1dfb87387c845cfc1750251ebd723637222cb5f6243525c01a9e4710afa02883b52257b7047bb100891f81af615bd36866ee0e08b6d52dd9ea207855845e9f6e95ff67892a63ba6819060f74e846adf8401c358dec5ecfecef0f8b5b4d1048dd252c6ac1b16e2a9983c35b5f41ba2bde95f8a429a91c8190c99a4e091a3eac8fd8453680635e2e14deadf919d5e01086044f2a4c695e33d3fd7f3cf99f936d19263ce10433f837dc5a2bb6355909564e291d2577fc25c629c858e29be85db27dc84971a48c664503a1337f67452a9567657dd15e43d4ff486fcde831f9fb62ff0b28166e77069e549c9166a07083e33fd39007b19a92a739aba35f89b746611f02b5bd0caf62052baca5629c4f8add7e42026447357ea5d1119dcbb130dd7663c7f7316386800b6b4b50cd1f07e13cadb71321116257ae071ca3ecdf3805400d4245a607705911c9d4b2d8bc96ab92eb13fc74a58185de2cf879cc6a730b972b86e77ad03199961ace1cf8fe6c0c77f69971d1cdacb05e4ea25e760ea3fe3f4209e74bb440912b6ca68ca11db5daad75e51503bf785cfee0e2262b8a4658655ac8b4bde7ac92fb1de2a00cf9dae92eb7627fb1050808f796b9a4912dcecd28a22d53bf24a5156d1b1ec5a5db35b835c1080a254053688c46e4fe8ab743acf7bde2189883931d689730dde85efb21d126cae51c4169afcfc162b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
