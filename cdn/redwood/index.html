<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"31e4e1ac6d3e0394faa82f751644544816b87528af4ccee6080f031768f3a1965e56a89a713a2996047003808f3c326e613eb765730de4b310298fdc2f1d65dd446e739e497a301cf5dbc1b3481536db99e3f11e132d3b9584215da32671addb627ddfe9c28789578355275598cc3897bca927509602c0247a6b2ace2bdb583d2589c5b8f46c0baebbf1a2ebb09e84a88a47211e4c3ae19a0f84e9574b16fbc00c8cc4d9f7aedebd8a1064ba3be04b0a4f7baf1c41af0cd19d2488f3a55fa24ee42b6fd41d737db7c0c463750ceeb1ea26f7d64365015a1bf542966e487e747ed2f7d3a690e0009e03c757b95f1e2879fa3a1a18541949a04a7b4859439215aaeb8861ed797980961514b1fbbd2d23130bebf3468f19d1872cad13975007fe272f75e0ef9b50653812916923d4515a24f8155d4adea841ce4bf3ac99d65d0ed67a278ab4be186bbb2ff2ddbf61cf5af6b72f9508e85aca2b3ef5f99d7c41eafbc45caca77d686da28e31cb2aae6674740b6fccc5a5e6663723bf6e8e40b2d2072b2f958bcf30ac737d0d9175cbc3161f4c5b9b0a1f82950c894e1d6af96875f2462373822fac0cc4b5c72d3306765f3ee6f9dde2a2da3d5ce830dd0b88d3e3294fcc0cdba7f0b41db8acee8f577cb81c84a498b9d4e0708db91e3462cc598c2abd870b3f27ab6caa351b5fbb1c86068e60609b9cb3872b2359f6852d25f10a5abd856a9db0502acaeb142012542230181d4271dd04fc6660f2f4917f22530ea112b623a52b712db0e35a9903d0611b82ad51a94824ee0849fab99eadd76293ae45f86454b8214af952d1fc55c29ef2badda9ef55cc33033840d04ac56be84b19aaff79332cd7d9c7bad5b8a1ef313a606ef1cfa8659ce7a1e921021ee4646627b42a504dd8507aa4a681f5b8ef55e83bb847cb17c06fd83d3b8d59183f5632258cec23efdde31e1ad32bb048daf8f22df1e65d783a231e191e86ecaaf0fc5f05c745261116f85db6fb5adfc62b3989a1bfa486c33e2b63e47d09cfb029c647a18fa734eb0e24b4704f6172839147c5c85f41d9d1aebf2bb158efa19defaf60674e4eccb68a2e678a0cf4b7a2bce8de0b05793c7d3ca6c195c6fb710935ce8281658f7a7fc3cfb82f2c1ef5d5688100c6a859a33a8ca6f42b16fe28725b89281fa2a460d401ba0a2dbe2c0389193733345a2c81fdf7bcaf679b2a8d9d85dfeec3282b44e1526969b95caaec19be969737a42dada3efd4d4346a75446062a8b492d6a6a59e3d43d19b0fccd59f505dbc02d43064059a7dce2f30a170836365409c221cf957d63f70f729648f0461237fa50d6e77f44c94de5e1ff9fb743d72e31974fceb5b62704c227f0104d16305233c0601a698ecfc7a2f22f8ddf45f147e9cc18b31fa1dc0f437d6386d5418738e1d02ffcedf9eb1b507d351d4f1a5adea52899541fa44ec38fbb5974e59a17fb3b8a3a849d89c416574ade224eb1ab98af0a1359d0ddd2dbe8c161ed60ab8f726ca350cf2222f655156a9dedaedb705317c5a68472451c11ab91d4490d4c81a71f2433aaba5cbba78b7f9a4a4c8d039ed80ec5837b58c3321e856bd155d8d7e8df2e3ecdec8ccc43321cf1282b683540888fcac1bac4a9f8eb9c8803011644217c58cd9be9f0e8ef4101abcb92e6f5d8c2601e584813eb14dc32dd8584ae288a04f7aa36a862480d4928c1fd1aacfea5dc109211ec9af5b9c53ee7981d34eccf905e44d7956da87e8eec80da47fe947a5b8e35707ca28ec85f26d52c05729a80063df3e983fcb8216a86a7b30f9a826a73972c4cc3c01841e0066de2ff22f6f35e8eba845b48680f9b5053f49586e5a125a56374f8d0d14c2a3de5c5cb525cc91263ad8376d5ffd5a657ee20e37c0c4d51aee813d35df439a824cd953089452d3b8deee79199a2cef64ccf24d9f22587e95613fd6470cb68176017dfffb41f8ffb327d1a714156bf1615eaf7b27a26c4862762a068e3aac8de5a3104819b3276edb83af63dec8b5e08076a189d24e2fb6d74af1b80d7037f18c0b7d9e693f1b760c46ecbbb544c3304219f1173e4b48db17206dbf1a2863beda04ca90d5c65372a533af50e30b74dc83db42a12469cfe2e00f35303c25d9160f2f763667f306d29cf62127640b505eebb1c5416f41cb2beb46ba852be7781283d8808f7fcd4057b43fed550e41df69128f169d1d38f185d04f930de963e21f97ad2aee50a3b55c8192301c851333227e0b2cf76f233c8651be00d69db1505da27288b8f326f21283516857362cb95fb1a90b84b09f460ad7539595e069f0bf2edff86dc15131fa613862e64c50a897167a684c397702cd59a431f7f26edae746c4938709b0526700d7fadf75c3c15ddbd34e7823a7b59c15104c05e91e9e0df2a41054f67ff4965a90b1dd1a31895acb0b192f4f5fe147de5fd9bd5d77bf235904914563f85c454cbd08f53f72859077288f41e95521ba623699c5066e0505716544680c4b98bf06bde6feaf537c17eaae6e1bcbf3f1a77e174957235fe1e7b46a63050d28ec6923105f8712b031d137e5834595c1367b4ad74b1efec2e518cbfea5a86a74e821dd4619ceac3a34356ca177c08dab077345964b2d9c112b24e9236fa3d7514af08b3ab1f405c7d15d19395b495b52d3abd74b97ae2a9dc9ba05e0f0bd443801a2e21e67e5e55cd2c562612568c37840b0a0c60dc1c21bdf4cfc3b626e0fcd92c131844fdd352ae167a3bbadae6eafd111f0001095a5d9427eddcc7789d62e692f324f7c5a20c4af2b3c2f7e20a62ed9ca39a5e34da05506fd23113ab615c6781f6cc08ff330bb5f4e3509c5d07f3a6dbcd3a799b2aa87715d39019bab7493702f8bf60e9695103e01748fe3d5990440363d67fa080c1957b75708c43d277bbfe7c6ef441b27584d8f2e1386ed8286b97527f65c79b332736f8970db27c8e05d4e4cc74b32fff205bab32800b7987a48127cb043cba06b953e1d382e57fbfa8db9c3a0e862c802686f2d3fff7f4073df1bf970b85f3e8c71a9feff8aaca47b1dcdca55e375204598c8e67cb7103c3eefd5816e926963242af790d74495f8946be606d69638b11ad26634cbca7fc914fe29986b8109d8c43d63042cfecb779d97d2ca4bdc8dac4827841bdd54e9093d20de077c10ac23ae7de867dc157674c8330fe6c8a7345a56eb6235a2dc3531062515bfeb14c66c314a989f8f045bb12e0d6d2c38d43c0787368747623fc9b607420d23cbfd85a04e65065448a83c516a6981800603f4c127c48896a158237b4c946a904ed82b78e482aa0c5658f71d1af6f9ae4e108e7c43a56b2a266aa863d140cb6cc565f9bd16864cadf78f5b962c176a8d10844a5a3ef058b12586cc8d00d23b025ae012ffece544f451527d9176ff3cbb5c2a59cfd5848cd463b3290e8f1c73338a628cf7aa9b3db1ce6088a8a9d31a0e16e2e7640551b25cbbe203f69fa35b1db2baa61b8274d26ba1fa3b2acd91d56bed0ca4ede6b0ca1e14fc8b9acad29c7b63e732554a28d17198c590bcb075e8d024c401860f110077f8b6c4528a767c41727bfffa97eb8a431e67488360c407e401051fe186794cc177594902ca936d1c3b434f7601ac52dc7e83e0b3bee9da0b8f1e7cdd5bc14bdbae0c951e2e028a5598eb0185199205e51d4f947fa2fd295b08b3cd2b5f260cd54cc7f7a421e771bf8d4b0b05ec88d03ea123037b3b3ab70fe281a3dd42584627c467bc9ab2230a6148157d1c8d80fcadc14fc755661a2eee6b3b63073379f6c1ea6beafb70dc212a9a71be1160983d75d20ea251873acd550b840c475c6fc7a3dce128110eeb78f28a130f12bc2641f936f19fc8adbd71bdb4be93bc46217573386e4bd56e84a4729b1ac66f55e6b33b735c8cd0151adc4f6ea18b2496a52033f08681eb9d5fdb7eb9c7b1ab159da2640d63f05d7491fdf44c7fa5058b8f984256a89e8f455b53985183724b4e367bf9a66895e76447b5fa8cf3dba982acd2f4f9007cda2e6ceed2b7180eece5fb60d0abf0efdcf1dd0186d97682c8d9985f1ed8c27525f58094fa15779f78d1d96f8ee1dfa436d22a8e58e093e1d09f6a358c14d8ae3428ead66d16aa37c57078d2ba35a0a9bd3dbbfe06f4a581a9ae6df013bd23a2f4594eb649a15aa4c15b4949ebf0f66cc3f74fe7f928529bfc9ae738a9e4e402d8b1fa024675390dcbf239cbf78e7d539a8c64bb51303becf2d0554c0a01b24d1c29d55ea77ec53c2ee7cf8b655580e948358541546e07faa1207a96fd3f966968166ebd17a0d070510e6071bb3885a6e290428c76f60bc7ce9b1ba7eac83d711bbc1e105675d1c0c7ac8d26b25ef336df86b5629cc5b589bc05167f44ccdbcc7de72483d051708738d8894d92d52425c3dd66fe7e9e3de6fabcdfc52952908878b11146f1677861feffbb6b96599dea97f95e2c6f6751d854cd53b2d81d219da6379a9e0ea1d66702c769ab6b13c7d3a7549bdc8ce8c575950a83b37795c6e337d91e29941757422cb0584c899a0d78fc62531d3ad89c2452233adc537f88b954c2e560cb736d85d6ef5a40c550c386201a3a45768a07c30bd6e9c55e1541b9e128853ba52e2deed219c796378c6bb19872212e89ad8f4695a7e378de93d21e8bbcdd2b96f91bed2da03766117b3f408bc061a09329a1d67cdb4d2a5f44b60e72474c1314a144767008e2565cdbe96a30490b841e75766e8f3f8f7688cd7ad3bf7f1909f8b632794e308aa9e2dd208a92d4d99d2da28032eb5bc99b5afa37967a89ff0ddc7dc90982eb0b9acfae65dbabac6685c1444ad2f04f47825645179847b92b535d6defe60c025dafa69b04a1eaf56239220ff495ea43ab79b43f7795579d05343e07768d1c40cd98b3a7847d3c0d6df95f2186d770fa6528e3912bc61a911151fb9e3a82d5cf07d85e9258802a98b67c9458eb346df0561752b9cb34fef5439f384660a7035fedb1533479a21d3856b1ddfc11750804f955eb01423c3fd4e73aa5512376f33fe6f212f990758b8886748177268ab68e7d8d616899cf7029bc1e82ca67284ecd6fb50d473cdd2e69f3bfe63c33f178357d255080f1d2e728e2c286e3cb645c0c90f57c744d04780f3ea4bd6a878aa69f949ce3938592e3a5ac7b8302c491588e0250bfa12134ec798516b4f0959f24dcd4d990f33819086e864df94df9528239438558942c5ea38df219c4b371e9aae6ecd366703de6cf5ce1cd95b2d49fa7ee8b254effc846cbb51b3b8dbcda0a001c178113636489ae1f123f503ccd5371dca8b22719353c8f331c6ae4d33e6c2fc0ccf830c55a3ca1799c8e33b2e6efe66c363f81def37809ee54244e7667efaf2e371756ee785a7fb4d5edc9a2e1137e63d75bd2dbc9620c8f7a0cfdbbb505c4580e96082933899b1acc0656932c829c45e270a1bfad7f65091bfe9e1f95ec219452a76f2fc218989853353ebbea5c08404e8cffc0036269d554ca07662568c2831865aa8e7e0d91d210eb886e4a50968396466b2b7e07ebd96305357565dab9573ed5e2dbeac874237fe3f7c8342cfd269ff936b5b11e10c13e361a8e26616b064e8a51343990b1982efdc5f409523b16781f448146e23eabc49ab2070269a9fe5576518647de243fc667164ea0ad2e6deefada2da16151b88d1c7d7c20c0a7bfc0dd12a0d3e1d25e362de4c88e45b181dbea94b50397fb25a8f53b769d775b6872018fba81cb8c16c76acb80ef693da76af9a0325c7b8b9d8f17cc62e38f5d78cd7e794e0aa0b238ead7f3b0b86ae2adeb12a6d663b8c39fbb9e6f506e7e15569042b48df8d25613cb084f7539ac756c94defe6b75d09755ac2a068a7fe889f7ac5719902e3fc719c035f527d4457a2041a4ab4e19f552cf6719b1a8d2bdfb29d743e262ee83e4ac6c1045dcea6d4c06d034b15e3f797e0bf7ea6c7b017f38c6fad5ccb839c063c258e4f0777710d31426cfc37eb60451e771af5aae54b0379350d5403150de3814a0ad75875eabc45a19c1ccd17c99f336bec01db63ccdfc75f03c78f1f25136cdab1723bbaa1a127424bd34f07c92ca83796e1c5ab6c3ba50656a4fde2759ac345b798d6f15c463871d54131722682aaa03a6b1e7ed69bfb3c842ffb038cde398634c2457a45e209addf0b4e3d6f9610c29afd0c1b3187f16d6ed860811cd8047428bcad5d4cf2bc7d951b4aacb1ba8780affe6d63bb8d646c44bd3b311a370613fa13e99f5b7a00513bfb363ff96711037348365836ab6d603aa6c73edf3a6cd3a18499a6021113fcfd41e6964147a7c32f06a2df24b4020b9e0fc92b7d11729c1c1a60164d8d8547c8b269b1fc0ddf1592c6154bfd90e2eadccd7fba439613366dc2b1a839eaa2776e9cdd18f7628bb1a2c2aee69daef6c244b20c3f900210a7d58ea936bec552c75fe7cb2f33261d809fc019e24168b9f29d2510dffc8bda45045fbfca87f172f463e638e77ae88b3ca0c0f710f29640b21a4f67d56fdc75d8ddb373c316b11f048faa9bb345bfc457c353fd04a0669c6119cee320112d3484bb5bf44cb98c081b05a0f2413ecc4e83ab5e19c859e1b24269c26cc3dff8b36c1a29d17cc9b63599c225eb8b69626f33cca003aaa4227fde1df406626b605d98fa9312898db29481adb99bde3643ac116cb2d76f966bddc60b20ca6f542ec91ead5d15e14ca0de844b20e20757375cc0c32c2a6b6c3a7f7d4cdc4674ca7d8f868df41568cfb4ec790718db4e5853a9028df4c512ce67de40b42b156e94e049db96ab6c18b023292df004b188e65ba8b0e579a21355758241a8e8c5d15445f6fb7a69353ff74d0e92100d95519124f469d8a56a1e610e61c04ca30fe2f7fc66b965a170f1234532d5b4a9ced91e0ab0f4883836914a008114eef3c743ce5a8ed006c1c326ebfff630534fb094318a942af0191203ba0ac9884f8034eb43751831ba5822cb22965454889a3dcf456d0c143761cc117129574258a40aa06ee70548f8264d0fd6448a78cbed9d51a9c60aa52216ffaa47ecacf8c39974863dea18857dd7716685b39153dd61b3308e5e3c5212fbacc72d4ae2d2a0d23b3202c4c92168b3f37eb836560f1a6fc9ad74a7984f3d97848a5e36e868a2ee61ade4792c769ce7df568d92e0a4e0b47641473aab44eabc18761c2aac1731d14fac6b1f98c3a0c99bc7b9de6bd40efa8db6417cc526164afae6d816ce58424479c92db0beb7ff6b1f29970ee0c03609927fa1eb1715fe51334fcc1dc095c31f66033b0a9184b9daca016238fa84fa3276d89889b450a4c19474414d3ef74010e2eef2309c5ec854353602d42eb1d1c9ab9cc6a369e820b6a0606db107c33b723a4cf3c29bca16d7cf69f74246cdde5fe24e59f0eda32fd6b7aecc44ff1d83369d175278bf80a6f17670522e1d314886d4876a6a1e1705042c0a90ac38607f4a6b008d5273296be3b6d81086544df0e9b5efcc7726b94880619f62788fc7602e264aa85d3f68d0265a75b22fae468f230fa948f63722a401417fcc5ef4fa5735a28b794ede1f29184758976ba09ef399821528e5f8eb86b5fd1ca9a6ffc5652c4020196bf334ec2c1b37a06f1b5a0898a79732c0c5633367d3965bb6aa507b10c24f0acbd4755f01857cffd0d8f075701ec760ad771d78b640aa79db093d3c79ea6c55dba1a071fb0521e0b5df3d29042105ad9050e890f57cb890ec77f9a6bacf6b007e097d8331a485f54b5f6c4b51918cbc7ff1d20166cfe056ca1e2297150c9bf5f53a2d0ec6bd90c66a0eef3fd7ce547ac6eeb20cb73fa2c5dfad8e869e68a779dc5ead7dce4e5200877197c8542e0084717b3fdd17e4dbea9c66f0f7113b526038744be71c35c6abfd633569dde81ac1e82f56a3b3339b1ee11ca4392e161fb3ad6c9bcf377096762f5751a94236b731f3588c4c7114d45a65d5052247b7c48c8d500933b0385b6aad0c15e68160ebb1734fb2739778d1ea6f9a33aed5dfe4bc036e684cb8bba17bb157c643bf248909af76695669d944245c0438c9c49688ff6e5f23ccc65e95ff976f487f576f7569115c8ef0db2f9de93045570559b127ca96c3aaea65a8b613c78c2d524763e649e7894b58fc3c5d76ae0381a62096ead24f616298c73a97ce47c53e741ad4c8b57be6a3a5c89a5798ea7570107a03e95352071c53fb98f7a7e9d9ab50ecb16884544025d3e2611c43fa26b323d451c2a6d52562b6a45ed1de2f4e0abdb3c439599431d9d5630165d0b5a43a0ea72eac729a2c1ecd31360dec8eec08451364221f0a334472e79b63051bee297d06dcbbf9788509a39bea5781b488d5fc3844367d5d96e7b363469ed562e710395cb3bd28fa97f6095b8b17f1555e8089f9fdc51b1632d0ac5a35228c46b314fb6d15aaa8427095c2586019c914b09f982d4ec00c6d04ccd4ba831f54546a6cdd002cfe0d5a22ebc737fe44650cdd5ad37894de6642fc2bfb67c969c5017133561ee128bd6d6e4e1a0130f7623cbbf7d4cc0c962fa075c8dc0479c30ee8c33c6e41f53b6cd247992832422727163e162ca042f5ba0f1421703cc20e0c72b489b49d5da304be71032929ce5aa6d04544734b30a29c911de5ca321129c3a15572923eba680d076713ef3ff51ed1136f8c7fa7e0af232d4ca13ed11c0145e4ef44dac750e87fdc70e3d2d5dc2c010ab41e2bf763abdbfdf389c4ece0cca81d86f9078cbf23eca994cdbb5e5525167628ce404d28df7174dec2f4c7ad2021c37ed3b0b6016e39c6570db1499f932e57004f48806f860e1d7acc0c4594f8cb5d45a7fd8c18c4dbc6c39872ac7b505cc5a510a517773e6940c64a3e5d5fff91c33e0781d8c3a0e2facd1011de68b5de4517a5635334e90ffd3a8f415099db7b873474a9b043adec72289ede20e709bf88104bdfe8cd9a7cd003c65f81a653712e764f1cb7b2ea227022992413d0c6f92a111ee8f2da6608ff25c9bd90b8f583085a792034e5dabbf3c0c36cf84a3d84b021e74b15709084dec7e9cc42abd16f920fb2528a1dc491aed79f71a077b1cb5820e5444cbdb50b046f05ce9cef9bddf75c206e5dd474fd8ecce7c1217915f349a4a9632184b31e50f783e57b32714ab10c1a68cc4713bf415fc9c07d10f62076f3c23e4fe3f58c28ca0b51cde3381197450a511a293712b46ee2a73dab722c319eb0cce6cb36d11a3311033fedb24d23ac148169afa3d05910fe78fe3b403f6eadf0bd42298c082d3530a54cae67ab8a6e2b3f5db87da8859c28f06aa73c650097918db84c95f5d1771b3599fb03e7b3bdea30df3b3e8d5c88de49fcede40616c3075a4c15734533ca2858eee1fe3ec75eec45a057c147e3ea01379ea87fbbf0da2d12be72207ce09c08ccfc6888731ac8c5d6df4b5e3f6cf4f38f109324ee11705f8ea5f127dfa45c45a0bfa92b0b2a13db13e9c1c9dc5a7f4e08d1c3828c5648bd8d1c431eee70800e2c452fb0eec8dee72adf75282d6d9d0ee8dcc62de45a79a1391c82c1e6f46c6b84eb6a0485b6fe370fdb7f610885d169d0b5ec37205bb21564549075cd1ee6ef6a990d5087d43baa28331f4859fbe9aeb2bba66fd06c183be0b77230e97ac8c7e8f95f98265f20f07e5d1d15172aeaf710d3d88a796f84bf66d5c44344eb07263dedb999339fa786744f0b9747f071b559e513204be664fc005b4b68a60c7c0c90e2816d58cab6cbab793ce224a112a2c7612b552c6f2d1592e1c105ab15b53f990a3cf7603c9d4e6265e52b2f317c3531a8cd2208b573c136b7486bdda869075c94d208864eccb44170e5aa0cfcb884ac823e801516ca326f15c711e834fa3d3a726aa90ee35c16e2dfe70929827f270129511777fe656a113ff727a2003f29cd71d39367a3c8f5efe1fe24422ec6ba7a74699e6a5a2c0157ed5fd2c12a7a96ab387284bc8524c9a032ca82a3cc8d6042bf3a3bd41c912f560aefbde8fa2911c6e5297c26c72087c4d39507b15d58cae7f6f3356c019078bd4667189283f9e79f0aed45be57f3a4087fffbcf401bf0286c6684621c7a10e799c9b1951aa7b601e4b2f14ba5454dc2bb8222d999d97b351717cbf80f795cb800b55d75d7e09a945f04e20407aa052dca768d67d2f7e7f3d434c6265afd7dcabecd845576812afdb02eb4ac3a82eab6ccfad097df56ab56a7ecffa323eeb41b1618a6518837507ba575bbe700473cf31717d5ed63f613628e068a81355b4fc0f29762b6e476910d010a644cb869a6e4d8b68e561ab32be5f27903b8e7dcbb68a2494f19810e5d57e11c2ce538e86de0ab8f05e62559f10688d2467b684af45118fa820b0ef77190050f3d6f38e873ca117deb8399128a67e2b744b31435d728edbff7f62f6f8485943eb6636b7993b391d458cf8c42ec19d299d63881b870b21e0a6770b4daf8ec9bbab04e799f875ffc1f94ecb01959fa0852fb6a332eb3ceedd1abf5caa0b41c40d5102341ebd5c370a12b7dd92a78fbd36e4b3d4f3e9f89179d2f1dee12c9646f6e5dfbcd9345b4d91b329aa1b97c11d27a582845c933fc6fca55b9d178a21484768d819f1c53206d23f4b0b6c88c82987755a84caa01197b506b7dc379910f1366590d5e08166cb6ac25e2f194e6f670c5f5250ca9dac70ffeac7a5ccd64a3f6e9d835aa1eb80f42d5abf20f5387401b2c44697d8cdaeafeea12f14218f48f0060004421fbe53d6601df3f0e7edbbe74372b893a5526967b4452e7c57df6509581950d5b69da764df18c2588581f9d474e968c4caa472a49eae887a6a96ecde2ec7e10aafe55099b7fc30fe5312ab316167f12e22bd02c248bcec15c197bc9f953b751d02e411134d814d0189089f47683d5b31ad31032ad84eb71198ab4a5d5616b7eabb971147dbb1c7510d555011881b50f467d641d45f870740fb4f56381e8e9b02ae0b80af4419d587549c42585c9d082ab28e3a4632c7b66ecdb5ff76c23ba524540e91f02b65a9db44c44ceb8017cc8b1d76d936cd8886d8342077869bc1399d9e93fb5eafed6edd5aeed59f8369d20c5ac3370265566579993398768cd6175c8d064f811d9f2d80818ee5f09b60fe1ad908f945660cad96c43271b21efe0985e9f2dc62555a6572219a94a119923be1520c8ccb7b5146617076c560688dcb5f2ec07d5311d024386ac79c195857e9ce04161061e00ab6434d2017c4d33cf35e14ab0933abd77fca36bad6c3ff43a34618740cb7fbe40dbd4517f0eeff2b9db045f7524d4c7f9f6ac7627053fd2cb9086e3547392dc23064dd81bf67c2b3e522ceac1f53dd89326533764f2b3b4678211773ddfdfe1caf529663d4d74079eb6f5bdfb0afe7f26c261ee8f6b5576c90c3f6f02f8821981a2e26fbda1c65eeb92c14286255adde87493172b4f55edbd4796e26f2370835157cfe9d4ac926cdaadc01e26ed3f3bfa3e30b0ab86add1d24bf41e7cedd9b9ef0cf271275e1e71f4ba93bfa0ce21e0732e6851dcadbbf7f557f5e9038be2bde3a1caa53fb2cc91b1e4f1429abc8bc429b9c2f8f42280055a1ca6a39e723b4c6c1d309ee32d7156ae1c255f2482cd0128dba2c98d1465e6d6109ca1b07ad89e5d4f1eebee532ef79c6adb5476c38b2747fbefbc0e48010e68ba217f33e5cfaf70aa84f2fbbf06d2e6dd94999483aaf47d3cddb767b090af07e81a55983b0912e43266a250b1fe8841e8b7312c24bd4422dfb4e74b30be188875b29bf7329fe0b42ec5a295aa7394f0f65d81ae2a16118a4ed99fb3b9acbd6567a67d7b6874703f0d1cc21c28caade8de88d17823ef5b6acbeb9cb18fd0df2a5c6629a7993b8746e438dc1596539d783665b922a4e569d924a23df5a55378e826eca62684192e3bbcc546955df6e03ac32dd0d3986240d76c756ad70d391fe96c8c54ac7515d2f83d68eaaa959489b8669f9b15d614c22dcabb44b800c5c065f39d3679927fb20a11eaf5fa06fe3b42ba5db0ce61d969526069d17869de8dd37e4add4714de7b908efdba004a0fc6bdf70022e2cce42d76d776582307824e44f125aca1e9ebc5835c849e4de400acd1c57783787ffd542d92a709e6c845d9097d344f07584e9eb69cdfa30464672f72d66e923a89d3b9c7d0084ee9cefade5e7eb4ce6ef8252eb4607d38ad23c58f4d4803a972b9273353b571d74ae3ccddd2a9ea6203b9fcd00a0a250caf2cfefa4c39e9f058e2c5e77f38bed6db040558b79801b65c50f50275f9951c4ddef1bd6467e1bfcf9b9f89853399d6a7aade4978bf9f5fad6b749ef1b19366dc18f0a3ab21eeca96c6e508cc041392a0a1198df43ba4a211ad58e686204eed8f522eeb213b439554060561ec0b2afadff7b82756baae3237e51c203c703fc6d8cd713605f941a764c70f0e4f56ca8e40536aa295a543fa35a053f455665bc070d708996d2c0a04eeaa3c7e02a8d66219c150f4117f7b2ca3c0ccdf744c62c96e2fc2fd031cfdfda49884cf0085c175611dd1bed9f80fd266da0eb9b6c09941635cf6ca7f031110c20855eaf48502a8dae28848209686d726cd71f2e3c81a6bc132a9ce5c466f08fd6e85e804a21df6736ecafe07d2b973024e407e8e26dad3ce05bff09539298f1043b289e8e551b4187ab6b1beb1d85eb0f14a4686ce84dc8a5c30e967f43faef7f8db3da5bd249cacd773524bdcadb640ab31ee6bd760d4f5907df6c63cc1f382b1cba3ca938de298aa706aad1eb6559a7c065a31dad07ee8c380940a0a8ae58b6b2fc2f8be3ecd53b6729b0911ac4b1390dbec026fd578c0708adce8769ae87d2ccf1166b005827e2c2ab94e603819f919ca07b1fd6a72894b028989b0eedba296ef5b77a3f97a9d87e45706f5e529c00704c2a20f921099840e08e6d7bd84436b5fc3299ef8efa655bd363a46f737d7d529c6dd16fc89386ceb7477f677c315f6311400857b83df36705fd28f1a4639ec1d5ea499fbcbc44698754c434f2afc78775bb56805a01068258dfa15149a33c2c8374367233f21dcb85820648450d258ed87b07a1079b23d0a5f1ad5381d680f512b5932d382badd68044e33731d447443904f07b1da1e9cad102923c0d1c3747e9cb5af15454361b534c2e3c12dd71bd49f86b413d3fe34df45f9611e573de6a3faa78d7289b1fcc2948be8b49e7c0fdc8f67d2a285b861c00c7626b95be6199ecc0d412e949b49eca49d4e6d3abb4ba3810905561454b2f53e682dd26c15cddb8cca54ccb1e941ba9ede8af43cdaed37a6dac46c59193c19e2d006a89dde7f6472baf45ffb4e6d36cb35bfc3fc95c8b9680dfafb443a79f53c27136d472d6e57eb4acafe268643697d1316f17ae6f27a185082eb3d10f2150e086a55860b78e8ba09c3d383a2a386525d34138e88c4d2860d12e9862c51938ecb932f14eff0ebf91aace643c72aea95cf52460bbbc6333623e227e03ee80ec8163bc633aff7098a016553196dfb6a70063fb350b4780c57cae72331bb37fd9b770a3545103cdf061f9196afae0622c7b6253b239d4d7ec3788d678f64bc2b69b09c99f39d7baeb003344bd4a5c4bd0da137264d1fd9ee36116e43e360feafa4a30bc6bf3a08c049b5251e6d261d9522eeefd25d075ec806ba95d287d20e068f5108cd0169e278e27b8629bd2eaf219f8e61a923a29ef4682b86bb729d90c521fc57aa090bc918cdb0e1981ddaf071737f8140fc79322a1b2f5839b8727553b8523656e3cf199ad46f42b4c5502a62a0e24d6a8012ee2e9af18296a9202be23992b3a86a1f104d02b427b8405a339b0195f211d49dbf629aa6f20fce581734071f7400a4292539b5cc5bc5f974d981867ae669dd58eb8eb4cc235d0a9211f250da336b7dcd4e83345953f7892b4e14eeb8b2ec2c6cf8dda9b7f095c7a2e71b451db5c5aa6cac607c468868250a303c8d92a1c730cd857fd356a3b507600499cdd46925196c5646ef1885ec179698ce7d65fa21d2902f2a867ef4cf8169cac1a30d1f8f4487c8f7952dbb9199ca29312f4d8a98ee43b42cfe5ce97268ca63e52df00f2c3db8660272108a962f40f1e14b9b5015bc4346323cc8704b9645aebdd50c8738dc6eb31eea1b6d942501afca7858f295315e1267b4d6666afe7a63abd30ce31c5ca572b64467f99bfb07468edf4ca8d5679126bb9d8fe1a29fb47c65612f38c08d44310094b2798ba0022eda76526004e3879de6a22eca0d7986cd8dbb7a03d221421ad432277471cb7ed44c329bab38fb74819e1cb3e708a0d351375fed406e80a2e0801453764a0debe57c83dd4ec96e66c8c8f75bba99fbdb9a3250be7c6d2ac315ab0ed4c29ef5fc389a49efa20df4f90fb993c4699059d45b881d826b14ac0bfb7e12b6eaa3ad2415093a5380f9790498706289320007f451fda913233f99a1acb93f0b495d0845e955eab3f83375cd2d85fde92b6b134930a6a61ffa321e0c717ba6dcf0e653b3082aa92c1329d24eacfcb9aa37193e8b84fd649b2faa550c81f47b6be3d81782241102ab7d62f1f68cc0d35a546b43958aafd940366a283d5258985eb7e299fa687d6ad88b419b669b4eb33ae069ad48808d11fd2d15a7ea7250180e073bd6fdefd3b5b1b0b23d1141d5307436980998a18f0dd3884fe5bea0878adcde34d42c82400b46b6ae8202f3d6c5db9bb80ccf482e6e168bc5548b00b5ef002b83b10e51b9c090d365aec75346b4032bf89b83d170322987741ca474308712dfd67e52ed0fbafbdad6a7ac92359c176e4ae6529707c752983cd51d0b1aca3d82673f19fa9773ddfe408e96aab5e0550f56bfd6d8700c66a8e65ffc529fbd49cface4104544975c6c9dabff4724fe625c5de60177704033fb136aa164acbfd721ebacf74ba7b5ec2a5693b513dea9c2adcd22587465934f88d9e9fa16c15ee9b7fd018dd066d819f270c5c254ded5f62f1cbda67865f258efc90301abe055ff275b92fac17ccbbcb37c0e8a432aa6a0fb9e38abaef7730cf8e840b24554e4f0c4c2bbb126d0cbc3064d1f7b62ea4e3341aa300fe40bd057435f1a33606da8128b604fd6256ecca7081eb70709e0fb8f5b0a2d44d8beb4bd7ab432b67f5f80c230de0f2b548ad7e495acb8b0dd94b779a6447c422df0ede1c3cc32bb03db36dfb78d32b3ca59ecddd3c3a028c206f7bd81c75a3b95242e03b0fdf1b301c2a831675e03817e8d8db99c0babb3ae3483e904f01ad132f55de001a49e0fe1c88c06900ca834c7cb22e76df7eeac2f6c3a4bbd5507fb06736aa4f0c40ea07737b87e3b9327b7245c56b708c2faa7773ba88a33979f5b3474cee29392461460b5bc4690e94022f4e5875e62b2ea3364ea9cebb705d3a465122f0e21a7c4c9ca55b715276fa60009671d30344500ccbdb0b98c3b00dbb2ca911881b21b382872125e0a7c3c938a495b85a7e15744fb915bb47c5326bf381da7a67a88f9076d8ed1da27043443cd153101f8a70c5848fcd2fa3f80a9010f0323b29dd7ba49362ce2c022c784eea28680a4107e20d4e2f88d19b0a5f7cf6bbee1d411bbcc132e5eab1a29a29e4b6770532d1aa2d6ef4caf21ccd630cfa9fa1ca6bb47b538137d01566faf3d3b6acfcda5f9fe9575f03160099cb3aa6321ff2bc3f24c1bf48aeef44b3f2c38893f9c18393ac07880b197d93f6b0aadda76ee2ed2280f91c3ee0fcb12459b22271da8b96d9ec97a91eea2c5584bddd5ab328b55f5b9370c0fd54b14690a26d87e0653b841ec58bedbf1a6d072a5c56f9abf172a755b88c1b186920f7071b933e1f58673f64c2eb298591deaca34bc977f73218e75cf53ab6e8191786311eb153d65dfdaa81e690c223611ee7c701c6f7c9119b5945365f9ad7a9dadb97f93e25476336314f769c52a16ab78848e3728bca6456206cabb08086e56f7a92545e136cba3fdc01977e7932c4fee82b8b18168c20c3158a4ab76d10c864c643ecbc7a3406c5955a5774b0b2ccba84bdc4623a55fab5bcaf68c4bd340012b14d90d0d60498977ee31fb196185db91190d4f3d9dd43cece8db0fb1e5917b590844096b910a30f1fbfb249f3e2d5b51ded190f42ccc8aede05bd22e02b117da634ca66bc91f66dff28f38d281741089eef2104404a0e8afda3c70d563d58e0213447bcd0143356c2009ae5f54c37d5f8d0ccd72985bab53a25985754406bdef53657e3ed8d7a95b9b19683b63f8adf237261fef9b8159155ca535aaf3e6e7ce88876f915b1a4f67999cb68f9c2e52406fb5c69a5dc46c498af3295e72ed302c4703f08f0ae5b5e7f5fb0a5743145907978b358c378b7c1f1a31e28d274d0d8af8f6433114a052b786aded13abb8ad1b83ea3e38d184a2a602302d183f82d2f7bd5ebe4b8b4b8f356d9acb6adb11898a98f764a29dea96a4c583c32d8619b620673a9aad35d356ed01d62e0a6b0c8c831b1316f7d3068f7ce532fce85790c1113f0c2b14f244b6999b4f5cc0007d5fbc3d8757d20b78123a93f3ebcc4088f46dbc16f2ced1badbcc35cc0efd13a9a9ace9575d7b978f428685b29d8c97b2398e42f9accc3db11594c462f8b37da4691968495b1cea953a542659bb14b5aa675b5b27ef2abbf50391e04b42b93a85d8aaa2087bb9c9f108c2df00cb7e64cf739cd86e14175d3ab83b219877d61e1630b3f5a0814bb9ecac93f711e99d3082f5a94e8781183b09ddb33aad05a7e1cc2994d02eafd863c5260753ebf47c99472e67af028003173d36995f7649f3010584cfea696ca5eedeb3cc5814d67b0e0c742fb7346052ecab27935a59398b6a736d1fe53dd55f7349bbff756cd0e48f6f8bc69bad7cb77b38998e1ae1b090eb8e920e027fd347a39382b2179cc18be72b2d26b6d5ff5ec27b230c2265f0ccc71cdea4c686c9a6572d7acc86dd49d5bc001b7fec52d69378cbfdf961c91b14ebf89e75736d8bf401ac0858bf716cb8ea4988bcacb661c4bd4754a044ae165e804e3aa804e667d8d6b8c1579aee7ab318d0209a1f4ba1e42df53308dee7e7e40dcd41c19f9c80ae48503231a2dc93b0c227931e755df73f73adf3a4a1779ce8b0925339803af7a244ed649adb674c8f3c0af92272101b8f948fbf8785ce5a24d3b09450dc7dd61883255bfcbd883bd2f30aa60e204c12f6f69190b45e87dd75e3a4c2b7a9fdb5b95babdf549752098f00f8f01e2fdd100f34141a8e1b6bc0e03bcea2c7495e65447631f07a6cbf386a8842b11a0ac63fcaad45c07c7956d04313b3ddf0749d9a1dd25e709d6364e49c5f3b37a476608287e3afb90166267e06d096b20ad302991adaee5b8bbc659bce39d3807157b56b536af9b135138b50b37a8a93c5f84df543177ba7c3e405e9e52cafcf27574ab1faa7fe4ca7a0b91abc48fd30c29a7e09ff09cb0875c358aa8e6bbc90ba87e4a66ab334ea1e4c9e88dd88452cc706b21d5c796842b227004bdeef85d8865a2115c9754b3cda07b5e11fda1959dbdb530661c9b19f5d63580f430ca4d132bfbc583474e05e42194d91e588c3d9299b7900418fa57104c1aa93916d9a6b160451d830a37ab7ba175c1c70047a477706c6acbffd21d5560ba05c7233ad80398ee1350de03d979dbf0873ef47a34d40a4793073b4eb5acaa20d2782b575a21c083bca67ff578862aff0d7f21419d3a76a904fc0d497e31f29ab0286e80bbe0f8e9a7bd0ebf89eb80ebf99966cb967a780cd0c6de1135769e21f8dc4677536db34c2aad1d758c6f8a9d58ca2893209b40b3a6106f31af06e5c0eefdd4ffd15e07e7c3a10de34c98159b72321e29fe272ac6ca86b509300965cb66f1d3b5db0cb8d6bd3bcdc51e65e042d63260f866640f82ff48864fb160dca8a5b02ca5371b4011f5ea86aa734d48901ccaacb2b623812306e7bd0ca0d5bbf099ebbd77808a77b63b49732cf95d27a49d79f9ddf1ab146b0a8ea855a7982e6c5af1b82126754c0e2d6ce3510744be557d9edffbfe8a65fc3a8098da31a4d9826220df7d3a1eee979f218ca4cdcdeb871b796eb8527f32486d26a0127d7897b1f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
