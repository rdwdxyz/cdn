<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"645cdeeefe31064ffe615ae6ae18e77af9e14b0a15683fbb3ec5506bdf2ea33c1ff099c094298a255c8c105b970bbbaa417675a31597946bdcac8fd8c574f9fc49ad9fd1a7b4b029cde2bc6c143c5d06d064b03463246c099652dee9e90b58c0d8f6674cbbc24b17fee09b005dba5194e705b1615edb7afa825564df8a2e207e08fc5d3169dfee8e9a799cc019b7b1cff3edcbd643799a1dbb80875da4207206b708e8fe5596a6eb10b3ff1ba41b9d93765d08c6ab4209ac8fe59c66c37779c0278bda11b724fe3104ded036a1bf9a87ff33df1926579f26518c691c7c6450502bc63734266bd23dc72b80949420b0405effb265603ac50303a501988d3ee7043f8e9a4948c0d7f7f32442462c96321650a9a5a2072a092b1c6d008e55edad7bb22bab887f70af4bd468c7801b1570b40defe0f83f92a8679a55d0d5ae62ac342670e179ed850f8ac26c5277888279d291efe2932aaf0996b1ebc808f385cc5c8e9b0576dd17ca16a60ac05ff4fad46c01af166e54f4621270142050cf72ac2f49fc13189ad826742b3b8c7ba6b13e57592a58ce6e7517d45da29d38813a36735c6bb7c60afa3a74d6d36aaf842426fa6adaf746aa8dd1412b9ece1b50712c4141f0761d3396fe74f21e67f0f6e3cef4bc28502df35424af89548abf70a5664dd427dd811d3570ca22e2058f3b8a44bb525e2b64c7fe849adf7070a42f81ae28481876119c3edd9226e102c5a0bfcebb22be480ce3458f0316d3798d1c0b34260cc03b2dedda3dfb494a4f76ebb08786825fcc3e457442d258a11e01a25157fda9e0fe49f07e7d7d5a4fdbd3db3e7aceb692184f7b97d85b45cfc7ddeac05c591f750c950f663a92f64709a41b3e21924eb4ab30aa94e3c1ba97f623c4653da47fb725d9f1ae3c734c2d3ad9abb18b9019adcd1916dc77ed472c9ac8bef51387648f52858b279041085fccfaae7f255ef809dbaec588b1d5449ec736c5b38009a4fdf28ad960fec145314953a5a4f4a8992969647e8e5d97dabfd66e7589f16e52124c9f981fe99856b25f8e7a9564fc6f85eb173e43b5436629e0ed61904b0d6ac7c1d41839a57fad54f11fc00cd1baac106664af3865b2d557cfec2be5ce3557953797c401fe830e5f04e1304c36247e2177036e6f389bd286d905eb50d055993705e0d8571ede75f9367a3cbc685fce3698c493841406300d1c3252d16fe9530d84f4e968f60593d89cb28db9c57c18a8e21ceef37e7d7267bcc380955468ba8092eacced62a70eff2b3ec3cc34697679862ff53bf0b3469c7621ef71f4d61d92938e556b66af9bf701f7b1825331c8749e82ac8709c6142eb8ea0414f6fb5f14e3327a5aff8b02d9022b4b388ee2d5ad1e6e4bbca51908beac94f355840873d27a5695146eeaf8f263a25ee662b7e975e45a3a9b7d7c512a5b9a382396922d0246c20c8b713c18f16ce78df22be2899b3c1460672f42daafa912c7d18f4c33e0e75a924f2079216e6ea1e5fbab5aa369ddf6223e55cb3c0e2dbeb4ac9cca942b745c4d4e12a5a6046b5a3993c629b79e15d2e68504650088adbf167fe5e00aa31729d56cff931df0e37510b74ce91e14d93354102beb9ba0fc6e198fda48f0d5c00f38776d479f0fda0e7ed1b6fdaf1444bb01200fa97560179f0cef37dae6b9b2b5e536f0f6dd3f8b15358fb2a28680e3d9acc47e374679e9d79a9f17436c23059991d3996fdd559c49d4346eae2433f02fab2ef901b41c21f63185e477fa207f2adce22b96d8ca0f0d4e0ab86a7a1cf8ca2681036378f80b44033e8915207bb1a1419dad4ff1490a48fd9612532f1aa5e61131906a78cabd690674db801600fb0bc30b5941790dba5f2d52c659f422c8c31b6e87fd27db9cf2d457db2b36d8b095537bd3f9e0d257116278fecf479e71662f68a0793fcf02031345ef54d9a3a60baaf1d1fea88f35cd3bb90d10a5b691ea73c7cd992a5179a9acd642f3349f152854fc9cd4e743335b958c82c75e3f7e84bc78ba0900a1e868830aee87aa56f79b1cbf288f924df7aa162dc3d220a22d9ad0d4ba12881328e86b6913e456506809a0ce854f9f98667092ea687033ce770a75eb283dba54649d3604579c17588d1798d72d48382f1126087252d557b581d4c405ff79e6548a62280b37587af4bd63e7654dda4de6a538e46adbaa08655f41e222338aa2c89aac38273b5e207b0eb67944e72e04727656567907b7e5aa9978cc3e2ea59cc105d5418b8cda4c867bc26e214f0d6233a690608c550f3d7ffd578613025024df73af9cdd129987cbbfe9292d02d092f7055a1e6b1d9eebad356dad35a6e4398d0dae4cf16e7879a1e5b1a662c9144543d9d9e23b642a0a1ba299fa01aefcc5b8021fe361f98c78afaa516360384d739773a3f0ecfda29f270c13357b970b9571f416fd4ffe42c2b3722b5dc4b6abf8b9e0bb7967234338bdf0f7f518e1b0201f6c42830ebbe2379e1726fd9231b48e8b5f3153018dc94d4a80eeab11d43a99c22f08119bcd3a9b12d343c55b6935d1bbb0c6041285040d018895c83f77bd721923523754301f0811295db642236cfe8433312540763bf2411d86248b9f5fd0e45704021249860e1dccec8afc4ba0b7b32726848812f4e0e0647161ef226977455857c3886ca95534f439a0353b14d52ba0b96c53c0388f713a4df0fef8cfd0ff6ddd226b9a5398fa8078fb8d0c1663e13ba9db3bc268cdef46323358797e6e32f9e84eae802b931c9fd54525e38d24cbbe907dcdf559df9e5af448dc118818df7d567926fa98e326e851f4dc21c336fbed4d5720dd1af80e0b53865c5ed1d3be157107c337a933421835e24731a13f07a6ea4c074a3bcbcfd7b2b369926e4d657dd5f85e42c6c6a00c6c93d5b29f056361a49262115bbb648c9b34a19f76afbc9f5bc731bfc0fd7bef18fcb14256a488e9ff521c1e77cb7bf83c418524d5f446582b768d9fdc1aceeefd65ec0eb9dc1bd0316bf0cb2616a59a4b916dea9ae9db2bbab404b82715a88d06c7fa87dc7049ddeaf90e8ba83a2a6f721c0314a3ddefae83e0f2c6b2ac54c867cf6ddaae91aa98e6ca177bfb837a147b077db285d226c5bb97635ca5afffa5a6f13ec0d71702cd2340228f749b11de7212470ea2c02a3b68a27bfa9401335155fa4c311f7e0e060df965f851709f6f360833831fad6529252a3f290c158868517d3398a29d3cf3c482ff98de41a62e8b1414bc672852e1d526199e93bde3ba722ea7b67998bf4d9ecdc593880cec9aabd10d50b5897edce5f90e620e721c0af9e6ed9c118ee9beece4305ad2574e0b90d213dea36f268a98848f25715df449e9dbaea7feced48275e733f6652af70db9db1c4d3e0ebf59103933b5ceac61bafb54e767b4e918cf79f50ae71d9192595e10fb74fc9795ca6301ad34def096d67b86cdb210087e2ba3aa3647f79a753c5f96d768f20a277134425ab0a532f8d4c349ac3e475639433c7f7df41126ccfbd56acc32897138242a11e0177bc5cce214400f2cd95d8e3accc8968967617a3cf4cc515c229e34b0d3f39f8b091b25d14e18b56e6f458fe5d3c065530dd0e733c649466b66beeccd0405f89b72b959af5c73457a8c55425e90ed93fcbcefdb30bc195288ceeac91e99dded552c29f02535cc23612d9f07244b583caba5ecc9932a99d310e7be34b6759b43b56e71a41ef920ef14335f92e8730279e35306eb4a6a9698d9533dd7df7075ff13b2de7867c6481b7d597c07c8135846219f6609f5665160d6976c2542d073ab66a6b6ed7222c8ff66e0ebc9aefbc13500a33b7c9345c9ab6a7bbfc281757a40b7a9368df48d53a36e3300912a992ef51f8db06b6c871cec0b5e83b139b7d868a7ef8bac097ee0d4b0504b5c87487b94c613074dd03ada86d52bcafd276419bf9dbd6bc2e964366679b516ebbebf677caf6c8eaacb29159bfd024bd9095274e9125841bd495103989567cd19ed6f40b80ea43aaac1bf5bf084162b477d9cea9f971d12c2ec9ea1eb89dca901fe4349a06347a028e2ef7021777a08e2fda19cbe86ab4f350db7bdcfd7c6ecb394a16aaac28e964df922d9a7eb0eb27e78d6c46721c0bd2a833432078a64b5ceb4468eb579a00f77c1e55e8b5010244046b09950f7b04052ea880eba9f95f50e8ab437c12e0be618d27d4a42943143a511e061ae0081c6845e683d4c9cc1925e01c2154e3d5b020d326bbbf99459ecd449b788576f7e0de48666b47f96325a1e5b5cfa1d7d1454b69ba797e06164c0f2a1a92e801c42e49f79b97c38853f51601d7c2096ad6bfe5f9d6c2bbfb148b61422f0c711d997349510a0afcae567b54ed0ecffec9e87b6beaf4bcc3068e27d9b97f06f82e911e0473cffada7b5e10d1e157936efcf8a8d717a6cde3a2b7f84bdb4986142564cef9769876f7291b19ee15392058d3d10c58b49155a4c2edde13c23e0014c096811666746d8a9d5afee6c1e9f2a3b797bcb0b113b548e4cf413a2162bf8909a9e6510b0486b2999d05810a0a63ca5e5edb7803fdb1420f44eff404576303eefaa59788a9ac660bb6750169c155b5664e0d83e4730d1c6a0b718c759b4e67530e288708003fff17327a8de3efcc71cf7466fcd32826839383646e4bf1016b0e3a78a18538e2cded932e632d250e6bd9986d13b3c4afeded4130123deb6feac3866d0ead1eed5430551ae0bb32bddd837dab77c36ba6be4098db050385fdea1fcbe6a13e40b35d1c9efb9bc139654fa32e39d1b63e46fdbf603eb7d2fac9deec84f34c37fa900334d28d94ca5391d5819b70f7080538f38de38c5a0268c857ebe82c0fc8ee4e4ed45ee6c4752a429b25a44bfab1538333b5648e9a655e1aad76eb9bba0f3546e7cb1c3788089f11344288d7a3c8f18ca232407f4662a78551ad2063e8f7c0007959ae56e1a3d80384a5ffd39c046075380eef9e9d325b3fb561d6466e26de32cbbd97d1035ad5f0f39fe611070a666edaa82733fb02e42f15700e2f342ac4eb484ec4a3ec657b8f674cf59d58e15aa1d6c7d957b1de9fc06a9f35ed33fd748be18f3c0173297e179532fc12e396f429a2e3675eef0b60b10de2662d50c65f38d2661dc86680293aa28ad7aae5f6e24890a490d6fcdeb32d56dbbf50cace116aa89109c414d9db2c41c6eda2d84d2bb369766ac8dc3dbc18bc38c81b7190948f5906bfb2312623df8a8d34e274461bf36c256f2bbba6308229ef01228ee9e040dfbc6b08b89857a2d538784c155ee38b5b5f868a0cc24e55a784cdf577b39e18e3988977f6efbda8f9ad78a747d14931aaecdaaadca049ff236c1c79b7845733ee2a0e45426fe90056a15e4efaca7233940cdc62cf4f0712d16c02e325cb94e981ccbed0ddae5c9494e1345a349f02f34462b19cce97ee5640f09cd0cb7f39a578146a55acc20e936d03d70558e021ba7ba39d10da2db57bd9046ecf7d0b1cdece1fb3889904fb3802a7eaaa72ee1371c9a69ef8a730834b8da3884a20e271cd7f5de2252e8faca96960417f14731d22dbb1b3fe027989648a2b8752779dbb412e5c57dbf1b669a0bb5b58fd8b8c959d110abbc0abd09ce2c6bc79d36b556b842d49db8facd817926a5484537a895643bf9ff8936084ff016bf59d9c2895eb0e00a62c0f08dadb79d126a6c3c8d55c478270b10eff3609de21c6ae5745ace947d8b24788c2968c501c938be7e4022917df4407adde752c710597ea9b3cd1d2804001a57dfe2690451d12dace2de3fa7752d01d14387a468b4cadef40876831d0d5ca9861a4d5b73e09659bc4748c12229dace99e0bae780bdd9bbf70dc19af18a38556adca9574871ee34a94da505766c2144dce2f3b86c1fbf4c1a113aa7294760f9bf8005376510d4ec99c54a6a7ee852a46e64635de2f6c784ea02ae9d0dda39a0135559b569b3bc1acfc544ecee9d808db3b014da013442740d33f6344297879792e3b42cbe6f8a3e7da4b87d57890391c65f11286b684d65fe3c447b45ee2df067bdbb31dff7e979b4a8a7da1b1589be480d7b7704808c2d4e5ce0d78f7046afc774b267a3899aee1e6abcff4787ff64dd58eedc92af298a3bb7cea2182b11d90b0c5a79a752b7e9bccd986c381800e1da611ac1e8d95f579c7272e3ccbdeea05c0de5f4576a47baeb32eb3e42c656fc3c64537ba0ce013f7455ca7f62bc41f10dc89130f209cb73006f6c58284994424f1af9400bab46c3a525944282a4f2084bdb1bbbc478b3d1282931d29102dc8f923da4587b978f8247048bef0d78c68f62510510bf3a2a8ece3f31de3635766c1852edfd0470c2a0ac562ce45aaf63125df81516e154a9f3736a857708f88b3bc1e2d875a9fc3ef3fcba1e66b17dede751bff4466f5a5adf0a60ce2cd05fdc6dc58e632a914fd9a64fb895bb9563a5c531190a6422b95619cec3d3d1758518c3902bc9cb86d9a065429ff3fafbf5b584b66213ebeaa6c9fe2fab5ee780e9f100aa8e29de4415639559bee34840f79f68adcfc423edc2e0ce7aad4ecafffc25fdde9da71a0cb8b09dcc4e1670be3a597407a3e7de4cf95a4aec4e5d16ddf2f8ccdf91a526cff2173ed1b1e27ddce77d5a8c0922a716fd47c0b2a705c4c0497e0f8dd216e5cb70ea5c64acba3309da5dace4903cd9a07779ae816a6bfdfc8194cc1b365d8a36789b70539f8d5a97e08f82bff4b6e1cca60a1e7d50973786b48dfaf7c39c1003de73b156990a09375e2d0fe2e2c52ae971c84153358a6e9ef3a8c581fe884f510337c0f28e64fe093bc02691b36b24fba5f3e46d177095a69e538b2c26c27dfb272e06b3f7058f92499353dcf2dd7b3e83f4d931ab2958a27512ceb233730f9e2e5de5b7a37186ab1d7d5535941c1a983e4a1ef6183e166ec9a91bbf5d43ba3f840e651a3fe54455ea9d4e0021766c85a6cc9748dd948850d14c56691d187fa98430ee8572f104a32f56b80b96796b833d7364890e8ffd4f621d7a7c2307ab4b3134978ad24708151e81d301f71c16acafe2f60b39b073b3c54cc6c5787ce1dcb49cd08809826aa013257cc7d1d519e3fa57106f7eeadc47dc6051c06931249b2e55b49be950c6c426ca00ce4c774f93994f86f551e5dfe59d341896a5d5ee952c0e19874fbb50a54c82160bb7bb2480575b1de21b02f3189d27bf8913c3347dbcc324cddf5938448caa691864923bb1ebaf4d3c73e9971da63245882e8920edd1d947f81d9d52d38c20d34501c3305e5e44efde37d0a24560134a80af1b9ac8a1c4b1c6b566b5a5335e155c72b31e01c734d34623955824639f1b1ee081782d214cf3cb5b18e04624d507864295af1a7f9802d8e8ee860ed5dd1c3de0fad230b4c38b268540ee7a66e63da929b1afb2bbe0377bb4ef205046fa5a46c4b41aeeeb545c47313ca1a0b6435da590ad873db1867b13f218a42cfe25752eb5989512d0b646a786dc16563003bcc1304efdecc69086e2c34b2f1e157dbb221894599259dd5d8355d2c5b33c7ccc61adf7f0f4b16dc7244ffffc788ba702419d5daea20e566f17ac137d72aecae16cc21826b80d91caf2a18392766122d91dc3447df3059f3e763ba7c73733c70d5fc99d76a85a0d5abba296c02c465bcce5f73a3d17343e25868fc38fc4ad27bb4464da9566a5280b8be8ad263a8a7d30886ae46fc4d00652a05c0cd61621b72030d7e67409a0a2c9b4b6a211bae2d17195c9ba1c5191baeca9020c45c1202958a0ebc970ffcbe7e8533906a68b15eb41a60722288179eb2efa8dcaa1c901e95ec9c19f8e11597562be7ba5e0625628ef99762669aae54a9edaef1e1530222fbf0bb5121813c27e8ade4d014131409a651edc53b2849f08179c4d96a8fa0501ee296a058b94e389c5615bf8f02d1bf30f86c09a494f3003c37b8a11eacc1348c1686bd4983f7e578a6d481163923fab75ba5408172ca754ddfebb63a61513e6635960299bb908ade04ab910a607a1dc2d7f2bae5bbdd6f44fda8462b0a70acf68b100afdc6e53409ecc0f952f4036b104807761df3789ca06298ef975ba7c2a169e592bb5744403983f35eaccb579dbc067469bca3fb8194c8529276eb830088c7cbeef1495c621618f0f0695c8fd9dce005eceb5e96ecddd0a83e5a49fcd72aa5835cdabf564cf869e20936bfcb9c29463ddf53f5aad9373ffe31b972920d72e0f603681d54de8b73c2c66c0ecec5b91c64a869d482a8c86a1a46e73775e08a46ba45c2bec4d0225565c423ae67e475ab4ccf2c2d3c41a1f092d10617f79713528dbd3b6df649f99da005207dcd7972aeb4abe1bf2e9fb9987bd1482600cd4d4999a6f95c581356d4f96225a35c69616843be833a24738ff4c17007566168ac61f0aafb8a9302f9446df9f9564a7c69153db4feb168312da85ca4a1ad38766bb97ad50a369342190f7153af29bc961569b2ec989d70262c805e93766dd8dc98351d0ae48bd7c7a9550a83f1d2e93741c0796cf0c1b4240c6e1de4f46491a3c13cc7568f0ec35af58825cf62bdae695bd7a98a6d9d69107c72bb482578f61c320461a4a5065bca96486ed0a7f738efe526e76d0a46fa9554d02c7490c2704935ee6fbbd268cc7f431ed55e27af1d12b54fe62ec8137ec7297446dfe25fe5a4c62037bab1aa346293350a8db32626a7510679d76ee89ee3b71201197666d15a3db9010792226643ba2eaa9fb3bba91f2cecd8a4708a678866d1650b8ea6027c86f4193f059461de2068f1486261567378bc161db2f3485e502f675045b515fd258c0afbe56ccfafa396890572264e7a2836b7881aaddb7bb9d1f91b8f43ef8120a65b2aeebb5606a247e33fc6ee8de301de3b8b08cc19e88a020e061a86643bfe5c63890b9abb4ebaac6bda0f00a5a1452faff1dbe22c58870d2f0314b8148a4d493f7af5cf86925b060d7eb7aafb5760fd1d7d25cfec137c39da8572a724b2b796e3780c98c58ce82f6840cecfdab8dc34934422fbbed607a1fb803d59ef959932ad7ef6b7be0b1222c89592d0ba6d85e1c282a7b10232ad2765fdf7ea30212197a5a2945f488855562e8dc2f74e5ff69fcf927ab578ecb3e0dd1182ccd9f49c404866d802d3f29cfd6c514709758b8df72c873a3605cf092ed74db5089f5fd8244a1844958a9dbe61a39849b8126b8f5a9a2cbd3861f3a3bd436836480d866d56f487870a6543c827de9f58ede57cc475d199ae65c05c1a09bbac24b30c47a137c17ac9ee6890604624fe3666d3dd062694bff7e8916dc7f8a19fc61c0990213dc04d695d631acc5691dc70e2dd264fb3f81b953699f5c399b9c5cd0f4fe5b58d127df302cf0bade09190a75372cb36de24491b80cb9531a1ffe126f2c21f2bcdd088a07d30b3da6ec2740471a20aefb9908dd8560331426a9b6726887d7e18f187c575c0e80c5315b2b158f55b38d7a34a6cfe88d8a2eddd5e9e60087c823a02c517f9dcfb1ce5158d5345be626863a4aa5078ac7b162740e4281e67e6f7f342a471a13fdffc9a09b8fccf5f0485182b7caf307822fa329e8900aae32e120a6a4da3b01d87f3015038da3074eabacc213b2296838bd4a8d00ce36c24663a0c944494d5c3faaf9606e927a56b3deba28cdd0a7aca5aea4ddef636a4eb804d809e90690ce8d4834b50771c8dde13e7b719488d474916b387d995b40c2b10908ed8c7dc101671826a7e16280cd68773686f52de72ba2286dadaa9f1a787c12eb85b72940de2fb09e21f4b0945cec641be81e7e630cea02a7569c0a3cd48ccbeabee2bd46c8ceb852291eed3f6195caa1f14b753031cdbd84aa90ca3812e3d50cfe72926a57a3c56e3a3154787fa64fda3a246b62b32adc18eb7787adde378b740cde62596cdcf57b8cc702a9dd278b4c45583f3de1dff3688ed95fc1fdf4c4f049d87b61e0ee13366f12312aec55591c714569904c2b2c96e49a22c83171d03f24cd12455419b1b1bb3a057ead0a1bcb3e64f18ab06ff37019b6ca9e843918b82b7bf48e365cfd35eae5476651f06d8b82e480400ad5d90a9423efa4193f1c89baf8bfc9eb71863ca70c120d1e1fc538bf1b1d6b16414be7a7a4ffdca96b5d352d23182b8068320c193bfeadaf63c5f9d0a48bb60155e292108c79c3aceb62dab3dc3ec7efe522ec62c914ed499e620f304dcaf5650045b2b851ce8733f797e50e417734500aeac06edcc2685ff268f7adff0f90c8d091d0c243def3585be22547c3534d0b0777e2f161d5ab33b490c3b2e9f00481f81a860a7c5a6acd58206d1db61684a44b3fe4fbad351a011c432ad40918b4ba30fe607f0ec30b3a3f99ef351920a9e3fb5e93c6d6f159ed37f657e528637e545c09778ce48d178ed172e06a62971796a8ce8a69ea7ae53a8f9f30966333427e17a45d7368894006eb64d960efdb38de976bbc5546af307a54238f6d8d4f5c2670abfbd355d55e6edfeaf8e37e69bbe31580f11792de5544ca69b1414a6baf689beaba5b8b4dd201004fb8231d65f6cacbe61d40e2743e2f40311f86f6fa8da152ab6a4e424194595aa3a4a40da68931248b61a6d1ae3352c78c93130935efe21ad34fe7a285f7bfe29a695dff33fdee4f863a2f53206aa6e7bca002a35a0475ff4d0b4d2926ad4ce3abc4a86e98fd1350052b4c264630c638228ba41f8cf4a7c7cb4bc0cc20207dc7d7f2e3dae226ef04682c8b89d292b05098d83e8e0246c62d1ea1bf6cbe8d9ac7a4cf7543acaa1eb7de835d795ce256f5c89cc9e0df224ee3af3f86e05fb40db3d5dc1cf05a9e959f5c4c0804c71365744fde2ebe2aa56a66f8ce3a1c06543ee6cc0f3846e5ce91ea60e984cac089a0111d381f8e270c1c6c7c905f8e133226f3dd40d4e12d8bec52691ea872844eef5438a6cf0af6f6e7d4d347711c1a0d71fe98062e1c99c68539b1bc1bd5b6e0c3cf5611a4551459e860c5e704ed6afbd881c190b45aa8aba10c4d16aad55135dca939d1bd324f0923a09b35e153499a7aafdac448ac50fab62be1a1a151e371af8f7571f9b51840fdcb8f97867a1e66e5dc982adb0b841f5bbec50378d99d4332df94b673b41e4f3072ebf03e9ee97063ca87ecf9a00583c8ca0018cc234b818e4e72a264247bfe48848ec119bc6b65cb69c0e2b3c407650e8fc302ce6fab434d28f10d6b60bdc5c66a0045df382f91720dccb9d0f8be2f688558a469dfe87078771baf141a7f65e18bb6f38e06e0cc50abe458f609eb48b66ee16009c4f6b285e10d3caae3b6fec6ac0ae09f098cbfbd20c2c2179a7ac03fdf1fcedac2872f80019e047269d7d59e5708debee243c0e88fdfd94fb8f008278a606aa5599a728abf1e8582ca7aea2931903cf47e824b06fa31835900ba71c2f98922d658bbab0a0b4bb2a84049ed45506a192c151b672803c18ce6ba487b8c0199801814b223fdc2a7bf733e71244395b7d86e9ddfc14aaf3d1c203fbc976e1970731a2273ec881cfdfc3c6d54491359cc897e6a584f761cf3616ddabf3abdfde0ebeb8f767e64c94d5d119b64e459d6c66f0ce4006cf22803cbc60cd9e3090f0544d8461a8873c4768862123a814b2489ab2b017879370acbb7e96b2d373966f66d2926a000fccf5a56c22a401143f8763d8147720d93c076825ab4225a95be55e1c0d6db64108aa1769e6388dae18d1068bf12ba57fa8a89524c2cfa3f78b439970573577e0af978f5e34827ffad893318ad1bb2f1067b0f73e63a666275e8a3ded431f183021451854cd56d24f1a2252063998b2483407299903bda10f86d9b685e908e833dd308db6511bd5147d724afcebeeba3ab35f8b3218926f1574003dcb377befe19c783c64bfbeb2b70dcb15035e7ebe9f9a1973ccaea93b7eb00e5326f38ed0927e80c3dbbdbe0b7f7501fbce762d269e3d55494dd2df897522abfebbc519377f90ef1163205e817fe671997f468ef27b817ae194735b58bf01e8839e384a78ef01c091497956f39dd857a36546cc4c08befe85ee6021733098615bfcab74afbfe64d80e5ac6d5562bce4a94bc3f3f2261a4140d57c8643e110bccec6a5a84c9379a22f7e84a04c82f8b6ef2550d415cb5f92f98672132a857f4d6c1146af26cab6bc8bdcdc53430cff948bcef061bd770c38fbc3440d3c20eeec8d7474a90bc23b9d158ed94115a4b34a623ac27bb2dcb7f5fb89a77238a4519841c93f425c0d3dc383305e46c536c172e62f7549e95b0fee1cb23063cae0c0c2f2f9a924eebb4148320b81246a4e1327434733df94962432093f03302a57063c63e1e0b9801937ac61d997310aa5e22ccc6fd4acd5b13d5b7989644099e2085fb9b54cbcc47a826c4eec7d090249376b524bff38380784121835bf77c30c161377cb7201f3733846ca0449392e71c92114ca3feae4981121ca96b2327446cc78c2f5ef3224b4cb893014da90a8bfe28e7a7292d9c4c0bdd24f7252aa9207943248965458270ea0a0567cb48d1d15c6d281eff429810409a9eb2d4d2f23ca3e0ef84ec2bae9a017520f986fb45a4e9a8f9d428c040f7e07a82473905c24ea89d30273a68bceb7fcea090875c8c9077c3b13f5141a66de2e7a2f7104a7ba0434056b4bdd107d5393847adeb7dbca698569a3b2b327f9099e9396530954655f4519213fdc2d8ce49b59fa773c27ce9eeec2ce548d45cd1cc34173384b881e294467f465e1e0b9c16d0fba57da28edb3fd2ddf9d7c8015a80e46ca097e947f0d8cf88abb1ab5da6d80a73e7fc4097713f9d247a39c219e30999a7951da19af1ad2f5d868900543266706a6eee13ed81e4d3cc2508c7e0f45d64dd483f4cf392d1027d8e6a30a9dcd65d07ac3ca98339b7587bdc4622c63ec6a69198be338f7f9fa75726c40018f49601f73632899597cb287337421567c1b6d043a882abc6859f43ff7b20ef7b357a99dfb28d51d6f43e3d3b3c5fc991461471eddaa84de5bff5752680956d4e12dcfd1c04ba0cef1ffdaa698a361cdfe1489d0a4be5ae137011364c9de1b56b205e3cdaca9cb52b02b78a821ddc9d8210df50cc5134c5162284279ac5d4329e5f621a580d53324de0918d84d47e1425f89a39b1a3a52b0596651977a69b38d618bcf0fabe6a2ef75ba12e32a72573cc02bf5a25838cfdbb67583196bb37e68c301c008d43a4327889e5a868f040a2e962e317f2b20a7abeb3d75b88a182e70fc986f121ba9b1907ba9712dad41f0572a0ae48fe6d6117ec51d9433fa303d9e1fb37a88932833bf053534dd8d7d9ff040a52519891f6eeb835d43f31d96912096d9ec1b1759841b9d56a91185cfedfd9fbcce041faee5b1f7b845ad5cacaf9a5bb29fa58a74635ce8f562007b8d83c153c61bc040af4fc9c905d64d94f6e61fea9d80bfe8632c1f29ac7b9668d5ee41990f9dc447d9bf029598357fe6685c5955ed1004298893d9cc8363f9be6220301d58e736fa5d959aead59fd862780f71845459de89b7e7d66119cae3381ab7689a9951e2b960b760b483e4ba067a3ffb5c87824e482c5a5fd73a2278dc1856fa289e3c0d8f7cb645a8e43e8a837c71633687e2282b775f3214e622227bfd49068976228d38185e6c932dd18fa96be0389f28c60cb7a114db8e6b923a427408ab1fc2f9279b2b4df2cd683a51771fd2a0725101a9ce0143ae0b5bc0c455d0ad89f2116ce03e062b89e4bc889e88e06e4a4b5901c3a034f6ff894b0dbad32d95c8fb7d1488f10c1a3b21449e648fafbe7df5dcb68361028eb2c8f05a3bd64e88b6fba851e86f9ef5915064c6f9627fe763c0e6956b0a297868320258eb60c7f4fcd45563e46988f85ba35664f89466f181ec8d2fb3b8d8d9b3b65f5b4d64734f271728d4cbf123c4049d8201a490334343ae72868300e835bf31bc9e517953799a1ed141cd812988ef15a877525692f08821ba28870dfd681eaf09020dc819a4b08751614e3be80fd4aa52d944cb2ace5df2cfcdb8924e45f6402b9df684cd8c589b39c70ba82cf6288bb31e8e621310c94ae3a8d98d431e00e251519f508e25629a9a7809406ca0a1c31524da661d0e698e4404a6509465d58f88996aa3487daf5c0bb6d8096d244b4a84b70287ea32fd1917ef730b075e8ab09e034889a39ab9054d64cddf3533716a88f4fd5761d94f1659e2f64cad29c298e187739e105f573c46c2eabe4ea9bb9d68b7f2b58d5cd991ee2f45691ea45467990565d9b10fee7d219eac9e6d1de1691bdf648db54f9d42fb79086d248b6ad9f7b3e891651c1692cd3d6be2c30e0dd2a2f565cf5adc06b0aa662fc377d700416e5e5e2baa971d3c144f4ed7518d15d88b358d7daa03f29d411a7190b102b078b09d6a31d80f22a7c58432595c75ac343c97597df6586a55952aa8cf0a73030ef83154c521b84231feb73d51c1d93817ce6273f0a668d0dec2b847c03f3b12158416810d0b96885b53cacc1b7ca99dbfe8cdc30ccbd03239ebccb2ee15b1eb5de33c9d272937c10525c82a20b6c6c99152496a1d608a98146bba8fe0e754263995ae16c00231a373ded3429df9cdab4083c234d34e90f7c54e427377663e1d42c72851547dde27d9d7f491b930a3f662778689253c3d397e5bcedd3df06b642c489f17386ce5aa935eebc171325111b23273a42cc509c4f7f93347f0159d72c52699a71c8fe2de5e1790a7eba2ff55eb0600eb8fad7bb23bd9c3dd88183c0e6bbf8f7a87b8071b5c463b6f4444ee3e8205b3e90ce42dbf39ba07209740c65775e4443cf4df63b97b8803f30b1cf62b9927cb4108764a84169218899ce713b370bcddc4dbaa4e8d9ee8b506756e9176ed8dc578ab8801fa020d7d1287905e863f7eed5663094ae28012c51e3fb4f43852f932441476710f147da0acebbe3340355ccad7c3786edb2864a1cbe6777b148760852623334d93617ec0c00c5e7d4e8e51379278e1f8efb14c3a6e69a650f9d724e48df3cd9db5dabe952378a7c9fc4f2d7fa1d8ff38b6224f6232bb991ee88590d0cebc39ad9acb8179618772288510d87d5006a2f269d23129ecab556f5115946c792b135e6a28b5b3cc3b461f0834f1f8707b142307422c7d8d3ba96f4de4cc30494daf6cb66e73042d1e5283cc41aecbccd2e6949","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
