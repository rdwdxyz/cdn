<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc0060ba05f45169f3819f269abb06b67d5425ae74bbacbbc20ffaacd8857b6a95e72f8f161f5b4d39c8aa1e719d8afa727e07888774bce3eafddf12d2818e17a924104cb064db42ba9a4e5df4f6a28be4d091e132f1c9672a8403acee450c9ab4bcf4e441bf36024dda696954130def4169210cc87fe576c67813b8cf791e0ddc188003c07a1eecd47701aed41c092b199733bb0e21e3f0dbc8bdc935182412ea7dbb4a28cef201b5b27abd9c5cb93dd3ceee0ae4e41996f1a96cf9b786dd4c0622fbec3b8cdb5a4919ad380f1ad9cacbf6f3b8939816538b18e4e1cfd64c8aa31c46b0792a7614577e182ecac1178334b673444abf9491931788ed05d7bc800972953f7bc7ce0b84524efd978a5effd61b281b8c56173b504d029f49e27b61833482e92aef5c95fc30178edb264d52a3550e7618b299d99adca55ce0c51e225d826b8192df8e9a7765b6cb239b00943c9b8dabcfd3555efd3d425cbf6ccc9241c99732ad3b02951eef0c8a51315c3dc28cf17f078c2c416abf40d07e370ab66f5d9fcbd1c20ebde35b4efe0707ababc6a15e0eaed0650b3026ca4e57463e1686cf5a415015016328cb3df09c7e8e558c06c383770b25ad567af82814d4c994b33bb6d0bded452c8aaad86a686481af2402dda0f002eb2b823cd5eb039f1bd899f9a8a02da501c67366e02120696859ddf6ddef41f4382e12d2afb4052105f7b47b67aad9071d23d80606988e5c9d0821fe1abb5635bc2e42ac28167cbf25a24bb53ef921aae232d7c1e40ca04616011e46be6c59aadf281fc552e9f28f7175efab55f2d1fad074b58ab3b256b45c935c42f843c31c8666d2877a907c39f4bfc9bdc96929f2cde1c9422125ae2ee9af5187695826ab8dc72af4167c7ade3869c5873de1bb868dd48b9d66fcfd9097b40432edc7bd6386bd8d448b4da33ff9e7179227462bd656d27d80745abc2f07db16b43234ba9a9e60e998e8f558b266e1d4c8c6214564ff81482ff1893e7d0364358fda8f039966d447c011262e58641d66f8fb4c89d9967d06b102cc2b7341718a32f2ab9a98096ec59450873e7266c3a0fe3ae1c4e10dc789b70a9ef4b790cbe934a7c7f07af8e92a1deb3ea154c2b6811bbeb8f526a9968df2be477dd82b7012400177ea31025aebfab902e7634538e9bbd37e036ebdd24de52f174fa1f967b86cd7bf54e7592c94a57815506c9edd1aad1274ebea8aa2b94b04919d01fe2aff016928734d4003248a503804b0bccaced09b51cefaa8b5eee57e7fa91f18a7b98a770727156231fc99a21ac3861c76bdc54fc5e2f50b1a2f14e48d480d161a90b7b9872d4dc697d0739ed1fea4c80dc703b9f6a2eb3a709eb633412ab31c8d88cc5e353d776020e932eaca878ce9d3e96f1afb3354de58b31d434c2573c1570ab5a6c1f1ced747fefaa78ef498a8e7b81b2e12325b3363c66d816901e041c02b1cd885b4727c590ba7453ee0ecd180b3afd1cc58a8523a5164006a8c93bde421ecad34d5dd66624dea1da821a55a05c89669bc8d4a66b1d20dc37ff10192b7e41035b24b879cbe414e0a482cc00e4174e3185cacef28f1df8d8db661efc894f468b0e0068800fe2f2c4f8fb18a2b44331db75a1379ee0217317e858ec06ee8ff6a12b51c9b0ecdf71060c59bd444b3d00d9e51a1cc2d48d42af2e083881f1d0d280cb60aa4cab2dbf308ac2aff9d2a634f6f961e77677bcae100adfb5e7303942d4927367e28f88f6886af58cbf1f6dc48647a8a4be1d033ebfeb36fd5097969594ed5f1af9df345d62cb6ab31b35ff9e36a274862a0f5f60e385196902cbb409dd26257a65255655864e6720abd3c9a560da77cd794c5e2bd4baf128189ad4362c8639acff6a79fce756024bb6289ea1366b86887beb7d1b6af0d2d4a406d88b24056453a48fee5c6b35c65c92acc0b703d5ff41488bfb92c047f5546784cc47c9e51606af9d50e3098fe4099dbca1b247314620b1dfa00a43712fd2e53d7180c087c06c7f867e90e7135e787e0efcab5125f61a2620243f1d57a4c7b9434eaf7835431e50d57d570bdb3bb397073339388b6ebf0a475d252fa37ea9d488c15a00f4fc67415ce4a2ec4556a34fea66c15b809a41b036908dbddc5c3050d6e5eb316fb0094aaf94396bf208e717f22744f332b946aef7a1986a17f81e67888a41fbc8913268df008c363beebef051b1fcd07e4aa00d0b3252a8be2fe991adde834f9bf99b1545d123b9698668e1aa3d2d435d6010b81832ac0047d8e0639d231666a35b1b6e61e2b28b7eac067ba9cec8100c6df1e3f3d79f85e2cb0e09e1d70c5bb643ea1aebdbedc65a2934513d726ddd31cd7ee90f45877cf2df97b2fb902650df6590b6080ceed8422791b0079f4d0211cb57c63540bb64c340a3c734ee31425b6ad2055ef0e415fa3044e648a48ad85f75979d5abeade7e2609708530e3694d9513d95cdc83bb7904a6ca38f0b9ee0db016c217b1ea052c1e82e7fddf6f820e3d1c6689d484e95797a8ae17e82e0905984ca2042651c9e39377a96565d40ccd6eca7070013f152d76d99deba1141a34314af5997f59dfe4866b67584b22b026bc807a86693af3b6874abdecde9ebbde969173a29bf3b8afbaee95ac4f44ddb0942344f4c863786367fcaa9bb0525320a5424921f2732f824f24e445341deb89bb2b2926cb72f74e2c89af465ad4ebf8f2472874f3646392bf3851e9182bfd5942df5fbdc18afd42ae4c00c4aed83eabb6e85097a5978db985a3f10a0c6850744626b3ffa3d06c5e7ede05dd299fa3440bf9a928eacdba42211ba38fa0e449e3b97c1a153b72bbbe55093558375d5579bbc903ee95dfb5f35ac636390dc217b3172b2a6b9874fedfbcb2d8efb0d06fefcef9faea9bad276d644847dcb129862726f815fdb2d36910a052de47781237234e854279da6fb92431adea4a9d66bf83d64ab793cc8699016c0a2931a751b782d6fe475b02922ac0d6b12479dd39d3854f3d68e018202633593a2f17344004d3745619bcca1370cf4a67a202ea09948a9248584bcb88840963bd6137ab4c77526d7de6d36ecfbc5b49bddb60bb0616bc689e1e10ea6bc506f0aa71b84d01ed9e64aa9058e0075e5e13fdf5e0cdc88809be83c070a77d8dd336e886fdc5c1dcfe96ee33076b7d75e0731f22ecf268a1a40ab371cac840b787e00b3eca235ceea47da0d3a2805552e80f3360a68e798b3ba961ac02201b1a8bbaad597c7318c6087fe00f9a0798e31d577cfb50c676ebb437d950cf2146fa2a1c313b2bf148aade9f7b6a1953430a94654156c2302c8a1efc2e05057fc1d95caa7764dda3f5afe363fd0e55eba30a0a932e5e5661acb20cf1904d7afbcbbfe823f9e678c39b103134e3f1a0d18dc9247ff32e8809de8116e4daa9e0f3acfbc4d1a4089e40e4113996e7133fcaeead621d25e83caa32ae9f0c958f08106f74046121f6e6451060379dfa21e8abeff571eed67e881b8ad80a2e9eb4d643c2aac7ff05c71b8e4790640c6302a4ea4510c4dd15b6975322a7d77874010b249aedb098606defb9acf7c9dfec505e7161075ef719bf4e4d6b86df3d0126fe837c5f7c483e1d00c085df976ee0df97bca0235113288b3c2e445e4c36dc445e0660a8eabf148cf02012d17ba3454f0d961f6e76edce05c799f03f8ef42a90f202c033b644d01a6b68eaa99d17ef9bd50764d7e920c62a142f5c0f6ffc418ade9b89ac319ff8792f3384609acbd402521cf692aa113ee5dc67151a332946f1b7eb71d6861b4ba0de7398224e0ec07d8d158b5ac263396a8aa36660bd536f2302e3c4c9a8bc61b0210cf455f6671da1a9b7993c4a567c187e458228536cb26dfc4ca0ebf85e41e4872ea100658fc63e5c1faee58b216d0970be626943531e4780cd97b6db7a4a7daad466dfd8fc70f9882f16fb65eb26fb793f2bfd82fd9b09708d9d6e46aa122c9a71b871a193d2a90da44e593f9a184bf3b1d8279fafba31795361c56ecf32dbf8eefa5982501008d8e5c80d48d8482f943b367217715a989b8ce3490c7ac7378062797a0b590a27b0b744f9ea623877302ae5b3693a05dd4db9d9f35e1ced1c0db4e2671b994b3fc5f028d4a25bfc60042dbf8d6fb92deea79681199b282815acf37faf1ca984f438906f724aab93dceda5eb8d10a05a727e77266337cf26f5cf147f2c41341c58b28794595a3b96db2b8b49533f79a49575c348657888b509e7b49eaf166841fac1bbcb29ae7d4817ba1eed27cce8b0835db183e3bd9c158ed8f2ecafcc597d5a710f3d569e00233f55a06b8ad6eb9e945a36b7f435f3260e7fc2b2ff142a57e046d9ee15ecaaab103df8ea3eab1224e4827df085a1563c682295a9f4edd712f8b701d1eb1639b5e95434f615211502f9c6f596d48980f32cf66bce7f9cf9da3ce10093e7f3e5e813eb88999fe94f6a86c1f4a99059eb6b0f0d592b26dc460c1dd138c270f11a4f1c70dc8c755537fc12d3ecd45e66350fd367ba88cb549dbc53337eb36a22b06ad7188cba0d3d815d4e822016a29fca6388349136d9b115f3ce8ee214d6ea47dab08738892f1b6a38ff0946c152be5959d764278f400e0bf323160b7d80ef10991fb56d74a0be883c34953ec275d74d096f27069907e32c4d25b2c54c4d4fe70c30b6190c303521cc9aa894c5e16258143f2f20cf3955b21d74cb1938732595e35009ef42327dbfd13c0eec055e556b1e74129bb0bd8ca36c05c51161d5c5b03c0d98e7f6aee64a08c51fa60841278b0cf3f20f34738fe799a1872f9191ff459394f3e13e3af34adeb1cc2fb9783cf230c70dcce47f735fe19236a9761be472d2757aa5586e2d0431410343e991e92e757b5411c8023527b0f643ba2b4ab15d9e4a36abea81744ee8237dbcc38998002f003add69c7c4672f0c07662e6e5e1ff72caab7fe75be3e8222cdd06d8fdd318a2c72c0e9d622de9e5aec10b9243245382a99ece8800f3b520594974c6ec0e508f102b9cddb1558f0569a68b480c5fdbe8f75ba1f723ed06039f58ceea113462bc6ae6c8f85c575e8dcd67c523612967ddf1d8ef60a076a1c392a1ff722c56b132dd0cb4f85f1d3dd4691336514f0467a59399632488cd0b6eabd249da1a8fcbae805da3875562b7a1532da02f568b4a7165f02b7b53623aaa253b73116c35fd053af6fe7332ab1b1341adc8c7189acad3529b1273d304aa682070e4e78c3c0f2bd0aa494e862a44e1c4844c0e322b5e7e827572a619f1af0c36582ce19e690c3587a548b0f34771af1f3140da15db4afa724327e09a327829581471fcbb76b57d92339e24bc2850536f5b5cfe956962326f7eee78bac924eaa5d72bc3d6a8132b62f165b2446ea5868c5996fbbb3599255bd9bd22d87189de49dad047b639d2c1ceb2315090fcc45ecc4b89c33c320b64bf43053b1d4c53f72451c594fec61a77e55db518c12dfc9cb207973e0e88e92f103274be9d2785ab548633793a92dd2a2c057f6c23f4ef8ad7ca20d67e16c62f1c47da3d46fb10303dad1bd3ba22fe496fbb873e7e3dfe165ddb215fded6df841f56d12cba07fb7e1f221398890000f3dcad8cab32b2d828c6577bc5bb1bc6516f3747449bf3723720f18ad0bf61d6113ecb8ff94ce36ac5d969d0b92c06b886027619fab203569a9103518e53489ad4c3365d3ab6212b007c035e6b792b940e94152932d971fbe79f4b709aabb152a3a03fe1965f3dfb2e35ce6200d0a646495f843ea4b24d522a4d071ef1e07c29c0c458b455af9f49c90982ad6ddfc3c181f87315c1c00418410807439d618f7b6cfb8a2b06b095bef24f53540f8b234ab1d68db3ba9d449952881303814b475437bddb87f294e9778b49a6805c88c898a6a74b6268766cd2ffd6817c0506a3615ce16dacd2ece0d26ce0fba76a83aa559c35f3aa82599275393a449aad2afd3b8fc387633df484e218e852d1da6588b3f991ceb5e3581a2009af1172b93828588a34d01be1c2c99b724e6e26a9e9091d4cc530be072176af0b778b106b080cce71a20f32a1e8be179c4042ad5a7242d03a4796973e63329d4c78d93b608c8d70b76452b88494173a207b2a1d1c93b71911bd2d75e35a6bafa28c1976921bcf051db43dec39653053b91a306048b2f8189d873533af5b9110e17a4f6a671bdb3da8012dd81a6f8cb6593a435f4fc7649e776b18da0e8fb91afd685c1f7ca3523eefd3fd1aa60f97820ef4cc9085bb2318deb863421726f65da3cdb312deb728aa1ebd48547439db315bcb2ad68adfd73571a0ad7e8ac4b518aa9eafa39607d793b5a5e89ef38c246782df5b4ff7a2018ca4025c00f9ec8d051985e1127287de49a5182ed8da06927a1df344520146463f6baed706effbc2bd260ca893bd90ee20481f5a142d2f2e2f86b17313fa7280529a0299c9bdb5bc98feeb9f4d80a4332a392f9eb9a9677db3be55f7745c599b976bd69abcf640658d12f32d34687b8648500222e9ad23cd4a1f83db89cc59cacfe9cde4158907d1916ca882fad47a0a93092833639341ff5c900fd1ecf7fadad86d60eb3eeb68de7fbff5ee7c1e6b941077429afc3d556ffdc33949e531fc6bc62316db5f7295c7aaeebccf4d830cfed0b9364788a6a053359fc5e5efd8311236b9aa667b3774d97267cc3af537d151d3fa45685ac2c6cd9887993adf87fd1a6492ee96b22b2e54eeed24b5b8d67fce154af80249d00f2fa807902c298c52fb994e59378b5c760383eaac8c00741adc89d64a2340a3148ea77263cb2dd4ed2ff749507abaae4aed0033b6251cbdc08f7a7fb0dddc2ea43ed708c001a02aa713fca722009cc882b3b3a320e16edc132c1626ddf26cee86b873eb7eee48d1348c8e2a35d8120e506f9f3eb0b454f5e9f9d54c8b44234fe783ddeda6a4d82d63775ea29cefb8f32219aa0f5a2fc4a5048b524312b4a029c2cbb395f6ee46dd73067ae5b5802a5518b8ab36caaf680db3a6a840da86c18e77c45f52370b144e44b56b406d966c7801379c84a12fb161d70f78451b7e0de0ba6daa2133fd2acb876719f757a7f8cc21702de2d5301b4a6357b365739d00cd91d48b74b1e7d3f8bc92e1a77d0eeb401e2d817fbe00dab53dbae9b279877bb2a3cd88da57d577ffa10f2e7ef5bbbd0adea8a32de310fadc83fa0a1070d613c699b5f47d4e9352222fc2ec0435ca9e28d183c83484cc19e64cbb4253f87a84dece94a0cd069d54646a0b1064ceab22efada424eb1db01a8114765120b7b2af33cb1f52a6955c048de547eed00680de57471322d6676ffff28229ad6bf6b9965f5953ba4a9fa6a46bfa923826c0c040826854ef1ac0e6ab86b3a7cc35ea2ca1040835d7b141585614f1d3873310e68262ac77c901624edcfb78bb316881e165ed036afb1df1fc4bb0518332fe820e05473d968ab663bd596be89490536bf4855bdc250569bc8aa6b08457477294328aa50c0aec5fc35abac8b9ca6a74744ddc2a282d9ae3ef93713957397ecefa7a8cee1f186bb5b84295e4ad9aceb05f2118feefd01ed76e68604371cf60a4cdc72ffcfdb15f3d9084502ec12f7b7dcc030c6691d6ecfc0a5f2c7e7638ec5007338916f185e0a3d34e5dd328bdff003d2e942873042da6e3af93a8c3cb0f488d8b30286ef4b39ac5d0940f61158e03c870753dc74cc2e04e9dc5451833c61e8ceb6af0834530bf5d95dafca5b8b902c130be804723a0e4c49513bb8321a3113ea6b638bf6abbdcbdac44c103f8a8be9af51bf7b58d0181b2728600b657cd1d2149ae7cf3985aca6886f4933f2ac8fd24ab4e4f8e63c72994051e7e2d15fcabddc25f57f965fad20a995d568217296dea2727872c5b6640c69c82ca4f650a0261fc2907c5f222e2cf43caed3a3b23af7a1d197104db294975206c0a0a5be3835fee90b2456a589b7402cc85791490c17cfacb3f52bedd9fa7651900749ef268e61ae8e17a2672e78e1216705bb1aebc786ea86357eaff394800e4cb7fe7cd1070deb6cc0bcc5f71c4d89074fbb74544053272782480722ed59cea02104364d264f4b50f3d43cca6d759ce9e295c699dca49fc748e0efbe509ca492f9a264c64e1bf68c129c59994ea56c2b60a15db34d586342e66596063e74fb73e8843e5dcc17f8d001b207eee980569d11d8a1ddcf1b6c12c6811161bfc03739de666459cd2454d59ad8947d8f5b47bd14c6e419f51e2fc5418d224625afc50cda77f30167f344e92a1925b1a333ae638a339bc9c1793a7eacc8ed440b43a902e714e8b67a1cbb3ddca70eda8f2d6d39062bcdcc228a19ba688ce4596a539ba3576d64ecc22b6308b52ff57591e8934b7a5d13263eba5ad3b5f75bd1428afd9517206a00d1e6b730662e121bb86975edf9487f413ad88cfabd319a722e9cc132b51ea6c79aac8ad1621b7aa92875e46fde4e7d5af9b0967fbc13fd64ed1d43270f4c3596ed50ec053745003d2aeea4f0fe3f7c91f236f786a143135fec80998fb163a5c41abd63ad4fd4d1181852a0b1ff1fd167436a25cf38b49d72f4a4efc5343202612dec34c9afb945562e70edbc503ebb1238a6d2dc62ec83d3f5d84adf8ebdd87ee5c2e34f9c43e7bb7eac3c97832159be8d98ba4b77ae11d34697821097555115fa2d5f8f5d0332d4ea956b462730f680d59a7f0fbf4ebebcb43865802ececffdafcc944ca4ddbb34574f8d69d5946b12e3319d6b19778cfcbcdcec3fc657fa57ec8a78e9dd522c930cee752cbc9c2c8d9167acaa34cda1c27070d6481cb8da2392d16b92e8d16292c60e26a8a86df5b9760537e732dd62d14ed7fe99a2805d38df3a7487165d9af2f8016727c51700e376168ff4ad9e3184f9ca66a4ff14d9d3025fa84933c063f031006650b71a1c714b5a37d6fcddb24fb115a32800d7f552ddb6c748b26170115b7aa1e32efe5af916dac778b109d5c32665736b5f4e61939def4010e36e622908f85b2d42e0ef991d7a0d07138fe8335c560617056e77784d100fb6ee79aa3eba86d2c908f475ca785c728921a7770990dec5b9f0a5077a547f9bb0055d8d162ba19ee80a8224332ffe8b559d712682790c69ed8b072605e7b58e9ddbdfc084262853b5eb6d6416cc80b4cd8384c18d2400484e3c5b426d7f009d91646db3b935faf238161b819b1574238d01edaefdf57a3331c8e23cffe6435339a820497f6f166cf90347eca20a7489e2e7de5f103c7b6bbcaca7a1dcba0ed9f34bdc73d823d637289ecf167c9d3b52ee874636b599eca080d0bd7064ca1bae53af655f571238fef67b7528c49cbde7f311c41d5ab148f653137cffcef20daa2ba6852b3e5ee7f19bb9f128b514874184ad7be870109250aac7664083d2b9cc939014570d7e159ad6250e46afa23653fb5fe0e9ea33cfefa7d975c2bfe99dda2d8a0b7b09ccc4da1e5361ebfad14d441aef86bd5cb6a9e19f0f7eb2b4a5475fd1114122fef08f42f73c283fef9213703d9100ec616ea80b6c2137743702399b11e0299a32ed14cf096d7f00722d18f747be6e3cf5e6f35f6fa4c7ead23e9309552c87720649b65de57fa97a39007351fbbd8e6ac26cd9b2ba0d31cf7b76ff724d1dcb9fba2933cdb4f2560118228bb810d8b3942e7d594d73e11c331fd254f35fa84eb7dc5266ab9958de9e09b1597eaa52a681b06f06eb507f5b3cd552664e64be6fa7533eab683c8af5ca1e7748b73c8073fd0c55195f653981b2d102a15f11310e180df014e6b6d8baf21b4cd1648b00664f22eeafb3f1c7c6d0b90fe9c79663012d42a8f01d5105dd762e248f03bd6f64a908d38e741fe22d7edffb7cd1fb6fafba40f3a027eba53f9fc03a8893e57657d35cd35e64cc008325ac86886bce2e15c68a03e41841de189e7167fe3d7c35cf859e58fe81baed625653c73edad33f137444ac657c0cf8aa48918565ad2d0c172d9a09a6f476a6a7f8dbb7a6d7be06248a17bf03c091f0a73e9924f5b67e17132f485e956ffc22869990ffd1d02eddde6d7383e89ffd9eab4d83adeac481f017fe55ba1259a8d57957903219fb10b91e13a0d166c3262ae6c0aee96c2d66b97c6c07bfc4f7d06785551524456f13c231b2d707fca5314c3e73c3de1e53720672ec30e00a9ade684465f4d909c61ba25d84c585d211862ea2794c5d6201bf012981f2799d7eaeb439f775cd26ffdeb86072959ded23df36be29111e22986250f33b72d52bdd32457a0124c7eea4cf932370d448ba6989442785aa328f8761a60b8c49875ffc8ea925787b1c06682e6edb70e58946cb724e102e70dc0130ced692f8c793347d3dc5b4f2f6a835360aab2135e302e094e90e374f7b1f36b4a8258b66f38e30b3369517c150b93dcf7e1de65f84a7cc51cb240e6b8a699b04d618d7aaee9ae5e7b02da6bb296c91be9751c9ffe4127a99c9638283349d3cd95f0f5677362a469c43ea5a1e93200084395c425997ec881f27f6617bdc0d99ae2cb17c5038259c1d7cca946b15548c294ddef2599b2308e05258af664824a800472d6bc1341dfb705505ab7cf67c447fcd08889a2c09ec6a7a802c83a411bd712a4975679afbf1f7789ee054765d744046e1a8c352e2be07825e0b69b60d25d055dbdf5e7065561e1d487a5c6823f877f02b9c3646ef09c9f55a9208352ad574a8f4689a810d1155fb59d8fb3cf052ead339a69dcc12c4c060f6ac899678e0443ce798c6f3e420e0dc9f7c4f2e6e4883d06451c2844160f795f757220529c7f77249e9893d7d864c0c384d03a71fcccb22caa6f2a9536d4a5caab5c8be450a2e19ccdeefc95b6bc94422bce376b068a318fbdf97c7c984e130c8338096acccad97feb698db51c3ed012c3d7fa618dca1a927cf124b218ced153607395997554bcf9816c71412bf7da87286e1c104c3d305b053588eacf7c2e2a08fc725402fe8489f9c5d451fdf956c66b435af580f32b3a17731d7f7e6b34e4d041fb17767b254577f1c9be026e0fdabdf4695d8e2ef42d6142457e4afe2f8087a96c3ae6ec3a4c00e2ac0f1ba0177e3e4eef3fe75f69ffd219880403683e07c8f723656b7e18851fec7de4aa5824530237a8c74d9ab6a2764551485b57b6a15b42c632634d3608aa4384f27c7421dad55dc8198f963dabe2a9b0efef379003ef6fc6ffbbdf219dc4022ef30902c02d491589650e840210409aab2aba256ec2691668a16c100206f57064717b2cc5019a3bbf7d715989553da480d92f4dbba377f91ebc91b1940535c6edd939843b59534963c99739c9cb4a76c1b63d7d7446dce23db0d92ecaaece783a39d61ce5e6a14c5fb0ba90b6bd82d1d6e6d722ddfa3580733950b6086d7d4b71148053c513d1dab3c1102824e28bada12ae4dd3963afd3b2b066498f75625fd39b969a12ae1300022dae5e22f50b1b33d8d586474aa1a53e88c699a5da0124daad0d61eda756f47e7c0653d05f9ef1edc55baea1cd9bd30236ef3d3928ccebc80192cb679f005449938ab59b9b68075633ddb54637529c44d15f32a997ef9cbfb29e0dd030fc6c3bb7de3dcb25d4503d205035b015a5734db21aef095ddce69a822d92b904057581133f11af3a52d7db0f89b5e9304ee6cccce5e6886040626e3cf89fe545b138339e42e03f3cbf244fb74e8d19684862bfb49a0d83e48b59ee6dfdcf0098b55c2e2c802dac584c7c58da13a4bf2f5663ea9a94c0a771268f9a5116db1b788bf5c1d929c01df38c6d3ff3eac634d24ad04b772d7c587b2d19dd1477f78199616fa0ed79e9c04e6f6666b4927637946de27eb5f1b874f8bd4191d91fbd3f12318650ec63896b0c287a9e7d2e436845438b1368d7b1e133357a7d4e3a0e0c5e2ca572d05159e11c5045b0f45ae9359178e5ce10dfcd77f6bf2a2b79c8bd2a71e496cb50e5b0aa1fb208ef2715377be4e6f8eb100b03fdc86bd5c81e0826908cfc747285cf76aad95f425d0cbc2ffbd93e26c968010c948b99bc0a37b3c7d27ed390334bb3610ea7d64006e6746468676b0f638c77e02df7e520bc07474e2030399c8f8a2fccfab7e953a3e2b422c5654bf8e792e5ae618a556bcd902ec7c1f4c926adc47f0a5526eb9f9afeca21c51e9f604322777e14a6041bdce379a76f73d344bb2ab45bc76408cc56a835cd12f931f9dcb3bef2b5380b3ec8bca51a6fa973d63ae016e59f05ce89a869a9b85fedea60c10b7f99e2ff59e8e4cbeaec9f63612e3f6160216ad72b3b9dcc8205867c34cadb07b3910755910fee055a71184f79af794a1bd127af962af10a03ad9c0c5235cc35721cf702b733a8d88f39f4d895f721e131a9d8e903e5eba4c5ae5fbcbab4fbeef68be53f6568293cdada604db2905d691051e1b3eed1052543e6cbfc16005f21ffeaddecd0f0773920d228e669eeb1d0412e14a95fa4ad556d2d98cb72a23b0b520cf33e74b812d74aad40fa8b2648bf5bb8bdf2799694175e1a4bfc6ed99d0e6345d55e8858b460c643d3c0b57e7847cc15a8b1be74bb360582af743abd3769ce844e3a826d0f7ab5b731b386be29ddccf9e32c0ed6bb31adaa9410ae290233fad695d6392c84805cede956f449b71e301640d5405eb55f10962b6a21f76fb3cdea131f9aecf20a39d324b266c47b27fdd791b327054a5dea773ef4290c3ae1d8542d7721e67e28418fb9b40e1d272eccf297eae1e94bb14a29e283ed710e95d575273df121aa49eb247e90e89e72071f2e4b4a621f7b16985f5ce306a8fe36a9edb57920bb54c8f29fb22d20a55de8b7d51dcb934a540b9722c35b56c6e30d2c774a20a10a64a09bcee19c544374b1947d6460b41eeb684581f4def17c2748eebbe2493fdfee751398a44f177536d4976bf647fa4c7a0d077e6920686a9a797be0c838d9c9dcefaaff7b7e7c16d842b30ef8f6013c5b3795e75262791b8ac1184fbcb081965460e1029ec4f04e8e7906b086fd5d72154f4594070ad9ff0008f7d4700221c000c028f3c905b6d3aa5e57b47f0044d44a9e820a418c1e384c76160fbfc824af88a21e915def97404fdb8ce8a5261c9a8f1dcf256f95874bd263e546e625720a3f815534b2c2d07cbff498457d72557feed6ab279a18a32116ff6eefa0e6390489ee187d6bb843aa0bc7ab6022090e990b3b61523642d695c84f321f7099d00b31c13938eeda75ae98ee0728e16f9198b43680e8b6ee245532c1950392d7b7d8d59d98ce9e8a63f7e80cf36a02be5ec3c4f3e6a7280c7c9d9e96d4d1cb1247f7fbd7694a5e7a0fe74cc08a8f673f58964a917589f0edd6ef6ab9e95b2413d6306e7edaa17e97e3bab6072a445c4f10856d18d27792618ace142221b6337f0be2940edbb892fc9783c55214f04c6b6e4d805bc119700de68c9c52b41cc92bf95c6de00d9840140a23ea4fcedba94beb3c2cb036a001356e23eb8f18ba8ecf0d2248c7c183c6cbb04e0acfb5eb1ec25ad81c340b761d3505bd1efa320b0b289bcb2165f741ee4cb758124d4da49b412d20b22864246cf27240083a4d5f40392afba01215c3598ebe861f1520a50e00fa0c18bcdec6feef3b56029405b7c4deb05887e0143c899dfa6471657fab90c295c98ee4fc22a919ff4fdcb9861f41b73166b453fdcbfe988f0ce4e5f7882dde451d7fdd24fe255bc775bce44b99b55c0c931bbf6caf3280bb0430e93177f7b34704878047ca1ff5502cc5c753f567046141eb859aac336bc08c81d43b8cb432b46d17f792cb7fee586332428fcfb5572ed94e51447b652813e9dc5da1bc748674f148fccef0d6e5debffc294fde76a92e9a47cde00619da872ff6f6cf64a91820c25f6df43a9e128decee6ecd4c360fdf4ccd75a6d36a0d425cd153b3fbaf6b699865346c134413e479c8487e7f1eea2c9c84b171501257219973f631af39df288bf0762519f4670ed96ce4c85464e673d36a319b07071a6dda7838e93e90736268b41ad6eca4f5ec824edf333f28f9ee659ace4ee9958d64b9265eeca53df6920e398cc6c6db1239b37cdd3a47f7b669a84d9b541d7e44727576904e6f41f7acbf014e99fc83a3a05aa3ee33b7fa3f2ce35bd79db9bf3711deb484f6c5d42947c41ba6daac8197ace24d68deb06d9f0b21c8291434e9767ee09e53cb7df603478a2585d04932c21e5a3dddfa650dbf2d331870b46b948391866ac000c018ea9f86faae6e9b8766d3233ea1ec3a61024ae9f76d076b85472761d6b7075f1c007a921f2f518815a54b3849afdadb39636e5594b971cd6774c0efeb51a8e3bf0c5d0c35c3dfb922afdd32b938d63850ffdbfa8c92ebb1896e29d89be853db49c43cfc9451c218a4a814c66947f55f5882c1dabbf5f3c6739a1c619465d1016e1363be28a7f900a3e2f787827d858c939ea85e74c1e64723411e83bcaa85440b9c6e9327b07e7cb3ac46b880a59bb7abcc6a6b916dccfab3f87b6ac2388ad1a1dca3594c3393dff934b94244e8b9964bdde185a298005824ac1aba25e2929f2a5749e5ff0c604b268a4a0805354e1c17079ceca2e3091c903fc12530b48f45efde3cf08e8bbefe0c6ee3192cd07ea87bbcfb8b5c8884e028b24d0d38055c09ed8e6d753771f080f4bcc37d1e2489f53b6e714711eb4c42957f6663442594209817a3c84822b636c3402a8fd49b7452999e763c9b8dcb3ec4f1d220cafc77145331a39de1b5f10c7b8a13686a527df6bea66ba4e9433adaac65b7faf7e5a7558dcc557c36a07febd643f05f00af56d463f29513b5839c957c818e63c42db21d4ca93e7b126d57da9f7716598a938bc20ed1e71ff49d8ccb5f948c1049cd5867ebb7bcaff3367028ac21f451090fe6776cf5f84c960335374f0cfe700b6657ad2cb6793c07b4ab71b16bda2a3bed611b3badd0ca3e9449ec5fa9aeeceba1a39be69fc28403c10f5baf2cb402ab9b42276674328f4fe79b41195c8e24e47af485b4e3ebd0dd50894ce5a62704bd1ecd8fd1678789023606da6e3f62141e74d7c9dee437d9bc91062c1174554985431fd23af938a9daad6bcc93c0108c329fb23b81438db7b44134e72452018f1e43f6b9daa968511cab9e4dac5195ecb913bfd00bc464d802fb67f6889500cd62e374a178c30cebffb0e1641faccba302181704eab8ae2f8f58a41691e824ee29f3ba90df068270f0135105946c1d5c7c9432be20487f590632e37c09afb105d1da4da7e3e4cec3db6662a667620e30dd83eb036488587fb5d102937bb5536c10a2f85c23dc7885db21a36c1917333d6f272f256e929b2a33e7373567268d44fdd6eae8fbb74fab0e506ea55dac7b020daf01ad88850630ae593f5644b010181f14ccaf12017925730a0666e8736822cd806b2d974a736ca6c91d7c67e3322482ce3a02bde534ef5702b2a3bbf3fda9ec99c1c8e792223a12097b9f544a5467d89c8c1d95285a2ea3662b0648105974037b7ab00f0ed1cab4749c8454ec9b6aa77f9e2253fa990a6e3f4d1bc49455123b4d78e3b50f6e3bfbc699ff6944d9d9a6f5b7764c036a3f3a6f983a6f32b5d0f8667739674ffaa062f4c17f2bb361642261d0b452a87a63c93fde1227a2cd96771630678ffcfb27b1a0faa9cf090efc9691cae3847bca1af124ff07b284e1944766a71ffc14053dbfac9d4d0a589efc54b90cd0f864057ce192dd7ec6743676bcdef17e7c58078a7b06ceb070b9380a6a1d9316a7a3da59c35808592a0773604ebfe83d713905348666426ebf626719732d88ceb52e725ec2a9aec30cf26b44729bb0c4c10a35b8f3f180e4807673bac0256fd8aec0841a7476736834d320b196c51a9a3a3dbb331f7af9074cce7fb9e0ae335200da66ed23173f535b55c58770a51090106780fb9e5fdab77600f28c2dcbfbd353d1240152c67db4a92b886f619f9c9ba4cc27fca804be71609169970b1cafed85744015c6404d6cebf2ad87a71fbe20c873dd0cda05c5e5f894df5237f245bceec2760cf9adb2fc7fd1fab32059cae2f90ed7c62f96e37e08d51d08bff0b49899db9e5b2cd07015907a3a0f68795c02bd8d925893ebb435e16d9acd3f4edf46c872821406d1c2388c6dedc44e9dbfa0fb4a4a79238430706d5b3411899d59a91320647b3bf382620b9f3bc7089e0f62570d38f6a78c6a23824a4c7fdd118d32c8e11dccd12b662eef2bd1bcae715b341639cb68a8059de3b04981970401eed2ed194b1f66c9095882d0447504abedcb270da85796042e0209c117d3dcc7dd0ae12765be2d8301c1d099b19c1515861920026f933e6157797c60deca2c011c7ddf420598a9229ca6da33cceda843207edb585a0236e5ed4510ba7ca65f3c7fcbcac9c8d7ba04844dedfc0ce934257d317c0c90bd1600bf8b8234b41304788823852bb7cd411f4742e08294c2e5cc008f30ec9e2cd4f8a990bd9a241a5850518dc5c0fac0a6869a814731794035cd4951c5259c7e69f5d096bcf3a9c1765a270664faba4c312a736fee279836753d346de1863654e812e6ad999b4df1a4e651b381a47e7e875a33288824af6157ce3f59096564978935062fbad4e82ab1afea1cbe0b04f3325f63d12504e42d5a31fa7804309c2bcc8e50e7679543efa4adbbcbdd9ee49d731f7fd53168631b8db73f296911fb7dbf409c3b67307d754d5ae9033a819a0ca994d66d063a8a80520ca83871b0b8c098a459e99899ec79d21ae9b2a16833922b83843ab51fb9bd33e88e9c30faf60a6db2ae6170635baf91d066a59dd5a2780b01d41ac9eb9446235a0a78797aa9e55ba42e18c8014fb1b0afb66a6efda492967b17b422127b962d221ee88da58cef6d2874f343ab2fb1801b6e83a09230ee4ab2191cb45bfc80e7a37f1418f763453c5f08954cf88c4bef825257f1ccac7d71391b780b57adc9f96d893d1013086003d584f3347b8df5b2c5dfcecf5773500f47d522d43c392a7ff4f5e457245f8e3fe67e27390c155b51178122e19927198b048ebaa08e5d0d48331386e969e3094bce5173aadb41af4aa1cd25097bd90f5ad991df811cbe183453147a908efebdd4a70e7d803a1b8bf7b9c09138f29af5649b4fbfa34a358f5e0dafee2bc660d1e2816c666451ed5fbc9fb1caa09e60f501cfc4325c023f6701a2ba37617c31e14f5e31e844ba37c31068979ab3a9756fb76962dd304efaeaba0e61ca7650aaa93ffc5b5287f79628ca76942ede60416c1ebe7a3d2a55536dd78f198e274717bce3d5a9448730e0d85a7347e5bdd2c260daad98d938fd24d92233a8518c074a178385c7d1341d133f92db4db555cab7eed7892f90d4cb9555f59ae2f95c555dfe3b71cf1011ef7ed08feb9a42652901515271de5b9d790051cc6235dc0ee9e46246139f506c0cc0d3e239443672b1a39587ceac9579f760753ce14d13add138ad33a644fbc5da8464f3ee65a8ec7a6843b662cbfd5dd94acdfe563277921adac79f97817368b58488346080f55cf98550c741f6ffa57f8a2ef7c363be39e233b72a50f124153bb2794043a1084c5277a8e9e8ceeac8d4692bbc2672b1870d545529cabb35dcaaf59192c9845fc59133419cadd788e011c8f527a843fd2d80f07bc2d5d3e711da6b51c231e0509fab19645d312c8475f9c7a1c6c67ad0f3dad1da7c38263adbfbc7ced5bbd847ba16af6edf44cbd1677dd242de6a36653015dd13255ccb265e243b2cb7ba4a59970b71daa7ff8e68935b5f2867f69e43f420b9b0f4a35133baf229978cbdbefb801558d1fbb50a5b6d9e32ca65e5478295ffa045b53365eff8a7f90a7412834cd8652e9bd1b0b1290b1eead7bb3b9e9e4070098cd4889e7a1bd2f38fdb3982784a2b7769d556adc6a652b84c0c62f1563fa05f2353b7a22326a6dabf2af134ea311b01acd37d832908725c490b0befc601dd3753a7f8c4cc97617976e94a3a7e2dee418e98930be692831fa6104be828c5c27ad8460bcaa638eac43d51dbb5f99cfc6cce4c1fd153e0b653a8c5c5c454a269800a130982e6f0220680fa5a1ae6b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
