<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f2746582d909525edaeb2375ddeb10c97cfe534a0856dd249f4edd0815f9cc0d67233d2b5809552e57ff02ae895aa67d54a63efee0377fa8a71c0b8b23a2ff14d1e23bec8a1bcbdc031353d7b602d27e806df81fd2aa04ab750a2cc5966fc442d8b8579a56df0797db2fef18abd717017b9ec893d121fc4c19a2bf56359da93944a84641ab375b9fd865d71713509479335c71c9cd32d60afef86ad07e436e73ac0c7bf7670e13b407fb819b5709d827e2e9533be076242807067c4e774ee3f12ac3fc33fd40760dee559dc53991a06cb5b64a3496e635880c8fd17ef59df65748985ca108be311bbefb98885a58e1ccccd0d4259076966e5cb698b1cdc59bb13207c02ed370b3450f6ba82c434ef2050b4dc4432f05048d263e42b02386d55f749906b6c5b4d71bd1cb2d3816246a885460f1b76b1fda09f9ec6a6dd3af28d35110415db6e9b583909f87f6f0309365cda02c6e59069cbb9d6d3dd62655107301a42d0a340b62bac039e95463cf6648c13535ba28a9c31e5f5f59a74330e2519340fc4e9580ee48a3e53f095111dfd74a8747f55a3fb4a932be0d6819b9a12ed14d320698e7a5262364e7707c877eb3dae8b2b6bcd07cc79416f252be389a9b83b70c453526f5ac1ee26c37f4c46ebbd2724d28da99cbcd3bc650a347d35b9d6b8315a7fa0025c95a6e8b7decb4892e4feef53ba1f4b8c66a5b90b95c133485cf1260778cd46d52319312d827b8ed23a9196e110b83f6face3448d8434dbe3cebc4fcfbf6123310473ea3515dc98722d04c44b9c7dfb848383a1cce9056680cc2e05d36c1d58ffa47d02d5de97d13eff85623257431d0f3d51acc8c287a28a35e2987b34043fb4e2d4431bceec0b636074cb0ac5ce924fc035074c0628d03d5d0cd995f4e8d6aa75bfb514064014d0a9d4a9e8eb150e10922d61aabfd09b7862f93067301496ce99fe6b5f9c4b2d883c2fcce0cf6b43f301f1231f74a43d34fbe90e6dd3670c919aff9db48738c808c5eb53653080a75aa655b55545dea05f62cb48047595d2f9227cde83f52dfe0528c918772caeb4baf3560fda3b442584e0a55189ed7912840c87fd986b92bd17e6e77370d9d6732853bbfb897477e6b77d437299b1295491739799adf92537ee94f076ab4d82d41990a05b91922e42811ae0327b6524c73e71be7389366a285ed5001d96ba46b6a8805dd0cea90538aec82b7c8b6c4ea09841cc9858f285d6e04a5d7a9dd6fc50822a5d09f9df962e87a489384ea6ae6b29c79c8de28156c9d12e856a4d56ba1cd24d4d13bb0cbe84626b9bc298993fd813f1f412d1cc8f6011beb42582b126fbea933d1bb3a4abf7786b2d13738c442933a7a342054518d1fa1c072aebf7c69d095880b8a57daf3dac2584b8387648add617620ad986b272364e8bd22c11a7c7abb39fe371fc96e893d2c14dfb2aabe896ad850aaa5e00f8d403af114d895f33f290ec632972834e163553dba7cc21cfae3727b06f8636d3e24c3d3253bb0408fb0774e4b1691313ac9c95810b34e7abb934dd550bdc82d63f64eab201a09864b89a6aa4e9113f68784baab89f4465f533bcd73ed9d6692a67c1ab628f7b59c97664a05af4e5d2c3503b847d64adcd9d939b85346c7a517d60abe0afbba288bc5a60d1d2e940d0c4144f7d9cdc03f3f9b817880d5b0784bc1909daa7257e40a646392352f2a75ee14f80621660ff7d02dcc361b66d458c072ed9d498612848fda17b6207f8630e1296afed632d9ba79f3e397aedc7cf706a31abc1c2c82aefa101aaf65ea9d5fab26c5f1cf47b9ee539b2025e83c2ee1f09729e4715116188de05707be3d8a1876efde84a665a285811c0c5248cd447c79664c6ed05c2af6c4acc032b852543702d94f5f0cfed95e9139540eeabe53dbf96bd2bb6f37a696277ba597caed40f31e6c4860effb54fbd6c10037607ab7bc7d455132327ed6965be27f95de7c680c0b5410caa0709db0ba193ed38947567fdedfa1f5b6da372133c075da5f31385dfbc2f424bcfdfaa4613541134d665254d46f4d8dc7eba36d0e347d3ec11089d4ea3a9fca247c2b0031b5503db63f5f5faf9fbf903a5fcb23566291e754ca608ea706382b75f0073ef14fb7cc071ddd0b2b640f0526f1ec6d85155bf2cf60356ea7139450bff22417544351c7e08c2634af0f092e13f75bae7e23524b3c62896a74c2b15f9851f738548d9c9b278423f7604e899d58f71bfdd1cc7fdee2fcd4049d08c4d5181575ba6e0cc43574ed7e819e1fd0bd1f48d846e0cabb3950e77a15769da55ddbf58934b810b3ac485547efe1aeabc24f4669d39be019dc664b8c9780f14961d5e8942ffccdbaf83f8c0e88728dc3a3cb74577c230b65b24f3c7e850739629e5962c93f843633bc94900c926df7d05f01a96b900f9106f597769405d8fcefede0f3098f31356b412037bf0d54606ad41255360364e1ca4dae2737d56886c27a6e2eaef183ba0be240d23c416eea7161e675b03c7121eab9f18214f7edacbc3821d7e1e2bcd1f80bcb26fde73bdefcb473068c601414bb79f3e58abf210c12446db2b968126dd455c7a93973818d2a2baa9de02d705edb80997a63962e7d1685b64c6718b41832ccff7c5e82be85fd7e94ab839bd3b3a868826172f887a2534fa9f32f54cf72d598999e94999ee25dba465d52f4ff9ad64757078fc175ad59b3cec19062502c4d920d3df79f245ab2f3a07e6fa04906c1f291f1f2593ae7c8f1f5ce85d84bf31224f4267f22cfab6c7a78afbdefd260e151cfa90e69b8b33fb561b0b7e0c70e1f17aec9bacd4d75fa396d29fc79b6904f2bd5f1bc0189e54cb09309509e8aded0515a9195aedcc3d1ec9b92be61d5345d22fb4183cf6213c487c4b6a5cc7c39a11f67b4dda9b5a67077b53747bd58a483c9f44db0006993b9c38196bffcf65d8b7fe364d632a75488bb9ca581a91332d7dc013c6219e75a46ba2be0300741a2842b75cd4a9af33cd95749b5f3aa594e4a4f1591d5c0a5dca706f6b8c33dbb71ad43925218249e99d68a5645c6a628f981cef8391eb6d6d04fa846681d87bf4bbef8daf8429ce0fb331d4ffce05da7f064ac76ebcccf342840b3b35359de38ec5def419b2aeb71de0e70b438712ca0a83b7fdc460bea4d527023af72310874a8eb4235bfd634cbfcd933aeccc1c7240cea336f10c0f4e30221444e017d33f273dd007697c5e0b3fe06f68a3a639d0825c6ab45e60f9e3e27136a12c0671a225a5f6368edd939c0ec1ed980e88dde5ad536b929c943b76dcab95ce3ec064f426acc84ffd0cfe4fc9e2b7e9b082db257e349d6dbe03ed473e9d5b46832a57279e76521a98649b03b8af96494f33cd7c748f3bf8adda950769d5ebec7fd364e3c4aa13cb88fce0fd80ec8ff6da777341e354e42dbc82d7075fc9cda7128a11e8118493b368bc4097932b26380f5544b1d95672b899fe6c97b3987a14fe81d22a52e112c614bff61880ad18415051200feb32d93fbd839a67e006d278f6724185355a9eaecbafc58289a7486b9dd089bf9b89d815335cbb570226dfc3d52b2287c28f370088730d21c6253139a22153c377579546e191704a3fb9d8671700924f676e7de2dc78ad2e9af489fe7b8a0318c80f883110202a0dfb2c7ed92bdbf01f270abd26ffff90a87d9bbcd525ecea340e3130dd31d26b2428cb6cd0575909f92472a5d9f7e297bcbbf2b5c9c9c2c9978df807df807920e06183507318aee1ffae28d0647b0c2d10be0a3743155e58973e78ffcd43f2fa71820b3ef85d0ae56ebf423fd357bfcbb52c412ae7a9ef8b98a75445703d7f8da99aa4395ac8026d2c047e9333d6052de09fe098aa80e4056956c3d7a0cc79ea635a5571cec59dd5628e4286ed80b3bf46ea54592e3db11a5ddc810b60dd484edd0fb45b949ca6ffa6a0c46d3d169d2920da5524aecb4998fc223422fa2708eaddba4e0493547082557a97505c0ca6b52d92204385702382e919cd65c8a8cb44135765d7a2a64dff7b20bee90e5b559712a65f52164d4ab55861cf8c806c5ed1625078dee770f4c078b1f405c1f8c24e7769b6bae6d037a8e9f9b7d5c4d97eabf864ce785bc94fa22924c2a16db03c4b024833ff5bfc6db2ab83347ce6a76a53071fe845b6646a9f63a4dcab91a4c50352b70147d8a9320049f653781ef89a3eb472b6e872015e6ab9946966d3510b549c2c9893e3cfd89a54d85e61a1a5f496ae40b80679adedd489cb7bd670b856b495d3f0a6367be82bfb95a3d5bb8f017d55299ef598e9601ec1f7c18b92f2962e844370ef46e45e2aea137af0a2121d2c1494557ecec0f7e105fd52c770551a0dd6e7bace5be9e85efb2e96fccc3294c12935932a5b0f0e0597f6d20f67c8c3da2e9bca9648aeba7b4f5d82c3bd3dc95ac8d8a98357dd26093924727423ed7829282109841d1a98e44c240c24f03f95d89faf534f49c8c94c2dbb2d931fad4a3d607016424abe23f3dc26478e9eab49f18384cb12dff0e0e4cab95e7af6a29a0024168313f51cbca914b99d93e91b9ed4f2ef5e798e5b5d1e824d85b4728da3439062f351562254488a06456afec92e06de97e954fb388640fa1f58a0a873f30f20d476dfe18b39b9e2d94c33287dd77277eed67522718f414b54c81d4082d1868a2c220bb0b24503abe7eceaae54625cf4a8241303846083632c332bea70ae7de7fc8c17dc37b72d70b8bc05f6083710c6ad0a4e86a1eedd0a8b810bce556f5fdcbd4d7110a11f78ae208f80397fee5684ee8550d3e786bd123e07f6b85346704ff936863cab32b0499bd3b848f7ea3d3bbdc5a1aa70b4f8b039ac1196a32a453b13aa5e275de726874e1f863df2a8414b10cdf90e38f0ad341f94a16a2055d860951b772c3008715cae29b2b07fd963b10bae6f95c0022dbf69d6016f11ba3c962abcf116f6ac48c3fc7436a9c940528ed7cffeedcd7512a0e7eea56941e984d8ec2678913bf458c7f9b477b74b489fb6404be048212631eb4134b1fa813c064384460e4c2650597e8c529405953ee9e197ab71709b419601482504ea6db882379b353f3bb832e4146c7ba51de3ddad8643bb503c2c9f0b17657ecd87126a0b75d864189589120a3512ac9e8b888ba347627a09e728b21aa5aea5fabbb4bd120eb053adb95b904073f058e3cf2e41fe31761231653b7dd8be01d1e208b4988e9c76c31102a38aa1b6aad5f125d211f7f7b9d200dda9c12c4ba4dca8a0f19045354ad294e24d67061752efa630a86d2cb14b6830e7c0f4b044ceec8861b2bed6e43b6138608d5c05b2926a4c5749603ef9ff16b6247702e4ac1845601607ad962250f507e5656dc96e409a2b84d58d940bb37f3a277b51980c570a1f121e9d292eb32bda656b944739d00aead039169d75b67926ca5e05f6974d5d791f7323e4d4dc903025d24d82375cca2afeaca6521efa12cb120565861f483dfbed829affd4b00d863175937857b5ca3b5a115efab5b518dc7fe54103c16bcfacc1f5d2c33ba5ff4a5a95d7fe8b7162e46185f8e648af8f87ead4dd3ad46965532a5a6bd159861576476415a9977f80d5b7dc9cc708b376b22ba332aa360d6023ee43c2d58f199e49b5636448f7461cf80f4d65f5ae8f58a1b9f359a737646c3bd4083d5e97c693e621373183cf790cc908f5a869bf5593f5101e0505396ad476f13c3caa88ef7b62ed3b3a241bbeafb92af8f76491d64e3124fdc41fad2d04bb1ac7c93df8fb6d9e8c68d128d38c8c4406db97b336a423f6b9d86a2e9098ed7a81ed22d1477fd0ed1d7388dafb8bda4ef42a16d6ca39d683885e89a2331ce0e8e1626cad7eb0a53fb53cfd7bedc750e7207d55627b5fea559a67c0f7b698a10c27e6ad1baf9aeed088e42202c1ea6dce3e53e779879ce2357091b1659ce314891a7a63b38d503a89d756816d1e216ba69c36ebadd931a9a69df7749485ae7f168951137ed54bb83b665ae0336b1e33a068b5e1398ede29d030d23669a3866f69e66fddd0213f832741b1d94a705227f123a50186b1579445691b60e9f3f3bb51bdbd9edaacd3e5508c415771d3c53a55b72a0a41404960fea296056624cd111aca3896285d73e3e01afbf79ff03fc8dae2f016aedd2690a2ae05122e6b3d9006c25ab930038aa81276dc37618cb8d8e3e00175957b21990b48f8527c0ec0d828bf4b5e2e796e5783c58b57c38d0a74389201f6a20792ffc8291eab693f43c30defda743be3ba488a3b7a607c2f3c435561ae344b7d4fe631568112097cdd25f0df992908ffc26fdaed0a4a970676025acd68f22ad3586b442c719b05afd02f1501319d892c62520f02604e1b9e4ff671ce7c0c64298b189d6fc3cb11dd45fe687ae3b501c26b3c7a016875496ac33e857b6641f65131ccdefe3a0bb2895d3d0b8da9928835c4b63a7ed40f2cf6bd1abeae12dc0898bbb1560acb2a52bad7664b3e8f649f010a436dee18329c773f199ec2bcc95721156100ea0f813de4be9ad42783bdf65f0ef0eb04da3d7956e9085110528c430eb180f70f49b13757b806ff373213294805ef08bdd030f4c43da9014c94cd08e412151acd224494de1cc418c8f484e7ca2f55f92c0910f2763b5d4e4d9404e43d3955d6186363f025e801249e905512d77c5e991550b827cf68bb8ebc1d532a046c64d2e9c88efcefdb07f3cba2f29fb97b1965c2d33b9e8c7f2505fdf1f545633bc483f53871723817523f4316adabb9e05f7de30009e0c5b82127bc42da6fce21fffff5924265a3c770ece9dcb9cb29cce1b595e63a6a955969e98ae4145f2f98fa87d5333e24cc47e3f52546d957f875c98c6f414338791e2e909e4329684829f0a896224e8526196e7f67a96b15b347d64309795f7f751570e663e40a94780f8100d77c5326641b6d16e6c309a634c2dff4f4550cc39e376f3784c5711da528a55c8211150cf6bff594274807cfedf3d4a7b209a2ad544f073438e45214870c7436628bdd104c826e272d33ff6e2928c37967861b575dcc443a7c16bef3b33370d69e3b7319f0935d3461804f5b86d340cbbbacb60c8276eba708006205066932a4d73a096aaec9ab73f3344cd5e713aea1a9a3e97da5702ad9c0828befb03029eb1f080a8cb967c54679a3b6add19d57343efc2f3a5c2c2338a3b535e614c37ccbe6210b8a4314f61b28aa4c41348f88123af718efc4506a0c3d4a3000811821ff34833561cdfc326ddfd2a052a3f24ea2a4827d0b67e70ff81fe5ee792f84db1a682eda429fc8ee76de469d663d4fc31ced5de4ffabf3021d26f176f2975551d59430d8a4cfdb5d60c31b994a6ecff405a4307967f9ec628b6ee5f68e2232eaa30391166e0af776ec11911bbb7a08660e05f283f9870196b87921918fce96fe02e56bb5d4fa62612355145dbded27be1780ac87131de3d235eac3ba1762ee3ef920accc693da6f1fe54970f7486ab541a2af8f3f4bcd4a474c53a7ee5176d25b2db5733b3c810cb8e1b6e8e0e2d6d26254f9e3a58a3d33d7c2a0fead5ee483c9817f85f46591f962287d3a40ed14f42ff6d107035d6b56c73faa7ce59084abdeb550d33d1c069f8a2fb36a02cc4db62dfa03837dc22e8158692a4f51c5c006cea639fb15bfe7e3049db307d890b4fd88c91ec1e672a12e730779555c70f31d74f8ad065909808add915405a6611e090319697408924f83aee15bd68575e5702513ad295869b7a6898b7d48ca6efb91d7043e3ef0394cabd6497f6dbbe6e23ef352872145d8a4e6f465d03096bbab63517f5422dae8f95324e6ad07d292edec289528902d951663c91533828dbb713539ed8745b8ce33f88785765dfea47907d7ab33f2b148b11963472ae607128ea0cb4dec3c8f96495f7474b1df68d6b574659babe900c019cf5905c4fbbc91bd618443214b127718d94942faf902101c6f8e2d3fac618313f00ac289c59e158d90a8a5cf0a78e2501c884d75f33ee95df7af9b42e194f8e09c71074954b6112bc9458da17dbeded7414f32d5b2ff099aaf25e6ffc126bddd06555a97890cbd6f69df2c9a90afeb9e8d9096078b3379beff75b2a12ec675a6b146a5500785956648c63e51382206ccbf6dcb8be04a6da8b4e3f6a99b3cc4b586c3f0c24dbc222a1e5294b3f43ff252db203052a220080002d131dffb0c0109f5a68e5980ed1ee89ceb20c61d867d66baf5a53bb9f15857411bdddf68fea761a624d052d3451f51f3d1cc877404c30410c79050fd0697369aa49bf1cbf58103e43dc6c7767fbb597c836d9d19461c1150b7ab44c69e8405b59e391d8c0e41c3ed9aa140a044a0a571ec096332cb4f88c5d23315fe77475bd45328dfddb961d110b569ea66e38aa78b01209454e6aabf3a09e43cd7f6f6e7dbab2a1c8fffbb7974bfeae6556ffbf8712655dbd98d11c8d48cf978baeb807f058dd55e8f4a13d453457274dac97114b2db8b2900ace8bf8460d02fde20973ce23a176226d0c7b70bf2f3084aac4ee6de636651a4cc43fcff7ff613fb5883d2fac1f9408e8bbef31cbd942a7e624431eae3d2d158f87f414cbd43b8806eab6c48b627ad1f2aa48d6d0ff7467b0f0c357a51c0b82f67cd7ebba9b03965dd4825b8282a6991e164c68ee47514a0896b607e74ebd16b4ed8bd61bc8d0bc5e6014c16abdf4f72689798fc88b2e82d3f4320fadf0053fb5b2f94fbd719cb9ce7ef68ddde0b6d50aa8dedb4d412e3294168a246fbfbc375aacac987c28c8d8d5e15cfd8a1e50e4ad42a2624ea1c0745bb8348d3b707597d5476e74aacff0519b5e0cda4cb3edc71f76240be9b3586f6b268b90d0d75f1b23dc93dc3eef67b4cc20983af4768fcdc2411017842b14bbb486dcc692778cb65b7af1a40bf919806e5744cad5e8f41f1fbceffaeb71abb9c656807ed220430bb4eaec92a9f60b8b78949f5172010a401a3696a11cf7f2de8fbca582756e68f63540a1b44baedc8e3c3424e2e17e01676167be20adf31d93b73f22ff6afd235527ad5445c36f66c10fd75ab0fe74d32d5543e4dc6c16e428c6340f79f0a30f3a410e237ec29ca1d636502906f2ed42bf865e634d4d29c516247a6f4c58dd061743c04677185bf6ae33cad34dc87eb0a53b3eee56995d11f55230269e73b9198fe364c988273518b7fe1d8aca5982eecc694b184add05bcba312bf7cbaa5be0aa26174c9422857e8effad9b4dec767e5fcda87fc818417dfc03049aa8e58eb9860449c95ef19263bc03b7c4961f48e34c0b6ebe5fbd6501044b1fd1368325439fc085ea49dd334644f321a1089367ca9353c4898bb716ce0d676dec8eb8d5b423f7ae6f5be8a63583a23cdee042ec28eaf3a605164b806dcd09f45d2d8ba83939048bbbb9105f29ea56ff3512a10dba884d2ba42daee2d6f39e7cc5adaee8019a04dd4705b16d13c1ada9459deceea020da85784039b437db7007f94e79de2369929768320b1abe80045b5cafcce33e752520634360685a9ab17f0d9e504462438caf965ecc49d1ae56aec9df84535c6e2930a52572976a9d2ba70ed601ef9a3f35ef64c2e1c27370f739ada4516267141941d443c79931eaf4528ae216ff8190df19ed4f27c8cb8ed9d02aad93a8b88d4c057cdf5d8c08cfb018c2fe3ae2509b48bb9f2e84da0d90ea43fb19f90f8834739dfa33fb24042b8aa3a3bb321c541a2dd5280a205816c150b61109989934f254a86786e136ae1da4056b4706a3f22ca0aae02c54763dd1969521bf45d95f5a51c11e6144158ba405010a807f607e72a7109876374e7bcd96ca4f4aa20682b8909d5544dec1271adfb69047464250f4862d472eab5195526942b8429cf63672c3b45f159283e3aacfd8c06e9c0e0ef8f4969bc52b762117b32a585a7b2167d5aac083e397d39ae6bb8ed65bb8cf5a31e0e4eece971179e69a193178abd943caac94200ca7ee42540098cca90996ce3709e6d4b548eafeb0a2bf6f0b20dca6ac935dee54c3a3c11987deba130ff5407944e0ed5e48f378e2b31d651d8d5ffa9afbb007084a7dd8f447b13f49d27892f83bdcfeea4ef148244e9df19a5e0c7342ddb69c7a46913e11122839d403ea32985a5f538785f0a66f60c7a958f8382ff9c71fe9d0a57abec52fcbd0eb0bec565e919d46c1cd183a1689415ce61f5de321305c35ab590a75784805afb7599ee8e3e94706028cbbaa64e006dde7df0bab3be28cb35a6d38467cb8f16e58d594d223d478b5fb95a2ce470c7b62350423be16f9ba6cf0eefb3dfa6a0504fb83485d76497812f2b1953862bb7b5d13748d2e5316d4f17aa934f7ee829a0d1ec52355c6c8fde9fdd165bb46efa92e09360617774afe4aaf84879fbbb831c48798b4d8d851bd5e931dc8f92e57c482490a2fbdb1b0b78d5099b2f0f92b86cc2da2d8eac11bac298f7ce373658b1d645cc472b71aeced70ed5c2ee310c949db026966f04994dfdc8ca6c4527cb15d3666dcb88b44b969e2a12da358f3d48c605884927d4bfb43aff2b72c8dd7e02af140b9468815dc6c538603ed51c450b819cccddac3a323f5005c46fd25483a36966f79209166b422e03dd3c58b0139e552aff449d413c99108f6e93d52aa5c043066238ea0326b080b8b7e441cbf3c720b86df1265827406f2ec80866a539ac9bab1222857486270fa2944d3868a9f41fd1090d8bb564a19caba6d2750cd4be2adcd42c86eb35214d947d38f031ca4292380ff74a145230101bcace68143eba2457119cec390eb7da57ddea7f2861789a836efc51470f3dd33e2c8f1cb2bca58d2e1335a267cca75f112b7caeecd037755cb2747cfc5e93a0573982b31a613b669a830de541042e2fa7d786ffc8fdaebf8b6e52292c9f1e8ddf8d784302fd06caecbf5ae3e35e73e11b90a3a50809c8356f0ee45b43d2a6b6e73361df89d692dc515a68f8a2eaee930c8786ccb1a5eb5970acdd7979fe641f558938a7e2ab5d1b7e69b74168c51a758f00562a8abd1f55d42c1fd952ecc37633d0d039d209255ac7da989f393edfd4b91f9aae2c70bcc666e39561a728161764211697ed7be954937357f8de770636c250b30b9c616024b470383eb9229e568b5c6e8f64dc72d417ff99b9e90d15c9e7f429d48d21a52cd910ad68d518d60625cfbf68cb4abcc6cde63627448bcc0d6185b9e09f233383cc2b369956a9c8e35999e7535fa4a910183f430ab89ca823570d6374db13507cbe3473bae4440b7d106679647660c1d8df3213152a2e767b0d08b79d5a001797988dce4374b8f2a1579cb182a1aa224085f14e5fed24c0fc091ed7c0968c6ebf5d8346f83c5bf3c956df57d9d7b85d7fcaf4ba28c97200112cbd26312cd1301576573d7254c661a09267d3f8d8c3104e47f31021a57a277e7c55d1a45ecacf35038153ab61dcdb493e1c40c62fa529b4c8bd9b268ecfbf167eae1b012fb33fd034be0f26ac22edfde28caf1c02f1d7b6963232844c355f134a0b2fc1910d970295ac9e6fb92bd3259bc4235a26b45b8fb92b61bb861d36eb96e98c875aca7175d83343a09664de50622794a9e3a4d1a133d244c8eb12492b2fc10956921bbf06b44ae731c97589851488533cc6dc326fcb25b0463e73fc255b2719c4c09a2640594884ca4410055f1c7ce6ef4e9640906de3a89aa18c5d92976b65fe01072e7ac28d563240bd1fb2bf4ffe11ec15197cfecd9a505a8497e0792c045ab00b9af8c30271757bfc7e4a9fd9f070c84b401252b2c917c61e6f3072661c9765984d9cb7df7e63588618e3739f2b74ffee8207b48688cbc6eb7aeffe5ddeff6a6c9a330c2da17ce2eb6eba54b2eb118ea2949a2212a6c1498ecb7f456624e14ac08afa8c67228b0611fde1239c241999959860ab62dd3d379ecb91299476d9c6cde89cf9737deba87aa66d8b2015de64b6cf98792f3710a20fd81e2951ce300509bff7accf59b8bfcb97668867e18b4487a23bd20f91e20e76efd87981690f6002b0e8c46bb60025e0929ce7b4dbcd7204245889078be5bd931fc34259b9b653ed4808a1db7b824b3ca49e9206d9827d331371da62d60135e25440dd3acb2b9017e0de73ddb9e22f502462b073be48c6d1f284a62d6b38f8296d61908e91513afd246399a454164a9b138f9d46f40e3e850aca90efe7fa5fe4c852df70890b79e7c751a52cb39ed59a3529dd205871c965faec42992b1fbc75f7e33912d39699f6b71a7f544bd51298b59eeab6cbcf82f24f533724c46ddf4599b9e10a421b5125c0c4e3772128f9a1c6f7525d0b146e7bcfe82e385b35dafb2bbb188a3bbc92ee74402cc08a6cfa973e56acb9d6b3f22aaf2ba8e06d55a650e925a682c1ca25786b073f2c0c6fa306584d57ad039c8ef9a558c7fd52ba1b829e141312f78ee5b92df5377ee55c3054cbce7bb607714c7a6433b6c3f01215f0b81ce8544badb03c19dda61bc70afed5b4ae6ec8464be7fb5c9127aaa88deeb2ff3c32714f23455c8cca240415dd8196cb0bc97535ad01a1e678571766677e6f7527a30d5e5057e6bf69b8d6b45aadd46599030d00ab44d21f53e917f2c0b314e8e600a8eb09853f06ae02a2d3fb8cd2b2c5e6cb49c43d160ee34bf2373203b4474cf75d07c092e3174461946c622d4611069923a5d9ab2c6175798af0c85b63850239fa8439fcaae66c7ef76b4ae9cecee32f5b6660c181f62787f15d7cf4d31cfadd427178d843e87904ceae445ee8e400fdb44159093f0085369eccb831ba06b66aae6f1e39aaf62940b59edd6da0c085cc49648cbc651846110bfca657ebf6ae7cc08e4f9d18022f0af45a4bd408faf0ee8b0559e3067d96a06def274d72362879cfc8a69ee620ef108ed3eec9a0d455227186e688bac7fd748b84b0f29898e5c21c5c9472c3e49812157c695a55bb03f8903240e7a8eda1cbc227f85f8b1324bd8ee68041c2f2a70431e38c26e85e15b94ac7ee35ec2f36fdddd171c4ad403d58c011b80d3e2a9ecc4b4508b4ce32d3281121972789cd54e4e81b7f2f56e5300cd0f0b4de4f0b27df852dfd98a9e3b5fa2a1ac27a36d590e28934b3429076916010b5169593cd7872f684fd0e96a283dc48f75ab010bc6bcf3ef977cb08d4bbcb1f4ebf02abce0e795850b278e273a6f033b0b5ca0f5c5b86a4bbb3afab4598b81dd1a16f0f7b57a1f71263a3ae9688dfeb82169b4335da2d1f4a896213a991f05bb71b39719edc0457e7bd9ec6639f8ea34b2ec115d87cadb05e6e3f826f23d7324ca533d0b0194ed0883774502da630dc5adaf848cbcc03e9838b061aa013b4ba932b318fdf00838dc0dac88fef91611785dc296aa56f2956bde511d86a9cf43a21e686c0235ca6840dd24f7bb917b6415b4f2cf4c49045140f3d1acde52e81cbbb61987b79ac9a780b10d797282b97b7caeacfcb063bde4356b6c00090fa6758187ebd82e4d413e7b1d7123b207bee2b91f941a11f1ed15c1bbbd987ac683586946d236a44dc08222c34df171412bd224e3624c198d4f20ef38f80ca976013e8f2fa7106f3e184c25043896518c3b436a2ef3c9418d3e33a7fb4a6355ae97cef7d15a4b45b4e15682b50b2547e951036f0e92ef762832e75fbaf5f8e46568a1bd1bfdb5d92a8388a2d3f7c91406aca942dd6847a76b00599c00ffc1c84fc8b8d9f9dc41f71f4b6dd09bbc8851ac921602fdb0f7d58c66d232ed2bc43d3c686946ad77086b32c633719d0361b0e4f8a9ab2af0fe2054ae7106b7490fffe64b1b171b815e81a55aeab678bc58e16039b0d42c15477d6b4df02a36eb37ab1642742012c84c481050de0503c830d6af1876dfd66e92c4ec21b6f56796893452f98a5666260e70678addcda3986cd79fa3a36ffbead21eff3821ea6aa3968a31b70468f1fbda225080f2e993374856467315a22878b5250d10f5338cc0200df24175ab73d779db7497cbbe4cf17c94763e1e5e04233c73b785afb3843e828cb031f8d36e7aef47e789f5e1569584e7b4623188b16a8e7559f518a5163f9dfa2d32b7edd6b7b494a5db31c472b288269f1a925fbb3efa5bc70f5e8849bcbf25f77c744d78f6ad18c5d32489debe4e8dde23e506e359e969b4208605262cfa73c762fa1b7fe6356fe5d8a3f3b7131a177392f400b1cabba9dcd5fe79b5ff07fccd3d7dd6c76edcccd6ca821a8f9e15076052b735fafda0e4ccf770b08b0e3c86b5a102083149499be125c2bd429e9fd8d05f9d2997e1d7c3cb3d0c0a688a60a107dfd63cf5b787fab2f67fa3dc9e0788cc8817c4529cd32a4a44019134f8a263ac17b37ed7dc72b06c9979e6d0b90e222d6760a55d11c05e4863f439f77cc9c757d1f7370c4246c5ad8fdb16427fa00d5c1249dc035ab14e59ee2a5fd6a302f7d7e08ec5d8446ecabd34bcb960db1b57da0bd12d4cffc5203b479dfcb7f8bb145711708504007c779e10aae9ebb0f051bea7c5514480041f284b3bf2e13910af6d476f8becf3d258f3c43dc1be5623867d93eab2864ac94b10c45e2de3e84ccbe2e5a6ed520cb8a48f79f6ae108348f3fb71ddd7f78de8389cbb4c3d5fa4363e330a7dd8298b51f24d1350160c39ae002fff2578ac4f8a4c2263eae676113e9d49471a8e9171e072256dd51bb5dcaf1c24b81ae7da77670101860ac827830e1dc4729839803ceec9439e4ac3d0172c0a61a0defca9d1d4585c8dae0458f73e0c132d96f0b7dca4baf86d3ff9b587900d6e33b4dfb53bb9cbc45b8a408ab0307ca7385bec5670436336b33072bc223f36e27ed43a755123fd7d93643e8bc56e58b53c5105af49abeec484439acfc25b9118621c94fa804345bc2c096048faf10d8e0554282da22c59884e50b6e63f1ae72ea718a8e5c299572b9cfba19313e671d1dd4c4dd2b377b82c2c1f0e447e2ea984937c9f4f041e70310c713f6062df98e7bcd82451a9fcf8562571367766d10546349e46efdf9d5a4d3f08e6f2c568e6672edf619ed9c1e01f6537e55ee186d38ce797385859e38219610ce15f101cceff59de583b32986f368f72042bc91c1389970c631b1218f5f5e154e966656fcb4c42337496f2b2a05503d19432754494bf63e06e6fae15be876b890911ddff4b6260da15a676cd5ef7dbfb113eefa9f8842ea48ee108f96bff96b1f2c02f5116aa9764acacd1f91c0de5e925651c4d43eefcaf9794b363fde4dcb9e374b223f0f26720242c5e05393e1082ec3d60d0de2aa9155237a4b2b5c5c4b56ded669dbb40745b1b5b16184e4062f639c794e517a9a1ccace1eb7284c7fefe0b7a066dbb72682ea234f22a595974996f623ff727ec8c2c5e04c5c0c619486eef244474da766fbfb958618f1e605b5d3af0bc68329e1bb56d9f566c7d01812033edb51f91e1c824a56084f0ea87fa3e4d89dbe091ff8a5067f86e6dabd71911787cd5821be06e2861a58f7f4dd3c4cb0e995ac15ae1cd60f5f6ed0d44d6ec55adbeefb23ef99f8683212f1b33b11482036cb11c04b450284baebea10e3ae034183dc5b9e8a10604e800c15ffabce2636afedcc4ee9fad19487501a8a0ad07dfa924feb0aecfd1551c9321bdb06e4e559d929e8aa3d942fda466fd27fedf28dbd3b8c25da8649d88d9aee17976def54871276b68ffeb2f5200d066e6a6fb7d07022f57789358da464ca830143019b935907ea3f20ed90a483958db4e3dfbe17a3aff07265bc48ede073d37c8d2f6adaf732dc829c7f52419c5136661833fc3215dae262ed5670f06b66575fc7fcb29fe7f9e6cc12e8c333ffa8ab64a060d49200fdb77ec76994357e5dc1b20ca8fc86e29ddbf84a9e5f6d840171328a13b329598f2a00dce22c23aad73d9b1d66125c4383c738d91deb19d9c536a38116b98f2832c353bc5f881adc8ecad92f25537e1d35814176689850a8d9c35dc7b6cd451c682e537d8dfe5e14c6f519da079942c017523322ac175b08993b073e89a16d697f0d1493cfa08a060b3f4b147cac6231ed9d1036d37c0fd6c7574583cc3d5cce1b43ce96edd39a8a2e57f0ff5c4499153d72494a602f0296f5d551fa8d9bacdd6e2a4b54fb08f4e7bed98f81f193c1e93d98239ee0cf2d2936771a2741220a38e6c48d001b5368c0e7479c04de57e29e453ede607004addad7fecba5f3103d8fa10e6565ad07adbc170f1d77563de42eab83e1178c456a493000534ced8f8273636547b5d63e2c105ba3219b18fed535a2be7cd94ef133ef6f973b00f6f8092548b042241a11cd569f3a9b8ab0595ea1b6c4d56959a540856fb4da2f692fa51c9cce69271138e8fbcc47040387d10e96cecfd453e451ac855672c3c5501b8035aea40b43126668379b56c7e55237d4296e0f8e2bd1ac721a797dac7d0ccbe6248e4acafd7d52c3946b9e812cc819e38dc08c195ad42dd622a6ee10a48d2f37aa99aa6b1e1d032d2e482af63a9cf61b3c8ec319399ad21d9351120fdfc2eea92b63f31e9b3a365afb695e71ae3539fbb2fb5b95a9572f7734887e4ebc808d3ecfa5c75794b1ee06b329ec90f7234fec47077242372857c6b46985a824b2aa4c5e70fb767964dea84f7156aa2ce032e2cb9bfcd53e41eae130981e9b15e4ef4efe6bbc2d411a9857cdb02db523cdbd67f7ce34f80bc16ea7a5ed43eccfdba881d365b11336c5ec0e8f7edb39b439c0c2515e358988d19300eda42ae4c0c1e25784538a3e4374f90b511627a56c1716b112283b13232911694368aa45040730ba29a420d2160e01ef8824b94caca5eb836f4d58b62a97aa2c1d551575cb3ebc291212e5718600e5bbf35b118dadf9a2987f4a819041d89c752a39e4a4f4e2e209f0b127b29074fbeadf878f12988182be8ef86a1a1d12714296f6e320213854497cd40e238eca855e1dc6bab3fa0a49fab977da4112a89bf83545f5bcd16d9b9b962410e3df2738dfe926ca01e9d0db4d98670d838940f78f3b1d2b79e01f7b7cb59f2774b64a15970f058c2eb94a75b9290dc9eed52fce45247cfb1f6ed9139d72d32984966b5224d51ec6c4645e12fccc24b5854a972516278e98633c3a2ee71faf207a60826ef4803adb05ad2df238ca25bc90ce458e8cbd8e7394ea9fe79496c59bc51dc98f5fb8e89482bbef56a69f897e740675971a2384418f7c56d2dffe6500559378f27a92baf56a4f0526c2df1da640ccd6350aca7a01df75cc421422b6caa8011baae4b847eb00b50726baa457cd227009ca990faeae0b1b6ce6c6f51f9fb28922801b71c2d16a094d2f9e4cc4091eb01e15383e1cf0511c367553c8f734fc42247b5fbed9be2f1d071512c6bcf1ae0446d65728a1186e69081952b39efbf9c9e606d646bfa22184477b3edd8654be8896571d6c99aa16a520734a5e63ade841c653695ed7781e6a3f9e80cf3f9f9987bc09f4309bfd7bbfde62facbdaa3a68e5db45dbbf37e29e26b17fdec2b64d53821a287ce106dc73a9609f4fb5182e45bcddfa5afaec1275c5bc832df95c97313462182d93439b409902d55c1ca896857a4c88235defd6ad034a36aed55aa860f1e5ae5f7a881d9ec78e5f92c3cb4fb42a64eabfae4816ad8921ebac7c1d5701dddbe853f91fbb949f2e0410ab80db75c04a85c65764a3565030abedacfb55f7aa3e23d1891498b25f32855cc861889d8bea50b34503e70b6bf65c8d76b81d3460f6f18be49b1dce3bb0935d954348cdba57129e7a693ab645c906f3cc40b8f184afeea2860f042be9033a88ed5db73fe6ee5d8138e2b5fa2088bc0ac12858e37841b91c58e8ac898cb30a759ec2e286c6887f0e2a52c76434382f1dcda85311eff57ca6c08955f43471e0f1afb54488cabaef5f97a0a0316b00f85191d4d042c24a6463fd40a8e69c0204e78dd0c9b72a409f6e07274d1b2af025a1b9da2fcaeb84b724bf8c7de3bea33865498c98ada1614881f9288df7810756511f97abdf1bb3079aea0845bc9e0c6658bf1ad30251e3868409aa4f24f9d11b6831da7aea0bfb6e39dfc532a65ea8fe6d400","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
