<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83d3009fbbeb01ef3a6bcc7ab404c297c2f52b4ed7ebf56208100c86c71fce25d12813b9f4d485d9052a1118ed3bb6eef4d41e30cb8087b790db70206e087a2a1f1b9024ea9b0729186ac82bd8c1adc49eaf36119e12155a8cec0ffa14a32902a706720ab818e82ce19b00e065623f612641c775d56a7cdc6aa70b0b219afbf8c9b3b6b42db3a45e9c2d73da4391cd4d79df4f95e944d0ff4c830445b611f0207f27e2334255a1d2a5ab53f66b8d305a72a3c8b200bfeb6c67b87cf59ba267d9744591c461471cf7c633d914887cd3968e9d7e8ad1124afc6c8350ee8b9a3e8cd21bfbfed7d2d0b3956d59a24f344dcc8fc54f70c81a9e8d1b7bf6fe3d71519bede12bef25f8209afd10d69739047774e01baba453b53a069b2ee86cbb18e09d8bf8126a4b832d6261fb93898a787268702fc021507551d0ad82422b7c0128ba61e61ea647ca1be674a273683f18ca7fa405bf4ae2f42ad226aa1a45414e93d5a8792442d44b4f96a44aaee6dc15a1ccdae676916184f2a497683c9084b67b83feb8f1c17fe8e27d9391f203c85a180942535263a3ac02cf81376fc2019b6287282da086ba2f40656bd4a2642ea72bb5278913e8549ca71959aff4f2bb0eed4836790a06ba5dd47db91b2e66edc3c69e8cb0c469885853ba286d9218469fcae3cad4069597ef1b1fa7d665b578c6db9b30dec8735893559733953adddda5367e57c0d5093435e859aac99807ff88efbdb75318b136cc66a2dec3f401de1aacc0c9146b0db4d8d6011a56fda3072ba0019601925feeb153b16f2249751cef4ffff8f7478f55e632c9221223b3bd6eca4935545aeb70f9bb0e2c0dc700c22ade87353440e7745a2e306e2b871b1eebe021c5bdcad1516a0994afdab355aa94575fe83dcbf0c1663b2eec5261263e3f62afee26237e131abc0cba1e03363c183280cbabdc095e7043e5854788809a674693ffa528b85723139b2545b544079c19fd96012c3d581daf0991efc47c97a7d141cab7fac949113e5a05445c8b254de8ab9447404887375834641e9581dd72bdd666a9956268559a6c908b5a604de2b6cee0aff1d63181a7ddc72e87db45d87d56ae0a49682e6337f38c4630fca2d2f524c02be55f4ad1d9f791c2f690c9f0049278e07678bc7338acfd7a317689749a5a8349398e739a9934cad8e711a9640d78a0860ecf2a94b0e8fcf8cd1772b6136f7e5004f986831048515eef456402583f2b00d4db4df6f454328cf8eb868178b9c8fbbe52406f3177cba314bb353691f3e57033286dd848cf17d44a0efc4d4db63d2ebcc9b18fa877749f7a13ac307fcbf2f76d52e3df93d22f2a25a1c8ad06ef5b1c07bb5c48c9848b3bbf7287a95a9beb59637dbb798c6c3a0352ce5697799831d2f1c9d28081fde4c7d01e0b99facaac58fd80346e6bdfd55ee5a6e7fca24bd0ee3a1b98be948d26af9c097d325771ed6c9eeb3aaa75104839c38824f2ff68e16b13483d0950b91b3171757c713b371e24bc37ad109f2739a55a50643cad8e38c41c549b69f82dcf9e107b9fed601a630068e4e0ad94d6a479644e9927feb2e804617569eaa68912a678141509e31bd3efa1be7c82af512c2707da93a04368cbd755b51209dad586f8565901037e138d61f589e26f58dca35597f75e8c12b4f18f76d9b918da2d8b8ad587601572533446b29ba7b70e6b25515e48b3878dfd75616a2a647ea953e3b132349d0d64430e56d013bcd3c0cd8bf28fa543a99335afbbb9a99dde8f5286527857296f5a960dd1e069fb1705f39fca3641002fd0474897abeffd435dfab658c7aaa145b4c3bf32049dc66a74a20da84cbbf5da9992a9ab75eaf20cdc7c05bb93d5d6f79244e221e667258e9c91a75469b7378ec5845212ee81150cb6b61976f74c1c7b551cf43f6e6dbd65a8227b619d8eb18cb0bab3e6f39fe05e60f49be4f14320222272f7f7757ed4c8e5e3d0a69ff37821dd3a5e8bb5bee34f576902a34d5c0bdac434031c15721ed71b987c5752882adf0d3a578b7bc09838c42942ef41acd98f75a2548bd241391822f71b3f66f3f73af5210f66780b77dc4ae40c95eeb63cd5f222593bd91e068b44fd12bf053990cd3c2ae74d7b610387837d472e4743c134c7056c06e906b012e0ef6e4f08cd6b7f0475b2419af921555c881728cce923dceab78d79d2eed98ee225a5c31d2bef59856576e2c488f503a0b79d4db9985d756ac1020a08618f44bf1b41487a8f0fcdd367d76907574aba48e4262c30c3db0b188168a533bece8dff4ab7e0307fe08b640f9b53158fec3b5f58504d5362a84f830aa38b565ab8e58a73855958646640aab1921b19a67ac0270c40610f6c1a18a485b76e4279a8199e14747ff0bb818b97a241c89c8173c30aa9fc7391ae06379a725f4cd247c5f0659d04b2b7a5bbdf7faea0afe8dfdca4a55d562b6760fe2fa1803ba0b76851d23ba796fb95f73e429595774e056bd0d283a89e1229d6a857f3652b6fbccc5211dbf4e4ebb8f03cf0d773730d38b960aa55cd5b926d75bcc3be504b11f6bd7895392eca77035dceea2350f96259b0bffdd7aac67f55bc6ce2c6624ce20050f995ae14cd6d98f3940193f088f6de763aeeaafaa26c871a5aa63b17c93640bec292092787a1cddb051e6e69448341d02b3b8660f12ca9fdb0f603df8d4956f5c17ee22540a466a4faedf00761262e6bacf2714bda09bfba877126f1b083b82d757374bc5fcb3269bb984e787dc8411bdc47c6c1b0c5e4b0b174f6e13972d5f4b2f7952036d9dcd3e377ef8455e04cb6bd6609863c5c2fdd8bd355b6cdfbdd56900c83d50ccf828138fcd8c960918cd4d110bddf904c0deb19bab432d7dbb9736515c1caa05c9370c6c1c7ac23a3e073fc964d288754ea0ac96fb8299eb9d1989cd2e81f9e3e22e025a404cdb73ab9b34b6a4e7e8024a1160d4be78406d81550395d3c6f29fa6a361bfa3910dd23f6812e2acaaa97ec1064abe07958780df23f270b58b6dcc34cf567083aae6e86a3912d48fb66405b7c297fc48664912ab54981837281607374ece2f6c221eff2a2f2c3930747208985af2fb7f673b42e6bc9851ef53185a08904887a18764c206639cacc5a95b18f5da012c4d0c5b7f0a80c1b82ba44b0f483bcb5c36fa89d3a7257f23d007d358d6e1577b65a28c09a122d9cf214dfe997c155f795ffd3ce3c4f5e7421b0f3e588580587f853ed03c7aeae8bcf25b5b3d9ee1bb6ce9f9d21dfd5c050536b4a6fe0bc84eb36471be799d960a06d7a46dcb5d4f6a19a67aa5913a5ff64349ec32577da8b704af751cec8f63925d909b2c9fb5a39c0a5ae781c9fe36f2f159fb70bd22a2925e611ecd6d68095c01a549f9c01f99ca9343685321a95d0bb6dd05fef6061c7db54e11eddb4843a7ee07ad3bc84eb721bd98493515efd2aa76862afc722170a5131333b696b8e4f1bd473392dd6f08c2a37fac277eab1818ae5a19ffa13ac8d8bf1058b3a024976882593bd2a7f8e8aadc4a69cbb8a8656da37baae5b4a1b093e02541d8afc410b0e1f8c86175e3dd5e95fa7b2c0c70a13f367b49ecf4c9dbe9e7edd0a1476176a2e372a85b3ed80b7ee9d67dbbb686961ed763cdf55f30f3d9fb5196920d951ffff7c8e3033bceae2fbf2e2cb01da37e3c03255235bc03ac92ab1f82957ad930e55d30f61fb4c2a821aea1e85a31879e5b2170df072d7c891eed6ac22d4a989db29278f542818a00ee4d6fffda68478a3001f392117e5d648e8798832ab443fd19d2b1b918d78334f75b02c690bb6def3186c3ebd6e4015095af8490d0a1903792157381a73e836fbfeb4962ccf6457fd2a1b3446eac5eca4b5308d1ca66195f82a0e669c5004a57d6b92f0dc833417c3cc5f6067072c86b428323ecec3f7b3ab3d56f97a53a9d898b93793c21fae140438f4a476d04a8d4e1cc028fcbf1f1f22c820e2e036733cb71a6166a14028a6bf9ccfdb7c8e5a0db0b7d0707ee9b45d432c63fba791cdfc251601b8762ffda755abdbc50b42f91808844574c597938a8ce3d5940abf2b650f0076e668f53c6a63247714c9f41afe909cb5ea1a4ab0ec793d3069395fe63f379ffbbf7727ea401c4453f96e714d244c7bec59bc34718a66d9e8a213c07b7a471ee8ad54aff39b0993f24a519beabf36208a75568d6cc3328597f729abedd232493998f6448a9c6d67eddc41a85298bb2bd2507a88597c491dd68fb9b466fda5e5e14cda5803b9469ccd9c5d48fae1905719c51d7b58926a123d5c86a102f4b6908bca1a90a77ad15143639a093556ff654cf3799f014425f2b4a125360c4f12f7ab016750bc8208effe28be4bea0336ff459da102b2a2fa7f1d3158cf2430804e169bd697f6f97316376fcb4a2be2ed37cc5ca604f135c114bb4741cdf2c2eee37c24777ceaa59a1ccd7abe9992c2f07ad325564c05fbe9a53d7a8d63d1d74afb2b6132373320cc4bda5c61706866b8a0d2b7cecbc64bbb7db5ba762e03cad8d5c19eaf0603d19ea7fa17920842085d0c04dcc4bb5cc88a1de64a2b62a133b4a3f1a01c898f979c881e3aaf609001535d4eadf24e712520ca51c57e2719c8b8d621b79ec546b2e5715f81fc63ea34c7634a643e235c86b8b8c2d18e75fa17f2c26a52d8df0f75df93a64acabb585300a33193248bda38f719f15b1384f4501dbfd8cd9e7fa1588557f6436e4091bd2b29a39b11618f09da3b89f05e444b6a2d0630d6d37a73762e5301c96501c56b9db1aa4b586bb7215b42c85d62b18b8dd827d72567858bd50cb8d9759e955720ebf748686a456fa5234ae5cd54897f670c12129581ecb3670d0bb38a2e513b01c01c98a7e0764713c54f0ba98ff35e2d692ea58c294d29d54d02f83b1426246a18c84897a214d0e4b91145ca3cd8a8e3f5cf3b7dfa51831cea9075a8be1f8803e1217252eedd285a3af788cb40d035db4dd35c02e8d61fd8b4204fbd716788e414dcb9b6acb68e387628e4487f02e9f05e264b84f8bc9d154321c89b2791df66008033eab51e97746eaa0922f4d42bb5267f21aea0cb04f54cdc3aab5730118322d1ab0a72c5556d058367429b8bfc2aef33f7d600ee85ccc94db4e1e0a38714d9afc59bc0dffc98d307980c790774096a943fd28d5d4868fd1c7fdc2e576e255abdebe5edf52f34f5dafb3ab34b646ba81630e339f54ccad4db227487708e7632021c0adb1903de3546f69c2f0d8b83f4fc4cc09c1ed64e46b3471ef9574b768e5e0004280b69ec35a50cad75de3a15df07a06d8058f522dd62d10fc29c5dd5b79df362aa871f3cd809167d22681d874bfa234b8a200cc4e3db1947da192df9041366a01ebe07a5c894cdc093bb4bcc3b5b087918053e9311b51ec8a9163ebc3a1b62cf16dfa1459ab727870f5ca9468deb89f6d74bd07a382af0ed011d0ed0b13b03c8f961863d8b001afccb54e9e50b6b2c231d10b0e4339de781288644507534c63706498eb515e7e223b472855746c41a2a16abc0f6430235f45daae754d03884f9318352ea3d6aa7c61c18eb61b3a899f3beab87d73d88bfd519860a05d45a8f8a1211a03f46027665993a599d089d27cb4fad7b5dc619a4bafd931647e2a6e65b514ebd718ca58d28dee292941696048e2187ab6a1b6188bd766b27dcad5f875b674fe7bf76b3e3580e02c0706cc74e8fc7de06be3341a0d5f4cd82ed23a26e8fcc17de2b2567ea8b6280abb9e2bb7770c7d469bec34a7dc38374e75653374fda823859c950633b3730b96232e8b68c39a32e939963754173c3c949aab0c514cfec650c342fc3d492eee4f014ec7a0d0e604358ec9ec3d1ef15a0bf6ed4c07536a487b62aab9acdfc3bc0c6733d637c97f4c394f6c11fc9c16b339f58d2a4fe0a8909939909c8c57748500b9edf46e5d4db2be09c94a6d9b021dfe8f06f03ad5406123b1a6811ed22a5cb0888befd70afdd65cd0ad18dc5e19830ecdb60b3d59f92c594d498269f9924e3306b552c8c8f0726c12f650012d0b1fd38c62dd10735188c4212a3758ba60828d83e6298bdc2c4acb6930ce5157495d9d3fa2bbfc4624e2b6fd9b9d27346c360c4696b93095a2ae52b70be19e518f65aac9f330795256979c8daac14b3d3b84b6a32f401380531ac98319f9d9f7b67abac017b49f790e91df98c67743817daee1b185d3ce94ce5bcb8918c1114758b7b63a07e553f81ccb3c23c04a7b88dbf9b24bb5082d383ad7aa99939afe02c7ffbdb46b489bc507a599f466526096b8dbba77e0e17301b0814423fb9b8128d40f1b897bf2663e3aad09dbd41ed56cdf4f4b85696e4217307dfeb5a433f86955ff8451067b8968dd4e2fef202f0227db22b30d6facce3c6ce28f362f1f1bef10203ad843d77fa6b57a9374b1faf3b7218532d96fbc3a3417a6fd34a620f2f4665af7e19223500aa8eb03ec4b433d57f3e6e3f4e995a841f937a4ab86ca19cb9f0333e3970c83ac227b9b201cccb35c792aca0bf9c15df6aa7b7e55ba40ae08fdbc463729565cb1fa0240f8edb385ec74f02f9ddc0dbe11467fa298b765304c72260e6fd9e85307dfa5353c9f1e785685ce43b9697ee2f82dce482769df32209e20e6ec8d0f57fc0ea9dc47343ef7f466c444cd2d23535c4235e10c53695231504d22a9a62ea09f54169ea533c4a89cacbb8cc7180a06ee688820e5d1d8e98a34c6a91f329934a54ec05ba39e07e05998f428da9a576e430963741bca6d66617645d608db4ec1d0548cdc8a1d305f66596f069db66d03f2893ea15bf880354a9bead644f34ebb9639c26a42f5944f370f25815d85e45491457aaa689bde45e232c799a5eb001dc1c796e869d257cd4889eac80c927c003ff2cd579c43434f1befd523799d5f2b93055a02017f0145c7beacdc4914dc45fa5c58bf7d732868082ec953d43f98eac51044e390b18a7dd6a62cc42d3c3444130a95e81a0fd61f90af723873215b969864f8b09b1d300210799d164054f0e16b8a89177756a1d52380ca855a4cb9e8fcad4525ef5ad44f12cf120738534a930a6ff126de9ad007696e5121aa5f0d0cbf27680aca8b3b4e756b8bb64c439ffebf7d43719c9541f1a352b7849feab35a03b7794471cadc6de20f2654bef3478a703d9904357766e6f8017377114dab36aa1d4a248ba79fb34021ceac181e48d17ea56cbbbbddefaae4b347b36ac431ceabeb8eddc3901cb23bcdff35fe4ee65c24c24829a0ab429f6a8eb8912495f4770b4f3847a48da5e7d655e6b9f13adbc78102f517d8d023bf45b86f938318f00498151ec7b38af107cc0d7d056dda8b6c01a784a8dd1a776625b217eae97cf3ae32be46d42e2f42fdab9ac5ffbdc83424e9aae32522dcd00dc3447654fcbab8bcdc35717453cd2400f93d550bd26420ab30b4f032ad1202b83aaac000c351092c1e5bbe312a462a2f9875e00a0eaf3e3e27bb905bd72275a5947376c88cd26113069d393ab49dcc3e8bee74019d197660078a71e2b4f8ebb612a6c5382d7524db6fe2343c0828542e97c596729faff03af7fda8068f7abdfc27c7f36051d78218fddf8f486861105df225d39606759e107c440cc768b78d85a433fa528795064915a39bc7ab3fad2660a2020c63aa3c3f20ac21a8c5d569920853a9735eaf01deb4e6a5a5e9699b33f7bf16155f4a28f1cddd9b846bca68c46817c8644057dfffd388d64daf6417397cec208b04a5d6bd0369c235aa88c0660aa49c2d2eac3582958a5da0d8b6562a74c12271a3451a194fdebeab439971e38be137fde89be283fd1d00a2ab1451d0be9ce767f6b23d70feaf5c05c948c0a8a4a3b335d3c2955084085a04f0c2f1ec4e4f9689551a6f356ce96445d6ed2d178940b1637f87e0baeedeeda99b745ce82e16b8e85c75457048545e3e346ad94d919d05d2cfda5456e9fc0ef1c21193ac969119fc9b179284a246cd8810afb0186fda9db062b64db7ecf69138fedfbe0ef820d2ea11a5ad875b57080b68e3bbcbb20aef38ab39e665f3ef5413bf80bb4fe5591c3b74425e9b3add9b70ff4a54af68420df80215aa16860aac851700acfd5034d94f3ef46b94c1c67bcd60b45fd2e9cbf92c58cab225c175c7fc83623e66eddd097a9cd087d45bde40eab4264d6ef5d249bf856e315472eaa4a84fa00a346296352983c877bf69768f2b9a7361bb0ed9d132331e14f8e3de7f822e4f642d2f938fc4aa281bca957a0c7589cf790d33f9d2bc6a2cf878e0ed0bde8178e5d6b97806a9c51a96b78f5cf1b1a244b2095d4d81de262d229c4443fa5d0ed20cb14fa75f156e4de8a8662d5288aace560a99750dab2d86282de71a3accdc3903a16a33b8f6a33125d5f5668103f00edca1f6618667aa25375b0d972afd7f06ca002b1d9d4c91400cd0328f5d192daa0df65edf6e5992c6e497c7c303717e2b303e393ee2cb0fc50c0ce07db5cb9993342aeaa2a14053e580b2251e4beb4c49b7940573db7f01c371ec0a08bd61e6aa5e34fa98dffb6cb3c5e803add34117d35afef3df1fd5e1baab84f0806220ea6b8d375eb813b28e381a7982434e6579191dc2e8a784d3ef878b4f60d1e7e57bd0ceacb7f44542cbd2cc74a9b14d2c1125f778517ec45069b06f9749c49651a73d4824ab9998e5a0cab072f6d5d7068ae484c33a426aa26ef22839de0631b776db5c90eee837f614962c698c8d67f6bff085e202d4b7cc772224cc6d98bcf10352abf0f71bb69be316e9dcb27203862ddd6ca0ec8a6d915b878c56b1ccb8fb157b9d58ff465824ca02535b5c762d3eceb76d6a053a28730cba854baec281236fcd016502e7b977e6869cb1232b19aeea092fb88233947ed614922d4eda62653b00736fa0850955d1943484a12d32c513dc04fe2ed7b3c02c25e7a4c1871cfdbcc5abac226be53f9fd646a3444d146c1e40dd250c04687ec56dfc4682adc25129e8b9456e2462006fa909727bfc832c66948b639d7b47544a29d54cba53fb8593773f06227f52e5edfd76c53ab1dccd76f10eb65b001e4bf6323fdefebbc16c78dcfd927b13438118ff5f92dca17be406cc6cda76332562c2ae11f6e2d42fcf460763b714f0815a8feb4122d63785dacf40c408e5c019b7ab8fb7338f20a98523f8f450d6afaf75a97a3541e10055baeb6a9bbdefe7109ac3f9a313e1479cff5d2454cf80d43542f163dd355d88e6bddd019508e8297c7509153d4aef29d9495e3a163a7f5422916d7cd11eafc334b039f770875dcc5c7ed2b6149e1f246a511345c4a9e746cb6c03a29a34374193b5689f7179f3485a7e4a1dcbaa625da3b2912079fb7c8aee6ac04ff3c488e14926d93c174434d2cccaef730014981587423c1d92aae27d5611e007266ea2e12f4dc83958aa504e888206b1df34c21fbbc4faf585ce2778c1463d3e313820071a1b45e6e191f8e249435a369563cf7ee9cca18d314c6f1bb8b6f2e5f5679a8985b805dce68c45800d0040d1b493edceff7f33739e8e0e54155baf3b4c9c8f78c21033c9c21b9c222823a53d253d6ed945d07679054b8e8213db3f352bf35fb3f100858598848a8f1ded80c4d518dd7bb51f3a88424c1008a231b2265d03edc12f065494e8d7bddb961ba9c662975fb63c4774b6df7d37971e39edf863ced382cbaf2536f866e8796812e81a166bfeded66f2c402635e771071639ba994fdecd0f05e7005ecaec795dd24c7b09f2d0bac076592c23e85f1c0520ac48c3f5864b3d001c29fdca58c95a3e26c536be1fe065e92ae750c9633171d10626f9f3100a9dfc5d49f74ce1de7ffd997d91b17e08070a738f588da16a3cea50de140f8cf1ec196b31f0911aaa0834fee910f983c058d543a978f9ddf78d17531675d102dd3b0a7e26e037edd39d3121ee5ace8383fe41178118163cd0df8dad779932fed6a1796d8648d5d59dc7e036965fd1c71d9207ae2d4b4e92d00f9b0ee37705c8143417c221b2fb5585c8b5c9a6d6efeccf286446669f7d6415a5c434e09beb048f38e91f9f754df5e62d9def4f71041f37eb540f273eaabc00b4fbff530a48fd249754a2bace138a91fbe428fb33267c4f72009df7b77d4c74e0c76a005af12e7813a578b6f28f46047f23a3b5ab8288fb3f26147ed59b15f0c8a0d68f01170bf188fed2ed32aa7a16938a8fa656975c0d359532504ad036ba4fb43fa67412760f9c88e4c16a1549b16395a1875c3da2690c7e487b2fd70a6c44aa0fc57c984f3058df3b3938b79c3f1930175a80af1014e09bcd473fa6c080d7f251ac18469b1f9f2730ffbaa062b60f1b7761bcafcff9bc9e92372cdeeefcae1d6050339909e468599eea4b26c19c46af8874c2ac45ee0fdec369a79381db07eebcfa93ed3b7ca90518526ae53d549bc1e4a58a5fcade4a0208fe4547e53aa7b6224a9bd38b2e7c8f9bebdde231bc1b4d39cb186933da7c6b44a9a003cbc86a330edf261afb4c8a98e25aa3d9e691d20a34fe035e8a39fa4aee8cde0636ef890b678126b5af5b10ddc8ef782c449d1c1cc0d69bb5c041fc963d03b70560a1ad18ed42ef3b8dbfe37c05b4468f0ca95deb7cd3632766808ef15d980206845f5edf867b4b49731d71da3509b499d8bd32a516b59fc3048bdf4e21bf07af0525e0fbc2339b7f244a2233b77ba954f40bec20c83ece653f1548c7b49feb31d2c5c675ef097644771c2f1a1710cc96cc216aa0204b6b6a9224aae621d966491f7a4ac9d3f0f51a09c35e03329c725680084834af6d6fa74d9ab78b964cb8a8f7f05995b82b95a5874a5a61aac9ad63fe2d570ecbe545f12b38d49782ba7b9424f60eef60990866d9f0b19e64d91dbd713a4edf14cea61645d3cbbec26bbf0bf4260c90f6d63e00b3a5c2f6d74b44bc3f9fd9e480b01235e2f9d6d647e99b47e61a251db82e976f74c4b0b14ad4643eb4c07e2bec59b8e6a2edac6c64d9c30cb7b4c5ad7a07fb5afc7214aac8a6eb26dc9b76510137f4146242972ee204f86614d0d42f20333b178a50f88f8e383a32a7eb3e387b5be32a8df80691a85938dcee5e59d0bd245f75a87f44034a3edf5451ab53bf802405b6cbe49efc5fdcae875ab464d40fe15026e034350626e0f4a9ef9857c16ab4c726e663b2d4ad7e9f3b50a1a1b7bd9287059683f9d4c16cf6e179372a9218cfc035d9ea6ff6ebf7ea4e5b914f6cc3ca1a5e1cdb3c1d4fcb30ea2031aa5c1ec4f248f2b3abba51263ba1ea8a77a06cdeac3b5d14c03538ab7fd514b305238826c7939d003f6b41e5122917e828f6b7d579bad7723079b5a8d7ec09ff9aaa537b6c19ecd79e337cad9d915a6e43f4449a3aec5b9e0ce4f1795947d3eb1e6ef843beb20dc9c7632abafad4ee09d77fb4fd3912282c7ed52c57772874e344d8d39f70c28c6522f07c691af2cc04417dde2954fc482fa1cdde44e63b5e7ce1f903b33d77dea8aac38f19f06df8e5f2157dea59cccb86c3c94c4f5bfd15725b11a182233278eebccaa44557bedd3085823388836671ddf14318cc7b4c2e29108e1552c0626f7a7794b526e9b14aa22a93d832489a8ab64c901dd367fee7d5dbd2a0abc3e178aac0e147b2ba54d32d5d715400f19682dbbf468b5b70c5f775c0c3a0193f12bba8043408536a04686f588e663636f770c81a7403cbb4170dfd84d8bf648c3abf43df2b469b17581f77c5cb55f09b0568f27d2b202997c52cf0beea2b0a868325a16b3fff5eb7e25501c0f1b5ad110fd93e876224a67b8229b757efb250ad15560a7d1501746f58fb40b0e6951cb5c738ee5ab701a3171b7eb5d051166562e14f8522a07a3bee52a230ea6dbb0b9e745f49b484cd9e84362274cfcbb83e235293295683bce7ac02db946eb38e796f5a3d83393d02c172ee0a2b9b3cd6d53bf7b8d8c5bdeebc29724342acada9d290ed415645d8f2bc84c33d058fabc3d2cc949fe8b5fcc3904e0d39fb5444523184157f2a4d6e8d9a5601528b9e223887c4ae61bc2d475bf3390a86b7e36cdec0c330771ba7ca3990beab274601300d0cd96565fd258c6e2f9ea630d1ec2f6edcfb85536385613c0fe07c2877f0fd887c1a6656cab9d122d68c2196612b86828b239790223aafd346940e9496715f80e93f51cd2238e97c0c4fe3766a86d8472d5319190e44cf6a789eb2dc7095372ecdf823470dbff2335fd7def2853afe21397d413ef23bde42bede49e8d7edc04f60788db207713ffd8d16ef351b59f39666f321714f3a32999f0ec2b67fc67445f59957beba497f682076829959f2a289ada7df8a236746f93d75fbf61c16d75d5887c8540bf679c73f43746abd71893a53dc71ec6747592c169f1fb1e4233ceb0b1d34e18fd09a0c46a65bc37319bce73ccc590e39b55a95cbf55d442d74c39408a5e2819520e71f046ecf54edd892f50cbdf968ba400f58043714b9b40d03b01d46b17f7931853735520d22678856507532e92411cf9cdfd47a3685582acf15937c11494cfe68842ba70167f35d47fdd516025fe98f2349f067aeb14ab8412343c58c4f1ea8b563bd87fb579d61a735758e2cc3726da5b6c2d998521df657c29eb55490688a71f163a0e742ef7c64546d64749b5671f4ca40cf16c8c89b9caeecf3c9c43e182f7748200263dcac8bdf1ae685f7eb996fa11463cbe934db73d4fe92f49b424a450386ecc6a9976394058d1bc4ca0ee8ba3e389639e9d0348592db5af1dee54ba634428fa94719bfe2c39014fe06fa50f0d1c95453a6646651b3cdcaa314ec0cc42ae70e353bf3093929049367ef25cb7ea62f55256152a83bb0f9700a44d76cad0cb54c953906f6a1477edb93679b03ee57f3d2bc102059b696bbb09583736a603908c4536acfb4f2b8a4a7c202a66ad0f28bbe5bf08a5608c551d10c9626bfffcf15ce2c729900436c22884a110abde325319ccb4df67ae3de405ca3ca7590c19496bfead78ff62c7c7d4987e915428e57e3245829f205339bf2190fd277b0ccc19e4269e39367f1132070ca1851e4ac08f3627c3c2049859bee65a662e55f86724e95f508c0505c25e34897c1b94689e202386ce7ac0e2f4a0515b8a44e8a22e19fda1a0fd3a2a8bd620121b33afd1a3ae71d52976fc1dd202a1a2eae2ae76f79143df4b100707fc2c38e41f9004c544a0afe674e4fd1ac235a9fbfa21037a311049408b1be9f6980580869aa2795372ca931953c2c95828573aaae93d7bb064f064ebbb1386624eae395964b99c51f4d5e4f5747c75aa783f657b87d3a5326e812529a9f8fc8d3b043ab66de46c35915bf4a252c7550048d153eece18acfca37ab4551108aec3aa13774d7fbed0559cc56bd6fad646ec9d237c9e7a1d1d6e3a6b111a3dd548423dd3cbc7293f59604e97e1bf53ef94482f9eb90c6c14377b26cc5c655146d8919c00dfc5dd8373231add28812edbec8ce3623e6f45a4fbe21b39ce0514a1e872a46a01f3e0a9dc7de10996a49230f265fb05861e87e710bb50a96b8be06ee1bfb4801db5b5e0fe8459fddc6979f2568949d7fe6d3ae4ecc3987b50824e1f16bb24fd1aa8ce203ac3cb4c9cefb01f01f914a45ca3b7d33900005b028dec95a6297cb6fe767f1cdc9d182cfcc3689b2bcf5dae70d7bd53268e0487cff02e3bf097a0f0d5309ce890d2007869d584905f32c8eb583150dc0c1e1319ba92e54fcf7ea9cbaf130d54e42d3664eb6e1e5991fe6eee8dda45af5a8eb75a4568040c6b6f9760313a0fae5688aaacb4080e3ed915fe90b10cf1ae5fa85f4197efb95c247f15f79112ea64e9dba0e73abf294f0d62135958f5d296c20eb633fcc8701f00185817d285c5c1ae0840288c23c54f81326ef0d52013d45e2463ced4b0f253425d2efd211990667adcf4625a11a4fc4e7e34236a989ec54a9a86040c009eb18ef79d6c0946d58206366d99fefc49f9b2237156a1ebcb463d81858abc61ff5cbc7129e65993d5e5668b958407721090c21bd8a9c448166a23ef15ba8c3b3c32947708030a660a4117a1d0c06dc8b48d63d4a3a5ea35ccdc7c2927cff2255159dab34cbdbdcaea34146627da8ffdd1bb259679c9fcc6ea3ec2ffa8c3af96406df2a32cabe055d5b0a1851c2578f6d3a2fc2188c288e3ce49292aad47f3ebb562f0cc8608e9ed3b8c59d236884817baa4785568827a9b40f7bbaee8daa85f8a32c4ac1cda267c82fd859f0a776e6de8f88e557f7db609cac7a177169470ba27797762053b88121a58ea1f3a67817537980404faa7f31338e99a1e7f0b484a82640086e885f0d85ff576f21f789e93a06798a0e01823f233df20eab0852837ba2f6166ac68f7ed3e134959ae1eccf4643117f00d25a752c76bbee33a951b0111d3e92d840b50e9b28e39644f0de402fc2db9ca204f5fe53d0933a6cc6b342f27486952b746bd518091ab70ae2dc5e45a61d1faf77596f4198b36e68346ee84b4987ff00df59fe4fef25726bd0d8ad106e3695fe3fe0ccc950d9de13ca2501c87bcae8aa6abbefb8a280e43908b7cc6b29208831c38504210efb648855f912a709361d84b77e8deed2a9a035af2183d1b4fad733b3f1bcc92c6bdcdec062ad2269dfb22b76df28125a65b7960330d536e14fc50f42d196b80ada692ae981510670f713ef5ae56c2dfc448741521f6d52b492a687373cbaec924d25002d725bdd2b23c395eec916a3a28275357bda4c00de1c9f8c9ee042381439526dc1e6e85b58a0d26b262fd89c70972d0f981bcf3a4b6310229c9dcdcb910c5c1f63c218a6cd2932635596ed8d8d88f15d4353eccd60ebe1aa3cd83e3c21b6c49dba9d8052955c28460d6628fd669ac53bc5426910d420222a5cc0fb00c11754bbb640571c07679cab8ad88f276dc82ad97ca13a745553d7c681d79d45df4446780eed1e3940813c5d77e28229d5194889cb185261c4e8cbc44cb1c168f319ff513dabb402aa42af59addeed444ffe0142a223e56ce883bdaaa8c17daca648fd89fcf2926b8e79dc5a0959242de31903cb9932d8ae5051ef92f66822375b0d2056c2696c5a5689d962cfb346a9ac1fbd9e209a12e13bad9ee458257d51937acc122b8c3a97b8dbaf50db144102fb2e16a0d595c70c7593c7f69189ac89f3d5053f0ee29da124a85fe6c35f95c269720aa31934e858b9c50aa982863be658bda40c060a2d6b5e1bf88fcc2f94f290e457626642baf1e9c094a069d2b15c361342e15302d882503950589f4458d3fde3caa0757543c822cf7d84a523428331a5faa859573ecd528495a8c0e64fbce6ab43a3903f9d961f6b39892545ed490bf0b773188ae0984833947934823380d60d5772cc6960c2bd1f8fa50afb5c2ccfd10fe5de1ac653173c8f482d8e8d3bda161f815d8f1034bf46f1ce34c058c22d603db4cd7a120f32e3db204f02e2f582ddd18ca3d9659b7d76f1ad3069b0e608491a02b00999e3cf339065c65a63b256c239ca6acc41334d3d68ebb4b0ad1cbe61c0d0fd6dac80bccb34d7fd97a71d99907cfb51cbc0dcd537ada6fa1482bfe749cfe3bed6c352d0c2338881b209da2c0dc709b7ecbc0b0f405219313e7dc0b49557b6cd1de509246a1f1c2701f40443c68fa8f97dcccdeaa3fa8d14428b5e14db274923c0cb47487333da78251dfc4009accd7342b56d959647d4c40615c19a8813768eb099003c11f11b98a19b25101eed8c82c4d7d137ed1759abd6ff40a03bbca0edef063d2364975194deab0880fbf1043c5cc73ba879fa80e66e292b8c3abd1dc13574f238458d86f9efcb9f231f1244bc0f39c79d44cba0b5fe08845388f1f9bb3dae1479bcb763a0d3adf845b44fa7e45d2a7a493cdef2cc5e9298e6b902ff2db117d4ebc3f9996d3affd4447197deb7ccdde87cb25bfb28e6676527dd7a9694e0e8ce76424f645d643ba60f20e6b8cf4e99994c15712b3c14f9aaa738097e335ccba654d55e8d402bc1ea37a8c73e6466710343cfa76ba1129b965caf7ee71844a854c9f2736d88a0d664d06ff88380a5edc534632acfd8431b2bcaeedb2ff9f3d8014921e5a7ee9044889604d5dd91e28e1345d1c83e36a175513c9ec43231c868d08e3f60c747e09052370272b042c24a3de760f6ba33ecc6c5d5606b20bbf66ce7c50c3a6d17b92795905b947cc7b23bb008b4fcf462a960fa6ab02bdbf641277e975a9fefed75f7ce91c2b6b88cb6ab0ce27e019690bfe3c0d3af9afb5aef9d683f49fb9e43c7dda7908c62a4c2f2aaa9769222a5989afdb2b89348a6fb584536f73225cdf69a87bf620a4c7bf7d63603f1d0c9e647e8fb63eb9286e8106d2e5aaa9d91170e8f8de5df6c90d757634acbb7c77454a328b998fca97a58d82c437534c96f5ea12443919e2ac5458cbee61f3c6543e14fc903058f6cca140c918dd376a7ca9a520dc3dac28e0daf223901fd24421441de8eed85ce83b805c599e8eef8b4822559f2822b71609fd7a093f25cdb0129d5fdb1d8769fddbbe7474d497e4dde13c7e9d7dc10aa57a9b5588f8b4a35e7aa7fcaa883df98e7d9775cf9d7f6b9f70f52ecb5c88bdb146de917cd2dc99430deda96f6af391ae319ad8f1e97e5b3ae2ebfd59cdf46ef06c0b04ae1e294007979df70689e863aa25d6cd2726a2cb529631636d43d5e7e34b440d46d5e985ca8cbec1c257bcd92c27d3208318624cfc36e53f320f80dd70000d800514b414abe52f7b79222b6477c353f68147eec8f6751d59b555894de5f0bdfd649cb36f29791ae8cf0707acc4d7efe38a8fe3003f58e7b8935f1e89d5f96fd6c6bc7e799ebddffa92a236d6612df5fdf4e7e428669aa3f51fb5e8f77c82ba12505b9512a75eae72d76be4514d25e7f890c1ecbbc3ae605505c757d447fe81523b4a0f1f6d4af8402fd848f2613cf2968899c6a7db33382c27a82bf5faf8625cc1c08e71fa235608ddd3092acf4cf9d4cfb5793a9300529fd436da53a847af6c0cce631a38df5125d0160e097bb8e87bd42f1fc7557d8febf3abfe3b316a455f95bf6d1ce08531bf07528f9058a484f68d0a07fe7968818e385776c97900c53020aec0ab403043a833ecfe4b5cad8b5c62d14c7b242fe86898f98b818c71a847bc6afd38a653815081d7d2740d5842b0504a48a170b848ed5e2a54174ee290675fb1412d5546066a522d931d5cafc5c5442d778d36e8c1ddb92aa54c7369d1811787da0095ab86edf2b6aaa73d98cccdff7731981f9375a2238c5f2ec2fe0744f6f547cf182a3e69eca82453a3037fed64b1fa5d778e45fbc7f636293d611d2ab154ed46bb38dbf24b1dff954a3bd5177f9ff17a043db1864b3510612ea55b301834a71a4c58b2f29b4308077aa377f58907e599c324130a9bfff0b97e848351db3129b06fe3cfdd04d4b3a83507ae483731ece53497affa6c66ca459ae846a91be8fea40571a594e57656d7e1785fb796301a67f301ca77710dd2ecb556774b201d418d78c01d3e396d364087d591769b7f412838052d4fe67f7a4346b803b36496cb1a61b5170b8f34889237ebca99987e700615dd61ccba05aff548a8b9f3f061af28da95bfa7e7c936ced0e2a203ac02a2af73087572c45dab8345e8cba2c436607498a3a4a6b452453179d4d3c7884cf24ef22dfd4f03c5b14e801d8f8b44b734a723b14e0ccf45e922fc0eed201f002b2b81c999fe2b2e5aa0ab7e8200636d2a14706bde81bf5a3fbd411e8bdbecb99dc4fa51ba3ff4dd2fbd5260a3d4a0e1863b2a6a60b50318f15d86e449b8d1919ae46894b230bc52683802bb668ddd1a19b6b86825903989fe1226780a2c1137f7b962a1a9e28e7936ee3861dd246e9441503b73ea46645f1c5c2d3cf4601f2b808aa73e09711596f477187751840cd20273ba44afc34e2346e0c6bdafa917fbca16dde5ceaff38900ee9c333172fd85b580d99d84ef02ffad9106414884499b75e479f15877c535818ad30cf6d12d99638dd05eaa17e90f3ff1ce5ae775d1b29ccac3fb12cf2b682e7a3aab7a36d6ac03cb7cab36f7229c2be4d00a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
