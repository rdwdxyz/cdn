<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f7e646d5203996e727bf9f4b269931bd73ee2bb2a44f0832813faa3226f754a5f6a5303c5be1770395581dc4f2e5b1f9d10e35c7a650635e9f5ea1d02cb54cba0947c98182c00f0e77b171c07d76b5f1c5c8c149e06beb1573de75a07eed01c18e9acc11d0f44691c97a43cd6d4e5409fcfd4363896aa010d3a2850195ffec95a64ef967e3a9532d7e63944cc28c48fd9343f52ba29d2fe0af6e23e3fac6c4703ee9452d1b8aa1b906fe93c95ddfb2809ca3c1071a2624676aa07b519526c0d3df8727561bdfdb4f685d462a9d9f2b2a95a7fe936e47a3621cb3d6f47e6542f36aa0109f678f2adc81f14c849fcbf86c7927b9bd66469c1032956a1695f7d6ef88e72094ea92c3878886e3559e6812223187cd2930e48d795633ef85fbd7f61e00bdc4dae626229cc8752fcd587dc7d21686985c49266a0f24a32cf2fef5198c4be9e27a7624e3ca6b86d1ac6a0fd8008fe6d3da6a6988b4371cec6a96f60523ec77b06f1e0360587a26b7e2efc34655fb6c1901d4fde969047f2cb20993dd8e972ef1e92c39b140c0d07588049dcdfaa9fad3720b670b1f513558813d2b4f9b6c49fe4db9e0f1f5d22ea3437d9051d90f3c6e57793ca9836f8da5cd329a440f6f484bc1bebd6c442198f2ec42c28b2c0120678de94468d7bf6a7eaaa893435542420293a2109a03bcf65dd30e2382a01a5196b1a7deeb463eb84941a56e6f60803c001d10f8a3a6233fcc8b7e708695db50c6b5bc2d4dbd7baad363a8de1457945074a9bc93b67bf923078f426c230af80c3bac5d0e9f23c6113851dabfd0cb7f0311b5a64bb139aacf96f34d76f88cab1f4dfe3e1c0977f9ab40847bad3e5b696ca3383a4b6faeb1207c69d473a87c391f91d024e44bbf5e84ce214b319a39ee632a91022d69213d38d6e2b47472235eaa068ee9ac7b97eb6953eefc82747f004e0ac3b93619bb23a9192d7aa68006deb3fd2ef2de1bd7630b192d293358378adeb5f749436a9e1c283e601d0c2b36bb91828e819bb9f085f78a62967ec3208731315c9b11be56292b57b38885b5a4755140a6c274ef46b25d9132379797f1be0e75325c78b385b52794e22530018716676d24ace613fba2c838b57219ff4ad9819286974d6423e63573975d13df5856f5dbec9c13957de7387e8530e1e00b551e963cc2d0dc981dcb7b48449d402b65decc2acdadca9333a1ccaf1ce2b45bae18e5b809ecc03e14f510fc87105cd7bb27b95a2715d1f281e0da8d039cc4f85c0c9b75445b9743149346f58ee545dc44bbeba19ff5d5b3d9a39f7b33f9a1a6f15987fe59a1c34798dd30427a7b73a15cac07f6c123ff1532116ab74dfbe5d955d3e5f550f392d9be83d5fa4bd075935061469e234c60ce7ead6041d623ee567ee1e666c2eb771c877bf33375943a4da891d9f7e01528f182ec60f7081142d4a6ddb844469a3a7081b29a614ea7fde521fe3e9cea858a661bf255f5a4d5aa1987d146b2df5f0f17de99fb47fbbf281ec000a4250ad53ad620aed9e2f0a3bc71b01cfee700526de9f6b17f8dac9399a716d702b14d73fcd357cad1f6c56de6b2a4557ec6239879f683b87fa05c2f66c6873d43dec51d16293602b75e4cdca223ef0d0eca43a8eaefa851d49e513dd27054a2c766430bf4aca56b794c8a30c2820bec743ab298dbe2a95c32ac9bde230e044ce06adb227cb1015769d080a7b12a021da5f01ff2742f1fab2ce1f28baec09b28bf2a7c92ea7bc0ece785f5b3b377d977cd24ec1e1dccfe4aecee0aacfc005437120d4beb2594ae19db89f688f50e96408ec699006eb44b30394ae4249e897d60865c050202ad1edc9995075b86922bf4cffb044d54d5aa3030645407577dd3b20a7833c4e77838df24ddb57b1d491f405158bc582651ba663511407c643708ca7b2dfb508da3babdcc5a357ba9f3a05f99a891da94d51dc71acc046af6f7397652a815f44da520af20f9c3bbb077bc08501d3ea6fe03d06ff251adb62da340d3723bf30f1756802bf8e0301457dd8d8881bcb69f9be8cbb4f3cb09559c22815256453c22c6eeb135ea032f62d6f6dcd78c5feecf6beef602a2225735dc67cbe07aeed79b8f125674b359a33c428273767bb11d11b1bcaa917ad00480646ac71c37d63160bb0b44824bd0b128a3e4bcb7f81a15910d8923446fe19684a30e48be5f9bdeabb852497bb9b0d2db7be1e26f72dd82c52ad5f9298d386d266195688b11cadb2ac93d131eb64d2e2ef55aba112dd3512b9063d5b140cb244032ab981af5f2fdce117bafcd506b8837d3d173f5e4097057aaa1b9ad6385acfd27ea1334c3f8d6bdf5bae881be2e467c0493262271570883fbddb3431c74cba66c4665996ce50b3b9449de0bdcc7da3cb35c9b58f349bffab70585bc3f386cb91d2ed07dc18a003e2f208373d35227bbef9e567be9c1053049322b3eb3b6cdb436f9d72f58dac1cccf2dfca10acd0c3ff94a7ce7b8f74d077740b5d03f7443707d672694bcdde1c46c3298b73d58f71621f1d753b6f6553c3c116d1f7d08261073c24f9893dd65d16fed203864a58271709a70f21fd0ee79549a3ed174527bf79c84260990746188acd603c9c3ce237ac2fa09934ada309b8cec0a4af6d9dcdec582db335dea2465e8de1b9c0197c0f00e021178511907bcdd57b65d8c4bf4229c9754929ee3e5b319b0d54e18e408c80d4ad813b6ba5b07d10176c1068f9bbe87d3b7da0462f2b9ffa54cfb59076ed3e489a213a4bba29fa44adfb18b97316d09f68e17ec0cb62743a477506efbe27ce414fad9efc52b54d9614dff9025f86a1d14d9cf2ef3d0142c59e84dbe0bae394ba8c0cd90032380d5bb52aa9a872bbf66e88bb143b6c9f3bf65fe84cefb4a68e118ae2ed1724cc4268673fec80ae29a57f22caa0c4a2dfcc07c91d280351d2d3f2ae22d3c19a545ceba33d4d68a0911e9ddf4b4c476765caad483a0fb93785a18387524aa33e74bebfcc8b5458e8859e75a3281ba9b6408488800459dd26332fcaf29ce0e7375331119c99aab68dcfcadf70e88e510a9486e134a08f81466c7b42d2b8ffb64eca025843bf068c83c2cc32d985a4d5888faafe2fddf1833acf6bbdde4159e7ba99f4694eca02fbb52580b58da4d80af60183f4ac9158f7955d9cfa8d3f2cc6ebb5deabe8727c998b7f407a79c24bcffb1ff576dbe460551cba2d7051fbea31a2c2849c65015169397e9a1d4b65b29d1244668cbd44b8c8903f27da6d4c41a51c658d7848a6af4f1b75adcf29010c1977d362bc861ab6b2bdb54c14a3740a0db71e00962c4ceacfcb0bdd9d2b04c16a3a16af341ca02ec97af5d0cc6d184b61771e7739ac6582614f10b274f5825c95e89432aa005a04464c8c08713758d28a42e7c01158133a57b9a02720da6d7bcc185135d7f099db8a9ca64909632414b4715486491af776850bff0e4effae4c97b76f7a2b59f34f76a9e66798f48e773528ae07d0ddfaa38e3b2c0ce96a44a18dca5fe539e804a907dbd53ae7d137a2fe5d4dfc43416d261ceeab50e38ef1d20b94b4be508b3f1c54c304a12fb42989241d16c2cf69ba58dd19cb8cd5ff2d5d41c5756126eecf5fef46ddd93bc7637d71ec8e708755589f7d8d2daa602bb62cb8c496e971997a2031ee432c4e2f07845d494209534658506d0aa1fcad3e0205bd5cee10e78872966352ceec7b9d4f738781ae552523a3b995f671422e351c2b2ef21850e021480a7c393014777112254005d1b407397115d89bbe15bf491e0fc894b657fb256ffd121116efd84ee98549f3562d1c8183f62516c517d4c2f38e6bdbfc5d0f5f45ea56daa26718a8a16459f9722c602e3a4172d04fd43254216e09c0b23c029b6859e6fccfb80f85944a137ab471d2f9af340ccf08d97905a63dc6886931ab079a2737f3953de84377524ccf8bd0de4f56c679edf4059a221e5ff31cf3e6b001c552c96eb9b858628b1f7398b332d58cc225e04929e88fe6338dbac6b6a3e082719fc77c489f36b7867e007b8c932b2c2a25afdbfcacc56eecbf4358c0479d078780a0b4e78441b9bc84751c4b31e46648094c8921ffb217afffcc8c76d4f1fbfb6dfb9700429f08140364396b5838acea26e9758bf7cb8d4c5bd2611842afae68069e79d0c63b6303d347528bf36297fff3cbcc80fef3b05711c37e6b43004d50b5dfa049e1a697630198efcddfaa66851b4d454ae17905c9f57c07564eafd149711d135e4b555d7563619d01148fc7adf60502c6f76008720856d3e68e4cb2edc242dfb6b6289885b9b84bbd6ddb0653777be848945c149fd41792023a6214e4a8cc8f1d7184451797010f2988376e6edea1959d92eff2226649163d0641b9a6e48568dc6c3605431d8ef8e41d663db3ada0f0f32f12e3a0d849cc5e7af2ef459e917e2a6f0a963aae0a024245fd7134dd8fa452c1bc4f2e09be2d015ae0605babb17ec3b72758e21664077d3e83c97efe64f1ec944953b76430cd6af50bf5e9b48c8d10d15ee108ef86687c580e2b0a7c449aca6257c5b42f92ed23b3759604a4680cffe1da1b930fd398c9b1ba5f345de3d9b45a0e79225dd0e5d538420b5aaad89e0b1ab8f30875d36150ce736eaba3eed88fa21e035c66fd1d8593b121db6645ce261a2c16d050b89f10ee03e0201a344af26e079ac44aecca7c25a33bf83e8c7718b5dca3e1388a0ab6004dd11fbfb31201336debd474ce5a6749cd62f7b7bbe7d11bdfc4c81f672aa15a53c20b7f5313c6d57faa3118c0eb336fcbd023b5abb8b063ccc9ef485c9bc4d8b76df2570496250ca015faf7e87ad1bc2948ae8716a209fa9e2858737db4d357632657622e347f5dfb8ee051cf1e88d8a79e7cbd0eb3cea81163021e211a9c4237cc38ed9e1efe91678041d40f363d01c35e45fa13fa58764256abf41111453186154429b74613e9f06c6da0e2940757a87f4102681e48254a223816bbca0c6f8bd45fc351f930d88316fb5af95f4fef2c5ff539cc237625a3b48ff47995df3ee9f933f29c5fd2e18d480b468694033569bfababe9440b5f41c6e9f70e0d24d9c2b748c631d77106749b46a3634c00ad12598086f9ad26925812864a40ccc9737caee13e9611b7b02f435d557d4a050c04654d2c4ff91769bc8ec678a846792c4ab066d4da88971d7120eb3283ecb4f61185922c2da819e87a65fa314d0e3c9e5e9172a086564875c75a9ddaa7eb95e3891c412987380c6abd0aad53562a6aa472610bda70197d6dd6bbfa5cbd7f15af7cf8f98932c462fafd7bbbfe8dec203d6ba9d21d4aa496f9f027a223bbc8a485a811fea17ef1d74eaa59a4c32fd0ee72bdcd70e936a5cbd7a8ab050e43b97696d9295894d2724e5f7778e88ed709a7fe705b19a7bd3d418b003b6f10b6e82d1b7c9aaf0dee729b689bffa279e31775291ac6ddd39e6682c69cc14eb462c31873c5f4f4a75b6fdce25f6b75ba7ac868f3f4e93a0eb5841a12f1f0bafe86ac8599a004cbbbc62cbd02a7d93283ca0bad4e88e83f65d2957657942386ed954f5ca3698cc33d8faad5d0eedf5747636e5439ea3d9f2811fa143b190467f61e15034be2675dd8fa87cb21d57055c1a4375c55d3c43e19b14487eff5ef8c371d187a3ba4451583d6be1c2d68d92272a145cc56ee269e6b91e31054709f9a16ff5d3f562c0119f3e36d6e54948d00894b31caa2f4b61da0679c701b74192ea2580bc6c800981826180c8d93f87ddaf412f0e33dc91ab638a4af296a7028a7f22f553e6e957897b89623f4f1114c3e310ac2a836a0ea62e18208f8dc6977b28d53dafa742153715e0851f6012bc6a17cf325c99b68b76ab3b7df853365a8ae8a055efdd5421e1547a48abede63d98406791142b9f77deb07005c531a70b0f8a7717bdd7d53a7f850d51bc8fd57473cc2f45e7a0511a119cd991cc2924e38f290fc56140095c1ebb3b0b65021cd83140434170dd246bb81c571b183e2c560d0ccf1286892bbd0578059fd87af9849e7899685ddf67eaabe89012079fbe19abce1a587f9ee61507f89e66256510e5210cd594200677ba0c2d3a2d2d21d5ea0d95987b4df2f882e9797bcbdc4846216d6bddaaa5e5e8ee319ad52a36d37551a3540587b94fd3d38eb0cd5899fbb59f209d82c55539968c7820924104325a9384f22547c551074bdbed442a95af85a3735e7566b4ec1122de4030fa83e0480fc71f1ebff9ccadb33f351d66efe2dd8b4ae430ad6fe0e88cbc07cf51b7d25dac9cd0bb789a041fe4eedf9ce25c5569bcacc8b9e9cd06174f3ff09653981a3165d13d2adc6922b3f557ec7a483f726051bb16ef76d2bbd5ff1e045e694e5fc44fd1ce1a954610691967f20aaed53b1a20acc65785784aebd8e3cfb309399139b2799bc57ce13a1f9b11dd36df4ed57fbd0aca4f3efd46f4f5016680cf7570eda274fd533f707ecb5ca657ae63b45876b4b40b3f07cb7d6d3133bfd29302757a83e83ad80c504a38c219d1dc41dccc5b0373509dd8f6ef0b824bafc0f19e4de0d38a4cb9f2513edce9667e4e9c4b160242dd42dc3c5c103daf1c7c5e284b3f2f33ff9cb7893101193dddcdad7ce5f2bc436ed87fd44bc0535454dd6259525e8a080269de073b62f68ca6d76b42a8d1b3b0a595a0e5bd4e24fe758ceceb738e361d8b7f449ea7bb7b5ad1a16e40e6472b342ae3ee8db64c59d2b6a26525c26094852fe45e626c98aacdcefd8ab646cb50e78c6886e0c499741c94581d373c1545be6c0f4a11ccfac52e98e72da1245eb2e70d2a44e99db45b153bd868c8b2c30559a629a6919a5b88e1ebd325a2deab216c09fcb873c241699536e5f4c0008e0a4b624afde178938a08fc0074e32a98c8251d649f24e93920ec10e28014ce171d1303dbb0d6f6a63c251a163d1239d849ed305f46765cf6daf28f80e24419bd61a6c05ecdb4240c7fa5f11d0e8137c72b1e973e25d62ad6873307facf8e00f940149660d33c1175251c6cc3debf8410e13575be3a34008433b1fef5a3a9511db8b807ae87f9431b98513aed7edbca300101b9e9e8d1a0b81812db5096b5cde39302c35156ef4bb45755fa27729a1a3dae1439b16a0ccb4e24ffe87c925a5b65d6c71b1ca39a5e9c272e907e8601335d7fc8bbef7b2e5a3d2bf1f83357067e709eb666af0b274456e521afffc57ad597c67d09a0b54ce292518ed069c42e941a981bb8f8d4b2bddfc07ddb2eed313e73bd4c47847860239aec0125ef2dd6b3b14543123e66c89be2495b2349b6f64ff175bb3cc470a3bcb329e07757bf9c74a7f72ee0dd8cd870886a5651100857524c5a5238e476c589f5f3829ba9d7af4a28821a057481a038c544801990f6db2edd20e68dfefbdf82ea8ff4d39df4b60322550ead511680d7ce1ee6ceea67d80e17701d33c34def4ff945ea6c8a9f476804a403f680ce9c2f1b06fb2f74fd1c6fd264cabf4f1b7f94d04df0b93c1047d3a1a046bd39f5daf081878d81d36477e713b34e66b8c71a56e00dc64d3b767512e6bfe38b9670e17577bd536cf25d15eb3563798a285bf55698eebaf6c23c2f2c762c0d1263e677e7d24f94e9a161cd62eae5d00412311dfa89f981c96e69caefef4cb87dda10cf6ef81cafb72b802d9cbb54242d3d982db0ccd311f511e5d10c8967a04149965ce9fe2a666cc98776fdf7670412c6c9b174afbb736adbce3bbe1b64a85045428d1fefdd24d49bcccc9ce7b3bc0402b3823ce7ccc119295f4df3e953366077a61782141331c395df3706a7e2428eeffed4288ba2b994a48b7ffa83df477db783b24d505e3725acf46015a086dc43ae3eac1e281f948f4cdfc65d14521f316468309fffc56b2e9933a40e6f2d9e6b3173de352a7249c99183916eb45240af0e8c30211a72a0ed16b0770e8970cda6aab11e5981a284c44ce7f22a657b428c751f08ab19980b7238546c22757fbd6d80a890c5dea0ce9ab36ce7c67065a58ede0ac581056fc967206c0519350cbbc3aff060868bacfc489320712445673d243ededd35b8455be11a1adc8a881efca85ef322e34904c9053c19b2704addb9c2e84f26ade822b000571d9f478a33d955b957488366b7e87df7d237bda2f13c56159cb7f69ff0413df5c2f7bd3e408c245a285f11c96ac24ea33ad708f095ba7313a914d3bf2e1a1af35058d7503fc84b41003b86945ab6260da8b2bda37c83fb09d8017bd0ad329036292f4f92c0c3d12dcbc08d5013129402feedfdf84c027a1ce9df273bcc863e058149c2d40534241a02afc363f2c30b6ac3aa247d3df422bca433bb4f9b7aca948f75cabe6badc92913a3b0f2181fef070a0e07c5c42ace2249e94159293b7fe281c9444b9c99329fae38f6193127d56d62ce2162a0ac37a599b7e1fe26174251a1d50cd0f02aa47d6d3b9de114a8e52faf4a6b707239b695df3aa1977bb78fe091d9b3ded6728fd2fbfa9d23398be81751a3de93142239fc42ef2294cc3ff4b539326c50547096fa90f78a616e8e52a8b19f48f20a865f3ec1ba000ee393d927353edd6f059c23e1fb7c821820f5e69d940daf955bd7006a7b5aa39362417a07ceba7bd54c83f5d25c3ba691b83dc4af5adf30646924c5e815a4e2bc9b0f3c04e6fde142f8ae802854679ede5242bd0da81defa4fca012b0a86eb1c4917db5407f342a8d520ec9f121b0ce65519ca573509bb59a89656737c52832c7fc9a8ad39b5479b3257e22baacc6eca94b6e13abebeac8130dd416e09a67a848680c61984683e0f6302b2a48a7dfcb9686339e5c43ae755b657c65a9f4fc686d9a2c050b59601bac81ff8648b6ccd504a412033f9072b1d37b6d8677374aaa883e3f1f71c48d80f8ec4d52cbde6f59a1709a91595243e564325d0256129339d3e91735aa4ad167ec3e18600cfa32c3fd5981e9a86313c12d69d14fa58b2c4185286b6b56b6254a97175d46d412f441a4984d4266cbac7b208cd0f1daf891ed874941a1cda398804e11dd380fd020cc0b5ce34cd22c9b47169ded648a17d47f2725673105820a008e45ddeb160cdf6f162b50e2c45326d5f19eedab4113eaa53f5359849fe18adf5d4a47be54b7938b6450b9f2fa505c2af54b9d9b1f9926d5909b14390ae6a24fded80cab77a72750dab4044949233a1332e94dbc354a9125a541f546525c3b5e701273d0fea97281c3429880dd7cd983047ee21252ac8ca263e304f71cafe571f167570a5f629575e3b67f313a0b83286996082563ef0c184b5b93b7041abf8db6151d096cbe3620e706028596de48258bcc1a57e1c284c996323e511cb908d80fad72f9f40c3083ddc0f088beda164361035e3412687c569db0f3e2a87aa6ae06a46a968470843c13f13074328816b9d1cde46703aa3751eae162cb3d10cfffa5215cb2dcce33b85127ba0ad99f8498bbd55ee48b4976cbd52c46a979741c73fe45a17d96c6299104e2ccb7f42eb594e058365469713725bcf6e8463776710bd4f41e80bdaffe0a911a908ebcfb32c4ab1be5c0ac7ab9a7179ecc5ec1155e3f90aa0d0e8cc4cf82dd06fc1d9942c71588f7f8ff3ba0222ab36e797eb0a752f524e753fcb0ccc8b92a410023913737d3d9e2d95f378c4a238799f34cb9710dcf4cf4f49593660acef1fa44a406b16556270885e3adcd640ef3f2f26cb304e468a1202a5e5b26dc2f793dcb6eafec38279949f79c49c67d590e3c6ce444583210d87ec991838db4991dffc6e066482bac3bee4c76cb331f4fdb8c9e722642303647591bca360f790734f39fc38f5ef17511f43f872abc1ee2797529c1fc76ae1fc052d3c71de5e3d8ac304921f42940d7f303657763a153bfdddc917512cc4ecce39d522babe341a67cd0e2a0986405dd36f5bc621ab7d5b98d994cb26ee6c06d68bd8ebe597cdb20bdff8c0d653388a072ca9388a89c5e75061c80885d5ad2a188ec03844a1cd7a1925e5357d650804948a4543bccae8078b6fada0dd455725466a75639111fc19ce175f4f96750763a01e517b54b4caf972fa2351a3e5b082cb6dc226a385535e062c74de343840af538ebf4eff640624efc8611e007429d018f195c1e2ec2c43a5b28b1658a368ce9feeecb622feb2ce2c3eb93599e2c5af0250fbbe02143188226302085d974c3139c4c865a9502c0d562a83be77bac19d423a0dd64d85f2f83d473eefe7b41c387538fcffa49b1e1fbd47dbb2100942e426ec63d245b2b2fa199ff20a11557f2fa9d1c36d211ca2e671f7f9225bb0f61e75b9ca86c85344153e835ee393d085950239bc69837962633b45a52290104b42a366124256703ba85551da2a74514f90a611814c9e6ab368a295ad316edc8ee6f1598ea3bcfdd05900f91d534ab352f6c127f8d5e985d87e3ec35f4550b5acf8f5ea2bf6bd034595d7a7f195ceec784966a66b09ba2896974a87fb67f7b7fe253c8730cabdaefeedda013cc478b126ffbfcf37d1c91c0dec3b21d31c00695a8a23b50085d60d532f9dfd951bb928504750db0f20ad9706d110ee6f09b93935bca15dd8e05407c8a6cc9dfa2184a9224ac974b62421feb3ce55c7d1b33539663b576f1c667cfa6427031d2f36eff7f4d4b402e41056c244e708d6c2253bed14ee9a11a227969fa5103add58c340fc3aece84ffbfc1fe04f670f254a4791aea5581aa02273e753f3a5b41cb3c01e4b58ce86728bf6589d57d09d1e9ddbf44f954e80a867f2415233b3d479be0621db3a96f39bc6f2c55910d4710bed7769d54b820e870db44ede2408a2eceb433989f988a100d3521b007516c924100dbde7b8a8f54b1898f2057786cd938232ec7406a700e2798ee8f12e218b585146a84602ce5f5bd546d92387dbbda1315d0ecb0570e0269fe80cfb2c90ea087e5220a663ff147b6bc74b610ffb99d6b4435ffcc3086aae188296ecf18382dddfd459bb078d5da5f5f4e9ac1628d73f926b26cb99f81bc61e58c55361d65affced993b4253dc340428fe8014047a99d702b610e549cd13eb2d5a8305568583a14ff618e872b60a616135dc09f8c16f2c2f86389e5880e236e91cb22d8dde803f6dc3636458bd7b51c66ac281a03302c4bfa75bcd31ae1c187e8c033efe4d1011d8c371e84f70ada511df7d7b1b7af5b3b859429eab45ff83188d2a5523042a9121baa1b01ff598c6f45e0854b5e90acf4c6789b1c263f592fd82d07007163ed2c47b0f7133b1a0161dd061e3eef201f74310972429e2599743d7932a4b37964e4d21ab8fd7e193e4e6974254215659a202621761e026fd7ff5d129a71cbe223d82ed49a074286dbb62809fd84f9cecb596bb87e747f6e65658802ec655e866b06c4ab8d3ea715a5686129ad507d554b53b6a406c9653784c4246a28668088835d7e8ee50b758436743d7426a039b2cdcbb7cb20ff98d6efdf8d35a180010856344eff67bd80cb580f718f5f3e7c3247751fb2337206407118876fc6a3a78a62bd8d95e4fa7c9a9b7e87be322c177c2d1633f88bbd9da147729de3c6c0a6b43745c8056f6f71150194bff8d26d99782039d3f906d76a2dde04892bb42f35e8aad921ec4627443c88b36fd2d93e36c55d47a6dfd46fcfa0e0ec57154680a9ee84b15d9be6a7aa13195d7db2b6d1f50585ee9cd9c4793975862a02725e98d3158ecac3793ef583cd50691867eb2669a998f39c4f5751a6f425bbcab025e53105265dd4c6a708e02258e9e4a32a1464c7181fbeebccc5f7fa46bde52d7ebdfeb542a1bc26b2d7c43a059d99664cb49799549d935c13cd3b283317dc3dbfd68fc4f3cddeaef1841df9034575cda864536a883d3d3797eb0d7630de7c45ff3869777d018940416c3ced89f522a1f2a8994cd6636e3713e815da2a9aeb4272bb54cae964270d781582cbd1ac5a93ef930b4fbbcd12eaf4d3090d9ff63798062a077da6b89b7e4e01c44e2ce0aef589ace740c33faa1c15b30928945e9bcbc0463c0af6e8eb7c2415acda9ed0a45f0093d370175fd9c3cb048267e9d8abc228ba43c7068fe4ae50c3c3a0e234bdbd52bbd1e5bd2fe26cf22ff56ce53d5b0c4d1e2611d1e999c7fce63244a7bc7c5094c367c537c5b578acf1a8632c58f58984823221bfd65205e7e970d193f5ad433fc9614d5912380c8bb39cd91736f1cb8ac6cabb978ed38a465b3233d8b0d5399ce19c174bab403ec2789b728c3281f4440e2e65c922f16c2a7c735f5e4e28510cc6f23775e7a28afbb2bafdf8691848871d2f4636e01eca05f186824187bd916ccb7d9b2430afc5eacc5fe282efc622d570b406520da2b0cf056c55e1db36aff0a5c1ac54b225618aa2dc08be0c59a1789ff0ef973ff867e7229e49c3856355f4b747ce307da55a0bcc9fa0e8c74a76b9d046d65f99df41a75855f2bc1512befe9bb3550e03f4cb67bbc2cd13f38bc5ffcd0e10366576ac7f8a247866aa6ff38cd470fc977a5eca8f07583f63d008a905dd9e49b436ae8df76bf42bb2de4358f2c22c4ef4cd29b9618d49f11b2b02c545b98349ffc6c3a14406fb091ec1fea701146652d3961239c933c93218b6049dfd26452f1d9c7455c211794d7d191dfb83e2f4d2b858dcfc9b5a08633cf1eafbe09be0b12ffab69db939d37ed6f1f789429f30895ce26460082c4480741e54a691593e83dfba704448be55a0c61901cf1c0d93fab8be5dee952584bed602695f8b82d8743fd910d4343544d086a8fdae5fa8160abc18d831e38424c6246f05118b18537980ac9d68d4d5148ee3baee7d5fbe6c6d667e93443571cb2d88cc3e0fbd4ad711626c1647d141e899b5e99b2449971bf6e5e262552da124fdb86554fc0ed1d01de32e62d5f0f926256ab3ce4cc9c9dab368116833ad7818f036997caff49de89d52ba184baebbcaed46a2536dd905ec6077b0cbe4ed611a480cda06a7e39a4b3adc8e0e003b008acbe5ccbd23e0d6168109d05aa8ef9ef23d2f1c2764acb2d24c2837ef4f07b9b0608d0ceb424de0fd0f03d5b10a9cde432038555881417ee53b926ccabd3129f28664ff461125f548a1c47ce39029529d11baba2238dbdab27e6fd76a835654423fbbf569c73de5eab95943afbf1a028618209011e69455f294adf909a611fa968a0b4e4df3616523fd66c7286b3beea2e16ab6ac95043050f47e1933b7ae2a4702a926fc1cd1a2f8da4d12fc671c8e11107299f84f6ec2778e871d311b82be2d5b3a3d60ac00b1dca7a3131fc79d70f939e6ed1b23c8fe384195ca8ad83aa2a1d2fa60870e6fc6d2fc212f8c97ea028a4e2f0057eaa24248255c564ec57feccc3ddbd53c17ec5401f1780e381159d9fbcd9637fbd8908f9185180fff48c1105c1793f278820b1d9d620b5832abc4e5540e9d0c7986706cfda988ad5b97385c70fd24ffff0409a3626113ce3596535dcc6a6662337b71864c2de131a109d71da04aae84b71ad4d21e5f2aa6c71991ec6f6ccfe05f1dfb83d67b9e0862ecddc46abaee58a11f6da956c84d7d3a2af455e358b092379f33d9628a72a2de3d22ff6a930fa731830a01227b76d2334543bd876c7513f0041cb715d50cf928484cd7f2f62a755d6cef388201a51233b41e8ddf48c80cd972424e06f3a8d29ee7961c9d971897f582527a0dd710fb7feed15aef34c4626953f62e4f789ad30f49d1443df2ef9778acfff12e7daf8947e9ca172ba0030f72a96123f122381fd671ccab62a31a3b7355d85929039ce1e08efc52a606294956768a3f8724671d43d1bf16c66fa70c86234834ecec19a941d6e2869728d3d1f1432ce15eb4db577a291061440582019a9a4fbb675f3c07ec31116fb631cf5f4fb5334081dfbe1f740301b6f04dbab94b9542078215988a32cf033a45f43e7064c8b1bd468511f431f8fc924ef309283e55318a7e1928b27d28a6dd43006b38968a7561f7cf6467dccbff93ec7092b3b86f1e1e78369d186d5d345f05c53659cf13cdf6543cc20705b300212f881e6454993f09ea155304c54da6b58eba5a5b3cc7c022316a0e77617ec26ea17dd75660e2ad13c66e0b0ae6e04a997e8da83c541425cd7fac982824393ef4917f4cedfaed35d9f6bd0d54a75f5e2a95712beb5e1f86d79c7ef1ff496d0c3e62b19ee7baf3f9eb9d90e6e478efae3bc8670ca9dd5c35a946e39b96f8b838bba27a48a163dcfaf704aca073446e4be0d4d0ba6cfdebe1ebff23704d9866be94ccad0a3c63a788fbb2848b5012074fed3bf7ce0cc33af9fa23fe4ab5603be8d336cfb528333a0c51ea9b98dce75ce63c7807d683ce847e8b39b6cb5321a6513c217e37b62c0766836212da4f9067e684da830bd255218225e1ae5edf5a1c622a84002b931bc701de13e55dee9a8470d130566db08c0a7158e86377720e0ebf64a3e49477caddb0da21ffcc7db9315cd3ca8f1857ea7980c3f70a0aceb44a4f032fc6983e3e0e8697d8cfefd49df8a4bf0d607de0e4af4a042165af6ce470aa6cc9cbb2d18ecefd84b0355db7a5c90e477ac0d27c24c6c230cb8c1ec92b570bce9e4a19b7c8097255c1dcf10d5c5219a2deac28b9c5584043bd44481300400144b33482280431f7f1baae8b2cc87ee5fafa72b13f4641b807e7e9dd479952a3d849fe04b8abed8013a78b75a8e3e905e1174b00ba623c2ea8b7147c3cb3063fa53ae0e1800c5d59a180c5eb03ec507417335b58746a2c99aacee1e57041de186be21151acb2149ffc10c23125bdefb46254437ed8cee49ee0332c34636cf396f37534a0085f378097f085b48a77e1343080bda147cda91c29a907f56a22bf30c18d115cee3640ddb1d00cf4948788b70a6bc2e63e75a63e6869908fe32d139e32948b55f4a0dc462755e454a3ba74143c1358fb19a43695bb6cabd1fe188803b7fffb54c7a3e447ff20d6c7ca395af1d6fb0d84b9b02ce1d79e14847d6e0e6e8f67832a19bffa8ec29e1872951cd460379e8dd73161669e140909b89b08ba4b47c0d11b966aa52d10469f897554c3d82a81a80a032d6dc1de6804b9d11c1fc535bdf3bdcd237e91efc74ced2ed5813b78d34e64fdeabf4032cad6641ebb6d00b4f999954b874dddefbe2ba808a32322fa6e55153f6c209eeab88250a794c9e790a75f675e660ab864ec4eb29209ac8e5d7f8fa2a8ca4e97882435a6f5d7a1dd69e551665483a6e1f22e6fa763e6d75a4a75c4c42369215a4e9456a0e35da9d98be6f45dfae49d027e91daf27a10aa22f2175b1965b782936ac8b3eec99194f704bf02396d08d744d2015be79672c13ec5824fc35f8d0e1eade1c47692aae573cec1a4d389385d7eba1e8ef4afbf139f43d4696f5b0c80ecbd907773d9a13b8a7105bd1c41d2b4e05a2d8524fc5c288b3997f30f43de0a19e5eb2d5841d5250572db0e9fb1cc235d20b202ce7f7b54c6d35e84b8d9ffbd7199d912a0c6179fe394edca93577d8f78e2cf8b047d31556391b2d365e8c3334e119d70450695621fd3f6dea4632a11c353828773c6848c2bf94dc083b2b63beb6435e066cd62fe52174ba2485159566b8b92afd4099e71615d174c53f038ecdef48ea7e7fa110315caf6312142c3b1d2d861883a3f15997b0097f04da1ce3d16a42de019fb1008a547464fe858ff8f38e70cb39b3ab2fc22e417dcb59ed175b769392761d32bfca36089ebda41cd9919c7e3ccec67cc7097fa9e4940d1fb9eedad18c1f3d73d89daa12d92b766b9da940fd62db97ec294965e00dba45601f994c1d4b83bf6ce2a70fe24931b3440e418475c4fbc62169bd6bbefd006e4a5597ee2565ff5bcb848ed0db303eae6a6a707e992db93d721528eab107256eb20fbbd97e3e1b7ac7a5cd0aec6ac221ecec2ff1c6b0a38ec85016a955459b60156beaa2dff189215c925a5195e17b6fe3443157d25758c72b34a12099ea72ba4b0142ef89dbc2213c8acd0aab8ddece7583253f5aa7358fe9904009cf38fbbb8c79b0dda0b9796af7402405baac4e7c17b6ddfb21f214dc82bc594a6303d81c4ce2af2c4700cadefa177410c64631ab9cdd0ab5f2fe872c292d1015060e1bb38c5f4a3fc778c929f26dfa09271b42bb88931a5aeab84162116fc7af04750f6b029e8c996701fc8917df8752466854cf761d442bfeeea4a7bc2339bdc3e11e0e022a64ab82de2a75f8e59bc92e9281859bc8f8b31fcce4939ac5a17111eee4788fcc2e9d686ece56905a800bdee17a443c3fdcad1014332a6efdc2277798ea00f747f1835c4e616d66fc0e59d62affa56793d6b24d03ae5ef97fd0c9da906172cca490fb5c5cfb8ae65c40a1b0ea360792208d2cdc10246c36ffdf1a6471e9632cea8400f3185ec575e21d4cf4025cbaa436e59b6f27568999304a4279d8c93df6c5ac396d553bee04e77f6bda2f298d49ec070894652e543ba84c40e58bf8c39af6912e93f070fe29a89dbce214ca3c5c2647289b9a5cbc57d689ae5270e8e495dd34b6df4be786617e56ecbd3e2d9a0448a0d1e6f4f3992a30d097f144189e9da009ec4f118a3b72a2394bc2e5fd7a316833010a2cb6c5b17573210e4b65e74862d6f6708a571df1f321ad59c250756ea2eecaa4c28392c56e20e4eae1a5df93afcc74f9679d821e19347d953b3ed9c8c5dc939d71172892c6e909ffc632f0e8c1fee534d664ed00e19444909d807b5f7117ee9151e7e16708972d0b2299cc3afa2394f752423db56cb6473910e62918544596a14e61d4ec7e0fcf729d105dcc8a8ed21f5b6bbc3f9cefbae5927b10b679f8db110fa3a5fc3aefe8b3dc6f9fab4e90a2a504513d0fd2fddefb618206bc2f98241edc49bfe7ef9ec0456db594a0d1eb46b171e01f9e8a367c703c2c66660f9907f308687f8d9ddec5dcbc56e1d3e38014b441386b9572a7ab78bd199f68f964e2666d74011273cf9a058e74c62a572b831ef08a9fc8b0c53bf4b25760ddf6f13274d47d6b48da9bc34f86db33c494abeae13d3170bab0c364b67de434b8e09867c20822b22422b25cb7ca19e01bb8eea9bb536482c2cabc95f61a5f710d50a4cb5de96cb727eac800e93d41e3eddf344ddfbe10696a5244346ad64f993a478264c9539712f630905ed0eb7c924298796bafa21960f10444ac800fe8aba35c3fa290f5054af0d1597ccfd5d2f35eb9d680e663e36c99e03c5746b07ff5fac3ff36e5bab26122a163d07361b7d1f20cd8159105adedde468b102d99d48e1c95eeaa38b6e71c32ce7cd78c35ee0bcd4f9870d6db0470e283565c5df92a6b86a9e0923730a804e824c73eea459484be7b3438900032c9f7904b35b5d74eef008728d833daa1f12928eb19b2bb91727d27b910e7be0b120e1990ec2781bd295d430a7ed7db1e45126e312cb4141cb77f9cb9f7c53bd2b1ab7030f9ba2309bbdb81287fa03298f9f597134e60f5d8597b51cdd9ae4c72185715b3c0930f2ee5386f301d23cc2310305e4cd859e4c2e884cc244910bb34585010fe03b1bc7dbddf4e91dd4ac28dbeca75bf224fa3cf45f87d094e3a67f326a393aae1339c17e11833a863762371d1adcfa781dd2f8f9948898edc39fa7c595ab47b22aa4ce228e532723d9847d1a8ce569fe07e55d58127e2cc98272f21a8525354e139f305517ad8693d11e3ed80446f2d8055acf02bb1892902565d3c9287402da5571202971095de353bf2b42a65ae92a03362c515e75172e8fcd005c2afe01b8e18ab8328b44a5a463687761a7e29971f82d6c96299004f83f74a3677f2af86481be56c76ed3c21134bbab8d6cca2e498fede1db502c304b53c80b3be0b8db733f35fa00c71c449238370ce68a357efb1dd1151c71c20bc643cad5d6b5ab766b44df9c10e0934a97ef2efa73dfe22473185a84e3d8e2fdf1073ccbe24b744b1867056d2bd9f66a63c5a114d0c27678710567c80628f996d65b98c464aefdb640d21a14c3d93d825ba3585c2f6baa07eb5a75343c219b206fec7a159414630ae4c8e6f8b737640e13af9c7b00b1a5b4176458c55b2b9a1b33baf6e9b2eefbb9abeeb8b19eaa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
