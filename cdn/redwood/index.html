<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03c5bc1eb8efd44687a885f584f6249cbc45e4a5be2c1036c96ad488790088dcee9bf9ee379598b905209de8c14271e9de4842c661e852052f5da2369cc0039b0797ac1f7739b81936a212d70cf64b8831289d1a08b86d5b8eab6854099d4850b3b2827294adaa2504aa131c243f4e08e6a293ef50e9d453abdea917b80c969d69637cff8878316e10f2ff20412aeecee9ef2b20de0fc349a06782072a42755157bf6fd35ad8307d06f6852ec4611f4ff8e8007dc9418d092ee0cca923bf701684ef91523aba9b5039bdcfe4f402de22b756ee78a9749de492767dba9964815f783bb952dcd8ddc153a2939d8dd76b0beb3cdec4b2b1268e4e8303c10a0ce4f553404aae5f4fa52e9ab396ec4595e8b138a27f2eeaf8cafa2c021de1a1bfb7a95a10da5fb3943be6f23a3b326d2c5b862ee20f9a9851932354758384ab9070a86e8c218590a2bc6f069609669d1ada3473e490a6279d867b95d554bb17865f1c80d0a52546b19ada7e6d290fd807f4431ffc121eeb3da37d87e4e27e3b78bf49b16876e9680c5def655d135865066769371f06f7dca4128e524060c6c192d004c662e51ba008e889f672402afd9bb12c73feafc278e144dc13a037c3e436a7a012d02d3d468cef3a819c5b3beedd5e461a208ebefd041836b95879be14832bf9ac2fe72ed1e41b66d1747d306b2979dc379ba175a625e0a3cb3573e829730f1caf45b520134da7bd868967594ea2dfbd36054225ca149d48bc74c5d60d8f363cabfafc78ce007b4a2e6ba04f6dac9321fa55952204a7d8684049eadfb026f055a4a3098fc63c97adc694268c3c8fb66dd43dca82406a112de6eaf7a4f51ab8b5d26a25e1b2a88e158946e22f0d9617a0c298ee44393b258b193094d817d9c04d0f6169df698a1b0d79228acc5de2d52eeaf4b39c6c444696bea602e3ac09322ab16c19be2cde1ec1e1ab73aa5857bbe9a6d0c7ef93fd143ff6e57c1bbc58d4179d3f2ed76da9cd51418f72c79784e1a4eb3018d8f5355e2748050c1faae92d8dd56d7ca4551b5a7611f049aafcf2be58b1261479aab8b8137dd2259f97efd25b6daf6894be20c63f80695a8a028e8542934be81a6d5803e1fc1c3afd23748e06347d445f1fc1c312020749c592b7833edc54c7cc6f96685c1555cdd7ac6084a71071d883e3f29587199e41eb3aa0fdd424a682068d6dd32313ca00fa0ebcffc7454f1d7bb3e432d011c02ae1f08da291ae4c052fe1ddac26c29401af67fcccb1b4fa1a3c932bcc7754208d76bdb160edbf2eb3cfc3d842d1b909d2bfbc60d721cff3d318c5d3ebee5babd2cde9d628bc534d9a196b7ac5a756c0d6f856836449e0454a61f7a4524b2e9b6e2cbf2ef205aeb01b3e9496d66a29f7698b4cb8b88073a041db42cbc0e62f56e5ad15371fede0c1371e038f17100e1de39f082fad012f2a39f63bf2cf328cea9d4715da6ab1e3c1d04e8030bb1d5abfa45bb5e42ebe769970f3927cded70e67bf6dbdbe3994516611c65d2dab8bb109b26147776bfd1e80cff0e7c0a241c371ebb964751c32412784d29ddcefed72de07045d7e96a1fa6bf66d4ec6f217e11a87ab57cad501009ee2679f46e961f36c937eff64ddba236067069d783ccbbfcb806ec15029d4b7ca75d3091b900ddabcf9c7ad247e65740a4ab70ff70f069f8b12c995b96450d59d4f596e3c05cb8b09cd8d3d735eb141094108c37ebec5dae2974b4a0d8cc955868e8cf4dd36c278eaf39a6aa1d048b953a6dcb09d34910a6e850114f9f7db6ae28432b297d98d04fe24a78089e7c46cc92b48f08147eeabc536dc82778a14ef11a589e7a7f514200f6b8e813ed3c2b60ccba85a7b20208ab55bc34dc997351a132438a6c8dac5492baa47fd985a71111b7d0755617b1659766e49963e6fe55d5b275f91c44185932259a0171110441be40281a1146be6423106d8b5cb8c89376432e771d7f03815a4abae86c0924853d7ff8defc6aea425273b353fe6d2293b7f398a9615d8f2acc73a0e61cf0cba15712630088a35c0d7b762832a94224843d2d8b649cb7a2d11e7df7eda6e3a9efe28ef97eecd2803d335e3a319d0d3b8602f8749ce06025be2cf5375612b3da71e60228c33a375d6846b37f13a5f281151ed587e5668f03f32f48254c54c5e0fca578165fa4b42fb95564879001acf80a8d39241265d20feaffdd3180d88a6e9ff636054a3b3bea8f75735b3e5b2b96bf363590ff2746589d79d5aa96d62dd93800cde46fd31783b8f73430428088d65b5df81030380c965c72d045be6734eb87b7ffbb1aa6b12c92dd0556f6bcbca7a72f62a032b6511dcbed4a5f1df8d0b41b6b17a804a5061dd53559b9eff5604a967c070c557230d44e6c1b11a077a11f302b39943c6c5480c5e0b3917d26fd8fbc4b51860c8af71ceae25f7786b08be5254a3e13e7b7ef159bdd9b8d17a25a3d6f99b666c5d213da405b1b4bf9af9a176d15ec4659417e3e4e9f0d3149b9c7fecd1ab63b33ad709918d1b3bdd9d21703460be31e9f8f736f0b8a6b9b55ab4b2b6f3f7febb8b43c6836a458da42c98f2650463ac7c14736db5c2b481265c7fa01e7e20c29c4fc6e96f05b331e2e71812eae018eb62cefe16c6e3fad13f714a0d692c767c75e719c4acc0a65dd293b0020ea27306d443436e75002433cf557e9f8724e2e4d04c0d730d1b617dfb47a84076141575aed1baa50e30541e80a8f562a91f701ed56cc1d7040981dde0b464e5974f0266153f72efa3c16821c197d524c8b8bf0fd88387af17dd212ee92a24e2ac5df089b6c909e8058d14afe6067f2f56eee8a4896fdd33d1470f0e23490359a641bc0a91973272a1c2b67908f298200b514eb7dc0aa4c9277e3bf2545aa4a5389d02a286b7cf3107c9e5a024f30a2a154d9d65da6b9da3e1c34c79db30a19ca75ef788f69ea85d395ca550687898f447aaaf658d7cf452da9403582c02dda322ca53fcada0b910b02fd299f6807f622c6f6e991862ae85bd19b745111d78468dc447519942ec8da038edf7e62725fb66251d3d5a236a9eca556e04555746a5174edf038912c48b79fe7c3d13e6715c2c9ca56f9eb9315dd4cad80d5fcd8e003eb3bb9916708bec1db080ac52cc543d5bfc79131e85cbf587a8741fff2c327ad4982e7a228ea6bcb7337877e513feaab4cf4a37223b87c625b13ebe8ea85f58102087b33417bbd6fa05abb95af1c988bd94ee50da3fa1c587a03fb8c17ddf0399f32c45b367bc4390d696e434eee995a8c48203b0502345618e97662479634b318bfb05e9aa71709d1abb0d2d2c0e020cdf664818b0ce60853abd54f773363300aed891fd9d10bc2aeedd198cd3c657a0d17c39937fb931248c0a6f47cdea80b51dda83905160374efedf28e2c0628843cd6e073643beb71089916fe7a69a9bda8c45c6c77b85d253758e1fc7d1957d3064caf7f6265fd4cbfb2b59f61c1f626844f5a56b9ced522113abba604ea29fc788bbd7d9e3276bf23ae0e8df77de34e8d328a70521b702a65746dbd7c27f3d3a07ff143c6f1cd992a3c92397f01b69f8058fd34d0874eccc7ecdfc8a631be91870e69c19db1cd956a17b406fbdab32d57505de49592f620798fc16933a35a3385c8bed41f385d23a33d7f0898deba2a0602a60eea034fe7286938c9eb4335a4002cb66df6040ad012b7278a262c8eba74554d8bab3308e3abc29ad40a11017011cc2fe9a1ffa35cdd4667db70d9acd3462f3ed668fbdae2bf87fd055574e3b50a5f3502dfc4e11718d372d1fdf535aa44a99d14b92b87f41e74816662fd23d136ceef4b2c9cd85de9bd5472a6eab394ee87f41e4ac721a1e95e6502886208c8cae1f842d87e7f615c5c8d723f72854b460a58e8e1924b85882aea1ae61b0304485f5c90ad6aa8a16474a2f91e002165fb0973e83fc659e7b7873ca9fac0e7aeb094820022730a76c5ee1a77a8b665ccb8e94f5cd13d6a980d63f8289b66708c42e2d1db54f716c870bc87b0f8defa1065e2ea3a651e5f4ef18cd1eb8cfcb645cf1c1dbaff1a31cda8b7f0fe590a7c439346cfa76279385e3494c7ee27760c633f7d35360e18bb468b8e46398b4937b99a2a947d82f6c1b1808351c1325e53e47777fb21a4dc8fd47bf7f36fd43cdb6cf57dc93fa69a2acee4e817eb92438bd29f6c6240cdc93387f4758d44f66aa5056ec6b02da128545f4702b39996e8538fb563df83e083e0b47d68d535e93f9d18eed605cc8d6b5779a5b036598aad651aba1e008b8ecb609b368d774763ec8fea51ba8acedfafd650f08466812d8352453d4ba2e56c2bb43bf121360ac2f18afc635accd85b37f9769fc1a543a6b1ec9824016c89a0e87baac168ccd134f1625b5a26c4de72ef035ce7e59751b709ddf63fdd86e6324a1f1a62add9d82ed8327566d7d46d63889f37cb887ed087f7b82dcfb4e964bfb2322fbbd8298d2626ccddd5eb5f1bb366b06bd509f5ad887ef448563f11b7121d2fc452fa11e09d2eaab8566b40f379060aba220b4f9cca9dedcf440897f2ca546dabcc5c7c517bc629e9819e5d889cc5085dd46c3cecc835317e1d0e3b5a47a01ac4c41ba884a6462a9b94b5a8169a7e861712e0eff56df01ec002db51f75c2b48218fef31d6d5cf22b9dbc80207dd84cb54ccb96a4590989590ffa49ee675d73374808fdfd5372de401e92bd88e24436880e67acfdb10394f301ec2964f4979559d5e2e433b48853a9ec5e645ce6371741d0acdb183b7e3694afa881b239fe74abe58d8a8ce4a576fd93297c6f29a11444503a9d5b84e92a0b0e13bd0acd51fbeb5f49365897f9ce95f0efcd0fa3abd2c145d7a4da808187b74e1da25fcb3602234092534d854d6a491af8d6d908dd6deaba2dce7f71ed45470b98add4ba812628e6bfe05ad03e86400f9cd74bac1ee37a359ab3c1363bac4f79e626d55d26721e469c6fd6d28f5e82a22a2626eaa6f8390fab86bff087b605e3ae996d69693561058deb9bfbb98a5ffccc76797d08e41593b8316bd762d041b7173b94667d6286a62e4b17048bf56039d2aae9b660adee1cf7516f5072738ed544309d6f88f5bfc6c74b0d495fe3ea6cc30ddfacb7e21a05a3fd3202a1eb5663bd1e77fe43bd9adb52a8390d7188f3b6f5c754729ceb6a152b7d745ac6ebb2feed2d23152af1f19b4639f49d448a0f186640eeafff99ce0bc567addbc7f8a81322c4fedadcfc5f90b9b198c0ae6ec37376d7ed89fbf741b716c0c217ba8c8087d70c936b8b09b76bd47adf15dce55f30c68f88aa72038ad89da42bdc7b84674af3f75784b4ee2f76bd77ab32f5080daeb3fc8d143eaecb93d6b3bab6e1ba6c836de66f2ad4c1ed7f18219d38ba6cbcd82bbb6776d1077de753077a59464af55faf29d0300d0e1bbd3205520a8442e2ec39b784c1946244e7e7a354e7c132e6b2d1de8081ef57b43be154d50e2e3ca47edf797417248e2efda0b88e4f50bad042d1878435a51c21b4cdaed17ff9b0158157f8b78e31afa3c6c76416fc4130a1e1443eef4ca84be5b3e88b43372908be683332b9fe19039a62d1f0dbfce42fd5f06229cab1ce02ce1c6e47838e625e13a5c7e42a15e260a2f1c8a0953e1d9423cd5a12b4b2c56d912118cda5032ef4ab703cdc41fe05e100d77126b4f5a67707e73e885c3b51edd5589101d4d2b943769e0479e414da40e0553b3f2143920dd31f618f1c78b263c16016208df47a09d5f16193cb24b31202620c93ae0aa67b6c1b5a04d398031c1c3e65d4bdee5724a4f32feae3b2944018ef560f115039b420a8a52f0b81abab0729ac844282a46aad2c4c9ae34775ec04199ea8729acc3d6c77eca0b772dc2a2725e21622d474e501f00b700f4c3260e9fd39a85d752c1fb7dd8c89c842ed91bd78cda9c40a41adb966c083af647fa3148968784bd8fc29f6473ee8e2ffa114c8cecfddcdc01b7e8af054581c0b8962266724ab5526dcab8211feb50417ff806fd6dffd34076311423f604775b064977aeabdc4764b442dac54edfc22f65537aebf343223c6370ddce4476510ee48bebac3820ebbaddd7f0e72b0ef4aae8673baac817a3edc663a38f4ee810a8690331e2400a661d50cafa79f22dd1c63c8309ab311b51b08331ea783cc35dc216f7eab63856ae1e7acfca1cdbebf1938ef498c8d61fdd6708026dd5549a3d14b381a49eabe6b2e17cb1e23de5098629f4afb998ff8b4646c24496c2df9000d0ae2887ab1d02c190ecf749246dd7f12db8a96ba0a521a18909b31b584e16dab9b98263384834a31244a93cd65f111e1f48ca02d29ad7ce1168ae8d4f7e1b5a550fa03f3edb63477a20a6b35685877be39ae7796109ff204873eaf2de65ad0944562603e5680d7cd6878d7fcc8521c5955f1ec4f932df6677d76e91ad7a2ccf569873947ec4421cb54dee62c0daeb5f2cf4f1dd8789d410bd8d2539de3ee7c3d3f755aff7882f889b974b7a8893cb7d4e5a852457f9a6c6521dd52de721c6259e8d5ed765813cc5f449c6a71795d6b07d86e2afc6eeecfdecba6a6dc612e44d772549afd353829e73fb442b84db0ab0af1e1446e1e2c99afe26a6eb9cf4b26cf0a2bb942719702fa4beda3d1dfeb9d75052f3f95e89ac3c623460f8297cef34ccb621e4256bcad475ef7d613a58c22f026f36f07cc2f0dda18e8a59d88e77b759786e82183f0ebc3350a18a3c18c1cff15d5a66bf65bf774982fab75fe8c2edd71edcf0479961c886db5e75ca6257abd3e1a160594d44b2a0831a74546226c1459aaf6bd571bdac83867506ef4a2c35df6a27741cbd5999c7cb3f4a9941e4e6e7869a00c3aea95bd3cfd0cd72caac56728d31e1f39a796cf44c7960c604a3771a53881c57063eaf795b2600a05cfa8f7f9d803e7ac584772757a9a5b4835ea59a72c4b2eb11997c1bdf32c481649a10c78a723be66b9631c0d3bfaeadfa74fe5bca11112798bfb60c040c849321bf7d4c31e5000b781322a7dac9515f4ca6adc3c3baac7fcf286bdd10145a6716c65eba9f1d5f1894f6e6b1d0845fbe46ebb961ebaaaba5adf32baddc838e4ad607c4c0a439cc0f19b9f648a56ec345f982336a28e13ebf7c9f5e01d218ff9abb624d53e2b4761e7a294e52671e826c9326298de7b42d618cf41ab5bacdc25627054fee9123e39ff36284ed607d838b517ea4c8c0ac59de6feed84276950f35815678050a52884f91abb503a3eea12d74ae85e43657810fe6ab08bad05c621ee6cd5838982d5cb84b6ce14cafe9f4f0104949a044ea76053f3bad4ac5d82c00ec8c0e840c575d5ce645a939d61ead72f3eeb46a0a4a47e8ce511690ff007178de3018fcb6598c6797bb7f4ade97f5852e44372aa9c16822fcb719937ef81982561c666fd6add61529011a2155c81545e3f98e6cadfc02f69cc13d48f0079fadeb0d28ac6e0fe1906fa517a2076172031d348c84876b8312d2523e5143d494c809b1c68a092d3f2f36b8d684a8c1d458a579a834ab02c2e483359580005e40b537e785fce2bbb85b30be6515b33cb0c5c0d8068564beb61786f022406f3b580226d0fdf744b06bba213565fab12e7e4e06aa25ec49c15a139cf3622b0352e4222c0b937b237473b79b7438208ecf54e1194984ffac49db7304946351d0b5d56d58f829a7f166fbb88d7b4fe6b2ac609403fe42ba290d4680175b885a79de57069218a9ecc0034b18e0a97fee167cb72a1eb5361fbeacaf4cc22612d075f0260df288e0db968eed2735d0574fa7d779969b5d70cac9cbd7f6002d8b8695ffdce647a690af6fafb4ed6e031e0e5def45f75bc4536a8a1437ceba5409b7a8a43a2345714b0fcf58e5f98279bb027191b9fea9aadcc1cf80ef13ea2ae62e73ea12ba28ab2bac283d56301a40136910b28cfd59149b54aad0124b6c51b147f4718bb72606d76362a193b35307b9b1e17425bd046bea93674b161ef2b17b92be6eb9428244c090435290a61bfd98152b6e9e95e66203dfe7592b3439732c35c7e786ae6f4dbb737c4cdde5b89cad49b5b33e323f4f7ab9308e517edd8c23481fad4fe9e72d283c0cb3d4a9467a4b203144f29ca3e23d20d443da39fdf522b428264aee5ccf563eb3c14c480aa96609d64daa038a81103f160393dd2cc3f8c568e197eca9f6540f9f41f5b9a297db4d58e203d596df6d3d12613eb536ca95fd0d3746766c417e17a06c88f5028239e9e10501389dd3ce7a5a3a2a1b8b659a3453e013c6ab5985ebee5698e9db1e3540f2e28b0a34d24c8a2875e233f955d33d14b8e0e7e76ad4d9bc7bd43ba7422b49ae33c7dc921a64cf95540335a76de8ec47a9fc5d4203bb670af6e2e924f89d0eb3341478ed85a4ec5b1182d4ca5e71f1132806e61abdcf8bcf17380f1bd3d205becd3db97acf06c49dbf968e90603ff0901b7a19b34cb56a640a88836edc24812c3774393c619ef0ea71ee05c3ee4d4b5377f7cb3fe539678a14e0df0e07c0fc139f4bc74225fa3808e2c71d8a22978506fa8361633141870935e3b2e7cfa87188026eceaa0369144a744261f6fb62e4e6ecd287c46e03d53664040e49d2c6928e6fd6a592d12d4d9f74e4a7910952dbb18418370f963df42be15addd6d5b7637ce8f0eeceefa2dae29538bebdf309cbae1ffc001dc57be06fe6f639e24b1d5807cb95c9d5f501eef7e85e9b22210ba2bdea81683c4d63e6ff02f201e0793de4a60102d042ec50838d77e75c3a9b8422e3bd0e372a5eec72d7a4b302fb79f82e0a4edfdde3890340ae8d5f689bbe46bb72dbbab98e14d4ab80ebc50e16f9e6c44dd5af98a1c5ee1a2d9a88bc3b98e57f11f616e374f5be6973c5694b9f5c3c55ac47abe616bc65a7ebf4435539f789a1fd134ff4166127a4fe8a3a53701ae172667f7e5c6b45c7eff9f6f2e5fb8660a13d9ee460252f5a0b59ae61303530e85e9c6ef13bb2a5f75990fd294a93a21392d9d236f2f5859bf4ea1061063070f003211346c0affa5545644409c10f8201fc41d03b86b8ded366035aa91b85eba9459b3a64d7a9aef0a32199181b74eb9452c84f1fb5e97d4abce7f9a024939209f81f2bb832ed6063465ec913a991cd305661c4ca6f5e4292014b0736fb10770ccb1a2981360001c6fea902315149658a6dfacc46865c09c802871f3e5fc27eb8b4edc084adec115fae7e16f7a694f8239ae71e2ffef015ce918bf8901501ebce8255ff0ca3a27bc3f7298089bf86f9ae2b462ec5697a1a112f43be8d723baf3c36e82749ba64592f16b1c2d888209885a1ee5e8eab327d575f0e564dc02d8efa6408fbb0681aab7c7a83af3a6f4103fbb8b87d47556017b6cf0b31f366411ad46c239979f90c942d8d30e8a1e256bb45b8bb3cd1cf4d154e91cf3a05566da866076a2912695b82f5d7d0b0e9211401f7840b4bb06bb7dba7aa6fa355f97be6c54bb30781df8115d47fcaff641634c6be17370cb61eda5e5e363ab571101a9322284873526eb304c16ae96cbb07b2eb360f9e6fb49eb041d61aaf4d3714f6f1efbe7c3671299a361118fa9426b81f98fbe45d1c79e0208b1b7e10ab92f31104523a800a8e35b392922e260388d722e5eb3902ec181554bfb064e8716465e7e9df66432ca0f5c4df7eed2d20e94c3f7f7fb0cdedc80a35d8c661954bd5fb66e63a0ecab90f2c39be88e2514af9bd38cd179a79120a8610a5284cf83b44d2462a6aaa3877c5e6548a8a630cce80c4ddfcf8a5bcd0a617065f249320a6b27b9392316ad6cdd53059eec902bfe5f4f9eede7e17b625ebe7e617edce53ec28087c09b5c112ece2162db093427991ab7b67e811f4d74cc11c9bf8c4aef673431eb7c85f5bd3337c88b845398507e409f97ea40e3ff66233e1d22fc6043a72f272213a01f88ea2171f391a394066e0361df02562e95faa4e319e40752d2a0242b3106b36cafab9c21f274e1556d6e50ab674b9c9a7dca2826a3d46c0ab53cb296893d397def2b3046e014e89837eef90837411e8e5fe09fa22a313970d780fd9394c7c51ab0ae6498982f905c47363635d1fd762d7a065de4efe8f21a8c8f0cb598d778a20b5b5de0b4e288a6b144dc20f780035fb04000bd6f22d54d17598a5f4c3481c267e03636312e4e87fdf567e83d6efcd935db3093d93139c1e9707cb4dbfaec470bc5671c907d4cc590ffb2ded04232087942f6d16cc70b86d4023861cc90f994d771e82dd49daf53cd1c69ff415763cfdb6751426377aef509d3bafbb7af932c155bb789ab7fda2a7efd9a0ad93afc4a33e54e44feb469514f2d0f9d16409da958293a482f2c5f438113be8b71288350e2d9e3c07cd491d45e4617b54b88601a8536718deb559e5e01a5cc79c4917385a9c58731ed6bc9de4690b5633ddb8bafd6c12059ff9a440b7f4678ad762f18189f659d8b644f3dab66b8fbe45508f1dcab253b1dd1c46114812365dee59282b6f9299c3e0d846229ed32f1ea6f56b453a1c34c06d02cde85013c43c3313c53309ff8bd05f9987fbeedcd65346c979637979913cd49af8066ba0dea5e0e7104f558e0a34d3186cbadcc10ebee7802c6673520ba93df7524c3ae13d922fa7c704dd03e984705bc536a7b6c8ce3a490b3e15902625b646781bec37cd8852a8a9f8cc6786ab010a2ebfb1b36283db360cf90f0d329352b6e2bf2af15793b9aea2c282c75845687dd2fae041717e16d311ff5b4c90b4049370228c539172b3bf451a948c5a2fb3ec5dd472453a9a64b9be88aa3a9a7c4f97d873d8fdc06287f954370d7232fd83e6b31025cf8670c2f3f2b1fdb3c8bfa50f794a3bab6864f1893b3f1aaa158bc45cdbc064b64e544361f7f3500fcfd80dbfc71213e6484ee814495517dce17d920dca177bb6eb133bdd8205d581b851431b7a3a693cef125fe9f224fd7af066fb3375e349f1868c27aea8ed4948282c5ec0b0c51eccaade589af3e3c12c3a0dd021ea629a47d5518378a5ee518625f409a74618eebd9ae36a33eac7c317ed4ed376748d9fcc31314b3a21e261950e115d6a3ed59f52d3a3ce9b6c8d64a8c41f8233e82ba8d6c1bed156464f21f3389bd52b851dfedd1f669c59b5b172cb15e7d1fd26653406b07672bbd65ae3d2a5da4ccca0f38e4c28124d683c63ec149b9d4c60df9d06320c12fe71a381d81997b920d5c7370e777f8e4dfa6167f372575b4648c25c7e839ecee10f45b0313d5b7ac78de656e0512e53d53f184bc61ceba953bbc6b38f927f4e80e4bd541f7295b7a71497b7a105b3a45eec4f4bc20c501fbc27c58a194065fe6462a718f78eb3383478d1edcefe457fc8c8d4980d3c08db6cef500b16034dbaa5e929038a0439290328a0023534e64a0caee898831e00a8610337ea4c222c6c5f4c275444ede486b7fdd0d0f2c560783c8500d370575d5175b72376e58a9013bfa80d222b5a75c082d210c8bb0f34d2d4b8c63af0ca20dd3fe529774712a9060a94bd06302b2ae80acb2d73988a78df5f6b57ca360391986728cfda3d59f90f6af6a9cd6f54cb2336a7a340326d737dc07bd3e2428f113e725b10e0cffb4db5a532628ffb57c030621b9b92529017de912ec42e9ba3b0ae7a4aff1eea4607d69cb60150b590be614184834bfe8803ec09de8241e5167133fbf5957184ec8c5588400e4b1a8b41c7db9025856f00737199145325dc6f65288812f22df9b8161fb18e03aac7380902d6b9561ec627dbfda1cbbc920b2f262ccbb530a9628daf71ca990541f7dfc27943661f211f8c80de0ce8df10a4654c3eabb7b08b374e13820257367f63a89c7569abca98a74754d4921442d2a1edd80e7bb03e55050294818e89d1d41ff6f308ee34a8182ef53ba9059cee9241df49bff2dda2f7fd8892819c9032b1725a64ec56a63c3a204e4fcc1a43616bc5a10ff222d9c02a64106e6ef9ef26b2d56ff18c8428304e4ef410643319f09ae9d1fb43aae5740549b03f5c473f7a6055f674d7ceb74518e895ee362dbb0732a56a7a825e5fca3fbaa0e890aea76c053427c131e3f1daadb148a9bbae1e28a06a40e56fe7f2b38fa38b0a1231c9ae000efead56c0932d25f24d98d0917ba076c7c6a8153a662b2384c128603ea2d8d9aa4c5e813236d530d4450f634478d25fe60660d1749e4f137d19c84761b97662b08633e6beb8d3df7bf43e5fc8367544e8424940e3bcdc6815dc3859750d2b9a9c943dd0235ca4aa8d11717617d67edd7fe8ce984a679fe44e6bf1236acc8f5171c811f30cc51baf76de3d6006b6d218609fb42827bebe24547461eae47c646cdb04a918c75a8ec4a44eef3cb34b204711965e9f76de642d6590f90b7d7e0d1f45829a5be53173d4bfa033690ca7b11021275a89e94c39c485030f86d5fa12ac9f4581788b287588b97c33c5cd66d96b7b4aea597868c623c345d106d34e12cce14b52da19f3cd7c42e44844b7ccd6d65e33c52c61ac33634ab71f3930d086d44ee48b538ea2e078586ae28533c8ff92e6c9b7974768eba13b2fadef40b507bd12dcd458e272428682fac51fc30c4aad9633bcd5a2d001f4abcfa24426a5abc0377f959d0ed94a707c340a8158893186fcf68f42b6bf31fa901ca2d2b725e1425952d5abddd057e10be69da723a72f0304bdc8fe4daf5a3d1dfbf035a79d0f498a77eb2166226484aa3ad2976b94e2084497795a134deedb080bb8d28928f3c1e4af9addd87a5ae8b1d376b6af8c551328c38ec9c95178554f89dd5baf92acadae4514e56e3989d3dc6c284e27fbfefbcf305b3421db25400bdf9ac6588c2598c3b8f1b77eb5a23c8472e6b6b61dfb1e9c41de7d93652458ff4b93ad935615207374e6ff3e79d0f1220c931266df650bdee6fe450eaa9a2eac7bcfc2ff82face7c9f0bccd0f103cca0757e641c82a3684ba3be353037bb414e4b38868b4a7608b3130cf57d1434893bb40a898caf3b38116ff41bccf528bea8525bae78ea2f0fa5b971a886d62cfdc54ce78209c24e33beff5f5bf9a40856cd4e590ac19057ea550c50e809261daff68100c6fb328bd0d938f52939f39ddbfacea290714f125e3b87769c224b5a625754d1c93940e8a34919003f3e450b6d9ce1cc1190185dcb05b1b6d24b8060ee24d626cdf7259a021747a1bd21c2d6c0b40ce0fed8df1c4e9fd87d9b36e486f7128ea2621a5ff51ac8a15dce912e82297263a7da06bdab5539b00cc7380ff01f481ab20a22af171d0f7070d1f2d406935cedb9c37749763eaea9adf593e5380dda6311b97c29a490531afd2bb43f240bc5d97b038494a1ac25dec126181d9c642fc31a1cbd7d5bd65371e1da93a8aaa277d60bf22c1bb330f1ada1f41b0dff9af11e1ef756d1abd76436b531f94cda4050205f3c111ac6aad06a365784b07c7dd2af02318c790119c368a1c267d76d2e7ff5cd8956e88b86eb9937db5ab6e749a2b387e041826df11ec7e383984ba538bb00dd68efbaee3f01d6b1a25eb88ecc1e3562676b35e7c43da020ad4b7c0068cfa5568acb5ceacf3e4b874e8cb3582c9d9107295fe4cfa3a840a97372fc9144a9eef2b08b963989e497c0cb9fb9cd68c7e39ac9ae35037742ce653a3a57c22a574ede11a1bc3f6beba18983569b8855441051247cf6900d292e6ec5537bcd9f2d20f6c7c5b9917c295a34219e12715e79bea125a099ca10410def83c4209d7cc563dbeaadf9f78a77080da1d4a5eac027bda4a1609501bd49c737cb5f42e9b22687fedc714b695cbbcb506649e8e4cac0c02bcd53c284ddf7d041b7c7d8c41a9b7816cc8e1818fd67ca861b26f8da022be76834ce5e7efe299c8b48718b685c14f47ff0a5ea6580bf1927d38f675b55a20cbaa4a3a6d00f1fd422d558b459aea8a7ada2a4e8af12b24f9b987b0baea84a560f495383b7b21668bb7c0c09ac0977e50f50c93e84ff141c781913466c873f98ac8a81ba6d7c3fc521b504e2b2745a393157d317c85f35fa7d5aeef89ef508403172257dfd230dbe756491c381f19cbaa5000538bb4f3dcfb97ce14aba826e251fc00ade323ededfe72b4016443c569f09c3ae84db0040c3329dc9bbcf27368410b46d8ec3c7566938c78cd491856caf83597373bcf2650fb646e4421b802ab0a113ecb9f5c86eb9e572e44d4175d69a4aa4d9bd5ba57335d5e98278e5b8527239fe75b586a42ed348a2e1d9fc0015c704cb6de464d7465cd199afe771179f30e845a363c97a2c15f446b733357c9b392b498412e265ef5e470d72066a524a41fd9b4e08acdd48b57658eaf1219f4af2c2e3157bcdaf4f88737ece8155361c42929374745b57ce09de98246067f2efbc55664d24ad8ac5e02d35c396e4db9ba838f324953b49adb9ceab13594299304e7fd3535ae6dc2c1177c1d2edeb36950f9bc8f75dab925531c1afc728ac3bd8695380247107961451ce764e7f07e14525b7d2719e7ec3f26a91ac40bdbc815e2ce7e76920713fead8d5e82a42ed3e5b91b8eb67f4244d6d6abf0810b7c145b8fcca131f06aa408bcfa1e32eb393f8d5e6fb90b0f0d84f37a0e4f9032cc9e5238b8b6602ae8893e5f5e66a9d3c193c39359ca73ecb6b5c8f7e8e37bf4ec48a8abff6815b2cd39d32ab56a8d45195b5b1cb8d690d76e30670515836a36f75c3655d8127fc24eff38aef78af4a58b6ddf419c894eebe62154f1e6c0d61a70101dcf83677470b5907dc4717311d6f2b0ed3809ca6adb9a6bfbc9a0cb3f7ac347fd5ebe5e2df07847c5d373bd17c9f2fe8e60c46e98875a1ab2d5b5416b3e4d3f52ac163bdc430334f77e758dbac3f9c949294c8a4f5dce4985ebfe4b04fd669fd2d3959c5d43ef56ebaf5dbcc6213e1111edc4bb50334a4331fe2cabb1eab8170903eb638f95d584ad7856fcc4d135fc4eb22d7807ba6745895fa45f46784d68d79a64b2f2873bcc2903498e4de0f087e74678853abc07af5619a6f3609605a07da7e73c40bcf6c95a00a2f54657dad10ad9de56e1ba718fbf41acbb082ee16a764dd808b3bf5359afbee70a1ec8f9a9d9bd61c14aa85762a6a05ee0ab6a0009901c376dddbc8e066f1f5993b98a7f3969e890ebd4d6e5926f12f2f41d822b51a500774aa0a1adfa5bfad26d3787a8181ce5e65d52b4c7853514627210220bb9d24196a0b4f52ffc18b38b719e0304a2a1b7ab323094661e8456429ee7d581bd4123a2de0599bd9abb25a16d093bcb0018a39cf700aa5eae3667f181bc4a44f1ead61a7cf4a00205b448ec1f7d02c343b8166ddf1a1e60e0e3405774e87e1b8a8cc56c048402d217a75db3507f4f3fa452ee55b1a7053f444a47599b3dd34e845365ddb6a1e7962773f2a0ef1672f24585387648136017514557235a493fa9b1691d5242a82f4983db39fcb303172889f75115dcf47480cca4db832a3f1b19d9d28a0805d2f0248c1d5d5a875f0dec91bfaab923aec716e675b69d6cdcedec34cf9d937aca2eb180550ae0303f2c91a310ce292365ec17f0b454890c5037c90f9986412042fd004cc020efc0a5165cc265fcf1d53b57dde7be9de5d1d8e80256d711e4fb7211799baf1fa9b2fb707a0fa80b19bf3dd39f3426d90e5fdb8afcb6b5f55ff8854167d9a8008a85861c88d5b3f178bad308f6de78757c26579851334aaba9e7f06ee59239002076b8401c14e28e9f60b6c5d52bf27778c96740bf923547fe5bd1e8329d4469d6a02cf4909abe69bb24bc29da7f8cad275df5e5ae82bde010118739671ecb97fdbf3bbe055ee719c561183dfcd87186a539ffd0f5a7980c507cbe4afc524a5ddb714d39a539a3d7c4575f2b681967fff022f29c2d60990270ed385f3dcd1abe94c831e328638acaafb2c778db7c7f5098af020656e73f1e1239eaa7b783965ccf500e7ec5eb372905091d3b46f7a68a7fea0954e5df1db9eda407367d7bb09cc202f97353b7eb30fc716c03e49e8183db642ef106343358fed6c9aa0755990d1b2b9a85851d80b86a210fda237b0ba5be1ab33efc35483a10f679afb66e6980cc43bf504eaff1ee4d44f5f14f04a8bf393699abcb068cca167a2c4c36565b4f9bd3ded275267a6d3e20bb76253e2e5effbdf48f886854086478763906b4a78b5cea50ab70f649c1efbbb9deb30bf433528d2272f26f364ace53d851dbcf88d17ac79b111ceda0949b374df09e769a520c42d034cc33490f04c1bc17706066521e51620b92ab883c06fca68202cc6d977620718bc9100f58a172dca95bc59cd471a2739c5bf6ba436c061c5ec25bb052cd08c165d6d83444b8be7e359fea57aae0be778d15b31b8b7e78cf03238cff5777b472d916471b12242fee139ee3d8fc6fd0fa5f37c3a721883be53531f0a03f6361ea020411aeaa50966f3a6a987d0e70bcd115d71182ce29e7530b0296efe209c42ef2c17c678fe4c2dec3151785752073f55786c6baea8406e44e9e947fd8fcdaf19622459be8ef172110fcf58a4e47810c4d62243c0c7893aaca5193f631cc33b479e6107a04c8ea26896f26ada20cbbe95ae614376ed76221d4fe9cb32d01ea83d1ca796a89878381e5af086eefb0a736436fd832b0fb4c2d77029ccc4aaf97cf3e52f57c89c4d72a5437b3b12ff943e835fe4bf4992ed023a2c0d58b24e77a8fe00c56bcbd8588b8029080b84672ff962b444059c5f05f22d0d8e5d2e5397b37c312e9dda106c82f2f59452e721ae72ea65864aa7246601636851144e348982ea19fce78f80aaaa3e7c7f7718750bef7233e6144f087b8ca5c8140a226b71a243c6dedf8dbbf90664a1508ccb7cf4f37b73773160cd5434a123abe5b4b6ac89678c5b96d1fbe1ada4c3f268749adbd28997beab5da5777fbbbda0ea89e64988b598d0e2db3812562788fb144b01c84e937b467bbf0a26546830930f93982346efb7db47adf59af73d02d3844139c790f4c62abd3695c723e7fa194b86d7e8ece6142c9e842f133e8055bc214a374f5cba3e634118c004b0dfd0bf7e86cb385057e1f06418f2c598808ae2d94916f7c59503f36b612a02ad272e460c2070767e9794d78fe400b2b077bdf501550dae9f43626e74d5a845e0fd9ae3e2e09f7dafbab5b2467b0fe430cd16720183917b5e723a7dabb16c1194ffd91fec009a81dd4e782ebe146f69ab2198951bc394b87335bf69d447a78b54412d28fcfc4516caff78d1b9a77f3c34df5dd2ddc17202d437a1b050cd5bd80df56cfd3afb0971069755da458da66e612f3bcd20040e464ba9c03463ce47c1530d5fdeeb3fa2f3139e7701d27b533d0834d6cd4269bd0061fb88b46a463cffae15e755629f014ab4732735ac88aa57d7e5b12f990fe6986abe1ed999e6eef3a70f082d061c337af151c3eb4d94b8d1dcb44155463687587e7c14db4d554a8924c6ee4da6c1cb5848378d645a9730786baaa6def39ef96bd3b0c78e7e32b5e7a40ed71288eced0637c1a90814f1bbe9fe13220f4c33cdc6028743b60c5fcec0771b04be3be0e8b97492fa4037b4338b956cb3c8b37b2175f7e074acd774ee0186b208ac1bcb6f9f6d2f1de9b86f3c626b5767a0e80a6948b850b7b6ff8f494c986fd18bd37ce579998be30f28b7c8109895a14e3885d33a769fd91f8090fd273e3b24ed5dea544665504b64096e54148ba0ad1726b20efc15e56cfbe7b3f21f102f1ec9fcd309915316d02c451e2b6c20a62477600710ff3f75987b59bdbd127f054f6745ddc744c83aca634889116802d5281b9cbee4f88633126f9f84f563defe2591758d0ae78035e58e44e08292e01a31e0928ab1157fdbffd3377221fd6130bcafc722dd550df2d6fa94f436dfe0cde41c3e92d5246e01bd9ec41945be4f963ddbb45ee7ac67c5a41bc935b28527fedde8e7ec934cb8233d8210bd128e2c0c1710fdd97f42ef9911ebfc26239e7b62e531fee9cff417b3724f2fbe5d617576add453dd3d33cacf367fc0a2780d3a9aed67aff5c18451922ff4326d807770abd17363d25aff331d02706f203a9b9834b873f8615b73ac2c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
