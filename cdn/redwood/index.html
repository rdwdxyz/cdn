<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"774bbcaeb54893e4a95bdda0b254fb64649fb9a9db52c795c3a1583f55507a63f52dfeaadc024b8d148838e870b775dfd1e53531fdbe0fcb2ac3bbd14da67d9c0d0770d6710aaec6fef9a572b36d71184286c8d3fa7f50039fdf93c687aafa2b3c13a2a53d97f69769c2e23a5976da16c997d788b8e8f4bb2280323fe0c811d686af774b3a85de8098f4ec84dbf793f42aba9b4caac151f7ad129fc66073c0bbf0f721eca459fa1c8a382a7351f6de7cdb10d11bdd4b6f12ce532916314640d21f1f4fcdad10d11b5b8fdf664601d984963a5e6c5e49ece7ff2f923312c650c10fc0e9004071ce2076b55752db30ff34f7ad4d7dc52fc34b770178d61a9f489d8ae86d17d4ccef5700a5101488c9c373a74378cd2a17192e41c1c7e55e5d6d8691f2c4e8c849b9a5a312d6ee7b49e140bba9dc1928b3caa80c538da7e0231b2daff48ee0a099c8f01aeb8fcc997998545d2a584e742f26ceec3694507d2b332c93b55adfc05c2c9622905c553b9ddbb6fa5bcff6155c256c8ab984f08dccbf21d2382a3cdb7184257934dbf3020e37554f3e3195d75dbfab484af027bc2310976fa04520b5cd589de47463182a0743a1cb3795bc428a521bf4fd67325a938b5ab43cd5026aadf53c69ef2313b5b3bdf17631b16fbcab41f941a40d26f1e171d1f6624a9ef9bf47f338d5551dda18421a32b6ee5e156f87d13530aab23869217e11af040490bce3d03997b83ac5074736f33d60e4a3aef5cdd0b1891e40bbc09ca420687e7065daf53f94d51c2b7a9a3ffd45e698325ae4af983b29cb4a8396fb2a5816e9eeb9f237145d0d9b1aba1241c184d568c396d46b5d8551905724ffe3466c0c9d1824debeb0674ecd8983339be6a2ec09f9629211ec5fc03cc38dd7bcac1b15677d647507d34cd1cc088f76f12a29d6222ab6543562d4e2094ae09b1ecb726a06510922a34ee44152fa2c371cb3c9b5f599d64f2befe78bb58f7c0be98cbe887631f0fad8f730acb4b062eab173dcc599495605233a6cf0bcb66fcf0acaba2bf7c34422ca360a0e4dd6f6efc22bd5507d8711df78ab7e51c8dc47bf01327578f9d3be43c9e9635316c86cee058c00e2da7720a7755ffd9a8cf1958693f82ce42f9b6a8dc318df3e6cd0123b4a3c6a197dc1e6b8354c5c034b1f6a4cada56495a26b5b56678d47f8dc9d68fe47ca5efca907fbf7235fdbfe9a382b560f8ec06ffaccb40934995968dba2b40f64e64a8abd8690ce744601c0bfbf3a45e2b9a2fbcade31e54579bedb16c75f8c5edfba3b0465ceb8bfe2c5872ba6aa2f320a543e306bebe517fb419b8d40c1ccf8cb44cd4af9359410efe2a9d17aeb43c3213a5e021073c7e4fd5e47b113b60cbd79ea4d4512cdd3ccd805c8741ad462667d08d69170e06001e8a5597012feda416ad53ad3eab9c7572e028209e62eddbee2dc7b15d33bc751cfaaf03e91cccf84c5696b71b44342c03ac4352eb88ad3f71dbf76d448aec220d32aa7d797dca1fc4afc530a6c58ae61da4427d7cdc9b3a412200eb987cecff7a10331de7476c2280097fddb20824a3dff423e41b591bfc8efe3a1641974854242d1e5bbd838e2e079f70bccc32b2e6c431e361a791d6e077e9b1d03a307d1fcc10101e6fee04bb4ca40a1abd37143703ced7c9b7a1e70602399fe82aa774b2423a1246c80138695af5e5cbc6d9c489e3ec49eeab9bffd153ede43e4de36dc26c9605bfbc64f2723d353016d65211eaeae60dba0cc11d39e72f3b0ee6f12ead4e9fc8f22d0397fcccaeb03296ceac01ca4eaedb341c595c246552c15af90eccf89616e12fd2b643376e5b64bbb92dfd404d5b3e0a25b6402a21feb9d0df3e19febf89a8ea1481eb5e0abd55af228410f25cec30cda958a62a6b89a31c9c4c4e61c42a7ec0c3c7ecda10487aa591451b5b79a7d07d7617731412476e43c7962aa87c18384fde04d99c2c1ac58f36d55ddd6fe7e80af032561967fc854edd62026063e7b3f76289043c68f5e68396d598ed48983c94339714ab9b671f39ec13108d75113da40c555ed62a7de9ba83d3283b234475fda35b0504b62df61c80c7aae835bfdd1835dd06ed666e1041b6cb508ba528c8a8cc137a9daf9b2844b25ea71f7d1bdd4403b7b81133557797d31001e02c31fd82ac4e4729c5d2a9ec131a035f165b5230120afa7f169fd8205fddf350481329a2bd7f57987324edc6e195ba292f2e2493209c5c7dcbe596158dc9a871d530082b925093b297984832226fd3f0f6a9da820e96f430c33ea4a1c68179f5adb47ebf7736a02ebc48d2cfebecb0f29261723c445ef859ee1a4a9caadf7f48b18b7a98b36c4981ab807899dd4040f71ed76d2e6e3add8db74e874c1bb551a3d9d04faeb1e212bfed8a8889d3dab99de4eab6868006bc34950c7bd98c73d01a7267ccbf8d40dd91733300a637c5431305728763d29fe18bc3679e57bcca2cc88016a0a97b0d7b579db861a9f7be033d0c3892e8944af802679dc061596e1ebf6977f05b9a689b9b206179b3492bbe13c4173a2c4cfdf77fcc7b065a6a3bc74a75f1b02fa2e7a2fa9d1c4a7df25b996624fe2d1b54fe78e03d25eb991deb2768e95d9b781307af1d456215ad853d34400dd87315e89baeac706583a991ba9dc69aa786158f0f537c26ddb5e9be7385b940ae6a80bdba96aabadb8827a3ee1d2cc63abb97446703e1be14395973895a549fe649beb58849b32b1e8f68fd16329f85b2d240cac820fde44c1bf6bbc5593a2c41a7e1d5a31502bd91a40f8c408b3de9f0279effcfb5556351926348f6132e33d9e803f2fd8f57f0c4eb8a3a1d0dc4eadeb9c33a84d81035cbd5b8109b645c9ac0ad4f40589e92d52a5539a3d233837d5f90febd30192f73ffae4f858d329074118b7190c226ff55b2f0febb7797efa0028c39f66071b2a4e7deebb3e30af7fc8a97d67f2b9fe30663a7a235bf375dc7aeb0b9741a85bc85e004276115daaf11513c8800de505f913ea40e5d8f492dabc2dd4158d261280303f9804abefea3e8d9fbb132573dacbe4ccded5a1ee7ae391e4328dcb9b64924835be5f8dab40d45bd121d3033a6bc0d9f90da40c2edbb5f7e20e99fbc068e35e540a565788cb25db35078f20894677d9f3b53e3c7044c6bcacdb767454f2005de35b20ef034c93bb3a57c8955f34885093b6aed97917ced2e26272b50015fe8936f100e9e5b52257b2eb541b333797f761a7c6dcb080acfeef422bd9f234ee2c0ccac54b5d943ec1c0c6aa815d00ada1b8b35e087436f69ec46b0edd7bda7d6b58eedf9fc43d9f0b29b2d5b8c6286a2241c9eeac975d2aeca93240be1e57e0a88ec66b1419931c8d7d4b363cc0db95a435d62123afc831759b5b7f073c9b477e8b3644bf242d6d2820aa2385a695ecbd47c72249226b02c5a52cf5a61797dbb40d230e7707dbbc3617e6c2cb38be6fd691dd734e2cc5154f12a16675d5d50d47a80860480621b10154c94c33dbc981931c833e9d42b8401a0c98044373432bfb9c09c16157e05891e423fd173e75c2975543604d1b9eda52d82aefa574e61bc097cfba9d76a5e5d3b5675b16cf299ff1c39af2a1daf4fdebd49dc880928f20d489b76c5e4241d3e1807e4ab2e2bc1d6b053273f53a611a154faa5e81514fc5197339652e2a811f12bfa625846a230b5b23370e6844868e31785cdc6eceb448e05f1cbf4c03094758ee8d981734ab64377bbd608a5b7abb7b3a476c9b76538d3f35b88566bff0c83c9375febdb8fd64414395687dd9ad35db9b7a2396beb370e4660fbb7b955c12f5e1f87f19b0f0106adc3048258c5c71d4809786d842c7b87b4d8f10b5454784d49a93064aa6a8832f0439737bf62cf110e93050d92641ca0f7f4ba4afdb8cfc6981d1839ccf4103cf6f1aeb6b19a227f5360ffdbf1c3695e17623dfef3d117abcd9902b53c4a622d721c43efcd0ccca921f3e015d37f36dedfbe328ec26b32404cd76ec369f9ceac5096e0de8f9aaaa449ca10e84caaf30ae765fb1798684d97f00fcb8a032805484c205259cd2a20502ba94e9225de8d6937b678cf9019fa1d582d492c4394135c208c2a61b41a114d7d893b4dd47634f90cb05546412d77d39723d70654c06a0d66209ab126380e0888874ea027421f7996319228983a846f1314ebaaa2d95d24845b01dab1f4e2a958de0621044957366b1e8ce1809b0ee3dbb9c5877aa6f34233fcf98555d634a4303799a93b740cfdba6d81fd1b40546b1740de216839600b56aaafaf279379a5795251c82841eecb0a8a652592df650fb8dda2161102c3e8ab9207723c754f4aeec55ebb2bd5e2b37636263de431f4f641225e614c94d1667ed46f312c5512f9f51090caa613d40f1e2d94bf4744aa047267ee147d8fb8dd3fd1b766018e0345c369f9b0312aca48e2fba5da12713f9907905ae69eb47d86366bf4dcbd886855e2d9615c9cee11567791812da9fd4ffaf09cc1fc2405d82879c43228d642af71c15aaab2f59876fcc5212a9672838c54a2badc365d2266b627bb4f204ae6451d1b85a519eaec1d3bf3aac5fb04f90024fcfb8d192b8f69674482682328ca4a0c9546eaf43f766404354461c2a943a41c3991ffb2f3419cc0e5edb5e4563aed903a118c35f034e050708dc89b7b5dcba1660d472b08aa77472a67c584111efc58de085adee03a98edaa4aa0309d27edbdb235f5e7e0a2f2eb57e4a1a6d4ec12494c02a769806fdf6e37f7d4e8fa6e4f7b2de965879d841fadf7a130209c506263c65986142ea37e8c5189ecbe20fd3b7c95877ee57112c32b6ab0e2b3f7e2a9ccb1029a1d4219d07dbf535461bbd8a689ac3bc98351cfb76fe7a5d395dbcc6fb81a7acd05aea0efe58133b0cd310ebc92915e7ede490197009ef04136227e4343b345119513da0f82b237ce6b3ccd8cf908054ca11d9a491274c98c262fcfc2e4c9a853b52dab7cc4cd06a2d05f2c70402bfe560f6cd698e01397599a935394594511238a7da0e78722d2e42d1f75eea7d797039ec4574a4be3236974c5acd663384d2c8d7fcf5d4757078fe53946d4e26f024ae75e6c974633f86f9996af76b722cdda26c19b818e7d2a7e8d82ce7286fb529be4f870e8703b7de2011e91a1f840c651a63e48d16a50543983de707ae682b6a8061d24e6ef787d90786260ea2f36b94d589d370d8b99386d561580d642614b071b754239eeea08bb3d4a484abdff326eedec9b3b4a3f7fa27ef32278d5cbac336acfddeb48550ec3a88970c26ccb43316817addb20efddd0fbf1a064122024acf3e5d697525e1e9f6e20049716f76330bc50cf9b41cef327bf0d3c458e6a432951fc023da20ddd8efea9e3f9b96a223874a06a1341825a5309cb0b8362e5d7c993ea953e173205eed0877c46676559fea7599951dc22e405c7599d0ce886d32dce3c3c22ae398f05b6a40f52751851a47780cdb53a15ec48f106ae6a4dbb7f6686b7716b1a34a18b879ac167572a56181badedfaa556b0a086e5f60fbcd339af1dad956485df49b69840d5f280245ded07387851b63333d44e96caa648794c61e05a2eec4398399a43ff420ec70416e40a0c9eec1e390c377d727caf0c8d4ada8a3e05f219d8cd868a3f17cc5c58a14406d2a432d0de118b1cdc5e57804585c39510c5a20ca37d8655875969fceaa82ac5530dbedfd3f3bf42ee17d0337655ba790a3394cdd07a158d137dcf6d6493ef21df9855abd9038e50e71a077d7009f2a7fdb8c23eae80d6349db9ed513569a224e13e72754ebc0f5b11bc9e31cc1e040074c856fd6863fb8cf723a3213b3201515da933ca794a83315ee2b144631a03c120d32fa32e46b2e6de44997239662b49b5f3d7dfec0cb261733a8d131264b01b6752dfe8ecbb2c61e0e0853048fdd0df0950b0256c11b248d96e60d36c9803c062d678f784573f4622564c29ed27ee701fa069b121ae7cbd8de19880bfdc584241edde2286c8f17557878eb55e9ee3f6497bd2b0fa94570bac93e64e89b292301b871b5a9ee82c8c3ce906eab1134e8cd051fb175c664b03cb472db2af0280312474ef68dae4d2ed9e88cef282c9d7c0bd1586492db491693bbd22cb9f3da1d95737fca3fe442eb689af7deaa22bbbc88c0929ce572ff73af7e639d6e9eff5ffcb8258d5e3219af30567b8a338f2b15637d309a84a60edacf7d3cdd0197169f65a6adc1eee9a7fae3fc177e0dd263e7374babb5616f2827c2f67203f6be7213b7c8b1e63fbbfccd021b2defc4883bf802aec936df34e0e7d3d8775e28c426b9db21eda26f8d371489ca218ab3941d5fbb472412defa55d6c3c2ef8c92a74b2afc53efcd7034822ba635e230f42e498f0f025da9e51069fb2c79c3fe2dcd7bf36fcc25c2896c1d79f8e80b8938de1ca5d414c19796b20557c0e46d69f4e7cfd3bcebc51fde9750f34b849c198f5b83ec92e9aa7e09500aa996cddc05e22903d29ca15d3de806cf59e594ff6e36b01138a47d8ae643ca39fe5768d5dc68388316089173e5850fe81250e1059a0b57efe3cc2e04e27e9d1b134044036ee21986a4fe3ac0e1f48ede7d8d44265e9d7a31ad97bd7088979ab2d08b6b8ba7a80466c38c1202ee49dac3be202fa11459df29cb67f73bf848b9fe51b06dc8a703c7c27aec6aaa0d9ca990607340bd29374b2aa0b226fc052761436b6e63ca7aa42db83fc53284480c0dc9fb0db1e6329972d5e2b58d9554894f2ac6055542b568d45dedb1e5bc55c22716a7150f3a7f12ea0930586ab08d3966349e637a779cd9d41d4a5f8cdded69fe77b83e7f78dbfc09b63722cdfd62086737d29dd04281c34f60495c29b454d71a298240cb77ff35984ddd6283ea2e04571b391c71ed7d4183933a8b11c7c02936ec3ca51282ce7c6736205150ee2b44d302293a779ad55aeb88a7440098bf1cc80f5e839db46e893c1daf79955f54f3b4ece672bfdec7ff8b682b95c58412707bf3eac1fc6aaa5cf3e7c7d01ae1e42e9bded2b7d7b894df95345ff7d4a31f1f6fd486fb3fe99c7384d8d381acb873a2832b8891a8a77354093665dd3c5b96d6ba469edd6b196500e9620d27e331af9dd9e9375dc2ab625f19c8c8bc260dd5283e0ea673afe18bd75b09034ccc6fa7fb516ce2ccdc49e71086d8046de03ac1e07028caafbdd107edd6fcd850639d2fcf1fe92ae54b2da6486ab35416bac2faef3296d7fc38fd8e7fcec2b120b644d74ab995d2fd0e68dc57c253f13154a16eca46fd3b79dba0750870bfe51b9f74dda70ddb78adb96f58e87bbc068ed95d34b4b89239058e609a12e9019d469502bd5f886b6e266e2284c88b4d1804d3cd18a04f1453ecd7ac261561019a07e770cd61f1d3d8d4c1c796949f7593ad4e794735fb7492e3555144b8e5b2c3d6e9b5e8eab701c99da7c0f6500bcca299e503763159b2951e1cf144950621bf1d4a28a8297469633b56404c8d1fe3d648d53d4221bf9086e36a9fbc51f42990d82c2a0ff6249923a18437a6de3e827644f3c154061b6c8429f11534e4ceb92d5e6b5bee5119366ef88b4774201bd2a450d4bb8aac160ac6498261318070e418af775da785cb27a995bb784703396ae2b8e4ad6ec2fd75d4e1761bd25bf6df3ef87348636aafef7a6a0ae7423421208ffcc500d442590fa76211b1abb95210d6606792cb624bc691e7240d2689e368d9b8bc61535ff18d3a1166b9ec854b155f8a003ca40f3a56e7d81b669879d50ab4fc33e13fe9b45ff00016322e7da70471f4dc1838a379340e8bc38f149e55e307e7325998817350fb054f453e2233ad3e8746990a3ae6c12cbd059426d76e6e92ea5a20f1b6da843a04585631d284f1a77b3bbfc3b250b74ed97a2397e94018478d21841be0e3b29a42656ded96556b47efa0a8430d0ff1801c0b1243fe8dbb4b9562b6217e758123363f6f9e0dc361a667e406973dae3e192d33a754185b13ee57855870c29832805aefb4d2c489cf32d03bf3a56d4339e19f3915867fcfe0fa7f819694cb61b6df59f959e1cc9129dab9f81cb1a4ece9c0fe99491e4ce0aa06b5aa341c984ed1bfb9affa87bb936c1d59ace1b9aac5c3fd8b1c30a405d65ed9922a38725d93ccdd44cf82fc20c83819cc17864ecda6bb9ef6c4f3fad3b3e1930d685966c3269dd31aa9e1cdfab00dabfa8baa6c76f44445882cc3f8c67400e82aac0f33dd57614016bd6c4c7bd867c25f0066fc3769a5b6782a4fa91ccaa1cd780b196013ed1bfb6ddf6d7b3bde3690fbb2c950290415630453f9079f0f63575f2151c5183faff0f16e5915181d05f5ae90d6c437b5e3389734da13fd881c83d76637e70d207e423f453900b6258ac88f370f68071b17c933c4762d25bf482b24714ba6b021994a3157e9cbba548ba8bc4c3fff12833ec2303b1bfdbba3ad395faedd80cf33535ff6026ec75d2a1ab5961f71fa5b88d20f121af74374bd6d0e3755afc409c18fa7e7876d448157da80af7b5a4498589102e7ecff715a01b7bc5e881278a6016acf7b2b142ee8f16c70556d022e55e0df3c50fdc6d2a759df626912fb5d117c54c222169e7c5e8946e211f9f0e7e19de65cdd0b14f52d59be8f3507e8eaaa4f16a290c930c410e4af91a719538a412ef9dd984e24350fec0ac2be4a0225ab26efad4e2db4f913e2fa252c8c45fc1aa4ddff67268f990a87c587ae9ca04dd6687e7c046ae4bb86ae699ce61143d3fb7af63e7852e53114e1c1fba12e5b3a4669d1386f4f8b594825ccb9d163054b85c316cd6d51f470efc56cbd0cc847b73d9697dc0f755267bf53e37041e25ee004437aa0516c6aeb57dc5c9239de9f618152894306bf843adad0c7889d766592445296ca6625fcc0dca2d930950a114e3bca7cb3f5a245ceb9d8294d258bc3bc6003d9641f506c4d231a8a1934b99b79e44f70626883951430f8e6e79187112bb7e9193ad670db8a2a562f61a2d36beb968c5dc42d85e0785358b6bc7e786d214cedda51cf7f7ac1e84c313b838538d2b14d81b35ef49f4aa89e98722021e081528cea7bc4c5d41d7f7d3ebc17a0f1cf268768e173c016b345ca084444c087199377c2730f2020f2a2acfd52a91480044457fc95fe00246640eec53c03740b0d2d9fcc67460dcf4f5918bca6b9cf1e1d56ec46846b701f70c142a8b3c4bb762fb099f4391da64cdcbaf374bd10c0d0caf70892802ff38b92fa9b0bf631fcd5886bda58032d263af6e4a60072198f70b4f80c6db669463b23bf5357d224900a86d1cead00210adb8facfb113bc29d0715f43362431a467009b7d1782b2b9a4c065007bccab523b1e7aee377436fafce0a12ab2ba41d88d7058f4a70392be6f5a4f93738156ed6f11593cc50a4ad13995ff8755f9874f1155598913469dd54af0b1c6a33727aa349e735edaecc2e16a75e29eeb6c93e82be3e0d532d3ac1d03bb21d83a163c3d2a2bed79429897cab8d5d5919fbec68c2adaf5bacde64247dc11929abe032d3a98829924a5f03b7a7831393369b0038d1869085196128329f7d39b9e14e25df1c5aed6a716cfb705c80fe45af7b8e83a1770b40594bc9c4fe5119a9fc09db5decb011c1fa2c03dcc57d25a6ec2babbdf7d893be4a346a00c9b481130b4e8e43d936a7c83b936c875e5877f5460827a84cefff244c5fff3c9ca31fe114ef68de014d43c8887035e9c9dbc05d01dbbc7a1646a707e3ea58f8ec33e3a9b2aa30341f843bf2b3d053e586331fc064a69182798de49647f9d729678d913f0d9d1ca9e7bdcd7a4f86f29265c71d1a811ee5718285d2bc7bfc10ba7045ffed7574bcc309db955ac97c6a37da3c13f6b3e5a8af5ec33712383dfd20d47154366d0aa21dd1e5c4f42ade7e0ec49f463a094a36f69e90c4b399ebcbfcd0a64eb46b10a5ff5133ad021f44ea91554c7c801440c377f3f3785c7d62beb1ed54abe7427a36db48c7a88a8ba6b27023cf94e53ef1a957bd7a4c34725ac39b82cfe468f3ee8162dd7d44897a339839f4dbced2540f3ba890e1ab0aefa117861682c67a33939abf1096132c8d0cd1ca86ccaaf7b9bcde465620b784e43c6f1feda86064e609edb8bdc269c5fcd23d214a0baf658da34780dc7bfdabf5857ca9df50c4f6eb89a4ca10e0c7be9102f9c86c3f6ab81807873df3ed620c939e2e585dc40ebd6b2d5b69e1f1287f08f82098ae2f80833a99d4496ddfe63320f2ba47bd6af7ced69ee370ad0889973e8e429eb450febd1ee44e65f8ee65c269078690df7a56714bb5f36688773056ed3bff893f1b737ddf591e6897e910ef36e247e1cd01401ccf751624f74e1db0eb82e8304792e69865a73e5553835b224a02d1e4a785f88cd9cc529f4ad42cafb0fe89de2fcb7a70011db8adabb5d9713cf3712deb9c119349871cb8ec1bff7868081da4767b99447ba4281bfebf5dc0e9fd44ac9d9fff7f2c71c872f0ab16a38e5f368615c9c894c96ac9338941340d8cb924361ced116f90faf09725e6eb02f6a9eae069bf8fffcd70f6d80e9ab967086b746780966c9b6a30fb32aece52e37e1144fafe637f9df72263fd4aa3e746f12420593ddd30612472f860e2b46ed2ad1e10e0bb6dc121267b541af0e6cbc8db8b05326c44609eb91a6bddfd638d819f0a4cf93491f7bd2b1bf4e44a0aef6b994f7e37416d1270d088e1dac9b59a492ced7ccb073e781c07ba9fb576a1bc4157cb1dcbf3a93b76ea778112ff014a974b99defff83a62da140cd9c5c9770a92c2a17c185c3ba5276c4102e7d98b2b5b50655af07186eab8d42310fd51e97f6b119fc36f0e3c67b261f54dc5a467ec2f802a12bb67dd7f3fe315562229e61f0efd6f94dc5cabf1d86b60d3d0ffe70337d9284d84fdd817961ac301205a544e2bab5d9a561a42a278af9b2f4c00b966292be83c4bb961273c4dad354f658c304305daf013de12639ec34f66b53f3291a40782b2e731233728711e6138f1afb4eca7f2087c31056ea09c084f81aa6a72ef82c224c44078479c4c804514fd45a8ccf641be114d8d8f36ffc9610718cdf74ac7b089b45cba001a846e5b06ca3f05e5371aa63d00f8502536f971d81517c7a6ba63fc8dfca8bf713d354ad170a6c2713ef73d2927c8224e4b715e12b8ededc34ae3de2771e679fa0462a97625d89191d6b47fdcfcd57243692e10930f097500830c681a0353314324480ca7e903377a091db76012cdcf196ce55b61d903a15c6eca22048b2175691a51ec2c9c3efc2e0368dbf1cc7e11a88e8b86a663f0570befbe0993fc6e119c67dd4ce9464278bb43865c5d3837bb788dea27bb14d6a43e0fc8a084d56e4c249c948013f38d89d8247291ce83b72bfce477cb11ac36ab8682e86e95f3080b7d263db35da105621ec54915153b4a85cd6b77dd9b18b71a2f86738405f2a3c7d5b00d1d8db0543d33f30fa76b34f6bcbf9805b7c8ef39fed781b19dc0f6a8ba23e91ac1601d0daec8e470753af4408b550dc894da1722a7cd9cb888f1da9d1977f48975b9f79b78ecce089cec51d4cfa5864141613b20c847a38255b6e6243086269a5995e479ddd4432cac5876eaa5b90039f035cf2505dfda7ee2bcbb79c8af72baf3240791c376bdbd89195ae8abd79b54abb94641192750f3db754a8ac59d64823aa3539b2ffc7a9831a5a90ad20e6b0c37796f0b9ae675cccf2d375b03891ca21e0a42764c2a6c8860d2ca0ab2caee639b2c4e50d36e450faa44212052fb162e52b446d07b69db7f9e42c5e3276a76360fde0f8faf552b2f5b4488c05c0edc78be260f1a0ecc6aa86f31f8e8f0911754759a9385cff846175c255d92685546acd4c732c3197857bfabf034f2533cdbc830c89c4cea6535683fade445b20006999f0c6384931e9cdfa0ad2935eb600cae94520ec60c862d411c738daa738abc8d1742f08487da784697fcc087606bed3ef5ea63490c83f54aaeeff25c87644abcad7b47813b6d32d02e564f487baeb93195d07ed337a1739a5ffd589d86737412f93a19e1be0f6e1e66a420614eba2ef11e57b59eb7a9eb388e3e9256b16613011f6786bc8d1adae3a4f1055f08c53f635acb11daae165000c43ffaa618c5921a23a0c2581a6fde877b169e42651bfed0fe0f3ba1cce55bf23d218c0dbd7a0ab702d4eb1d5dc5805e0cbc32a7b4f96818645d90da2fd75fc4f24fb8bda01ae45383a933ff0a87e673d9a46c4e2236d77d8b164ecacd3f1d22cdc286de0f118690b9da711217c4ea23414622d399f99ddc2f3454c1855ddbf78b0ed2ef2f83fedcfc41795373c06833c458b572b18f44537b9d0ffa5709ac036cd6510207ab3994b166789ada16c30c366537c59ba6ecbb4d01a86d05955695644a08586bf92914a32cbc2ff3aa084e44a8d6dc701dd3dea9bfe794a334cfe04b21a1b6b59c6223b1102eb5ff0ea189f8bd518e03a0a3e31b74734b48ef2dfefaeca103998bba534a2e6ab01160a90e12a9dfc8ca7223341baffb748b90182f42f643fd65acc34fde28761fdaceee98598c3710b35fe6a35c103266768dbb6f9532fc9f3241f7f680da89557c80e449b4199d593843febabc2b9df3c9ca987c91093bd466bddf583c8d8d631fb5839fb270035989e2437c58e290f5b253ca1072748a59b9772bcdc2d95595b5bc5281ebeb3b6075d2fe860438b8b6150fa8c9c01e70fa9be3936dee5e05ec7d58f9d594539a637b48a2b554c25d5116a0e757628aea33d799804459e59ffba1dc2260be3e6bbcd7cbf80e9349e28747c45838d4ce07b6bc2831d8ddc86e248bbe59417a9123bcc2bb3f4498ba301463f2c294cfdb23fcc21bbd7b2a00b0c5d349f7c1ebc329d4dbd3d25e2498ba07cf8fc60a995a47b1d00693bc4b9d9ec3e7a0e50e0cf04035daeaefd7efd9d41b57d5d79823bb38947b172b384d04ec23d86f220bbd66cfe0e1c6a3d3e83aaa8b67b61b38af40fdc20e0d0379f78282949da5c2eb3bc643220873fb6af3a940b74f77d006dc579952244af5f6392422359db90d7b9aaba12a074882ec918c568c36fa12c5c49075084f653da0fdcb4c573e166e5e436d7eeaf39de7dfa93dd19eb3ed2e275a91d9b5916227fbacf90581388a331cd69f8f108f2d4430942eaac37be1bc7da20b17166cdf4cd51a90f6c3b6b3cbf70d38d3d07fa6073062e4967928a80285e334df82202cf3512bef3c353d963827c78c510724a813676da2b3d46ced63f950f2614cfa0056a62a4879e6cca20111c04fb214ccb3c5e36bb919c98835306a991f5c543a2171ef203d9763e0b120a1fdad62caa7f72c6ecf214441d59f090324327fe62620a3e757d2fb02774a21a1e42817da283a06f7ba52ec3b8b49e49b727036e86dff05cca0848c66aa6db2f98aff8a1fd8f85edcc3847e4561b35b2b81dbc3e5e47e934f5059ca03ca732a8e03f70eaa170799766aeb2158eabd8f3a5176033eaec42255b2849f7ab561bb7939a2daba422f3c5f6607ece5a3bdcf58a0cbdff0c25f69048d0fc88ec05691ea6c603009738ac4d94789e5236f44f1b35a5b5ffdb9f42efb19804fe8d0077b8bc4232a5a4797684050ec17780f173577dbd7738faf4f482e2d264cf1ac5aa29b6eeacb3d935df12013c4914e47f536df21d133fbec8b5874c8a1148f8317d349fbaf73ee6aeb5abdd38d45bedae5bb7cfea8ac25b92aed64585d70902863e70bc505d676156f1f0b81d9795caa14f6b3ef241f08f4d681bccc68b21e7620a7d3c5ae1797c7c8a9da3cc1d07408eddd516666984f7e89d6fecf3c65e869a7a9e69a734d1e70aab04fa4874654da54e3611a45c89125e965384ad63f49e9d90c6976a94e9460dd4a4b142e0b58fe78fba1044a20f34863c01923ed4775f13c9e70bdfdc4c4e3e24dacf108c8421f55c789c2c78cbde1fa10b7aedee44753d61e8b5c8a6fd740988f727845d0c138b92169d5eb9f6b1eb89785dff6f655d9ad5eb156cfa4f9e6a99f6097bf934a60b64d488b447252b0856478615d313c95605ed1a476caf7ff8b19016ab6587370c3fd867222d7369e7c2b696f7a86ef08df33877b81c791eb6f87b9395a8c4b648b6b320d168ae992c6a36da508ad8802c9939eb19c8f79b7be02b212f2f1b57b8f5e5bcd983ec225ffd12bc7f53c4bf4f15ddab7105f3085388472f38c0011708d7a792027096f1b879ab3eda8c082cb2f313dd467a329fe4d514dbc02cf71e8ce602d09e2fe351e1433c3cf94ee1a534e9eb80e73ee3cd1e9e8e1fac473af146be154b3098fd1273e067697130870353bd70a74574a035a5e1d7e45d34b8fd3327c7f1ee7161325d8e65cdbeda82daaccade680ed73763546fb0af6edf8460fbf765e6ff9b959014f4319eed7e719d10929473f3d15e66ce329a9d5a56b703ca79d0b6a9c1301a55473bdef03f8b2551457b803eee2ed5049936c32e2c4d1fb99491246f577296f1bddb2c17918c9ec42f5a9b1f3fe711ef15710fc2c9b3a4b4b2bfa72ef814c73deffc3a3bd7a9c49926fa0c3d28941624f59daf2926270aab6e76b51d67880a7619514788e6993839b1bb1e9c69640d82f6233d1aa4bc39e26ef065e0a7df76a00c6a5f072d95be0959a71903305083468f0dd336d258bfe671e656b8b92eb33dfe9962746fdd950ec51c5fdd819e616f062e0e2c30c0f99da350ad7f44a106b3996e34d2bba90dabdf4bfeb78ba723db239146748bf7995d901ca549c41908f5a8e5a19090257ef4b2fd7496ed3f4aa2da15fd8f2f5b313623fde8dc7270c5ebac2aeedf75b7905fc0fffe74a399332c51a3c1ee64b1a1c162452b732d82f835ce435136dfaba3120de35cd515728147f154d69481ca529dee63d603d811571e5d1ce7098e8d714f86b4e0be513789bded033a337e752418a6869a9f28c2643da969830098c19021cf3f42a76f7821caeb7dff1c1ebb61c33139d05b034d9eacf37b22c2b3d6fd0d57cf68df75a7f2e98fcc06a30bd47059039954365438f77a10c0b083827ffb64340f73ecfc90da856cb4f9c35ebdcf4c1af1300571b937892cbbc4f710fc88fce640b174c29c08b38599a43d767da3cd5b2a026d5c9500e0f099cbdca62cf263affb05769f9a1ee575c9360280f545b6f29e873b9bc0247c2c696810ccbf200937cf71e9b554d708aa5e9bedb2bcd81465ccb69746dbbee61c262a549849b215346ae87da576ed9b6ea2953d189384a923f7178d59c807d06038f8b7137afab6eab7831cc6614034eec4e2ebbdd64ffed16767d809e9b4d91ffedfec3ab7ad3cb86b69a9203e02157cfeb840d977dfe7068bf75c31291269e400a29aa83e6ac14dc3d6420aa63cbed8507499bbb43820694127f9ea84ce0d1508d05780d7e99a975bf4a395c3508032615fe7a4ecdb48ff774403e2a6daa6156529547d7aa3f17b107be174ddfbd25772479dba651fd5a28a795f59e2214cfc2a17fdcaf5980461f9beb6e1e4eb4fefb1d3703d1480828c8875307d7d37beab53423ef0054ad134b52e5d9c2ae8730be1cbd5b70fb26e167706c62bd7a3597f078ac0eeffc741cec4bd6eb8f714f57297d58c201d82b0e9cffe84779ab65533b61dbefb49e6f3c98bd1188a2abaef62d86a7445bb91853ee91f0df838ec03377f83eabc1cc444b1ba98ee2c07777a5006412c1aff061e15acf015daaa61eeab76dd59897d7073c6d0b6f3d974184990831c964ad567dbeefb1f8ec6cc8de7ec04d506a5afe559bf1864f8fc4a0ba0dfa0184c7e53de818b56d33ae84cd05afc86f5257b6413dda50228ee404f5cf7fb04428c3cb03f9a74a4a9a2bbc7567c1e86a56b680e8e3bfd31792cfea00769647cdfa15be6c64b0e12319c5a6dc999a6eff5557528615de5b70254f1833bd2a67e69792066f13297164e4f8d56e7d3aa4ba5e0d7ffa4055cb5678270949f61e8de0cc93fceeaa8be82244ef278b79cf3a920a711da791fb1cc0fa7166a4d4ac3a1312942cd77d6413fc713389130317e3ef772d7ee9b0388ab93df5cb26b129e11e284b719ab31f080484efdfb66367a03122c73c1a46424fbc89d3e8575e39ae3dbf39dcdc9090251a8d7e75a0dee20542c46921d847c5b9a1fd9495c77e6113551873e6987bac5519bd44ec7695c63ee02903c1311dbd5d3aaea42cbf1a664ac91fc11267a1ec748cd0ee127b012ae2c0411a2e146f07b444b9dfc9e217f9387b201d8e003044137e3fe01e22404e113c2020f0585d0dc7d20da297901804cad15960ade638595e040d88f02de696445ca490b167c8ea53694aac599da91572d21b8c490653e384000136c1f6f1e3372c7990d387246e36e895fb78512a9db5645c0ccff09512d70519a01d92c3f8447158647400a79088a0966aa13d9c6e221be94adddce065034d1b473f983e47f68c3d733f692c471b8e31446fba6083fc4037779649fd87f3c538a31a8658993de3f55e2dd3759868b0bf7c60af667b7217f1b256d6f9ca5371c259ddadce8c8c984fc41db38182e93ad06838a0eb0d8caa7b42a542dfa928cbb7cb95df5472ea0280d0ce573ff532f46d69bcfe3f916aa6463e5d9d07341d25e3718c1a243ef08c6623f77967793b3067d07be591f54f5afedf9dd2e70d648f1012e0fa1aeee956ef832ed4c1a85bf78d4c6f9e77249faaa34bac359583c48ccf1b8ef028c996a0e0165d05c1e1b1090dc9a46042007098668dc28e9c5a8fed4b4c87de2b8607a52a42a738b5d8aed581608e0456756a6f219b909b2dc74d8263ff6b8633663b5469d1d932d1b202062dcf07be96c67929bda1edc7086a671715a87c97768505f7759f764830c5dc56fcf13f698423fcf2d2e14e8b78de5a2a10b119691d06113985da5f78b73e27922bd0b2d295c27538d4ccd531396c1712e380b53c5c266e689a831d6b8dcca27ecaf4aa609d565a03d86400b398e966303cccbe40e698df1bd0144acae1a3004f416e55c633396637ea9a4380ed809871901a0e72fa9fd334565dcb1ca2314345766072831f597ed9c552a1034954997d24652f2a26ea974eed2cc9d84e2526905cf9395fa6b51879fa3ccdd706c44ccec49994364a4d0956ff8c306349fbb43507840fa2828016307eaac59e9293b05f21147ebb7e1dcd0816e8eae1d09f87db77df560ba35836e5ec24e36ac184bfd16dfba3a29767451ab77d05904efdce12137ece3130a6e85fe52907dbcd3c9707940a16602fd6bf947b55a721619424b16c287595f4d5e1260ec206540b1f19853325a570e58b8bc2630e0215a3ce6371f9ff1974652a8271e0d39aa5b3ededf3479e546dc1f3afc7938c1e7ba8546f2d504115daf956fb6532317e5539f9abba9e24eae1619526d7ce96b548a4153349264c0368fe837c389a60490554b58baf5f1d09398e1ce5a81592ffc1654a0d64e74f47ae9ee2d71f77849b4a4fcd9062d5ca6cc5b008229129fab0defb13395bb594739c7ce06ddf8122e06de91d8145bdc5d6c67b2166f4c751603eb1eab6b49b0a509157811a3d8fdea09550f0c0374e904702ae06e488c06b9a22e34f56688ba9bbadbe1233ecb89480d8e59940b25efbb51ca10866e8b3ce16b98cdf24ed72617976484f1d4afd425cbad5d01088df21409a3c3c8cf541cba544668cd0f1f8d61c0f79ec79a5cd96054aac752aaf9a7fd0661f4b1c6a40c71e9697d74a8119bed2438b90b21bbeaf23c206f537d0b06f81ade8c78c78ed1351d29a2fb5106e74952e384cdb80ea0008f0ea112528f4af5907ea3912bcc4e394c90650a12d038451e61361d27486474f231c2eeed651a3765b2f0306d46b7e736aff49a390be5ac31ef9cbb2dc115febd2cc8362b0ac84a3a5a98926263e2e2d5f3792c34eac12cd0dc3a35b0c14891cc843f68a91a89d7f386a65f51b8fe9ea996b1cebbead6e4ab84f50b3b8b04525b001d56332f8dd0bc510d6c1f3b1c0255acd94a7ef0d4a0c44a27aad67d8cd5ff74b5f36e490152b34634c74c3f50c1684b35ccf930c216d59","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
