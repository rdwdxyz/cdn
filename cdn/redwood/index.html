<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b622276831462084b91a6d838f39e197c678248b4b4b0fddd23336fd1d214ff1f6047278538fe508e672bc029e5b71225e2a0762738f1a1c5fcff6f536e368ea5594fe27074fcc79c02a3f75bf5fc4be3a2877315457e89a81b36cd8e20f9f982a5e4902ec523ea0fafabaf2c30deb14822c500b4da87d4726828d30dae70190c73f09b62c327ddb052a1b3a55a2a7f925ca16688544a562c9bcbd51be6334037e2bfcd43d5415c4712581886e88cc14f0abcf3f22ce711e97e8c40b50b1d44e80c110f93c4f61ce24c9bbd13c59fa86e38dcaef15d9a6e98eb3c2a5b0e9532d14b457c2561897cd7d54d974a33ef441478f915ca4ed0355a8b08ad649e3e55adc23e4af43acce1a69b0c514458368a2def6e61649d7e5433f4d21ab15fbdd54abf90a43c045e60d150572df5235be197082405c145e4f4cab963f1ef487e0d61b706d7e072e0150231a0f811f38842804d84179512cb7bb48110dff9cdd75e4903c0691a9c107aaa19162c79c15420a3716a33c25d2e96860bf396fc34ff9caf5b4b77b375e5c861c9d112b95a0bff7f65ce42e07228f8a2bbb20a191dad0d844af05ce5dcc5e3c4efc45c21e181286870e21d14c06b5145f39072c900e9e8e4df37a562f83af422ba1c4bd7ef108fe1435de3cd1336da9560c0c8409a1bc2cf62e7eb252d38fc45fc70a9db98b68bcaf1b49bb395c770c1c0c0f5e26876dcce5e99a31984942665e3e25159e0cc900ed0f1ecae101817a2431a236e75af99044d5b1a5b2e2f4a37d9132843c4c878253fbb47e819ab8e3d7339134b0f288fd37380ce08a5dd9cb6031b6340ed9a57a312c4ebddf9ae5c4ba59f1daed42ed8e024668e068f1b44b7a5e47802853415d2bcb93f47c9ea4c0c488821c169ad4f3cc03b510c18c9b18fbd7bcf1d5f103b5cc69a7e43a86780d3d7ea6eedfef0d99699864d4781eec8fd3e1feb08b3032fd63e90e10a1234f3744679fdc7d565c5512d5b7add68d777e245fad7cfa243f38e06ea1605185b21ec18bf74d0e8f3ce069a2ea477e832998f4f6444077844cc518aa4329a17a2b332c8adf61791dc891f423f37b9e27c25faebb0231ec99486ddd2e7c9d36e8acf762934c5eb5d6d608f91c1c7d68983a9f95903d68f9d8be06ec2b87b804a9718afe8eb4a26e1d60759ad1c504b4b41f808350fd7b2e767121e9eed55e46f326b87a36a853c10f103871a5aa162dea173047f5cba6191b8c5770e19eb1295396ec0e286f8704fcff1a8fdcddf48e1def7c3112df0cc981ff3af0fde7da03b9fcf3c09364eaf28a578b486f76f4dcb18f25260d74c1be07c75f8ee84e48adbdcd96dbc232a232d7156bbad46aaff4b8d1af5a17b9c6c93deb76d7b06687463a0f1f840aafcbac906250824a2ea59f8d447a86ae31c1545100ad4881d7635e042ef9694a31d9718075c4485538bcead4444ee4a95819ee9864e22339afd198513183105cb5217cc0d877d402591cda0b0149c025bb4ff3dc1c697cbab7caf6c61d95fa82be4b0d03f3e239f64c1668f1da09a2a5d194471df6adfeae945c1d0958b03ce0645b12699015e313e9851ed7348404ea20a0656d92a8370cfab1931c003fb5a5a33b99c40a25ffba026bc73529a59d31d8d395036c4c1825a516414b6c8677f38a001b62798a0fcccd123682bd5c8d6a2391b3865e355d1a097d4ee946cbdc57c6f336de988c0b0055e839b7d6f856f5ed88d0302022d52f6ec1cbe9a4ebfde3e34abb6046ce052e268c87df775db73d193e7ef1b685e4380f9216a466c2bffec58e90c0146c7fbb843e5f1c210737e69d78df8bc40d91332bba088176f2949b20a8f93416785fce48a6e43698222dfd40aba2d0a70c583ac0b3fa20a6f94aa5c721c36f0ff6abd017db3402b3f038ae52634b8a76afdb90d1cf690f94918547ff28140f26179998f920d9fb9b4cdf8652149a75a27907324f7556864481680fa3405022f61bb986b72f2ba07dc601fc17b69c8146a6252cc4f64e1fb9636d6d322314601011a9617d4d3a16b693744c1523deb0c89090d8e45ba6f18247d7708922866d65f124c6093c07968cb26b609ed5aebf1ad9986df4cb86cbad2d62561fc632b25555807f90885b2a1be8a5893eafa65c08681ee4f76f4d7439ccbbf6b3bc4c10de98cec988432359fa468676e821d7eba69a26abe7323c401ac2a346cc7f91c3d99823afe9a4d83a690443bab5aa6d73b08deb0368c07f143ac2dbf45de41fc8bf962b5a5885a0b14e9424e354d8a877381269a6d784792306c9f97b494f27f31b19d84722a7ca04a263bffaf8eb699559139a65100c0da83faaac6bc61bde6ef193dec491f3a84f64f46d2e28c79d59842c5fc4413fd626e5af16f04add80c308ae8d2a86e77ae0a52be400ce53141cc1931d55699dae3322f5a825073ba000917d3edae059152e1d5dd9e914d5274bd0f1925d169f27db83aa56917ab8160faa68b33a78e2c48b98344f11452893edfb48b469fe716895c12d115c61f5e1eadfa16944a2d3f6e7f882e92b5383fdbf3884f9a8af34fda45c2d957b3ed872f39caede7f6a92dd15bf547728d257f744bc80da97f8dbae7cd4c7aceb1e5d6a83079c1061d20338266905099c57e069e1f6c0c401ad49ae0c1059ef135f3127d02e010dbc6fa5e16f4909e956aa9305c2bd493342bcc6394d757bc600886a99de314c73c92e80ae3da472b21dc32293e4858535d351409baed1f0d49392a24598ee940ee49a65ca4ed1e9dae8cd007b3921eb79bae78a7ed4e6f6042718fb204e94ae1d5dfc9e815086ea789cbd6472cca850a7fe5a07f87fa43fa06409024fa085d1d209b7dcdf809b76a5b30aa617c4b8e2644d469838e191e90847404e37e7c1a13477b397a1944126814a115447de8b01c991a2fc886b709ef2dc7b4cf8b296de62cce1378033be6b0c83309968ce77c3a4f7329e356d86962b772517e30c5bc1aa7b47219dfd83c85c379c8949aeaa02a05d28d2010b7c24c382dd182970c98ca25cbbd6f15cac77fd8342dde5cba1578d7d2eee5bba4d880d0f426b1778cfb8da357da533891cf19a96af8ecf4439a3262a650914fb771f0166d1e9bd778c492c76b3412c1091de6d861995bbeda05fb33213f42770bd172ce5f30e5397be88f19bce06b42aeb15bb700c922ac8247df6a565a064266a584c0cdab33fb3370eb77268fcc55840e07fef4a54d99090b641d1000947aa3cd4791cf6010c73d1a97939960dbf28264b68efc93b1786dd4847a7954755f84cd97d950d86628d7e943f77754e1bc3f8cb8aaa6d74036201667272c9ddc4a6b28465874e31f56b4ad0b9ce8c37c1f05ac7f8b73912340b79f7348090812041608ff642fd6dee2bcabc3dcaf9f21143d1b42cefb42bf60edfb17f728fe1e497b8ec0a63b4ba5772d736d58768b71b705f964d1df5ab5fff182bff03c568eccccdad811a4d8ba08d4d4b9477cdcf60a642f6138ca46aedc734d5b60c663ae33fefa85047014ed82ddb43c188424b341d685b45c1e44ddf56bc8939401b621aefaa913aa03d57c420a4ac70ffc284c32d7dbf31afdc6c42787ae3282b3ecbc712e970879673704f331050a35143424ddbf9db9d444b1b0f580d4f792da47076c1dedee9372a194496cf79d31ed27e9a59d0eb5fe5c868bb03ad7f7e8dc86aa263ed912d7b278df4355df61934d033ec51868c05c6b97349ea441f54537e46106225eeba2a4c8fb139489111bebaef4807e0be9528a708c5c2145a6725523d5c98535a428d0ef1c659d6dc116a4fe777abdf206b9459eef9ffc8fcb58d8513702476051572b29771d9b93bfee8595770d9749dcf82d27fe3f21d72b201f16a1643e35ecc0cc46415384f331078809d2cbcd1acfb330029de29921f1481a5511b23c024be2eda7b9d1da03a94caffcd1bf27226bbbe82550abbee82afa81509eb31a2d0732aff005af56ed263c03c7ba5f84558ebe7d64a3b6aa39bf38709b0f31047cf5e4143c4d3f077295e2aff0099bc1f083284d02a8b027a68fc30d709d075d1492497d932d29ab44681ba1432c006410144bb34cf6ec4fb6dbe7156d5c96c9d987331a47d9c59039d5b934f3b9624ff017b8dd5c42ac4a3f02d8f026e016a2454e4627bf443e7ed1b02909dca866fdc1dcd72d33c142543c9931f9b8b4e2c120937916569fca51b0f367aaeb741a84c60a228c38434c61b5ffe9a42c9396b382ca7b30152a70bf15597c0bb96eb723abd21f5f094c15f912c13344942f46b82e77ff6465aae38e99da8f26da77cea96497dd357a0596d4020aacee295d623f6e4aa0005f601b44d7d00782705fc453579f7fddc2dadd23dd3f3daacc499588ca2cec9735e7b47a94dc7abc38e96392dc609d9aeba97d17d1e7d748d4dabe6a32565bf08743e69db069bc9714729085f8954c069a072e34041f17476fd493c81a5bd7480341a9ba21c25d5c6c9ca5517c2cd59b1a1cc61259dfec160818574103200b06908121c6501a05078ee8387e885e9c7da6f48c5e650eb32ae18480fbfef15324b13441866d971fd91b726bce708bbc9f4ab6b75571a908785ca961c62d1314072ac361d8510f12471df1595b082802a0c15ad089d3d44aabbb8d9514a2940e0332180af29ec54fa6704bb853780ce32e607891581803437df2a2d0d849ea05010f9b288ac6d33969c8f724291b8e01f671cc477c0f10419d3ca6dcfc2bd422b2dd8a11ea0e03da3738f4a7db53ab9fb9da81d3f7dae159d2b7e1976317266700aae56b14722b416c9bf3b75b28f331773a22d3501e07dfa74e7cc088d053b05af96fc250bfbb717f81252c6cd453200b6ca442168ee03e1bb1a4fedcc33f1e7670669bdd88d0afc973bee4ce39b1e417d8068ada0dc192ef7d1e7de9406acbf79fe22bade3695860a85cd142393c7ff5e8c586631dba155ce26dea5daed6ed01b2b43256cc079bb541d102cc9737f69ae45b55b0d50b78744d3e1be9fb11589c34c7c75fd43f9bce5e5e90555281250d4db9b679294a7576b30c6a3b25b0e7be51f81e18ac0ca05ca6a4639f222494ccf30553af6f8cffac24c3e4a9a62fd9d04708f761e5b6f41c78970f348eef5c052107b6d11ec0d1b69a6130698ec03a9525c79814d835a7f505f6f6bdb87abab2c5e8ac7288a12c5f717cde17286c938ad7887692aacc279fcbd5b7f16dd349c50b6925e028aa9c3d8ba16449cde17c33d1b9eff2199204117196c4c4ea2bc16c72f7428dc140d91ddc129c6d0edd5102cf4203f5190a7ffb01dc9a8f439898810ba2e31a35efb4e5ce93f7f35a21f72b9cd22dcc4194dc48a9f00678834e8c4306aff0292f3f1aee40e2cd3c0fcdc632044c12d74341d7a0e0835152b3154203347029d12531cde80b03b14c2fefacbd0e0b5c733223e229f4b6e024c89ff2b72f53662655106728dfb2a7b92d312bf436328ce4bfd7ade06609adf91bc51dccd2e9e33aae157c3f4474180ed60310fd3374487da8d9011a45060fe58aa2ce5a85b06fb08734f6e2f2b22b1dc4c8046dc0d2757e05ff40b5829e35605e2273f670af6b598c0156a2b1f2f81efad66a0bfa098d1666549ae776e26b168a0be3941d848c6643827714290adfe9b8cc46ed57334c6f3f35f502f228296aa3515aad20f8a041f5d2a53bb08c221b21c936db759265aff47fc5e89412f9c6c592a486c3c2b484fbebc377cc47d25ac8c01d1a335cadd4ab48eb9782ef53886bf1959f88a0a1c017224d973f7ead5bf912fddf127be656730c1f56cba3f4e321300a2baf5e762e7b7b758cfa0ff853d1bde94da69a816188b4cbb4b100b4a7cf7b5e2f7d1d96552287c335b75566851f15074187f2415c500087a7377c6adc55c478374ddc633aa95003f87099bd9846374104669eabfd8daf67a405d3950bf0632f4049217580ae3d62d2910b846621d868634365e652135293af6f987729027908014b4e1ec85b8c7588a151223580a616f4cc6ea5d0c0e7c2869eb28a205fba398e23ae4fd4b92da6af4cc8c62a0d6e6ecf77b83795ff5af910fe95dc54a2a981effc7912e492322c56091cd955e639dd50e494fe50d5106e531f413b8018c56ed575d8e9969cc7215c7a0d5dd2bf516efc03276f25cc17fec74cc2a484c2fc30d1a814ac1857a49c64c85221a8ab1b51a4e7270caa4fb8d1ffdb4f09493622c2adffc588a54ce0b5d839d003cea5bca979b6ffc905b92d9878d091c4cfdd5554dacfe7da623aa66877cc74de5f307b2b78a516e2c9ebb63cc36bb1ece82b2a7162a5dafedf4a48fed904f63ec6919085ec849c295abf78edf6d25ee64c69365ce0221901c7d7ce3dbee1d1a6b1876f1c6be1c5ee65f969e699869c5e9abf5661b6bc2305944aa88299f1f84252b4e18c56786965935c2974624cf65e4c2491b302c32e0797cbba5862512f9c3245ad93bf152609963086dfcf6d8d6086659bd3480b0c6eafa2da170c5f955294b579cc81353d1e43c277250466a0fdf176f42cbd68b524bdd1d09ceabf21cf10362c765f15ef58334817c28b3c498b58d5849a24eca115794fdd520ee6a9e59d51e8db7a9efe258e013bde95767682396e16300c672829472682a80d1d9f3d8e273b6b9f1ceb06b134bf06715379714cfd8472a94861f74cf12204a8dca7083ad0c0a665b8f4368be7df28912775277a5dec46a7c44a8ebad9990db5c3c6ca9f0152b25bb600947112f80468a1895de318dc9b0c590ab3d80e0c5917d3103ee3d6c9d719b0406c1a60ac0684cbe58c5879bb105351e2fe566b47db47dd5b73d78dea458b300c0f618479c9dbe9c582f639ca2fc4c0c1c1c2e7bc3921ea9d4ac4c0e02ea9461fffbf50aa6e7488ab6185bed3baed3c00dafc479aaaf0352290d50ccedf3f3393bd3d173afa4a6928a33759e5ff9f89d6c275ec99589703ab6ce2278e9886ce029d3231c00a4efc14b3ba764587e69e66b58598e597185ac2b942a50177ceff5a92b2ef6604fa0aac7bb19ed4b68542c808e6aeccf034628d0ed7cd0f2f65661a7503842cce2da7de2eac7231e2a7cd6f6d4f086a628cdd02951165e5ec00f1a03c5a90b75b7aac3081710e4f9c877d2f501a9db1486b24449f44274dd267b376fbfb4e2892d7085fe33700c3fcd0ce6bacb3be837261640543830515d08ead38636425b6fb5504f66055cb1ea022885785f4c2192dc2c2e21fb2ccddc24af143641a8cecbdb915458d71fa1263fb8a4d12d85b1387105cc5edb494f250088bb03076646f903df757fed31d18c0bac265128c821742c1395c3460f8cc4755feceef1e0d0ce479555bafb081c3138118947052e94bc64f8fe8d07ce50f3f579681fbcc86ef35203f83e12b25b66e00cbec9a19e5a27145e5bb38c8c00cca1e9ca9c8f93ccdb1c9fcdce6615c62f1eb3cca0607f859fa12b2ffbd5965a76c647b73f2b61ac1bdf3a07695328a13c5f80d60666fa457f837ce03420a8dc3ee906d7736e051ed5709d1ed13fb70ba097216d119c7896ce6130a0c44618214678532601ab9b613c66a7c867f789b78cbe3189213603b40a5acf512a9dd656391dd02790d379fd5b95b306f0357d47b50aeca981444118b65cdad20b2ecd535fc7b0b8e81291b2cc300836e7af304eba71795a306e0afa064b2502e24e92ef866ec395dda7d79439ed5863d88f3eb06c53c78441f85b4aa2965c71cb9684a7bfed3d0bd1be0d7688846760b5e3b7a4f88e5fb1d1f2e24fba31f2547c108758ed24802490d54a025128307b5bcd84e1b0d931a9a3a3cf48223e59ec8c98f28ba02e4cd02f9f4a592d72a3e132978100548486f13c75d3bc7f7071b840d90854aff5cd2358696c5f2656d0567fa14ccdfc3d6062775c1bebcafa83bad8354efac2e9ccd2d5483b632dcf06a9d4de65319409bcda022201e6820678825116e347f6dba290d60a192f138793e5b18278cc94adf9efc38d4976cd21b7ece20aa0a8bbcec79002da7ced8287e98fa4dc65d0ed5af9ce2538e930c10d44d70333080ee558b0605a7adb6d20294d51acb453c0bb95a283ddcef098c02ce2aa3139052c23b2d7dd49760c2140a4a7a2db12784357333914565d8824c9caadc3c336a08b23daba43b7876e8750b10b2ecde8b4f4ff8526a04db381bad699929f24fbe7cc6ab137ab4db5495e47f94bab02679aa957bc68b74d2421f3caf54598f77eb40eca667c4f339efa1f3d05c95c21f07d9ffb09228818b380b4fa4e78ec508ed2148d7304d114785f72506fa4a86dada7a8ed7c74560cb1f92dc55eac370dc35295c7f8c3a4bb8670b894c4bb912b50e72b8f1458a64f359caabf9d2846b5dd42f50481ad7dd84de8bf09f35709a44f170e7603fea0ff724f8bba00386b148f6d6fbe037a199e1d11c1323055a3499143aad878cfa58f07a0fa1deb1ba0cede2691c4583a01db35ef0a5581bdba12bdc23b2faa2159766c53ed3f5dde4a4056a8632d3c97c3a6fb0fb998cd51ab9bd5089976b2a23574727d28bbf175fd1283963f00e4de69c2ed604e588b1470f10d89d439bea365426fa45235984de493e7d9e9481b5b52a167231cdaf446f636914cd66d65c9a92d21ee95430b5ef51d7b5e712b21cbb413f97189bbc510c0aa6ff4319b22f83aefd79a0cecd4c3de376348034330f02c9715ac89fcda0d1d486e71e882b9213cb6258e332823f6d4b9be9d58c8fd9ba26930aab1412036b9bd0336bd6c56618ce81566732917b03e613cbb62eeccf030bb1ed02c21560dd8b1d85811e7833da8b5bf44a176c1d24416f772fa3be65c6f836e000ce1a6da668bb9c58558c6caed1af40fd471a2baaad05431a0b04ee4bfa9b3876e531757dd4817a2007b1298f83eee28d61af0b83cc53658894e11beccd3118223de986f3637660bbd563e1c988743b164c6af35827d40fca2325cad6118e4a7c7ea3dd435a38dd2e51acf766241dae281140b34561fd1eb20d02721d2af7b29901166e31cd3ea0f2c005e4c478ee7ca79711f7912a11c7f8aa6c64aea881e9e9638e25feed7332c57a08f017dd7e94279ea3ebc6fb006ec9df853f9df78a82e28476b7d10b6f996b87ace25e5de2ac9f90e993b6fe76273fd6b4566cbb335e74bbdd722d7ea535e3947a1d879c2eb9e6e8cd2c2425f225d7f51c26421ae1a497d10c35589daffd3509a48c4e293ba46b47d1ac9f8d70fc4fa2631cd0568b197c97f3b85370d6941e9321525ab89aadfd9d9f7b605c50da2f7fc6790d844f4f4cf1353359a2f224b9bcdd265d5dae4242ce7574a4f5ec56837df6b8abfb371c1dffb1a9c80f4f6b9855043c508228106fc947cf3d713933db251ded52f6e1470c86d6a70277ba33bdb986d4765a0549f0350aa1ddef2430afab51845c12ffc932d45fa7aea2d09bf09c854e04f9a694fad02e292b9c912d908339f3c4dc37f7091f6664c2ed43d3fff993e3c219f2da5d6aa46257a3c459a0aef2fb687dc50cbbcc2db6107d3f237ebd6e1d797ce1ac6a72f7901a0d0ba9fa328296dc22a13d76978cc535d67929c7eb227159003271fbe1bc9f71a1d53db5d14b764566944c57f7b9d41dd16415442e901d9ed137f99dbd71a4d2f4b45c2b9831fba791da84787323fac3019690c185d1c05a0ccf51614cc784e31bb94db6d5428d5f7036c8709b6906ac103ff9d28804cb01cfe25c3861f95dd814a7f61043f3c74655e7ab166085f159c5240a7cc40fc2f5fd9f0bc4741cc6411848ee071bfea29b9b7f49e43301d2854b7e4ea3d59f9bbe3453839c97c4e905bea113a5f5bfeaa6d7e64e03f8b19654ed236725d6a3d60b7bdd32624ed0b1c8aaa8722b998f8e6bac7f5f79d7fbd569f6c1397c201d0bf387465a6d4842a6db9b2fb95c14ab111d02cd7139122c65ddc381c6f4cfffc4b2f62625a710feeb24e8a5a3fbef4f11728211250d8472ae73e395a72e4b7843a353ca42cd6f8fcbbf8991926bc5cd0c01e23bb57c5122f4c7a7bf2ae65e180cfbc21579cddebe1c11ff321e2123d8ba26d3e211dc219aa0f664bfd7dba6cd3e542e2ba33e73e32acf30d7fc432d035ef2f959dee9df55efd4c7cef34374ac62a0f7af9be775c60a210c71871f5738ec92170096b54025aed641a31f03e9825f91cde7720110464cc933e8c675560485c34fab153de4e51040b580eb3ebe58d638ac069a3dfeaca3b4d54fa704a869010a9f8ee65409cdc8291146984df65d5b87a45f844c3f5c70b06640f63a75eb48efd53f435a60d972611bbf7080ab684fd59fd595094ac45809d24379b6af808b0fd4897028daae68a23ea7360ed60a0b5c445d8bdf72f6fa4a88aa65dd5789e8ed179221d4206ed5ea4aa50e224077c1353464a89327c8811c4c39f5bc5969b5655e5666a0c5df2bf99bd70997510869a22974793b8c990a947dd0632da97471a5e462b52d1c5b92a76b0c8036ee6be5d8099e4c82c70953e6f3211f149f97d25824cd63ee658aa5990fd2742f14a024b8c1a12d9d5a67d731e14bf7a3ba95ed89455acaf5a55e066c2acb8aab0957afc8735ad1bf48163f707de09f39a1a3806786789cb0e903b77b56f0ab147c1a5c77690faedd27e4a9d5ca76ef38caf2b1713fd7b35b73d1090ae8b2f93bf51de329505a6a45489dec7c701d6125f0a2173cf6379a393494b7698b701dc187e0208aa8089a9bee760c1272c9e9a5e45ba3d0322eba6b463b3d51d6db3a8a286c1590dd0dd3674f720c54e24f9a6f3313e0546cbf94ad068c03ea09d78a5fe721099d33250d4b22bbad5154a3f515c5f70c89abf835546e74340dfdb003076800443b0bec013abc060e0193f997d6fc9ac665f5ddbb0086c9a17d3cd47dd8dab1c522f7fb711156817a7184a5e33dc342d0699af669be1903c1012b162916e2dad1308803784429962e816546b3e2d553a07d7c92fc883c0998469c19944b6ddd36d2fd8238e8a7343ed6d48b11e8b30752df8ab5f62e3311a363054be1ecafa820624686eaa50afb39cd417f9f409fec689f981fb84510ac75def0e19b98583b779afff491fed8ff8ae7bef46cd029689663bf2cec81d5f42e6758c0c1fcec9c51e919678d085f6056348ead863276b2a4a5ccdcafa5b714056d8072279c2edd6ccf1805dbb23cf07a29093343b4a1be569af37186a1307c5aafed1270ce457720e8753245fee53818fb289fac425a3521f2b8ee366ddeee0f6e6716642128cde25be28872dfca1efcdfb63677de6f5a1f83bf00b8f5b0452c5ff99d418cdd2c2f9256d2aed4ac4660e7abc9af7506d00ed13392788640eb10140f129c42159215ced96f69426c365d4269ed16e452bd01a5b7c1300e71140b2f4333666443d8ee75b58e2fd09c2c3445ed74604c0d2049025315baadc1fa0ef71bad1acca9197debb6d18b00ac1a206d320d6260564ee3d5ebe5463901d967d0d3143cad95224b233afb3ea22fb7a8646f1da36dedc67dba830356007e7eece87a2161a66957f7730e8708796bf752aa622399ada6a82113f179f0ebcc6d998b73815394b6d9f0cee0e22f39bbe80898be42b309222e823f1a3ce8f58d9170a4d18024e6b73f787f10a3351a14b25981c40d40a97ae0dad99f87b991ba75c1d45db31b9ab5c8b0d9d0c64c8712cd5548e9a6b9f5111136ff016243eb93ebfa588b14bfdd3d9da88cdf4aaf587521ce78385df3560de048dbb7f1ab3df87aefede7a9a26ddb31f21abf1042644e17c97cd31fb2fa3846acc0296578361586409f5c52b4dd3e61eb13eaca39d6bba0ca1a20ba3845e021d07fa11757a686f9166f5a103baf9afc42277814b6253b4107a973fb745d35ec8daf9f341526ab60d40f3eb19df0028eed76253d6905eaa859def94bdece5a2725f47fd8a615d78de2bce213a8e6a6a941d0bfca6b7053bd28b7bbfe5736b2251d0443f7018854760e8b2574793c3f920890082e2d09e69931e218e639329001c1dc8ce5601e0d50b7969b0728a0681750dbf4c465e72978c2d42510913c65e59eed38dd486ca4860514f31a0061aa60459cf7b095ebd65c53fbce972518523bb75e87e7a6992c2770a6475963bfb6dc7074adb274936d53232e72645c075d60f2add2a7f827a24c3f9f152c3e71245bea62264076199720b845c26e0c28da127870f77c810edc7fc0c0d253de070313e60fc6e26b4a54f088f45438c32f0de185f4afae55a191e43375444f34aff5c37dd71466f2917e0a67994daa9b2d808bfd94843fe3c5880c43624b956ede5a421508e4b617e5a52436d86a70fae205dd24ca167c5ccbb91b1873c68474d5007a206fa02ee13cd4a9d6412768775e77870fc211dee31380c4351306e16f4f9ae9df9c70b3b409f9089bd347b4c8272baf56922c3d7f85278e944dde450e457dc8a4182b073bcd44e7463260ed19b0f5ffa3d720c965289df676f3a73ef6f6a5cb089192c6ce5da19ab71e1fd8ce4bb61ec448021fc8c3870d0b2c829231c5adcb18f49b4ff6189676c3aadc856c5e459729a8c3892151b580bdce266e4ceb0b2f8848ac07d16e548448348315aa57ae1132e1645ada519137a48c30ce8c33a3211bd77b5569799551954a9f54b8e43b2de83576ebcf53fb4ab53b7bd6b6def7dbdcf33f8799838cd53dcfd3d3d969a4b76ce9e2118c2429d24b4bffc337ddcd53af14cbcf30f70dcf16fe8e8ce2b538f04284dad1ab96100f072b7f190d805d09e82489ced40fd2bc4573de08dc3708b893f772e97a3ce632fbbcac0abfdec7ecdfeeff003b0e3ed37bfe36890d6cef2307b4649d8424265ac648555c787724b8ddfd0d68c9b530ebb7b73f9d4c9990d6ae87cf2eb5e13632d86450d9e5f41fa835b3db4a6820d2f98e2efd8a99f3203e5e73500a4ced2274e39e52b1110e1d657dcdb3fae8a97911ca432d1d0de46fcc61c4e80dd56c17c17f5d447704a3ba8ff52b8ab9ac0bf843131028861d9750f515b4ce20b290ad80cd58ccd29deffdf3a3e4c6335f570bcd07c151a87320a47f5695a8b9dd97491e5117d9a7f13b45abadc62cb2161e11c1174750addf2308e7a5357c95a95474092882b7438c52baaa846a39688844a350688230d22b9e64460705c7a59379c52d7530874768b46cb9c4751b38c7e5d6bbf3e267b892ed71260bb432444b0c6fd1bc87cde61840cfd7593aa6957ea1dffb70003e6457d2b3d38916cd762babf07be7a6e55246fc32effbe90e6f8883b37d23b5c925504cb7b85b712e2daf480797943e06a8ea23d49e45a6e5a45ed7be053e5285ac95b149fbddbb3dc6aee7968d61f30eb68a7430ca0b55195b1ac16277ab9b6c2a820380fbf5b92e8f25ac529866c08bf9efd31ece61483d624f5b09b7773b9dc0094886b8daefc4752d272d55035c125b6f1879b16f242c49929fa448f8eae122c0be35780cc0f501e071273082465e30cbb586bfef787a3e2ea56edc8960c54db4e042baf664c8dcd9b2e6b1d212b09dbaf68b9870717ff04de9618631ffc08a5637a4d779961f580afbe1feaca11d1544edd4908cd295f622a750a6e0d8f32710fb645e4c0b3a33ba439bbcd74534493b026d48543620f3ec438644d6171eab0e0b2e4180cbe8e6f9e50313e308f372c6097b6435df25743fc784632730a5505f4f8367960d56b21e432d9a3ea5ce0ba4148105fee0ce62ab50382c3f14b984610e161a8f595b85b06ba740f708af25e5a9d196617fc13aca9f5891cea5ae22e4e383075d9d23872380f78ee7e289353e6c953e9b5590594a6203044e90235237575dc3f5f1df7bcaa7d126b9e8f373288909227a30e7e58174a7ab54c6ff92224a259d1374f788052bbff9fd5fc6a6945bdc40e9ef4cb680b2b06ac5a071756ac5fef4baa2dc3b9100e983e42f4bf6d6cc483ba9b9d7e4100b0b1328de5ac7d6773b043f42f414fd73bd81846bfdddcf3f63356ac9ff3bbfd9cd2bf66a610206f3561c40451176de5748f3b07d8705b4a73945e1384ef446b7236b8e910e3fa59b0002c067f36d644db23b6fe4c1c791108abf3c976c953299afaf8c6c374247f22dac2f55b9acaae8fc378f1996286fd16c8a67dc124abaa99657cb2faebcd4e26fd0173dfd0780f890e6225f58fa7d0dd28aa84e7c689b1d2b40794251a2ad48751761e90154a770dc9d630ee41ae4f2821444765136f8e551b58b455f9b287528693f601ad74ae998f94ec8ecf30e9a330643bb48c72b5039d8df8a5ab9d6247001eae1bd9d00577da67e314ca9c8445233472bc612c73c2099183dde78e7e1b01c92353cde6b8b77061d541ab6cdd1e36c70941e5a79d30d90af1b57473ff0ede5f4b36031033d98aee5d5b8461606ca47495de229ee188d8fdf6c0b0b9d04abb1956b3d4286216ad80ad4b5185b959f2a989be355b26f20929de623ff63a058cd0e2bbfe7a143f4d72487ae02670be71640e0839b03d841f5db61ff90d0e1fd2741bc2db37e3dd2df0011afa8c694a0e71ae1d0b6a924df31695854c43068a957cb6923beea0ef3c71d7593685cef06392ec5870a0ee298e0c0116b2c1eaf88900bffbead6be57be0954305f43f4115e6ed5e813834fca5190f382816941bfdf042fd382d6d477958b6200ea6700ca414e63ae77691dbdb7f949bc65050c58787ac1cb166617d64d905857ccac705ad415294ccbf9f1b834b65fbac6dee2b57e4d026144a3c2109f89c0766b58eee5eeebed287e32af4f52406893612c519dd9a13b8c71fdd565e83bffbc2a4ab8c0c1758ff35eeac14bcfa656e81b2866534ec02a5a401daa25bca4b13155d1332259763d4b96c302d4873cd7eebbbd79ee56d016bc0678de54b11a614bec18aa92c3a09ae0c4a15af2b3dce9f9b5fc3b0d42ec1f65d17638c7a86be4b8f379547e2c45a02cacbe9721bce4667438329090fb1f62ebfc38af34c420659488c4a7d18d5102166d52629c64d4efbd6d5dc85c0e0ca5990cf3f9108b86bbad728e6a10ff86bead4ec885eb6658be34ea3dbdfb8555d569b7185ee91de6bcee7c8d6945f691de6ef8f3612f64a028d7fa30fcef2d76becadcc3208ed78e20b3fd8a62d1b20d4c66c837c1da903d4929fabc40bf4c31d4634281715d6f5fa2d364277517a0ba0293653d97fb7a12682564cd1943cdf80c6a5170b7f4a8c5abb511d3e6b89c968bedcdc5708060cd2c3b482bc1eb0bcd09d9e129836f45e0355960feb4e3f487cc1f606ec01d930f5aed32241792f4d4e2273628cca62ff2cb484916729dd51978b9e65066b7ae59773e200b01d21da6497f09aa7113080005c1f50496e2f4f54968a38f820c696719721639bb82438a46b81a0fc443e91e4246360ad519deae0d93e6fde3b3ed311730884b5ebab68f78092a4e55ddf213080215a4ee1bb69644399183795d94934541b880ff5387edbb264c10977f37c131fcd654ff4bac5041c40baa68053b2272e23302ccc6cd1f4858f853464d5b1f2cf07f3fd156ccfebc4df90329f3b7ecba5a2e487439b72a92bba359f50bc17a2a451521e39c99c7e038dd48b1b21f6dc5e69c06a9211a10d9572e64cc81d9d9b4134a081c3b723da22dd2061f2004e097e03d156727e5290b75a68b992fa9612bd6c0ddde32c977a2dfcbd9e9026d27777105428b641b0b0635cf9c5a0d88819c089a2d27c29470249331e50bfe7dfef9c52ef348d676ccb680dc977d8c8a355729ec2ba1f7dbad2cc7f12d9e441642439f53d1df5aab0f72f18aa2729e596026a647d0b2c717e49e3168eb503d9b83cecfee9ba8694167275e51a497e815655b5eea61823f6138860a7f5442a1fdeb19612414e1f6522581b277afe483a3f2ac266e91bb4ce1839ec993d63e36d67757f04c560813d5f8b27149f6a0949fb489e3a588e2c6992a0480c932507f24fe389fcf3a3d4d757ffa00e36d56ea96ca3c3ccb0388ad19967286f040b19a1803bd635ed058a95b1b7947e2d49e00b2a302c866cf4830c0e95a402a893603bb12f767c4805fe67c16c8f4895cea7c3bbf0bb2052e27e1be31e8e8c4af526e2aeecc51e6f594fcb2558ab38460eaefbd98c94dd19091f731288164c6956a44bd58db39f5b2c0c3d234e02546f5ce70876d834e8c675420dc2c611fb1973a38368e04ea348c6f9b04311c74118e799713dab7b4ca8af0d268cdfab337baf30db5bcc5d335e6790ca961e627186db3fcb490367fdf15525b5085cdf571a2dda6a8da87ffefdf5fb3af4d8d4b3a6fbdfa68ea4ae9fe1bf91b3332db9c0aa0e7c28c2d4bad4aeb9585e44b82bf6f007dba501c4cc7ad5817c22204c6373589782bfec160236c7b1bff2d14fadd9ade021ecd0d4d97acc7e79d75c73f8962cb87a13a373cda11cf463f45f9d874cbc37db2489cbec74764ecfa743e61b48db615ccad34ce2a8468b8d3f2f90311ac09726a79194f1e1a952bf0163249329f8e50cf49347f47b933d1eea0d5ed2823514106dee48beca92cdafdcf3cb2fd6db4168e1a7956205527179505efc065550b6b2d21e659cc5ed9bb993be79ac55fe0f313e49926e1c0a576e13278dcc4b2ab8be3816adbb0c6704f8012f53f4c7b1f0ea7f70520d5b8a1d4fdb01db66696aef9300c0188df7898d4ffa9335ea1c0553e0c9747af6d8f47e4195b0fdb9791f3c083761a39e12c26056f542bf4299c8e2867dd5f6e3a35529461ca86b9620fc48c7f1b2281e6e748af01bab58cbc60a399556ffaa2bf37d2742252fa3b65229ef59bb3edd40790867f1f12b5fb62e932162b761079bd52db6ab7c620f9983a8986b99a7c93be456c24881d8e49ad914494a9708056cfced0b201ca4459ad305285cff5adcb6a105bae769e776c64a73dd7c21541a4c735c85653d8bf8342b8badab9e51a372a6f50bd0d8dd4df0d7828871a53a67ce764a88cc20dea9574c20822101e5a9927e00c125eba71157a465f64da28df86eff1c125c214d2424ae927d7d3528a249818653b86399fe161a10cb7767db35814fd23c5b382454d228fcca241a9d495280ddcf1e65f2b6bf46ed0a0b340e10cbd3ddd1210904281376827f2c63e8ffa48fd82beaceee3326f2920b3941efab33a87d9e81aed23a520c9a797201e2cdc62a1c67eb22889e4237eeeeda164da735fc936486300ef5cd7841d5eb70d1900e8d571ec35f8d4ba5968c1dd8a2fd7f1598851429cc49cee9fb6c673344be75b40be72b53d71be65a63c708be080a1470adbafea3562ad47dc2c9aba0d92830dbe3441cc9aff0a793989a3b7525f008715c8363192ff94a99339ac0e28057af8f52543571822938b3c2d10531f849ae3825c675a81a603bf3499fccd74630dd88eb4b27a15dd7cc322544cb13674e58f352d83be0d110d936abf1bc54efee0bffe0088d05185b8246596dc56eb07326c8cb7e0fffc30997a50c93e042b7f216b70f0c4a83878f998f64a40b2dbe23f444da19009e4296a94f31095cbe685a3a8a3eac6a2926be918c0b6e8682fff9b5cea2edcb9ac92a058cb8d3f94288a66c8d40a0a83ff21a761ecd5cd901700025974e6cd0dbd7b460a46b707676cb0c400fa55e8262ee309c9588081bb9682364da18ffcd9763f204e0ce9ce1d468163ff1513a297a9723fa52f130db5407f6f94b31d975cb37b32237ccc42f44d268a732282a3d79b67021c7ca765d5ad746ce740fd5352cbda3d1a93e91175a5c1219c1eaa63abc27d50c60b6b148ed565ff7b3d307cc7866f36df7e8bd25d504ea35d87e884e7122632fc867debdf09ebffb287396fc46dab25f69f20f77edde19ac08353e11e535420495325c59f14c2df0b24bd34bf60d2261814039aaa6cee53c2834c8afee8075fdf5f5af5dd1e5b87241271d5d3ca976a31731364f8c35a1d63ffdbefd5e96bae7e89abc0f8f51079c46352ed535c2bf4c23564dc96940441af3e60aa5c4078626286c9300136141165045824a6f9aa63f8c0c38dd5baf74d34ee3e6f6a006f0421f92a8bfa06b45c57d23548b119bfbd4cfaed495b69","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
