<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88cb558ac5d26b25e5d0e6db56503f6fc46093062ef6235fd81d0c639b695a39b0b2cb664962933804c029798640c2595f10ddf8d0a3adbe55ce941dcb704a6a0efbdd8381f326f33ce0a1be02530124e78a7aca4d8db4d419bdc37cd31c6ca421aaa540a8277151d0c71070f69d0bb329a4ccceacb97a31a8ae69ffc67f6fb1850b166d71e7be34569fdb613d0aaa59ef66026e9a9aa4964bf818d4b90d9e143cf99638e7c89b5bfa79c17f4cf427a58d567a76e3f4c9c80f9e316e3eb7f2cfeb13bb7e9b75deba8ae80c691fe63c9550b3e3dfd1b7e2a66fd06731fa7ecee4db1f371c835c9088f89306adb687c1cdf30d5ffbe1a0a7609a2cf100de80d359398b675fda5aab7e83c9ce3d5b5436e866ab61516b63ce25eb5bf6f35f7a67afd4936cd9d234ef6df9e65ff1c8fa3fe994c8a16519747f58b9cfd82a8c675380420c42d6b39d8c48f7e9acc5aca558cc5cd61fb669c8619c15d476cd0082917736909327552c2934290dcbdb3e198715cd6e273e2100d64ba26e47f1ddf16d0c0bb30d3391ea34aef18e7dd5a70ce2546cc16fab71d1ca4e525c73691eeb40d4af75d1cf3892571f95d5386969d3bbce8c20d5bed466f6100602f73f745504623cf123319726ca64fee3f04e236e558499ab3e6dcd985b485ec9dccc8cd15e2f16094d2ec84870622e5b1b033ce829ba702149e62add648ad71b0006e07a043a5653bf16ea6baf1cfcd816b9952f3d1308fea6fe3359f3fd2fbff0ed6ceb427ae34be65abe3b526e7eb1f54bcafc1ae3a44a05e4212617fa047940e29b3595e6e617ab793ee16eff8ac83a3b4d129bb62a7b0ab6914c86fa726ae35f30c098d9abd7ae7257fcd41a8a3192f36e032d58fbb81e866ca688b6e719b3be343da015f7e6ad3ed69c3ee6d7d71fae36133bc6a412320361bd24940b26785c60e947dacc6ce750445d6b9ceabab90f9e5e892abf230840ab25397bd59ac87d6568104b77cbec9c943604eaebe28b71a68d97759ebdffbeaeb826fe29f5f269b6b433f338825f430147c0cdfe1730fc8633bbbe530f40dcd0e870be18545b805c720a3e779614d9df1cf7cb9992fde40058fab2d1022be333527969a2413c341fd10665c77805ee06b499da540ac4a557a37672152521397a3c26fee99935c0c0a65a150a3dc0403aaf24d73b93093edf4ba798b3684ae037d7d9cb2e54d3c2e23703c044061fff7b131a7e08acbca3a8760619ff3b0735413672c95abc7057830d0860348da53c7501de8772b3fa7c30203e58fd0ac61a494828659a782f0aabe2807b51d8765dff2f73631a7ddaa91abfe4d3304e90150bd3d884ecf4791ac45734e578605cf3a7bc812a17758363e3b80ea33232599d2f7ee744eda3937b15247f3b7308d86f7ac4ae05d12685c01f313e9c93758a06c7deea1186f826ab5dd19ea94e64edf03ce304525a5013f70386f960e8dbc8abfacbe67357882b209b6e91ead3cf85957b79c26d61d9dcdbcebf9ca3fb35b969476af5485076953e01f339d25bc35ff84c83c24bc5a3ea0f18c2455f219fc0141d3b0c509c57aab1ad7407ef3be21b92b886630efb54545bcce0f5670fd4061e1e5599ff505601381db962b48fbc02d30ec24c071144e20882ffa86dc14f79a12842201b564d7749405115fe3fbf12a064905a9c59086e18a9a4fe1d644d77d2ef1b6342db3a84c72bafa8576eba25a74b12fe53b3a018bbefc119172a734857bac670486315d090a5bee75fbe5e5f6f018f332f86389fdb438588d3c751668779235fcb3940948eeb41f7e4a8944ee3cd8f9afe3600bb89994125bcc4072388529c12d25e234d18710d73b0b410dd93b4055ce3adc6f0a54d0a305b5059ea13de471f4e5db1d69a08e2b6243f2a3d604dfb2e0abfaa910cc50585b657bc3aa78496cc7131e2bbbd05d541e2ab682bf5f361b1e095944071352fdc3ad7bcac2b60d42d10f4e0a92e6e2e38472ce803f1f08040f0ff0ad500d090f02ffaf955777978348ac53a7c1d68e0b08e4616d97cb6fc9322c416400b7fcfe00ebeb9a206faf679dd87599604e46c2199304ceb34d6ee020b5ccf4b20216c79a23bb829766d870fd9e67af29f9c44bbc1735322b39cb44b20f740c712827782cf714db24541fbdf94740498c6bb109418d09de3f7add5b57fa366e7d19d2e0393b90847e43fbee8188f46baaac24dd57302bbe64cfa2f2bf8887c49751d3dbe8b012c20bde1089e52bdf47d6003c9134d68572facf3b7587d866f88ab28f8964219112ef80179379f0246715b1ef93f69d3ac730be2fc90c0c80106fd1b800f544020189ba61fdf6eab46fd7bf9f6efcc74da6c8eceb32ecfa74b9fd2c900fcfebd2dbd3fc7c5d77ea6f9ff1c3d959b986987f3cc3d9ca3c915f56aec65d9b06e5f966b69a2ed20cf81e5704291979eb1c9652614f40202fb0869dce6961dc5aade02a09eee8fdcc009434839025ef206a33f3768138d7dfaca19613d9acdeb388d1eef591c822ab8cfb56b0dffba46d8427d7d2a58aa37bd5d6b1fe5938a50ea4fcbe0d34bd0c7447d77dc49394f8458351d29cfb493225a85ae8e04fa9475f6d56f318b8c033f5245773582673bf166e090d9bc898199123e9fc09b15afc519ea0df5adf194e3b5440aa6467453ace39ed0446ce3740a8b9af8cc0100a6c62b79a9ac1e8cba79259afd746afc8a07082a2f5771aa100260174e35f586faab179dd576d2f26bc5f2615c4caf963374a7cf41380557070bd646f89d4ac0fa436551f7fc8f8abe31634a3df68361cd6ad12f57515bb30ba6bbbfe37b6ff390e1228b7c10f4c1b104e67bdf45ab261154d74bc289bd88ea1a71337e6139b73cfd5d72cb0a8b6b23b51725d99257db87ae3574f98e345234f1cb05e2f02c39b35048a834ea8c532cde0cb000b423ae0101af8cae87d9dd5e334566fd4cbe30abda6c043a29f2e1e8799bdf71192f5d78801cdf90e6264e9a85f1bb720602f1798bf1320907e233e3defa7a68885e954a3a42e621544a43328e5828541002b383f6519fd96c85980338b02254c2448f9a162563591b78691043eace1c8d438d2d71684e34e7f2233f912dac9327de285d3cca351af58f9b325f26702387ba15b77851f599a635cd66b24d0501043f4944b013ad6c407364b2872f62f29ce2eac037f7f22ef0a5692f94b68fb57cc66e2b79a0bb28803e62db6ab4e69082370203d88ac82f6cdddaab50171c3714f1b6362448a928fa6b4dc7fa89138472504779d000bb1917f6d2f9727e4afe95dd41bb7f036cfff559d1e580d5fbcc07d57fea1b5118277e9da135fa7bd5b3001d31b6cde7cce6f1a74cd39d5a0327bd2a97f4a7f69311df2a2f2601c6a89407a9f9228db8ba298bfbfbc1432de31008bb4d684fe4015722fdafcb15e6600b753dc97878cfa3e8c65d29610345c122acf9ddbb9a443864acf78521274647ee7a9e949295b3fe47344d2cc6c3d22988426c51b5d5dc320f53c35d4311832b3da7ddc0e44225760dbdd900810430282333dfe792677338864e0eaad03994acb482f30ec4abc2b4945b850128652c05bf88edcf5dc523e459d854d5b5430ac7ea9ab63ba4b7d1619f639442c35fb8bd69d1815da80229d82d9c6f344c00d5daf5c330931d83e2ce0d747a9eaef4526cbf2afa38f623438e760348c0e095cd5991e2fb6663314048623c987285348fc00a66c3be001ed089dbfd6f9aa02e0adc9587070fba9b5f1ed3648e6a3abef785410bca60e71983f46597593d6eb19d3e526698eec08c9b12866dfb8dc785ae98dd2f2d9d1858313a3080a773627403ed6851421ccb9091f6c6d9b6245bcd6dd1e846a57c29bf672a603dac72045597ea8cf9e379defa35b60a32d9f90ae66420879ff1e7ced258d3a85488e687dfb3ae8038aa551a403107121ec43969cc784f652dd63d984b89ecfaae3a9faab3c99056c7c240ee67c135b6d0744faa54e6f9d65d9a13c2d3280c6a1befbadcfa5a7782b4815d2c256bcc6692f512f896a38f1ddcdd89b962e04df9042e136231c14b2b397dc4013b10c26d21f39adca2fa0d006df4919ec7aa0c9af85987218279511efb947b4869d1ad1a3c20577e7560bc01e5211282ac401e0fb9a3edd405c44be202fbe63b277c7d73a32ee0a121ae50d3ed8ef4789ea8b883c9167c386de99b34a2daec3d71e41ec7fadbe75e0c9fe1bb92fe81545ea94b926cfb37ac506d711b7c06465eb1c95e8984e42fdc3233957f23212281d33fb5bf4d633dc700bd309596ece8f8c16935af0b03d8f261f1f00db14fefb8c9ffe2605581ae7b8a21bf1c5448ed366e6785b93731081430e2aa72215fb066a438a9dd01782dc7a202d09000a08f44b46ef073288f9af54a0ef0c3231dd31fb4fed92f1efc545145408e621635678853220d52887301cd9eeea52eb950a41679af5d8f376e2a45707069ab3a348942a594a9ad0d60c010549e1fe365331c0541f7b91c694f3d71ce2e07c663c5e28b343dc0f2e71aa5fb5efa0568342a7369947327d253e705bd29dfa2cf74bc01625608e50155d8d8b4cdf2f40d9dbc129d7f48aa883806d909e3c7f1e829e78ea5a58df51aa7b28c1a3cc03c7d1e8f8db5e96e59cdb1407412b82462179aabc6719e1fb42d738237a434125eac7a36daa24616e3cfc24dd0d47bc731942147401bbf0000db4c3bf06f03d834c616c43f4d4dcc719eeb925a92f0752baa1913a031b352dcbd5001e6c9fde0b5c4ccf2b86cdcae28a1a3de0d18d3c4f541cd9a501378133d692af4a81d726f01c8d915621d53999ee53d196dc2be2014cfe5ce0e01b069afa23bce63469fa3c8754b44a6f9f98a63c012b5c2e9102e70c6b1342692fd671b064da0d0da7289b0e65e7ea64c6377f546b348e3e93a03b4c7119f2601dedbea487393f3bcfbfa79336f34c4f4ce176c42d1df1ac8ce02e5bde0fe771b166a2741f19fae07cd5ad827372c59a942f9dc3dcf51c9c24054d541431b5bb86e517e530e2c7365565364d2af7af01c7c3f197654f50a03af44abc52093008779f12f59e66b2ddc65b5f5c9864b1047b98e59f81924a105c21c7ba772243d98ecadc4576327f299eaa8550475e19cd036cf445bea71c40a63f8e8d5a43e1313321f5d00e3866e854c64dfece8664313571139e1c279a594f8e411e7e3dc07466366455ad5be3de2305d2c7c348d4531d9ad4f38935ece1843d44fc87a70652b7e7ff26b13dfa1968fb82015e355aa5e87b9389ab4f5ce49157f88bb61cea2b5fe87070f74debeb7472ad45693ad25d0a8b2ff78fc6c391e38f4f19b6053f269e214580c6d629a014db6ab7b24d2bec386e93256355e17444ad31d211a6e2492f29f04c68e805d856f4bc4db227e82c857d94d1f7264474e3f0c9cbd9a19b29ad62e02f9cfcf59bf6b743f4ad2d7bb78d065ab8aaf9a176d7c8358382aa9d4df09e21e1c6fbf7f68b1d9e8088d22f1688c851415f1fc7c7bc9e52467ac36a61e9abebf3159030647aeadb9127766c947a0518c0b7fe6a253d8804fd1a947ba36e4a999718ff3ee236b41aa2d881604b0d62964867ede8bb8ac28ab5e92d8bcd3a75a6912a60b58013cca7e4788bc07313cbd7b8c1c97562699ee9417755ea37b746c87953ef6affe542aea0657341cd7c06a2e95a71868b1c6f3884dd72311577da6ee45d8653625fb32e665f0ab58e79371353dd625d1e0055a8bd3c66529695a36413d34ddd52761e6a7fe627e18447618909c54e120ea7948dfabfd3fa3cd70baf064386cf5e998fd5b24b2ddfe008b079eae96de9ebd5cfc742e1000b29a9653359ee7531bef17d740967795fa14d0524c1c582a503055310cb0956d607be6d804e79840cfc979ce69d04e999d7b0c86ba8e2bb53c79f7c388a225e71407fd6c81a90a0acf56688856596ccd2dd7fd2bc4473932749bf89951228db0ae64f07054f9e2f5e58e98007504160a905d75be191a115751f72a89be7f201ffea7d698c520de2bb9a0a1759dcc20760c68c9beebcb9ca0a765d4217c2af23fc29c8e0cc1365165d11eb9623c70658c0239402eec1e191b6b1b7a0475a020dc02f6113a288c178401c3d39ded1cd60604b8b9d9cbbdcb0a90c2a17982c6fb15a2591c83904cc946d1ac6527643683b23ab55f2142af719b53810a832aafd2a0214ca964002999ae3e2cd6c109acf9baaaf237ce35f7e22123ae2e439b09689f81b705f32ab208db0d220643229a3c221d0af169e66e14e6678f2206dbc5dfcedee0ff60fa5e0fc79d1b89384ff321e881b51f06ee5b20223125082b7747be1c7191505923d8763902f381d67c2e3fb86a400ef03bdf2c195da8ad8d91d04ad7fa443b577c023d90ed8189d7c08854fcd6fd760a5d27d2e912004fb5e626367e84a3c723a845b0456e75e8e607e06bfea046aa3a9f2368b6adccc1650b0f064abf3aefb87331184dfae75d5d2d28e10fed534266dda98bbdef6e86b9ffaee7acf7386b66cb7d0d71af517529673e7f3df89e4993becfdaf17a464d6102efc08bb208422e671beca2cc95332f07034ad544514555d0dfd3358a49e0d1009022d1cbdb3f34e42ea62a4648264b0a18887a4d3b3dc8e24f80700f2a4b1d49089a57be9dad5c0121063a3d4beda177d9e3685e71ce82b5a1ce008be393abb759fb22332127cc29cc72efc8681c9bdf8aee4e6ff2a1aaf7c8fc939c0a1000dd1694f50014ac2627c5c37d007fc613bb961aa2b0b190aa44dfa2e5a695a8ac769b2e0ca1755308bd5dffdec1237638a4b4f817083055599f77a66491c97223d04559d98de084e84f4d58c277b4bacb2b36b9af0e1a79ce96e982ab09481e7370ccaa3f5c9ef43649886fd27a1444712f4f9e20d8aea1c12c6dd1b2deb73dc8062d3865260b1aa31d113997b858a74ac528dadd4043998cbfb5fcf86977775a70f00cb3ac5195f0cea59320769dd3269f3a28f76c674a327e7173ab85d85c56db1699155741293362c5f79fa86589dd80701028490caed6878f954f29ec5df3f5ef19bd9bb7cbe83f2e63c8f66e4557f5c89622cc208a32e304acea5b795560fc7510cc29eff793fdbf59fc1360a8aca59725c158b2f588f05ff4fd0608216529e978800ab765ff41b10d3988395f2af28e94028ae481017d2e38e30b309496fa09600b86178306fb2513c37f2bcaba9e55d29a94c02eec3e80131539021626e56f667c82ed9ea254d6e64e0218293d2410138b33d0504aa7a62853e6d8519228612ef463caea1e3808f27cd61354e2be0ececb3c3b53ec15a9c39243562f103a288a908883391dd169c9cac25ca611a2943b29c1364495d7044448a91bcc5b8aac3cb51f21c9afbdb56142776cd291e28d26366cb959420278acbf0a9c16e5c1fc36cc41ed34a8276766f92f7f6eadd8922e3b27ef7b6a194332a78c736502913dc4c24a02011a7da4632f7605f19a1de923d14bce29b897546c012418010d30605f868448db4fb06d777196cb9b8944e5f60a46b54d86ad67056cc7d3c98bccbd36fa680aebd112429e759948ec8e77547d85a5e9453e6644bf6ea7b3e46345db64bbbd86f1f61c32293712c378902e3f855d72d243b2e00330e521189c4137d590c809a74a8b38c790b734c913a1162b7986982fd183e242e5214d65fe5fc4600db9c6ff261c4740fe96bb4391e8c49eb139fbd487a6b9e26cd885d227c53c9707d174f89c8a0c5919073f50b39d1d42ebbca84524c11807678b256a7e2d7a35b3159609c6230c5d0518279f671af30e50684ee5519edf6ec1784631f49f275aeafd0650a465a2d1d09507f7aaa14bfab82c9459e92817bb196359d1d8a09628ecffdb9fb39dfcf99964705e83a3b3ed6ec7a0c6fdf1c9ce0d3dfd5d44802a2ae56868c9aba7dd800a8a1f73ff9daed104b4297a49a99900699881d23e83c0581812e5564c3ff81f87d96273c47334526d653588a9cca3caf1d85a396e02803e717d896d25050516005b7f4367f7e16ef7f26fb80975ee95c911aab49fec7eac5661239d3f56689f4410a5d674e43be2c5f2cfc22f708b999ee143494990e26775a9d89eb447ee919810b066bb8d6b8d54fe205773ca8f4e83703a2da88f98f06ead3a40301700fd11f0b83d1f7ed8ef0775e5cbe8ac24ac1a0966921fd3db1a4b1908eeecd842714a84e8c97356531d037e3fd60f947c346dc9caf051ff26e1cc6f77fed9104edfcac8889031ce0cbd5599aeab690fada218cf0410d2fcb2e2c9044f91482f947952df79b75b9b081a0eb70068fb5f11baa0f025d9bb95e51c5bbaaa1ee39f4d49804a516245ab54f24ca96b264adb1c7c29c2061aad840b2950f6760a9ca0f6fc91e3ea4e057dc937e0f5f94fb8a11873f1551923c75ffc5a498ad79b72e73889f462740af3c034f8a09a097a5bca1d6d6541dca2f730f7841b65cffdcff99e666e0a11c42914b5ba14afafcb23c082e973fda9b88b2cafa27f793573e2c4729028bba4a1d62590180aca9fea549193e9ad8f30cb8d6de25941f897ba9d74e25d1d30a538a40e20a328166c1abca1acc8151ba6173347a88eb735e5c265070af6f08c1fcfc43fb1f1e346865b9185177a4cbbf789bd8f80deda8b0e52f8d5cc2ecfb9efc523638998b05b9d03a4c589c2e110156ed40d050d10277b5ebce16581967168080435ebabd4c6efbe2033b2ef732b9f9891bd5c906eb238ae4f3a0431b76956cd3e0988dc3bbf115ab7ee22f1d1b3de2aabe32359ae34351a7ff70a4e3d98a911f6479ff5f19cec9023b258ba0f8342276ee803d5c0e9c9ca35330dfb615ba9317909b76c4a46803cc464ab2b7da5d5a26835cf8f41f13ec27c11ab17241e529f9568b7ab685a2752dcacf38f6d5a181017bf1e0000f1e81161eb4f32abdee2761c2bed574fda6c37056b742b1726ca4e1b53147b69d354f658ae8810dc2de9d87e763615304ff005bf580766b94cf358e69e6d2ce2e76463ae8f68c70d43d9252806bac0c8ff31eeefc9987cf039b57f45a6120ddf3f6c108de2c8bccedf5c7ec43f9bcba31488561e61e0dff5dcac79b5ae4fe42c88d8692ceee1f2f1f0c2942656e5fe00edbda04daa417d45e76cca77c280959c6f2a27b33d52462dd804124dd389b788a735b615cfca7c88a103d35ed806a10fed67fda0c0ada2765c12ce8eac8c5e8075be4d77c4161b857764218417134e92aa5ee77d9683fb34a47852960b9e36a9778a0b1da976181ed3ecd4cc5badb6bbb14923031397c6baa9ac6a13a7aa38fa4825dc4460180a93461c250c298baa8efba87182ce88f064bd282fa86a7f215dbf325b8a61334a0709c3d7c7654e651407c1e345aa8d112eec120f76b077ff1c826d05cc19d089272c0efd4d1f1da4243b0d4d7f67bc223d3bcd9cdf89c3f4ea9e7e28c01677ccd7bdff85f4a367b94d62c81194f992ede5845ce3ea06e99e4d6c39514847b7a994e833726e2c5f61c53112451fe1da85cfd140c3c4306b2eec31a3f6699e9dff508e769458f114714372ca916c3df17b1c41d86d2bdb09c0d1bba0230bec57e8093d5abfb1dc184faacd2c7c7c3e76b148ee92164bde8e48e0541b4801577f8fe85d7a69f63dcfe93fae2592eac065107ee9bedb8aef917ce9ece361a8741931faa801be8d25e7eddff38a287c5dcf71f432df533b093afd77e616ca27eb13cf315725e32b9639c112e97bffcde9b6163c156708fd756edd64533fa1e8d1226ca590deae8a6a174793be38a794ddb532f3f5cda8b7fafdd3156f24064ffacbcbea90101cb77815e38d9344165c7464b8667638a0e896bf0ea86e80794be2466ca0f446df56f744ca8c18acf57336a6353d398a3e9d9436295db953a59b1ea9ce2eb0e815a0f6eb9d3293c3aec224d6866cfb6acb8fd3aa89bd68773124bf9bb4fc6bf1deaf76e724c9ae45f375e5eb0d98f2219a480f39501867e17c7e81932268021fc901d998c59f0c933f8163e99dc36cfa68dcc134845bb5668e952dd14b9c463382ceb54e3190b66a900ac0312c4945a5974d63f9e7241035e334fa4624a831e181a87410f402743a2523c287cf2a5bf662bfdf6921f7f3453c6517384c8cf1f1cec87fd129c0756b72c55635127ee564b3e9dbb42b9851d25702d81c971aa096cffd531be2ac3bcb02da56aa0f326a48018fab72a79e26a81e1ca375c7bac7e5ce5141a491dff04d7b63568a362d4f6f4d53d788bef64c92c345995b3caef45833006d33557c64914a7b4cd1da2f4fbdc1ce66c7420da57b0925d62c9eced4b818a1aded2e3ac5ebb35dbfefc0e1c880abdb81891b236d5bc5569b6159573f4012729aad9c53d817fc8d51a4fd1b73dd8f22b28752ce8f342d1bb3e629e89566eb7a8ecb8311aa431424440d449f22b1476fff49c2769a658e2b4ca3b0dce88497c148647de6692316dc6f43cbddc89bc4ab6344006ea87965ebdfc9c3f15e03bf0ef1c3890ee8f648f45e187e65b71b1fb068dac11a134cdead618211be3c530165fb87efd74419baed73633f9d2e2cd5edd808799f3ed6c702c7e180a4e4fe717935b23bdf6d2568fc35adc8b42c6b54ccfb2c4fdc66fb2322e272804396b062bc191f4e71428d77a03710bfb70e9a47c52c9b6f60c06c258e0d9cc37a060bbcf98513e8df33ff0d0d1cbd6be44a248d4652b910875b89132fccdaf663a09784e54cd9edef056eba12a6a330f9c329d490da9f56c73d6cde7292b73c0401d192df8174d5d96cb7c7682685c6c7832466e5a639987b6ba569eace3e387a239c9b726f9fd0cf364b94340f0e536185724f65cfb14ea9cc5fa514e8048d8f9e498881ebd1e721a8fbbb2e451f825e0bdd9522e1be71068beeca2fd3fb45c0bf382be48b607037a5ccb9ec7e4363c037bfcfb0c8753c71a705c2f913019b34612f9c110465d2fa286d1ef4512798e84ff9f8275daac0dd27295818a8edaf8454030e28010f4d0a6ae8f7ea0e534f661c21f032ef6384b86553066c5993a54908a052e709d0d01ce2475ab92e54c0e4e56c1f717c470a3e340a1ec4d6e834d8280fe640d8574d1e9bb977a6e7e96b2089df1683d4724c0527c0dbaacd0c06b4b10fb6b45dc475ef0bc2b1bc1cc206064e0022d782ab3c6200b7b2ada7039ceeaa84c99a80e6ded55991e39b2ee70cb729954daa9db0ffe5c7de2d9091e018fbce42c27b4ac7788c5fc17d98588a0656927df8ea24b1d4bf40f9cfe474e72cb4e0eb902d1a500ff12f41a7ea6eccbc43e9a44ba9785b6e8a938ebf6d5e040d48c09a0a1c76ef57e15caed34495af34fc424b20eeaad1d3372d11ad1bbeb335562b908ba0dc7741d21e68917130cb49950f115abcb39b3c89a748f1795e9dd531cef8eb341cfe6ae9d97c47071cb415019a31566bf89e4ca47dd8432fd284bd1207e300acc2317835539f66a24074b257106ead38af014084e27a1e874f9f1a946999539797f5e5e861e960ff36c1e430b3a32243a272284932f13883360bf13668d912cf9501484cc60fa521acaedfd8954b97ba0b7cbbb991e83cca8ea1d38fe4215c85f8188b7221ab2c9f96a3211cfbcb39cec64b707379f0995d47d344b9df913e244255c0d567ab23d727b60203654b1c71f80ccf2e82d5798ef0f8862ea835ebb83af1d709bbb4f0e1ffeca1cbeb570fdb422265f3f37167275dd02e259ae6369c5587e7aa44b30d63295d4d8b8fe58c9d94f7091352f2c8d7036b3b009201717c728876435c7c51d7ccdafeddc9f86ff30f134c9015710a0a82bb8ffa32cd36047a68fc10b52f86a4d4862af1ab7154252e0a8dc326f3f4775355d0b432a5f4f9a7f67c16f08c7500b3e16f3589a05470a562c02f6e33d58e76b3bed2a60ede3e305467f3dc030f5fd6572e2ec978a1751819d0fcb116f554a2a606bc2e8bf297d2efe1b73608f77ab185ba4e8d3aa9eb8dbee31a42247ba0216d497d7c27f51a70febb6c0a8ae4e4afa476e4a488642c1ce1fd4efd0cc82f698f2cb5800c72672c2ab0055912bfef7c27e006c4e8645a04a99c447d72330c899dc90e14c21f47c9ba7a1094c823659dfbbeea28a9ce366d74bf1c6c6398ea385d5c607ec17faddf089b788d56119083e65bfc470adbaad000d7f2442664e3c6c5e766a41162fe47ca787d36152488c16779e468dec21dfd13e61850a3527086d8befc73f4dabb53dc56836c560f161df38b1773ff87446abeaacf9ac656c3f43768d8e0042dbfae7bac390f964d55f119b1a84f5184dcf9868d3d578e416c2110182261269a4edc513307eafdb516d65025fe4be628cf3aba726fea7ec38a212670cbf42acc98abd1cadba2f3d5f7ff34cf847e8a2dd3c5ea388c6f0034ad5bd29ee47b1b720304e8d05b93906e4e0671457400fb665e546a2219d96ef716b6d17b32c3e2e485ff5c8edcef1f3844cedb30517390da281e6796ea35c75d1d70de71300a51fdbb3e6744fbb069623efe51ddcd49770266f8a75cd09073778df873c415d441d960d2aed3941830c2a05de635343ab22c95cec38c9d1e2ba4746e85412e5da436599b68d9bef953a765a497bada6226331bdc16d040d233f9b31919a0cf983f74ef5a9b781f401bd1c5954ec3b290c3bafa5611cc50496839161454ee6de3fb516df1361b088ceb1d11fb8134c437307067df2f1941a63288331120879fc0cca4de88ec54f1d94aee06eccba5ce214a08cec0b776938506241a18dfe5df7f871b54770ac2298222d3714cc9928ec051a463f6d21cf21b8f9610ae4083773c10e4f3d8bdbbb4a8db742b403fdc3971b8b2dde26f0f6aa817dfeb7c1a971ff115022d271b513602c7ef4e7e22e53f99823715cee307c40dbbbcb13a47d64480b239e895657db61c71a320334b1f72315a93da8060acc3b353955b79d1d4480b1bc09cb248f66e5fe83f012f9c60aaec90e87db1277757294b29da7ef1c545b26363c250f5a8e38f2a3429f1b6b75b0742c81b073ec0bf65fb619bb1d39e93849bd59142b35cbbee01b44a2333e17f45a541e8925f2f4df2fd29b6e6b0f11dfb492b3f31139cd85db0bde26577e5eac1efa16466418ad17544f460c7d34c2995c0c62c1b60f192701b83c04a566e3f531c57b289502e8a87bdf16b9f238b9e4da0ef60b91161a5d2cf2833e44d5194745e181da43a8037d4890ef074befc75d1c92b1ed5b6889f43a06f095afea2a404f14f24c638d2a0da8c173f62eafd9de27df3f4b3591f17e2f13fec5f6ee7546ed3f037c02ab72ebb147419bd8e27325ffbe4d5e93dcbb5ef035e20c3c04e441cef9cba80a72bd951e45a2306ff87e0c473d0a343af61ed629ef4e46a257485e667195cecb8bab89e24c44b50f35c191b7d83b59c76ff13396104fd71c6556a62fda5fac1f0b4bdda0d8ff059767ebd8327c20d1302104370d16c926c72192e9ea787aeb2af40ab6b1648644d52536a40b977ad64e568fe032fb7b6806180f0dc2422e4db73d3fac987e0bb3f3851fc06ab0368f9a742961d44ca268a541bc3be0bdfe4f47adc9a6fc281778ecb56b65c12b601eb0a9029c6b5cb5bf44cea8401c5fccff58e91ae12b2d06a856522262c0c7fbaa2b7877c977b7829fbf95ad5181964a8bc9b4f68e9b52ff5d62435dea58b0f97bd75d313d23230f00ec96f3ba3b0433f01b6814394dce17699d62bbef2dff4387f1897314ef4f8ffbfbe28a201dee67c6761604a639fb98ec89ca6a613287d26bbf1e477c946af12b1a95cdaadbd334bd37444710fcded254ec760b9f5c72ba5b39d9ab4fd0f9a026918214f19687917ad9ea487e59f1745eef1e297a9e74ea2bb293272725d9c4a2dae79461a6d77508e494eeb4d1703fc87f609866d61afbfe235875df7354548e94b9cde6b79e73c4a53e9523403d4bf2ff445a9248535efe67663dedc1d8c96aeb328fb28c7bd7ee862fd8ecc1a5ec07bf0347d5e798d7f97f9b456c6f17688239eb1c951861465c876aab76d0561e9d93306e97b4afe910a10f59543195ccf888088bed54222bebdc9bc6b3ebfc22463ba9c7d00cb70b0e4ee97bd10b40c9cd8180b05dee9da5b6eb93f4901252c8953d87205eac8d46bdb28e22133149da6da5df14d49599968f2b22c6a4a38b1cf4ba0f76461b5b5b6d8e29cbf6f7f30256324e7e590a54b0c22435e01bb45d56ade77304c7f0376ed53cf84db3cea41dfba1e6c9e9f51319f337f50eaa10ac9313a50fd80c1bb42ef8a4389b33fa57499843caff8963f50721ab8425eaf979f400e4db9f7472a6d9de75e3b1f57b3489fd0e2e807c17b4407281da22e132dd1eaf75f5d48c925781abc41c96ea22ccc25a9790301464d12558bd670ab3a80825f65f325eb2fa3da246d2ed158a79e88699c1a9bef8deeed169d8ac18800c0dbb44d53d5636182a1c983f80e4fa235ffb0e7d24602c4a803aa4e59c1af9afbba94ab5b94280f675c75f0a5e6f89447e7008452aadf1d6972ab7b6fe1eeb889a4c33586a69e89e8c20cb7c56071e0a29230b65cea321a9ec61937a71f14bd54ebeefa721ba2d8388c62dba86af186202ecdf41e46f79163e1dce30daa08df3ad006c4150c53a493a1d7af8e9dbca5f0854f22f4894e36c34b0727b1c5fe4ef93a2857da7fd8e45e8393d39b8cdd995c80be74c2b0b094744468084da7ccecf3b03b33ed1c7ef88c377d5181949ab93eaf7bb9ef5901a29a2b4322e0b5c58238adf14737cd352f9ca891f7974862e6c79a7ea63b5cdc31bd24205f7fd974e0fa5d1710e3414d4f18ab89c73efd79e4ebb96daf3cb10c7c6b261380333ead26f226d918c2f33a4fd38deaeab5a8cb8c3faf2dccc9d830996483e3992a850cf24f1c94ac452a805f0a7a71a457540612993a0cd3fc9c7cc3b7b35622290b982f680b7882ebe921ba35947aed0564ebc0c91f542a756dac61b30c8a3a48ff70545a4deb0a3ef51db4268a9e608b0a7e6ad59a1422d2fe2f19102bab4cf9cb4a6cffaaedd587d577cc8fce1e272954f23c78cbd1e00ac8491e47c3d5b51793ef247b59be9e6c5e6ad1cc73b36082b2b7766854f66bf21350b95f409e52a93ca862aff5045b705ad8a199411522ca61b78f20a55e7ece8bc8afe1b8abfbfc20088d4c22cdb0d4b7867062f7f060958c1b0708be1d06690a9d435ce80b15ab03c2fbd1531e4f93f6c9621b907c01f7b52c37bfebcd3267823089d06c5630dbe685c83f72c56d2f1fb1656895b2ecaff3e2bd0295de469fc989d1837a39ed61ef842da1acce1b3e2c33064e091361f72916aadcdc4140b4073b50f6515f299a15e33a3b4ba5fc82a04c68a55ae4d44aba73b8b9a9ab0521237a2fd0684152930cac20ccc8912e20589c81e82feb2980fd88dbad19dc2afee93971ead71e334b810d1b90365ecad39d5bf947bfb9f2cc39bf3f362ec6175e021e64529786c7f8c12474592220a2f2d31fb61730f4cbcf14b9332bc5514916c56e9c464f6926d7e95747602ca3795a3932897e7b8625da2b37e95bcee2505609dd6040209d0fbb4b1df12f09661f29e2875cea5a78105ce5b115d48421a18685d4cdbf96aeaf2b8c5c01121de588d2c307b18041d4a40f83fa82fd078b50a945d73d36886c0617a65082ada7fbcc1beb664d508a247566541ef2a59f50d3aab077c6b8e218faa340130b76aafeb0960eeb158f8cbda07dbdc9c8141dd5fac6860a623c92ae639fdfe69f2e14098efd3596550a3125d6612a430c22725e8ee7adebf647fae31772171d07859638ceb2edc56d1b09f44015409df66111043ba73860e694aa081aad035a414a16677f0e8a6976dab814f43e4eaa2ffdc1bb8033c1f9e01f5c8b475d34c91957b840eca71b7cadedb6fbade1da99b9fe4224eebf67c49d255fcc0894cfa1bd94d3c60e155c7f73345a277d581c0c0d2d99631365ce94d53fad6bac0aa745d6f81f84e94bc0accd9739d9c7a343c8500de13e633f39c306d3a50d377587e469c360ae0e44b8a1e2579225f61e2e9216cbaca0d3957298366b41f8f56e99d256eb01a594c461fc348b09631e35d11430ab7214f9cc743c4cb7a6a61bd7d3b4c51ada77957024eb287069c635121ccc1da0d2a50e3c8870de247b69938e9897ccbaaf36891ff7f422ede5294ffd2ed261c38f3b1d90c664420226cc9112554bbe88ca1d87dee462156744841cdbcf119ce4b1666c0a8f70fe2026e1e0bf4de4fe5f83c76c4e1ac9dc376c629a39177610bcdc7c1bcce46564218265c8551895322b45dd98e7ff054a33292423e6f35cb3028fdde411f6f02089bb20a08dfbe4f4af390649c652614ccef3be636450a4d74481a1262a1968ed7ca1fd47801073520bdc9d106dc97d19a1c69757e80570189d605609a8315fc28a6e33a8ed0334e160bbcd9329e58d4bf53eb1a1fc0f2b3c15fea7ae6d016e5ba498268547f05f5b9cc86831f970c90eef8b8caadc7f1035871803f7475ecb6c2dc3a6a9aa53ee17d048692e59cce5af58ae390274f47439b97e8dedbf8dbed09a004b627796cdc05ccc06d5ab4fe7d559978f5635408c7ec1eb7d59906e3c83a95da8f52265a25e8c83410470ada1a9c50a0fcb0c5e617ce2b9b056d95d4b9bf8870ddbd64ba287d1b76c0bb32bbdc30067e18586a7ebbecddf8af687beb657e1fdcee8efec18d9249afe21f11272add263b500d50686f3e992c12eb4f8768f4ca314170b747d86c17b31d92e299bb8c46e2f61a8436644492ac641217b82eb62668399c260e5f045df861e5d24fe175b447f7a7ded176bb3bba4597628e87e372ac4f7df533fa0c5b2888477297c1bb1504e92b38335ddf34fac3ca0d68d2ee91e5aa680ffd1a5dd93299ef44a61a7fcf366a019078cbbf465412b4c87f92b5677ab19d80c4ff82b994c138310085a90246238752081b87e7220885d25ca0d07831990f0e1bc797425b1b4bd746221a4465a401b945720dcd8e073c780e19e60852400dabd1067c29a02e1b80727f68fa1e74a156e30f18c184bdc28bef4f20d3ee67ae03602f125e0bf485440ebf354c3e6f69edd61dafab76f6372f4bee6cfadf2f3a03fa02ef1eb83f54185b78c9a88a2a82867c90b1d01f8a85e9e3bae31bb6cc3b1ba33ce7d86922b2c21dcd4a2bcc69fa78d18147dbed04406e2eb89872e82a60f113807264e1c65adbb2408b19a2e063ac57f941e77f475d026f91a0ff827cb5610ef54915e75be69ce0b4168e8d4083be101ac3b8fb0464e63472e119b36cf76a00c19ea6ebef16ef1101ba65d3a1cde363e36a43b51cef94e529e82ee7098e6e115423d5ea67c49749bd701a27690397246e49e5447db13e055d65722d0c7844f5ba2312c91dc5ffb8405fbe61432620d89a77e1847a4af937cdda21e174fd09392a429b905fcdbf04d197b15fa6466ced054a13a418f17b174b3577cb7d14e4a75d08219382b75deab971ba568c74a752fe345d58cdb40414924405176442540d83e3ef74c9e670b6aa223c5cbe5918860774b60e81c2fc39f255978ded7ba316645b312810856ee89fcec0f05d3757f86fc30e07c9c6c412897956a585dee3e72224c2e52cdfe72fa57854b6a6b088f168df38f4d14d6b3a9409b26862ce1999a8024631883cd45f9de5c702df8207b78a7de5203a3fe3c30c22d3a3dc2a5d5574530a63f510b6d4af8645adc4f62584485cf9cef912ce8cd9ae9969bfb790325e10d01eb32e2990d4b7fe31092dd019dcde29c8900c2fe5cbf37f6e1dc89ea6e03a7ddc3171fb02ad2416935b90a13ab0009efc70e0b0c2ca3c2b8606739417a45ee9e205720f0d58074347bf8825a21b5a81e8933b30650d457219a294a98ffdc138a9b2213d2a7318d6bad967998796194d2b37b6e4aa4c7ad398a33733825d0397afc6abb86cdcf27260fc5761e59cc7d5831192ec0d0771dcd0fc8b780e2d4415071ab3aafc541fabd0b2cf726032bdf5ed1914b2408631fc149f80ec53b3bc7d6b998e05dc8863146dc8f03bd136863ef0dfc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
