<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9a897b3457a1e5f99d45430e9fc0ae96f31ed28b67e82786e8a9f79cfb5201439d4405e88b4c8f062c48dcbff5afdb7dfbdec38a5cd8024c8049d7f7b619dca9f5c52fd343f09706c1ca5d2ef5f103d490374c4def733752f08a426c1fa2644cacb9f0115df9bc33dcc2a3d4aee1d6c07ba235ba4c3ff5caae44e7e53beb1e06507aa235de260c52712a5afc38a3f44d1bb3d1150bec051c1f0f20a4da884ae0ecf595b3aae6f51a9ed8fa4b6a1f74ec430db65d7e91e4ac3561af7e10ba18a072189518cdf2d3a52e92d4fad800d8ba4acff3ebe69ef8a6760b827a367b0ae0ffe8881d28cb6c4459499d89e53759b5e3ab4e77e990e8bf33d0c7e172169455c5f09b24a8a8b1825077add24f253001f47374f93e1a1dcc64bff54af372a8fa4b85956826819a568449846521e6f902cac91e20e59ef3be64eacef0b72da3b66f6eb91593b797a434cb690b7999d77a215721bedab1e101a96a14b0e098e0458905881ea2346aba29b1da9ed4339378096a0cbafb75e3d6c5ee755f269adc52f9a3bf4bfdbaa8a061e40f95717523b39f1881711403f139a5a2d48b5758158624fdf024d3622446e5b4b6b9e8a7af1dc1782df29e0709481152ebed966ad857cb0d5a008fce496012390928416c541dfe43edc8cd3360d57c9d5cb5e3b5fa2a19e697b6da4926d7e43926b4a04206f5f3535a2e4211986c75635bfe8ff967055cf03e24e12eb63d81f4477c2477c233e726d867b7f5426c1de1df0e16c798145f9d8ac8587ef29a5e547303e4d3f1946b14a1ab3eebcab0120da179ceb8814617e0a42624e2653774866315c60f420c5d104c85bc40769cac26faff92ac978c84e1cd7d3c4114c32a6bdb3167cdfd99ceeb72f719d1a0ed5ab0248ff4d8f28f31d1cc2e152b4942438d5556f1fc458b2e83975d178431e39223af875becfba57679726cc77ef6bc3f86b4c38fd58509716f1c3f3cdac111cfd944e2fa31af7367a193243a1f1cdc4ec9494fe8b160b2498ef81f6e22a4b16932da4690edaa7cbd0d8b61193c7865f9bf6c7e2b0db7cd50df37c37441840c9fb5d6cd4048da60548323f5755806adf8829fdfba035118fa1a78ef19bcf64170922c5ee2ae90106d7e1dcdfb595a385b25337e4b1de5887b2784a14700224ef6a6d0679319e08343c31a8642b2388aa0c397b2ce5045ab0786e2b271eb9391006375657f15c5bb2b1d8a2eb82b280fba9693997e1bdfd535db59f673f8e95ed9260852c0b5b219d77a3ae4be4c4ada40f794e95527b969013f6976a0c1fcbdeacf8de8a5e4971ffc9cb3d6d4e7975d2fcbcbcaa361e7eb7c8ef25ca1621527087124d8f4f393eecb2042fedb2653952db43d327574988bcdb3c8e5867c042f1155189be0dfa55c0ec65ac342b2510e22a79f2163378d2a3e37077813bc4dc282bd3a2916bd43b2a5b0f88db3fb0ee26f30bcf21b7db0f5e2693f54878bd306742d59610155bdafea5d8215779c16e7ab1a3d48be5cb21fab44c3da3d6962f5e7a627d82e2d4dc68a47cc3c7b9b04abbbde8b3bc51d376e4c211abe6c24ff3ab08242727824031b8199c4cbb29d127bced48187b57f7abf1e07cc3b1caff4ffefce14efc834b6201760aaa53cbcfaa0fa296ac3aa4ac992ec25ef776619fd6e80e798eee61de707ccaeae553bf631add113ddaf453f830ae82fbd74e5fe8c046025e5c324fda85d1467c7c542e0cbc7f6ada98aa0f89b56ce9d1f8067aaeb52430335a093088c772d0f6603ad3b2830b7ba17accb38460ff67a42da4c6543fd1f2ae04ec46e991aa04183b787b4dd128629ab52ff06b5673f42a39eee330374125f218325c92c9be3ed0875e53d8a01b32a9e90c137ca028619496a05f1a94679ba60a56d55db9d89aa0de2dd4ccad1c424c061da16d1bd412d11bc693d4aa69ecd6989c712370e0af6897e1d39cc4eb53c7a57d87574b53994221f1e88487ded27fdfb00473ba9215fdc90d68ceddb1aa1a5e7bd6ecb64ad1e6ab96605f0ac1932896e5ee00522f74e284eda22f6d4484cc6d706963b8e0fc13a67752ab5f762510e8307c4875fae8ee09833a0818326d62f2841d3fd9bdd56d789d40306ddc05279c22d5eb8270f2270a5d9cee9f6c8968b5594fe5ffe13090d09ee0c8020020c71dc41a77eeb5f1a371231d14495faaf55f80256b9c675b985b16cedaca76d60656feb09d2cafcce83b67dcf5a0c4acf98603ac09c48dd5da918aab19021fe614adc98719bd79575e31cebdae5220d54180e497af61349bb6fdab8b787fd545e1bc0bc34f80f831083cc82d9821785c764ec162a6cff29649c9d9e1c3b6336bccfe68a6195eb401789c51c59a6a66916b195f44e2373e9eb111e018ceefc9686a27c56ae4cdda44c3d34e7f6b2861a0edb049a726e22381e1389bcd7dd3b84a9a850c3cd3e4c0a3b75017a74cb4d0236b9c214f7926c13a71711b322fd33d92c7b7f94827eafc6828d1d5dd36270c9389fb8b5696e8328580c8e33b02f31cc1785fb9ef04c76f61973ac2c711ce04d24cace7d05e64dc0ddc65243b92db535f571de20eeb7e1fae5b3c34714ad7218b22854f1da7200fe01566c5fd9ce835c92f3e4f6c3b919202340c53f6da2fbb65d2aadadd10eb02b86d4ebbfe970f34897ab1d476ba7fb3a616e1d54d97d7558be8309d76efaefc531263c2f43c8ec094e378202bad3df7f271459401e47b77f450ed7800fb18efd371799547b67ac74e0fa14406f5ecd4b2307cbae75b9b206e90bac435c5d75ae8232d0f2ac7db3694f6b89d64cb54be854e5a991937b01b72be542968c61d3ea1743508368ae3c43e60c4a86d9ce616a2c22b6ae183b6ddcf4f07b5be109cc113ac81e022477156c69376af3f22f43014bbf4ed195c8af0464ad89a56712203ff18c588373cd748e90275b186e44578c69c2f903cd0e99db41ba9ccc12b5f5c9eee10482ea7e7c9ce85d816c6a7884f745b1ad897844cfb1f04898d7ee20c1542934b532fda81b1d95d297b45e994e935be96a85d32bcaef6dcc4e1d05a5ab78ed5110d637e04d6eca60c43ca2dd8bf15b90d9e5eb5385fae90e882b882305e67d1bcfac1a0d95fc94e4e0aa5fab5700cd95394d355821e14094b126e1aea32104edda0f6fb3155323580e6336f009c51f1d9e5d157867d9ab5d6aca06fe4fe67284f2f8dc5db88f310e3cb7d4702e7e2655e33f706a37d27a15b4048f8f61257a3b0fd7d96e863e528ab3ea054cd42f034f1f8187b58f3537fe7494f7d373dce81f1c05664cd9f77d54436c0859abf01514187a185bdddb9c24908dea851498b77a6a94344f9d577a8d30460754cf2305fd6895d3091f77e3d029fd3ecc48b2ae9105853d9b180f8f176e68e34c2c6876a6dcc8ff43ecfb8c7cdd08eff0df09034214311d917f0d46b64c1bb554e4a2796b75b78e0d6567ff0293f66305bd00ea3bec2d6960f6ce75ca92bb51892f8dbd63bffbecdb7ef15a7056adb2ca5442858e08c0ebb2c4639b442ffa4f575a5ec3c38c125965422113c884049effcd2388802f1802db2d24e3d09dffa04a1337bdfb6303d2221f44b9703d83e839386d9e58346397216c4ad042aa7082a6f1c12acc0da17d3b491e2a0b354bb7ef7c7caf96c6518dcf02f7f1493cf9d840fc09a3aa198122452704d702d78142a654f27dd17df402e013b51184a88f2b136f233e4eeb7798b0dc2d69fde66f15673e65dc220e076ef1c694840702a7501603c36aa0bf53bde7a573fed344c64348724d35da571151e4ed1cf028d513bf5a8c5a8a5618e62dc731429884b1443a2570281f4c252e724b8bb103da6a825b6179f59d27631bd8d14da1770dbd5c0d8047c9d45186366a65e15462cf3b3fb5867c07a06ec5e699f83ad96a2ed801b6dd8b8a7447b3d78f990dbea18ff0eed364aa5d27306975b49527071a1bbfab05e3e9a7d8cf62940e87d49969495c2aa4b695659a79183569d67ceea9e652eff8e5614da14ae2f53c54cb9335dca0873e695ef9171fecb7c66162243eb0758eedba9a009f4cd557579c790caf67c44ffb4d761700943b8cac51c8e5f2250511c88660033c2d2f67f39eb4d193a8a4f6890cd96c4841c821274211dbb5f71c12fd7a6e92841f23b7eabf0ecf9011aeff0d77395fd36b72c8b99ed09286d4c0e74fc3739cf5ec1410dd669a8b33ff65f937b8e56ac9992e9cd17f399a30384b8a7adb60f0efc02d89663d1799ba20326638cb35b15f9e22b0c3b87e76056de05a2d7c7b8e35d2b59ad10029f0d5aecc3862fda794538fa55c0f125d67a8ecd2d801a7277e691ae53bd464c4bb5145c0374f5efdcb5138469b6328da2a0a78adbb9ee86d3ee39095f08339220450f5eecdd3244500eaa1a6ba8ab99f2d0c399a75e005cbaee298a1fc6a2ebfd5025b88711fe329a4b0c8d2fb0d10a6eaf123c39bdb55278b67e05b2068882ab6d62e387dc8e3b3f099ac1d0611eea5f139a43f037350b4daf768208f6d9dfaa25aeb33504048562054d7f7344ae1e9e4d1ca46304c23d9f8989e647daaf836653e43005279bf257e4e3471a139a401d1bf4d169d827452f3ccdcbd7222b7875f51a0ff9dfb33259d6ae6b831b9c7385fc6155e9c7e58d84ab36150c500758051c32508c2da2d7a1d0e5a51d6bbdc2a27e5f219e7f495e96c3e32919f2f8bce1cefceca5acaf6413ac6f0dafbc742112af203616ad6282ec996150207724ad1f93aee7a715871df372d3e715188418c8934b55c729343d3f6375f7b83236f843334186b4d9498da909e21964a2381decc5474391be22fbee621777194b892a25b2411faaf52972993e26458e13179fcb21a2e7c77d3238a3739147c53fba1f2231e956566d09e4acdeb24e3fad5a6502a934101b5b865f1d64a4c4e8532dc2e26e7ddde20a6cd1860f22d394945cdec1bb8e519f26ff992d8392bbafa48b1dde267a5dd73dbf4370e1d97d5fc055e2234f259f8be7b1843c377dc107935f621abba7acd7f3499e758c79006a01d72f6544b77ca3d57254986509b44e95a4e12d2a458b5e8b12f6e39c0211bcd13465d9bf2aba5fd0be98af9123fa5efb562f86fcf1f15afe5bf606a6030386346f7357e9f4c6462065148c541d0e7a8ccf0b6074236bf0f09e41dbad4ee1c34b05fdae38acaf30681dd9d8b81dedb027e3b4cf2d2d7b4e0f7de4deb79b37430504636f06dffec628fe943d6b775a6ec5f49e6128866d33dc421fae0782ba3e795294b1ce7676a990524e3159b068ef618467f2b9a9cf8bada390db13606175b4b1b247fef3ccce8bd03f75fc9340942005020b794a6ab4d74a2f5c838d9bd38329df93923ae84fda9001cea4250063175e4764a0eb6204b13889e6d38eb60e1342c1136bf56ac6ed62b69673b6c062cc525a9adf9a094ef67aa87224b46bc0e15deb72990c3bf2d93477de8a567cb0490baa1ba436a17aa1eec5658df44d98b8166f16291d9631f8969db258e20e49f4169c1cbd2e59e026eac2100db07ba029045fc957363fd2fbe0a3e966baa596888a6a48a51f4820a367201d1eab9e764ed9737b3335f8460d613f4b423339e87b27b7b822de94939522532627b656022e8c8fe72172ca7c3d44978f8c5826bf8ad97af11637334abf42bb56a60e49df7f7905f21707fa6455cb044bdf6490e89a99059dd46545c14c66bb829c694c364444a93b42e07ed3ab928511d5046fecbf099c54fc657a3903a7227069d17dac648685f7a00a255253d8960cc6a44a8b7c8234c53d03f24fb5aef4da921226d17112d40aa895d5a4040f0b978ef8a39255e051655303f5444043ec2cf7a380eaa6864c37a605aecb01fc3bd3e6937ba127c07d911f315d540e2673277f1a268858a429e8c95e6208085669f9239a4c6b63563e1cec93d223d12d546ab7ad90cc4936bc534330cbfaca8514fec8c07717236593e4a399f97e0ebe78ad13e3f6d660071f239be6d9179b6ba323052c42ed694fa3038ea85e1c1b7230d24c7d899ca7e70e4b1e7acd2c31068f5bc103519050759d08bb5b61f8bc83576158e629e7e7cd5fbd210b4c3875f4da5300865337b3354410d1cd1c09661e8043c82c234ecef857985087ce092cf0819b4a9fe082dbe489d58c08dd20684cfb3ccf6ac41dbc5f906630d38213a0925f7260306ccc95a49b86932083d562a32eac71065aba56f6619635862fcec84edcd5fd37cb69e12638b07904e2784ce0c78a75a2e7766c4444d94accc4580a8ea2924a20d0671b1e92785decd9ff53109d1e84e8a9f4f3d1e4fba5be8ae0b8256573198d7bb8026c432939d5c8aa42c2dbd768c73ad44f590d259aad9ab281b49a2f3d78cbacd3deb8ea8bff2d37ad314be9c9dd85b94300cbafa6651d8a39f2fc826c9a3af6aac7e5b7b407bc44fb37e35d55fc13f919753abe1922647aeb8959353156c3ff3cffc01609ad56142c0c367e86ed89dcf6d06f1c12b052e0411f39a92006ef6cba4ce1f72d87c0ed8e8b9e9901ae883472f3696160964a15d0cf5b4beafdd765925a2dcc79f7bcf06a11adbf9d9ced422b9ee2787eee61119dee65b80e29d3c7542b0a7dbb4f66d44c9bb744c3887a311b05b1164b153f8ccd3bb1e0705c2a50cad1a66109bc817f4004a64a945f60eeacf85c7de92e7658f4b8103b6a98afd7669abe28df76ed97e601c5479009514595443e2c11bca47e457aa5c11678e135b09bf269b8859ec37c3ac6427e79ceb2c96d2433ebc9198211e1dd2235a17563de02b68160aebc59c2c1e84b5fb4fa6b2d764f43cc9dfd42c30934395e79b16a9dc959c485e93f0adfae432747744655fe7d82e05638932bf34bbb8d76188559bf2f38ff74d64eac5e67ceb40e9abeb36ed5c71126604cca9b19e2fc7c3bded9db7a8362cd6340ee09be8a37c5552ef9013474658c8a3c594c7b5a4891a7cb015ebb7ad2ca90906ac8c6fc7fde13fb6913d1499d11827cc363f09d4b09abcb2e6749d3a3d8387cfd735a1c04d571c6de42b1fe86d9030d8bbd889b8cd362eb742a3e7a3599910967daedafbd1e2a74d58dd670a5155d7f2bfda0bf33e8a62883d5e12379c1905f6e7415c58054fc9f5f2f6034fc75d14e7f32c0231e34e3bdcd716a413c9f68cc3b87cebf19390bd2de6d5325ce86cfc6cfb677179ccab3c08dfa94189a4818c09afc6e42e93b24dee95d97f9ed882b05bc657551275f3e593aa9aa3119248b4655156a5ff3f57200fec7955dad3e4819d08758dd4a2614dc7d676f106c97470fee7fd8626987739fb25eb04f43a026eea9fed0622a7a37b33f812a19c087eb7863481e18d03e9f49fcec831f01b4ee9d44da1efa77fe4453f9f03fb63377cfdc28bb666ae0be38391d4c75421d29643714a8e6c497632cd9dd2ff6a60c044ef288fc2c4a2db8cc66af5b26c58ac7b477ff7c935fd9244ce5e822678901d17e9626be7807ae1e6b8b7d47b6aa5f9a4bdad1153a3b4dcf6b47182a750cf9596ad3eb9f85fd1855402eea0042548530373cb2456d409d64280a599a9d63900d69e02bb32c81f5da78c9331aad6054a14f39b92de0f8accff1c325fd451503a256dc9569e8321d9e772977e0a39efbb1d33067f38d4336118e6d1cc7ad83bfd78ad15eba1f50dcb218092878d55ac403488ed16aa665adb666a20cb86a4d92916f1ae38305a4a12e9c24fc0dfce75b32413ca38cc0649c020a50c5baf3d1ad831ef9ab0ef5f4ac4b021c10dc81764ed4cd0a1dff23dc8f428ac310ea6773f782cc2061bcc1d697e584e3a4156fa17f16b6929925446c3cb35b020c45fbec7ef00190a2ada336ee92ab7c92dcae8695b01c2f5f517cf550a2ba5dfd57c87fa47fadcfd5161367e2b8af94b9743975b2942f71dc4d2385e6baa6c33ca8904b1afbc2ca303ee6ddfb1bcfc067ead7b0403c8da374a72426a85f5000ea636f8f0f433d0b430311ff7d228137b9346d8aee24e0a3801d7a54ba1962e49bc980cea22c2c01d35fa160ef845175df9ab37bc8732eeaec112c0475c5ab47c6919dc39a8039c3eab2352f0ebf0dc64de7dc2b41a1d23b37bb97186fb567b1bc49b2abed553980d09fe4ab20f2ed7623790ae03e0ce53454d8c9f3f89df5db861566c5187c483a2b2702dfe3f981bedf5694b2d7258db18ebaa216d093286187bbd05ce79e462dc0fc653b3191e3e5286d84cec8b79304d694fc0d3aa12535586df20155f7dd374f1981b94d3bdfd5f6d0675649360cd72229263ad3cac6f71f7074daa34a8ebc31dbe110dc41664b34f9f510df33eba3e73610f52f2aea2317d774f5d25742aa730dbcced5f736ed003098e4e0bd6ab097eac122b576177715cdc945f60ec401dd2c4257fcd6c15a9bf9f99b63620b2dd53c9c358a7ecf773455e3fe0377bbc67e2013275bc50f48671f86852455f88616a9b74b8bad2eaa90088954d9239a003c62cc7971f7e15d4290967a7747270d63aa0a02734a4a02708f8ac9ab306d379fc8649561b30515552186428cd2cd7a4d74e591898c9eb7f7500c9da7f2b187e0c9f6378f5a4acb9c38f732fe8bd6712c66af7c50125452dfa0e435e861102006f1bc9548e1700da327744dee34a5cd90c5e3c4aa943b51869853abd95c21ab320d1d1cc150f385bf5fb7e6703f7cd2ebfbe109940ab74f415ae1c72d19f016666a352980a7d86606bb9ef4afd9352207e5dc75dc3e9096714315d64d65aee02945e0d5d22472c8d011ebb9f868f2731114daafbb126d80479dee53aff82fba656985cdc60d120b0a8aca095f454ae65802c927855e2a2be201022a7eda61b5ba00b48b04b3bbaee6f9cbb163383893c8fc74a8ce26c204792c768631059d2e245271d72b18689f2ce1a711bc7cf50ad989406b958882b6c6567ed5c50ca48fe2e650c448abbbdc4d66ff320ef70d77f323038799967688a6ee92691218cbcf8b68d33983cd9a5a1f430873a1977db584eaecf9f0927ee92aa000686d1e9a33ff3b343861d157d48c88b1981b74613bcad8fb36398f9f618074c975b6d41f6b2f8c8bcc80628c80a43e633a211fb6554b8cf5e0cab77e88e34843ba340fab48d9a33aaf6a79901ddbfbc9672ded7a6ffd643317e589740842ac4cb934f691910da35a18e2650992baeb9d329c20930adc8ba2d4d519746cb440ffc992903f53571c1421dcd8d09db2245d69e9bdfe80678799852711a93bf615a22a6dd3f982f14f661020cc3612e9fad92ea3ad7050443f446a3d00f1e8922fb196e0fceb600c1ed7038bd66c94c2f8c5abf15969f04dd2b1c5a88ca7a77b44a52ae0972e51a1ea729d1191e2edf1b425331352d54ac7d0b715f0e2693fc2da10d0268d0082c9fe50e4a255cbb9a657dee6605d3c952422c7f84973a13b9afae8580be7192051efe4824921d906a2893b13f6d0abb154aeab8f98685c55e6924ac039fd56377dabafcf3cf1fbfacb4ee4523eaa5ebc0f4c3293055a14b5a010a465c357c4bf53b79a0610254b3752200e7b4d03f2ddcfaf5f48a6b709ca4985b6c5ffe97baa3a27a0067cd91d89cab21572190068882cb3e6c8541e485e77f8c56ece90325c7391393ffc3fd17548ed285fb61f186eec3ce44b815d224eff3c1ea6de0f60f4611d14d6c2044abe7cff06661a3809bba49e80bffe3cbbb6b50ce2ecbf8435a51d2f801764be11d62f22dcae7b05abaa0776cd2ab96266af0d2a35edad2383510c764b80ec678e2fd61dea4c6f1a52b20d87a0a57c7682dda9e15b69a21412c329d3fb44fc37a57c6a736893a4182d72c45351e87a3822ee89f8eea1e18da1f4029451ee7eed66643f5f3e27a71fc58ba0b9a6fa4009f9f638e3516901b969818b9e54fe2b4fe1404793cbe3bd9043b225b921e118f9bce84492b1d818d9e66b87aab7a7dec15b2691e27c04a1509d6ae4ac5d3aa88c525394331a285b94fbabb06868464ef381e2cdaecba308bbdb1a6d1d7a295b6957d2cae759f43a626aefc9ce37c4fe2ca16393b19409126e272d776e60b377c4e8957ab73d2ece532b6e14a1a7b3352b91c3b29173fc73149162217e9d6c1c96dfcc8110c8cdc085be182b2f5f70bb40776f4d32960f06c1cdf95a13f735fb8192f3dd2abff147bcc575eec1e40534ae66e0d1183ad4d35c9d33745d53fa50f333215b75a66cdcb51600b004df3affb9a2dde5beb4727db46c2b8d2a6f7a8ba53cc3f58b2de034be7f661eb14cab2f5c642e78aca41ad56c9f67108aba00f7f90432a5335d18d0e5b0606434feef6a885a82b57676c2ec6b45b4b2b9daf9c4ccefd49005c4959d0c722bf925228ebda11324cd213ec508e05971537781dec366434b0d516535292d2ecdd723df2e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
