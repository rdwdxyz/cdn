<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b6c2ab39e829b4f725cbe893114b553ece9fa7a70fe3fee52f78cfb91915e17bd227931a44a127a9d371c53b6392da2ca478e58c6c0332d362020bc5361914e9ef944656ef11584b1990b463293a216944f81d0543133a7bc0064a4192c977210a7c7ee5b50d6fbc5a4228266f254b598fa8f3062ea31fc070658ad71900f08c8cb7f072d9ff35ee5ec126cffe11adec728282cb2a95a3c1268edc83aebe25642e5764409fe264c384ded19a3324f43040d786e82d50d4baa3fd881e0676e3883740ed5d71a0631f0efa2af2181a275b039dacc0aa07ff43f4310d099b0ebd1d5321cf0b5a47650df6c97051518537b6b1f44c99e609d51e7883a040a251ddf61a697bf93bfb8eba44c31c13a9d9da053331b4983415905a6f88bb0ad6e7a55380271450011ad02bf7c22456e556d7ddb71f008ba8f27d4384918ca10209d0ecf31bf44517221e2e06175a3b95472291b6580ec6262ba330d401bb416a90a998376c102c84d39972f5566f17faaf4f9e70e2f3a10ee53718f5a8d4239618ece88afe3d5febbe740409cd7c564b2e9c16d12b7dd5e653f30fe6178f86d2a6a3d353ed25903cbfaf863aef268abc96e6bb21dae51539df80546ea36e11dbf2c58897a677f285e19b798a5d11f14aa27b32c656f787711661e7e454f41f75fb4b7903df8138984686fca05cdf217fa177d7bf710e9060cd9edc2981310d816acb802b880fabceffe3da43edabcf900ac8060f8b5f58961e0a89d1b012a2bd5f52ecece57b45184cf7545a6c7c68e450979671fee2aaba5e9b6afdf9f69905c534486740fdbbbe95f3a51a847cccd05d12cbd7bd15dac2932514d2bfb72bfd71385dc34bc1f6f44ce0b16c498a79a326415698981a94ef24c1654eb98fc82fc8c148fc6243c59fdcfe0f5959fa461514c66f57d7d7e881aa7ca54dbaaf45deaf61e898622a5a678277c4d6da92f4fd8b527403247370fb91bb23de813dd4d833f6f57d29b6048959a4a97f8f8252783e34ebcb09418182b6d8f4a3982a84a34adfb6c1f124b0292a95d294dcb16db3cf351c5e65d9ecaf8b692b6146f6fce825fde969e0d679034191d1c25bbbb3acf15eddb2096eb59f31005d5551eb465a6271bfd3195850dd0719b63280cdc1e86bb1165a76bcebc7a6d558ea4b74bb4f4ed1071c253128a745c6dc68511fb6661af34aa24fb04752fe5697b6704c1fe9cf63fd63a92e2d7864ba387c02cfa19af510f3cdb2542e87d1a6accc48819ebbd07284422d6e317c3861cef867b619d2421bf740cf34b2bd9a496c2bb573103f5dcb8143790e404d11051b01705b44e981972765b896a8140d20745e7012fcca0306453ed7a0bb8ba1729b52b789d3cacb3cf00418611af808abd763f6b819931bbc37ae121cf29aca1b071e8d22039cd0ae9a924fbb11819872e1a4b385477d151fd12338f0f6064050d3c5f03f02226e1c4617f15063f8a30f368115543f69453237a6dd90e064c27b6ee0979e1573fe57a96aacca7e92e56a3addbb0d3f44f3b0774e3dce8662a5b75689c9c58ea997716affaf97aa7dfca51aee39ffcc077583cedb20b5904e05140dcb4b21f8de62e2e95e5bda24ad0ade4c483a87f74556d81efd71404dfa56102b7514ab1b05dbb95bf9a2e1a6f7fcc5da0d146a8b67eed4d29fc228bc5af3240669315bb82b60e922b6bdb87a5151aff315fd47d90717e221b8f2052422793dad0ddfac991a99805a76a0880213a6b2ddef0ae17adfcb1533157001a55d2f8b6f92a37eed5aed37463b49706cb055ec76da9c6a503c476c87390944b905861d1004d4952abdddebad3fd68bd13789271f885adff38682eafa381687c13849435c5ba36f50be12230a70799ca717d283f4c0f4ed8cb4ec13907d8a0468a6e62856bd70c976ac1768ee627bea702691cd25d3e5c347e8ac9330e586a4ce08f0f447ff03c110439ee679256facba0d61a192d3e01fa672a915f5d85cb453554407d45646002f2a302170237ec3468727d54f5c45fa62fd0436d7b9a0d75d43446f015cecd9470a21d76b662b2fe09462b129188b37b6ecdabc4c409becb91e37dbd787b87c7c7734b4cbf092c3939fc2c9dc3fce1a186631c31c27c11c011a4f86a4eed22c1af0e2d6c98cf295aafb68abdde1da6979ca70a6583597d6965ee548425bd984ef76ac38bf419c37b0f8c7e30236e72490c5116cc404dbb1c434f82cc1cb8e58167293f90501373dd6b60ad20e2f597dfccf799a51424142704cb694a2725f731afbc42269556f3b00ad79ad2d2092d2155c36c412e160a76eb5b94c3aebc4c1add08566be0ac0ec950c72923dd1f2e5987d0f96c2b9c103f97c210c989dec9489d51b5d8794316f915956a1d689b28c69208192815a78063c686f99565c945189067709c44dae0fc07a93918dac039472923cb7d8e47f3c2c17249a41eb46f568c2b68030148fbce755a38b7af5ab8d893a58cc1cbb5a4f3ef57b92da7ec0b0adae869d41758e5d015261bc061956526b3e4cb887ce390ccde6d14b50da27513099f165faf8f110e04d2548928b4569c1328cf22f8ba20da2b6a65490d9239a944f77604815e65de1e9e56f3ecfe303d8d27918638e777617d12ab129b1d48ab85b79aae282beeca3d7d15a3b7f2bb266118c1a302111499e4d439e8b0b8d6494ca3da0767c3da11300635046a33db5027d6b19d693c4b73d9345d07980521d3b020ecaba2fd636cb86f3dcf4cef58e76a1f513d4eab3581a19115fd93aa6ca7d64ce7057fe2fad41c088aed13b612994ae2c7e588fd89aaaa128102b2bd1b008bf83610df08d99f5d5f5a64e9bcdc2fa6698198957da79d57560a2e344ee3e158cf8c2142b751d5a1075bb38c98b99cd3428807f19570707ea3d4815060d29308875cb22153b4dd5fac3636ffc8f36cde229a66587bfbe0b9f21265ea77c23ad7332e31614d4c73e010abf58e6f8274afafde6db98a74f74e98a628942c4c966d94a523c91b002dbfa4bbc47f579468f43e26b585f889147b3a05015bc56263cb72f37339f6a19327f14c7bfcadecee2093f3adfa924dad32ecce071fe0a2b36a9ebd8e78bc18bccc5f86051e56336f29db5633affe6ab225fbfe88aceac04aa97f0d825b4c1af81f2b3b9e62006b578d778ab455bfc58eafcd7645f5797bae395d2f9d98cbc7d4242396d2fcb648d0037de826066a64160217701a1c8dd85e1db624bcd2133e4339fd9d89b8684e5c5e1267099b210027eecb461c06d0deeb1adb5d6281570dd7a1e15327c2495610e5ab7fc55df95ad1d5d3e69ef46250464080d2d9b393c20c5bebefa26dfecbaa19b757f7614ecaa100c1ed449c5c4a58652390222b3dc121de55c0207907f364a8b02c9af7faf70505e6233080d42b61d4122186bbc1cf0bf049eef05fdaedfb9168badcd58cd686a5eeab9c3f343c9148d03420eb5e50143ca60f536c8506ee931c6a4e94ff9299491ae9c66e4b6444e2df24a9388aa935725d7e467f629d5e3773d06e8f1b5e0e69f098b9a576b17be0794d93d187ee482bf6efe1a548c66611e790b9e1a965df89291b4320d576f93aa0584bdc0553d137ffdab277d84415805c7eb84e0f6ee06565fb0a989254bc6a4b9d63888a1ee2b67c81b44ed707071b72291e4a9bf2bf5594a0a3997b54350bac8fa49932bebc8983d4ab8f5a061e637d7d1a195e91a66c04caa2d2e3b058c66ec258745129e29b8386559db026fbdc68b3232804e50a777cba3adfc4e348696a5741f500f46c0d482a3113bf2cce9581a7d8f4d446437862b39b904449732600bce58a5b3e5bf6bdd5efd159be4c3fffda4b862afcbedc2b44c1bb50b7b8788e9596ddecefb46d275e8b5dfae689b307abb844161be04e3d160311127bdf4f62017094dfc85a57cc722af27e25f4a6fb01bb5308b6012eca3f575165ba87f19f22fdf78fa89c0e1517d6fe8bdedfa5a1ff6f5df642262f5ec179e6c68dda7c0f6dbb5695ca44ba6d1b88d50d2525d25d26bceec3c2e9ece145319650f69856fa3362f5e1a2451068ea72cc375c0069f382d2f87fe3084a12755bcba1bf03d7d24919bae17c0b607e29433b83878881069176c7c192a4aa58a04a505debcf452553586ee276f38d16f519d8afea3435bc7513237e4876cfc4baf42b2ecd4790d11211efb4051d181d09207e9fee57dbf13ecd9a0bcd325ed8f96e852ab0cdbe9016a071c8ee38b81a3949b05a430f96062e256078b560ac0581d429b413e4ef883eb2a7ed85553fcdd4caecdb85e7269cf3b9361ef68ac1acdf77671b81ce8fde38e944988e88cdec77f70fe5175f5d78e142a732bc958661bf6ce590aa4169b968fabb18742d5649234ed66c98ad18a4a037d44176325271ececa3bac8b502a77bf7b8b1c119fbb62c81d726a1534b2e3739d5966dfd6c7d0cd29fec8c93dc4ea907e2adc8f2928250a413af3264fdd0b47fa1d0021bebcd5522c69871da82c7413015c1468852988858b89648d31bf86e574428062006691b613fd640a7b432ed84fe760416aed16a590227372e415e1ec571da83c1268822c3d4f82354c2d2f84572eebe3309ffecc9c069ed1d31f63cc604291e51a69ef50fd3b5f94250a97612908c695cdb8e79c886105cf469073ba032f683dfee070a12d8fb8a13a769c4dbf2b92b225e2cdf32e25660567b3f3212664c4a8aebf87211d3e4390c7618c77922981394dd60978d175864cc712cbeda2839a825e25d2acb944878782cb6dc2de551541ba2187882fc199c39077a6799fe5eec4e39be9646aaa81faadc29144f2b7275606426be2112d95c1704187e6725512c3bd8ea6d7f5e67a2e60fc94cc9ea796bf3f8fb40515e4e397bb20edd128a6c2375d6bdf37883bfcf1fd6ef2b24f0bbf8b7d07cbbaccae301b313ecbfa7c880bcc270dca112d3139221203b042ba6e8b1d6dac58e2cd71b3329d08c87342f38cfc4c3c9e1402053415842dfb1c27d070045dea56db8646c9cb9a234aa0cfb5c6e5f0c4497fa76e844bd65648be968db6e5bf5b874fd0cb5e52da46758cfaa4135c5b8e6fc9dc5b0485c66e048e3d74fcdd65466aee97cababe8b88723365aedd7153b710879c7355ca4b03157ba0f431eeff7dfe6612af1f7a88c4bc5d590b7485a102529678d44e8475101d57bc14ddb5984e5fd2bf142e751d03795b881d91e3647171747bf2581625f4e0272f6799e7f657a2d2cc721a65aa55c5a3c3699596e07732f4ff3eb0fd3289ce24992b9931a73480238997c210572c281761a864efa01191cbbb97591878aaaf6902a005076d7f0c38f64ad77a8654a4c3a9cbe663739eb93af6566dbc23d4ed352532e4c5f4745a2dfdc82f8f22dabe0eaa34c309136beea03a000bd5b4d3fe9179d757c1978b3552e1b5b50e27cded926ef2702512441e9214ce8e7537ffe8516e7987e0cdf2b0945b5df982607c0374dbdd395b08b0f769ca3223f597b4d637767b103634b0accb3f8a6d22db290d2eebd5b4c925fdb77834335a4591e8c3573a217401c8a43464b21125f1a28585454c1d47c735a1d50fe1e8dcbcb065741593da6377719fe758a1ce5d3b3e2c5b6aabda8654095446c05f6f323b89f63ed58027897c1c6a5cae4d001904ce60d47cdf78de0851b939b570b9d212feec3a2ddaed699d40d704c4d56750e84611c016c62e02df02bba23d0e95430eeeca92e462e54f39dcd3a81072f763f0db0a2c50c9bfa37b00c3ff565448424243cc9a1c61085107f7a1ddb171c734eb68f01b10ae10f9dbb76044144cb3d9a0e60cfd33a8057db360a2156761576825aa8d72a8ddc70c52d37ed8376c298daaaabd72dcf29f9fd832e72e07f5bf06116554230e484c68d04ab4ef61668f9529f0213d904e0286c73d31173b4ec3b07b6d4e7d71f626402f7dc0ec413b9366a7d86d4b7928ef808176bacd8ecb8aa9f04943e2b3965c5e3f19451bf7c935939a404365d3932940e531761c0c7e23570d67d876203a111484d113102b3633e0ab3abac7fac0e5523e521f14099ad5ccff3ac96927f8423492cc26fb52997f95523ce749bbac6519c7a02af02b2f9d64b16410569feb4075f3d4eb0d4cef98f64f86970799ad37628eba8b0f2896f3a53ea27cc49e334a8811ec52a1df16b3259404fd5982013d668c1c8d5176dced18b82801599cff874219e9e8ec0994d9cbe6f0450c5cd7e963735516cae8f80dccf7e905cb0e53fec68f3caf9f09036bf601cd15c2074081faae3370c25c2480a4015163dd846b941919ec628715e9a220f5db73383d0ce0cf45bb37a2392835cb0f635b5e401933dbf96250c74c18b9168a19c7f57fd92a4e10106598c7aa384070a3b341208ef004bea299fd6f37e230c29ae99078432e585a5f6362d84cdf18f166c5dd844a8d9d914f78aee38315876f6820c8084dbda4ca23400bc256979ab23467ee7006da8e491af138a392aeea3aeed42f31538a9be3344a8a87409754765aeafbed012eddb4781ab45ddf42251bd7ec4aee84a352b2f2f6fb16c40fb498c514cd690544715afd62067b0688ef6099a7513c317bf45b9db19562a0bf27988d95f2569e704ca0a0093003a0b969d6f4cc425ee8fd1a6d4cdc3ade3f56c0776ce4e8e22e80962bbf88f0a3348799ddb6ac29cf61b86dd0e8d14bb6d6ceedad3014a6bf92b15df359ab31c94cc5f8de3093ec16a07c16bb790083d99f165f77624751c146a6c948585c697178ce27e62f16e643106caafc16da9ae8fd2c35ce81f94f486c5554756ba3c12d14da7bbc39eb67449e67e719ab10c2da64a168e1f183ec6786fff98d9a2d0ad15ed73cf856645bde3959b3259b90ffb9557996762c7b1b1001b6d06c4137fbc7a8789fa0ceda10f24762682617d60685a9ad81c8dfdffa4d2931e0e5580d13ec20e731fee67c89cff72145d63f063f1559585d85fceae18f471b1160006b7179e91695d63af13fa2bf647aa47d6579b458033261328a1bdfa2d077c21d103a966d9863bc4d0b6173a67e1544ac3cdb5ea52704aaa218cf153b9082355eb8c7f42e68df69c27534b22ab41e6137048a77e38927c27b2009f5a8880edb62789cf965983cea8975f61b292ab059b7ed7b1dab3ce5cf00fe78cf33bee83d48d367893f7f2261a57caf1610a342145af39db06e74ba4f7b6b83941c624cdde1928f5189359a865262a5afa4c88690edb47964003cf62956e2fd3f2c5cd06781d9e38ca045b4a2fba9c76d3f7e4365bcc153f243277e03fbc5ba2154ae80a219a1c1b1375c450a41da1804f3bbc1ceb60ee5938b0126ae5ce312cb473e7abea49a9d3cdf5d626ef039762159b6059b2728b4ec8ee3a51a970b4c87d5ab21ff66ed337d22f8a2defadd628ddb24ab1a0eeade5af85314068566fc806f209a7dec00efaa4030c4e35b24c06a24c722f2132f8b7814510648a1d451e59b80676f4b3448455b88fa40d16b5e19ac76b5cddf9e837d6ab50e244d75ea29c9db777d5274de5e8ada65bbcacdf5b9a849dddf6e019aa93bff77ea992ed263b0a9fa74074c9b06703c928cfeb9a6d86bc63a598b529d1368343f04ed0e0453624ea7bdf4b533a0de38efe1cfc020e809a0875818d2f2b7a448e3c581cb3c30d279cfe72918f9993fb17cd46bc84b7364f370f768fdf977a101111a4381976990c2bf37d1524df756713967bee7700978afef095527a47a2a6619758392e2e6ab76750924cd4f97c03da79935cabf59be6c709c61d81a8b2b61c88351435401685381d45a421bfbe01ccff263904d3f5ada52b773c7bdcc02f78664e5306158196a6e7a9db7a54582607a7dd59bc51e55745cfe554f8c9f4ae1555f0c7fd7e03530c0ec1478604e8d6cc6caf981e628e794eb5002e8ddd5cfa8b77d5b5456495bf432c301f562e675ea71aa4f5bad996d15cd912b64112ed1ffd195e46994e592382dbef00607a09ca436f497e3059daf8a89dfdb52ff720f4698fd42e2e9c06d3e727bee7b724f2913659dca782a68b523c588522c141af6eb7268d26c25d8ae3576503fee890bbfba06de579c311b207d1907805224755c37eecf89bb3f67e7679a83e191a42060a69fc4ba0336aac597142f1ade6a37db198f694e2f8709449be2624e631ff69d9680dfccf947cb71fd95e6374a29acb95912f6f3852967a4f0c79e479c538270cb0ab1d9bd7a15ebd4a03e85eeec3dcc070da2996b52561b9e6a203e42a17ca89866b082f1076bde10ad7d6fd6b38543cce6c61e8ccaa15c9b5e806d7e7d932c58860c74fa19ec828a3b1cbf422cab9fdeadda3d42d50b56e716847cf79a56ab7576b537a8a4b9345e91065f500cb2d220f2eca00d2d17e11c19d3d3411f43a0ff3edafcce5d04521649468f2d7eee1a4c0c06347e984c6b6b8d0c8dafd82c9ba48e0bda20d1b3e07d2d1feebf8a8cc31efd141e47d2f932276628c4f335f7ea72c18f7f692b2e62a1e09b800a2ca04b45d42035b426f97449f6d7d60eebde01c1c56b90a597bc12e6101fe3b981e976b63dfa93cc168cd48ab6a46cbfec11f6b239df4ee1fcef05fff02df688093babd78134990d60f8de70c986860e4cce99c94a636a243db8b334ca6e38e1d66735936b7e370433e096469738ab9ffeeebef21857f1ae3f5282ed33580680b66d0495b22a7c86331d9ce83f769d5adf0f563e8ea9239ef7f58ddabfc9e534b35d3c4b167f30570788acf8c9bad6dcab5e0e1733b4133409f0cd488ff16d6434ec238850f88c30e39b1d6f8cc626c19cd80324c54dfa21c41b6a932b720eeedf6fb0ea2459132fa692168463962d8c09732e43d96226cb5584e1ddfdb3ea7c4c9ac0a553aed83b3da94a480b0d8855ac9785d94b08de7ae11e8e8f74ed2fea5cae86fb6b848795ed9c71c4edd86ecef4d30e294dd081657abee8ef23958c531a567d06bda11c202bde51366bcf3a67791f7d8ab6721e4c31a6996618597d9e4d068a58f37643ae221c357b1af86f09d9177e36814cf5836f31da0cb517de650216e36fb2533b1f29b9c687a9a000ec4cd66cdeda42565e8e6d1de233904dcdf5d95f8e9b4838b6e0f99b24336384caa706e194d3bd111004190207ad257b61bae9c00f3e3d25a4f4bfa6c06fe069295baf7f4846cc321e8975f808af0599617cce0ae6f07b4a9b032a84bddcab78a1ac2e823c03d459a09cf9c5d388cebc18110ef949e18162fe75c7b9954f91ed86d2c6cccc44e1abea4d27c64ed4eab997489def93a773854abd69eeb0b29f9a71499164691856a2468eef3521aba46f746a854ee7f997bc9b71cb77d57ebd5269776a17c38dee80c047f9d24ee13f39acd4371e4e1bb16c6d9e2a2767e81f458f83a2aa46dc28df64ba4f15c78663dc42757398a88db3d327fbc76973956eb1ed8d82c8dfdf032b9a06d9d1b99997b7c7dcec9df1ccadc6ba6054f7ee43bbf2a19039cc949af977f4fe87da2bd7479cc40609700b60676d46079e617855e3f0a05b273eb220731dffc9122513d2351529f18996e31b38e8aa95c99b055427dc2769ae83c1e5ce32b171bf7e22ccf4164d093283e98d7c00bcb3642bc0874b45569b9cffb2b76d61527be95996e139bae197bfccff86f0811621b9d3dbff2e751882930b32046eb739affc39cc765bf5d63777c7c4b135f5699c8e719cadaa61e8a4d2f19db9bbb0bab5d48c9fac587590e00aa8567a321729f73ece6a73b22c55a8aae84e25ea6f70c94cda6fe1b4182ccbdbd83913194e75dee9de1eb7234364492c758e9431c7f0951642a85a5dcd52ecf4a2cf5f9e4037f29775bd10e9ab6fa0eb698f459436cc4cd9a2f58c280c68f374cba3a160fdf46a1d0a68c207b64b3a36ea8754e1b4bedf801bc1d0a9ce2d1236e690aa033ba057ade0397f23a97a3ac040d78be9ec8405815ac6f33f7cc060fec493932fcd7c79cbaf5be200462d081cfd7bd3ab949b9f80018c5b56182ca5dffc3ee7c3632ceb5777e3d19aa6a097e277309dfdf336fdc22fbb1250ecef1af0dcd906f3a61809c9df91f3d27f583621a56dc607e5e00c0cb26a8f0ccc686d10200c7d4a3841d16887ac53a093c42b6d172d3a8f4b4f0b0516f7e2e5c371e12b6e2e80e0820f82000be72bfb0ea3db8ac65061bb16064db7b71f45035f4a6ecab77f56fa247592e90fb9c23b79069aa25528b2d9e085d8314e09baba5656f6621a999c5e426bb519d0896915205c9729623236de6fa6e591c7be257908c192deee5f21ebb63d327f4d599df3281cfc62aa4a3719d77a2b12106d76be1303073e2c2e0afcd37ee4dfd627ef7d2a3290618fe18a12c14aab889385e9696c5fd6fea9dac4ca60cab9cb361d8b3b17631cdfd84e61a3b76f5866b061a3e275927554ebcffa39760edf6d5308b5df7625d408585b6db5116dd94bc29dc6b8b2368f3c47b6a678701c74803de058ad7bb1966219caad535874aba66229d407112bc2c1c0d05c17ceb9c0496c9a6a4aaff2909688e5d37b75f989914bfa911d717813ae0f0048c53523e422e5c4e7daa6b32608b44b7e3145a9924b67f4a4fc26f3c3b664f45126eaf4efc11fb2121fda3eb3d0633e706705a2726b2d4010b3ef75d5455417526097bc6d42f110f6114f981b367abe66f9c677de2a1c4a9ee4fb2ab9a3e3f5c8b08edd563d77f3c83f8020d47f3df5db0e4b7d8d4f686f125b715c4c749d27e575a6a6a9b9b0f844c8d3e8edd371599bbb954cbdf2ffa1bbe4f3b93c2ed41998d3405599c820f516f35535af149479ab71f7f3b3f8f6a6b7de03c67bdd7498c6da09c379e3dea2bc496e199b57200fd943334c1ca0828cf244eec06460c42b796969cc31bd1e2da94ba6bacf58d48ae16e04a665a9f0462cb177d1cfafb1a8db298deb82a36c2406a76697931bee69c9e20a71244f4c3638d75ef6257235daf06c6334c2edd4c12ecaa63fbd2c9e67cfe0ef02f8da3b5b880baf4f3df662a275ecde448deca8916c35bef4b6e931ed58fb55dc848d8d560ac0e6cfeda09ce509aa14110e61cd265eb5fb296e5ae1e5b0eca8e13588154827255c31b30920f559ea1dcba52d5702742460b5e1852c5b729aedec4dc11f3b8c447720901b5c841b0d22e9a267bddb51563a3ad3bb1f31d209cedff05f2dd3c9c58704190a7d7618dddb775c283845c08e95e258080e8f55e025035681ea56617b05ce25511ab08f5e92ea1a8becdb8c19a3c013e71a8a9ec8e11b75b74458ad8762ce1f5efc1b579255d7f91f130856a1e36fccb148ae62e0f4a5e6acef17f9c44f9ee7c037b6d310954543ec2a8adfef080eb4ab92be14d56c0ca0c3d77c29ab27c200fa52f5f6bbb36759ce9e9b8346c5dab7c61588974649b67d5493ae1bd488bbdba31d57bf0df14581d5e705d947791eb22a62884bcad970d1ece7be63a165c85ed8a15faca5412d3432a134555db40cdab2bed851a143af75f6649801e9d13eb0b0cb76a63c02563e45d6205906cb38961f65face1d7116b6ee01b70af653ca1022e7000153acdc9785172195c83464f493748460291ea7a408ab9edc697deeb71aced5607cdab8949c81d1989ecbb9bb988e2f0008b0ea3e564b98a222192d1ff91e770873541f5e33e11e249c7face31ad94c3e3f297c733c98ceaac4f9fbe6c3aa0d473de92c363a835b94b9fb983da36930fe1e93bfb7775c8c4c0d514a07990f6211e61a97abfd193d5b2148c6a834a76160034f2b0cb0a599310b07d2401b12285af798aca689f6e834412b84e9739821dda383c4baeaecaf51daace1aa03b7071b6b33ccc4e8f8174cb941f0ce01c6397ce8277825a9a75918d1348813f0dfeeb4a48e5d5370dbacd0cbb9ac13f94ce4e5ea87beba552d085a670fb9de7aa92c23c3e50a50f4177306c0a0c0193b178155743bfa811b2f6b258f32e435f5e4d3acd83980b22bd945f4d126d42be7c0e6749c303c412dab5a88701898689afd49d530cc1fd6298ba27222cae02f78de0cbf579759e9af71e7d4110a41a1391cde7618b8bc57a829d757f2978c8ac636062cddda3aa11d2ed951e17b1f8beef2a0d17bd192db05f0a8a70bd7b18767f9149c32e816a8fb6ec64472af80a99e0efb0112b1c9899b96741114d9adb1a72fbd7d44f986152f153802a8883ce4379395df6f3e159a94d005cf466ac43d600ae24f8781864367659221add5e4b1a5100601bd56a2eb0677a16b519717559cdb392c8dc35a871f197d02b035ed213ee6201651dbba0d7c750437ee2cdfa21967841594084bfd33593036d9c5f48ed60044c09414be7ecb9e988aa4bd4e518153f7324569cf8c6789bc6d476c4fc6abbc7c90b216f82807f6b296133d580d39e4af2b4fc10f500287a6fd106734b29fb7fdb3dd2961370602f7bad738386c5acc369b62caf9ce741460b338eee008dda393825316fe26480f770f374160189a2852a438b581467127ca2898a6cb0918211b84756ec34a9813e14a0fdeecbfeff8e361573b216454f9dfdefb8bc56d72a7ea892e8d87951ff20e0e57473c1f45f0dede5ab2307775a1585ac6f88f1feb0f06ba650544fb554d5948774887324a837126f0b9e92a1d4977b6d0350fb8161e2e5aa4bbdff99704dc73604d274f2a389f5ec6cd3bdfeca42abf4ea4aac415a475a561f053ca633510c4d249692be32ca169775a201136867313525fc83877cb15e645b93009e1d21c58deba68aa65653d3eebab9ec6eed49c9d1021e02b3b410da79de826260e494034e00cd3117c4eea5114cecb0d7f5c3d269d6dc95944a9b0540fa6b283217b25e9539988bb621b7415809cb83d472e333d32e7217d3a1d18cf34d5b2dc42c375a0211bc2424e22f82c73474879985753c51b83e47edd1cf25cc75b318df00816567e89fc1aa3aa99374237362c129d0e9349cb235350e46ebac65219b369a69cadb11679255afb6e7a93e21b7869a85b778d389d4a0e4a619831dc337636a92cde6713110d5d50831d564b12b1a8c0951599698a0a3ad447bfcd3ec93d34ae39e4f42358d42be84a64fbc4210ef504dd4b6ab52ad48c6763709bfd39f1cc0bdf81387f315d1bafa3f822d5eff0874e533d19ca44ad1b6e9f593120a14875f6e021fc91df56cfb298fce1670d70e657bad6f91fc06c70bbf4efe531a1b22e125487c97a07ee47382bdce1f3a04fa435e5bd22c369f6e6975a9b73b5c8f6c5a7b96cfe9a1fb14afd91fca9adb949cc73d6164f60b5f37eea06e8d75ed6cf5ceaa0c94a0ecaa04df2f9198d5a2f1e65591357e38d545fc823a452ce9b5ea367f0b63ed8b1c03d436e2bcc218913969d4cb334f6a73ca9b6b8ed278d7c8600afeec495aa56ce940b67719ff887dd5ede48ad3deddf99463ff1836d92c8f94faaf9d5b7b6a4bdad04b849443d1c43ea540579c00a22c028570625c430ab6a5f0bc19e4ce051a39d9342b3dd7b56b19d922950b06098fb2b3ff450e6cc06643a2e58e756992ff107736c34681541aa1c154b5abd15a0c429d51f610979bf8dcea3829622367bcb658f001b2f6c90f07c0eb6d18a8b9e21b05684bde8736a10e05176a96bf9b46ec9764d4b7c84c58fdb8ce1d4c552ffd62327aa7bd98383752c499c4943bf76f3daf979f369f97075b7deb0b7da1fe82f2ce976ec2979130fef09dc7c40c9d5bd9421b5a86d0ea8a04cf04a637a664ad47a34d7bf8a6d116abd1bbdc8bb9308a02bb0c7ad9668f6d4b0c323b4f926f141a3f1099bed240641f54a6365607fc870c9e2196befacc1a3f55c5f141581dd7b2a2177bfc98d69cc1ae0aaabf3b7bdc323b558608cc54242c7f58df72ab891ce59ed0727e471cb489377f91ea44a5046b999b1398a7ab2ebfa56c76358bbea44fbccad8495fbed96f42f661b2944d99ff1d602c31427372e07af5c5f5169b3a2c7192f1a75a92030d338d35024dfaabc145ae00dc2215d42f7390b150ea852389fb62d64135f48568cedf37fa341a3d592d7acc4d8b3123651390ab794918aa10bff990ce8a98bf4db318ae4d57c86040e0e57e6d60cfd128d34e18d7400287cb1c6c5f2e92f157ac376ccfa1e67246a113104519542fe6ee2d8732ea0316ad0614bcf55d09b2b7add112ff33597c08f14f273b507fd8b8949c8a8f37767fff74086d1bd9338ae5b0f72220fbb113730cb32d4767be800d4f0513d0efdd7f66ebd9ad016ef84729964ceafc6a6f44b7185e2b0b12ffb451c1952c934628c715d8632ad3dc58ac8f9f979847118f934e72c7143ec725151d7f5f941a4e8386c1035707b4ea3f4e8de2d06910fb2514f710357afcaa4e00ed7a2af7b7f0b5013a561586519a7dd4f7bf96d48472a40e1a86bd9f99cb66f2b417b2e484f2c5cc226d895fb820101b790857e80a6b09713b0c12a62e6b6a842ea3633e159296fdebc5ea5e84f2b15b5109cf6ca9a06aa6ca3de956f9a82e8909c951cbdb1cd49badc8898ca8cb7e465c7f0ff5e56d498840bd4341e6a22c054c91485537488306f44fc37627e7f746bbc539fd97fef6c5f69aa2213d0b2f9f8b0db510c8c2413a756a46bb046a86f7c56de1941e6ceddad209a4539fa32bd4ef725f0b63a651713b41492c961b272358575982a1d3a7c93e38b0a9007e6f32e1bd5cdea0dbc52a35c3c56dec8524b25a93626cf38a3f99f640fb51d89a5532a66c8d0201bacb1ebdb17fb5fa016b37ab9e9200352dca78b29d8b434477c4505de4cca76b1c17cd3bf2e2d14fd55eb9d2e23bc1c36570d7e799888e74cd90ff9c7ed3892da0a2c6593aa881f1b7570760b3c2e6d42873834cb2c7f2c4f5bfc43710fae53c114e02a2c90f273ab7186ba59acfc2253e55677bbdd94686a1f64a994535f64a95d8034499153fd7f68cc1fe7c48652406d82201b8471a73070dc4146be25ff4f186867d2030e9756f866505f1e7aedffe2db0ff267f39ecef0c336b658f4c3dae3f7c06227d32f101143612c8c2ecbef086e4fa63dc2fa0c57ca8adaacd16f9c55cd39c0f046578d14f03bb939bda5a1661b92e2a280c2ca9459a573e48571191d748711db206aa91f56c39f2af7b681393e9ce8d33335f2249d471506903085d02f98b94a7df4de68b3ded89ed2ad3c3e34e10f3269f3ff369c813526f7634d348a752cd5b6bd249f6a144bb08700c8035c4eee529f87c633579278ac9554f0f3e457ac6ad1351c0fca7b8b845f1fd6798d99188c7d5c59b9fd97be0af0e2dd97d0f09428957bfb9db001b1a2e724f415faa2f054aa15bbfd8526678391a50bab8959d2506da4b3bf5c9702abcccb985d4a8e815401a5fbdaf52328eb83ab0787cf718383e149b8ec20c390673c3151e1f98c443b859e3d1170ab829ed5d18b69d3a100da9a17400a145b0faa9984ef0385d171e27ea83c249e46b03878f979f1dd12d21627d06d81441059f1698c0ca32da5f2870c991250b5c618567e227a8c49a6c89d01190a6a486324ef19790debf3d41ef62401de9207a0881623f684a3bf57a83d081349d1b7f58ea92c0fb87b21894058ba9588fffcb7b3e274307cd4651220e52fafa050566cfd3924bfcf8d1bd81ccb13f22ba8105c8a909b19745756eb4008aa1b4f8df47623970e0866913012cf3791c53b31a3df8d1db0e2ef876ea772cfeb47dc8d19eb189547a7a846c1dfe9c8a5647387ae4c7f8f755640fa0048aaed3502ba59c209fccf76bc2641d58315a8032be2e5e2bff58d034c5712cd6512ee6f4659cbc8195d5d0e15d66ee0688003206c6cc9b0748d45084d9b9e03bd54bb31cd4808d15ae211777e9aebfce9417259f6a0b73dde5efea0287e0d5dc4408bb095a1a864b91bfc6910bf94414f09b02f247fb81f8e3abcc790ba98fea0a63c91af46b60f111dda5e53b9e6f142611eb266150c54e67c8200f09a16a026a3aceb50e91c0738496e963ffbdf6855ee07469eac2d612845668189e216bca6ef7f250dac32bb14fe6fafb344d1a1fab1b62c86d7a4f159838d0e78668828e90bc4eabed87926d4db385619d736de1a43e999090fcc6b70193c55a4a449bb127f1a6abcbb2de3429b81cdef9a9e8fc7399d1a6db264ee74e17ecc868d419fe0d62984ca40aab4986711620026a15c23b697e6be5eab62319799f4e0f7d2b9ada60a2590db36b789ced10d67bf2ddb2fe1093f265cfa3400aa7d1b25bad2c98e20ba3c575421bf3a49b64d4fda830768d08a116c28ba34cfd2f3e5be87d72dbc7ed137f391b6fad98b30b2a62d72764c7c9f0238834c9bdae8b71f91a6b422ea05a696bd1b51cdec6560fe25f655dfd28018f16f34c08b17cec78361340dbe459d1fbe5a45b835faa84584503d8c685fb7e610d9ae38e7535a8d2601d7b790e82e9545f03d91a60bb04b5269a13aa9abbe875e7750361bb3da68f49a07105b356c4bfd7663011904e0368e298785ddf781d2d42a3657e7ad56cea7fdbb1bf677a4025acb858b9f9f40d2bd90682384bded9e53cd473ab1915e705bb1fe4948348ce01762eee10b644a7cbb2b39778f2bef50724426e96534c66b35ad4159d04969b45acafd226a1f0074505c470fa7224ff73897963a8f84021f133b446bf6696091fb9736d8f62cda627a97dd38e3e619a9b76f9b2c9c351d5482d615f9eff1b3fee4bda8846c6dc0f389e62893f62f5990ff8d4585757d5c32ac3f6bae985a6ea4e5ef3f47c38d5785c1848544cff760744f700a03f7553b6b9d8d1174c2448b5f8348e1796866234aa52efcb1bf5ce9a2aa40cf3c7bcca0a4d36e0a445c69650877c9b6de59de580533be0f2af5422151951ef4eb8b0d108d88e64223e3ac03cfc154d2168ebc978945bc6aea8995149c8c057155c5b956c18ef32d78d86fe93feff987f47c6c194881e88a61005683eff52743d52c76c151ad188ae818ab005decea621692f8d518921f0524297f5003f0ffb5f247cbef3d5737467c0f8aa027c53ae0b3eaf9d2507e52a447a479789f01ccd96d516d3a69c8b3977b9fcf0e3867706d304e3b11b964fb7686979ef8e3fe9ee3366287a27f3bad257a5c4687edfb35e37964a572fbe9462d70a1e0508be3637de8aef208abed72f1c1208d6001fc314acc69a0a149d9611098b10535a835a63e39b20e6ec92d2d2e719d960f3958aea52cfa25122a8a936f4f716e93738e22d6ae44219743574bd81f32d6c64d55e59ccfccddacf96ae702c93390a97a00fe4b74581708647b87b84db4a3e240b9a5adb8c32a3763b220672e6b1b68c0616f95d3fe3a5916a5870f4e6bee495d4f0f20bc273c9d4d20084aa0f7c43c91a023ba9b427bf24c0f590064936cf1e319e58db491e55decf85c89e16e07aca53816cf4325f097c30cc239ea91271a766af60e6b7621e6e929fd1992acfc92a1a9c1efed37a3cd4fdf152fbbcedae8d4a00c6435e9fbb945ecc5aa2401c987e6bcb6425b1f943414073bc48a5b0f1789964f91d1ceb8691e91cf9b518816dba311b09e798de12517bd304b2ed7ccd91781ac11675c6dfdb28cd32477fe1c9d46e736e6dfe4955136d79853d32a2e070bdf6a60161f79ceadb1b34ac6982b1b924c0828bf4a3b2e0600397834b10ba21839f6a99750065448794e62752852d2354d7d4ec82f41553247583468f655a0e5bcc65aa239aa88c9b457a97d94173e91d3ccbc36a61a25a4f4d96175b5690f6a7099370a7cea238b4939d0effca10e5c2a4d3c56b3790d89b21ce2bcf825d53fcb1f708a386945ad42417b0ac9b9898bc6e48de6cf07061765016a8004ff145da0cd8349be3a4a5ad66d68d1086115e1d55aadc52018a87911ca3b2f616a257cfc62ea2f04f568127d7136c54c98925b013f02670b7d4970cb1aa8b98dda545b0e75aa3779816be0b0598ed1c648a12108900e7d25ba199d0340235c530557a205331048c3681434533b42dee43992e0e91724d28bbb7717d0a95e7d656398f290372c323a63adeaf8ad5eb4940be03eedd3502462a97e2ba7146263c892667372cd7ca502342e1fcf7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
