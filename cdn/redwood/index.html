<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0da65b49cb85d24f1b0b1ae1bcc6f1610a57e4523ec143bfaeadeeca4a8495288ef620d886784e20186099ae1bcb8bfe4d3bb8f3496e11b7ec80a8302a78356229e7c4409eb1cdc4e930e1c1c51ad4bce06ce8e9dacc61b4575d9c0e17e451a5c3deb406cc6e2d15d9afe648f1dca9b881114be4add3393dff0f647166d1387542302451c680a1ea82124291798a7f90fd9f0e45442f69c6edb8809051e9cd5755faf409c1139fd4f4577424e231cd497abd8d19f5deaff16375034bff62636b2efd38c4b055a4e9c0cf0191efb30cd87c69f28db9e34ad2b78733dfdc0e7405fd034606997f413b8b926bf405b8655663aa4463a4b228491627b1de0512eafe695b739c3dfb8c2bbcbec98b519adbb1135fb5aa4f0ef7629eb4b1162466b7659b8d3e18ef3c7f6cd52ae195cfa14f0df1a0f7010f62bc4c2855b2a77dfb8530ad2a693fb93d24e13b57ed9a5c0c9cf68e92885c6cd7dabc52da15f058d8c120d2c8f75449e7db9885485c647bfd7d459d1360fd0b55472049302204b0c25d511901362a794918a08e330de2287444951d9e4b61fa066b382c68f4b73506b9617f124a78a9e5795ffb1079ef61ea7e0786731abc33a076e5524b1c08adfaeb1f9bff2477267929059b96109ee265dc9f750e959fb23986ff36bd71ef44b73c4e6bf47472e5c12821b8a220bdcd76f664b9c18ac322045010433aa329a6f55ff70725bad98b138be6c7e87139492b250d5ed0a17e856cdf292cf18ca38e92ef1ce24ef2c26ecd21fe08cc6d853c4816db6487b36311741379c8681e012ce0e717662851940d62b7ec3566d445cf3d45526597563dda6c635aec9b4c9e876f5b509beb901066e903b7a498e719e6f1de733abe9510ff1841091e3be4954fa1001f4c69b7bd6892e4ebd78850cb2ddb1bf31fd33b87d5616da21be899f992469c6b8bf4e673901f308e6bc09e49d38787e715c69c4b3d97d57448805df4b5540d63772f384861810e7a93099bac72ce9e1a306f0e6fbed7f3ec1070b1b9af4a91a4154c945d79aaadaa2ba21722dd403af650b61ba065aac8d8b0bcc276d628822d457debb406ce7a4ab0ea2b14587c414b18762652594cd776b3453be7788c8133f3ff8e8f625adf06f292c34f56c1886b694e4b274b9b10b201d43a9eb6bc1121b980b4c7e44a104a78eb7736ec23423b3f8fc0200316cac256799d035738c887d7fcd6715dd9014d077d96df746b198cf163ecdccadac10581274e3889853fbb5f7a45d36524949e433fa3fea9211fb9747b9c802ea7e72014482d4bfe006b8ac3d9b6631aa8818776912ff094dd1c5f624bbca32585b5b9e8bc55da76570177e8b7aea22a9a1649d8c18cdd947056bd80267c7c293b9cc8fa635077d5644bb52fc586a2770ea69ab4ce9aa33f09dcb0bd4d33e88c6fe37ea2c5227fd22c420176cbdc3a02de036e99e1c1b23439dbda4da10fe8cd4640ae89e2dd9b03f886e629cdf6ce3da4798d45c47743f737118357f5053a2d0c9d6c2d9cfef949caac906ad81a3b7ede31ccd847a607c61e314e26a313fb7bdf76109cdab21ade1d24df024caed822d772b1cfd1ed28b0e713935a9226667fe2a5c4af9e86ed070124b289106552cb91bce74134c71e0f276d81d2079f475324ef736e882510f52c1e6220e08b433f5903b4271bb25ca7f9832348b8a916fa5dd51837d6fc0bbfd1d2a220f47c3ac85772e23fa92145fe0ba2618f20e254169ae7b133ed5a558b39700b4ff4d3d6de49b68c9c908cd4ea3ab8a0cc699f662baff393b333b46b4f85c2bd39fd26941950413d701ed85d1e787848f220cf84e519e446c0074de185aa6f0ec2d1cecf83815c8fe0a3853d7bd7f4f9dca189349bbe95265344e02bcdfcea30a77fc3f1bb52ff4e2bf48485d68dd977a17a9261599e796f45888fdaa94c20b2da1e1746d239fa6699705bcff414561bda011aa192f26497597c248d42f76c4e724609ae649df565e0402cc0e4a0c3e9b3861b6fdafa7b44a6a118d7d96a5f902c24d9172b51931cda3b8ba4d7eef4165bd0303c54e279bbffaf2653b38e2f1a54141d9ed4fc5ba2390b973d0bb2be5d3110126f907b006b1f6eb390e22a321c1f1414ad41e7bae4659fdf7262419e72b72577bac76dd02c9a6e0239690937ee4973aa50cc835b0909b429e7fbc44823cbc77753fc70b4392dac1c1761b028d89268e6d5a03bee4e13c26c079b456dd4bd8db2a94c49bd8bd3abd9d2a3598a74a88b1819462e3bee70bd9170b97370ee302ccff46f6dd36116f56d1d63234c79ca5f6dcb73da9a495ebf7b4bac42184c8411a6bf62015d5891e34760fad084bc37857ed878433da87ed3be0f71ed3bd67ca0926096ac10aea74cccddaef6816ef56f2486925c75d369c13b649d2c95cac393c809d9d272868334ea4c0992f3cb81e9b2852e93f8111cbc3830e0501bb64780053c741830223b22f521f98810cec8b07e790c443087d3b289b4395a3491812584fce9ff9d1d09bffb849246c564918506395ff25a2d4b144288de241edad8c1e25ed8d34fb5564003fe63edb74d57d3a23b4d8ed1b35118c568d7cfe3906d95b672f97aa65054b198639997d1041562b452459cdeb5fc298f0c039956158ede53cedfc453db60d52203b11d10f34658c37badde594021a3a205b7e13db24e626363321c5e8fd5f9ed4fd50145a455caac647dd05a110f29291b166758443ef1e77b347ba5b446ac0a66fa48c8f72bda6443cf7ecb46986a50b4408fd4d4d2e971e043f825207826b8c9aef2bf21aa9ffb8b6379f18d4bbf12d96151fc525d66ed63e515c0c3ad3e086f42ca431cb5176065b8f417819153bbac74cac4be1ee7d2adfe2e07c9672785052df29990bda02227957f85630b428bc9ce7ab02d84826dd429cbb5dd43cebdc075fe9528069dca3e6684ded4463b460ea63b2d299c26860af63b6d8be83861c17aafdb3bd7ead8fcb13c0fc0238222db6df8fde036d93a7956d408a4a42791fd40130cda0c20d0255dd5437f76f9bee2e06fb0142e212f66f277adaa445bc69bd5ab723405e0a9935484d7d0c29044f833028443bacc4d8553a3ceb4e19c4ca73e4443f51ff8368368656458841a6e6329ff1b2e4a3ac138c64775f7abed57e21adaa083240579d082f03ab26d98869a6ece685eb69b5736c9e1b7418a6c42926a235a2fdf3114c48886249cb68bee1604b1d20510359d56518181e1c3ecb585faa829369d27464d8f4af8cb7c2e8c88621dba65fecb6519ad18c64376e5f706f6b6fad570bc33faca9373c2861ad6182eab2bfaa04029ed492ceab6d83153aa76caf8d29aa3aa2749c95b7ef9c09c4497f45cc849c4a63fb0a39d16300c27ca76f3ac6ed9c451f8c1beb251efc8ccdc9c7e63e3cac9fc917a324b43885990f1c5aadfc4002402a143b3adae776d3ebcdd7aeb10e54e4daf74faa31f058e956949a935ef4bbb34e6ed193589d6351a1b165e0f61b6239e529329bfcef497a217d7185929cf52a99f339a3986db12ec0a135005cbaa1b03b761cb793a1c4a5dadfc4b35ece999fab53f485351cc811e9bdc265fc46afca8bf4f543d6ed4f682d355e2b91af94bda0af02a5a03e6ff1eb2b1ae2ece592c14c2f1d2d6138ea1aab42f08b8b6abfc0a1f5358b414b35c5ec0066d9ec3de6d69c8abf757050662282e8c728780ee2d188ce2f9ed2c4d4d96eac9aa56d4f54d12f55a655c442c2ba618bf4012ef3614274ab54f55e2428ca8506bf6371ba317965f8884ee720909c9e159b52a9fc793ab9702010e6a50f6765d37ba7000078574dd31bfd325c0d573cd92f8e2eb798691d4fb0590387a28950b0935af3f60dd172168e56acd531e40355ed536a34d0ffd7c4dfff3b362992e2dc2e15dfb4d548a320557217d3e16616d7c275be6356ea3615532d1323e8a371964a213d23cec507b359a5a54429cb21c0411a6a3c56d455438f60d506cffb6052533431482acee48b7ec8235e5ba693e7d4a6a5807359119c1d68de6ae4e3672289d06d11b0e2b10aaef3d49a5c5cedc39ede1fdb6d9a542f8008a6cd8e38df7c7cbb08c43bb4e5e29a45c0f66cdaff06f35ea6df685880c40c08ddfdcff93e1a00249750106650a46cf54c63658fc0e10a508653349eaff68fe4b141422b9c75fe9ce661cf479ed9f3cbaac95ae7c191380927494ad6210b25c96946bffdbe4289bc7c4d8877e80ca72b054e0ebac63ae9b0f6bc7eeda28b039fbca921f036b5a409b21a178264caf8dd877d3762a72c0ad613782ea1ff7814f9049a212407fe137ca1a72b16751787247082fb2101a6f1c9bf3f8185c70f3ec8b7b0e66d79eb510162744168383a9a66daae1279f250b24337939f5cf2bb4698c769046c359ff95282c3be498db43758c1f8ddf191d03ecab2bb37fd9cb848cedaf5d817cccc20a765d4f3e99e136400a93af81a41ad334cda7a573528c30f133a0d60583ff8a2e484d475e0e380482779b4e9adb6b32a4322392ec8bd01b83933be224510bac24eba47cb8ea99dfb54618ccc6fceddf26388cc5a5cde285c5bfbc625c43532e38751d61b60049fe89168040fa4cb3d5bc9d41f40b945a1fcfecb032e0e91214662357ba64add56e685a8d7b34fb88ca8bf356a18f6b643ab1ba5d88230a5658d473ae3f96caf272707bd6a81d978f86335d4ab1f3a49a87d674592a8fd8e93c28e39636bf25176f6c7956868e7aa434155e704279c1c48976703f4e4eee5e78fc7fa3bbaf6f68c5381eec7e78f1d29add4cf810e7f2ba4d8c68fa64ac6e365a0f6d0e00a8be1b0ca5870e7b1020d92c581c9b0ffe8d493478b1780a40f52fc405c5dc33d5249edf954c42d03057bf0f4893c326cd2a0c1996eeeaa9bdc7d65feda355d783b708806ab27469016ca0100024c40eb97f3eb1d9ed312acba86584ff667f0aef4e2ed198629f7696ee0aea56c37756469796856e8bc3f3b8c401bc6a73e46b5ab3e096256b92ed68987eaee596989b8d160643e005bd850d4731e6c5230b8d14a8197faa11c67cdcc01bee85c1f2a57a9107c6cc5dfd26f9bb0a6382e6fd36e86b7557cdc26854aee58f04c9d5a331268e80946b5c30154cac7c02e73c8086446785a30cbddafb4a0c75435a0756380d22d55061ac323892212b9c74f93d2e8bf3534ddca247bd5d8e05148a150a87ce8806bf7a5d2f350b5547cfe6bccaa40c1f63a2a836e58bc81a0fcc6b1ad2f50b3b16f2fcaaf3dcdecff31890846dff179b4d5e31705a759ed0db0bd769dd00d97c9cb6a56d8890c6e227dbad3dadee2d3ea0aeb6d909384cb6ebe87a9ef83819bbe306865e58565d7bad2b298c1ca830ec5d6d30779684eb1f94e55438d0f55a751cbcdc6426bc840396301d2a827ccf798e88ee93fdb3fa10a1ab5b9d185526fe8ab5e0f5a11fbcea403e77f31786a1fb337c6a336f5cdce80d878bcaccb56844d80c22de0cca4540193e3f48399dd3f8e1025b6b499512a33a88db1a2d090223602e41a68250cfb42e23f0264db6a68ca5bd0a5bb91fbf2c692ac6cf2e56929bf5186c306027cded424558107e8e73d5a5496f3b8dca8265e90562dd3cd16296e7555e7e4173bc8888e31f02ac3301189a4cb013f1420afc75a9f35d2b6dcb1282c108ea3d781a4e8d1347884a8a11f1179dd510978d8e84fb22d906691c880d3c9cd70c3e21d61b8426788d263193b58f4c362b0dace2e8fa69c6fed2e4ca9e8b176953234f18a5240b71f6be8419e53ed7e254b71c78846b81821a4fee229584ed0b78badb9b25a77b734151048c274155e7357e03282e922b689e063ecb8093fadfaf39d2c6762a42361e6136c15c7b75ed50f77c39eea21eaa18b05088b98b52a03d5a4c8e563594d64fdc7f2bcbe0371d2fb4d1dde0c06b791051528b27805151c4817a847cdda0a38fc949f4a47d0d55f1a52f3e7abda2fe57be130b9d72898cc4d4df64bd382d5edead1a603951711e722820b4745ea95017b4da7796ea15a50e322b47feccb0a80f1a3c8b38021a74932b4d3b4089b440224ae493f4b9c2a0ebee01adf8f1ac483b878c14801f82fd644e15541f238b9e62914d8654dc15dc866d475c8d4e96f1fec70cc765e2206c8ca06d499677c19b23e6d3762049e01e6afa6987fe05cf1bc3a7708e9a82547e2a3492d0477a71d165a369d1aabd7b74ba2b40fdab4161ec3bf01ba05130e42af8fe8858b934c66935ec84b529c89c22a54f8877b29be84c206d660b5890634cf56a2dc37341aeb9aef37639c3817c70f6477b30deac2ed7558b6dae66f47a518dfcbbefcadfa75fd02d5c620393d4c0582131ca7b9f939760507ff53cb2d1cac04329fc8db9ea21e453d4b3510f13005544c5f12a6b7830a77e27773aea5c594b00485f9f226cb3ef9e815dd2f9f7775b2a6926ffd0d41844533640f0bf62d910616268c2eaa3b69c037ea82fdef425a08f64b218fe19023aedd88a5684e3d0ea2b7458c22ac042e6b19d7ae0bd6969343ce6bab9a4c6512ba981d82af722ec00a50a2dfd49ddb2b99af08131fc29a646123efbd89ffc1982c29df7603c3dc641737f1b7d2a4639133c4014ce937cea31c3d68d12759727c5fd1ff8678abf712623726dec80ddaad72edfb48dd8d43b39b41d583bc83fcf3fdad680015b28eace50a5f064605e39d4713f779dbc6e1c232574c4709ac8b43fd2b05d7bd49afb46a5263412b45524b274f1c4cb709f232cef4b1d08b97c93a23f1282b4e6264b97ecb49eef54a373b93306a2bec52b075c315110cec51a8573e4c0d4de72734aafb44aedec0932beec26270a1294985cabbce538817c9239439502e4a289df9bda792565e5544d429eca9d1f430f8f4650c71b48932a4c24eea535ecee1f4a4487c32f60ee270182c44af3ba8f8a27e3a8de23b0a820f25f3d1b38e0030b98c88e6878af521fb1c8399d393b0a229ebc13763aaf5082afd5bde248262a8508b8c56c54c699f0089adfb620cca1399cff9193dfd3cd83e22b301f7278bed13c5e67c4e7cbcf4e93473184f4bd67e29e3cf331fec4274f47b3c5884441fe6034424066795ad76779ffdd495b02dc81d7ff02a1f5dc08ad63d22dcc3b1bfa4310d367586e092f32a4da07d8d3f73a896fdbe045d8a9c92ef116a1c0819d1379c859fac0f69b67ddce6958f19342be33baa9b0e6194ac039c7663fb6f66e5319f1505f46c5b7a550ddce0a601c40ec4be4cdfb17b2d06125cb783da2e3d454b32158512066713eb0d1c544a161ea77010e5049be67e124c522d7f900e372bbb962036992dd79cec1a26c73ea7e239f6b4d947cbfca6daca7e66395e61a7685bd188a84417259ffb319f9deee59d0fdfad569df448a0cdfadfc2a68a3cc16c1a89abfa82fab3a4f063e4ce6ec2be4b776a47ec883685e9557a033ef197bb69890159f20bdf4c34b7bcdb8966b9f1f228183f52a9346bcf706e486622ee4c5b84849c9bdc9fe0f3e4b029bc79856dc3aca2cce3f81eadbe3a0b6aba5d3f3e020d958b0f4f0c1f5349d17736ff7efc900f82c641ce0ba3666c2e75b4e818b2bc6ed76cf92ea6d8cc2073a37989458cdd0e3df3f87690680a179f2e1a90d6cccf161e6dcb82037e012d3bd21f206872d00043189d6135b5ee1c82a285a449ab449399d5ab98b331e50d598002f1314490f46f628568709bca1a80af3244f970298587b60de316c8425382b511c6714f718e307a2dd34784e66720bb3b90c46aae92299f7c0377bf3f781137a20445f2483170d192c1f303d9a0413c89adb21f4f6b9f87648203fabf140583731f5e35da81c89176d45279f4d8ea7ed0ba70ebd00c0f5696684f1b6e668c01f0165561c448fff2b036360bc7954372333760d2c284877bacf21752528ef5bf355d07e4d21ae32e1a71bf18e059a1ee48bdf7e5142821baea08614ace9510370e6f1fe895148b59117e0b6d6494cb62f7ad5e5c56956247c67af7fbc6b73b8506d7ae95a7b6d1643a51a0293512fd9fa157cb0919ff324bc60b019c62896c6b1683b544db63f145789bafd7fdf1b1a6c177447dc83b8777271cb349661813363c0ae5d2eb6243b4a11675a120831eb66e89e04711df217054c846516243b88347831b680441fca810ae710c69f5fa453853253d6e041f63c71ab841d2759197cbbf47e27ee8f8ef5627de15f1659f1b81b08ae3323c3c026978b473c0cfa342fc461e23fba86f3270a74624e102878f5bb757f3657d66da7d859c09be208e45d6557fec9f0ed4a862f08909424242a76a6315587c36f9af1cde152e7d18337ba7250245cd6a155e517a78ef758af9ab2ea6431297fb649776bc841d2b7462b5da42fe4199ec5e3bf09a18d18ce816873f075e8d4d9a057038fcc6b85daa143951c143971a48e07462f4037018c34edbc191428d2c9b4984369d71c2351c34a5a3fd7f78b6299f9631c4b101e87f76c432376258578d4182113f4681f274893b6a660528b644b4a1b32f2d3a466a8fbec64e0bc29388bf775309386727f96d8c34cef30c9ac2db7856568b99488570a873e775791740924ad4e891c1f02b71b007c7cefaa48e3a5a68552010f7d8522509a87d0de5187e9b78a9012e27ffd12d62f48453f03d0b337604c96eef0486d9f62bb7f412941ad2fe22177e0cfdf9c8bd28adb665bbabd1c174bac055bc54d1dd5dfae06bef5e1b09efdaf3733af45851ea75ba27a4ff8e9d2b2322a853db5e18c31d26c67bd2bfd6322f736c66c038c275e06f4859c372ad0aade2dae372cf6dd4e28e86348972b10387aca477e9bada35e62778d9870c7454d8036ba37c8c97156b6ac62e71c5214106cea2b6b812192a56e060adcb983ed1b3b7d2a0715530d5f39f1590938bee1304420c93dd64e0fde3b17b0b8721224ea9bc116c6097a4f5df1f561133075fba47c79908c967d78c75116a81f9fa51c8a3652a62c3d5a9b80bf3e9223fa7fa924d724bc0f609135ae1207315f540800783688115151cfae15f0d212a1b106c25e0c1d1980adcd172e6bb180aa0ef8330b23c4acfbb6ed3985a9d898e5a5c0638820241d5e14b5c6b1f3bd5e2c034131a4d7722eaf709b6f289da4d24e3b875a755268296bdb2f6b10d0abe4bcda3b1a4e31694f1c6f3061fd165543573c710d794b4baa3f0c41c8fad53c33174089b316134b418e2e8d4b972b6cc922ecf9ec4ecef4c1315dd88ea05b319e134a5394fa8dc9286560598d1f831bbc0858b90fa5b8161b500a2480db47d85eb74d2270c17107a5c2da5cfcbbffa20bb57bf83fd1724d7a3ab4e9163fa03c69c31b514085d5b14774260eec9acd62c97570e8f21975ddcc92611b3d6dd9ccfa748c00c170f95f9f070b2467377ac7c6f3c953995d5db71671aba818c8c9667c3d3bf7212110ed33f75b5fb32a3a5e6d097f7cf3209d7072ac68dd881e9cf192f3a7f628aaaca8493b210239b9d296f31c25019be548cfc8169a36520d84137700c18079492c25328bad676fcf8e91c956294fa8a2b5d234e855ab155ae39a095d3d3a8bfed400b49d49dc261cf0627c5d17fdbae2edce84802384884ee772ef7f79ed768b264e0b0967933727daeffec334d48744a684bc334a10916b6e399dd615a5dd79bda72fbbdb8e3f49c6933bc3c64539d8dabfe81f416ea9aaeb6a1414713bb09f6412b640483c5d13398c1e8499eeea7090001ec00005c5f54c43b7e9c955c5a7c01cc0049eb26be7cd2aec4fbeb9d534006996feba4c46b2a79ae06d0df30f83fe811dd3bdf7390a1ebf2cfd856153b3de493ec97aa8b65012098c3a2b0b9293f3ee8cd880b7edbd044c304e25531d73d275bdbf11f15bb21bfd878269ac16a69d7ebcac062de9daadd42a14e25a3fa9fb59173f0e33bf89a9d5840037b8b5ea3a0b4fd0863382185c4685d6c32c965279d95bd455021cd1efecc686447d48f421a7714d2f79addcc205a1b68e8b9ea7ac1bf32de3664c976efedf579b60ce5b86c581edae4b71a3db07f2056d9942e064f53e0e536bd74f885557538c3b126d8e79cefe714e533f61d85d8d42da33b1ca6e16d5a43ff198115e3f4ce975ea02633248b335ddd10cc6ceb2934cca7bfc98f88da2d3b3f201e252048c97980aa1582f91ae734293cac3f07edd1955cfbae8939db933a70495b57aaf71a01c190de178cb6bfaed06f3e32a9f8271e1ac836c9033384355e35371cab94e7d0ca3c41883e67a9676d4c006dab1712a8f7b7ce59e533ed0ca30dcdb7ac97bd315ff6da6b87944afdfe808e820b57f7ede75ed3b49f0acc1de34fb6e5efe903ee89047768265d51f776508cc46289e5c630c9188c91cc4a5c9d8d5af55730041f68c8f1fc872296d350400484d1882c4ad371a0e281dda9c855709753eba8e5b37135ee64e9fc8911742384f6521a8d60c6fd571ced683cf70a36b6583f182f5735c8b0f204a525ce5a00845db1eb4a804bcf6a8af9ea501b72166a9268a278af3e691c11c3e271bea65c63c39937ebf6fb696e35489ff3935189d98f980950288d6331419edee205ac3bb62e4cb6a0be30abf0ee9f950a2be518f050cd0450f0847675203bffb2d0cf2bc2cf868f5f482d327b991afbef75f187a69e33ce4d2b525c0a1f4bfc72c4c38b62d84e35b48ede2865a4e4437e7a0360aef9769ad19f0a013e1f4331f77399049ea3dd74455563f833733840952fd3c53166321b9aed13ba16a65eb38d6aaeefcc28896def79e9cbb57c9e961418cfde57ed971fb7cca1000deac674c89befa028db5ade0e13b1ea92c2202dabd287ed065a0bdb4a79ed11580bb361da92ec1463961e9d45d3db4a2390ca49d36ed5ff9e99a502ef8c7f5ccbe7333e20016d707473a02069d143de51cec0a6c271a468625a9ec22329865b10935859f804deaa467c82329fd1f790c64e996cd95cd6477912d07ed6c8b07e43e00533e6d558cf5d319093c35539bad7f17025ef65f9b5f3c7e5da0d3d5972cd8ec2e53002e49928d718a8c99dc32a09d5ae3cbd65ac814f9407757235b82e4d9de34d813294cae648d1e3779f9e01474f45e879b36e0c6e6cbe36cd277863e1afbeb4e33f2f840d0396b9ec555032168ccd4fe909f507a771209d6edf5c44ee65d4775d650be070ba485bd957d9fe9375aac103b2abf1d269d967fa0ed1ab27af6fb03045f4b13eab75a0bc64897d95ba8f352f077789eb16106efac513d4d520e5c578dd32ef3e2a144e38c292816621c884b01dec62616d54669106bb88e5b6e012944d014d25d0a3f1c1b42a61d50a1a306be5fafbc2849f581834aafe126a72e184cd20b3ab59cce609788e584110b75b3f26dbf67c3c908de09a16c8dbfc7170ef7f622f6d254065f162180250948f50f08f17978231aa5bfee76992de95f6f79045de2a2f4bcd2991f948508e4faffd144f56c6406c3f073f5efe694be5914d2d98519ea3ec777bee8cea848648f4b1c517dede6c09bbd07177b9a526625a66fa7f171da121935ab5655b305b7ec936301f53bfdea789ac7837dc5203b6aff86e78b972071e6f21ae05d654569ec5742416fcac392208744ce22b6f59b45e1b66ac12c0f95f859b9ad662d44d3dad720400eb811fab770f0fed28d8a1a73070b3fac8385b1eb2f1af260dfa6fa30b0ee195ccab85dfe07b10b405b7fc2c74c9c015faf9fe77cbda243978d037f79e9b6e03a901ef6f9193fe583d739f1975fbc22ac58ec76db266bea09cde289e5520ba099163eaf50d9896b89b22a8757b331a0ae6aa4162debd474153613006a1db1dd84d2dfcf330167f68796f408323119d0f49d1c08040d534f1e7a2b8b1c88eeca43adc8702a2c221a2abd16ffcc20c9360a361e495bdac33ff21c0f03f80ef9c65878a7a729f96f1dec80bc3059bd286c2bff41f55bb96d090346308c7dbc5b29912b22bf8118bf8e44b141e8801ea35000b978940993646bcb66a4022768e587a4695a57ad37a5c1c43d613c2fef3c3cbb6edff6d2e9219cf376ee56258bfd2f60319fcc94204fdf34e13649faee465ce6ee8533ff7d0a345cefbbf8e14411b271f19b1aa24e9f61ca1f3c8b63fb10ecea2089b99f40089b6c2ca57d09b76988457e26766e3800e96a9c6657677f269208a0996481dd5ad3bf134e91578930dbb4c1e78a330994efc61bd9a25f7a7168e7885045f7b2b6048aaf82dc999b773a5610bb123033c46c6733adfe9b97526a27f4bd99f6a3257cf269b2cc1914310942e636cb9baeb0bbe0beb0f8ccf088605db44994696c0f4d5d638abcf597ff75e9a080852b630513d439cea1dc3199f650f7ef8e0cd0edd01ccbf1e841e5be9a17303d112de5b9465e400d96d49e249a909a081e9348055107814ede3f095e1ed957fce2664a5e3e922b115ad22fb32e4daf45fca89623745567eedd42fc89cb60138462bfb3d5601dd0db31c1c581c1ad243d9d51db8301b16bd8048538e90d68539f7bf17c4b8ca46e4344f5d43ce4d6a8e4bec06b2be241d67bbc003a15c9f5f2ac06990b7261d718570d3c38e95f2e92c731314c038e895c58f802c5c00ca1de670b5f2ae2762d1d963a236200a2d868e850d6d004c2c0c76bc31fe562d263baae097534afff3e07e82f7e527e8d4d41c689ba3f0b49894e709269fbb5864d6ca02ce90963c721dd9944af680de46867068a223fa943e6731664c630837fd6a387de022eb7ff39a290b6e146c5d593f4a4063fe83ff3b77eeb0b2b2d4a7e032fc0c084dcfae91f62fdfddcdb605b45a9d007ffcd7a2eae57a03a1aeeb16974bce46be03eb7d78e37c5e22b7a6b560b17e1b6b7848a5ae8f1dcdc907188316150d223de03e887010796b6f7cbb8cea3fd3bf5b073f5e61fdafab7ed20e384c61d2cdb8cf6bdc19a51d02781129fd03b8769d571196807d3f9fdbb4b426509bea550eeca00bae740ceb26ed95840e8bea3df6e3fbc6256099d46c8c43f17bfebcf3231e39ee10b5cf2fe33d53466c9e98eba670dc5524484996f5ae3e10d3361b0095a1c92b6a4aa5a47c1b7e3933109230ad5f4425a17acb92d0516f215ace6349a6d73f6d539ab6c04ef2d17d7871f6299f85a85eb6ee33d10e6918186a07215f42dc3c3c4a71494e646d7b94c11e05fdd44bcc0ce7cf4b2f1c2d57ee418d1a658cff4c577cc91f1fd66c2baed3e34eaf333022ce3f2f317b2d7fad99a867ea999ff06476709c0674e3d04d86d83cfbabc1d200eefd3379d39eed25adcf849309caa0f8c19c3986dd06425d53c5811755bea8bf8811e5a6f92fac8cb9fd54cdfb7ccff16f4b29bc81c1db9267c4d1457a0f9a46fd737766378d35c1f111f931eb1a899d40393dc7053769986d0edb8afefee3c7b81ce435f9cfb675ba88142afe04374d11dcc308d001ec02e7fabe0b69bdc465daab9f00ee9d77d264f8eb8fcb3b281e6794b4d9a77c3656c971f476de51d9c80383fdbc09f38b10b412ead3239da5482786b76ef6a7489768cb6017d79644318bd2d52cb16775eb0ff72d6196e9b1d0eb809ecd1f5d833c0b1a0ada081abd2c8b90459a2c65e7c70c9c897f2affb38a6d71f0e3cd128197c1ec5726eb29e0e4c486cb3a5b68d808d906342a5553bac8742b3186d3d8a89dd464b78bbf69790b8c9bb45efdd765bd91f49e61015691734506e5f5801a4747619a79518bab00898b0b9288047f62a86cd8968e44670e0649f30924ff20f3baac49d9a58afb8600116ec4c1d7bfa521492f91c7bcaedcbc631ef4b5b1b9a363afbd0dc75aea6c27f05123cc9b3344a9459a35a511c549f1bab8edde7d9aa61199e7bb7ed4d26cf7995163bb3adaf48952802f9b9985e3e14aa7396d48860c5a860853c7ad4875773c44a0677c7ab9f1457289068deb947d4b7c840ed6e39bd409a2cfc094b0bd17cf35f70e962a4124bf1ab24ad32c0af43dbbe390ec4f12d2bab4efd7e32ae865b8adfcd4d383e1fbcd2b1aab7ff9636fb8a07831ecb47cbd6b5f9831df399f7234a4fec4eb2d4de33410f284e23d6753f06bc3900284df819b93e6f9537b52c466567d4beccc66285943e16eccf90ccbe962b39f3446ce95aa1f7fa4805bc805ad0ba58da27c6c49ca16287779a10d9f67a5177b447958579ad7ab380d7afa59bac3d827b5149251af200acc7f5feea6aac9220bdafb564cd3775f0806add52e4fe76460095082d5308ed0215115aa82e03103649c4aa434b83917a579a8926a9a4b7c5c1420f80a920981d2d7fdbe978deade9539b4834e07a8874b9574d5faba10874ec4cd770c951df1c85296803fce7758ea59c9680273f292a42d1d56a4cce3f2f64e740b5ffc647d3338a8ddc151ec9ed7ecbe514449a1ba8ab8b41de91e50e621b629f427c77d49bee7548ac3391a618dc4258ed883fe6c9df8147a8ddf1f6f1cb58b386fbca3c1c4988a4a2d98ac3370bb7f42517eb5c725b65e0f6d7a991d89f194965915eb420cc5748453678165a3b3a811324574f83a0a38d377b516b5f49e80ee3c7d04c13a1f284d60d165bc11fec6683e4668385343598cca58cae639b0fff1ad9c7560a1f7f9da66501ec1e3ea35550b651e6f7b3eeb2692d736bd0702ae84e402a1081b8e0f2649d83dbc7d14aa700b1c81cc93dc82f6619c3e9965779c0594ef8cbad23ace802628821aeb58ecbeedb268656f73ba0b300d1907ee1e83ad9f49bcd2a833ab13fa3d54ffb857cee0d18cd16b1bb58fadbec5ecdbac810c254bd5cbeeeb2d01bdee52974fbbf6185b5bd136b34e79b709a5e767aa660c7402c5393bfdded991a0b6676c70477b7e9b9103615f641da8ddc030dd41d8714780699bd47c64d1ee327ddbb369ebe314eac3bd34331a92aba809a29e0f456354852b47dcc2cb753ddd3bbd83cf3971339915d53db104023421723221605f64b14b0680b87b87277783aa7588ac2da66403806695c33b3f09676ed1153bd37b254efce1b4d1ea64c80fa0a75d98e9be606165b56225eae1cd82c340eb8b2521324dd1ab1d283794d15874859d79e39e6b13557928aac06a66d1e5b0d24c83ea6d226406bdb22d334a7e3bd3fa78a530d6df55a79d25a1c5cb5fe90b1b2098b87f1a91c59e9dd5fc4568b2ac114d53521e785adcb00278797a38450a3abcc7abaa9af89c05dd2484c68584a3fe8425b380bd45b1be796d4b151ad57fb3b495856fff4736e56efa27fcdd954d5c60c4bcfbf359edbf4a2633f0e5be234334b701fac206ada3437205ae5f68c9f6c9acebd97c1b7b470cf62af129193b8d9fd2644ccac948b633e00245cb77651ea99a6bfff7f06d47e0244727338486ccd0336bac65beff84dee63248fb9c88bb4979f72b2a441aa5fd57aa4a1ccf6809207d13e82712b1635786215b66cfdf1164cec83f7b1c4e0c09c441cc7422cac88e5a1e20e031f41e255ab1fc129ff36c2ab798bbededdbe450eb38e37227ea6f6e4812d4fc7be2651221ba2b2ecbad389250836aa04c40a2148e7dadb5d32165f98ef95dab2d9d0412581bbb7fcfea224305f8fd830805f7c2b399ce526e8260844ee270f8ece61534a1432b859d3d5c9de0c65c0307f552acf94275281689436736d0b32e5b8b87bd2d4eae97584fd369087c496bddc7a6737375dc3f025dcdca431945c04908002dd4a57d876449d24a5daa3aab6d194776e444c606f855346084e1f44914c23c27073ef068d7a69b3d3cb1410afe227547d6198ae5b19fe50d374c0d81118ab61b8e72d50e6fab9bc87f052816f8ca558a96ba47a50f39c882243cbc483cb4d6bd47606d7202041e6711543f1ccc6879e5282a5f8768aa61d6d65627d29acde36a0e3ffc897eaaa0c41275bc116948947f343623352dfd0b254f877f05faaec150c0065eb087388877f3785f3c1982b670e107b40eb021d046819dbe03f8df779b43b3e38d3bf9f68da3b2fa2e3edc16fa5f07335e45877af03056f57f5b59c09894df97c140c4a6ad9d894a369aa52ae6bf7a442d6978908f2de114b4a76398adf4eb7ae51cea983fb308b498ff8911d5bb4461a773e0e5014b067310c29bd44dc4684d2d4f83015c08c6df3ddf98bae12e299efeffe0ed21f3677afbec86723234ddf61e0a9bd15ae2e3ba835d6ccb74ea76bcdbc26728b25f9154bb809cbdc1e3de98fa18bead4957e74c413c59e2e0595d4b7cf723b6113322e3970f9efb7e1d166355376e9768b962a2e2342f1570a4e33bfcac74fb38e9ce6c8fc65b68c33ef42dd3637476728e6fc871f1fa0c65f183275539815e942c66fb8f0e5ac25aa4b909f296a07ca71b6ef9e24358e8305accea298193c2d8b1649bcd118112bd32dcf7514034ae2cedf3a8721d116ec20ee139c03c99fede461bbbaa09b144803e8e611fd424235abf9e45da2101420965187c88af0eaf782a59b76190317ae7a4ce1961a753215a0f7e3ad7fbe40f938628d18347faf20eae24ad90421d0ad430aeb42d117d9f89611de32d068949483414da254e778098d74c1873fc9cfd723dadfd9b66ce93c95c8bba151dc37ef5b00c89f51eb9abb89c94bc5dbf2be60b287a414e92249ef37d29cb23d20da3f8e927ad0fd202a2853f83d3fd0fdb68f0ab2b13068f2bd261ec7ad8ea453e671925a129a121f6a2ba68866f18f2d2a8fabc3ad9cd0d8c68522160c48b2e1c1875ef54849e45c147c54fb15cd9781411f4fb59726b98e217f88ae0e8b84a110c9edd1c3dd3966258480f9f7db4b5e24a645c5ab770ea7182fd0eab9faf0bc35634cb3470863b2a7d506e413fff89308704e3188878b7faecd72743a0e917107280c902aa09c572701aaf560f69774bbb8e0ac2952556e72ea5b6fb794a1b2d8a6699050dd6f9735f013891bebd2207e1591e6d87c74160e1341b989ed299804eacad4cc47f003dad5fd40b087bc1999acbf5b9b05b16240468ec8fe53d043ab0b1055a270994e8392a4b11db927c0e46364ccb887f62aa3e03f183204bcd969591c2a779216c8ebbf449022cc4a941bd6088870f864121cdf076e0c26b0066065ca30900b1f0c9064271602a11c1649c62cba6bf2df5ba4ef9a10338afeafb3623019988543d9e8cb574a34fe7c9841c53dfa2cf1f875f1d58e5999bde62477098cd39a6e24ffc20cb9d62ab40a36f45acc6d815f1d36da0bfdcce9dd8d780c18aa9bda680e80be9cd3755649ac55cdf1f7a3e844b5730d2d3e2df5b584c21dd12e6e78521b28a4ea4f8e6b8e4a703343bf101590d6c44e76b10f0fb23ba3810530fe4d9dabd9552f47b0032bff7ba0d2fd6b971077e14b85f53686ac0d6215ce1d47d8b5b5e4dcb62ef3dd2be8c3b4fd2549dcaa7df006434c14a2d8a661ea9dbe1826f659ae90e09376cb2ef53c4aefedcbcbfff2eaeca84e5881ed47dea6b3a0c5afc9ec22c0794d1b9e0861805e87a9341b2d52084b3b4457b04dbaf869783d55a89dfa94d84b0064df03f4e4f505b8b165270cf696d2f52e0c6bc4f5cf3e2ba107c0f3aecfe07c6354d2c7845cca4d4af7b1a09ead556cd924a1819b7825589ee3fc38eab2d1f6ffcd421f64f561f68763109ed9b358e94c5975d3ebe7bd50dc54f70ba534d87a8de1e9aa4368af5fddfaa33b21ed3882a5fb77807e2ce2672cf185ed6a1d173d029f20d031eeb86e8c84defac1259a23a3976444171bbffe446bef757b0a89361f7e69f87f98f731a9bcc67acc5cd4b563f4fcfc47ef7d1e864fcb363235727e24b91e0ec7573efed9b8026e5feb3dbc4855897de8b539326421ea7f1e0054ee7e18e5ba9c9b09a62e35b95f079c43a434d5bfcd62c05e32d2207b96ee294536e3a4fc70a4b646a02d23ce14d25653130b5128327255124cb28cc740d75a8e174b5d544273ed1984156b50ba784f549f95e9404b14dd2cc62c75b2717537cc2e6ded87e70a331ba0195f0d43d98aca20d5dcde52d405de24071ec3c9ee406c34828df7e441b70b3fa37943561ccaba1df763dd6b5d1e0d7619dbfe60cd3a80be6484538731f72d3d87b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
