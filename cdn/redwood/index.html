<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"854fe5fde1c841d6267f4bf9841b2ea7767be04af90df198ae5501091c0cb5d5e4e2c75fa4738f81b70c869a515a49c29736861fa94770a4aa8568d85a2f3eb25ddadebe859cef85397fe9b437280e9b6cdb1f09b76558b0ca84e078249c2592436e20610758c4cf42a3d894e115d9a0a6ac553ba8bea88842f2ec39812b07417eeb12af4eb402dac30e81a0e02d6c1f59a046689a862d4f3850f1d6f48418673e204455cecad76f9da02ccca4b1a156929a9e087b5aa9f83962aa50d7ca7fd322dbc6578f4fef27aaa771c184a5512c2621ca790bfa51a84b82646f53e7dcbf4ec821984b26f5fc56fddf3baffaf1223ecb47566ca871a815850f275ad7a31c2fea30f904ee50034e3a6bde0e8ae240cdee45c5582992eac3a3fe9b67f2eba4d5b1efcd3ca905b67e0f429e84a4ed660c724ae2b77d58181ddb527b828a225263e6e67d169ca52fc75f773cf54b20e8be49babd14f05da206a7d265f68df138a622d66663b8090a7f3723d962abfd3c94a2edf63bae844d6a074d20eaa53052612125d2cc9a4060df632367d617448ee7edb181917d0f24d4f2b0140596b2ca63b76881aeb19a9a4a63a6e45f6754eb07907ebb9297af8712ef4efda774b3f0a84c2ac3dc8382c0ceab3c3bbf277c2807f1693061565551b83830b6857f9bd2faae08bc428b81e86be8a769c73be38ca220d804534d5d7d8540d50cf9dac2d375daabf64929d3a5f835dda3b4d72b9da2a0b8558e9023fc2d62df7d00a82d7489f63a5b4ed47c5f6c921b1efcd49b5eddc13ef1479e4e241909b71bfb5e6f0f55b965d1e5be28561c52009a61411de8b9163d46237857b99356b144a45f6220f1d65b71b9a3e3ad3f3c6052ca6af4aed84e62c861aa5e750f5eb7c1598cd50ff61c49c8725ccbf350c10544c370f4325a8276f86b632218e2bebde6ab8ad9dc23a348e2b40360ec246000933145de69715ebe732c41b7196c4b6c205698b0f898a52d1116acfc87de3248dea2bdb61d86ed47f8b92d18beaa0bcd14074870da6aa648f19607a46a6dd0e2b2672227e2e7c81e9613830a1639110abd73e5e8a9a1ec5bd050e10f9b1915a7f29b63687d3914b54778bb29c474a75949e84afa934a8e097a84432fef2de576ac874c0ee94e774f1a25b45443802ede1613b46f7b2e41df8de224bf0015f319d340507c22029483ac424ec9c677f0a5cd16ed47df9e006dd569842d8cd80bafdc8dd1a3f4171de726ac78f9d3e2af480985286bcf6f77c3bcbce0e4dfb4fd4863a452c8728656ec923f770763ca98a17cf0634aef156f0e7b3a1639381db22c9ffd409b4a1a5aacb077f5903974e15694a95b57c7ea38914c01799d4bdc4768792695474ac73c937faa2fd071b77b9c623357b57a1ee3506f23c4f20f59d5c55f7cefb1db0265f6c08b5dfebf90587ca185a90fa8a4d16b98ab5aac7bd1e703784064fa47365c63a7b3ba44dcd0f25cfcf4a1eb8d9ea589aa4a31d7d4e6b5fa3e7c46635bd05202f1061ca4e20020a69d51dd429935e417f002e67d2377bb2f4322f3291da9cc3efa311e0cffd39e87e1d6381d96aedbad6b9ed5b4c8fce85c13239e799285e1141d00932a00fa5e627ec51eb4b06b20cf4e1c909dd9216c2baa02a5d8780e7808c7dcedf96483c71e8472a37b4ce185cec947c5f96a889bb128f6938fadc4ffee8d9d32adbd82c5519525269b264b1020f983027201b42383edfe68c95415610dd6390d14e882c7696902a7ecbefc1263ce20687d68164c6ba94e0fada95b64b1c0a20c24110780dedc97019147fb32510c10525c41545433f58d1137a20bd2ca0cdfcba8e58358a50381fe12dbcc56e772bf43c85fbfbdc75f4e3f4f92de50e4d2095a69fc606075ef5d21680afe333779876d538f13ccb035230cd2b228a5bd49b728d7d82854d0341e425203e97c1c5eb878ff8040ccfff23d1836b56c34ea2cc222178eb52d37c3386290daf559c2ec2453e73b654820f07a9b55e34e05dcc9feea7eb33f11e42296c5b01eb8d7e3b175882880aedb881da6d9004312bbd58dc6124ce5e7869c4a12b7264b51e2d2482439fec0c6db764b30616fd9acd5c1493e7ae3c2c0ce113c0c0a353b70b532df13c387c3186577bb31fb5fd656a1a762ef70af1e94d570d12fd3049ea566191d1e1bbb8c14d288a95a3add6592062f3cd648325ebd116b6b688878d1e37615ce3a8f23d69063a0f7c5d7032881f49328256225ca96f7dd597585528b8d8a821cd253e61c9cebe9e46a3ae042d9cab5b98cec0a741f4bd03d0405dcac357e78911ee8720493800b7c7ef212713e830e16bc4bb23a03c8b5d4efa81f219d9daf1921e756d9d71e853536f3a63149035117695d8659a84bd06b02a5c52420e2789dc359acaf9538a3b97965ca2d2c1b94ba36aab44eb85053d9dd19a15569e7639f3cb16ceaf9c755eb0d66c29fbeb3854e3632df6f48b4ba459e42f99b2d6c5691a12d3f2502be11b0a2e6b07869ccd7ad1ce2a689bd640976d294c77e3c7e74300669503b2c6e65788b990bee986f1bd19a5e5984251827051b5d52e6668f8a0318a663d3bcb17bf06bc22de13a2b66976e491e6fdd1fae3c2bbc0e8390345c70e76e84c370b39054506ef02940a0ff47f6ef4eb9e6cb3bddd78abe1e244d3d59fb43130b85456cf4b452566aa4486ef22a2bcc5c09e7772078407644e0834fcd75dc7797be9bd1e3d608055342153ab968843be7aac65816b8879bdb017c1b6b7e691dcfaf0da637c747167d2ba7bc2c720b961482ddcda7309d411a76ca58488b34a0215d0d18d35ba423b07e72a4c1d6b863e6cf90c3f567e649d04467c3f4083db267ba3c4da2bb304f2243ec7ba1c37c8fe9de7948e4b5c1fce84fa73a1420524c3b7d4c7734bed916fd8046938fd83f3bb39e698256cfcc30c05a456926b2f0352a47de84c96cc0b1119c3f6e8493cdd3163edd631b57429768881ff176e7ffcfa6964a357e0d3527e09755b661c098dd998d4117909c44e4fcb8fd851d2213351c779e6922c66b3ad401789028ce07864036bb942b41a10098da8414d39bd8e9ab5b0a1e027abb26ae242459ef2818ec463cfdefb0beb1c50008ba093c0b42602647fc57ce2b7549c306ea8be36769fb9cf141f36f4c98183fc3705d4a2e6c0a4c4f7272f2cc27f36c6a8e3a9f61acd5a12edc08b47056683567dba3ee078cef6c05ad16f55b3f74a15e1c145b99203fe9714bfda84d9ca25e1d0da6da7dd0ef88a55b1dfbe27a2314611b2b387d4ecfe52bdd34c021971115e022500729dfec70530b1883a3c79bd85b7396cbaa96ab7073f55ae0e5489bd553c0d6f935c07d08f523bec0b84be6d1ceb17fbb1771ff6f58be970ae9e2941343d46283090049e75d60ebbe867b9fbc4395da0c6314a42cebda70d19c046400f81a5a6d50d189b37f33f04878d76cbfa636e6cd5387d9c26435d98c559eb453a7b428b88a7ad9b4551f60c72c7ffb2b250d4ac7b3705690e54b66bd8d673ad24dcc34112c14b4f9ab280f236602319dcc1ee8f3ef8fd19b7a5a668d2082a40ac2c44ad672b24f6c9e8ad4ecbd8f6d30885ee17f8b80be51c6bc55fc78758f1dfd1986aebd306c3507e9903b733880a94642a27ced522401fc6c32e6a3e59d0998b5be16d36eb89354eba39eb7a7b531ceabf3de456350fdd59cd8cf5e6eea7a2edb5b51476caea3e3b25093a80bc184fc47f53a3b840563d24e58bda9e8eb3c11f3f681dca0e1574af47601f18ff2c41d3e069b9d6096cf95ebdde0776876694434331eaaf5e5c46ac2e99fc9920d9d41871b74b5ebdf43be62df7b2d14744fe0ef41414ede8103744f2d65ea4e3dcfe3dccda7a9d77ae41f135f840adb6084a1b43fe4ed0f8721d7f875efb030b670b6d0f54006a2e2783d9b040dde120bfd24d1c3b047166abe396cb40079dbeb4a60d44180564e4b74f5df068b2480b01fa7ee8c4f34ae52a328b188c1cc11693a8253e638cc3e7555bfea5ca39b7917b41e626fecc2aea01afb824317916dc355fb68ebcd4a623406bf9a63b1a559d923f8f6a2f9dfc8e21d939c24d917229729f95a143b22960e8b9411824ca95d3a26dddc19bced09977ca49b5ac8aa470de219fa9336da57272ec58313b1877a3519a26af9585226e524204d693af498c73afcc6a2d06a9434d57a37ab5239c87964bcbd546165d0c9d956cf7d1bddfb4af0c99c9202913d77e7babe1c435a3592cbe070d2bddcef7683e9ccd054e0cf8b940cb9406ff3564c146ea33ed00ff1897baaa32f34c85f7b2a09eb3bd28628499da494f9378e082ffd4e6c94bcad52e98136f502b2c2ad51988f96c1e73990adae185074d3ff2cfca5ed86a68946af7f555aae519ac51a3b537b1de503c81b7490ba0dd6138e7d065705518a1dd8269c91748b6f630bf6efd7b677974c0e99e035aef46d07d8826b58ffab0a12287ffcfa8ddc8a2f5f8da6c08fd243ea5f1fad70b5d5d5ace958d595376417d345923bb3493c191cfb6d2c6a6975911ce40137caa8046b90caec2cbc1532e0670f7aad2456bfc42d4c6bd29a11cd58191107f13c1718da145a40246eb8168b302b032ec1e3ceaa733d8e7f2330f4beb26c020d992952f26d2f8caeedb17356de1c5169948d1dfa38ebfac7c0c4602f1f8e7ab6f7072621ef04fe2804b5b3973cbd1f26425e631630a088e97e75556b58bdabc2abff5584fc91609b2e8ea90b43d5ebd8cf5f9f330918404eb58c713ed3aec451d5e2d13494b6dfee2983a789343df4e628a993a9057460c3a8116daeb1b228df6bb5204fa58864d118d5be5758feeb72045dcf214ec08d709dedf5546f93b12236ae302e967e553fe3f996a3a7117b7938c0466755489f339c85897f4d05a8d7ef2a2609a0ffe01770a461e1f48314e9ccc6d5eaea79ae726ca070a38dc21ffda9423946b3c1f789280ae1950a8289813059a99f505746e3d0360f661a44fb2dc616c587f327c7143327dea5da32f077348d4ea0ba5d97c4076c25a28020e68b7961fee1d79f77a1291f533f8790c8dca75bcd328f8183ad2d2ec7c6f9a9e5416b07b1f384cdb7cb2acc9ab8dce73c99bf1c40d14c53956d38c8052c66fa3b1232ac56d8d21f21248deac4b0cdafbe5751fd5b76c287a959281e2e1c07ffd4db47f6141d1990f66636be61891611da2a1f74089b3dd1bb3655e096b6ba17346808b21dc49e17105f1ebcdefdff546a796c515689acbc4cbcb98e848637c4c043c2f407cb572bc6eb86ed4162718ca5d9fdb1b93d916357173985c372160ba2b9cf452a274ca23ef4be5e9236d422975d2ed442ac309acdd96430e24d4c31fd891e31a7892c1afe22dbf92d47a790dcf13ba997f3bc0eb01d202dfaa277028cc4a15850dafd2281f83ce3a86a8a96293a2160cd5a7ada9c1fee025e64b126bc9913b34a2759857571d1ab15ba0cace8a85a0f2e1020b3c98654fe86d13f25d8ad56e68771d20b491d6d2378ce564009dfac4d718690cf6c9eac8502f7859f8a24c1f42740e80b50bf6c23a6b4a6c35237c0a4f560ab434b2043d2b56878ecf3b411ad0f852f599062c637a9ea5c31c77f3921151e21c3d1f53e9cb8e36a51f784c76a39324c1cba5abcbdd916cd08fd2f208dd9f3814d00d0086e5cd5151d89e741299046f462990e993002b768f3d5d26d36006a5aeab3b55b10974a986d6cb7b7ba5c8660de29b710ad871c359ed93955441292c7b061db078f0e539d83769ac0b576d90478fa9cd488dc24c796c8479ddedaf00cf98026e54ebb5884ed534cd30987f17124d02bd5abe8e3199b7aa19f3701df0f8a587e6fc2a1f2aa0c9ab17d332f4d07614a41be2ac77d27293374e85300aa8ecdd7f9c5018997b2bd1d5f3663c47f58e736f2a8543c6012b39a99bf03728b85e9ae5095b379bd65a7781aecbbc2b5a0b76e6b3fafc547aca52592017193dccf3b5c3c843ab50615dd9c9a803cec89ba63f81d0eb61e27be12a0d425c9d0fe66a8e2bc12e6dabb726980755263bd4dc1d94753717bc9fda3a21f7daaeb15fa57b05a3cff35345c49efa0bc6df29e32aa077154cd6d3881fc348054568fb26c4bf00bffa2d363c882045c82003ad180c2eb0e7a77f25fe8be2e6376dc06186f90c44fa267638702397836687f641661408795396d25b97c44da311230400bbfc0e93e92ed3097476d4ee690721785fa4c58b1be97bf5db44577e03ddaf2ce3d4d647cce3903e10dc59e54ef4bb75cb9ceededa2f2f9d6508b0562858a88d7b946c9ee0e564676b24600752c1add3ca290afb68cca42c3891ceffb8cfc52620f8cd39fd89b42241b1e8fd3344ccce78a081b448e5eaf22a20ac5736c004cdb4439d7146d973c147e81f8389b728c0e8e12db396ed4de4a1c08867423d457d6152ca9860bfb807df2b20631fe71544900fb98ec1320c0174718c4590f2a2ca0325c97e147d904a023584eeee004a2f3e9249379ccd7f2df26aabfa6371d9d322977e757420e957b44423e246180e571bf754fc026d660e8306eb1f8d9b318b11086639b182a858af3696cb866a9fd0269ce99e5c4110d21aaed8891529783b8bd2e0d2fc1cee3da38fe60a69d51d9d6b8329e20e06a710e993e7efa7f7701cc21d1c36dc3f80f14c917bde06bdf92535edb36c24fa79cccf436e91b945f4dffd21a51e42e6d8b37cbef90e5f4d837df2584af2abfc31611848ca9a59dba71c083bfdfebd9bbffbd1b149450c6a4576965bed3672b2eec04cf855136262c15039ee6f68d24c6bf8bf920a90a9bc8285cbcb3706cb58052313ce6e12e7ae95e242c9a1f0f9b1893a03224f27d999ae38ab2d49fd1e4b9afecdfdd201f93315ca8fa7c59cceb52ea895d8595a6185e8a345a52c2995ea6978823792b0bb4d3f1d1928691ca3c8717dc0a4272a22787922b89f12db9a5b83afd473d98bd87ff248751c0e544628d3331201cc93fb5b112b453a05bd8311325052931e6c6bd35f0e2f5dea7fca9391ced7290accee900f4699a56c7ab3ae2d4a22845cac495d8d9e0a3df25e20c4c8ad3ce3942980e8cb7f4edf0276ccce6f705ff6472b03187593b7a64c21dd1d7369ca64cb94f42aecd17ee928d69bd403ce000132cd4667dfe0b2bb52e0588fabbebadf8f46c34c39efc0d2b27452a704ea5488eba4e2bffa39e270bbd3a6fbed4578eb964e3799aefe5839ee804abfcebf53e88af48cc5dcf4624a613b514b522b9d23dd856f6c182d276f41db3fb874a2b253644fedeea3acd10e2f1db8344fd990a1c98d95e202e974d84e327023684af8a5ae6a2b54f9da832f7f4ea13e686ee82b6bb2efb9a7b51143c57cee6f0ec054594ca1891b93300e3ddbac09142af65cbd9eb6a8e020f9410636625415908ab6049496210c938c66703017c798fdf44801302e85e25315f58a8b0614eb54d4b94177997414d5b9ffe9cd301bfabebaea0a87827ff44fa0826013835e2e4729bd8b40ffd74b0008b390013a881f53f16c964773d863cfbde994faa0e1ed580d89943898eecc3133a075997ac152f5e0714776cccaed8d2f0e46b272aaa9435672267eb398443ca4ce5bd4a0363aff0d500280c940a60b82d4d751e86eeb6b407c75264a5f6e7ba22d251c5adbf577a6d4ab7f67e42d415ea018692effdabecc63741826a5df35fe544f6565cf919350f78eb7e82d4531d15dca3bc5d3758a49cda513c7c89e5e14762ec12d7c01b85186ef21d29050f33683b2172a8b566fd3f6555aeb36b662fb85a303ea1a26c96b8016abd9372ce7db0a66d1585d74a7ac439388c20cf798b84cb8b31ebdd58cadf69276ed7b2106156f67d8353d7eeeefce8c0dc35b4e5e9a56a321a08efc893ccd39bb3d0c4488aa529c8792d521135e135f27ec05a1ddebf8faaab386d332dee6a4f1222c1633291018e76edf51cc9909dc4bda1d0d6f054eb0e7ac39bf41ff6b17a8919a20bd9c459a1bd9026dc7394ee2c131c76dd52e65f9d385b637cb64478d616bbdf057cbbce90933a6481cfddc1410afd729fce03d366a9cf13f533caae23e7326c3a9704b89f1fe19bc3438304c04fea8afc8abf11f1d10a7c063d5740a7d8b65192fdd06d76c45e30b7ff35768a9181202263e5b05fe67cd1bcec699bce1b174b41c673e78a14bf2c29e09922b6d6b48723bfc6a3119d68cd012094a88808765954b388148facba26a6715ca37cac3b2d50e3a64f4a5d2bcb11e25622832c36c3ae00df22ece119d5dc3977cbfc6d939d2f339973f7f3d678f07ba637272129e434181dc91bf04bec6be7a5826e5aea7049a6827a36fbd44e9fb4f1ed7e721e3e03adedb761cb3bd2664c62fad947c9608f53d9ed589c2d78323d8196709717bc3c00b969a816c80630c4d29af87dfa8817be1d51ac23dc400efa8aa46571036a17a53b15e1f8a11f0f4f80ed9723433df388c45293d2cb5077c1e3ec099d298596f9a56c37807174655dbcb44a39c48423270bd723c81e03986e73b787d127e806f06c19253e313eb2268c546af00581c8ef0e1634afcaf96626e59ef013202bd785e821867ef215a7eccd0b296fc3ade23cddff72a1c063e4f3d0fc6d0e7cd69ed55f2b67fdcb3b20dfb276e948a12cfd7543bb74485b4f5bb25446f44b559e6aae05501c3ebed6a887040f9899f9f6e7fa22f81530a446958167a23cb33346b7d95df7b36d23e521f34b984641d093d97799462b190ea32f4ae7ce54690645057f3de82a2c0cf4635992329e45dce6994f113e00eaa6c084e554d1952c236615ec911300f6e5d01543f34ce32c1b47be89290dea4f909ec499a21b07f22524ba25de0d701f9a5eb37b481e6e290ec858309a6d6f12a22ac3c0ab17f06c1a3742e798fc63c029d2fba4365aa05d907fec0a8def2e0b6e8d942486e4149a1b69bbe03a968ff69aa9108d55958ed2c0b054f4a86adc7a016b270756547a350eb3b128c1b91a4d8549f2035fbab5798ac762c792605a64553bd552279904cad12d651c4fdec84b8deadf15a10f293576cead5d94a20f4dc3ea307bd0749207fcf079e279dbe58d4d6d321e758497a540f9d73bbb1ab6f48bdf750dda1cde42a6e0cee4eb9ae7d16420ee420df0c8bba011efaadd7a8b970894b3ed038033e0a7f5d0e313fb67aa68efbc16fc53a34e9837ca275ed67668a7b5c2a5b9c040951ada1c00d26431e102359ca5b2a66d904322980d37bc7f6feac4f07d382c3413d8d1be94258d3cc7af949aa8a01099ab00cb4234d2203e27dc16a803c2b37cba353b8c9ab491d1f7e727aa72e76f6f5253ba5626e490de7c8ed0d51559a47d7ce40bc3c850616aa9a8c7834f9a827e871385efb7a98010647e93a6126d802c44389372754454ca3e8aaa68f3a7cbf254fd8bb6875a2c2b392305d1d5d7d738aa5b23648348455d913a7a8b5b8710d5fc7eb0c8c41104d8ea0e8fee470da9f683a8e7015c98f20a0b0b0fe5c9b4764a0d885b8324694c8603174c46b4650173ad2d241ac617daec09984ae426c47dd4b5611e362c64f0144c7a20e8efdaf5c3634c74f425f4dbca0402014baae005dbd1ec0e9e00752f5ce814623005f6ae5dc42c62a63b419f2efdd7f7962350509788539a2dbf375297d8061f6599c42ea3e8b2dcb487168b57e853f2bd9e9ea95a954abb7c2c724cae3c5eb797862c1114358f84b0dc7d8d3faf12ab6bc68a1eab700b293ed994fd13326ef251cd16e833f50c71912ee7df8b8a58f3da541ffbb365c855a21990c1beb3cb7716024b9f9e6a98aa9bf419d9ace448667c6c569cf6a85d23034e539172a071819e2491b5202f89765c70fa5e3f4812543251e6191e63483bacb733f4559e00f87c9408f24b821800d2ffb48c21ced9dc43283277af465fcd0b007542b61745bad4338262c9d0032c9af970bddb65a3e29bb3097924b208e712ca0f88d5dbfc1aa71adeefdf464dd1eb742018b2ffc40a36e9c340661f054b921af220344ac386f31509444ce58e5b87294850fb053b31af7cc23c87f18251f4e3465185abb58a9e7808fff4143b415aba4baecf9c2b03a622ba602529dd745d3c4c486f42b97e5307b2d9093e288b7588c9356f7eb6e83e0427b1deb6f33549be8a330d7817537f7c6bcc525aa45d5ac69293182f6c392b30b11147f1492708bab411068c4ed2df8dab14a73709a6905a0f2b771cb31ee9dd722e726187c3aba14aab6a3f2b879b5643f35b7389608305aea857f816757f39d5810b0a04ba013731d9e8acd680c76552f2ea33824b64877688d23f217c850816ba9f81891882a8c3a2d524979c91b7e0bf117378b0fee9d711d53beceef3bd65d9ea574f7f02e1d13024a5ae8f24c0214769cc8e8d71e88f2beb26b6a3e42489380f8f463e7965103fd6d09ecffb02935bb25579bac2781c9891c01ff87f6c748a8de1be77c0a0469414248328fb328a2b3b13ac8250c0cb9e96118d5aaa421721b62a5b6afc83f6c1dc4e5ded6c4e490ea78e18be881de6bbdc9de5bd378601b19eba67dbe0ebea86ca7f1386a372e2a963b3efac48405e9c8259a400d3876a8be68df239c80b1d62d18394018f68ef3b805593c79353e001f8ab993091fc8db3cdb24428f419bdabc36a5e9db3ab5e45096aa70d02240f9da6974af4c49867c23251953cffc6c7da070c831f9287c25c20c201da3886ba0ec393157fcf57b0eb83604617c909d54588b3db80507768d9616a38af6751e09350f187d762a7e7583ccf1f3f1ece352370477f3006cd9fca3553727297e457c89ee06e0d099493bd74122d21a701af0202090e7de1503c57a7da0702e7a2e905c1f28d2ba11c03aa0c14a3f57bdd6ebd8de7b51532c54737f2066244cb851a25547fdcf18511bf1d8eff62b3f9173cf044622668df4c1e2a0b1c0daa84b7f390a647ddc28449c4c5e809a405345049c5f5c3c278d41766fe616ce51ae8eb6387168384874ce24faccea66584219b02dd4bb35f074c90ecfc91c867e71a18f3480fa58ba52525381f85d0c18ce2b67af3b8f0b70bdba4ee20f0742ca368efb7f3fd6f4218e9b6596530d295516fea9140bdeedf8bdb67df29646e5ea529aa5823d4d005af6b16929d025462b960621c31fa973da6bde4037e166ac103473f2945f8cc8ce54d88d6f3b245bf9cbb8c3e8b7b1e62118055b75d60a339b775cc5c2d7e675a21e7eadb9873070419bd9c378858604e0ea043bf96628b3326ebe22e8021950706040c1fa1d04ef125b3b01dc62c3e93e94d26db3f6d40d56be32e1e6864a39c148b4060fd9c2f7bcb902e4ede8bc9c538b611284ab3d464ab00a8e14797ae0cc9c8ab0cbef18b30e8bd8c55c4a0eebd9a91453c3427855d8e85fc0812f83a6d687241a0f9fb214cc6bec95853fa61071278a120144ccd4b2310f70a3c95cb69bf37b532ee5489a7ffb612d8cf75fc4e95d213331eb370dd1900936dadb7e0a9a937b1ed7010c283a6b9f7c2e61ba1f7efccaa646f2dd372092c2d21001a90af86a826c233996cb555a58398ffd150204af4e19b2f3c80a175ba2e24c72160441b8fc00c310706cfa03a44c7da8e02aaef190d0fded246e26d5e796030d3ed9a616309da641a05d0e944ba03dd9e70a47288778cbe05898b7a81c27456ab63f6d51afd0d76c5b4d237b5fa47f8c38b11b658c31de6c5f68eccba4ff71afc60f57cacd1396bbfc4b2bb4f6c009d3aa4cdaf138ee53af8daff77e159ba2f3d4809c74590d19c41faea594c96aba139f428d079cfa17eeae6d2a5e3ed5e048eee0133976ecdba280b393007be136d8bee6e562393d32c3afbae4609ff6e1c7c3990213f9c96d4e23c20d1fe4da174ad3d51f85d487b379131205732ad9a0c6e52604655fc0472f5d3dfcac15ad1d625d1d6c6cc84ad5745f33b556ce8381b3bb631079850096c8618d8b775c600b8e7cfa841a0e57a048d3b915eb34aabc92d0247f6b640386ddac4259ceb16c7390ad1529c566cf5aa42bb37ebc8465b721e4d49fca38b78f1a692fb819f9e7a66806f6843cc6fa608cee4afb0ab009c78c4ecffb0a97c2d9d5f8388cc9e1d6edaee8660eb2955b275209b0dc342e9c4c2a4d9b2ac44c0ec0ae3f10dcf3a6eca14ee0cc4baea838ad20f53d39aae4a9d14ea6a663d4de24834d45e2f1341af53e253dfc708bde6bc4747febd1d6796018d95b4783a84df4d9bd692141df958e9e6920dddf2b73a71ccf445141d20af164b286f239d1d3c433d5509c7b17979e8b08ceb0a56c63f4157e267336d32a7e67b3ac6bf85ad2a62dad728f19007a0f07e5b1d0557e5c0b351922e4167b20cb00b5ed7c85b797dd85b292645936c9e9c8cd354ac2c44b435d540a8802522d1add9eb59bd7870993187d994562b6a17b85f4001b186ab3bfc36273e5ecf816b3316995d2dcb33cbd0235a846a477f3e6f42ac43333a8f72a16f4b3a0ea09831c70287ee903eedd070dd4720f9591ada41a747071f70f6054a2ab819a69d8290c51edffb343f06e4554975459d9a26e7f4b126cbfe75d177459e2c18f397edda95e05249f37192c2df7e426bb14c217f81e6ba520d546cb2c2499d3d1fe252bf10cc0741c2348605eec7ce75a49b142c8d59106cf79da98b77511bfd5bd9a9d093a9dd41c3656e34ba319d0ef36c6d2a253ffb97b7ed016d8e270be221a9e27528ab2cb64b27ad65ef200a89c544f164773abd71ff6581488486b44d628f15c542c64f07573042434aa47f6847772060d53758e52965c40541634b6d9c1c5de2c1a1fdddc6920b48ed158e52c9637c9e2f25759b625f2b79c9398bf18b6bfa663b297f68aa00a39fe37c1929add9cfc1c3849fb907975e2503b9f313be9fbdf5f85e26baab013e7beba5de8ee4324fe3e2947e910b606d480203faf7d804981d1a1e947be0091766654d314f0c6a6642c10e26ea5151b0262fc86490fa7cac848f0145ff7e3839960598848e05ce0580d332c06598a3d09626aba2d85f14644bf4c6733389889ff7253873ed30d02a89c71f81807cb36445dcb9911ebbd15023d254acc73796eb98a49b9d6cd3d7a9f34a00540e0d9c241fd3627d8a6593b4682aa4803285657f49699b1e43a58f9e9c9669aba2a3c3cc55f4a4902b0247bf40525566e0091b351bfa0859778b70cd813a8b78c63a8c94379e4bb3db45c00028c2e2e15b0422ad582d095889b62cee27279a90f31005f57d05cd2ab992b313be0c07dc0987e1014b571eef609d8ef54edeed64bb077a037d1a65c65799800547f621253641ba7312dcbd103ba604b2342f8c9acbd73783c677677073119d3ee23132a25dfb556093c143ee5441fe6ccf6ca96e1a6f17a11cb875dc388174733aa8c4c044811a583f2dc7c251c1db7d916299cfffa34ef70d68a3cc8fb6b0f34f0861e725800addd54f790d32b81bcb2934c36707278b68f1a2d4d98edf2b5f846cab917e11d1900cc52d1efb3de78f548899b3a9c2b6222aeb53870917dcd1cccc0daecfadb44346fa9ca2a333ad52dd88b0662bc356f3c3e54f5b079c0502be0d7ee78d52ecba135e1ef1e795a1a72e3ec0e5b7dbdd90ae23fa1e8cea11860ea71917dab65f997e5b27f2d66f6667f0384140cbb1387defe9cda4126023b099e0aff6ccc8d7841b4b4579edac4f2e4ec6a121decfcada0730fd4bcca64264928125f53331f6f6475e508a4659d3e5d8ad4b194f82384634f89f7ce3e519c7e4d72f3e7e8c6aa683fb2f122fdbc498a7e4b99dc0ea782433dcd2337d140278dc6dd5b088c5c5b0cd8c95db6d3135073684824c612f481588058b47a28a9f62cb4462f5d8f15d7aafed67d3b61b35151671ea7f4d9ac46fd6ccf61dc554a8c68d65de4707638bfa015b2e9a0854ebe510c586c61218472452485a9f2354749572a699d9c987272dfc35a926655b7820733d09ebdd1b743c915370c651246de68e36046ec022a7a7424f34b09abc1a44749a1dc438316c2e4f3e6bc5a6c138ffd7fbe94776d344947a3329010e7abb42c85b4a28006f20d378bde4f7d2797957ce603427239bdeee3d4eb46187604d124f986089744146f96f42495b1efe9628ae9cec507f33bc7505d08a65a84eb561cf636607ef913c3b6fecc6a5f62ae2bc4d8ef538025ec90a2714d4243e8f124b58897504ce115d7f54c3153dc2c5cba238bef62cb4ec278554882998c01f775bc13a450ad62cbd5935306b6eb3d292211d2a55015f6aa61f2cfb3c2d1ca3be506e1155f52c15789e0ecdae772c54be849c600f2fd63459609374fc7cddb0b5c2090e6c9ac02952b16bb4d56e006c8d5a108d4cc0b86cf09d24de64756c3e7b015c438d1d164aa78b9057d49a677590439336f7556040442f9c37f8141aae79cc7e04e98920529c09d7411983b03a8354f944199984038830c53ed2696bf9a1d2717c0bb582c615f06c3e50e5bf73270953b190fb7e5354505983adebbe524cace7a9c76e2159ad6e9e05d7c77b45386a2020a4d70bf9e0a665e37ffc2df3b1ed92a9d3c53e0109a632d6a6a2ce2936e189751559b6e2242ace78b03a8a541e91fad6799bcbd0a0785664475bdcb17fec77f316c19431a5fc168c433b860f9f193049db047fb3efced02bb9794d41a4bc37509e6e3c344dac625e82f6d58f93d6e3b33041ce3d1e09dd6deb6f3a3a4fb323c3f3a16a41e9c656e3d23bc735288c730ad452f41f025292ac08f3d7bca6faa52c1265f410685a954593f57914c892097b55654feb7556c2f2639e345eb9681f00fc2c90a2d4aba32b5c1859a5c524a244b13a9de0bd030e3d6be2c56116041485e72092cda0fc68e51a9e4907028316857a4123d4fdd71e5a29e0b63d7a90919514918b239a565693813ea3414dabbd2e56ace3d84f4df048ec6db8a2fe8017070eca690f2251c9735b97fe4ffcd7639f2f1a5385fc09dc5eb3cb412f4fe342687313bfaf1438154c633cc3c682654319ee0be4ad488bd7917d8b6128926b4f6b6667acd125b7cf332c4d7ef60bee9d436cd2b4848aef0ae36d56d145781cae018ac709775b4fcff2c018bea8956c4915039d3c8d4497cffb0e64a64ec54a29cfc600ba4da78f546373cfd860bdbf67b99c104a98b408e28dd17d4642902d98021d9ce721584855dd2407aa7390684b06fc3c39fbeac9fec0e521b7c47971755e0f9d87f591d647db25e41e5aa247ec05b1f84f4bbd2e10d1765d2482a82c3c0aa52e1c947cbb10a8ddb42547ce2b57801454cc8d671c0183ef343b7d2a84bb8603206789dcc1e7d7e995ce85b6ce7987ca29e51f75e65167a5157a6bbc698cbfc4f30b7788532695422c703d5c62fc5d03a316e1a912ad2a2ecfb91a28d7a3711afcc8e28407a7ec2a281cb0a0befe11c42daa1cf6f3c1fc8e2e7c791310aaf69dadc77a7091689fce707def8df67c8739b4fc0f6fc927ae37284aae1019e32b7b87d820ff54393fa1bc1bb89c349618a1af2def5166490067448533a1b734dd5f4ca34ffe610530ae08d34a14fc0d2f397e09e28ef5ff2a66535912e31e62aba5859a775b5e382ebe9d21ac06f7126359f00354bf6478aea5177a1354d7dff39b40bf5062d8dcc0ad2697f793785cfa2b47cad1e568d8c06d75a719577c45a8d71216c07a7e7c8395107e3b165c6440d8b0a9c91c1033d2a8504da1431b1a3b15c3947474c16e2cd3fb870f39af85b1832fc1481629e94f04f2c9e9ad9153192899d98f060cd74fa58d9099bdf392954aad008ba92d240fcff672c525f5c48de00a270d4b7518f7176f8db5b3c415bf1dd0a6f6ef65f51248834e61d35d7321bb4c3f4258300e8eace09dcd014d5d95d9b57c075de086d345eac21b48b9012900e1753aa6144cadd559256cc1fae865403a92e59d3dc1621375a8994ea722e3e1e3672fe01413538b41f153226bc8aee266c92a64006f64c5bb25b39417316c5989794e5058fa1c2648d1878f39116ee3550d18db49accf0446ed58eb81bb1435b0e7571b0326cd54a1fc70810cfba35463577133306ef89c905018df32734f5b4b45e888ba1d8a02ef76f3c68575ae03982c81bfb3b14ff934e0a9e06bd84a25d4524b70b6009555efd30a76cc1863bb2916a862474dd7748e05b8775df24979b253aeecbb113de7d5cd3bd30e392b77d2feed999d3aedee295b135d04758d8142917c23a125cf73cea58f05963b7faf7558fc7e01712d9872c2addea750b327d9c0aa5691392b72251a124c25caf9ae3059ecc7561b588b1bf3551c9bc762bce5216b5c7b5f3ea0673f70acb01bea7e719458606491150aaf269a99a99d3dbef721c85cc1c28441b42fbb366cf30183f1c0fe482d7575cb634bb2bb99d28cee69c81eb35ad2dff83d24443195c5aea86c822c14dee1821f8635482befb8492f491f8717e464f8d8f18a30b5da41e4921e330e4b858812a478750283f551417fe61a8cc3dad8b7d9c38916229a05d4a7cc860cce5101cc5525cd6cb6c9c92c6fef3379f54db9566b6644bcc77e5181ed4667c9b7dff66b3b28ccc7f5e07bba4ab8424a8b1ddf2b0dbab9e2abf97e701d9cd0d385d46093732fc2894d1312a7f122e31883347cda68a2214d68f0142b6d7772b7a4a0a736e9e9cac884e5321253f6b57111da4d859caccb39ae97afc622f04552a54bd30cd4a332695f314928ae5631c2a6a8f68dcae86dfe181ccc97de9b5387de24353dbc27365d390059a706783f6fc9868a273bd9a4bd4cfb19dff2282a53868f08d2e0956d8b6ab92c64e8e49a5a63e0b26445ae7b73d9e35ccea7eecbb418a19a3b2eacde96df48db17e293f5d5a06a9672b6140314520c2532dce44c19db6464772c24edb4001904184647af1edb84f7affdb347ca923fc5a7595d7ab3a3a8dbcf110e3eb1146b3e1aeb2644e13dcd7c47b20ea3d0a60e3b8661b6ca47271dbb63c93864e63626d726e19f87d07f2f46186689558425ae1fc0fb4df1bd9462229cc188dc5e7a2fc8bf0a2363d4e9e8ffb7207509cfa460cd09b10830860519982401ba27b0d334562a0a68111ff33036058fc71554912f9fb3fdef6b019d3adf26e4a616a7ed5f0c85f1bd0dd17d84d0661d30b50644d0e77533094af0479a43b45af04f51f6f73fe711d113c43b10807758f1d704aa1594be0510c0b22114b7c1ff13189102bfdb256d9ba1e32ae76d792fc0a25d39b78622a10283a6ae8d51b53fbc695c9f6b33b995a0ec6fca48e4e91bbcc81fd386ebe58b7c030c014e4104011848037d354c6f6daaf61f311fa37162fac959de24284457a1e09dd08ee17572ef9e6ef581c224d2b4e04049af9f4c811afbf03c8e1435fd8078b124a739522b9fd5c1de5a47b03b6226a2e8e4a196db65a1a39609970794f916c2747d72f1ba88806d472808fb0bb80a1da73cf436b88caea4c7fa3a56c5e45b51ce0b0f345d4a806ffe6b86f064fec454bef7682ea7912f2b580b21e374615d986c734a261b8fc86f2d39552fcd99b82379115e528acf9a1e30437e5045445b406425acb1cf7ba197ab6a6e47443a896b51250231b32578957745aa2b984a4318e185fe6c6bf26f34a9a233e7ebc4e3015bee4c90eb7e85b056edaabcad458c52639b9932c9d2bead40e644010c1defedf2d75a6752e6808b6ebf598d3580f11edc730e44caf5df8bff01a6b240bddb2a919d4cac618903734d7a082b8a6fee0f815d931e1b4f477f6496faa19fe469f10d60353517e2f5c66f78d6a63c213c5531f4c84a8ec6eafba1181829a1a99baed745e56be802d351b336262482917a7f97a34497ce4ae59dd9a8471ca4e902113bd0d80b77b504ba72356dbb13b37606d31c41fff54e2713f9406d693101b9ff3add507d728ef308af7d489099420bfcadf342c0decffbcaca99bacdc885f7fd639d0e96de08db6d93f71ba3c7b6171bf4a8a26be72d6e3a6f453affbac6e7eef9679fe3be09e43f70bd5b328377f93490c5ac0fbc69a1513723395f500b73fcc044f106b9c2ab9f16ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
