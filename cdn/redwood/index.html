<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c4adb38cfbd222dabcfa11fb34e2c0e73600b42ab87bd88b5266923a7036580c5c4570b33574dd098765de2b6b09a8c025e8f60dc61a4410df891f2d27f32ad901051ceee55658dec40740cd9ddec0fcd788c0969e61aa9ff57749de7c27ecb7eac744c72641e976cb15a0a4cee14c16a230c409837133d9aec3d3f765856fec6bef2f370b99368b3dfc847920e9d724d1957d2caf5a68c9e3f2874c0d9337be335f1721fc652d2e61c27e14a6d9f6da7c73cc9e0881ffe6c58a3de28b0e5a3fb062b485cc284bf3008ea8bc19e8902880384cb1abbb261a96407b70c57b1edf260cf37edb7cc147e50f8f64d5c93c29edce7386c217c2c457974a698e86d6a3a4467a7b70f81c9a17d19903dbb055eff327f9304c25031a55bb2851110f9a84bacd3cd03ca03d98db5d82de6adbdf782e62cfb9dcf764929648c5869467384a608c691df59336f948ac6a1e089d1a05154e9298c8a29883c05f57a3b10d28043f72747b879f425cf37af7565e26567973e77a1a6fc9c77f830913c85bd1162e5118f446f6b2ea5e33d1802b42178394948bbd3dabaa397849c4f5b885b85320a61e2969ea2ae1629cbb20122a761cd48f1138665f6d0f3fe7bb85eaa5fcd87d22ffbd29b8ddeb31c0a8f0a9b9a8df8782e19c5fdf3dfd551d89bba088b4b2244182d5cdfc08f487326c665f864dbcf12af24e7bb3d963d9ea04f4abd00158a29b744b47772924effecb05f1343ea4eb06d6a4cabb21ac6fd00c975fdbe1969953d7859f4b749b55cb83ac96fe9bff0d1ed1f43c562c05860b2730decf30b6899348782a52eaf9126ff77e9e400a257058e4edafad6efe3cafeff72493512104ea5e879c6a20706f400c54f180c916f79064aee9502409aceb9a68ea6d9cf1a5631621c2eb1095dc9af7460532771ca060a82cf7a4703204ce8dff59ad471f357dcf4a2346f0b54e6bbf66fa06694a74d28e215a6df3fb77ad1039e351b6624bf2bcefb760b2e7b82b461895a3a506ec071706a29faea04e8e4a4aa2908557dc1222389871f9e611df592716244048b7d157067b854d5c3393f296ae441fdfe5e3e3c54ce1287fd643f93b3817a183457e2a40c36cbe1efaa50c9f14c76553906ca24dd04bdfb036dd173fed74a2b662aa2e78ec21d0dd0407c95ca2f676b9b3ce7b371a737e41734c0067ce8f8bd2522a2de12c7d1cc097abf09b64740e9f00285ee8d9730a9f1c62d51e87d5baa38607c25f4f4a92159f1ee23476452efb0d3a59b9297ae908621557231502427647294926c4c4e686c2c8c35c8133bfad84d477c112cfba0e5e67737e21aff94e272132e04a78168601366397b88738d12d2878fcfb2a2ee1c6b942f8a0327a881b63f0a9d3b7c1289a4d3a33a77d71889b5bd53fff5758ce8683e34808ba48fcec5924f8eb7758ba9c6b4b7f65402459e25328168268c931c3c5c5c690346bfd5d49b1d56d78b5987ccf6d167f3dbebaf4736d492bff26948608a938c6c0cb181a2b7c5a69f3ec0dac65da70a05aa24daa58ef60c99e57535db19b84f0e36e1c1c1d52f45af48ce9dd1c8206193475237a00862cff1b839552e33b00bf6058854b0786e0bdd327aac4e6c971585e6613a56bac662066c955db4e288ebb111a3e08cea873050d7bef1942997c4c6508fcb0e1ad7365ba3412af02e157fc05b9d4f6899f8cf106a00ad3e3d7f8cc7cbfd57b876ed695a6be675519d67a2e869ba69bb3cbe30eed35e5de51ece44537bdf32d7411c51b60d12be14f809db327f2b007ef5f17b86ba152763b9bd88c4af1c0c64e84f520ede6c7df642414d7432bfb8c7fc4fc2a257a5b9713c86cdeb2f6bcf19c3815dbd466ae1646a964734493bec19d047bb29e93524bf71ada5c3d3d54c30554c816c2589ea5d411e762c5e79f8664acd63c54cdaf4044cc8a88e6c19bf988be89484dee26aff6fd13ee66a0200fdeed80b48f46a047e89652ae83fffd04cb6e543f9f27e99191a4cc3e2b44cad7f7b55aec5fbdcbe5f55b7aa3c1d492ff366080bfce17321847064a199313c77d9048b725825581b2c19c46ffa7e09859e0632fbc6cd9c1bd965846f88e2bde48c6b7b2acab7ffaf41b286ce3cd41c87676ea863adfc29e6be2173e99d6e013e22f3750840d6ace96a388175bb60d3488ca0aa8f47f41086efa7af87151d9a8a8c77799ca7b7d7b41903f49d9affa5a4c6ca312ac453d65ba261d28fd33967b97f403ba5de38aff5d6f71b6141889c93650ccb71423abf975a40393b7d2a2930780d2d6143fcf4a653141288911d6f25e605ebc8f3d9359129cf5edb35cc2dba3dca613863fa7f4b352e4390ed2159c78c9d30b5e796c2fcd075aefdec4b00c5cce76838ce79bac7039bb43b5a41b6ed20550a7d1ce9cd188e3c9cb65307d34e9f99da05965ce50b1f6815de2a84f1220af1aaf7e4ce94bbc9f008011e73b3bd968fa9a6de6faa3e494d1c87ba4621cd2fb10ca56e5fb762bd42d54963fb3049dd94976d8fcd523f66bae23ac1e425a7b6e9b3a69345f210c82b405047832e58abb64ccf666268f40aadaf462a7ddbd8446b40829e6a2fd9bc5bf2c7fd4968c137bf9d39db51afa580bae7215372ee4bc828a087a641102446c01375998d0c9ea765788f4fa53314d893c1bc6c80a1f73e12450e235a4114dfe7759e51e70ea9baaab20198d63a540e08fbd4ff06983899ddd96cd4586c7bc682d6e58d9576b8af49bc78042961f75f5bb147c9144658cfd9efe36c1bb8c8412917d169839e2d846251b83de601be1763348efe41fa257a85b932b4a395cc30d246a9fc22fcc1edf83a7b0890e4a8110b0f06a808ae967f8b4e4fb551d7ce2dfc9fd77023deb43ee81419178987648285d1ab18b982d46ae997550f7b84dedfafca690f6e833596bbab67d9a59c22a47af1b133a44409315e3a003c7a694458b1ef67ee934d4a589c64f4c21467b1c1013af0be89785dd1fe2c6d6a3bfab4c099418ad6f5ea19426a058553981bbe48849dcb40158b106e6cfde934438964779db4d2497537d94d22ef44156f7767e231d9d1e987d21d22c868346c7472286c73eebcd2b2bd94af632a5a780de9cb7680508de9420e2fe8e213097df05365921ad11b53f7ed3bb1d865c7830d83197752d3701c8b55a384ba4b5174f676feb0f9866a5fc934bb9e4e9326c2a5d4b7de66fa2f0df4a221af4027999124e797bc766a7abaacd3dc5261a789a64acf4c76080ba453898819321bebeec68d7f4907f40dd85136dc9c085bb556c54f9272d4404db44dd3d109c098283320a2ff2ee1856abc7030c073d4ade4d29f8ec6278be3929bbe529d74e91bede07f7207ad8b0ad55d2e6ec48d3d673fa53f199ef714244900356f53e6bf1b72df632562c0ef40da8d5fb56a1eef2ae847a40ff0b0f297aa6d67f381ec5f9ae8f8378f5b2db9541bc2152191b50d017d98f092d8a92b08c2ae2c714765f09f4becbaad9840521f9bc3a2d0ade265fedb89397ec68176a56d351ffa2fa751b6e17af4e4a42c73c76544568f05396c208cbf023065609a5b4b7ad7a8141d5d9ea858f91b3c2fa12f627a66c12e79efddedbd0e82f3776d640697ce3e184d2cab1fdf61196d0d087832bd88d771d0fecbbde2957bc65052986ac421d3b5fc54137407dbae6b6ddba3d6c23760f3cb71ec168f37901809a9ee7f4d1e9efc8a388690d323095bd202535bad93257da08cbd8e8070970daabc89b5167fae4f4e2a53d89cfbe0b1164781bf1fe006112f70a68cd41bcb240675ce130cf38a0060ef96f961a6d8a0cc78c1c6f0d2368fb36697ddce9b045ee34d8a81edefc85d8e04006dea7e51a973910c09adad0f62e89b95fc912d90a8ad9de6d05a21619eb33c193786c64981ed05b7907a14f6df24106c7fbd4fb28b204c35ce69ac335507a4bab09a80f57dc5ffaabeb808e1aa2418f31a759c9076e16d71d2e361c273072f0e178fad13126500e4d75c160c490e559fd5f1b0ea26950c7d763016b0dc69986a8f57451383f15a3757900fbc335619a92101f51d47a6c25a1127f0eb7105a7a5efa5ea60f620c76dc2ecc8cfb351932360586fadf0fdbfeaafd5cb4f83dea5eb40fc4305444a6b4ca015fef2a7e123dc1cad20e422a26164ccb455e96c9572bdf3e0749c5309f06fb97ddca8dc9104ace3ddea573d1c5fae7951a17ae5be10d6eb14ad5f4540cc88eef88b782a5a8c62c2710a18983dcf46528e5a266a06b319d04c3cda2aab19aee58dbf2b82f78328a1b769faed3cd2a1c544722c7a19b7f019c2bb59b56951ff6d05bc5abe09d8142ab6f6bd81678214cdaa39714b350fbd51ac1e6b9ef365625711f8bee27a94b46551c0abc043cb356e4bf107224780111e213cd6d257d2faed27d6263955ca3f641dd2f68685ab56e9d9fbae0e4c4f7fd9b97b1305e75451811d0e299c017a03ab8c8dfe0982cc39dc14145737664458f91daeaffb6c25aadc6d7f6b6fb21eb365538a68d447c622e8737efede9d1d1e9d9bd4336f2578aebe842a107ecead03d2edc48f0f619f3e4a77a46d12299dfe1c0debf95cbc77cf887480c4d59d2fdffd4120d00a120479cf670a0b088759c7e5373d49a5a716e12fc0afa86c8c34eeaf17e4687d89a14d8b42c3eee0cfd096e763072aca1799665f5b2f0c0bf04ce83eadd345c0df9f4487e793c985ba2724750a978cbadbfcfd016b0b3ed49988b36d2f315f89119c609f88dea838a86d11a416183abaa9049c22bfd5a4e9077cbdf675097cc51fbcdb5c5754c5d41c8daaf420484816ee11c193061a5025e458fc73424c67d83f973e6300d8414d5c07b2bde15889560d3e4ab84578e99b90227f74a6dd1944e68557bade1904bca14eac6c1d65db831111fa93bea0530e7fea32cb2e13f8da4aedea10cf8beabd0de63b766d973088ead349984868bbcff230822f2290ba75c86e8ab2070614f410e60ee643a92622ce80432284cefa42b227b4a35a8dc9cfef50f50b76599d192e9faa3c63317cedd276ad88694c958ef96bebf8662775b77223fa9ee4595a9730e4e5515230beabbb784ea0abd90f64b55b2c2edbfc8466a123873a6b088c6be7b3c25512f9deb2ba652319fef65b6dfc9b81b16f31d3c6fb4706d01335a8b7504cf53553ae15b1706b4cedffd2a449d582dc22c7203e28878cdd891d2c76bdf5b3eee276c8712ac6308663ae3deb77e5669e8b69bacf7636976d738d8fea8103727a4a55eccfda97c18200cbe35fa8c10abaeaee2caacfa1596b3fc28f4d54a5a030bb123761e2ec6dfbcb8b969ac05d078a1354c46fa0e9887d20b96df00a7d3c1e5d5713bf3ed8e1a297c909b75f5be45d74f17ced47e21f635c625ecaa8bf49f6fce87d7efb3c38608b5255f2b7e2ee576d0620360d0382ff581363541b202c23deaaef7ef1b718f0de928ab0f7256663e84041fbbd2980aef4c688096de609fc95ced27e590666545d51e1a5098594f036819c00ea24ef90ec89c94f59783ce4ba1045c0d218b79be5f2b98e7d1c4f85d6429dac8b01c0f28e88cbc6d1cc46dd8d8224973739d5e92864820ce62c3bdd2f37c756caebd8b5b5fdb990e00675ce465db23cc7bed28c7caec9826032609c5fab0e165885b9c675e27baa80bec547fdb5bc3b61bfa92024bc2c853ffd62f6b340bc592b6d7b94f5308c4e8570dfa6176dff446be2495842dcc673a283130008f56fdc85b67910deb3371a3d14b8964eef59452a64356b65aab3f837bc50d48663bca23bf93aca5568ce0f85235dda019bd2c380da111946b4584e897b7017d24e1bd7bfa3ce7105c4de5566c60bd3fcac18d78e91731794f08673a42322887ebb69351e1699b74416483d9a9b87710e30380103de6fed217c2e2127a76de349d0bf18c35e9c8f3d1e043c7fe51cfa7c1e0796a27f71cc4d7b915200376c250c99f7ef91871596ad84428c00eac04acbcb788c69ca8577f92fe30732ea9e84779cf47f9098e9e88b243e22539677456215658c538f27cedf386c38195ba40e1110fca14a08377d73750499aded6a52fae091cf6bd2a7c0f01c58fa8f64d255c6a767d97112a2c1cf388bae06a5560fc5403ab9d026a452d83071af959efae2012971e14b02e0fe51f5dda5ff15438c277b2e1a4bf9807c84f8fdbb354434774466ba913271d1fe8ee6b45d71d98b234d8a39bdb2e79e3c317e78e18b03382243c0403ed04885b15a04afced3339c9697b06b267818444f7267b941ad7cc1014a7447b40d197e955bf751c264d6cdc2235ee50cd53d15f4a5f12ff2fb0b5416b67b35b39fac48b1d4c453ade1c5e1f75fbb1ff3793b96eb7a14e9f85f37f11970fe882addf161977fe0cf63f7dd1b3b036a3133b3bfd16c751bd99118a9d6cda0fb0ec4826ece459c5d63e9467aeb52be1eb6ef20b6017fe4860483016e7670ff5c9dcb42612410fdab468ad0945ce2dd7cfc60d9528facd7f7fd766b3e10d6b36d817ed46fdb8cae4479a708f98582f10320aea1e58d9b898a9f8318209c5e2f8276a539283ac3401378f841b1546d73d1ca31c1ca5d92a36b2b58b7ebafe822637aa5476660e8595e509b25e17f495fea9dcbb3b939c67847da3fb8ad48c9be5351d008d503edc832b4a9ab4299b1a282de0907c96039fb0610b85a81a555fa9015ac40b052c08da2727d82cc3c266a7937b9e6a3dcda46b35d3a59add499cbb618e0cc4e809ffd68ff36368eecd842c568f321507c11f1522b071f99c4ae7d4d01d12490cf0bea1c6c8e86e814cb8d6649fe199e7941f05316d095d9ccf003bee6fda211ab0e08b95f8807dc26abf9bd014a8bf33398b8b89670d369af53e8beb17514eb1496ee0987e6e3aea2b78fa082db0b2253ffb7aa7d74ebad2205bb80a2cdb9f3131fe48dc737909783fd0a31abde08c9403d3ff1f65bfea8784424c65c3c0d6ad06b7aaad5b6cc4349527979a4422fafe13b29e23d210599233a532d12244637ae20ac2d1a49f2e5d7b4d8e0b84279e5674617d0f9def7893d33122605dc7ffda36f479ea4403ea428424349330016cd2d7aacd40f6fb3b85af7b2edcd75e1f282f06a8facb2cd1d2d484545f5ff08507ad4672f66ba679d5cc68ea0fee609a0f9af661dad4b17b84e53af7f1ee617883aba3b8fa94ef676540c844dfb336dad19ef216269059751e3939c94061bfcf7d7630b0f767e838ffaf5c9d2aceb13c92ed9d02bbac3c0e2753c5cd6bb5c564129192e51ccfaec3334f898816f1689131bd9b035485f5decb89c573357292f9f29d328f32c555dd6e39f07b67b57283865b1a2928ec0dad6d76d918d2b9d8f7c395a7482011521c06423a271fcf3509ce4313f1017e8b2bd4ad2b8bd4ffdf122e7bf02ae10089e6677f57615357b2a9c4fdd7a3dc5213e1a07d23686c6331e3795bc1a34740a7fcfaa27caf9d1a09cdd9c7aa23c8e4c5fbf7033db289b171166969ab2bf50144f6152fcde1843598b430853ea90ae11c7da96ae72903c4be174cd609e8e970c429f68c6de424f0563b0dba95c286907387973b8cdc221221f6ec603ca2423eafdbb783c155a0bd70534985d25c98709d550c91feb6a4978ba624034b865b40bd9e77a607220405e4c5cc54057d08abc4d71266b0282828f28879cf5178ffb69f58531c61c241411cfd2096d4a3c86525ce22edbf40a08cb2ee3deaa630b0fd308df85eead936793d6e6cc0a267025f46ac5c7db2c9affff4793c2df4f64dce0dbc86af21690a5996b0c6a8dac3974fdae8a72df61e1c1e36e947a38482b99b759b803d981bd0e191818128da428662e9705a6769618d03c28ab645d2b4143b4c705cd496714417d0f7492497bdff216ccf6ab22bba61cb4197a23a8bf49597bbc4d92d9ecfa3089c8a90daac98f1ef4e88115669dc80094fa7c65d799a99d294d4879efe31074181957f321052b0c4ddefb2cadb92b5e9db7d1c69122e5f9a1abcc26b2c23f5e36a5a60d4a494ff267dd1c027d2e765a94b4439fb9d00c535c4be282b47a5e5b2ca997b91074f2d9d87990a7d0d79d30ea54b666a9ae4c0c1d94dd17faac0ec17919c7117949f750352840efac95b5f8d9787e068d64a33337d8843a09e3f506cc70ef78e5250ebf0008f921bc130c571958ec7cd7f0b7e2a5098f06d4bb145158b7b42cf22231b08e0623be7ae1cf41f25b0f6a430f3f17fb3d35fe1adbf7c9f812572a856fa599e646b66bf64d1ad94160bee71d7f944529ae76342e9772c6e4df1819d61bd945ab7ff6948e7434bc00e1ba1cff1cfffbc03a3119a0d7c65b7555aba785b3091e498f2b1175786fda320610030e48894bff8b4ac5c1e026f17e41eabeac3e896c229e653bcf4b3337321da65730656f5d1777f0be0e5d445f7642d5e85720dad78e59d43074e3dd1a6c3ffdc3b489f2837dd3b8e5de2a9ea27dbad15cd1761b9416635338a0aef8f676cfd8b2cca9601edc4a3b9419a4138d2cf510f93b19e0e9271018e1124ea86f6a88f6146e594d45a82eb872eeb8f35846bf4d4df6f774a82a45964438419dd2b142f012c69f5e6af452a312b9b551f5914b3796ca9f29339017278218e0547f44ba167c8d8ef02c830e10d52d502e4d8402101197e2d6982b1ee79dc4076d3b469c0001cc319b4e1e12ad2212acd4e6728c3cff2a6dec77aaa3e1d74d14371ea9fec9f168eae8306a76947a59a5e87f8317758a9375d6624ca15eb5dbaa4060b9c620ce796e6ecd714e5d3129c96fce45f36f5f25f37ddcb8c37e9b30fc6bc126eb960ffebc59cffe654c13eb95610ad51709f50db98866838ec4934249abe7be728868e6808e89de55555908454085514d39a8a3cfe39b4008bc4b34561d2bac46d74daac268528d98c8f5d1b1be5160d3a39d0890e40139bc8739adb53b50769bc9d7fa6cc1578ca1638875de3da7d068cbc1b410269c665e0a315392dbd4e53f3915391d69e107f59964475e7f8e59ceff5c9023e992f54d6dabb75a8514d80ced130b9261f44d96d94ea9b46a97a71a55738f35ef1b7c050a3fa01dbfdfc9bc9f8bfb05eac1ab4c8e4702aae921af78f353ba95c58d6ffa409a78d252643e7208a7167b8888261bc235e630f35d0c6dcfb81af3aaac9fddb7d59b3b9a77be6d0c5390817ef1b508ee6707face3c677192978b24425597d47c9242ae44e5523bbd548d8beb8ed67ef992c71f0dd70f125189e826f5631a43344faff7ff42700bc64cd388df2fb866dc94d470faaed59ed3323a7f62e7787e9685ddae36180d096adfa0c347996f167d13e07896ec6ae57709baa380feadafb0d635fd6ff39857c97dd1a9f0d539618b3d0ca2e850cfa3ab3150a6b8201c5fa9093053e37c1b54b5399500d2b8872806550bc216a3b74e1edb9c551066012715b78286ccc47b217d70d3764934173b85b854992a4f87cafabb7c096bfa3d24e9a96cb682e5ef9f49e3ab795307fb463b2e15dbe1c219df54337590d37983595cadae93424d20e2a9e7c8280f5156218a123b664140211c82284027993f7ef90fabdee51d67a0dfd68fa60f0140766bcf8849c5f4963f41bb4a8950947582a54da12e4180a06fc4afab96e106a2bcb3d8620c1e3530a65567ad58d0d3d781649e2a5e238ad4ca81405dfbf3b562d31b5e5b9dd7c774bcde37a737cf3be12e97754a76d5551952d348eb08f47afe666074ccfe35161144c1e63bcc9f4bad5cbc26c0dd3caba55c11dcbe82dadf7e71d2a13e0cd7e9e720bf0c2e806ee8173a6700e7fce9609bad27abe2e9ee39266cb7e5bf02781439411254d3f9aaf36a5752a4da7d86b7859059017939200a2413147e107b942b561b2a6ab6e477801e3d827127160a9829f9e3cfafb3cc3518675c5a398d28c6a7e316e1a1297c7926f5e2c85a74edcc2a0b8cdd88d2d5e3482c31e43dffbf64f62066af2892ee684c76b693e659db9dbfbd26c1e4ee28c18d7c938d2a081ac696897515441137b4a8b33747371747193d03502799a4dd284631f97c73606d0adc5f8c695873b084c63f53ed210a6808193189a0c2c7af85e1077419cb49192f47051786862524f8f624396620059aec9536ef84e31726a4553c498d675248d40cdeb8192075d24444c68c82fefa21727657586d032b40435fd28d60d5963bcfd0ead359738177fff2a308c7a9868e52b41c2240a76592109ce620660494fd8173eb75df4752956de393de9438e1b48e4d595e5842b710451b7051362b52b89d722c0544a17cd22ea107b996b19ecf0f7b3f75ae9ff012ebf9d4fcc8bc0c2c2da577cc177ad67d2a07f6f86463b962b5347d0979dc893ca4f4279dd7cc315da9d49146cfee52053225469408437ec8501bcb58dc78261e3b6b8146046dd05ec5fd46b2ebca3bec74501acb6461133c95bb30b3b76ffcc98ab15637b2c68fe7d5c1b56461aee680ce38b1483ba3a409ea6a2cfdf9c4c728298c47e9e16f1d74fbb096aea50ed67693e63bfe6f27105ef20375ada4d5772a01404af129d37214c985b12dcfc51d94b7e16d428b6966951a64c1956e0d5067a6fab9668ae16bda1644efcaf2d3cd29251abd50aec9b690e69d1dca09d03b0f4b3dbc2d218c258727a25bfa1c4a7f50467a0963e0e58dd9321aea4e1955b330a65080679af116e55ac84528efe5e86da8d8bc592dbf1c620e8953cb007dfebda56c612e4bb78b8d9b0e5f2fa3071a63aa3d5de699b23976f00a3f50e447b4bc556f0245d6d445375d6dd0341214352156bbfc4cd76b032192952377b9ea2c913bca05d0dcb87055c60763755f56243eebbbde41b8a062edc915486a00e2ffda82d49be5d312ac4a4bc2aa7f818bbcb021f5fecf6ccb680671ecc1008dbe4bc2a6daf34641fec038b4337a487ae77ed3ec4051edf7c499cb40d41b7490b2f5948e292b1c1b9d7197b1b2abe1d23c00eb0ad49c53ef31901b44fd022d23f65a8a599f5a6235bd7e13f7b773dba070fbdba296edb463e3dd890e62ea8badf1df94b6ecf25d9aaa3b2f28431edde1ad28002ca4e94d788807bde1921b448b898a5f547f086bc1edd5c54524aacc149af12fc88aa662ba32d9e5ebd24f08f101ef5ecac89188b08b052d1e84d18310e7162776f241429caff48342de6809dee798b8efcebfa74b55f71e7b517f2d2a7d64a84c1f83edf3d36ea0fbaa8739824c2437ca4dac091221038120694780983ee5fabcaf7329c2d9e3492f0996acd28f5d00fa2cbd23b347a0a9ff86d5b2f57fd8d7d6740b9514e3d7b62960b8436b93e22463f17523080c5c738b2877845745bf43a3d48e3e1ffe1c7430a2ac2734eac3d629c0434141b02c08d78d003460ea6f6110ea24821839ab79625955d58f82423a049ca15fb705d88474af02688fe6b6e0e885128d84f7bbf9f33ba30ce275fa58fcd8b2662599735cededdf29e981d1cd13e6f380e587531cb3fec0d3af53c6579f2a3b129d88e52f139c1ea22df3e53dd99fbf3fb967acf1b0f7a5805e5afe046a342069274e2137f03cdda6a7881189195f5478e8e76ab9b2d1b85b0db899fafbb5f2a0ba1bce7a9f09d386d53fc8d6459ee3ec341305705d29b6367b7e6d35bb60f670af252b34403b800328cfa98a1b8dc8f49cffccd8662ef3a80f37f073914f885c2681532cd7ed20d7133088790a5c01c79b5ab386532a2aab929556d2de442465642cc44d76e029199680fee50e535a578081f8b7610b074f261378a6aa6f4ee6c351da204716f2477ff253dc64d22c9742efad853d54144d91065ec1cc7638fbd7b6c8341e9015aa046cca9bc4f7b30de8d15f4b0f6fd71e6475a10b8cd379736f0306ccf2cac488c99c31c0e46957d8bc521cfb9ef710cff2c80fc75eb6d35443c25ad5255b034fa4589f0515661ea3f6e3288c6311d40bd65e93fb94d7fc7aed3b1d4fa640ab6607c2d4636d390ab42d33440be003cf51352478596f469cfad36e51ba7b924243fd6ddb277566b252015b23ce504fb6b48c767248847a1ec7a0b5dc45cd37db0ca9eeee4a74b76be2567ec22f4e205950ed3cd9e66f38945fe961174810961bf88b30b8dfb5f1379faccc030bdc795614481913a30be5b9bd7a2fef0ef7912b03f4dcca24f2e554c4f9bc64087544ddd9e0add52793cc0b6bfa2fbd93f63a3d842916fffa3144c6bfd4bcb79def7ef147bbc68566b4964e5a166e7d513dbc51781a5f83280c1b12052525c08d8904d3aa86391c6744f29928e82e56598bb734fd22c2c0a70454793ab7567a5625b480ff1c1a6958ae7769ee2d897e4b6eede95bc3e62cf041e544d1da3c3af4d1f57ce6b0092d9ce0c47bff5e6de4a82d0e7d0e0a77e23ab558c59a35e0c930ee82a71baf943ea62b66103748f766cbf89095b5e7d043a442a932878e70da70ab1037d60f55e8a2122becc29331195d22be44cb04fb96164608de28b62a98dbf45f6e4722e76c1c4143f48ff1e0b138ebdf484b95c9ae9e2d966f6afa262e5b4aaf9ce2fb28cfe8b1b48004dd64f6a0213f491c79bae9818f0ce9a0fae6cec3193cae2bc9f9c31c87e1bfb4f23711e1d0df3e1bc9a0271f8711d81200dd7def92955b559dcea8545e6073f6fc0e66f8769174436ef29bd097a93371e60e0586ad7eaa40ec97006f2d8dd192974b3619d6d80c2bc3b9c46871c6f1803e65ce4de4aa1e8cefdb9c4d3f89d7174161168ddc5aa0a85012096728ba80612149ca1e04c401d977e50ff0b8718642a08918fa3df25b71ac4c1b3a97b9f16901a9c4628740788798f46a9f7f9b12ba2d102002156e1fcb305cf33c991e26c62af2c4cfc92db20c1baa0ae795da1de60f3f66ceb5f2e232e3d7ddab7e80366856878742a51b0ca74e44500efd26e18d04b7786ec469b9e2a68f58922d12d71accd9cc4fa0214a02db7c3c4375a02c319ab09b726f367164d50a61bfb4c899eb030d307c8da5aa9a198b3588307b02515a96ea7280a1884d9b48e9d4311fbe418983f824eeb6aac41794a8e72ec9590d631ae7c1a57170a53d8564fdbf8abd2bc3c5ca0a171d0575d5f15967d9bda7b50e4d8f7287f82d9f4575c672b29e32b3ae8d3e60b8b10faeeb3c1609bcfb1b5f17d1910ecd360268145bfdcdebeb3bc0b2c3433c10cf854948672884e0e07cd96326b049e172592d38774def3dc9789aa11637b183a3858e21a806f1f9175339514827beb94936788c28ddb0f2732b910ac2fc37f08188e0f87186a3adbe2b117a0728b00cecfd46a29c12c283ab1ad7c2b5a1248284dedf9584beddca860709709c471fd9759a401b9e48afb83f86580932d1a53297c95461ad9152785575949ed42a70d5f40f3e4a3864f875eb2a4adda4aba82d2585bb46dc0b2207b7cabecf6cd209ba8a3be0d343ab65788a1f8098de7d36d0070b6b53be32b3451818d83e713c4df6e7678ad6c15b4e96076459d986367a6be6ec893c856d73b0df88383f62e118f1eb69dc41ac1a4b99d2b6ffffdf8a377de93b96d331354f3d45f937e1dd0e460b6c1e50f0e5de93c55bbe9a8dafc1d342c8377474fc9acb3069537eddb335af6a8349a8c0536b86ba3700469a7f7b39c64f4b3878a747fe2a8d92532c5adbe32e92bf47e77c9ede9ad70526f110ec77d6a586b96e06e79de0087a00e4a2026398b43ed547101da285c1b52fdcce1e5723f4dc07153110c17896466ed1265bd725d2b4dd10aea6c1c1387876be37a2904b4e1a20b1ba62b27d859e32657014669334cf40b038524f6ae3fb80d743cea6cb76cbaa9b90f74467f64837bdea365c9079501e3ec7b07e374c76ad6adacd0b67af306b045b831631862db083c11712b88f61ebfb2e1cda09f418861eb44e2e4361976057bec6ee4c890bf5a66d8f8c574c21094e7869ed7055a368a8a1d578358caa1b42b4b6c0b8b8aad69f5479dd0fba12be3b8a4e5a260f52357d82447ecfefb87056ce187de8672dcd08e33bb54a15e222b1d1d5120f87b0439f858cee8f815e3f705a456d7d611ab03942a4c6f38ae9683483bde2ad3640df0658222169ec49f252d0508ef37c8c8de42213b8b9e71e23366245c82ddb924d991a245facc0a19f9fdbc887aa6d0929fffdceb8a6c5fe748403a835b74af804dfc74638288bb58762c6d5ac7b46bde6ef459ed36f4e216d9617b5a9441b7618838088db360261903e57c66371a84d7751840ae4e81e67174f8cd436e8a9f30a266faafb36d790a3adc2ba12825340de872ddeece22e87b3760ed76b7842919d046901a481d8dbb4e4855fffa01d75de38e1fe90272f97a0f6da5e12d60dd4bff2081d881048b872276b44b076c0a867e85906ea37a5f3eca7023f33494fb97d17a600508b5c4f6e02288a1f326d86230e252ab3c79e9a46fe5a6285df7762664f0ea0ca2718ddcf233fb53523b9a7388e0ac572a6c35590b7f80920bbb11523022364f9846a474249495de70ebdaeaf6961308aec8604b5cbcf909a72e0f1ed6561d2aa7ab9fda9ba3dac4a48063d239c9e8c16599784180f292d817c128af802cf9dc335372e04664b4a3f3c68ed967e4c933eea21f0fee5a5b6999f0c2dde62b630d93f222ada16869ed53ef717f5fb67d4e2cbc78fac3a29fbeaf0dad3413dec423e1eb6187ce72eeff1fea165fac52bc0daae3acca6772fe556ef9e6793288e61a7ab466adb2f74c6b58b993e4f8a82a557df17d8f18ce832ddd7ca8fdc956feaf3f4246dbdac58c46ebce8f382972c60030c6e44304e7ec4f66e1806a1b145e0fe272e5f536557ec0736ef280f202ca4b21461a9e014fea47c90b15706da04dc0c160c9bb52c97c20b459439b486ff3c84023d9960c5e021ae91ebdcca1791fd25e1094512a0786e788f68af0016dfc19a1e47719cf764fc1246aee794e18cb2240f8252b87b099900504aee57cec7ef5ac603596bcf1a58d2f691b052cf6c0305fb582c14c74f83988f19cf895d2bac277c996f71e19d4c720017322a1f7befecbdcc89e09e935f2f54f3ec61a6f44b602cc3d2fa17f01c0bc8c1705cce9775c7f859ae32e2aa13b12775b9938d196ed0f39af85a560b7dbf186c44d3209d1abf355dda248b7b94ba6c7215fcf401d56d3f35ea316c6b441a946e69ba67c8fc0b8d37d0a163a72815f167146396846902678707102468bbacfd6a03a65941de4095f24d90c4f478aef90b406edc7bfd3b86c17ad098d49e40fae6187e44005fe8f60c17b4fcc613d67e173461cede380ad988f0389f69f55cef16ce34af59a757b633af2ca5d3ca5e1ae2aa71846823fb976d050bc39d2b018a130bcba58a5ed86499698a5ec8b182966e0f0573fe6e4d31261ac2da722ca83a73dc22c466c879d67b45c4ae341397db00794543aeb7fa8d42472feaf5d50c921eabaf3cd48339a034db62205f3f6d803c3189ec48b2fb74d523c4d8b116a5aa1a340bb891dae7073c3b4264d5a8be0beba871dcdc6755b12abedc9d0ffcdcec078eb54e76e2e69d5b56ed1586f3ca6e68f76579f9f0cdc4bf5517470371b8e48fa3df5be4e1439df8ef36a84e8a68c113f1e4dda5990cc6f0712710e438f70e4127d12cac9697c119966f15a7cd1cc58c0dc56b47b5f3734cec40221294988cadbe6d26f44a8b0bdaefc350d898fee9384038f606d75bb9777de57954fa8d7f7dd54f0213399d8f537dc99c104458a4a4afcd823057a25e3464664ba34200325dedfdc9200d17089d61131e07a970829683e8bbbd9f0725770a4273193b8dfe9d314c75df32df8dce08966bf12626d83fa3ad13c07548bd900285e5a7326103a955cb1fd22515e21a51a8b97012c246883e0cc535d2d3dc1f83291ae67154fa8cabfd664b0ffd55e95b272bbd39e68356554e0108c3de0bff351afb19863b9a1c9305fbb12927031f78594b3dcb1729c740ec2cdc44b74213f8ddee8ac06ae594f2ca07519c46b8b760d3751269ea267fcb76186d653f5f8e8cc6491eae2227d3aff2ee51bffa33329bb08f606545b52a103b319e8050813c438b5f6a62f584b3d05b415d6a9621293465b314be1d01583319e1cc6e31d6fd74aad58ca70f33285f4adf12b8bfdb6c47baee8447f28d977c7165c8762f79ca7fe40c77ff0180b7ee43a7e73c22b233b1f19d19c7bebb87ef9baf74ac3377302a776a41176a3e718fd4ceae03c2a8a34e8de2807500a4c4f9c18dfb096a1a30689909472f231d8dd35193e18f68133665593d0ca342422129e833a1a70990fb18d5c26493d8b1c6385e5beaecda1567873348f22492eb2dba8330faa78b1ee227f1baf602f7b98f2a5258c00cbe123e15998ff581124a974bdcbcb33e39b7b627c01ab32faba47f5f7c3c93302f529117d9812c5e47805b95e51d78ab54c9b25b7176fb7417544b92b2a2f6a99cc5cc00f2121368cdf461cd1b03e1d56afbf32e2dfb1d3264244b71f5a238803e29136faccbbe8135d890ada1c072bab5a1753203d446ed540f5cdaf1abe5eb5605b33ba8fb53fb98610644e0b31c9bc67a30872dd867f49a3be842c6b97c9942340b41a3789ae4dccc239b4ecabd408084451384690bbac70b68d946c6abb2b902c3212ae15500207a868b580ab2b23f8a747c515b8cca4a18b70df7864afbbffa9ae37d246f388a71a3f7400e6f1e0e9f6c7f620d5965ebba2c8477a55ddff4b5c41f049b29336a50b80cf55387385e51021a3224bb998619efb13f36191d7165172af4f98bee33132a6007d15866009d995c610e0e9482a8bd8aa42d47a67ff72401491f8d0d2580d5760e9bf810076326392b2ebbcf3832bb61d89787251a1a9b657aca5b7c1e4223022fef5bbfdfb7022fcc4cf739f7da259ab7758be1055addcd99ff199416c75d77981f1648d45393727d7538892786feece7a1252816966757f06fb4d6d35ceccbb9addb8a5af7028a594dabb3a2d46c2ef6b097f1c2eb630460277ac0844cf51c49269ad48d008c8ef75969977577a2e06119ed0afced789333f6934e8129feb922cee6d7f8299292448eea2ec677a0c9c18ea3267c2d83f23121baac659bcbf0d2d32e72c6c180f4e1506a312b96a04c8834d80ae7cad165d291d8218fc2573c24a1f3d3148929f95ef3d2b1701a98f74326eee3113e8cd0782c54debfb011f33af9aef63fb868aafc39a6ef81d336efccf20182fd2e8b155de298e8960021fda3aad5e6afe829fbdab1613712d5cdb7a1aaffc6f4370a696d9366f0829eaeb43b9cd7855d6b0f9f127e8d0e53df90777f95e72ec88d424d0dd459c8b6f1a79f9d8db48aa35d3249e040a0f23f8f740a3566b605d349c6b9b37d71213d73fab092d9a67041d3692c2b6f92a4856ac77dabef438ed0d507b4d9938eba927817938ae515f7e46802fc17afcde6781bd94fd0318501549b4591cd86aa37648d86c1d9bf55b22174315a65157b991537ee66c0627f9f6bd87677029c23e89f537f11d37beae32f4ec52c3ecca2d5c57cf950ed73c91e1f5c2fbf5d0b99b796457d659d2875c966c3141d6d9b5f4daca01bc1c94390156c900f8990fbd061f54edfe5d5d92be0b5e21724908bb264e54c29d0e702a9407cd68dc10c610f1dd2b78e8a1e10c0dd5f4308448f159330da280e4466a3d6b5be296f58eea505356f9564ddb0fbb1512a44d33945bad2167fdc2ec6b8805890e86c4f4c1506b18215ed64bff31883c93ddb603f22cde8cfc7a01638ae1f41db1ea2fea0e9b77d4597d1c23d647eb9e5f315c1f01700ca463855bc45e7731fca228b2ea863e28f9e5bff214017ced2dcd7c21c88f7800afd5979cdf67fc73f110aed24df2a08c6ac28e32a10e3f501a68d647b3d75db390b9274a93a3956b0e043d4bbbeb03e025296db993be7499810c89f43a4307b4a528bbf4ef4e3c378eb0c08e199477376a8c733df2caa3efb7260133c4e11ae92a46f5cc36760ab94be7e468915f8067875bbf3530e24483e052cfb69a5743cd89ed55246a409f2deb3715aa4188c6b82783ec8db87eff1fd9ccc511d88e63709e33a9bcc13362e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
