<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cea3182beeb9f8ab1e13c51ab474c6abbcb8350dfa6f27ebac4feb1eeff19184b9f9d0b4727671c1a5ee2affd433affa0485f7fa951c656de52b9832807527a7a824dbacf9286783014e9c9d70b0ad8498d2ccc8943cc0d4df0ffc0861e8e8743afb786791ef6c134f73192bcc53e84ba9dce49a1dea6db8abae4dc28e5bb318f9baf448a32d74b137bd21d143b66e6efa2731fcedd0843af0ca60c1666524e165d3eb8b986a5137a1aedae100f7b6d5e533e2fe0a65ccfddd2fcfd645b13232f73aa303c78653e7580f9578a86ee5aaca90e53de65b19ae4a24bce50bef0ae70bf8e2df886a2a9d994062750168e2bdc0f51a7ec45693c422dcdbdf3b060893518f0ce15b5b919014c1e2c5d73754405dc68509628427b9da8a9794d67ab75078ee88323c429ecb2814d3c7852671ed5ffe6591847791d1409d22838feebdae095fa5024abfac81b533d87d3805c46d7b98d651a4f36a9d9b19cbb070bf3d04d7c44652b384c556158474c105638f838f713b877bcca687aef5ab761d169e4b6b8aa5906b78f5ce1c0acc697bafcee6c454c22fd78ad3f088b9a01abb01a244da3089c7a233755c42b510ef8580c75d7835d716f3dca2053f7215ba8ec5b13f0e740e120b66e7b9463aba14911f05279a8abec0d71bb68d4661bd357689a7b2e87844d0698f1c2f5c34251985e0d3ca74dd4f898cc527959b31f323f07991362804603f8caa84d29a821573c4541783e159e26d37936fa65cdd2ddf11ed08151c73dda18dc917372ac158e350c97c648c7f20dd082b6630a474ee2903e1914905dea24d89bee6f4bad542b0a4a8fbedb76b4f34bc3994b6a523cf11d776f85abc43207db15f647595f44cd67e2029e4fac3d819af9f954dc625afdc98c25d27f1f5aa5b2d421f08e39fa62073f495ec0cd91493f9d06bd6b113ad108104a6b18ac5624abdf8c1e9eb4b1a020e88d9e0df8eb8ca2e2ef59c130f9161d8c170ff38cd76e788164b0d87d92bfda63a7b47189da1bfb227ce2e80951e1219c76d986e3587d8fc5a627f1ea72542bd14d7db7d791b2386037ed2e4a57aec5b5a4dae178916891d78fd38a76822af9922d60593d63867857a1a5d4cf294460810a5ee5cb6269d34eb7f11ad50c328f9731a8bbf84adfad3f9e29fe648e8600e3147450e11d346a573fab5dadf8c72a5fd9068e2d61b8baa14abdef1c66ec3fa07e9c43a48636031dee0571d381139c2b94155e19b7e3bffe7683b637d24f1884ad2d476ea7b1f7da5fa58b3630b636f3ec3eac5acee7a3f815f8afd4ed41ee893f01b02e7d44762b648f1a48d67e011ea5b97a7e55e851ec72b6d030d4d7fa3603080544502fab810b0bf3e032420d2689196648fe4d36106e7e3ee38b0f554248f1febae2ff4e51588efe68061dfbe5e5c6896f9de526aa8b779b33ee3e4872923092d53112415fedd639d4999ae8de2de100fa3358d24b49ce149f99cb52db9fd973bd12ca098cf27f12231cfbd6f9f39721be4282151318c856867e52539b0c116b8479f714ba228c08d0767cdbf849d983209ef07e88ed1bb610adeecf2b42452f5758714caf199e4517f3074de82c526534c26b08f481fd5ea23daffabe3c108607b88315b51d3ad6d29ed933fcb4908ae2d02c39300efa92ea38fbcd34d884baf2a9390df432228bfb44d0071fe347c9950d50836f034819ec76f9aac0bef278ea0399e6951893fe501ead89f88c0ba711d6a78e19d7f796f6f4dc4b53eb1cc011ae6c7a28b26dcd9d62123b8bba8867312629a16fcff45aa74dad02970274d8bc0b559eb8c83f6f1fd7024e262e649e1368c0a06be857c7c91d1de0bcc18984ebec187cd1e57fb456bd54f1c0cf21050460664c316b4c4688a97b552b4c90564c2b8820ce24c3540a77e6ccbbc4457a69c1fda3fe54e054d7b942a2f35a3346227f4a40838dd3e13defcc5939c79971b3e782b85a7037c99ca30bff323bc8db70496524a47992c077ce967ba37c1a760f83f5c257714d32294d1d2e0d51e744273238c0c678c3458462eda0218d0def98b01e46a2bfa31e9679a9d6fa41ee3a7cf349f7a7cb4e0903f05a008dd1da03af04bf53ce54a3b1832a9939b48572c08e35657064ec5f5a68069c8f72f3cf76d2842e6b44ac56ce6c75424ac0c42a20ba74c621ba2962dacd370f62419d9b29232dd3d5463e35f968541c15238a712325b6ca6b7abdc9929a1f9e26c3a4b29ad95af16f5c30fce8d4be6bb8b7f9ab29fc0b955bc78d490f15ffa3637d3aca86cf8a12648b51ea68eceecbecc1240f7de19a2c8c53fb996df4c7b49ec9831233de00bb0faaf31342a6179b2436f4a434d7869b9659891cd181f8b88411024356371d61ddb866ba2a2429f2d44c833ee97137a081fb6bdacfbd2211580e9b67330f0daa332fa6fd82aa712e332a00dd7ee51488b2b0a33e5968acd674dec3475d6dbcb1e06a0a54bf3311225d5e0e59e7316f5c31546f73c2d40687b47e774bc2f826f5538e95efef623c46de3e5a9f1dc75d79c405f679a62df2f419b2d083416a5a80291e35f3ef2236c2ad233b92ec62ac24b8961d446b4bf10f902f99f7073846222a3f4ca398abba742640ab4ceaec13d1002f98f108cfdd92c940b4b2e9157142743e184563ffae0dfe92d89baf92249f679eb73d7921a25ce17e8a88a444c0ee842630dc8f72195d8a7064b0048c7d061590d09b1f81695cd81c2635837ed2ab73109c75806d1166214833f7a9aa925c8181fb2778c70ce0702626d4726a9672c931559495e0ff63d746c689748da451aeba20a445327d7bb003d4e5d0729b900064a84332b8da5b401a97deeb2ab450943b9cd294a96034726aa02458d3572250d8a104a5fe64a8f21acf0ef4e73f54ee3c56e7659a112fec3cdda8db00a1771ea69af5f256d662dc1545780e7272a6ecd98f37450b1f074c235146b1813174c5458d9a2de83cb0ce40a56f410b3153411889bf8e00c0acbddb2361e635426513a511a803025e5a2a91c0b9594653aa9cddc50d2ad8251e769e4938f4d26b6b934d3cee753a8354f0e6a67d4e83dac7ff2f506113862d05886c7a96cb5706260c3faa2c93a8f630b17c1b28aa40b60314cf4a8a2dac168f6e1ef773187780a62b18d8053ef23a04344603971ebd5e08d3dc6ec7b76b52fc4d9802c7b33cb762fb3e0ce8be409ed5ce325bfcbb1dd6f755389cfec5c0515be481a1718acdf34bad7f8508e10cc03aa291ceb75e8e5472132c38578cc0f9b3ed032975940e07cdf588b3ef7d10c179e2263482fae918338088e53044d3b9571d4a7b99d7fa7bf6620cd6999548512923b03505963208224da961fe0ab925864688f96259fcc2fece984a615d8c58fb177156e6e2aa7538292dee75bf6c4ffbf3d42e649ddeda999222a1aafb6bc8d9d6d954343bed2afc5857f2f380d54721ce6d524fdff1e3428ff9f16b06384ce78be2f7c8164880eaca48d6bd4fc88fc05cf7f6031ded3124807d25c813f2a456a91bc81835d559dae03bbf29273676b91dddf46f3400b8910030ffa3d45bf625d81dc46836934906693b4857212e06edaf34e45e070574324b4d49ee4372fdf3c8c396c67a2ec14f0db73c60f627bbf689bf77842d0803de2d7abcba10ef7b0678881fc7e180c2aa8f3ac0aa29dd2e6bee02beb5a48e123377c669e5fb07ad5d24e209876fbf20b043c932f83bf70bfbfea1839c9f52e104ebe00912aa9ee47d7448a3f128d8d9e7b711c2b97ee301bb3cf98ff81eda4d15c79036bb86650a712871e60df0509871367fc70d396c2a7c372ee2040f59fdd4d80b882f5804ad69270b154eae5efe42a50860a9098a19f192543f690dd6c162b26467eab3389d3f2fec2adc0ffb1fd6cfb86d7a76fa3b0844b7afd619978f3184bed0e0360f96eed705ee1335da8bdd2401927e7713c48fad1fdda36c6c28309bbc87c0e9cc842bd12080b51d7e45ccd29f42404241aa66a8cdb9cc859e208d4742c209a8f785d4dfbfa37361a56037cca0c83a5b4a17050cb688bf803f6ea80df30a39bc062d9ef86544f3963ce7e298acb9deadf8c4559ed4922fac569bbd4634e20d737740712fe713a425cde7b429f00393d1fe258c7750944c404deb623663b1ea110d7b57e886f43fa0949860a087901c19036dc25283328d41857f64595ef060a2f89fefdd0b2160bd4b0d7dbe29a515900c6299e485a037ec5c3160b20b54d89c0e67cb616d156ff59da5d4e7ac58d7c8594b8a304b27fd59cc48d95309ecf402605e0d17cd6afb1df83f7adf68c0a37be1b3bcf2e3aa83848b4b9384b91b95f0601f733b0249230895f176a91a5715d76e3df03ddd566ef8175c6f51f2d20956a4c1aeab5febf80d1bed5be2fbb6310c68569dccb07523ba20e1d286894ac06fd52b1e0c26f50b4b6916f03de6f032c6b2b9f1345969bc1bf11c4b233e0a5ec18bb6e26ed53e4d962ac6fa31134e2d32bbb5cbc3984246d768ce35efe061f2b60474b76e2bd2f3e5ee2c30c9f8ec67f739510cf12f1c7b6aee4187d55e1762b7b3fa9e5759074e53554cc0568c9998a24198e998317bfa925588a508017ed2047b84ba224237d4c0da77713fbc0a879762826004e0146583b0cba2b8a21c20b3b407f841eafc8060a2b599a133e255cf270aab65c1122f2de36af70198a49ee3044f497972f8a4e679ac1041937deff6e8551fc3b6030dc9ba09349255b83ca89ab2ac65d13b8c5dd79775ab6b8ef4b32ed1d8be954cb91d70a023bf22ceb09805f290a85419b9825608417b1178190ca6452f08159c1e5f60bc322efeb48a4227e006c1e775f3144d18fce657942d3a2018901697aeec60f03bf995f714fe18264a68bd631d14a003ffad929da96ac6b16bec209b7b72d56333ef3117a4aa1358aa6007ea08a13a665ecd690b547994693ec735f565f367e1f627edae87dcc6e236ca840e625fd52cd05d89b9e7760670a6af7db528f7e20244dadc8249406108ea514e21c1d066bfc2efe8c6698d6e9b2abad9588dba3bbf06ab25564589aea90e5edb78cacdb9acfeb6391d5ffff8a08b01260052ecf71d209731df265efe57c1c422cf491d200394e2b9224f0fd286b75c83ed45f3a6117c8c4eb44e9fa4fa42989653ca26cb75acfc3f24263c4814d6802566cb14bb347ae6eb8e3c0aa31c1a51aa36778ab0bde12bbe2effe54252e85accdab2b25d466575123e0b8b6f7e9357b2580e44e25cf361dcbb091b1779261278ac5e88421e575c699256e66947bd852953d8124cb183005d7fbee62c60a8e283848fddcd3df9b3c6d4dd3d13146f3411459e35a81dc932f1ad501719928c0369a2cc11d74d95526d0db9f3f06a059a6d15748eb6342fc27038ddbd325b98100058fa135f31fa7064a35555ef0c9a0581be11d79e587f45469aabeb3997e1ac67de7325ac843fb086f083e44e2b5b4c7ca97513cb2deee84eb29453d0a077e1866598a1ad1a00031c6d476c2423ca8c6651cc0e15f7972049447cf689acd6b0b8f7ff8192a7dc99e534fa193f7d98b423a543e36b6a0e148d84b479eb4f7529ffa2ee401f3eed00036f25a7674e0ab2cb23207e8ba6352192de5db1df4513e7e1a64d88bd334b4cd5f5f91d51849d72e6e50946dbaedb6e0784a929faa6bbfc12e775235af1c3f1ef01ac2ca29c50edc2790c33dbfe3facc3d6f586bad06a1978c5079531c3c20952e8c6c639627cf52cf347ed7882c3faef837bf25e65d6a04ab2036e35c72a6457279d9469ba711e6c77dd6e73983dcf7de958283175ca62639b699e67ab4c0ca6c542301ef9359b71343736d95ae26a1364e1cc7826a672b79bac3fe0a16cd53da7ccb92d5eb9861082414734e8218fb8d16f01ca738991ebd4ae962946fc63bae8d3ef997b017a5497cfd036def0620b4604ae5d22e132fb7bcf4c5648cd441d87522a0019d6050e85365272e8f5c5b0afd0e9b705846dd809d17c7b456c3fd0b801d0ac99672f1d7ce4f0685d3b86123f2863010cb031d9f1d74e6dde1f61f1a5d380efdb331865a0c665c250384dc7587464e546583663a07411b295cc57a29cd75e67594661d1a8dac7545aae07c3ef495cd96298247954ba83802e6cdd75da9e9a5e7fb2aea971fc8c041ec665de500543db1d4b29087edbc40385ba8a2772b8126b108fbedcd9deff89343e5da1f01825f2ca085a53d7e3df4c39908daadabfba6d9dc010f2af3392a94510c3a1a11bd5f99846ed0a999423fd805becf35c8b688c09eb940dcd94e82ea207560f80089e3eea3305706ca488d18d21205bb6beb9e801a483f230bfe1674fdd48a1a702d4c46da7296acf6ef3f8f5d5f5fe8e666f24c427c653900129b03403129e7feaa4c23823fadbd362d78534d5be7e6f7e3888b5f7e0c1ff9aa1f245b27421a3d52d88ead90c0ff07103ddf3c017bb6df3fa6bfad81c731fd8a7850e92c6c94c671a6ae3c0427df177cd0e3f18154ecc183109c5f5f9df7557ebbd0a7df3233578a4ea15d48f4c689ad64eedae3b6deb117dcecbd8e96ba66f6aa29a50c23dc7aedc2d6cb228e844f53a8c0c77542fb1ee46d52b52ead7b58469672c1b21309ddf57751234a2871569515e63b1ac52bc29a3302992f6fd463a5aa5bab33a6737fb0618c2bea451c8305daca067d6d3dd6bec444219c75cd30a0af4c30aba48cbee9a0eb221a84d3021811a9a556e48da23805115b61684256567d1f45c070e740b183534bc8d8a6afea663a9cc6cbb80fb68727744d948d6f974ee6f9239b4eb8b2583941ef71dd26aa9bbb0a8a4139fa54a7868f2dea100c08965b5f94fc1c6581ac192014497eeb9dc9d22c12db3b957350110dcc1247c19da4fcf082a0fe75a12d67f81870d22b14a5c3173c6dcefa1cd188431a500936c0c14ee3ba3db54e72a3b147b859bf6f87a82cd1266b9996c8d63be3abe39a0a6a75eaf7608fce305314e7ecec9a77877cd513d733a33e4e27e42f7cb6b9d13a7b77bb28a43b28e1848730862e684ae0483c69640bdf0f62387b66d57b345ea61279d32a649b7433cdbb317c0de8e58018d484e4f6c441dc808f00ba054d1ff54d05b72a0ebd44411ff5eb6a8a80f359ddfb7937f7e3fff0bd5245662b42721c1b9687b836736e56df806b1d2b0289d88efac1bd59436f3219de969308d1da7c09bf53d112b2d0fe2e78377b95174342d209130eb5ba02d8f604087f8f68103a586389ce06d4c273e2cf4b7b20001c101a4dd144aefd3fe60c0a51d0514ae97dba00e9721a6b4d721b3bd8865aa928198250f7622c15bd4399b72e0c37f5be3148b12844d93eafde500377fe043a13aafa4474b5367f330376b5d7b2c1a32dcbc6255051314a4b5a57b393c354c645aa5ce228ca0b19cc13aad6fafb65e6b07a0c3fc608a14b5aee757fc18699ab74a9dd806537939ffb731f9425970dcc271edd43c0190d359aec704f36214d15f8a47b46908e0f3d9f2fd060395bb12ba1c3fc88019eaf5d728c5c48af9491c2c1369d91ab2f39ed4aff14a2c255601119958f99759aba9c075e3d6377c45d0aebf08ebb4cca89fef6c6fd14c2427efe77b485e791ceb3e6b336ff04d0f3be4dce872b5a27bf1a65e58d2c272b4c9f1fda63e9d21eb2e70d6231efc6fa4d295a92816e4baced7450c949acad78dc3866679a062379fb736f32b6265ec9c04d52e6498b87cbdcb39ac9eb1dba9a709523833411e1e2af1caabdc8915535d56959b096e766e33c8783ee0f05d3adca218d50b12d377947101b2d24e95d47febd243e964967c9afe7445625baef1e1378a0a20e5b969d30f39341c711325d59d4dd2505f3d58267410e1aeefc90272a4ea2f812a91096721977f0191700d0d211ca4c23c44375c3d1c992aedfb9d805408e35ea6d8fe4ff55ca8face834962063d343ccce739836f718af6fa72b015ba1e7e0afacc4d6eb878f85bd32a5e66b2bb8e3f40c3c9b41c24704e30d1ed3c27548c99a30b75f2cf5387f528ce6039b5390e5d344a242b3f1415bd7371ecdd1e726d97e84ec5fce6ee836342c911032975b13bb9d78aa5da81b52e5eea5f113e5c28f4aa1d0f909cde1962a44593dff206b2ea54ca806418bb608f378cf07ccf40f6d72ac56f7af16dc63a8648cb4140ed4a9a4e41603113d77e09692cd6b3ca93e642e17177a0fdfc6bb927244db88140f9c31679da373fb123ca4d35c55c414ca18485ecff2dab4ce632c8fd82343a8b90b7232f8a3ddbf7f4bb5e40568414745e6b0ee40a6cb3359658b298e7c63bd1f0c40e69cacf0c85c666b4487f60608bb8b75cd6a46c36b20aae33669f3fd4055a9447fff02c3ef8c2c12056beee94ed5a9569bea4349fc553cd3ea8cb7d77bc1e682226495fc32d43af31d2adfb46cb3b331eda7f9e3a59125d35a9e95a3560e55f93e97ad515a8444f87c471a61857cdba24f6711a72fd8037ee62e9b970ac80b54b517839869b53fd82174b5dde5a7e3a208ceaba1247327c6b6d0b391123934e4c20db1e7f8fdd1d7325125031bde068a4c56f4a02e590e50e256c3a38b3e31c7ffb37cd86bf166134e404f770da7d6f4239f8c1829aa2a0b79b77c9e87d1b02e6aa9d073c2047b334803d5486e11e6da0e4f188eaf0de916ed38c5e01f69c2aa7e731f38db9dd315bdbe9a3095954eb5e1d5e8bd22376178096ab99f2c999874c8371de4e7111d5b831cf10e1b1c06a42e176bae29bf834fda73f0b592dc57e2b3c2bc0c20e312d154bdc95b5fb98ebf00c65ab6f18d9fd308df8c11bff7a6907f9360fcd7bfe74b7161eb84821fa4108219a638ba1e6d538445a15b66bab68f00671982d988f88791a43b9d0a44719991266f8f20a3680e37dbe420e98400666ae3440900bc31e00615c9de2ce3258f865da7579155be081f7bde6f8d5bb1f74403f7da71e2ec70376b1a0102e00798bc6ff35cf9591132d91b0ca05d38bdb41c24d89ac288d6d79b41a84f0ddd1b95bdfca186f374b7fabdd6f2b037490ab3248ebada09b67f3c957971f1b2c5d3a31b158da7f9333dee54338e7000762606568a2bb2218ab824f7a28aa7feee6f5988e277eefa469460235a9dd29c9b94d6173f0d744443e6615f187e94861c527a05d3b8ae8c086dd461c2c6bd69630f66fabd05f94d72bf4631330361d7da08c47ab635b4572bc25f9bda8fa1efc860049151f53d8db3e86dc42663b1e91ea27847ee54203292efd3cfd4b040bd8a3e69f92e8f7cf503f37410b0265fdedf512d9cb3716492104409e61498131fe2816077744c2bb104b93eda3d770c1a7e5b93c6ea4aaf97970c984c5535bd820f099c31b83fd6b07d5f6dddf3546e8d283a5d09e264b3ef16d43f310b47d852122da4f4565f752314b65e3e2412d7a6bd3ffc443cb9079726878faf37f522a59881aad23e26f55a5c048467f03868420fbc6e2909b7eac9f63333284ac535a217747eb980f76626a8a95d7af06a97f26adc15930664bf3bbd3fde6d3a93226c77e36880d6736bdcaf70649d3ca5fa3957924decee401bf130a5cae645f6537ffb30479a6d17316a8a49b77ed8a1ed065163a2649e1b0586414ae0d382a266af2d0f86702788bc9ece5b9e563da1b5f2746de5be428c96bad8778453878d7af30a832b891204d3846d334204e4b3afe03692f3a1332216a981760fd4886586007f935f8aa7771047e4e9409f65cf87db45f4347612df99a9f0276aff1af7758860ca2e4e1f00f16aadd02c12432e7ccad5a518528f1aaffaa5c8e1b29755ccc085cef492bd3d2f7bfaa06759588e184b15c50a00780886081e23808d6bce3f345aec53e9fc1fb3f6536019e2db28a2af2253baf3423ae5500ad780de6d47378e3546c879b2e45fafdc43feb71629396439a0b0801dc84504bcf23c9fa5a90d17825386cac532d2d93cb8b18a46a21bd93ae2c7227d46b20ade37cfa3388de9211c62df788196a6306c27ab1ac7bb32b1c012c379ee1b5c46e8415c479fe79b45884342b0f1b91ea69e2c8a6d402f19f6d8ea9fded7649dd756044a6c2ff28aaef30a5976bf0a71082464d49c1626a16042448c81c1e74e3b2f780cf9c2821a0f08804ec24a8db5915904fabdf47de40481cfd8df29ec31d92ee0e5e5876ad2358e3a0a8264cf320f6df7f8108de3ec169f3170844cc30bcfde4f3d730643688320da2f7aa550f2ab82f475dbcae1be5435af449b890e9a504a9196ebd7fd8e95403b707a05a17e4e0b0485ed80d3bb6a4d12bb97a3f508510b8a3953d33d69033ea78ed9f989302ca9259a36f52ab3fdc72e3f6c745af74bd1dd502d8989af756d3757cbedda14fc50a87e8e7509990efbaaf28cc9cf039979cd4c2711e3f487dbdcb24a463370d5b797371312ad51affb911dc604014436535087d891202f7473a83ac686e54b04d39aa3e571906fa9f7c065050598e88877d2fcc204f1ac4a01d5993eb17f56201a563ac095c6bb189adfefc72c7b91bc678df68c719e4679dcab9936e43e07640b88c387e07ec9af559536ae29d84353110bcc0cead716804219941189cf636983f4d49781ec22308cdbc8bbed69965e88d7a2c8914c977fbea2d87049c47f56252d6b572bd34ba0f2738b0e73c32e736f1b9d1c8778cc5b9862fa3908c0b6279b1452e3dc2b82630955bb54aa8b1187fb8f34d57c1647e632d9bf11011525a2604d7c43a2fe2c1bcda96b07a85e87df3b3b1517cc53ad42c6c87547bbeebe5a8190b1bda582de0f72198f797d10cc6792a551c79baa55788fba4df0ad124971c377872caf9185fb395c9cef0d942fada52ecdd2375db3fd2f9a446b1bc7549a2a5e13ae7ec8a0a9ac72897923118897094b53bec68d4b7a278f01d8d4cc8a546a1cd1dcd062ac0f793ac37e9c274314bd1a68336f83731627dff633659a114c992f3a3d8a61121b34944c883d650b8d961c7b4c9459bf76ea9445c7ace30a864bf9882514ef34eab714c733d7303519e3b03087c16a2489f2c0e9007bad121e9aa221db05af8e05f0794b7c4ad314964e2bd04833e23b382f7474686dc1a283b491cf7e785c57f3f608226dc581d3529ab311e8f16790e7081cee2b4f64b37ee2d5705c97f9bc6ffb74cae12e1dcc5b3e052722a44d1e9430490649304d3a78046b768cd71b06c9bbf9b5145ebfe132327333895ea108473e7f4713e332b344d7283ada2e276a4bd63deca67e113295295f9523446d72eff06cab3c6dc03dbb3f9ed34d88c8d494af60f510a379f73e481126526857d97e65037c5fca20cc5251bb4e0e588039647b5128ca4fd5b60cabe09aeec217a9543b726a66c58220f5375a17bdcb482b667182578b637e48dfe3f48e9f019f62a6ba9c88adc0664be1a2ad418e2f7c6a3ef9ec6feba61dca3376b33d6bd61e6ce30d38d0c0dd97d0ca1fa0f8da2abd6fad78d3a5bf8ab606a1c15b960ea0f6893c10a9c22682f900074428f95d97359140f247f4cd1fb3b4468fc0fcd425aae69bb24116fc492be48f99b529e262e5ad236f45877fd0f98912543b111de2366fde9c27968654e0503d070fe6a4141eba18c96fb9691c6a20e1b303559aa2672659a5faabc4c826d74e8d5956ba7cd5c09c6ac803d4529868f12211143cdd815ded98834da200b57bfef4175f04060926add5378c52dc8d1bcf2059da4d051ebd3a631e1ca2117815a032d1baa4b555954e859ebd2deba6825315ad5e415934123f36df1fe0e155c93ac4cbfce6fabb897e6ec129b90b33a5ec3a1cf6876c3831c5ba2d6ce7264c8431a93cf816f8b6776bc063fdd65dfc20b35fde551f834e72c3ad94a0db9db43ba1f6b2c5000ce5e1aea0773d88301dd048f8570a7acf4079c3b8ff20e715d40ed8b21c108bbb8990c2362d19b305a87d5e3024c227518af493559a75496a19fd7e9da5ca158eb8e91702ca03066757f46d47d51a76efbd51521114e21766066cccba80de4b77e214a3df79414c846b6d67cfdbce93dff3e775f66820ee66c7eeafc75065789ee79e3ce8671b6213263e0c58f547021e0500b4c6e5aa92d5cd21b99cf7c7596150d82f8aabda0bab7e3916dc642523b88c4ae7c58d4ae06da5d7cc3ce7c1316e2292ee772137cc69021ccfbc760d7d6c902a0847f5587e613e0d4fa7acccf19f5ebe74d9c4b2b10e03ee8c9a7f82c933667f9b994d5f7d860be22f5d377141c7604d48dd3707ccf0623bb020e95eaf47aa7c014d14aca8beabcd5c3cf5937e1586f78d0eb4facacf517ea721ab03a72520fcad313867d263c9fb6aef70fe8a6a9dbffdf436263d0c1f0620c8e128516ac3eafe04b35d29149ff3929f78eeb68cd87e3b302bb24075a52b8a3c25e568a9ac04969712211bfc140bf011db25b00581f894516ac2a156e992ce9fa203a1ae5468ed8cef0bf34e13152e53af26fcd2ac93d4b6b63f9ba160c89d9e4a76477305c047e535ddb9328271e62acdd91ad9d546fe6ebf894f8caf6fc108a1bd0b9345610fd3aeb9bc9617957f0652bc777f5c63aa2555f933c247ed8ebc72efbda48b2c5caed39dacebf1ead617a06d145ce921c3fc0d217c848869bca56347efbe90806aceaeca88501307d35f124ff784681ce48b5b0df4de61be0b22930089a71db0c1e7792081bebfdccb73ab409e755d7ea3c0677c4de110b9af9646913ded1d8d171db1f479dbdb8054140a060e7b4dd9e6eb91fd6b3ef6bdcf1478a2dcea909cbbf4ade94224759a6c35b4d806a2574b4ac10d49a04ef6dc368f8aa2f9669d47f76bb99f6b0e5e5f49b40070111534fb712735bce719e6bdb64929ccf1ea2253d0b9a1572d38b02d30b0bf69730417f074ccb223d711300d653e4942d50de692d94b251545963a00a1240beb62175c91928f13de886dd17139d6f54557f49b5a7444245ce32070557eea11afd214c5cdb91955def6d214158b55f80eb592647e93c6f0a7aff4fb06d01d70b3b85d41ad4dfdef7d51289bddbbf9006d06b887080f163263dddf35fc52ce6d9fe0441651b6d1721b92ce2aa44a83e1cc8f850abedffb1f22c1a46ccbd8afc181cc64cb6fb3916da8ea5e4f02c964c362099911ee57997f091addbf6be0a84eba7ea0473796cb1351864886020034d3bb34ed5a0843598df305addca662db6aa902fd5b88498e5af7d3fe4416efc6fc40445e789205894676af1dc2aabe9fe1b78c1d616388286d4131f09f8391133c403876519bc7840a9bc434a8106a791aa5adca23e550928df195b9971591140fcca35fdc40db3dc65a6b89f19f1a03e417d48e4fbca898213cfb935fbc93e177a78dc5fc0b5de0d21533f7b920e5e489df46886c6eacdfdfaf84980f1450d889838f809809939aa6ae98268e8c2e14cded43428081fdc8e25e0be98b6b92c7ab3f0eb11d70b61e39c604c40302768f71b1037c43eb5c52f42cf8e8cd85fbbc8dd18ba163361f9d836aea8f9a7631ca5cb91102638018a235853d5821bfabe2f8fd61bb82c084f1db4191a583e904fde7715c40575e8e9c88207f5dcb9df6e6da65a88d2d578d0de0297926ed0dfaa57c0ccb24f0ebff4238a994e66eae2298a6a17725439e6c0c9f7e7da11e1efb1075230d7e19d40c37dc1679f0b88e1a3c1f1584200469459d29b431fad3568b685ac4a622f9f552131ec44bead3183241605716875e4e2d55475a0e3e170ac75ee605cc41bc47129f0fbe621b72dadadd396681111fd073ededa9b52f27412c590512099edad2978035323867ef3fd312f79defaa1eff0586b6aee362f1178b5b24bf5db5728d15f600493f667fa431099dc80b96dcf90f1a1ecb715cb1ae2de3b202375cb7ff4dbdc60e2393ea2ec10c7ec68e39ff2de1e7fdc109b0bc07936116b6939cd534565360fb5cb84a13fcf624085298c8defb0f980c837eed18218e6fe4f1f13d2d294198e46c36e6d27ec56d22a830ca1967a9e0e53b8b5ebe006c1c5808d21d5c79d44563c65c840462d40b69ebf7448473fa6d753ff1107cc694a5bd69a599cbf178d3095bd8adc61c4733f35d939f61580985ab92fcb6ec5aadd2fd62d94a5116eb5811cb84d692ade16f06205f5cd50f30f05b474f84844389e2f1d858e2c59dbb28475b82c35545e562aa0a9163626a0d40d2ec9b4f3db8e97fa9237e70c3684c22a17bb73de11a947258438e877c205556b99defcd4f8a9a663191310b7a983e91d05aec18130e0633fd19fe9b9c03a17e7ea68ab6340211cadbfaaf860c0a96a4212fa1d43b64392325ca51ef92a132b50f6cbe06dd1f9f4d495d4ca83ad4f42a6242afe5ff5f6e97a5296c00de2ff718b512dd1367ce7dafaf8d78c01422d4fc95895c4944f58f30911bdc2b496cfd781328dbe5da9e06e537a97bc1f8534162fe1afdeef7107f6129f0b22d87e39def615fb472dd0fab3cde665a0eaad6292e674cdd173e83ef8a6b4ef35330c726f748d33c540cc6d808edb6184f326756d6554eed53b09027f1432c86b3d720af6c65596e16b21693f0e875fba1bacf677d9a45eb04ad0c8563e4b8aa020f548252730a06ed2aba3185114469d5c6c0077702f58456fe741c8e94ce1bfb498061bd8a4e988dade972f01d981c01d08d81e56b2da2aefbb159fd7f09adac3fa9375ae00e8a904dfb804ae75a52f805232814690f3797f350b39f64b3600a490747ecab1f175ac07d88aa4c0351b9bbc82fab1197d5cbd138d0d105d770fa5bb3e20161735dd9dbc451260b081b63b7a0fb752669e6df92ba3796055d4579f39fb68a757a4960f8b77c54dd361ab0f6548f04e99116f2285f5ece905fa11cb168c414d7abcab7e2e8c39a12fd9545c18212579647f3cd8eae08ea00d9e40e7bb7c8d049caf5a7ac08df718bf7e6516b254a98b8d16fdb7dad7c98b8c7c55eb3b4723b561ea505bc09ab0afceaffc192a9bf673856e5a9fbb13c21ae4f3fdfcc1ea5dfb381aff3ca13de4f1218a7ab13b345ec17ef8e07f62267beeb3dd45b25a21aa57cfefec4ea3ae5e2414e3c41bd67d56032bfd6caf4ac0ad8232bd820cc18a72e6feb80315e8bdc165931ba5af68ca52271b82301484a2f025d93df947e7d3aa5be008ef4628b55bca2be8f3ab137ea493fb872d237101f34852d7b6b9e92b41ec5b214c3fed650c00e5561aa90568111c687ae1e27d65cd6fb5aaed97e44f5385a5265aea932224ec8337a8ec0fc7ab678d48699f0ca54c6262fc4ee6c5ec4adb06d040c4ba6a409c9930d069a991cfa156515267dd0a634a49fe6de8c1f7afc9a9478887ab6bbc7ff31e7c5f45d5e639502c82440457bda9b8fe6e3e3cc3733533ad1a59568b100617c370dbf35d9e1cc7a6ba4fc75bd4f2f028fc836370817dbbc202a2fca7b785dc6fa872e30aae9933b2804c875d68a382d65a64e418e1b374f43c6b0e042df110c094c36aa7f4e61d83ede669175dae5a685da615b7a80b9863ad493416e119e6360d402b62be3c0d457553ac1fbc24275fcc07b474989e712e7c93d0dccd34f0f69760f7b8ac5a883b88725b0b2f3cf705e2b46de2b8a1225406328e15b754e0f5beea6c45d9e2fec89fca90998d5664dec06fee70125721d6a21d7bf5c40e9f380e912689bfb2b0f849ef84f8f099990cc34913730a08c76f634028d6b909862c81ab78d6b3664b44ac69527600b908a0dd093a14559bf258d44492649cc3b26eb5e603e657cdbf465cd776392ed7f3e4578e511751b7ede1ed2a296f81e44948d7ba51a86d6bf4de841bb7354a7d2aaf1b7ade5154dcdd3ed95c644847385a159a879c48ac7de311519d01f3f02b4f2eda31869fadb5b4ee986d436af2ee9d79311f87db6977f18062fa9bb41f8c10844b0009d2b00472cb411b23df2d663be0716e4b5fae0ab70f327cd18889514ea3f930ffbe29d087a71e8d9eab9bf7f1872ce8aadf51a7ad7c6b0b87768deed1ce821f35358664083c0b4f39d50bfbbc4776366b152b63bc8fbccd463d378c503ccb403050cede1e0bc6bf2929a1c4c50b116b8f45d542bdca49e868104d2391912253a36bdf2835f808183a49b0f415df91b010ca514b169fbe28e254eb83bc2a8624dfb248a3fd9c971bebb63964176e570133a3768996cefa226f7cb7fc8958777a4beb63fc0349b973ae075b97a32dd73bf53405b7309eeb1346016c6224dbcff0e894184775ed22c3871db51586ba52975ab7eb10f9c324acd3853fb68c08630d0b7f08fcc9ea6da4dfa0a1d3b4f44b989986d546b9f3392df487bcc55d7cd21cbe6f749c672788f4a2e6bdc7ae3f146e5d16a130d78b87cfda02c694c96d43b5016fdcaca7a864f8f8490b3b3087217b4aa4a67b09737e491afb0a4e724d92e4bc57eb09e2ec95e3a452efb69a5625e44389b1ef9452c24dd4e1a94c5a7669f9f46846e725c5a8dbbcde3c26a8e30f5e9e4978fb556cce261f8599baa49c531888e0b647efe091f3c2506efa18e3b963ddf628ff2777df64f11108c266b1c3c501a2b7807cea87d701bdfb60850d8bf659c50b3ee04fe666e84c61f71e352bbc0e35ea7fa59649e30574ee8f439076e5a2a483d243ba556599997806314213ffb8101afaeb242dd32c28a17ccedc347b00d174476aff87a91f15bf681aaedecbc79b1d2ef06da65cf85a325980b536cc5c34b318a1fa899aeae0a735a5755403ca799332f3154472d8227716c870bd313afc33ee16b1ca62ed1164262f5186c8dd15d5b8bc8f70585de78f478b6cd6d0a75fa6759792756e3cbaec8d7db715e05645253306a56c4d800079615c9c1b31bef4b3d44066657cafcc35b905ecb4aeba7de471c07128777ff68b9d5aafde28cfe76461b1aca7a1dd4d5c6d4565d08de7084fc5ff7bfae66d80fc89aba7c6189037ce51fb22f3f9d6f7e1df57d01c7bb81f46ee9f33c90542cadd03a413d339bbab6b13ed03a1a4bfd9775284d305979a59e5785220b8ae6a8cb14a96a12b9c5e75463df736f9266e0d079f53d005c69f6b124f872a30b32eedd4ba225f5f78b5b19c7e809a64c9746cbf3f4ad468b4b70a32c4a09cd64395339a63f5bf3e2267bb541ba4ff6fff2511ccc14d5b8b3ee062e3bd4325361277d8c0acd145db70f8b120bae97f9fa5fade7212982f2a743b6f075bdbaf4daad12e3ae9c04a7e8fe38f6e54652f64dd9689632136f99a3104ed9a037bd2fed0d918bcb60ce7ccbc5bb4a2f97a37f640a933acf0ef28be68112865c1b55bef87ecf9260287610720607c565d3ed2f345d4e28c1da0d53939a994667f7c40e1762d80fbeb719908d21f6680b35b90c28092aea101a91e98db9c3499f48efdf0a47cd7e37582622e36354d16000a1dda77f1745cc7956502ed378f4e5ad1021e09699d217c203c4b4ed4cc1621fb4968d62b9ccd6fcfe2843611171519d10cef60cf541779f7a92f1c87f33e87d497d178ef88ce437507ec24027f7735614629c7c9e2f0c1eaf5c5b916e3f5928240783327a3595173eefc99fac88dc30b34194bd681fe478fe97b2ecd02e5813a189144430db2a2ce7eb337d3f3c9e2624cab90edcd04aa71a2ed56562ebc05a2b5d9bc5727b400ff7cb03f352dc6571294d9adc205db7c221cf68eeb0315bbe9c4af2c093a3733fcf1e032a0882292a5932723a18fe335deaf38c0cf6051ca2ba8ce13ed32b2a4c5ee7cb265aca3a32e70181b2b710324bf732fdebe00056dbc2367d77fc3f8172a85e941e5a207550ece878d6fa37a8f4accfcf3fe278564e8f69a752f9225d87b9895f5dc45fd39f45a4529f73224e1e74ff6539fde4c87c9b42e99ef99867098221b7a1fd98991979b8b9b2d013824f1e121b5fe6ce1e6a109cc311140e1c9f9bd43122c395c961262234e159d8b653d3c6314795b0314b1e5bc9154306f86801c265f9803020b6ff89f78f8e3ffdbd5cd1daf477a204ade39829f811d49b43119aa7d12fa98de50ae22d6ebb142bb930348a3015eda6d87e757ad8ca6d9dea26dc2f34c4d733cfc05c007a2cda7fa2e0796ce81f2ab08bcb8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
