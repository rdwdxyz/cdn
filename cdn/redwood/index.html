<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81c0d3ab04697488ec029bb852bdfe9558503121a3c2650865b489d070306d9b1cd0a98f0fc2a870f495c660684382bcb993ead413c02ad8a69c6c094228d639851f588e81b0c486c41ef1e0c665143f08b6790f91ad97b1ad61eea134a8034a0a01b2d8ab9cc4bf6b857e131bfc4d0397ad9a4a3ee1828c076d000ab3a382c56e6c74800e7f9a195ac05c22e00ed71adbc7865388de280f01f5340251be352abf390d75afd4fdeca132073263ae51ae0a57f24d4d18196360adef81ac23ae25e116c30e5f779041c1e38708c4b0be7f98bbefd5068fcde5bcc612f35be3064af19e5b3cda1b61bad5442d31e90d9e50a4a6c1a0ef42db5b80b42e1cd359f7601816eb726662338f1219b02fcb19be021ca878d0e1af0151ac2e6f599464170d29737f8e2f141d697a7843d804c3a7c85ff572c73dbf93eedc9688476de0c60772d3b882369d970902c3b03097fde9fea9fa595033a6f47ade793f3789f74478cc4bdd01bcf1de26218bca484cac7fe873412db58ac3d8ead3eed3a55453b51f1be744d2cc6ead34d5776253d6cbb05fc7aba19c8259f46e0efa741388664ff1c372dea9c56e99ba8915e1be13ee5ee52fe5b97dac5eb01fc84aa0c2dc801901268dd449a3f24f6f2f52dff2a6a371d0b2c2b3c34d4049b871d3624ed384a93c61e2e6a9ca408837c1f0bd9a8fb0ea16bc7beb9ae8c430b2d95667590c0c695545bf776cfa46d99e33b27ed5d35dd28965d6407bcb1e0cd554f1ef3a6bc2edc733ece475fc97dab869dd0418f7b017ea93db8b079eea72e932f63af6605687ca627ed499fc66a6ad8ba154ff1212c4214349c0b42b6b17379e755eba8f622cf6ad49fe15f01e69b0f79dabfbb041b7f712d44b8fdeba43e009eb408d44d3d9e94821e8635a33e58d674c0325df035304ddecdb2c71ccaf8b2df12dcfd1dd46f3d50663ff0b8d75964762812e578d415ddce67ab71e18bfff623e345157ab9aad54b0651c39d4eed9b4a5ff28a31cc98b972919237b69cd481179984a0e9b6b751ce4623211eedf1bf6a33b60bb5d7a1b1216ef03e836a1c90699e2cf6bff9a838e847216d2fc587c8c9977924a50e11b47285fea0227d8a5c594143be9315e1bb90fbb7d3bc0cda61246a23fd7f19f3a5702897bf7303b56bed48b8b29a77657462191bf0fa6ad1b787905ae4c5716a85b2e9ac45c097ae0d78d502c6ae8e90b5da012fb1452abbdde5dea065bd24d73fa1b3e42734b522ae0d96d1684a1af08896b3d4dcea3eb04d6b18e6b3abd8acfa71bae9a0602700903e122e660c3880f178a98cd816104b5347e9b88f51a35afeb261236aa8019c1bb253bc59fe8b3b1d761742b418983a8f9feedf5f169c8e78cae20a78b97fb10cb86870ce9e7bf83a5fcee77ec40adf11cc728651f67b5bcc537e2329feeafabb7656703bf91c52c2120438e2f80e5476644eed96bb52c2e14166f46df0f7f68604e91f8ff35cef6253392c670610cb6dc71a7990d3a2eaf740e1e995596865b80657d643eb5f7b519bb740c6de15f59d7ab4308a09e53964ab5bcca489288c669574bc8c4b393feb1abe12143fdfd271a481ae87343a695d0c1af5002b403dc3ea8e951265ce17f6152cde04223bc12fef57660d4653e25b5c84683e48d8e852965718468e9f26731fa386b2b52a600cb38e772999424ae80911b01751598c94b640d2fb46fb6066f8aa499c25f18fad4def196fda961498587c8469546a639ef894ad144f856f02e15f4bd6ca2628d523491224d07a6386b4e0e85f4cf84fbe271b937104206aa04edc98bea0987f1ad3dba4fb63c3751b59a03aec2d0f14f2d0b022440c839cd4fe2ea9b12f53a806046c63963db543a8bb3495de61ebcf4874121b1b850d96dafac3d9ccdb9fb4e39ac826c957aa0dd38bc70551f7767ebd830c6a162e9cdfbbaa6fada18f7c12a55b70602c30104fb45b470daf192c0ff9865ecd1358e76dec451b72cf9cabbb8010497b2b5a136a91b8853cea1340a3d476939acc50fc8af5f168f8ea761fe6688da93e84c0cf8b259ab89e6e9a5753fe8e1dce26dde6fae4b05e73484f4deaef79871f781b0adbcddfecd1adf159e6e9e0dc1170fb3728d1e956adae0517b9b71e1e8a97e690ee718399c6e8d3cd087c4a9ec61e964651a93e123d9b14c8c1e4de4c37b580dceb46ea1d053aaf2faf3ccb10c8271ac7e0c088e362b2076833bd889bcd375922b121be85d7d9974765e57d0026edc0068679381f3414cd5ad48accc5dba7a9b8140bd1989dff6a120a4e9ce1c516bb904f4ef1a2ef359a45bde6e25fc21918e1161666c92a80065e652331108a29769c2c02daa1d3675556b2932e9135e119a13ab23149c35003e21b4dce2f53cdf21a4ee54da9001c29b94e25955b10aa7f67e97e2792585fc8080f6c5c884ee0a9da2601bb9cf371b8e7887ec4840b34ff937d886ed152e7048acedf3c90f073e202c468ec89a106975342211dfa6d78f273f528b1db4984a5ef97192c8719d8cb1d14dbd905268d315fb1a89fc2853745520eb8f86d089b039dd8ced094609a02daa2bb35d867ccc1d0585f5f76e51af633e8d686f8f774696ca60f8da1f9d05d2ab57f35a3397993496d06b85f812a9afd3d19cc5d97283e1be184ef4e6abe5162dc451878cce8b675c6bfe7e1b3d11653b1d13386962ead02735ce792698d0d4400d275e01c1d787742c322c4c6fae03b32ae85637aa566c577ff8313c0b8a2486bfc5afe2149ecf8cc6114eaa28271ef086822726709dcf391a46b0f484284e3f59d13db74631bccdb344a0f534616fd91c52dc952844605a712d3321c492ea0595bab7539e165d3ad3c88eedd2e9559204a9dfb6e174ceb21fc33d9fbe8d3d5c45df2e732848aae3bd8d43ad66a31aa27a082faa0df3828557877a79da730502f30b7bf0089619a19287e4acb1b2394328c31e9dc48d1b43ec660ecb7f2e70054771cadfc83214b83dfdc4c488282db175cb620f884fc52aa955beb190bbabf2fa0478013cf392b6e7211611db3e10750f0f27c3d14b4246fcd5447d2c406a09e04c0d0e8df284c210c17c8d2eeb083b25d4ac78cc2baae1bdb8263c7d08a1e55a1bbf88e70532832f78e935ded94de771ab12d637bb9aadb75d7c87104dae26fb9300478fa4903983cb8d5e216bdd64383e97f6f0b23638b4f5584ccd8b9dec4e381752b3c2e56a02f56489c49d17a42ce28b1d3601f38b45ac783597b456fe9bdd2ee272244d83b723375c5baaaa34af622813f48ad506c9e004ece46d3a28fe41b172543ee74242516a6f6866524ed97276b7c38d7bb977e064715c89313e2aab8a6069ae506d476a8054cba06eabfa0bc870180442168a43da99078b9181b4cf3f8902fbd9075174d83f92f79da16652bdf1d5f555ee2aff870478b1de60edb3b71d5ca33848d80f2e44d8c1de862108ab0c35ff7782c3acbfdb337937ff5c0c1c3195a9fb9fd43b487133c0e70b467359bbcc25bcf9638a2717aabb476522a86b11b218b7e0c67618aa0fceb0cb31609d2bb88cce0062b53d9aa5ef890f25c33539a51a3ec4eb5f730b9c238664764907bfe6f2a7a29989cdeb2b96f13adb0354459f43a349746fcdc5e962182f163ca2a81cd373a9132b4fc883df8fefff5194a5f2ca9ca7df049d36117a0c11679f4ab85869e1ab242ca0942d0fb7ece7372616cc563266cbaf39fdebfacb8172a484ff58526ff69262ffdc472606d9146a216ba66416262e424df96c92fa77c17e0843a452e91ad4d358d3cf290a5d00be7d359cd79de4cbfda07b6517fc476e393864979c88c9fbe28d5706817d95233305481ecbd358231ba89ade570159420ae648fb1924ba29d77ca6355904cbaf093cf33520566d1471c4072fe10b0e24cedaff2750f86c566d901acb4bedec88ed1c7f0bb56281f74a4fd0b95b77c613d7e6f7eb7e9b04e794156f0767670090b0f048f99cfd494db5671a3ab86f22bd03a9bb8e47c89b91b3296de3e1ec98bfbb0b3396e8870028b3e19e11d6ab009dc454919145c916df308cd2de2cde61333b593f3b4b351fc36779dc8a5e0e811fa58e7049f7913d9a45a43ad130f0ae8f7aa09f7f6e2a4ef660cc042bc232565e3ff663b2bf706c87b9b9313b213c6096fc02ecdf519d43ab8324011f4c6f406dd7c7d34bfa01968bcb473e9a3ca08bb9a5a402fcb0893ebc4ff0a17c4889f9aa1e083c66a95cc6194932c68cf536ba1e13843af6a140a9b2192700ce3c2442b1925aa60568de05d6d9e7427e8e4c19314d348c240fe8348b31bbeb534c08cc4d26ff796ec2c21aad64eb182a2bff7a0354d2a44f2dabb63f49e1b412932bfcc65984d8b02f9d41d7898298523e90fd58454130a356706c287475c84fc5beaed9c707d1224e714cede2cc69feeb5c1d85293c315f6c38de87cc42cc49d49f207568dee39a635a7ceaeb3023aea220f43491a546aa8a58ab96342cc09dc24143e62d18e33d19ac6336f9939bbf8389f35c8dbb619fecaaa11d335e4a8e6121994fd6bcb6536e8d193cf45ca1404c57dec06e4189fc499014242ed6c294fb0ae62dc7503fdde657c46f082c93a884cfc017a26d4b14aed14ea71d6f0bff0470aa316ca506b7dd191c8f82340faf253b1990673acd2101f50d2cd524428bfdb65097bfc26788fd8586e0db8e81d5909c64d7da63951ef3e11cbcffa90e83b8f6880d8a7082c36a8ee2531cb39fefe64d23af23f4638aa88a4635816047efc180a4c1ec1fcf36125e3d3954728d57aefbe3992dfc01368ef36fc38bb895c6bf6af28949b31792b782336d8f932afb1a225ff8c183fc9c45628d4168779e2b91da9b7622f30c5bb451485ce3c4830d9961cd78d54929979e307653bc57a0f0cc9c42d5b7a56a94a4cf51bc4da659225b621a1d4a9f52b4dbf81cfa4bdc77ea003d37a0f69b6c9b2712619f70a21f18bec3089fd7460aaa02af98caf9b11813e7838148f3affda8841e5c8aca006302b912ab926f2e6484a72523e0995fa4d98cec0493e132907278cade208c08d7020ebf32386cbd94959208c2e317ea0be93c427868f00ee4a1ef7b3e6e7cc19dcb42179ce7a6d7013d925e53f476065bc1e4e155673e87266286d0c1224fd30542f57e6b4d5e347c57fc1474390c491b05af1874c080fefc1f8fe519479dda9f5cbc747715b0e26c11ec5673268238f7bf0577ce2b100dbfcefae03ae5f9c0dddf8adac7f43e3f4de2ffa24fef6fcb3e4e046078d0c55cf88264f8b59f04abd520f1742f4f2d82295f42f2d6f5947a9979075401e3a0c6d6eef0998783d0b281eb433858a768d573eaac081ce38f481099be247f679e9412362e63e4e17396c34ca45fd882b22e718292b2d13ed9c5c189c2f2ce87cb46615aeabcc1308ff2c4f936805dc36bf297fa51d46276f6798f590cdde87285ca0640777280fdb7898f067b978ff3ab732175be1f12a280ac568c51c7e7c733a2f0963e3ba6f9082eb16476bd99cec41daa695d9a94295eba2a2781836d80761ca6d52bf0761a2abd9c9dd0d0becae4d99ce872334d3b87879d8a65d2ac3cccaba1dc4358e990db7cd5c75eefa8da96d19a4673ff5d81f52d4ed6c1bb7a03e1f18d0031400c40a130481ed2c084155e5415118e416bb4a427c4bcf8586d6eb75163de00f06221023ad24fccf6c9bd4a4e14472bf19709894ac06829c22dcd8d87b5076aea7d487b0030a00e4b626ca21d34ac96c228403f69320508c0485e4d0e305c1ebf4d346a1269628f5fa7c952385732a3a2a8aa8e8953607bb64a55cd84d3877b03a6b99f46786d002ba21dcda78ad24e32b5173596f98a84dee0746173ffab2e37b5abfce32edbb9469ff1cd5bfaabd6a0aae0f7040b4b20321a664ee15171eb72f7e88996ec31cc195af377d2875c18e8090094355a241b781d30d006b878438403804fe2cf50cc111f99cd944a6224faf4e13cea239b5070d8ebbf61df911692165c11daa5f4e46e5fce9d17d372f312ed87052869c41631cb4c542c3d61de73c62224be684fbca1dc3066db1c3cea11d369e7ba4c249f59e273d4c6445049669c23fde03180685bb1840a4fed63bb8270c6d8e5386e54f40d9440140b228d5d5953922804ef2cc2138fdd63ebe347ecb95729c630afb85d44877c47883c4f6dad9abf2c08bb57a119a49fb5e6696065dcdfc48ea5870f3d141e3db5c15d7b01e7ce316b55e55c673b910c2465563127b72214e2ba30cfe54d1ae5d303015acc1c478915ddae9ad02147f23786fb69f821b7fd0adc428b56d62787ecc20403778c8f7e621e291e7a36422089f528e3fc82cf6d1ac2466b113d5e62c1a628a76758f68a2d0f0f1e7ba5370ed1f30dfe651d6157df5a985530bcfa7d54210d3442aef4bdf16e5da88d1fa80e88e2b18bd9632ae359872d2aa977d6f14f11541109bf3641e2fce6ee7075966d9448a98f228f4d1f0a0588a328d6172a00d0257c9f6e3e6715fde66088a82c8d850791cdaedf61027eb3b1b00a34c6780dc6fd1acb519dfcd25fa54e8fe1b4738d7bc60d0198a5eb9784168332cc0719c8f61e2f220a93403d29c31f35068cfb6bc7ec7552be37fd2f3addaf87fbeee12e30864b687a836bd1874151e992e363bf8c4e9c72d3e1067cf86328bb04aa78592a8d97724e4f225fac607bd7580febb485ecd1207dd71b98bc443a6373b2097d03e7e20ed852b3f849abb73234f540573d2532fbb46cbbf99ac4ac3439da20f0043b67514bbe835b23593d4c387cc9ba49637b5ce5bec2be10738dd605bdccabb15fbcc99a9374254551b4978d89bb11d0340e792636d524e948f3b0c51fa85f320b578f3fa33fbf9babfee557dfce5109fe3350e34f2c80e6570b74a0826e1452705e8d4477841eda18c50e2f0e314f11309115df362e5d9a7f711d69d64ac2973d82a3b1742a4131ca2aedf94462a93827c8033ff52ba0b0df3dfa3c0d3ffad83bdb979fe793a1f63e977b082f9a4237dec6abc7ad7a36e0e69c792593939d152df1a9720dfc907c9640eb619cf19b335ab582c1503d09b363ce8e77e871472c5a7afb26bae2d9e9c1a0648b8fd147fad65255ca0789ce696dbad4e652ab52ec09c08e968f8f3b34e0de7cbb37e05a780ec92b25b2f59ec85039c7383cda03f40099ba8dd3488ff164d1f7a225fa458325430a6904dddbf24e96b42d5190359245ae8048bdb9957ae081bb45bad26041381d2fc018bf9a5f43315a2d42151092bd3ee515e7b00d94b8c477b4da28563c35dedaeb38c56e053901ee3e1306365a9d24989750ea84d29282a7ef4a4ee22138728e61ecf5815c09d8725a9333faf838686d71859b1545db74850f47a8d02c86dd6f0cbc2ed0ff8bccb505fe0a7eeb9ec6032cd32c751bb17a93a0e16c4312e705f3c7c19990684212732ed1fa221c12fdcee701bb6be2a30568039988311afdc733fb7577f844949d7df1030b52a456751fc66f1521b2cd0ff9f7ac1ed7245565f3424fc8ed52c307af170e85c5b26bb426fad8227872954255262258b31e76bf9fbddce52d9fba6db0d5254dd964e92209cd9a6133419801f4a1e029f6a33fa8121638b507389b4d7e509095d131dcf9bb4ebbb7bef0636cd0620b4ae36c1568ad27543b124a68026c5f62669297b1b81463874ad7f769e7b3d1407c88baf3c0848008c0591e75356d2b4e0fc10cad7b8e8b5e6cb2232c8f90ad5aed4cea1daf44cc6c66282cc3625308e31e64caca3d8303a9b1bca2275b7be33933bfee07af758f44e9bd9cbdf826b4847afbe7405e3cc92e4cf61039f29be4ab4eb5c4433c1b848e1e0b1904bdfa661179e3ebcfa4421599c9bd6ed1fe3e929db5aab0e451b99fe369a4fd7154f0b05c7d2ad8f8d22f54fe7bd3a1dac05d4a0f61c5e5f443447b06052311c7a9fd813abfb1a97bf9ab15be4bd9619d810ab3b81397a84303daf92a6ef3be8d735a5e46765d7700af77ea31bfa1f3a91eeab2fb39a077fe15a6b5fc9700a48cbc3f6e9d0b833ba816edf7a62dddf1c7f1fc7a6f1f4100bca21055a88d8d6dfdef72619181fc35ffc6e8bc89d8bfeaa7fb0460f3bb275e983a92c8bc754b1505aab1f07b75d8d3996ce6c08653b994118663eec8526a791034a247ca1061eae4bec9ce9740943cf34a07717b7fbe43d47e7dd4d13afe2dd999c373461a8f0c968a12ab2169add7e3165ab178eed7f34761ddd3939112e8671546b1fff397f3b5b5b232b87594c77dd29b7e20aadc1f9323336ffacd5d49ef7fd652faa586fcd0e350b246e3386d5bde6e654060db333e05cd560df73333db0af47ac65254c5ac6cf59a92128dc8160515804a361462a1bd9977a2b6fc4cbcf36719a5fd68e7357d2cb11927b21bce4d24cee94cead0d8d04dac475be0215eed5f67a7c5d5a8a64822e8a867f23086f3e9e8632a7cf832493c9194dee4fc3a53ae047b2141b0062c7e6f5d0ba822a4b831f962f5e1c5227ffabb3c36c98aaca7ed00277be8ec00282c0443a62f49a567d3d3020a1bf47dd9f165fc98cd64fe1d38ae2cff4a9662a9ac8310a2281d4a8bcf990fe8a1c53d43843d8c8a1f619c897e6280c96738882dbc08f167d980d529a387a1584ee2e68461ad85c0181bc24ce938a49a429b9aa74e956391951a132fddd2e96f5c8b7df7f7a43ecfa95271557e5da1b5316873c64a37ede7ad29535cfcc3e2a8fcac439a93d500215e4e07b7e563d1ba7d14d8d22c3045c9750b624fccfde7624a84f2eea95e182ea6c92ac40f7b657fb4ff1463e859d20e940cf3064b66fb6aafcdf166ee9fe413ca0764f50cc0a8bb38d8a283f38e286dcef2c52e689749a60e70cb3534c017f9a2ba48ae624ea793b976ef8a732c3647b714f35e4c7050194c4515d41e05b62e30efde610321056c90df8026527e3a6b689fa6f137bc4e8724c479a7bf8fe29db143d8dd42570bcf206a94f60ae9e5a72b8d91b33668c189b8e2125ab8a03c4e571f2da6c80dddf212ea3ad2ce5e5cddff18bf2e8b7f46e1426c2d55735bd3cd285cfb7d0c907c32b70fd9637ac4153f614e842be40f787bbb759a8f6c32e40085e32ace245554db95ad54e4191d13d57b29953e82ac3198f19099360fe631b53324fc269ad50c2037f1d2950ff301b069a10e51bd97fe96673ef79e75f48baba0add8e93461c5bdae66c05ff03aec438a4c3f81c90852822fe5fcbe25c4fbe9e83916d24dbdd0fe8bff3d50f2f21374135af982dbdd75dbf433f2bdc0c719bc806fc2b8d8729e184d7d7b021ac40fe97320d37a4bfb5a0385d734c87bfb61286f49d86d7d737fc8d62fe17e1d0831fa45bfa2010ab3d725743d930caf66067dce56ad6757467175094e8cd9e3a2a47b875606c3fd2a7a5b522034a89c467ef2fe9819ec8975b1055f3dc05436fd8a317dc197677acd0c3ecdf609a6121f76b1060e0f9b2dd61180c4ff62d1b68b1c782a8dced7d99cb21ad612408130b3e7ef2ff1e16a09add577da2668ada69a4b3adefebc0915a2b4b2d08e2754b34b923129933ff39ed5af2dcab7a299925d7a6c37cc1fe91be2bfcfd3c5bf2738ca0c846f0631df5dbf97282919f2833dc94a1eacd17f87f57be5b812a13c0579c12224a25283664128bccfb311888fa70be44a9bde6ea905d5cac7bd1d74e5530c0580de1c96ceb4cf6c3a94d3b12b016e79b8b80df27b50686921665a898d219eb182cc208c32e64e259504e93033edaf1cce567c0229886d914fea7316968d76b20d4a840501bb2b78da2a20e3c593f60fafd13dc448726475260e900f26a15e15cc0b1df1e08453255b89573ab81377ad3e99a45627398ddebefb5ffdad99fce90d395edc0132fbbc0016576318ad7f2c1e56de12fe59f070ce6b427db7aafe5f47c83fa83c65144632bbde458d60d217d0f9fb7517420078754398d78ce3cfe24b441db223da91c73f5c0314704c446d0aa0f0799fb86b53465b8b8629a123e720269462bac85299490f830ba94f0884655db874c612d75df065e8ea6ad483b802f2faa2986bcba9bf969c8ad642be5be327655845284a3858f280512d4a8daf653d182d2457cd6495b1623f659430b0aa75a7273141b5d12c0636cb7468f32ff64add77be89acb94feb368cbf2d7b417626229d35825ac6d06cbaf9e3a2cf65010b96ec8266e908e1fbe743b9746a4233be4f43fd2bec7511dad63b3b19ab20f1c3051e58c00c7b715051746f547d2bd74b2b2b863b7782cda375460b0f98f5fec8ec91e0ef449888dc0c7e09313ac7ff8e589e6f11e746fb0ffb007ed2c278f7a8071fa2b6f4b3448639b674c1a966f749a1d54014237d9c950801b3c400306cdb97537a6eec67bc1c3c3895a8584a09f87eccfe8ac567dcf3f4a8afab4c3ca7835e991dec8f380d781a2a839724009fe27dce9bea79616ad092e6e19516af1d572a6655198ff403940bdc2baa8d54b8c35e289c1ce56003792c4a19b2586c018951600deefa987b7f988289f4d8f24ba3daddbcf7a678ee765c097ea0645497dfb02df308b1f67cf452d0570ee5e53f620ac5bcf4c02c340197ec5ddec2e3dc8ff61248e6870a170fdfcb478bc728fbe436829199d36760505d2fc01c4529da10b9d223aa382633810c792380a5ab27c36266f3afd575c7e1fcbe9814270b362c5356a3df8c64ec6da7e7fad0bea8614079905419d6809280d2b63fe942f592bdfa5564e84e45627b1a52b8f58c119ae82783f5b8d2afa387d6b29472b4199738fd56f06e46ddaa38576de2e2fc5956174c100b9ba840f8c5fb056a54aa48b8689cfd96c19ec31f1096d77e559e9ff4bb9c606422a5cbc43844fee9f03646bd7956b9827eac30add1750349686c3c61db8ac08add146575efd8a5640e3d447bafe6067798e3af573a4c080a88b4d74816ba1a4fbcaee9d04e96cb579f8af06770c729490b702239a18b1c780919acb88c0acbad830a423eb7bdfcb271e139c7699c37fbdc468db34c2fd1c5e10862a46f9a504340bcb3130c2f28fabfbe3578e7a0cd9790ec93943bb9dbaf4ac21e73646bbe0b8e4a6ac4bc33da948ba6301bf05a391dabeb366d8b4434d1c1ee5cc8926ea4e2483a9ce3ce5c69c12bd6f11c56ca944209506808eec004487bdda82d9074526bf4d88933bb46ac033d436baee046b44ce94ec780585abbc914ca09bfb8704b2edca9c2793a10c1457c9286c40827ed29facfcfdd7890ced8c99fe8f6ada1bbcf4ff1539dd9e56fe48e1f8fca09e6254ca26f83c85c8e88821a0dbad17e92f7c951badcbcc710165fbaf0024abede4fe253e1a1deb932a82ee917921b1cdf05493269b633ad13ebf4596b3a46dbf28a772edf84b4e57e690275a3f9a7c87830c36e4d1ed12e9967e7c6881a7435a9eb1a848c2e006cf07bb46ea240ac4793ea5149ad6e61c99c43a3212b086c77fbb6707412aa0c193ac3d819660ac7a0fc03c190cb14a78affb4a33ac2de94f5a7415ad4f75cf8cbb9965c878c27bb50f82051e566eb6727ef07f214a3a4c525ab64683db0db92aa6972dab7179a07b5cb7381baad14de565fa903a584566b9bfbfc3214102ae6e58606113df9b28a6d3c3913eb1905c2ce4fc188fb644c65f87ac66a334146c4f0e017e2f74a1a4e0d6557ebcc9f069dd082647d4b2519e2344c82710e074d4e67796a7a42e2eb1a63c43f888501ca0654a8d12d35890634de1d0a89ddc591e69a3e49283848aaf5f52fae76b99297c6c176c560303a1bd824297f14c3b1ee040ae1e27c073e19054885608a620e07338936528e8bfe416abacb85053b082bbc85f33e1b4ed5d33a6a18b7d22adb4f4a980d89d3f0fd894f736d9a017f6761e8f2e34d7b3816f82e2fed847da6e7853dc88dff50aeec0d62f8c86b038ef1eebdf4038de754d0d61b73eddae212ba49e47e2473151d7270a8a525dafec7f6a56c0050ff2595a0dd92a7f49c51d7265fb30104e6e57e838dca2e3cc7ac630d2a6c919d2f39ed668ac66bddf0a55bae4a9aa713d230388d5494786259dc67c9c94242d30f03e44dffefa16554ab86280b6d4fb20666d1ab126209268f6313e7507be78e660e3bb5414eb9543f080c10e2ebf7641928981542cf49a2de875e2c71f8ec784afb1b48f6a433fc8f0e65cc76af0265f867e5c183b568193f384c9f17cdd9c244f99a71d6d957b25e0cd0d912a8d53da72363ba8c8ac62c87231ba8ff91b91c272c1139efc74c03993fd20c1d4e0b896ccf8e8129c395c327a7afe6fd77fd994daec48a66be3315c6e5c002e8f0c01cc1f096f20524bff9542bfc6ead48c85f147c71cc9ae005c5ebca548d7ba1028e8b4477df0d4cf5894130e53d4505e9f70e1156191aaf6b05091249112aefbcc413dcaffeb89fcf6970f86fc59a1b505907add0f4ea4c383ae472a886406ef123ceb35f6646feec5bb3322fcea870c06c9f5e9b3cfb505cc0e7c4afbf43ed0f9dd0a15c31ca26fbfc6924ccef24f377e834c3b36aa6dcaa034a2bd57eda4c1a44a740b41b7826262d54a165779f1a272bf09f567dd749e9be8d03c4a98174284398507d9f9e6ceb1df5ce00fb844cce5f72e909c7bd41a358a0e2f4850e2b5d42a9d1278ed4e09e4468d69992a6a486f52d3d6bb979b70aba5e036cfaad6b6b2993f8e5a9cef156146563b30d05c86f188448383273598898afdff3a3222b92adb8b371dafed4f04b8d13f2936a8db2e0249e5e13cd6e7a015d56cdfb7ab8585d7b9c6e93900b5f522d11d2e8eaaabfc4c20740cf734eb51614fe8850a56d2592704177eef0b19abccde2df3dc8072116de4059dc7fd74108d796cd8b73113293d350e79757f377fb57be52fdf2927a75b9840785263d5867c0e5c32657d49b7a4631feba99a03b5bebcdadc8683d0b52ccdd4ca6b1ffdd8008d51611e66274b06712ca4386adb58569c4160c72b2605c06d601ec43d3e455bcd16cccacd7d70e5a7ba34af9916ec0da526258f18fffeed0bab4fce195ec1059f416ac31b936decfecbf185881e50a947bdf57bd5d9990c0a1766e39fc221e767b2e33a58113923c31c83492342270c9007bac46e7434df1774676da5d56e9b00d2ef47932efd8a6aa40e48b5f1039f37c34b400b8a0f1cf4d7b63aee6cbd2fdb1722847b7befeb0cee7c35fd44792689365e6c9b10ef63ca485ad03241c74c25a1ab3a925243a41f3b62e792c448dd8592657d05beff224e27074c7a7c90b8aaa6f99d99aaa4f9ec7342c98fd698786dae593f68815fdd60d0dea2544e7c49cc2e3dfaa5f48cb3592ead4fa43cf59fec5d9f3407a50fbfb6cf810c33e750d90aa35b98f9b434ec8023df54df2eaa787d27877c51e583c132c2511e03b76c9005f370ce46d4f8c53410f1f1a912aed2aae7784906aa317e9e0e7b3db5ef5d7d3a65c6e262fe2099b9082e5cbee3d079c5fc9f7e5ef65503001a9ed0839cbb30368abba95dfa4176b1fefd313fb22ed2246864afb395af5aeff0c876965e734f83cce00fc965ab677acd5e0161a89425a8fb1af1c6710d2299b3182d0c85cd913a14828b36cfca1c97d536092655da65ff019707d777cce5281dc9709dfd461d95a214a94d80927fcff04d6f6042bd827d3e142c83ad9fd2528390464b71c731129f04f2e75aa129053e63e56c34efe9e76b88a0a563589897b61a19cff32dc275f76f12d64b7f2fe06d19bf0f365a7d104a847f5faf04a4d7c66a041caf18a1a60710296606fd6e58dc3f0083d838ca32b67aa88745119d47180f0a65f6676b7d0ea5d8d52018c7f529c125ed267ac9e003b94505d1f3b96497091042831cfaa37330dea0f67fdbe23c4470e809da5e49dc5622653513b91243fd7ca966a71be66dd965065449e3595c3deb2a98c4f1ddfb989961de34b7a75a7c727fb5a43b79873f2837ad979a5313ac6d4a49bc4079a1b14697b5438616a2439cbdc7225eaa790d49c53bfab66d60691691744234dff5df18a516b978dd0032239a8ac95a86cb9832ad594ba50bb67672423ed6745e9302d38fcb8529d98d904156a5d99577c4fd27dd707e510dd910f5f5b584d1b9fa7d4f0186a0800b669a0d98192ef07d7a37853fda00b5ca6cd4defb1448109a0eb261c8d8ff680a0dd5892f980a4e1264b51d33820092c3e367ce2a208aafed15b1a48a1118ed4596bcaa14a43b76ed60cdf4666984f296e073d5377c1fc048a82d55d4d29221038dc5f27d0fbe5aad1cdae5f9e159b53105ecc4adadff5789623ff97e02e22d3bda957548fd5c0199b1816d63b07f099dd6de887fcf4f404da91e03542cbe142580aa0a8e668234c71480b86879204188a40e3393a620a594752a87601029595202e53783ab586b6020962155c994deee4ef42e9fc3a8709da8c4d415636a1369b335d60a319aef1320b48e359d258606efc8fd663d38844b8207067e2ebdc9e5a8b590a2a7a51bdf7eadba83f6668de068e0a93af97ad7a7e5fcb5d6814c38bbc60bebd3dc987657db490f4e7edfbeb493909f4cee3561ab2ff6778b5c8f2846cd206c803ad556deaba4e81aa9c780dff1aceb064e1e3592c2df242c6e9b1d41343bc53615ee1a48c47fa07a364445c9917192de1df86dcf77e7c87c720cdfe02d39849eb5c8c4bd8a35413663c5aa02f5a23ece758e651fade45d6e76cce5b5cc9626671d04cbcf1ba4d08020f6d074406b16bcc52e23132f81eb8cc7ea35a2b22be7f190f740c377c8da2890b23d8cf8d22cbc8bc0c50f5fd970a5e98837076ae93eae2b10a686a0fc84ef5b7c155f322f3105f2f4db15b17c86b8024cc4ddb0eceb250f4535c00e88a0a5024dcb1c0bd094d1db2b13a9c0ea2b6f0daf392a630f5c34f3053863a62d60372f4cfd2ea72055cd4d6af62cc79bffa58e068d82415ac0c761e239c84194b3991c6f9ba9871c1848823ca014049c05b5eab112295cb26939761ff19ee652fb5be6488362ac671ab08367d9e7a26829456c5b9db816bfb640430de4f85906285b0e1cfa5f28ce02d7dd07386ed4156965c36b6801e9b5f195b29c017ac36eb16b02b0fc9cf55e14b4eb9f0c406586dafbca80b7824808a699940e22b299b3f56eaecb3125473ead94ddaa1dbfdb52fa7a119c6c10dbdf7cf55b7dc528ea9e1b494dda6fe77175745fdc9d2e758429123d7bf536f3a4b5bbace5a97c10978f4251ac5d7444e60082d6d8269dcd4869d61c40e515748e708def86e3b27de5f702342dee03181bb165af6d369ebfcdf144ea1b7fdf8ba4c339065a2e6b8fc745882f573feb96bf86c2196912a979ab617240c5b7b8fee9101d8ed53c6af60324d74b4b27c01b4b1202478958b86fe3dd67d43de2005a08a778337d1863bf2cd689911f7af4a97d22522657c59d2cc1d42929a71dae0420967d96a476974c73e51078cb20fb5c5aacece6c126abe85e063687f7bd82ec61cb26cf705e29ff02c8d40b803f07260422560a97c8c23011a2ee680396b16994a5723ec877b2225a0d44b4adcc57a46acd23ce8516edf97b60d2350a6d0698b1150cd077adcf1ac1d5fe4a84aa512a0b0a86d56998aa689201e4f79190e6eabb5b5b13a74c3e736ce015b0f05ded3c3d6b93c173885103f1fb4109b3a78f9189dadca67dc584df5084f2fb1d95f0d9bf54c9665115c6e043d0dcbe4fb6e0cd779d010a420f5b15d847bece8df3ac5be6bcdd92ccd2b28de089a55b76b813207b8d071dac7042e77e5b0ce11f234c64ec65de7d881065d49b81c609b5e31a4b49db71787ac8b765c3040fd90a576f89774679a556c2d3ecb2109786b85ba53365ef195dbeba2e16f00dde731e31b675e7410442ed9014f1287cb5862b6abede93ad52a221a425467f357a89747af93495d47228b2c2ef55d9ce1c584452e01f10d69416664059eada8f8901bfad6a744d2c83b85fda60edca076f4dbe926cf29cfbeda751862347e738895b6e0969dcfc93e9e2c67c737ac439ae1c97081a8d9ce4179f47f846dbc85c3a4b866d941ddd49b6603057027e263fe254619e535c33fd06ab4d1326921bf36a75ad584c93607bcd94b431cffe6ed7b6b7681295f960a8f1244ca0f1ee7e57642176528fbaab65ef66383088c5caade14e7e62f1706d013d68bf03c825dc11fb69dbed83e2af043c4dcfbac2109462dbb14c1f464f363061d9c33ce8c2f51f479c9c422d72ba493050c048e3c9c4f3c7c7976ae0670e8ad567b433690015e3529a1d05ffe3f7fe6f703dd609db29a3a183f739e0864df1873a0b7679abb8ff6dc8817b9e70f61815a59bb5ee96bff9762fb26d2d1cb10cbbf75cba081ef79359df93714e6971118a71b76804629319b890661b7141a3ca8db710236ad38315af52e7d8bd29bf7a6a20f79f146c32faa3e1721b7f8062f45867d33d26f4cc2872bcdff7cc3df9510bece622ae486366d4fb7466ca3c0b87905514c6e493c7bf6b9c26862b5662e2f9557df89c139a5ae82599cef8f93183d5e07f95ded6c588ecf602cb472f35b707adfd2d2971c921b60afdd8fc680a9c394e676869a5444bd4a3f438c0a774b3d24cf5f2afe1a4550f54381b2de74ced4e2d001e037c8edf413c29c970d8828ec2b666dfac207b97ee4d8f45ed4de650317d9af4ec111e14ec59e02d456f4cea90f76447c88e3f90dfdada519fd69a60dace0a465d8c46bae374624485d9683651311d2a1f49df946555eed38e2a10489e483c96ed482e1d1230c44a05c30f1f104248699d29d9dbec54bd0dc95e25c1e2a848dd2663caa2b1968273aa2678f872414e96be156ffdd14dae2c5ecdc3a479f9d2093cc4125a169dd5e8d5ff631a13e8834e5b08ac8ac0dd0abd747a168c90dbccef9f1c02a26dbf1b2951e45781704a8ae4bea59fdd90f47480fd6657246b99c8367c6c2f9c1d031e5020d039b92628d83bf721a675d92d166a2231f4e31784cd6475d9e7a4a3a1786f37faf97396413a6be5d7c863f99afe45f56e2844c13db20b82b0720cf2715970d4bf5f5c4eb202f9b86f893e1d2cbf7613758f797f89b4bd40c1e979b40fe8d08d5fc64f5f5493e9cdff7e681dc33d6d65f927214abb0be202c9453b5b4fc2afb356e2912ddf249a6d1967f6acb68518be31b2d755b632d9cfff7a083d4e5ea20f3787b4da6acb4881d9b462630cf4aada2d4e499e9f597be59419f23e3282e92bebc7d878d1fd300d7f3218030859f5c615df003573b707a7d6d8b11d3a105c3bc931320247d746a92476a594a59946ff4d09475ed5c52e3bf7c8cce54a5690d1c2a031abcc41573fe6cd15614c819bbc638139f93c54a0aeed1c217c9b7c4a62bc1881e240c4da379b65964c97fd87ac53703bc9b69965eea9a1675684296bf6721f030794e626b865f8e897e2e75ae583dd91902d26afe1ca6a1a845efa4e656af560dbe06a08098da403a4221e4c4b89a16a9f82a9170e3b3a9ca3d157d2f9cc77ddd4418924a440a6e93ea64922d8f89aa69593aac1d0c1456b558b6168f291a99a17dc68b54f48283feb9aef90ffafd916d628b8dc10b8c4102621e9fcb431bfa844b8d49594174fc7fa572aeaafa494f4d83e6462be95591513aa1bc7708bb5da41c2a4d1340921373d99d7135c53fb3170b4ec4f25d2ca86a9ecab01d669631066293baf11880dd29a163f62cc67df4bb8f794c11fd350ee3f4f697dc720ad85bab1cf887fe09899be3f5f9a03f814b94b67654b350229330491ee9e0f0fe6d7017adbd7661f072f7e3f6aef31f7b5f7b9312a6d5fa917718655954d5c16b9408235e8604ac4015b16f696ead6af9abc3d3a0aaadd26ef17a1e38d7cfaa3730e9e54ee4ea9c872aa6cac6a872ccaccd8ed7cc1acd85c055fe759ad9da08e1b153a8c78a1949abb7c12739bc965b81f2a57f6eee2a4f1811fc598b0941b9aff2421606c2e962037451b9c075ffc3268e3822f2f484bab55a7fdfe9184b2149ec7ed8d5f3b6f443e1c24e1d1f3700aee62b4d3737e49c794230f8b0145bfcb384172a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
