<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5cb5d74b7b148148360e030e38475cde95e11468ad3103e90bd85aedf5712ce66644b3f43e9cc98014857941ffe171220f1b24bdf34d936211e4545a58ea498c94b195a77e33947516c1c960d1f4fcbb3b6adc53e26c557066c2bb35bdc440ba74fbb1a0b77eb9d1f1a21d8b67e621e7aaebacbaebc9c9ebfdf262ea48fda0f0133d9ec43567bf52d1c6be2fc8da375c67f0f2136fda063365604a807343e0a41ceef5b98675ed69ba4c38450cbe2fcc33a2c415cfc81b0dfb24b84b99a1d1e7088496af29fe32ed3b13843a7e04dd0f5eaf543848cfbb0949faa99b8509e11f70a636fe9845381554bee087417eb4f16206427e6bb7a654e7d8b855500481ea02e140a5feb713a490cf6f94635c32bebf3e9d5d47f7c65cf750a60acf4941ba280bf397a19f45812f35b49bb99a22f8291d902be8125ecce3c801da69e1b55634ef66ba938cb4c90398efa481f0451bd069fdc2605f6ba2c290068c5e9a99412094c114262001f63f991b3bd8a4dc5e0a469338b5c111459c608b7e0efd90c59128eb39090735daa97d181571261d82a53eabe7d48088b2afde74d4b73921b07034cc161c2959fc2c6cf05742aba4a4e227df39cee242d47d3653a9c2f8fe6ec1f67bb6aacce3760bc39d27477fd08624e76a1948c1feee646cf19d0678a572bfb4a7642e903f3a02575066ca725d496e8455b38abee5d4d1e140f4bbbf0039cda8d39855f174fe1c2a57b0ec37beb90c466df01ce9a31b1e31e01a25fc0f7a6e9cd2358a4ef8dd96294ba81e377668c20eae47678c73571bf7df4859fd08d70792d4d960a42a6f90a5fad983edefb6c6869f0469865418e0d0164dd546a167cd0a52b1f3c9834faf151f1713dd29ebb45c6ae17c317aa262e832d196de130dd5c6afadb77759db5e3f5703d15997351b72f3a4709506b54771fea5ab8d266635f9a6beb7705b032c0469aaa1f3bf089cea5db4924675433699b8a39201e2d9173da98ba9c117b239bb41f3d024b8ba9950ce9b4e0de5b75c945c2e621d517ae9f45e5386b9f830f81f6f53c26aeb931e06b33d94e2579febe540d31940e4cf69f35a3fa76620a9b791bac88891b76632b56e0cc24a920a3e3c0056e9da2ab28b0efa5d01fd0820f8d7c08892185c995720e5bb7946766995264ef115e1f41800afa43d8988ab51227a6d88f7ec27e9d44892d4a3ed67c7ee5eb6b06ba47f1b463e8ea8714776b0c54521e1e2f136dce1bb9c6ceade288483ff30e40c20e077b295983c87970070ecdf4e2db3a34d243cbe2e5bed113195f72c88215301ace186a1002724f1772a5e2593a9de8caa2a3d0c4be6e144620291990751b2dcf86d8cc0e09ff183402df61b87a34aaca83ba017c0ff0cf6b7a28fc741f96509084f6b043639aa07e4b6b0ef574cc7f1ab75605255af5be4d863ba3e66282e511c816c7c2cb0bd8f38c1ab890d7afbe937abcbad0aa91c43df440e373459499363da227ab89903cc64f94505610244cb9bfb83b45295f2e9fc92f940501ae1f037ae40449e9696036c92d745eeb6f580c9f67a07ed859e773fb8d54f66ebb08550e74de89668e3cc8ea7e572b782fe84ef2b17d18be4cde43682c2ac7cb60642a53aadbd0491de5632a0462a742ca607a7ec9a8944f2c2dc3ed4f7c5b33c25c11cf1e8902688306464f8e6f9e5d6e5a74aa1c5a780e7882220fccbe78038e4dfa898a87f61b52624df694fc40e4d2a57e1bd91c228c74492b82ab303e5e0d3e8f31986d86ceb628bff0cccbff1d3cda26f38a2440c9fc338685757ac5b1d1dffbb2f2a03108a21094a16e28dadf93205ee016257ca055487e8f6db43a60fd190354af6655f800fc9395930a884f48dbde13a6f37ed6a22578f8784b85bc844c470469b2482b3263d311d0584837ad4057642c91f9c8498e3b296183f65d44b9c7b8d8d2fe2b0cd02505d864f0d1461696ed8464aeec804fb4c476b526fac20523f14a16cbe545a4cc093c733c2a099e61f98d6099102b8b2e3180ad42b6bc4d40b6d06aa85c74c17d7ba3d505b2d800a136da243e0b2c30eb622af8c039ecf78e105c6bf7f14b5b10f0fc7988d0b709dfdf8aa558ef6039889b99f67117b68e6b232a49774ca46ebd1ec7c4a6ba40001045a316d0d1c86269b7763a447131dfb4a0cb7978b6ddd2f28ddf93b637ea7027015007309c5c66f8b41cde72ec80e2f917a53d8d92c65e78af98fb6a121205ad6585704ee241b97a3392927faee5ac5140d1c6bbd7076d88ab2e0b8effe250c9970ef6f9fabae984c3a29bc5dff4e7a52953d848ed0f4bc39d3f067a518de404b693b0c2215b6c4fe9f732c7e4c841aed16ff8b8d325dfedd08c927046596baa3956b69c611e23c14398dde3a00d3b4b633b57cc3172811c859a5614d66c76efe735221a617b1ec2f7f77d59306f11639f6eca8300f4bdef5a7d5ee7105a25df34b39e8cb1c4952f5ab23e1b5a75ab7c272e0911d231fa9376d60041bcb71f4a0798999dd90fe39f5f4f1aed9beeec802c265f381901625831561b93ccb6d981515dba483da2844eb25ab2c934d922fcfa4f402452c8a904500f5583436167a68dc6796be93cd7ba9a00d5eb462379658ed4d569446c3c96831bdb943f5c707cc472135cb57ff6775abc16fd6fb17cca35ee47e89eeb2eeaa3f39800996e24a09ab85f21d56c67c8de47bca7a5c5b258af71b3251b663a9984f4e626e9f61727f123d29bee3be8ad72748c966752f49b3d35d36bf6a02d2ea68b1c50e298e5b844e3794da2206c4f4c8f4adbe174503b6a8e8c0f9fe8d46e08a916ae3b25ce89d78d2c5bb2673bed90554e190d965ba7c8fca7df935808e161b4ec5e75c57bcf8e87c22a75f2c422bb95b090493888845cbcec9b485b9b6482a664dbb8db9ad76a2196ea42a00bd3dfd11936df8f9b1690f8653fdb6963f7b8891558c24c6719ab6c17be60e631b87ac8439f118afa8c3a3709a27a8626e7b58d394130c9bbb093bdfe9f3bb6ee169abbb96650e3d5a15405c439af558b2688476b04294a192eb63ddb98ed495d89d0311ec7baa7c39c7c9ec7ab02a159c29102c3736460447e40d5e5bc346e9e49da60b87c789a622720e267009e5fa3211a7dd79a470a5620de0cab3c751dc27580197f4472ccf8c273de43a14851e1bdb57ae388221de1db93bc506854b084a5702eef2d9cc9c2e54556ecbfefc7c9189920b72c6436051b2c2fd2d823ddb9aa4fb96c1c2631e51a599d9b6b3a3b2c6cc2ff4743d35fe6cfeabddde806f012256d62108c44447f806b1a2ef18ede44830602e27b3885211a4d9a207563cb273f079e3dfac494fa63d662da3fc9c4114f8593194d63cbb0e81d72e8c4adcd853ba9fd9c8f088bbc21deb26d723dea4401de3529d8582888b1f660b87e591a15651fa05953e8a403fc356968a48bc744a83e4b9a181e4cfbac2082ffc1c78873689520855bb9c2a7b83787eb9918288d4d6a933852c2c41c9e827c1278d5043ffa588e3064eedf2c6e7eb33f43f5fa10b6558bd30ad7c0f61af235ceb7ac64ae4b17f648579c6d61e3c289575afe09f7e81119aac32b847ecb508a394076cdae7290b86588e4242fddb353bd92fcb154add629ccad8684c91222af1445a282c8ab72f7dd078dcc4dd1fe5e85e2279d713283b061ea95e633070d2bc5c87fb23684469def6a0f16eea81a3d997dad608c621b190822edfa5b8307564106ed5fe6c146ad12a75d3717a15069517949d3c0ebbd9508dc162d6277bc569a07946c659f0dd727a7eb83bd73c5cc70a19d81aa3e8967b6252c4e922b6e78f4646c545394cccf38cff86a012ad8e8ff5a5d8b05bfd46a0c91d1da8d00d5fc4169fc5d23ac6ca2f5fe2a74146bf6d50ebe044505f439c00a0c9c479660395c91303e7ed98024ba7f93c7ce8d6de28bc038017ebbf03f2bd168093e48c3494d2a0d5499507b6178bfb326788ba88d263424bf0b6c642a9edf05098f1d46cf6bb2dfc7acd33c09d36739df8f786f5762d96b6cf1c0c64ee1164d578476ee48c3f13145148e8984f7463c9799c2424e6567b1ea51ea507b1169de926bf2bfb31fe37da7a86e66d6d2c0af0a7f14b4ad534a093fd2566705da79d5129f11e52cc1736ee68ec1ef4fae678e167448678051f53888b361d3e9279d4dfbda8f600e16134a5861f4073d8ef5a1452509c7570bb2bc40e2fb2b3aac8078738f2792bb62475435f696c398dd32d3ddba2ac626702622f12c1a90a0362beff661ec303fc6903203c7af8870ed93a2e5779e573fbaaf1b5618f1288ae90ede62dd00ac569c5059c950d6ade178b6f5892b3ca05db46cc6a5b64dc5b99e5cb1e7754b8252d97970f557c581bfc7b553dc5c46e108e266e11788abe0fae5bdee5fd982a04da7f28d2f95b031fcd2fc7621db572a6c6468e5129f12020e57f69886ab7481cc090543dc3cd40e9659f5cd59d3b9dd6aa49cf311cd1e407e2e4fdb410baf5945d19b50f514c906138dac445478aa5e892b7e70da59c104ed8833f4db54771d39d81fa5773355640a8b8c38e271213e9888278efe28b881ce5dbdd952864e55677bc9092be2e1ee09dbe2ada9ba96937323cacbfe369ef446b160876f48f10d58b46c2a86ecd9c5ee95ddcaaf715a7215a485a6c11f047f0deb46e72d7047bf3030cda0022fd6cce21ceee3fdb2d3bcb7d70cc45f79d1e63065620f1237043353c7b2447e1c299296a29be892b506d98540e1947d1e7717cfd78dd5c863e76d8a4e3886d150c80cffedbbc51dda02cdf783fde3fee35491fc6ae68d483978f188ff44ae6e1b5e72873793a6c8deeaf8e8fa7d3e633b510ce293cd999c73f4a2af9ef0242bf226482905fc9bdd19b3958defb9522fd9be3dc06c93e1de6b27b0ce4aac8843eaca4027fb74b312ba706e85eb792a1b267064c5b39fa7cc9c0ba2d3c98184c2c20da32144bfa97ba358af1d7d1b3b681d508170ae2df4fb93d39e3c40cfb61bbe50f998b91d19a83fb80f45e0f20663935d715ecb7f13dee46c8cc77aa5d76e5b359e12c553f168bd36e7339d378a00d634756b958df62e9a52379d2da45cda7720fdbdbad500d775db2b39f60d461ed755ef15858fe7eca5390bfb2e4386d714266e8c6e21d207cf0eeece3c547989efafb1e6933c3fcc7dbdb8377ab23575f3b234725bef6e26c93f300767023adc8440caf8e423094e297dea6aaab0ddbe4def0afccb82698ea33e10872d5794cbeee68013e92c2c97f3094e64c7767c49c2f716e3cbba529f2977220b2cdb9f4dac23121b9a10b6fcc2efec207c60d025387f68c253e79cafeed097520bc38797ff67f0b0a78a4a8a69818b2ea6eb75428599d4095e7a28ce2ca17565bee475d0f538471ab43d77ab9f2be4e2901adf03c612b60fc0e0e466a1becab6343fc70da911814a3df6a8174c008c24307814646d05cc4df025a78f404f2be1b4243798834fcf85df103caa95cfa6182809b51bf95fd050c0ba50b6bea6fa4c6e195351ba5fc53e9a0fc69a7805cbeed8bc1a76eb046fd6b27185ea2fa7410ae003c31fa25461039ec435bc9ebf86978a21888cc2de321339938a3a312d1a42caf67ae074bbc9882a121a3a8d19cc633f746c39048f1b2eebd2d9852203e90c11b952db871a5885eff6ed9604546dc64060af7871d5e78f6b3a0b50a44df8263653b8aed49c137f545dda4c1a6ff0a0694ce28b71e364c8faf4002f618bad949c61e409219c2e7f845889b13d886e8aeb5f334729ca0e6c7d3494a60800fd20c17c995ddf8c2af9151740a40b0da5a75c3ddc7c029ccdbc982188e6dcb0be1a285d7883590908bcd51805fb6e61e1c656225e2b75d92a2549bd5943f9fc17211b78df9d100412c318f7e022bb13ad822af2dba7bbcd8c3d2b8639c00fd77945439b2ebd59a24a2f8af3fa9f414fc6f862192f48f038301b7626beb63e3b9f4c003533ae28b6b2d11ba46d1c4f6d567a8d3242288b9897cbc463f7d0a590a382be512b8b385e7eecea2c51e0a838face1d781f31f240378f392dc533f9c90e63a7610fc42838fab6527ac59f415c2e8f63750cb141ea8b5ceaaa5000a7276ec40fc6746ef81d532bedc0f7b4554317a1f3e8862c3111ff1801f5ba58337ab3528e2af3cbb86330f6944102f096e43db80298bcad0ca18cb54ed5de6f3777bba9979f886f3ab96df97777cc249afc85784c588cb64c9a22218ede0f97b5f625a2ac06e60ed49bdab69df55dfd530098313f77b790ae86c7f9c89477085a56d91418681729f96901c51da6ba210bd7773d1e94cb77d7ab5da1aeae5614d50211272cfd473b01aea72439e2c36008c220e4e13e709af4513f02e5e5fc8a2f98ffb5237d29cc6b94e4408fa810160e15fe2fc08cd46d08d45563c398ed256c485a965437cede97d40a00c2797a28f2ea8fa0b4c6e3693add71de463dbad15c6dc5a35ec0b0967c18e03d598801b8f0007e837c14c46cea7e7f160e43e7fc122db3a8c933af03c59252e3a4e84b473f053daa66d7b3309de1787cab898baaec813445d8cbe944d4c4173fef70503707daab6583a1a4c2c50ed7127fae5a7f7dc32323774a9f593cd833609ea1a29cf892a15a9f120b28c88f6cb6a14d66bedfc3144937c93d583c2c3dcad83d715ce43071f94cf9f63ca0d0e4712f55de837a1cec731fd7dfbbf8d8db90a061f65089904c0d6572daaaa25f33e7cfd2cce86b29d00f758da5aec4ad291622e017a69dd768c91f17d16e74172fb0d89de54f5b06380afbd3cf0e675f9749fde914ed590a0b9d24445206a075d344dd6cdf4b6d429f2ede33b963285ffce93a2541cd201b91c9dba3f810a63b65ff715a81c3002d43fcc371819946c272cd98552d814737db0969fee2179cfe588318c1a0d5a286d9f8d175f6389c4b66c6b78db08d36581e6ef7352742d75a83e1cabd47508496ee011048dbc387bf8e70f8e6f2712c3a0d6fb98242f6877cf577954078eb788f5badc6abb2d74842ef638c9e1c905443f277e355aa382bc23fd07e2274e5e2cad2b03ca238eca74d2c241299fcccac2e1234607f286e71ebf9d211d1a834559b2a010a964cb32ccc632430d192b24469a71a69001fac17888f48b68d0a906d14a8b7875f52cbcc5a8be753257467b0edcbb642bef4019869a26d7fe19693e4f466cee7a0d81e3fe81947132b84fb2cdf4fcf7b6d4bb8492293b3b4745d2c6c822da536695b279b17f4b1d17e6a1d08c5eb51464f1f5350278ca83efa55df5641ce4ce22972f433ca57646b214267b472c4efa4b638d8c6dc44dd59a4652e5524de48a524924c636e5ab2a78246a9c7b0074b4a30835c2367c5f9160f01432394ac78a6319face66e5fd22cd995def773b8dcc3f40baf9683eb961b9fb1ac68d7160c5343bfc5386ea32ccc7c2f7ce8599c2286fc9e93650ba7b8b8b59139c5354467e928a47234c31d618b1c31767df8db8abd8fc75b16e198fe12fa4fee061a763b0399dfa68cf1b1bbcc3f2cc2b722db5e789cc3a12b09300fb2ab9f19976638b4ed328d5e74add28c34f2617454b62a269cfdab96dbe599b9fe206328d2242ac742370a5505a087c84fb76ad820221b85c24fd0ce62def0d62d66b5e33ac2ad55fab39eb9982c737f6bad4a4cc35c5db48af8c033c7e664428addd3537e64f194a412907e7e5ce7d23cb7f77d7176ab7fb1be1dc9f55c15434a7df0f954b83abfd6d4b3067ca815d1878706a225dbb40410bcf908c1bab58ab66f08b22a94ee1d4f755020c38e4a0b27f26237ac199fb22e1b0a19e2af22aa0f5464ba13c7621e5445229d65409a9c06799f48096820c02b25063dc1a5198abe45a434ece8b7df3b47c61a19e8acee1975e0a4dc7f6559f6ff25e747015d450d864f99ed6cb604c7967996c7b8ffd203de4e18474a1601851ea2caf55f2c349417b8863f93666576d431b3fd6e0d5d56a9c73a7618e4ec0d075d6e047de00cfd2ae0263225205028500b56c8175005571e07ed100e9dae3c903c462c79d6fd627abdb656437db1c6c8f47edca0a0518edccfda35e54133d860e182df5ebec8f1ccecc2c3168a4dc7cf5b0a3dc30de483528493b6b7131f6faac93b3a4b30dff65c56bbaa122e71921978559993116a058ab88feb6a764a20772aac85913361c8ae1169486d092000ee4fb40c569c25f01b7d69c2cd790669e590b5e4ce80ae99c4e43d3915d88b390a5b08d2c3be5187a638388a9744ba8755bfa987083e02a041a4c87e9179715ec4f867602f685df03f3952e5ea1f249b733e8fec2f12fb6f62988b4e50f7cf371ff08708f9165fba64c52bbc13c6e3760c38887c207e79da5d8fbb3aab44f8a15b81b83ed8d6b6d9e85e412b7d10f848b1ab6f07e554242af0f985bd7b05403063bdbf21cfd22834f8ad17eaa2a1f943ccac1f648cdc825d874a1271ae7d904453f4a19ebdd4b388245eba49f35ba2ce66342aafda4cccb76d338d4092dd472a2fba1ea78257c894871fd21b23c87a1349a68541c3e51f1a61befbd5ed01bbfd87fdd1578894f068828f4b8b69608211cba77fd301e0d6759a0e74258272bf494bd8e468b9c7afafafb9e473ec949977241e5a93c71901a461936ed2ed1709ee48a55e7789a087d08e55c699129dd4cb1d198968c238d4e01152f2584aaaed6d1a62524b2f641b2c2f2861c8776162443cdb79968b54c8e171777db1e5fac51f6bdadab6441fb02c8e983d6a17187cd67b2fd488dd6b9574d8f84b8006f9bf3d7c027673fa11c5e2ec3e24067cbfa0eb998894cd01bb0ac1b60eec61ed7bf9798f0da2e9d161a0b58b02c804b62baf641e03f3a2973e54e1709461ff6eb869addeaf673b20c5f51bbe44599c4ccf4e902490da2c02e16d4241e2e0aebaab6a730678a4cb0557828bf7aa7cce51f40cd7167eb9e60b0ab9a077389c59c9cdf6d82a62400723b15584f8d2ca84608dc626f8902b5bca9abe135652d8ec738f31f3642808da129f15a2de03298ed081d1b297fabb7e7748e11d3876e4bf9a7f8776a86839116bbfe2795cdde3da81285b2072bf88d34ca739df1e6b43e92cc1e7f56f0bbf5b67323b9f94cd9896b11410fb4fc034d42042ea0e86ff82ef35a6037b281415c9f9d12a1f6128b638943d45d2faac5751c9811ed02dc769866f14e548233720f97bd881c1ff5b7a57c1943f81ae3549482c4275d7a7342927fd7d778e63609d408fb85bc190c2348995f0ae454010161d8efd3cf305f51e128e577e16c2644408da9c4a49ce01eebde4c3a58e15048aaa81eacf8e4e85b4e8b48a30b35429ffa45f66c406498c8d3bf65a8210ceec106c36d92677d7d9b8160dd2803c9fbf71b5febca9bbec191823501b25287777ba6e7b51531f7222d9470eedf86aa245a517dcb3bf6053ce51f99889ab483da90af9d0b515e17a7a652fe0ce0dc119156194a567067ab3f61cc089c30ece31bc3cc1c9cba6c8cb591960756ac52da02f13e569ca9790c1b4739988928de325b548ebf4b27d52f86a0963bbbbeb142a1326833675f078cd35477b3dcbc85ce4e28518e5297de23694bb5ce65bc5372491ba383b951b0c9b9d7b614fcf1e59eca2f971dafc7721a619f16f3f04a5cc15997111180852eab611db4e79bf66536768a0b10d474334c73eced312020b156d8113df1bcb8833a6555a63bd25fe1f73899216b06474fc2a1e31071eb49ab6ba948978a96a351cc9a8ef34306e6f02b19f590ab25390a347b21848923fed02ab74f6e524933eaa669a9fa55a845ba941024dbe781adad7ed5ee3369e5ff0969ef88cd2b0edd498e21eed819002377402cd154a4316fcf451a1ab7bcdcfb90f28f938f5851de5dac751b2f699f53f37dcd28d07c179248eae203555e21811e4ef27af7bcef567c944b5d1b90f3d2be537f655965d4e561bf02757dffff435861ed63e8479024a086218f229a1293ae642f9e7b0b1cdbcf2dcf2f3d52ecb0da351fceef59ff29440e0ba7c38698b7a767a293fa82dacd7b3f0268a8c1ca285dd47c1a2306bbd5839cee5f05bd7ad5bbe57ed8a9103436323782ca2ec3d7cd42f28a449ed4f63366dfb44892ead348b03e3016286312b2e0b4941f414ac91dc3b578e6a0fad5bcd9145d77a075c24fb240af5c28f067f594c750d437b102fd1810e53232bbf4346de542a7d07adfa46ad44f23b0d67a0f0b5e13e8a3a7015c0b6a89ffb6ee3ee087c3ec454dfd49f6c1860f28f0355a3535934b8cc6aec6406e323d86a42daf0072cd1a716860576f52bee9e9f2ca3e5708f6608d36f828e54314b4e6258a979dba282c34fb9b3e7b27f09db7b3ec6fd30276ef84abaa7de09b1315d8e29949e48de3c9c0a6685aa3ced12caae39b0c7de74930ef301d24d72707f608e2f38a5c3ec47311993ba2e2db58c31b68b49edc3641652bc34436f66860adacdc47f874b4fd0bd2dba8b1fce2faf8ab4dc449eaf87f211e84c1c5a27db3556944591b8c7f20fe4859e153ab3e1f800dbbfecc5b4af9e92f96c2dc4d7c0127c6daf5203182969a0c87d66deaa0bae2e3091817f6b1badb62560a6925076ad93e92927fa6194aaacb637261a054ec33f0f46086590579aafa14034864015fab9514392d73cf02e61ff6db25e27a00d81790a057fadb617c789fb2b0c12ef73391c034b2af753b54187ef862edaf31a77c0bd3a1ded59dc21a1170b81d214f7cb732eae14ccf3c192c71ee83e86816103352ac14167e5dffcb52c8dc72af4c62937c533a3734e74cebf24f86eaee66c88fa652d0e26b53f4d9f93d6d7230b74ff3f59a064a9b050eefcd3cf43a26082f90006d1de50ae01d9ea783c3714b9b0472c54da17c207035c7d9ea6e60c7ed3e1135d4338c9d200f0ea8efb111508c7579146327253c2038fc038f406352b753f6b0e98f6cef6b765b0bc885bdeae377b0f402cb5926f71c16efc85967711283a402486d4369d9cd3e18b1155886b92ee43c998eb263fddf999ffa37b20e4f3813b685e50b1a9d6039670396ea81fb523e42a4c2adb4713fe52ce607fe71d1ef945ed8510e785351fe92d12e6f55c874e7bfdba0c9e3d944958183f6e0ec46b232ee73bc978f15949c175ff32db6ceb728a7467d2a8facf91167ad4adae2db6c69d26ef7f63191f6242e4aa17a0417b10336fe3bda19561b12bfdf6e7d38e9c3176c2641702df0a531942a9f4f8e47f954ada116ec031fa415a387c62d32c531bf9c900c28a1444820cbe1c78cc17bced62cc3cd45641fb294e88021a12c5d063657fca2cea910794d28713923e365ed63729fba6bb984f6d39a14531333f40b9e25cd910aca2fe16ab31fb1d91c6442af08d0ffa3e986391bc6e4eef41e7664bf8328095e1194831aebf5f913ebfe671636ea55bd629a527bf66c60a4ad3dd8527c959af2fbcec0f1c933d5587ac8c615aea47bc900b41663778fc70102a77c156e97b07a4218fec89aa6c03c8197e4658807a5f3757436da803cc9a0f714306318e215544eed0ea97e6ca03c0d17b0e5aef602bc5b3856cd7a2bcf14b75de9f079233415e510423849ea81544acdc770f8ee89341ec9c8d35619ab31f28cff387db9983dee5d2802aa0893b3fde9b53d48dca53f5a1485664577532dc8057f91da411e31dce755f3f7995f132cd63f035a0cc5e4de009267813325248d64ef8219f4033489aa689ad508b9efe99408fef5bf7a4ec9d1ac8701e69cb68ef7580c1293c7b58b3c8e917c5eed45ad13fd83db4c6475531e84f3e788911bb6417d380abb9a6f43329b99ea4b49ceae30d86d0f44e53ab2f07fe72d76d1147d826fa590e042ea3044f5404c5a9e5593733896340f041e46765597e410763e5365e88a1514dbecf593926ad915512adb803d6b0a23b7db9640749ec8fe49b55dce3f151383593abbefe0123c3ea6a0d2d844d666109a82a7fc16c75541baf11b3a2f9717cec581caaa51b3415baa1c815aed904c5728028f7751fa1c9d0e2e448b9a88c8e3b25fb0cfbf07313a9b6d0f9808926e04adc8aceddd5dfd39617cd1fdbfd590b15f5f15a407a7a4e07227751e23c3de60731058dbf8da1cb1d44c2859cee9827462d5289a284bcb03f9da1b7f5269982fd52b4335d6082d116fe9c7645d6597f4927933d1e3bacbd8a9eca722403fa226708cd890076667c4112113eebf55e76393c5f50cc72ace77856835524f717e1233ce456360229139e67e14aaed30a3efa5372c95156d5dbc29c695cfff29804b18b9ccac3d1fe0c2456bb189378210d7a7f3414b483a91f6bf3474b8856af88dc31dc932a0f92aba023aac0eeb90676aeb219e76cd735f98047daf939023f1cbdbb78ea868cce469c351aa7e1429e40a9493f831c15209977078b4bcb8a391e0c3ae38c4a8a408c2cf5b7995c7ff29fcf0e88c120bef317e2a6bfa91385c5f6c926e9b8bcd9392dd8d3fcc736682870675c68a176674abf2a7b129227a77572fc13724915e7fc5aca3339a16e297d5065a8306e5db427a526ef252045aa32f781d0860aef357234efbc5576777855bde68d4cd03df38646fd38554d7dc734f97f94a74b7996e29fe2eeef284ba8e0e04a17ba416028495e331692fa1014d7a007723e64546d4ce1b7f74e09bfae7740ba7aae75af226ef76902ced39ed7f44b959fb892d69c057186e3799c2a5177e8532729695ce5d9f13a9cba1fb93d45fd0ea3615deabc7bb0f26afd767ca9af61197aa97b4e5338217c40dc204b167e9dce7bd83854f7762e6ffee4f5943f46e6cc7bb9b33a3655bdd8e96d9a88b6c4b7545ac080bb2c008bef0f45335aa7a1985e92304b211f5bec63ce877e330b9745b9541d937d794abb3ba0aaa2aa334d4b3ce53f616ced8fad3c2b127867469d947bd9e85c6ded8abe1174d31d603feeb603b24a2e9fade1b759bf2c14989c0ac1e912da12ae2cc5b545b00c4ddd1c622d9d761258c6a1e3f169dadaf6016137b7c06d6ca26bbd21cf74e3db2c9cf61ab664376c49c6d7d543f286519dc7eb8c0a092b09e82ca3e311764d8ad55e63b130f5d6bae3cc6d6bb3cab7fa35adf8902dc781d5d4cba421bc6e283fd035cd444adbba293a37ba8661a577d0ec834e537973de4087a1523dc6868a6289dae23afbbad2bb5d2252d97645f3c7bb29c24b93f2c745f2bccc4c0d46f1c2db57ddd01feeaef54adc7444ac5d214e5e7b2a97046643f046a67588d7e041ecd9514ee5468a193ad0dc3ac4c3f79c790c5773dabe8609821a423677fc903a4f052b78cd94be712799a1c73cc5451a467179cabd984e2fd07edf7ba65213ebc41f900e04f399015850c654c43c3a32f9c721d45cccf80927b784d7d27ced64af6170e6746fd25e42e837de5ae2e44d487e8819c9e640acee6e22cee38e860c6155cfc2c92c265b5e8fa4c3b9dfcc10908dfa775779240b21c2f00551cf8decb0ee3ea705871174456cc8b2eb35aede92dd1e1b425942b988447fb4a50f8328334242afa32acd1bdb09b28ff67d9b55736826ca14f655a78bb0faa3df980b05fa3830596c1d4df77356a04960bc95d2879b0d994fd82189a2b110314dd34309bf62dad2b88abce529464d9b9edbff76e28faac0477c5ccaa5843a60737dbb74ac85c3998e7ebf58fd71e79c6d5cd8c7ddca117c2a3f5bdb2f54d320586fb6fc77cc160ffce16ed1528daef94388fe10bb59ac0ac243a442c5bb0056ce8cf2e546e485dc0c26861f051bef03acfe75d41e4e69898a9fcf514768591613280381cc0ea2669f2bbcea38310e4adad94fd1e2fed56c922f5d639a3e4549edb077aaded0f75e88166b48be5bd126faae27317fb41cf6367bfdd6015d29d18ac74065db5289781cad750946d5bc27b18628d03b81faeaf9c53d6b9579c196b05f7734e267f0059691d189a4748fca5b9b4445c4e5abf4354bac252675df894464f7b0b9089850c99df35d3d41986dc0207289eed29fc96b839d5685b4493beb3df8abff4ca7eda86c3b7bb39385a8ab1ba08f0d4109716d90dc2cc4ed1c21b77dbce3ad8f7be2fcd3c451628b2523943329350032ab60243c706b605b896af601fbfe0367f1c65c2e535c6bc86ba317b08e241615fb96e11d936125d8ea903660c1387722dd29624812130be470a39a9771346ceb809bc79dd72cc09518d70fe58ec8bd1dcd4b4ad02ea60415a29330023d76df836d725cce79001536205d495dbd87751c7dbce99c3e15a6a50bbb7fc19968fa411280b0ad0f07ee4ac0339d7b3b37a20225999437add40aede024ef26c6299819ab7a548f16b855d42a11d0b6d8405d74ed6f98a852e4e1c735e6e5ef7f7f922c5f0e4794ec8d9c86bbd2d60c4bd62bf8c7046b37c7c516c5a7abb677e310a9567ee21e0b142028b136ce878efebeb1cb37fe53b5daef6c81cf73bcc1b7ea19208951586bd7a22a2d0968431acf14e1e3bb6ab7651d10951ce78484847114d6b233cd1c35698b0ae71851f37cee05518c561e315decbb4a8be194c1b765fbe1a0de9e31b9441ef376086df114d381c76b0755b469ffe0bf575db16ad9f93b2f4aeb6679e7db8f0009169e3b2e6ada3ca63ccb0fa7bea324f39cb31305b3dae07c6a517cf105e42a23b7a942b13eaae7fe3ef74f8053881af1dd24b66e60dc42d4fe8114378d4b93a99dd5d0539ca0f4df01cd8bf41eee04c900d75b20e5a2f08a8275190f6085e061c6b5a536e729fed9befcf4ff560534abe3b7e9aa3ec5281f1faba6d2ea452ee1ce63613a1c73e9de4c38337d208f703471091420dffc10fef5b48add7897eeec1ddf2a2acbb70cc53eff6fbfe565decffac99f0827101649908f39d7ef97d7ce21488199e9e4f3b2c315f7f1b0ceccf096d0d65729b2f44d1eb359fba95a913c5d91b304b595fa498cd4c29e39e8c544c8d5f3b0db24afda1b96e37c6b1f5fc5e00a0e5abdebc4d989095e3d33c140638b27805c2a9162483e8c79295ff38476ed99f05d0ec014ff2952c871fc606278b80e58d6046e444bbef95489914d511ad893331e984c047fbbf692567546d37a8b47c71a8a0d308df2b79916fb1b92129aa8a2d2b763fdc4c4024f960699a7fb8db2784ec444ef37f05c553221a2fe72465a707b9481eb7c14fafe6639c73da45159f7df2f8105141ae9415d0b24e4d1e27c695edb2c02bdce1d75f169e753f2c6d187e489f2e9498375b189e1babb005cb781e01a06f3f1abcb4cbb4177e889fef030071c7440da83af783419f860918634ee120cb267aa20874b8a646b5dfd65152516f6e723ee3750844b367d0f048ffc571dd6556d4d0751a58573a47ce142dec1d836720eb379bd4a2d4d1e24a82d0348763e75b3eee503f2119f47c1cd6eb3d54d3043f01bb83df4f042da3a7152761f494f91f9b7fb31d199f8936b30382ab670995c96a3a02cc5d9409dc7cb393cd3a738fbd35f39b983d446b8eac7ce3bc21cd0d470a245e2b90f5a7ebd8fb12d03805263ac6fa43d289823c3ec3ec3b6b495c655ce35c83cb2c193d6c55ac071e2c481893ef77202462ebc3d957a8d81f4dc872a3d6b5399efdcae39efa027e47184857dc6740423c3056df430f6d5fb95af9aedba180607dbc90dc815c7af0399ea040a3168ed7cea364519d000b799b297ce7d8c31a12dce167ef8d7c665fdf791902c93dbc7f6791035a45fa9afe2eadf288442f370341653b7bc6d4886b0749ddcd94efba10233493962f24b2e52b1bd79e995a96a4db9cb7a5cddbb71a6d1a9d768deb7389065601243e43d31b8a7ec2ab0455b179f498b9c765961b14b4768a9981b0ad1f81652aed820c117e1fd956b9e4c36c090fdbe62edf2e583b1ec8ccf5b3a5fe5dae2be532d554472c19ab7fc5a42fc58ee0e625667ac380d87660b74384b06241167c0e132354115ac25808a1618da2431ca376079c1d4ebf88e9be722b605f0477bc7a03c4055e267ae781343fcd66b6aa76fb6ed38d35f4290ebfaea597ba5abe1d7d5a96e4ac0ca5f011b5706b6f2f234bc208485d481e3ee0922bca549ae8c9195b90137f21193da84238d6af2ba3b7581248d41f7ec612929548abbdf0adb715ab856145ac62dc946001b3767dd42d1df77a396a0e5d4e99bd15c94ebe64ee97b80755dbc98a18eb50902f1ad484401fe4b1d3060432f9e91a45afdf10f34a651348e81ebc0603e88febf82c55617aadc4fd84c7511838bbf545a78c8fa49e881d3ab2a74435a208e8f916f52dd1baf0756670648517d81377adb3f5556e4d9dfa09953ce779bc732f1849d0ccd6514ace5fc5553067d20e8f446af6cfc3575c4417b8bcabbd2692a3271a5c4a0757e52fc06e912b3da263207d0c811a7765d61a4b10b87e98461f63b2c086b4d253327c654f1dbbd24f6ae36e27d87937fefc58d94f2ae94fe0e572fb32be69ee35b1471b172cad35798deff6c73e85d46a460b2e23a9d6b54f77d4e57143a847f0670f801414cde5573d4870655cea564c49abb2c9d46b83161702da45323eea27621e5bb02cad0b75362a8fbc4a1bdcba4df4fcf96d32f3cec25a520691055fe2325426b777a2cb8caf866a9a03ea8fc26ce2bf8b65d163146270ff02fb3f630517d9382c81af84ccbd0ded2df817d964178bf4a8f56076237e7adcaa545220ca211f0b128558b6236cb6c79e49ea98f57f7783e13567ce8997ab94584995e02b275402182da10962934eab8bd6ab8b68ccdc237bc891e6711678d22773308fe1086457603cde5a7e11ccc8ef27d15cacd183487f348a5653e5cb798426a81bc9bcbb9f2d6ff6613ab688e4c97ff7c019bd6d42a96ced90c38ce8077b1551997d6c762c5d01e57c7ef0465207a64c2da59a42c00870055793338d3bf80416f577ceba4b2736ccdd0f429dd0f90eb7eb8ec01a55d1dc4a916c8d8b975fa0f342c3e78437bb87a7e6540d2b0bb7febfd527ae6ed34582964c117532a591b51e74e107ee82dc4df51c563af19106119b971823db992e1cb50717b37075ae447b1f647305fdfa2f5338ec21219287d1e48b0a842f76e16f4c6cc10fe4a8897f63a98e4b06119f369a430f1238dddface14cd2daa37896259fda0385793b728a9200edf54edc2b355669716c906bbac3f0c161cb96b15530478c956649e656923e8ff8581d264caa5ef93b81d30ae3fc4d01e8fab7c0be227e61c1e0b8596fe5bd3aa5d8b16cad207693c3dab1572c4eb9cb9ceecffeed677a924cba8596f923a3a611f18dc890f465effb496e17fbd2604b1969fc37804f38591b0cf5a79a020dd558330e6e6d23c80b4c966ac77589bbcb25ef7144e75c7ad9c1d67ec9558a5c9f5f708398a1c5a416bcb3199ea13cfa8af58fa3651cb6ce643191184c3a8acaa91d8cbe08ff9a9c942af11f352008e9d168896be3472bc44d3e8cb326d09a48339ae4f50c6cf4e7e8e4c470b7af6eae855bba334c24fb6bd646d51021a981a9c2ebdebb308f3bd819e8b880c78fb7a79915eaa25f0dd707a2451dd7d1f728d985ac8b8bb5d4172a0fb857f6a33b46942c7e7177d619b24eb0e5544ca127628aa67fb691913e7ae7228a5f65a423d9083b34f19c5575360f207514c67d0c5d6a616fb928fc902d4c635745f229c8457c7b45ac0a4177bdb0a5b21babced0e4b9411552a130157b9eb2d1fbc5fdbfb39ca637428034e23eba75e3c895c8b49f93b33769c50be57c05bd1cbc06a43633f6c33ffc40caecdbfc7cb150a565213e152de2d2974a1badec80d7b5a7ca3583cae58498e4855031fcefb665e30f1d9aba0238af4e9ce70cf788879cc928686565dad4e906307b4a1dc394f4c73be01f9d9899bde78f16a03700181152e2d65e5571bfeabb1dc64d81feac8dffc3170417c5e16efabdca9ad8acc3abbe4db0ed18decab96a48e72ff1c51b09bb7fe23e36d9d8abc1eaf5b27af442bf70f6d85de8e3c81f63ed2d3f9579aae5ecb6f31137d2367512aa95d5583c10609f181dfd9d295a8287c80ac066bd4eafe37d22f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
