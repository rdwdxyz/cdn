<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b707704e77675888199d25a9db166237fc4181322b6295b1560884797a456e0da46b181904cbe5fa589ca3a88200ee276545361577e8459cae0b2dd2e3a3aa205e067b78164929c02174b4772ae8985b2d16a3a198c121bee27c618d360587b44d8ee5bca367693968ce9e59e6a9dae8c603bbe2ec54511ec9840af23ac378f47039676fab317c47275732a8bcac627a343564e102d1ff11568ad6d7ff11f161ad01eeca78d9a532e21c1273c369ee2fbaf12198e39234e9343c12fb2f41d40f6b8c7aa7c2bd4d3cbe27f1cb32cf3b7fd7077acbd6afb592342d5a116ad2b0a9ddd99161f3795f8cc64192647f89c191f71945caa6b741d4ebe358068d16ea0ea8c8c4b233557644d8753549eea848d0e12917edd0f0c6fca7af5d8ea1923568d5c109383f755e21efcfe319b31d2a4fd764b882f67d914c5b77d61a1cce98de187ba0bddc7c89750e4de28f361196305d26bb12440eccd1b849e081cb1cea808aa8ab7d6c862b1e9ffb7dd10691b4562836a73f642f5d05a531825acdfe237c835d831e09ab16d3fa5c8cf98a9a93878152cc950d641c44aefeda889dfd15bd022d50e2cd49b5eec2668142f411333f36653fc17e50997d560632ce77bfc80e59c3e48e4be208c0924bd31e423ce76e9a38be9d2a6fcdb4640d68fe44806da708212300977ef8bb8342a15843ba8eae6f5ef6aeba269a07cc11eed199bb5af81201c1ed282e7dc61b101468c1f4f8bca6fa58603ccb2b7cf6127e276c50b46a3ba6422d0df8b383e7f22eafa3d3b09a952f3149ac3c83503a89656eda2ed7675b13b7e9c4f814b7cbe0e02ac79ae3f222cde85496d2869c45d42bdb837338b9bae86afc5f5a483569b6e13f13b1bae6986c8c2c7b498e8e5f2c59330f198435255ccecd5dc3a8f7c980b63751849282cdf167e9b41aaf590e77be8015892a1002fac27e2a891618dd6ec651a77645ad7fee484babe82fef6538f9ccb6aed081b885c9b664d5cdd6a0290acd66f886f71afcc2fa4bef4b5022885a59458cfb5202527ffd5e1318b3cab365daae27e00d9a935fe9fee156e8e926174d0451096afe23e2e4ec5b1d197879f818eb32b241118ac6a2e98be27596732e1a69f528897bb803d92bee163474cad7914ed07fcdfd716899c8a7470dc451a3a98626fd591ae898ba907c07d190f468a11a590cbe454f8252dd77539a1c7e96751c1ed6c14212fbef8a711d5ae8ddf1b3ec4045cb1f5ecd0ab6f066c90c4a87c598ea27811e13afc49d87aa926f782ebdc03c7d5b41460c540038273331100e0419f0fd388c4c3975b5468185f8727d2e1e4732a6e1bada1deaf65b160e4fb222c2de36f245d8f5e02d96cc26eb3d1a39f8c11c5cd81cd523941451b2d3f2bdaa5251461fd88892ec68b676228dcdb065755f3c6069737df4a3134e9d91822a505c54dd514068d974514d83dffadf02bbc13212e8d5d9b6801063c5340af8e3cc4753bb561b5ba49ffdc939a02208c8eef85259c2486d6e0d3075f9908fc8ca6d14573d1aab5c7d8e8bf59dd628416b4929993aec270faec11b1b6ef9a5b47fd0c291ffa70f66606d764d2a08b64f909541b2a9ce0e3176030e7fe2779539b379c881268026d303ffca03a2148220e2eaad03143dea4789324ded0fedc18318a22a58ee623c1d928b6b2ac9d712bfff8409d82d2f0644e0f420cdcf0cc816dae58e61896ee5547fa67fa7a9644ed7fa657dfc75d7f6c6724b3fbd81be6c19fd9d4e60ca31b614ad61e3dd6f6860f74aa366380f11825282d96df5453fbe753664e48705549305063bd2af0c0bb15d97dc8554686c968dedab1c222a86d826f2f54ddcec2d437aabbdf9a6b55d5a0556f8f121c663e6f127bda94138b9550073c683d608981d81315b0883d6c389737334257467b0e986c641849034dc428ae5827154391efc69b579b0342d64342d36f251c3dd3604999d74e8ea763215a3dfa405b7f62d83261028ce165dfc7c7be1391e29bc1d4bf26f706b320cae4d41eb9c3e4e4df723c274115888b2572dd37d5800be34e7662e3c4d735a7980f26d16ed4d8f5d09480ab20b1756c05ccc1ecdb8e69adc5f6a535cd1315cf3f99e89bf2caf4259c13b4a000e58632884cab7192de30cfe6d3ac3a0a08e351614868bcf9f066e587b5c897e7648b9a06fd5d8d2bbafbafc9f0a7b0d35f447aa216d4d5eed09181653b7c3e84c158d1f6b447d9a14b9ae6be3ae229d141289dc104457cf3352f69e0f4bd624fae013b392e6a79e33212f87aa59005dc95b4c5e7f6c4390414dcf97fc0c3c5ddbaba1e1ae584687a8959e585a9068ec5fc337e28b6870e6c5fc345ccbddfb6bd639e9bea73377cc2c1a57aae81f5a9ef0447445afe162f088bd997e07e10506f8eb5652f9c6f09e12f011f424a64cf0868a1572c6187089ce44f72f53d938cbe55cab7922d1f5b3ac302835b422cbf014332f7caa2513ef25b6264dcc418ef17985d14f73da5515a614895616e041a740853bf7a564c624df832b009bce34d885ece12e2ab12a01831fc3287a177280767dc1a218660cf7a6d9169b4ac59214cdb9319bdb930b9490cd4ef0dd90ee995f7710188b417b5ddd3f9f160e76f13a08e181e0d1dd8b3cb94bf6851794db9cee9ce410d8d1a2cbfd68353721ce44f4a36f162c34bc002a7056f1599228f80b0a2250e1da1c9e6353a5adf4a0e726a5f0165124376a24f7039f96c7b5028e861c03f065bbdd07b3b993a14511661f5839e39f6cecaec2c91709d82ee8aa791fa72c733294fff0565998a61314faa3a18f786ec563f3d8515854c06cb6bbe141a72496f76de6d27ba357b4945d68478cd13323458ae0bfd9b7c7218d68884e6c2ba4408ba95e81e875b532a17fac28e34e304628795be354e45c23cd3e80e386a6e57a1af16f16ed08b7c17750254fabeafd5a68d7360acb54a476004f55780cb77fbed632af9b900a223c509bda8aaa60283bc5b70fdfdde9c6ee8e4863b36546a944a87602157486b10657cd6703142b525c0903b36c2947f893975684aebc01e3c5f5ee48f97a424fb8a18e9810a8d7d08a017fca3359201645ebd4b791ac6c9e0e9faf3b733a4bb0c7a5a4b17ef669e70c650ec28f059387eea4c132b7eb4be585ad4566d558842fe190f06eb39add86fe331bc9194da6723690890d4ef4ed5a5091b83abe514702b5453f3ead31cdd16fd42241164c239c4ffbd1406607dca6705a41ab8d3dad76f4ace9a4e238e6a35b896e036ddcd435e70317f3a63e5c5e4841939dab88bff94ab2af7e41f15ed8a98e23ac532ea7db546c6624232793844bad374ec4d835b24653741415c842aadf98249f469cab46946d042329ea2100de1f8b3ba86d1bfca8b7522049b2be21e162e0cd211d03dbe190bd601d6b09dac260f1200b029c25f1396a3b96f8ddb2e5861b95b89a1cde3b9a492128e8d848d4785d5db4bd100f24c6736eea310550419696f6133b8449e08054a7962afeded03f19a58960f316fd70b0d9f86612de5f5a766d594617c51c6b2becb45272041b3c3e47108a6332d54907a3a582690235a29c8eb6c201d4a412fd81aeb4ccce555cc5262a24975e109fbb3504ca8168737151006426b5e4267749d29684d46b09c3b01fdf73cd426a4a4a2341f5456380e90c42d8533467fa71ede5e3b05ffb46022ec966f1b42a064ee0779d61197a30d5b8654c9058a73895a4f1d55a18becaef2f3d82a3368c36c42c43ebb543361559e45efe046bef4797bebeb962a6766fa93aedbcd04b4905286d92dd660382aaf09ed0b9854b612516a5055267df3a20e64d141927afac710a28d79d4c6d9abd5a928eddc4ddb4fc2bccd6a443d4b37b871ecc3582250db0d8fafc5fa8500c91f0c63d96cafd06bb49c623f32f789797197494d41cc4923f1d876c71028663da14d13b156c7b02b89f40fa0f06425792097b67d35ca17d262df5d8e169b271222b645a4b63474f5544f01cfaa69f6ba319ac9f42a6127484ffea9e818210582dc5c12f7846957b92ffbb6c9ae5d0775a2c78289e2801f521108a24d3fe7f916eb68037cdc2d4203c07e5625b7a8b8fdaaf7c872dfa55ad51afc06bcdc6565aaea69566a62d55bed865f232ec158e424f1e7ab8dd8b6c60ba82c582dbb4dbc525a154e464b3e66c55eaac8cee5b006c9de013be9c387c17dc2ef6cb8db6b1c105e950ea77b280516b140891e58c9d245c2205c8631abdefa33c871c5b3fcc3c1d42759f4d5fcb680d264455cd2c934e3a7b05656ec6c4ece9d045f8188f5fb2865a96958fbbe7414fe5bf25ab15a81a80a6b1807e6c47618a42f7f3efc4e62816a21fcbc1f76ecdc185f750d898f01caef1bf5c7c5ae67914d2d81632667fed61ba3d418b5ccc77e7b31cf65c03526b72420af83ae198768cc8fa14fa74017d936e861efc99d5246f9eff42e57b3042ee134891c9a10a90b15f3768a9827497de2f2f7f55c9953d276809dec2186ec072acddaa93f681b1d1507b07c8bd6981daaddb59dc3cd3bdf16dc2b92da2a385b957b6f3712502d3f8e6bafaa2525043ad0563a8c0b76f6a06a359bc730435785b75b80c7829e2686558d0669bd53b742c2782316c64f17dbceb1ad2c900a36a6563d2999c20fef9dea91aa99b6f84a3c07fd32fdffbeccf2e4af48f02a14f5379227e02f244610fb0981d3608c0507d39555c67144abac813e5ed05e43ff9321aaad685eefb208b786cfbc92a05bcd8f62005faf87e852d4a82a55ef7441ab378d6e184ab50379d2859f0450874974ff8ba8710b88f0628e42c454358b74a37f93a1cf620b9d545f6ac2dde5273341298fdbf5c4762519d09edc075c2e387cfe4c6811a7549643925c9902b36e3d555913c898dee03a29ffc7107db8b6cfa97f78865e9f895456bf72c7555d39a84939bdf54dcae2007858c4953cb9e398c49829c298e0774060545e755d9c609d98f00a3fff036277fda3061f7e20d6ac70edb36854a96e8bbb617a1d6a745008a1f73fda31565b2e957fc99aa8e7aba9110838dc15d5ff136e6015917c68158d9327c45c3b416f7b059eebaa4b816169ab658a31c1e0a8722d646821991e28bb22e73fd9d30e0d7fec747ab0b68f7ef05d2c383846d6358711ffe86a9f17b11edbb1dfc70320b2281aba61c96347d1fbb97e3909d40e3b03459168897ba8b86b35014770484876465f02d0d69ec03a50574a7f6197bc352c8151eda979815e5f1711a6a367ca922ee64897138c3e8850550d62ed9d2ce3c33f4397e0b79582982685d0cf08b29430db9ecc82a57b8e5fc15dc4d0e04c993fc3d91fbecc760cce2dbe09195c04b97b44bd57379026f59c0c891103a2813892b1440735c4fed64fdc86218950e7e5cecff4a4c8dab43774d0f1c0e045533588e481e8ed0d826b30900e99a86a9b9c7a1e9775cb351df367fcae61940d2fdfb909fa848da750f6f279cfb293cf4b2152e40424784e7f9e7c5db89abbab3f7aa7968486bd9b935950813ecdc0b8eb05b20c2d7175847063a5b79dc68f346da9a3bb7cfe443e62938d96f4ba1c7bd7fb5b5f6a4d48bb0a2d9228e1159b7a36d29eb6e7bbafdf0234eef2efed128a7177f337cfcddf7472de2c82e7e335a0d321506745e64decd6cc3855b7607856c783ed8aba27ea2fe17be19eb2e841a9143d438f8b05ccaa05d888576fb09a2c5595505d2ed5547081b0ebb8ccc8e787b14cf5b277b097a4ad247bfa3a403c2751bc0b655f1c09ec639cbc37efb15d4f747026fe9150148511ddf604a311a59cc820c69417e4bc23750be47d17b13dbde16f1e16bf23aad26bbd2bb2251eaeff1259dc7aa9c0ea41fd75949ecb4d4a1ff66ee1f64b07ee771fb866621217332275b1db79c158742631bfb3d79da26820b804a43cc4562e4e4bec558f2274a94f517ec24b7895b3d8ba9939f4860fe8191b7185f89af07fd118209ec7de12d8bbf1dffea040e429cabf3d4465774f38c1677b0eefb1e304808a2a3ac578fceb365f387eadadf85889a096036504a5238059cd06791c807f23f71024d6d1dabee1f38f0c1d01d0d5f0ed3162db6a247a7a6eed2f04f71f13653f7f752fa93d383d6b4a5b1b484aec4c464bf0b8e1dc9199e22e951d9c4ef03b14555ef741c49acf63b73a0b8b7d46ff950f0398eb3fc294b541b6ac9558a6608a155e716dc908206274c016699782b0e4069a39f6ddb673441bd422974fc2e3cf397ab618b1358dca15a075fc2f22a79af13d8e046d412c866dad95e9116f279ff6153612f42e8ae39b4f15818315d8ae0203ae1bed0e01696d52638c3414f7eabf29d54e22c2b3a70a2e6f4c3561af160f194dfd765d2c0706fbaf6cba795600d040fd7d74f5cac2ff53f9cfc295d763b61bac1e852debc954c55401c3116d45bd385f2b3bd7f2d7b9d58825166f3500476b53954c3b4c3f022c4142fb4b7741bdc8495248cdd768e66df7591ba6d3cffaa0d16a7264ff71efea97168e004e7638f5c427e2ca9e03d46e3a98a4e5fd2140a109256934fa95b42d0e1a66a694c927db33a8855be0d64c0f468a77d23195e7fa8b3ccb739257d80c94efcf660bed02f3197ff6628b22fa3fe2b2296a4f6d6b112acec34a82948a891959e651e0e452231152c592543fdafd5e6d8d6ae46add2ec02e393ac938a076abc002df1105f4d3dcb37d9f0a431b2697526fe1a09622fce054f8785ce1418c5652a6db017be49edc4c00dd6aa1896125650ade202fb7cd737962bf96c552b1686f68d9f8f589c5bf38abef47c0673ac35e5c50592c85eb778e40c01a1f80c12075322e4a61b7eb54090a281da3f895aacf32b11a06a3e37f48405f15e3eb2599f30ef0ff1d41aa388f7b27201f48f163185886db46c0c35eb803ff504b6101f04d00c94e499a320b1ea79ea9baa4e1286e2ae42b0b035f108a217b270cb0a2c7035f90492c2b579a3ed001cb0088c097780da8630d6ea590bc01e834d2101898f9f47c72a477a05babd9a7df2afe5211eec92f35bf92a4f4803b5199f01bde4b0ddbe73636c0e3a74928858a773f7bfe57b26735c62ca59d0688a3c8483ad7c9e0775903784f42c8da7cadde8980ffafa6361c190a521aae7c12d2ab24ddd9923fad2bf92715e6a6d92e4bcb14d15c94ed047722a0b999d45ce32c36c9d59e7e07de54e49091fd8674fd123e3c026a49158e57fccb157e94d93d1dbe4a7ed4ef37068012c208a04e62debb2cd022a1b092dc38737fb466c355219dbbf7f617d39069cd1626f1e64150f2ac8b8232383b93b6f9d9a688cf68e6e3f78619d6cba844f02cae64b7fbe2350072dcc2e7b93bd2ab4cf6fa6a06610325758bb4d7d98533a396ae61dd2510089bb3162e70d7eeb6b65684e805f6ed5f0d9799387562090bc83b86920ea8ecaf337701fb37b1b1a839e5e2fd1f49c8ab14fe33a2c1f4ab6b43de19de1d0dad582dd8be43bc45b71800fcf1c955531fa7c663cf3553c4168555f38b21fae95939bfae4ffd47215b3d33c9b3712675b0aea488004206c60447ed813217ff1def3fbe429c6ef83bc0e62e68c9dea5bff2e910452757aa830538eef0ec6225911de060d9a859f0574e1a01023d727c8761de660fddfad0a55f0e8ff7a69ded73801bf48f31f6e100ac2b7f0d013b68eed9bf27e6a244b986f321527e523079e823b3b9486c45c04127b361e4b414f92684993fc7a657c940c5c82c2b12e0a39e71ed21a96b89175f13f6105129f90c5478ad2624e45de65a9441a7c6def4c2c284cf1f9d0ab26566226814e850bc70627400aea6f048fa33e09d3a477be300633ce2bc06dbf6e5495169eed6c449906d9ddd1df170743d170d86e52b6b74a7c4ad36740c3e11e5b53ff76343e17109520ef03ba8cc1a0a19f6814b52eb7c502d46c1fb2d73eb6bd219497bee78150181235e64d4ec0d7d4c9df536317425d0603e888ea451d40f916b01768f6bdeaed93544140bc67c48242999f56a4e3b0267f7d25576fb7d131a528dbbcfed0c4eb975ad085e022082a419611578e7bbc8e57101e5023f6745dc45c5bdae9e06b907837681e6425a1408615008daef13d2f1d7a3937ff2c37ea9d6f17bb13bf8a88e73d52a1ec9ab3291878c775a65d908f889b5b49028a9f74b043bc69816cdb8320c9f8656fe60c61a55afbd820c8262f95b006edc201429a853da7943cfc96d0aefe2822dbdfcd69e4b58433b9e49b3411417718ffeec4e01b31c91e86c33212e19ba37c564ee615fb3a8cc06b930cf36078346d0e217cb39f76881a04417b09ea8af457e56d10d3882b19f20c4d39caee12049b873d75fa191d178cb1381b81593791bff3c17173fc403d5fc15e5f2db1f1e45748a810e80753c22d33b7ffd08aa845fd04a91b67c1dc7c4835e3c5577f8319321c75b9693668b91f3b48bb121c0f04b966804aac2e80621384353276a3e7d2ca423b283c5b5662a2e287ac667da0f3df14d9621388ac2cb92226db3f54110fd1d47e21705497b0675d98ebed54b855ad1c91d8a3495272b318d08f7916d451df1ec4663a0e0cca2735d53db252f4cbaf02d1050d46dd02dab036db2726fa3031811d191a171726be582d98a387f5bbf567d128e62ccbd2a3b4e951153cfd29339c4c364736b4351c1b3d2b0872c442edbea4a485f1c6a8dd040153d3d098d293c79dcc64cf785c6bdfe3457dd4a31b33b3a72636b70fb2793a61450d0dc59948efbeed4981ca1bf1e8582f4e1dcfcb9d8d9ba6692bc7f9b08c2f90de3026ba16f35950b618864c39dd7ba0a36df6665f05b98ab61bdf62bb16959f43fafbf7ccf0bb8ec53d072c07a87c813b7ce3daf02d5a9f8b7d53a6cff9492a9ba3f70c52af162d298bd9b4df4a27029da9964346e0f1feb5c6941e7bd099de34ea078d61f3cd5dfe93b01233df78f54354736b313f0f9c4987e28c1237bdd6a71c319c0d866ae76acbc0c94802334e07527835d2dece1257785a64cf7f3fc8511a95aad9293dba49c5ff4675a46f60e75b53c0a8ef89452f76f3dd77367499e4a16e290c15c871a8d49805e261744f34e5a16e3542f807e22b6618a71e9048d37438605bd6bf98c4b339ff5d0807dc78d70dc816c641a58818c71feb9728325919143b329b2f432be35115dd3c23555f77d688279e3a6aa9fdaec79bd9d64b82fa05f9cacb31f03a6c7d993734048ab6be1aee73a7a3be61f337100448aab6c7fe51c12460c4fb974f097342a314a772f44433e64938ee881680261f9a58b91aeb1729f8dc5b10f56ac9f3d8e84e97c650d490ad9977ee21fa28480c3e2d1ef27d4d1bd45aeb6b63a89fb96eb957aa70b2545edb4b134108cee2253839a66f4822c2b369ba9a1dffbcd832f91a2004efe1e069d83faac3128b8cff01610ee18efff2efcc8eb572ca9d36ef4df7272d4068f538ef9c6c6f97df7548e5fcfb659b77de8ab816ecec350f7f7211c35e39c4aaf6cc92696e03c57f150dc62cb7f75a43d26561fc6afcb80025742eec312a9c79d7f9c2b98bfb7c05a7840ee08cb8141cda93fff43e7282ca701623a2ab4f9e6c327e904caa0d1425c27b2218fe23da74944a38f777d640b43939e08b444c1a6d1a6a36a00f99aabf0e8a8e2fcc2b42797bd7ff2a8c467a9a363609d3b36f38fe86b73779e01e0bee6a3870596fc4a92efc56782a716dcc5f7f0a4f60b829c4c738754e9dc58a76b8d0343160e64c307cc882b66f40f762f9adfbf0743d766658f5e25f49b5c20c779aaa78ae0d0b9f90c7b750be83a059d7511fea84aea7abf6abf10a937fce550870f708863a8df0136f7fdbad3a300e6ef74f9c6397d700089a8d87185cad0d35678b7bafd77100a9ab87143989512d833c82b2551cd0ffdd697bc23749cfd27397f5622f6357ae829ba9c6275854cc9fcaa6ef6462fae0da45ba273c138086f06a805f07e89002d26d28d0345b409999a9a67a12287696241b881b86a32519aca319183ac009faabc6baa1712be9a352971a077479e852f0e05d793f44fb588a81088585a9e37a3a3d64e461102e19c39d0e12793f736c87ec7caec100904b6cc679940ad6b6fd87b1cfd46d50969b516cecf5382dbfb7c8aef9cae05e724eb0a2894d70df986437b8e4fb98fecdc56146ede04cb9436c09a02cfdbe0728957b106fd2ef433719cf2aa9b02be34ea3c1dd4aa83a8332642c723dec8031f51cedd1f962869144e70f002ca9e7a2d8c70c085696fe508b6e2d7375e83f7c5a68ff8295f32eb31134884cc8d5e11da8843793bb32d2d7d017fec9cf4cdfb2f8945f39af7ce4adc90e66430e231faa6e060469790c58c663d6a321aeef4432e1ab0191184aec5f9a344bb71e88809f3a685edcafbf8104d6f9af86c6bc39cfc7142a1accbb238f68d203b446d8cf0109ed9677c7807644d148b4aa07753acc074f982f43da70d26a4dca3b9a8188e9d21e0036e066df652f4f732b7626aee28c5f1f465ba56acc68863c0da7e5c79297044a517ad6793a89ab07f91071b52a3eec70ddb15bd2d207236f28d894c24adb6e03c6bac8e28d1b51a132226a9077afa1d04b8ae37f2e90ae2569d5019f865e1e28a6f637a5cf3eb2fe394b5ca439547d93638a2ce405916b29e81679de978a4eae7a5159c7d1bb8e89e41b91d526ea5a4d62deb747b76edf5bee468091bbe01e42f0af2888574c750d0b168e7c6089953d3c023b43da261ce991deee66c2299f955a2eff3fa58c381b550b002a0566f1a74ee57ac81297024888a40e92b6449549da136bad3cf596868283fbad2e5641435c6b8fb044d7901a0623da6623b68970ccd79e60c6067776d90c21203b0666e42aa014a13bacb32a37fbe809ae4511a09891b1dce8fc0bcc38e4e1e6dd4a5c139ee2bc4a162ba93e4c75fdca233075a935ad0f9d8bfae3e8b4140e99cc710354750ee1d65c17bfdce91cb5c4a0e06975def886fe799b702e1fcca634c63b293333069acc98ce2b42aa0504bf541cf7ea922f5dc5bff54862ffbc3edc6997f9fa53da5f40b40065a8026479881bfc77145a368b7b95bc8579ac3f273c7f70d1930c3336fc501cce98f29557e0628622e060f1a47b0c7ad34c1f553ee4d22811f189bb53b2e55120f7e19c1f24a02c0229a9766fe7bf6b506108c950baf06211bfc6361cb9c67755b93f128e33ea69f93a0dda43513d9bc92434829c775d8ae09541b80bf70209c2f204d883c1d4df4018e5ec29e106efa531a82cfd575b1c384ed75e932622fa85ee832cd69c8a7ec707ad78073b09db14371064937a107386deb529b941f09b699d3ab039a311c90794f1992dea3832aca3bf15e084743d229f9d896dc2c897eca896f1472e932d401ec552dfe6cc0e30d0595b24c84eb60b02c765dee7c09842715017bdc72b0d1dba33138438c1610921ffd2a19a566c7b292e1e5305b88f90b3adfdeb1cc7b034a8bf4e39821ab94c0e34886c9e9fb7678a3e012ef09a59ac985cb8540eb45e9990750b630bc1c69cef0a2f5e2236c955a2b349a2062d6db8b3bdd020207bb8a63cfd3d716cb5dae4442fd44d19c107edd449126debaeb395a688f9348b7754d107b9615c98905ec14e422451dfb33f890d17372341577d1ba4661cf5c7cd7d75dc9ab5242a0281750d87ecc2ef044745856fd52556c282414b6593583066156380b0e9bc2506fd09faa27507156c7915212656e317acb2ab351f15222df85fcfc9ad7ae5ff9255c512bab155c5e3753421646f7fd32e9625403398757f0bfaf98bed854469ca4efcaa497ee17e05e159568258f911661252fb47cbfbc814fa8e0a74eb63c1e2f44f3ac3e2d545b5a6a94272951dac29132d19c615143b29b517248c51b6683825eeb3aee6a9d9a74829cf6dc17a13bbfbde65805930c7633a3b75c88c87da992cf0c6cc59d6e5e9c83af5dbed111f9c842031584f5e8281f53dbceb0c63ca848abd62e834d10c94f1a41238afa9a7c7604a97c05b3762fdee4b1b7a958e4d09ae093950141512f5733250a4c27230ab61b35c7c957ed3e3c356e9ba6f1b6e058209f1a0b00c24c460df49c97e8c48cbd97d85da64e9754ddec6e1df9f3da941b89abde9f000fd18547bd797033c79b9faeee81c8b34867de2e079a2dec8330f32044bb5f510b4a86a9e8cee108a1cd718e45ce88836f816843e31e343106e67fef6698240d1a31945eb6387f65962b59608eeafecfa55b519ad556af1d9f6df6948a13786b05c7aece269e51027d667335fb49392f60d3a36e105bd4cbf5b76e5393570492067b3555ba34c2155600cde5e6aa084b2bb97037af5a064d9113ce20393139406959abe8824ee638ab1901ac5e454eb2329e981f2de9f2833304dae36e1d7d279f329b49f14bb1896ac6c5e9a0f3070885b5c5607088cf593a0f8b0e6461c011b3f886449bbf8bc040408af943488e8bdd375be8030bf521e54c085c26d27451c596141386240694f212fe1e09b64ad1217c8a648d9ed980cf288b25cbfe72657f78219922f27f120ec0b4b91b52140cd19ff4454f317e9e354b94457d4b983baf5fc9c00941e645b64a3d88ab42ac26420c45635dc5ac5e7abb2dc91a6ac143f37f88f24b1b682b821bc5ec61e647e5d2387521d545f6f35354aa3f2fb653cca00a7c872c5ffef91d570096b885c83a6bd37b24d3ad28e0c58c5ca8b35286922454c24884ed4b33546a622bf09f69e1e64ae00feb9c22210b1c2a3667afa1fc4f78be090d6e8502905feffb07ee980e67b3a65dea21f42194340bad6a532a35d0da3d4d6904b82100d475e86112fc833bc1372e47c0fca355d5ed089e48f1a67b0d98ab541ac45689679f4bef47a93c9770c647b2ce6178eb33f5bb636d69b5d52800a63b69be49c06dbb73c6fdca0315feb8a590b24531c403fb5e69efb4c3173611e3f9684e2524e392e2f2af0d5efe4f4e6d1f0a8c4522b84e43045ebd7629f0e4176f73fcf267ce94c39615c9efaeac8149a3547a533241f983b5994539eb87b425d2f5f92d3f5e84a48e95aa76e0a692188ee4a4f7f2eff61d487b43dfd7e7eae253a18c7ca3f42fe697cf12347c8c806056b0fda0a28daa8fbe6f32c884587d326f9b44e045a99536bd67bfad741861668f8692af5d8d93abdfa06ca946e958a8e648e4735cf30cee998c0c87dd11260bf68a11fd307e85f003f028503dbe88642e55b5fa9881c555c8a67447d27f719e11d950b553b4b07c072aa90193dad0af005e97d78e3ae09c1a40ba6ea1fdd23aeddb93ef84f7e1a5685967d0998ce8c0675e94c6200e9c487a4a6c1ac74025f96f2f0ffdc8d9056da26c0787c8f9eb95fdc78d3633a468a42fb57d512cf284c525959ce8ff5d5b2c2b7e43d2dc8cc838f98381979099476e383af24ac8ba0975b663184053ecbce90da52e64663b9af76055cc5e5f1ceeaa70975e24de32bb8eb26f3fc35b147d0fd1824eaf12f27487668f537f9f87bfc41a2fb051af1076d737472e976335e7739acd36ace2871c8002e21af148d3235aabbc39db2635bac2dab1c57d4b18ba237d60d55277604d6900b7cd332677cd564debb7bb216207378d5dd635819bb3f7ca8e49f4b00620cf97a304644810b1eb1674e6bd7d68a15ec050d76925d1dd66de5ef44f47b4a9b6772be8973878284cdd1fcf681e001886e5df9f90d110f8a19c1f9215f8f9b6c9bc66a6b865bcf3c8451a5deba1f5785944342a1ad355f60b7f4e2ec21451ee9381faaafd5b744570d6906818c813c572bd80f99e03d4ab0c4a3101e7633824b234ef4bd4484de534e87203456636cb47c0773f888b9f23d09e8ec89f3c90675396497dcff743ac69254616bd84eb70382f0432d552245c3735001354355289d4ab40cf22d9d9bb9e86981bea79272e4043690739915cb81409b0a3292188f3a225e084b695bfb423b0e51f4ad9fec1b05dd9e8f61ae1def3f1c3d18ad97feb7e2cadefbaf747909e9295ed0e0f9573f11d3cb474bf8296f1c0f177c7aad75feae6e9ae3b84a9587a63f096a731944d5aa5dad074ec63f474f764ed93fbdeebb5ff55299075985b485daabdc69d1e51ab8c7ab62e11508137b0b230390614147a7a8ce861505084ead81aa03dbdf167c24f2c360374ef60fdf1c57390958dd21d2715823db1b5ba16b83a03395be5d4b776dcbdab7ee9f577b964f5f231779865c0c82a2a3eb75bf4c7e7a9784ef18e480ce2be636b656e7dcc27964d6a6027ebdb5463630b7c0ccf1d02b1d5c4a8769e082de0b0bb9984d745511fa675ccee9b1da62218bf00b97e688b71bf5546aec901e52fc73d7ee47539e21a70c6c453e91cf28c9bca9a483b41929bc10ef7797c2887741c0851f52f73f07a3f41ac3e2175f3b23e206519c1c62a886ae756ffbd4aa4f6ada30086aac28f7431b3b9235148fccf8b0d54975a44b6f72cf8037bc53cf86ff1b8c038f918b3f2aa20825fec293bd6e4cb676de1c56f31e0923c4c8ceecbbfdbcf7405ba89c1daac398d744ea901c0640ebbff08681150babbd6420eefe940f1b8797341e0bf968abdf409e70be125ba0671fd55d6f39f00de1155aeb6010a578615a52a06f945c7459560328f87ff9bb381d0d2e24c66fef31c0b6015d6288b7a0f98ea11dd536873c4c8b6045b2ca6060299ecba5d21ffeb6a2fe7d6845b12525cae649c117c0488d2ab62be435348632ed5e4c1f0447917a1d6fc444f1c27b35671a3ff72bd0caef51d75202c16bcac0b7fc6423de103df3cc2627d880f0a05bb4a0d4a3a485aaaa5bd7061d24a165a6b4ddd4816172c9abc151b7c3bd4d4c90a286417078c89098ca3446b3109d85cc8cfb56505b1665b8cf9a80c64831d314a0140fdc9c4e50d8511dcd7a27d9cfffcc7336ff8f529f581a22d46c6f730c3807b2358eb35d3ac207f6a0cd77225d5f064c6b9a6b58eff1920b9ce7de65c93692441e8e7b6e00cdb338ece4e6bf79a33aca67ab6bba2ce24cb06757b3ae0b624480c1a8ea86856175401f6b33d1e2ab63bdd64c108941501bd1045cded8d46a41d622c2790b669208edc8181f2278fced17d913c6a7aab7a6bc7aeecda6d7f5210a848591f631630cd6fc2a6613a837aed2fdbe9df80b2ac8b4e7f97672fe296bb2d98ddabdebb9314f478fd529ad02c99f4cc59b2dbace5d30c85e8e8743627714617572dc518be43036f9b9d7f81af1dc43f36b002631bf3dbff0b43f9fc1b1c56d860d3d2051776c3ae668ccceadd83bd5c64925d19a62e438a7c3ec48d38d8c74b3c77fe3acec38df58b653de5ac9a0335753d1e03ea8b33a0d27d073e2904cbb5b0b8135c4c818651887d083dea9b6bc5964bcca40aa8285ea140cd699093e01a2a02d929169b58357e4c49683e3964f664110e1784af71c72afa9e3ad9136c875fdca0d3c22ed02730b2b68fb2d3d5a0776c3255c29d5a7f4cb5891b765c750c23cecbbf78de558316e2e0f8a1d2495bf008fe32efb331ddb237301ca414d97b34be336dcd5deb6cde9abeecd6bc67401bf88555477a75b49eeceae1013b848654534ec2432c645553a20f8ed6d5664c2fd95a90c5c1771b5145c7ca2c9deb46b89e5120e591e91ee08dd125c00e6f27a11ca0ab1505f977113e554560837853f1e4b5f34ded9313e26422bc369319c29e1ac7c0333c7aa2cdcf72ca401bc67ac501669175d8c35038a8f15f46c709198e5dc2eba5b3f409b9636c5a3e5ce389a98402e07b51d68d7f8ce64b97027dea0dd4ada7e1e8f292aecf15bd6758342e80b2db476881598f7486fbd72bcbda1a9cd3715292144ad908a6140b88a8634607ac7a43cc35145b97af46b0b691e4939b76313697edc7f8fa4d8b0bfdb44f2ad5113b454da8f6ac08e775eb3c867964da0af33b9f0170b218cecd9d8c9077731a97a6844ec380f1bd4f9aea70232c9c1454287f99de62abaf34610418f62b0c74b3acfea6b1db8af679074bd414bde1fb2f1d5c35fbd9b2db19d9bb8dca70cad9a5cbfb1f81e73345ef8605ab17c35386c53bc07ecb1e85b918aa9cd2a36199fdc72604a74ad584566df02664e028bdeaf206452a3384b52bb184dd3a7db478757b3821880bcf687cc0bf178b143c2c0650d0dd0057dad91f640e144978f3aa38330dff4a993c010685fbdc4098fa1a158e5e410586428b2c13b0060f3e1c7f7b518949aea28fb3961fa21eea167c2f66b38c334880d45f55a9eac4e5713baf1597d351b3716ed6d38a1538ed5bfb4f129af02b18576fad8f85d4097bf2d81cc353bf78fcfa5a729ad1a9f6d8d5c3e1fc22f62495492bf3124f47fb71435e7a0d3ace2a58cb5395a7a7f5b1a04aff4cf11b9d73b6e84cac7cfb98379927ad3f3ef9cb3464ce4cc441d3f877202adc271309a5c60727b03ef64781af911401058eb4bbdbb4fd6f81de38221da31a14c7a621c6447231759a4fab935379095abb8e771b2df1ee866384fd0a60d6746a973a2013be0e84a3ee6753929b9aab03a29d180052a403a8afa6014fa2154a8543d5614b12540a73016f2d832ec98b9ee9658d8dfc597e3e8fa78794df0b0fc1a58ca08314c80fb4accedc1ca8ffbd9380aaf728d682675a51247ff9a8935c0d5f10ca365fc52accc3558c42cf02a2aa154eb18bed922ab93941e1f774ea5f4708c50185a9000f9df5d8c4b4de58f7fcbe910d642ac6eff488c8c86403c8138d606ce6c79c9d59acf5d7b381bfa5f29a227299c4025d38889e4b9e61a269df361eb9ed110ae5c003859f4aec4dd2a95bf3018b05a298f6108f181096ce12e0ab57d3816cd5cb89de3485b709aa3a22d9bc79a25b2288c76253ea9fd449b64b4f38b84bc2aacc07e42309f98f6543ebc8aaea546d1701f8c554e6306975bd39eff65b220db32e18d5c5262544e3dd9c50c1d48b9287c9fd038be7b47ba093f85cba70906476d7dd1266645ac7a21a647bee7341fe8455bf8150f78fb1c00ea59d4a6c0f7bdb14dae8fcbf29dd3c5b98ca44e30b554c8d909b865ee01593bd610aebc06fc6de43f176448937439a275e5afb5422c0fcfb77c2e9604d9efbaab47afd34940a3ef8701b85847d20ffdd5baf26908b4cef4e2e238de070b95020a2ae0ff207166cdbb5876b071fdf93ce75a75050cc6d6b28403b84f67840a9d33e1827eb17dc3fe51ed7b3a3588061c0caa0a22360cdfcc20af5bb2cb6c617c723178120da6cf6ddac68356c1f28e8da18585e40ef7a6f79c9c6dd6aee0f863c4dbad265caf6c9bd77956f72f4674845d642372bea7102734e90c13b815f01839a6519bb883a711c370a5b7e2d23bdb7ac9458296f1d9e237977379ef306dac72d4e2514ccf70002b4d6e69c1ecc5c0c815a049bdb41af76a8dc4a9f8abfb6fbb1451066b6e505d0182acc6e573c07fcb7d2cb043514e41058b9ea9b336b35b401716d89f36b8baa3c30ae7f67da1390d43cb5a333caa9f4a770e5e6765ac371dfc26809be2a16606448b52fab63362a9ddffe26d6b0d55fb87e7cff6d96ea62976f7c1aebb17ceb7e4f2bb3d4cb12cdce67a4e4d274b141387db54f2cd1a0ab28862264684b999a7a3ce41aad2c3f6c026516f9231230f714d22f1e79630a34b4ef96074321c003069b847390d48614aad0f6b3b9ea730cc363f7531091e8faba40f903c66c5b364c33ab5792bf1d367b5b020b84b6a5716bf3088033c3395548ef575ea01917e94767ef014460b02730b5a0e680e2e36955a1523169c38832981972538e06698fa9ad25c8f7651da54f3d77dcd7427d9473df67678b45971fe6813d059e98b103b9c3c6f7bb42835054937acf25a4472992ba66320996b9f4fd4c75f719b9253f61bcd2a679586f5512fc460c867acd1098038afc6993b47d9ceb0d71d0c64dc379c34e61ffc76a8a9b84fe201bed381e97426b187aa8d8f9d57b09b53f704cd8ea6fb1c0ecd477ecf4e4a333035e992bed6dceeaac7999938fbb5463e965bf2138874ee088d0480cddbd937146932af4a0bc13071b1e7a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
