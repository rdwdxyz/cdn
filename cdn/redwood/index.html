<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6a7f9b7017a5b83f139a9949b6abc4cf431501bbe66a27591f917e8ef6285b7cae65be64af21e5c8705a7dc7d86381c48948430d5d27bacce08601ec108b04361ed8328372a39ec2799fd5ac5b17e756f03151b9b9bc88e7242f708bf3ea3af536e3843e3f0a3d35f502e24a3bad6e369a2f8d3bf1f0aba22192dce0b2a98dfd4012e3f641345c225e48e50b5d1e90d68c71af62f96ab9ccaf55687db0e410445b60dd427c19eb70a9bdba68730345e944e91a68f8cd79ff2027e02b28afcae8de5fea0b5270c5745a4cf08279d0774e5f2d7ad06b96393898babfd1335f196321ccad94feecff98de13dec01816deb77bf2938dc994863048feb1982f153ab95c7bd8b40d52ba6d3f962238e0a26540558e48613c47e9cb4645e7646684b22dd12d5e427cba3306a3f95d7f1615a05b78e51579dcbd985e881b1e35769ef22a3c6d3ed8ee61bde6e064e1dcd631854a273a74968a729c6013574675529c5c1bb23bd44a563f0e016ebbd1f4251e1c25dee6a097cdeeca12d0d218f9b9b218dbc054cf76384707fc38faced469527e6d1e1e060a6cd141973acec75b8f1f4f1d563b6a36c704dd16536f1ec74a6612bc8828145f43517b5d72094bb7c51fa88298512ec99ecc591e882e4d322f87cd9cb4c12b387df6b348561b886b1a66c10b270e4d216d908589b72a3f983ea76f050b4d94c19adcef3a04e41b4b6b2b302f682671ba0ed8cc74745c8006bbfe6ad6bc24cfad2133a5d7b10d5e32f4d05de71cea6d8c0749fca2ec3ebe049769502f9162ab3894d3d326b2e9662ded7c7fee7f507ab1d65ff48b5e24aa33705052a5439218de65e49ad43f04a784fbbf2c1a0172479beefb447c005f5b1df36b048359b5c7cdee7964e2afef80d6fc678f8cb19407e0c584cc71d482054517cfcadde191c7f58e873fe836ed225f1ec0e645241c61d2e372f6079b85aefa011e85dd5bb9cb2378b46b6a2736327acbcc5c98f42dd450608bc7070afb8e7e1165bf7c3eb0152ca71339e4d9b00bc5542b10bb3c6dcdfc269b3423fc059f19e8816d3146da23f4bad225faa2a472221ac4c988fae644a338bacf2d593547ad3819bb7c00e09bda961434039718e3bb72d281118ce668e907f1f6cd79db8e7b02df8bd96eefb6aed9948b48957c7fc5f86e3d9ef4bf867cd0b80f5c4de15af2066ca234fa7df0d2c12d2ad26313204a77109d183d138ff9ed7157e803fe32deaef5b2b78a4e2f103ee2bf5a6440b75bd28320f1c35bcbfcba933cd9e842242e5926e793352697dee5d7a671001164da62f60d72fc8042cc8ca491b20383b5066ce2f553f61d4252ffbf2930744b47b078639e1170ec8fc746a2005817e8a3b5addc4572079162a5c2c8b6ce74239fa27a71e707917ce17671a2d5c2eec6d6b3d342b958f3e582268f8af448809cdf5ff42392254c4f420195cf3b13cc196b83f99b2c9b2528a1364839ed371f928154656e25891fe3662202a8168fd1e45af306b5778c2951abfe435f590c7cc0c85a9a13ce937a64d8ca5b415876aae00137c0816882410a7309b2711aebe0539e669f69f09679e1b11d6a78b132446b7dd13c9534cee0c928679e5d4e3e3ac9c43c92cc35652f0683eb2c19a8fa7dfecd6d58f0a11ac474e02d10a1fb71d6475fdce4b24b9aec7d859d2c8bfe1e4b378a3a3c0a566d9abef213e39a54acf015608ef4647cf17ad574ac4668a94b2ba658a0b129495fa4cc4330010c63272ee8ad15ff18e58ba10d64a6eddac08b6faa207aa5e78f41109c126a2856acb84d968e82d1b2dc41132f545c6b42955db57f2c59b475dca5b17beb1fa89049374577cae952552407cd2c5e09fe754af0c8be3e375ed0d8a2cc36008e265d4b71b6797b2d599dcb0fce5fd291831372e1bfc196e5ea24b9919be9c9f8ef4c207f609454562ad584f1fa0365dbd7329ea514fb1196f7e85afe79794f309734a3b7c9f3abbcd01a3eb575b281bfad45b02fe01b8bc5b57bab450a1ace1c8a5738a99bca100dc64752d31790f34df765b702ae40c1ca6c70d4b050c23f1b18e84f339f32b4ccbef19b909f169befd0fe6b20513d6efd227a235bbefd69897b9443f14678a6bcbc04ce218e6c454470392ab7d3f31871bc7e560a386662d89870d38f3e86970e2f97ac3fdeff960bc041d81814b1b0f7f1b6834497c1581dd1f5dcfdec931b5db4c8c9449c9eda0a74e05649d9b84d51000a1646dcd93fb29bf085e5170736c27fda756c07b330d668768865c5f63c7204f6e4904d9e7cd19fc8bdbfd6419e3d7970169516eebb1a14c7add22fc0d91078285c83776fc669ccec6f495c10e3b5e4e1ca4e898f6341b64a76bd0aa692723bac92609259d5e7b1e74860d1f03ead35b7f67c94ab7bf0dfc5bccf99720a9f5ea50fe4e0b8c7e587a5ab7a40a3264b863169676277f508a3b6c54d6f5b513832cb6068651721f533fe7ba9c194628b70cca69aa2a39dc72f5fbebabb42bc9d338afbcd056559177f62d447dfe08daac3e37c5b90c3bb354421dd4e4c47a6ca28052745d1ad40293ca5073afb6ecf5b9869909c0c8ff973a3036d0d3273409949d543f451792b3e9ec298acf8633d0bee5589753bc004ca2e5178a107ca2883f47acb9a64728b4f96a6cdf164f0cc2c17289b44c895ba17fd8742eac0ced7a33bf25a2359453f3ad578cd1b23b5d8da951a5e75646a2ddf0c9761c8c062c2511f16052f84ec835604cad26daa689644a6199586383c42eb99364ac3dbac1ff3e839a33d723c342cce9e79defc7ea9256d58d1dc0143cb2614a7522dabaab8593b5081b5b4afef61d74e9d2e036e537bb929959a09edab3fb4b7c60914ee3af67efa74ed5441a5f3c88a214f3691adbd9e5e22773d02acea5d8faa4a7e69f2ce68b9b6fff364edf882cddaaac96b4fca02b89180212e9d4768836d1ec0eefae964fb27e065e98e60267cd9eb20d9825fe68185090c30e43edd7af6106b49078df27d46947be68c45daca9625f44a0cc3f1b54fd3b63a2dd8e88f497c50fcc0c83d97f02bee27371243adf38e36ee3c3f5915616e1baafe1adb12a67ab3174c6792ee316dcd7f729c9d263cab6a410e05cf8037a8da79e9a75d51b7153d1a1a99b512d3b943c50bc71f512d2f90d1e6e5382ab87c3d2fccad59fe686d49981e7f521d0587fd7df024126f2550ae4fc2bafb9148ff04ed10b0931b822ee99fbb3be5fa4e24e270ee9f42a8709a5f49b52ffb11408e81f1e2464f2440aa392a2e576335378f2d700a5306446bd946458674f0b2bde2b9cded16bafbc130909c9f4e73debc3b0b361900ab6bc74057310e9cb25a96856d68d6422976361f7266cba642ea9be14fc22a13520558cdfa39f901c6054a5f3e269910b324311c3618d4360553e7ce75f4f077f5287834d3005804ec09fbb034dfa974aab29363d315c417f6fbc0d27ce04f42d05e66125b76ea3b9bac1f23fca26cb255756b7792200ba64af8cc96cc525fa4e9debff96357745c43bc1fd33f5aa9201894458f89228e98a1bafedb340dcfd26e945f578f422e298bb546486b9839ad31f584557ea9ecf3cae301b5c453ab86db50cdba2f78cc309b96cf9487dbf3acd923c67ceb18b20e460d0955131522157e469bfe5adfd76dfd8f680c47ee825e46e0f8700154064fce428e4e583bbf43766504f83e5821448c8627eae6dd38c91701f505875b26f811075728c57a5445addd5a7d8729ec4cfb9efc0e8f60eb1aea27e4be8520a9b6474836263b796aa6d2225e3b294c0a34e96fcff2ee9ce16e9f1f28ba3e0cb61d47d2e4a893b8ceac2f5dd2bd13f415ea1be40658bd37342bbfdcca9460fd46e60f52748035542a9d48b446de22981417a34b851589acd864116ace528bf4294c58b14995d088e54665436702af5a3c3171c20ce0c21c9865ee3a05e37740191a9b697c07241ff9ea3e729ad896afc28b1371a9095320b6e538b5459b9c4342a9fea666acf2f315e77e2d8f7c41d6b581af728ea55b91173a09fcf92d88095f9d2999d3f220124619e3dfd35e410be2b044844363a3b602c4d5824a572788118ff13f2b2a2c11ea43fdf601c6a460af6380f23fab7ca7bf90628ef8aee53f3fa454a6415ee1da05699eb7a1f18158344d0339fdd489a8215ebd4d297b3f83ffdcf36eba536905d8b2dece950fbd08fe968c8ff70a772e13a0f3ac877f5bb62c4e92703aaf0ca5adee9c0180309d12bdc6422ea40ac606387ce1e8a19a7ee31c2bd6f54701c41eaa35f4f6bf756e0bca7e0ac2ef3f88bae88f50c51649c22ef7bc7ae097e4934625601baef5ddaf134315ebb9070b4bcc832cf95f3c618637814e626871d5aae022d775bf126c53890c72755026c0e0c22d4aec5e8e7944c430cc1073c99f9b247078374f430e02fd7121aa7d4e9e7c01e7eb7477a61e8a689e1f2e315854080cf97c087acb3c2193d4f9797612254bc615163f0d514af27be402d6af8e54b9d9c2b79cd72a2cfd7437f48c28afaa1af619f44524b12f97d0b3e05152914b07f1e7ec53d1c60a4658c86cd54992c17f8b6d3ae3f8f52e5665702801843eeaed22d6883358273a8ab6ccf1eb4c1cdf0440626af78e7746e5d48182b2e66d8f8876b801a901d5ddda72253b33e751e7a0c28abdbc2888b867a5edd04e61a7392296eb04460109333919bd11bd8e58f171999ff9d80ac011467938ea1f03afb39c1de45d4ecb81fc03376d49c6efe2c6ac85c2218a0d8332b79e4fc7fc3a16e8cd93b3d0f99dcc474c122bfe90aae7be8cfe84cbb348e203bed982c0bbad739bbbf9fa6c7825cbc09b532f617851dc0f1f4be9866e0a95f31af8cdfdd1aa99ad01b24b45aeba75e22766e9cfc8150bf2268eb8f27ea1e6b2a836276b1446a2ac4311215f447d0cf572b384a27212491f4cadb832a955aab34513ce140d4df3f76e80dff1f1c15b6e1bbfff4bdb0c1ea11249f7960e61ebd171e3c8fd08388c3d08314d1803abc47f349a94c82b1df3dabb96c538677f0861b16a6c70bf6b7f6e0c9fbd7f17be56306747714f751077e9efbd81f20b6ad3c26aadeba503142e47f32332ed30690e87f8e80de4d5e045612bd91cbf726fcfe3db002723bcc56a46444dad573f99908852cbef90400444e602785f3ddd24114316f9bf804fd6c230e3abb0aa4699616c6972ca947de22d6c3446018dd4852f6cad6597dede4717a1991cf381af07b67e2279a2636cefdd7a7d71e63a22e9ae832b50d420974f1fb8e2e8655849ed0898a0080fbb8e419ec513c953db511a343a57345d3827d43afb2fbfc75761262689f3736e26bb5a403e7111930bf371be60806eb8faeaa657574a1af0b72661d11bdf121b8986b582790253b8cefd2f26dc6b000dc98e97ed153c9b16c841344ed85de724db1f9da72863217869511fa151442721ad5ee18aa77c432086f3c3ab33d2c64f1b4c0e876f26eed40db03d3a198efe86b12d18d2924f7f87060e423b662f44ba3a90e27f277a8d673c79c105a865471e1bdf8b7d959ab63fd2d77cbed20e2a5da5cfa99fd0857e158c128d17ff5aa0c001468f014dabd5025604096db9a23395b1bb37a9298d89a6b8dc5997db83627832e93758637df7f60589a3c83fdbc69264798860979b49a8ac439a68d6f9879edb4f4f0d32974d675a91cb6ea18ca4c08470385234a97029aa1f48bbc673ca55a22bf410e0d71b4038f126b8144dca6a1239904e64a21ded4a15f42bbb8a038b45435d429f47689dfd219a1812201494ebe90bedffd1bb72db1672dccc1a2f390b2bff3aefa9a96f75ddad1299342aa4788d534afcbeec475cade517ee006975b571800825d04bf80bdf5751dc5483d5601df9082f286300780c69caa6e5cedc32a7831427b135b899470b2d4ab9a0ec5bc247505dec16fa3e8cc3ef2289bcaa420557a89e397cdd70dd4c07365df28a91b02e7e6d93e0d7052b4cba6e192d94187934f3e5b10f59d7d55dc5f274ac689dd8302e2639c4db14bab48ce4352b8688bbe78cb3337dc4334527a800e1eb53d32b8b6b0555072b7bf780ff805d57a2877153cc5612f391a0565b338eeec9d63a605329af3204fefa505ab7908c5f7247c6cbf1f6d3826bec7e2dcdb80a5b25c0bf1ebb028ce3d083adc718c7bdd7722455c97ff3a8e3b901f3c59d6a3559658b98f99350aa36edf57f8535473c89e9b822ff35d9b0a4c85f17de8d4e81c8760d0d7accf77d47a3323f96cd5379723d73b9c104509ece77086fc1d41937b9f10a4041bd12ec27f118515fcf9b0578074ddaca1bafec1f515edeee9cbd61dcb955a9155ed77716acec1f0c879754c87b8851a8ee5bde567453f6a16511b1e78c3945170feb4f3fab031813649be04ef34b0817fd8b2d0c5a59e9f9ff25e6481c2f1d1d767c5e902458ebc89af786023b5271d3a6742a20e49d1d0d7def4e3f0d7757fd5c557a444c3c63d638e6211019e4c29af7d248a0e6c298350007957ffdc3ec53772812a753a79f6edb484235890d85b049d0605dbd3d82b4ebca520edbf20d592b6ef881c373517724059e278efba7046c24d300a82d0aa53bfae2997e09478b218b2bff4e53870eb7f8ff809636d45b8fabeffe63cd16517016b241230bdbdecb2f286f8e3f9415017da813432f586bf8cc83f0122cde4fcda46df44b3de3f925272c9608deca208a83d8859a29ae0f3e9bd4a77eac94940f0ad59366d7f8f0221f3ee713d850a51171fbf6bbf821a5909cfa04adf03e0556d00ec70b65cd2e92e7698f551f6d1911d2bc835b05ec6733ac3395518b121e54b528b5821c8216ea3f0096fb2f3f870e1b9b1337624ea6240de9e1ce6994d8d29bdb0612f610be0550d164572d68a0e7f98ed99616e24225ee9caf2d3b0aab9c2b1d522aefa0e0ca5d235c507e3ac1f8963a6adff57d94341df1ab296a4139b77e5b39febf36f4a5e7c4bd8d76e64a3454670eb2cac517710dd1517e8c4547d988f6d74a7ff3d540ca82c6737b77532c5be2e32c8ee4d5ed46e98b7e08dbed5aefc75c8e0a8343f453f44aa0e7e43048b7e206a0c6041f6c9720a37ead941e4611cd66ebbb03f2ceb897a4f8b8d5c54eb495db911c9dbb628a881d145e6995b8b92e5b195032056fc7e0a0df33c6505ac98bb4f58dd3be00fdd3e6bd23e47d44e2639372a750ab5b8ff9e6a0add3ef3b3bde6c6d223dce3e8c01e13d5b2945bf58ab0c0bc238434434ae47b2aa000cdca9fb0a1a9664f5bc9542d017903618af55fb2259da660aeec189d59b5092a66201b04b82d52c74a822fa75f36936bb6e5ac1df0846846b46d66685413327ffef86d83469e7ec5070c756ec7dbfe22a136d2b29620514f771278de8bba3e131428c85c86c13441bfaa6f9afe72fcd3d5bebf3160855b63af9ea53990e52c77404eb93abfc0f2f8ccbb3296a76b93d8ce8aa8838f2094593613d11d293955be12abe88b58743ece7b6bdbed3c1123141caf1841fa6731f1ef5e64e1ec38af587d6801b44af052a81e9e49082eb17a29b6f574956fb58ed823bdcbf251d2ba88bb3496d87458d6f52e1797cb6d49a3c6cda6c52679a54c9fa22465fa9135e033317231ca35e3c28f738ed3240a572b30bce1d1c8e2233043ee18799c47fdcbb49c4eff7a5b39d64d58628ddd1ae1d15b00e494fba681126e64e11a51cce67eb3783e1befae7d0f27c600135c640878e52893ac7161952e629672ec66f5e25f48f54ff6a7c194d06a749db29703f6fbee4aa3ecafed437aaa61434770564f550c6a8ef01f16a2974dd927669447a5082c01db7f0a1295c1048b10be464f5f1d7372d753fa43d028ecf8763c539c7a2bc0080df50823cbab3e13f3fbf4fe230b1d5ecfda2aba82d01935439f97fac13ec05f9ffab3837ca9510df05b01cf508a095a0201a0ac21bd9cde47fd14e0cfc39f6909bb3b5831e12bb7f19eb0405ecfcaad4356130d147966b6f187d90ac2fbfb5acd0001969e470ee344f1d814583e620bb283d72eff65ac492286bcb5312cccab659e77bfaf47f0476ac1c14f52c78a2ffd88aa0b2fbe885feb038a2d4c7bd9dfc1063acf229150fdc17a96d9d300ef75f9dc025b2e23b39bea039e51311a2af9895a6515297ac035f5f5cbfbd7adf0bdeea93551d1ee6eeada46404a1b4c420492dfe78cf7afdc12a489d0d6fee2d896b2f0f60ec9ca6bf9512fb6cf43c300251d4bdd271d97ab806676aa7d668ba1513db7bf4cf52190ebf292212f3110e2505ce603adba7950d550172f7358df19231af1f7776c523ec58637cf829b8e80e78e7e7c83efbd3ee189b116319a3a7cfe1ca4e71b2cf1e340abdffb537b4b50817459aa754fbadf7ce399078ea7784715d9cdada200ab4524368dfc66b7f99103344807e72ee25473ce15065df119f86b731ecddbb9a89b9956a74d47b0b5f500eb8984cb6e326a6bf39be2a6d1dca5aa18699cad927eee4f9291aa3a132dcb374f13852ce43d5c6ae7523a9e242617332b26ea24a43f1cb4df1f19cc212468e2ecd9b121afa510e42043d1686d68b2db5ef9fa00ac5a64aedfc97f816f2ce3042e28ec835f1f481593fa2248b98c5ba49dd316655221713a7d209e671c25003596a99a883a6bafc803947e6f5c130a45856a35185246a5bd4e12e4e6178b88daa41bcbaf64e378c3aa9d534d3b5e10103cf4d2a2af5c1200c32ece7f724383fcdc5d540288a659e6e7806b994372f2537b7c941ac47ed036de7cab24f96611bba4d390af32372079ab3879e7cd2f560b82fd72367db8948530ac4afad37b75c6916c8a80883e98a239d29a2d4d42d85ff79cf56673fab6f2eabe7a18de1f4ed75a32c3001cb02e6c242373e29a0c27f5616442664d42afde8f93f7ffecc55c093986a1421192335c6ed2399a153b764cd500cdad93b5c597bb50db96afc22c7be7c3696e80fdb13a9d3cb11d73c2780bdb465cdde5ed40ef7851394837f4b1c2a92276b03026031fd7afbf2143e7f9b7725de252381401fcdfad2d8b3758c5724d535399c4652c514cd9ef24fbb9708dbc606fa99623360294e7478d376d91897ce14bc6a041c394b4e391af87a664701adb65d6e6f1f23d2d07e0407e1b6910cce593f869ff762802da7f711789ca614d85f075c8816c23d85a0128a09473a83a318e9ae063e564670dcd52ddc959219eedc3dd24d3f9289e457a3b6b6a75fde12d6689a48eff267dc381027245f1027ea16e5162c514ab843a40692c9e9069aacfb8a3daadab661c600c5e96caf84f213edefcc92acb87700e70f1f44206fb22354c2e74bb2dd1379fabff4873764dbd4281608284f61f3bf023341804721070786f15eb6d7a41c9ed78fe990d438fc1ac82d886c90585db23b0afe66f3614c29b46772a7d858ebc4260c073aa85da477d66d1d924e457dcfd3e287c0a128f14e148c04c48ec212e92cc3705b4431b8fb095e808695f2a8ae12d25c78e4dd89662b9509fae01e87016a94f75b3f34cec0d3b00dfe1384dc37047901b14493dc17cb807831f3bf96ed867c63aab63d44dccb4d40a121dbbd987fd7de6610d5958d355dc8c21e9493ec060d29ae046222ab9fde472a5aa625921fdd3e53b4ccbc830de1869aca171948545cf0be139f2f7c03d935a4387964f479a0b024a39fc5c7cf3e2397bf560f64c08a20876c23fafffa472248de2590ab2456140bcf072aab760fd742dcc23f50853273d79c5505840428573cd2458623c3fc911c2fc7ff3e1be26b75d76abe8fa1f076daa3ee246523e7d3f4939907e02294866c86febeb6a99c2439ad723643fda0be432d5bb0b78f5dacae5005c5eac9b50e34fb01b199c21a522c1c189e3aa572812eae0d7d8110b5c3492b415d62a01a5e18248fab33048dc10a346e6ddea1d6adbef10b508298bf5f43a424c8a512e3ff9f523f7c5b42856d9ea513c8914b5a69c48eadffdd7974fff6e92c1edfb30c5ee729b6dba2485af50a3ee15ce69d5c4b2f26d53041d02e50f9ddbaa52ea859abf351895cea05a04ffb4351e7c4945cd41bcc3aa25ded43505131dacc2e0ce58971284fa95639b25b7e1e85e1163302038997bb232db75c0ed2fb329e0984c61f73eaa866627882fe44e14bf49a0ecd89637c81b3381372817d634dadac389c3f543fd1f012af8fa1a5d4b83d1a997f1dc674a79d85f56a19f9b82cb0c818c9a870f21bcbd7e13a15af86aecd9ed8d970eb37d6ad0554cf071987966c2681e26ae61bf3ce614b7f198279c90d6d7663773a1112ed48b36e2bff7bddc1eedf32548c7ef7630e44a16a23c61ee5a285ed4e994feedeb3c99afd8b857384d3a403bb51c7de7e70ada8e66978aa65c8a631c3b9c5f6c7b30f4b4634106b04423effd072cc1dced95e03fb49e1ea806f881a44d2222569527f491f1c9e2ed86cec1b1c8eed8dda2e2795595982517502373a8b1d3adbaaa6b172cd1eaff0c03108668c7c3d1f35d33b624c1eea17e1abbce0bd520cda2b0700f953274fb00e35ad31ae2776721240e02f1f328f93bfb0b14df00babd5edfb5c295aab8398128b1bd3103a90c527729f53d816518d6a7202064c597339d41648887d1d14f16e6ecf8e4544df696b7f3a27ef38d3a91de82438a49e4ee6f7ad7b647785a7c6cdf2a33e92096efdecf2c12cc039eb200ddf76b089e7f58a97b4157b2f032595b6b03fa067fdebf7775626df9cde16e2ffad5f7f5da1aea5df9aa445382919948673982c2168e585a5e29b0902837a1b2832abdf4377ebf7151590f496b1494e21bead7c4b4ccc2e485a4eac789608e4a7bbe9d7add74f9fb7bd25e862676fe3050804df8b36901889cf318439dc2a03051a6856e3e1418703df2792cefb4755f063a7ed1f25d5f6c90f5a04935a366ad5b550200fb799bcb16343e438078089681da169d822762509ad83e9d8d88a05d7f7cf190604bbc57b055e3283ece45b9543ab2a2ecb236ab448ce118457d6b569dc9a8dafff79b63fa0c1fa0e88a4b5a006e7c3e3a90c83cb1096e90827a74a8db84d5e8e287a0ba8894000b052040f123357d8420434fda802ac919de72606183646edd7e8178e9e6362b31de757621114cadf160dbb57a57ab4a0353551452437142a7548bebd24e7eeed60fc511db6b17967d055632d0b26e9072519999689200a559605538494a5c8349db7fab619c51e62f511d5c28c54ae22f73947c07bb2c248bc979476847e8f1988bea285a5119dddfb22c2b27d7726df572f89278619f36bab9a94651ca53267e81d8e530f108ab0695768474a396963b3113615e092cd4e8bb66a56bbb23e28ea8afac088607789dbfcc4241a6fe76b98b056126e9446bf93e71110e7ff12b8af26990f4d858e7c002ffcf5c2faf232172cfebf01aa1099c7d03244033f29d5c6b4702749173b9e5617188bcba31fc7deb19b503817942e79a780aa92c710417b7908f3e7260ec9de35830a2ff9a3552293850af024604209b8e33d1c14ab8ec7a33c13f19bd032f7b9c419d5b5600fd71783ef6ca7dcb2880aeb4001b394f24dac957c00bcb481862c0c5cccfe14eef9668151b868c24ac610d6da54103c89a212895e8caf4c2bf321d3a2875a9f943d117e407d09938fb52f8c2023e65b420d03ffa6ed8aba2149090eb78de54f99c825a0dbaeebc40d09a607b728b0e6822f3d1394ae9ee1519070d80a645aa526ca47b61873670a7fdd00950990fdc68d200e8cf706cea6988b6517330a602be55425f645ff404b3be544264183aa8d7c47a777941021ecef211460c79db4ab36d4e23c7a0f83e78811cedef1b775fac2f1dd68d1483faf61843e9f5c8af60f7fcd81fcbc7218c225a6cb8e4788942686ed71ad9487e1a95685ed825eb8ea96d2ff61999a3f8e1ac0da735af0bf841ca8c8e8e6c9632c395764e2e60bc426a489d5f1bfdf92eeed35621b02ceb90022f14915dae466461a0af0cee17bfa1a2224855e12c65f24f4b7893962c39facb9c29a26ae97518c91c2a0f7f431c9cf5e3cdcf32d352f7891db33a4e1375635f4767a05345298c3796591b65db1d14ce3b51b9fc02416490b0701268c94430c02a2247bfbc7b6a64100ca91bd91fa4670bdb34fa9e72256e91391e36c72e2c7f47ce54c8e314f971030c8fc2e70afab97d459c983a6e4799c9e5fc857b5c760a6e260747e05f46a23c68f5a88e86da0f6a9001dd4aa097a7788319228d2ea7ccf5f2f34263827fdc368241723f1145ce307d7d5cc963b50230c0ee8640e9a006d9ddad94b3fa1c366d641c8ef8f7bd2e238551a1ddd12e6ee2be7629b0f515c8c197f48f120fa4fa2842d6bb417f05aba13ec7bc0e3e4fa419349ffff2ef98b1d253b7adf4390f47db824d6c1cd71efd224cc2fd8951580cc0ca0d8fbecfdb14ffcc177561267515fcf66640008d6b33e393477e8ada877afa3490d94a885917eb75fc882a37680265c713fb0eb737ee6217792811886484f823315d6f088ea932a60c206126f8b9edcbe1e9ef15bd04e0e3a5f184f5f51e20d1b3934cf5ba60fa224a8bbff4d2e94bcc4ded46eb23a0accf3494c9d0220211f3858f4778697eaea8c968a0707b8bc9b5ecded7b50834746244830f098b4603eff1b93f23893274b60aa618bc098f11aab7850a9e24f52984c7a969d254b9614a2f92da7072544c51e16834796353e19bc94a546ffb0b055f2dc86a8ca0144eb50a8770a9657bb4ebdf849c51914646ea45994545c2ab14f2fa3a28096efd480a38c7065a23ae8dfe2aaf4fd7af02625e03296121eba37ef1ee37f7bfef21c214eddf65c0ac26b5d31f16dbdc7430a7833d21da9bd951f9cab28abe3c59639060f4de9811c907cf8449dd7a476c0664f0fa06064c26faf9e51df680604a76799797b382280cab08310d17efc8c6c85d594f486d2383171cb7a49041ca0f06be6b6882356422f6228dc5f74d1de69a108674f23643a74a89da1012c6e675d3dfdf8d6c1895c1882d774d20e711b0af9141e848ed7bc4b4e409ad2c25951d54119f8869ed51815af74a2818b05be9ea8932a3f7cbd8bfb73b71a0a3e7c5c9f3686f3d6ffe2e674ba8eaf59f9d3cb6be8ad2423da49ee6024a6a2de36cab89a1b6a0a33157a218e355a08d266d91390fad073b12225a92ed822b3cefb5127ef2e415c4c28a457d207eb9227b676d509b999ce2030835d642fc43e7c2f963b77f46604e92e8bee70450a43f0c67c38a49657e8695c3ffc794c07e007e79eeff704bd30cb02f4704678eb1a5ce25ada020980c8bb025ca914666b16df2beb27e1157b2af3a1a954c72712a5d386e33c3e3a93748d11c237651cc9f2f787e55c6952e2752f9e163591d69186b2fc35d8917dbe170bdd0b13d802787fe57065fee5d7480520172ba5debad09ce022dec84b6f9263d62a4f920e6a7c87eaecaa5e6bb4626b8d6e113913180ee74cb0cece69281ecb3d0ef3c86a24d2ed6779ae7f83994fe1ee80b53af6835988a157622f77c296b1a1d79bfe60fe31cab0493be7ce4aa9e5030cc1635bec9fb4caed60c9b860d13529cc3353241818c1ccce5a66eb82830627ba5e01f7851acb4342031a6ada5c9e616bb47b9a1c913c0814818221fd7bff86b33355cbe973f7983eb4231bf13e678c0c9a794936ba500498862ce059da6d92eb7f0e44588f44f448ed6e7c5e2b72ee1b2f83d25c98368e4a4ad06f5cc34f7799c4c40c52ef27d13b49a698c96c5aaf7d30670aaab1611bc4301c24e36920b7ee13040717a204aca3a5fa74c2bf39c7da4c6cd945383a3cbf49697da80a969749dbb40c79bad2734309256097f2dc18910d9e77f16a0b71f30face8a9c6e2e4afff394ac6698b4f1e081bd1fe68d768008cf216512263716e5bd4512b588b927161a45cc1c6b566249bc7ecf8164113dca25931c424abdae5f90fd913b61fef40816689227cbebe14a65550cf5240a9efa554bea42844bfad0822a662299f73461d36bac3de7a09e13c2328602e9e0c9f333a6f5afd7ba380b23984430d0c388598a6ccd3bd7594019cfd2a724f9c56adaedda9fb9e19add58aa3e431a9ffe7c0c7328053953485394cba72955dd5a0d8673c179affb9cc43590412c2e43f7d16fb111b9a6fefb1036cfbece5e83bd8c1b52974092db9cf031345eeb199b08a97618aa3ba365c4d17849d9c18b20386ac40bc7fa24983d7a954ef713d415e4a5eab1959a90d160bd24f3872cdc1a0f9378cb2fca243609199e4944286474df38a353a33bc71bf134d0783e50f5b5aec98562f515af5ada3c9fed68a01088dc51cf032efc42c174ebe656a4e2529b91d66612cb487045a5473bce02714963e341409dd6dce155928e1bd4cc8ddc90b9919bba76ca76bb61c474bbaa35b62350af4a6dd60623fed294a6926a01f6fb42e2300c8ffae31b90e296716de4dd67021e247907e665ca4bbdab3c4846dbeb722984bc2eb4acc631a299aaa45f5965bc72d6ab4c760f903c366ebe450e95ce11ef7a31a67e5119e193dd752bb5d0c2644c9bc3efa52eb505f99bf0600631b8c42a79dc0e94159d357ea5c7896188d5180306a9779c6af1d08fac23ff4990100dfe7034f97ba081c68e3fcc20ab6c6e1e4a52dfdd9665d60dd462a8bd0f489b7e205aafc41116a039d03801b40f004b8931de1b6b35c513f9504561bb83dfb09c6b29770770b9f9be19152fcde8834792a590d763e7945b2a0408aeff6d65d70113c4defbb1cde1b30817124d4448d3ca228be58e274db7172dae992474cc771f73307ef5d42b96bb65ee459f4d031dd8eeb1fc9728f515f69e5385fbdde1cff0a74cc8b545f6280fa50960c76469f8c992825218fb2978eeb6c8cbbdde33638833a5abc8f51505e371fdff4d4cce1ac058508907faeb57fbe205dfc6158c21792ad0f400905a479c0aa668570fb06981977acc06e7023a8d5fbd25e6a5eca6b3a70e5c734aad06d4a95b6c57f33c80f966c6f72f440cec4e06541892282eabbff38b6eb85cc6d2f953c74717a28c935743b191f5b72f2cd054d1145de35d2305e86dcd9a6140870c28954cabd4fd1afecdcae4d63f19b1955cc250049bec74cc99e606cbd00d2b853d50555c3e4c9d98dc1b71875c1d3293e5170279f2b4820887bb87621106076c5a39493f2323913030ece196f0bed6367de7b8329d84aec0af1ad68d25bcd6e9ce88f550838c904f9adfac67ce16a0ba24fa836f5d02741ea4c2ef9085b4aa0fd920a3e791eddd0be7b23b2b594503c9b10c7f7c7c53f5ada126e0ac3e002f2a848a7b320c8a9ce9086ffd023092f61c1e91f76c2da37ec9b8358258b84e864e98f2789d78bce8947655cac0a52cf9e20dca3b433cc22d000a987ee44dd0c8b02ad44f7c3d0622b9c89cb64a64211b7a6b24298cdf69ee80a077669360898ada7425a32fd4141f5b34ccd93d5da238553258c65737b8f15efd524555d68fa7007cfc04811128c381b5f549f8da4d87cdf4a5b29dbcd7ffdf1c2fc0925337a8883581d68b941abd07ecefd7578fc3774a4f0466c29b0c24fabaab46457aebb71d567fd17f6357877244c1bbc6b6aad57ec5474934ff7ef6401b3a149afef69e83d6496d51b9a21425f07890ac2d25730d5b931409ee2d018c1d1c09aab114fd4c11475a197409a4b467e8d75ccbff83484605536135039f2784f76345de640a7372a4eef3082d55fed8cdb96cb47cd9f458a9f9051bca619013b348c3ba52523a8d2fe7d4c22d99e1d9e3b883304d05d990061d7d759e84489584af0fd3f28b11b64d0bbcfd042f3573188c8572b2a612351443744b26441a3f5082b3eb18a3e73da1ec447d0877b7de701e80cc348d6c3cc5a724f00e10bab00d2929aee8caaadde05f1272ab4f934342f72bd853a9b2acb210d24c89395454d323dc8eefbb2470fdbac40088654856394827dd678dfbaa1ead70cced5208a70b8efe0cb046ba7aa273100ef08dc389da76e9ba8bd6a7a5fabbda983763386343b8bdc87ac59b404faa1b28cc84e8fa0c702a278f4825c24eb42b123c6e43994d9518b7e703b87fdb4f35327c9fef61942976b71b616826d524fe43de54c6069ff230be0de088ab26ba2691909409be8fb9c9ac5d63f1c54a9ddea3db27c69edd95efb53edddd6adcad8c89f2a6f1250fffbb755d26f1825a760935e9d9a58687864baec3fd564a9f8adb7d6014781516e89303cf00c999443c021aa80d04b198ff72b8420a9e0219e424670757958d4c6bdd6202b820d19f77686d8b0026dcade9b10232077f22f37bddb567d21abced7b0567185b3746fe375ee7a48dcc8aefba9e45b5f07f1b8b345ec5f56fba7b11698531190c081c038391c001279811eb6c24aec2c9785da0f5a9489c2373a72f9987c919c4eeccbe2ec2f5eff1f36cf75a1ae5663636904f76f48d00c3ed8e6a6004328462812d406e61587040418da3fd8988835cdc33fc2e8035d321d8e74d30c48fb645973b9a28e01ed532e78d8a07e8530c801c62ebd6d9a48693f651462710a7e37820ab54871629f082f3e4e567ec1938b928b30d16a6ae3f30653d90a80371030c421d96bcb4f9e1a79f3635f50e4f695fff6962ed0f4938fbe38fb7d29177da14ba059d85136ac6da2d6bae4d1d3a247307fdef53ed97f42bbb6692de6a3df10b15523c614d99d583d16091b9726e34eb21c5935a9c229c2d62f3d4f392a20a86b8122391f3f43a76e87a5a26091ca921f8a5aedf1784bc57e2d4c303fbdd016c50eff963212989697e19754fc30bb3260112c206d8c381699e58c8b5d82504085f428c8d792de5be206e12a5200674a190e5b48448e9515d6e5433cbf85ecf0e265242b8bff6e564638d208692603a08fb65af652b21acf076f3009c8fcbe2736fbba11068a202f5c9068c6369f84b30369baa0effb759e666d1dadcfb3eeb6c9045cef9d026407f0423d1576ab6a0b8ac6d0dbed4732e60016fc56608fa9ea0f2e0c95014416fa62dfe68375d619edbe275b2ea0ee1207982e07773d530e863eec32a24f43b3a2644192e45fd03016e713feacd9c2af933eb75f3cfef2e6188fae9ae9f1f4fc72d2b4ceb0856e6c89d508196c88128d330360f6cd4445ee6db3662f765d4d55ec71ce99d3ca9b60ec8097e97e32e4d4a8ac03077214891e62aac344124818e2ef6a33f2678c18bed8e30ee66d8065aeb27306d99a50b2cb272376f1e9c1755ea8bccf92990902b9fa656d0db89147b24463f35f5b67cef119badcbfdfcd5e0eea21b6e27f36b6caf9757ccfbee6cb696f9697afaeec3cde03ecdfdb71a7122d463da96031690d4d0268c35c4249c74b6e6e847569cff5b702f8ddb05d9bc1ab1fb859b1fd7e57bac615f61bdc433d104bff07b2ea92bd0508e20afb6a26f204b68d86efab63b9b5d65d2e80d9c5cdfbcf72907c88adacd841ddc2bd947b902e48d9506e34fa5b75d07c36d938d89a1abc54424defb62952ed8524d780fa214ea97f82d1a5a34c24977774e9c7ee0fc208fc47d6905c4633db9a50382d6c59aa261d2daf821424db77e59fab5a7c960959f071e643e46509fb5f08976cda8263b46a7e55ddd320a31462ce5f885e6b7a83aa0f7cf93a57ee23022bc979e68fb0c5f954a9174d9fefc233f97683db9865ed9ab8f10c488c4c12f8c0607fdf358f9f85b2c94dfa3bc99ecb7c15f31280268c58af27b54a0ab128391003eb32630ad0a034e05da30c07f46843999fd7c0b6aa159051ab34385ca69f67ce6cf1d76c147e0d693f24ab27652246f10bb9a3094743078f312a35384da9d435c6ada93329ca1f99b882c90891d43a2a4b24398f9997bda8a19651be9b98fd355d7b48f39ff329ba4cc9109210b97fd8e76db6935173f5b101d35fa7e521806a8d8ee521386d67e896bf19c0047d00512766ed305cc1d267013a08084763df35bc40af4a39b602204456b84bbf3d7edfd569ca5a68bfb6863c2986c4166a7deb8beb063bd545f011b8f5a96a14ec7a2f954e4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
