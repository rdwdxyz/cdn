<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"adb210ab52c4a2ebaf04460c0e4c3abc51bafef21d55684381a970e345e4df22d38beb64dbecab21279a8e77321d5dec9f76de7c347686d61a23ff9575725753a7d38f5bf86f724fc2d0ccaec2788c8d3b27af054d3854e2b522d36b5e79718201693fbe2843c53238c4883d5060865fe80e8810669cd0b8d7ade6107f00adff2053f7659f4bbaa54696c0b25f29cde5b58cec4a513f38dc06effe63210af800953799a2d62049d5b59cc730620325ae363d8a858b65884c9ec8d90fef4488efc4f30322b5ae28a50e002f15706fabbcd52942be4ab20ce9e81a6b79b9b56418dd776b44eeac6ec932c5b6b0bc0dbff353b2ad8a4b242b5bfe73ad6a98d5b585c1f70bfd5ea8bf1ca6d3d35a005aaa112d3dc01cab4e5d1470b551056ee72e6729b5399388aafccd85d44f57f6bbf2a42d15baf1f67589317e74a9bd6b90141bb2e4ae938ae701093d77a5420380cc640dae2bbdc155c599ced0b2dc952c9851e8beec4481df721ac272ba8ee69fcb728de1e0b95ee6074cfba00192847e44bfe8531392ec2fc14bb30a84d69d2d88cdc5d571dbaf2f5edc3aaaf94acec683329a67b22c1834e767edceb5d0be424350427f11394a16b915cd0cf3efa312df4a64db3ea72e37df0016386ef0abe6fa4b89816c46383d94a333aee5c0b58e9d979547db9d2f567e86c204b133c9cf5e060fb1a1bd5e5f74e6563fbf307581fbb6791f7ab79f671b190814350fac0e7d216a3cd056c230cfa89f07960a3f61d120d39dfa2de1cb148ac1f3e19f6bb2137422735fc8c7df57fa2b319e5ec3542511a30570e4816cd501fe7020a3c3c436a1bc48d53f5c1758e59f1d624dc0e257f1e5bdceef7118b9218218e4db6615665c5ec6f3e0e46a366b77869ee3de4b8779ac09f75c1e99b1148166276c48fdc5c917c2653d4cf189c5e5621948f8c64f00fea0fe9c6e7276498ba55af28237749cea0524a50ca69410d7ae287d07fccf9cb416c0567713588358afbd6f1383337194b24b9077264d0bba1adad0e8c4e1180e0ac8b565b6a333639452aa9b268520614f177b4cb62f3f2d40ecb6c8ab06fdf709de90b545bc013d8e2d4409f11d489c58e952c18ae374a5bd91a3f581f40f51c78fe5c214586156c1a1e692472aa7c0bcad5873ee08c7936a2465ec367841f047bce7669c68bc348c37c1b27653b1e3e953ecaa8509ad940581a259d3f28a4ab8124bfd7799d144aabcd1601d1b5bbd1351de46fbd30fa7b512012e08faf22fcde951173ab24c06ab4e0b5d988baf536244a0133699aa0204ba6587dbc73242f9b76484965d8e42a630242ecbaf8c48d37ce2d7fd80722ea870b570f8712a509983ccb139b723fd8a4ecee1cbb6139802bb5200a46e05b109bfd6b67212efb7c4f3c6801641943523f17d397b3a9c2c0f919dd1c10fef19780b8abb81babaf7a36923536fc1f2d320dc99d5ecdb1774f38f4ccfccc8eef8d6ce3a5b193bbe8f2e504fe5f57a833371480fe1fd0ce10cd48557b52c46c7c7b4bf255df99209e294df824babf62063dadb8467891d28849267b528580693b83ade7c6e5c6662c9ee6b7c871593b3b5866e942cad7d264ab78470fc058fab30eb6646ee841375c37722c116779a9d02719977ca790e64109541eef325ae5677bf472064f98e445afd726ae6bf4a8553f2f96739406d88e3ff3ea61391348c6179b0be5feb5ede961949338e5676c90b9a2cff4a51d673184e4d29d168f72b7aa276b2f125dc599fe82e7dcddb77d815c16798c2cb756c9e9357663b67cd2d15129515a655a6cd7a1ef22d46eb9fc555b58c94b504a49ab59aa56f9cec820c6744ec435c16f554c6f3d69f0f349a89fade615f985c32e06d23e34bc6e7a8c06cce0f0967c90cdac54f427fb8c89175322ebf25228dffee56c8e2614b58b0a2dbcadbd3106f85c3e624fe7b2688439b24e3a26243be261f3b7bea4ab79cf396c90c111423dfbd63f1dbfff8d2c9e1ec1af77a0a2a28715cc51ce83a31aeb4d0bac94d8632993449ce4da7fa2ec18e791a669a83fda72fc2357cebed8e045da0f5fab9339c7a630b59988108318f06bbff9f5abc4277f2935e57dfc8b1e09405bb1295062ffbdda0a6e394bd3ee08bc1d75a1b874986f1431e842d84f1bc1b0a633c84e426d4e4865fe16cb114fefd8e6c07a2ad194d88ad20be81ad66ed401e7b889cda03334673d528a12f782089be5fb0b62e951fd17e02355d16e64e4001a7f498738ebd92bc3452078b6c0d910c5d95e04753eabe302340fe37fc4c06ef3863441a94b89b79eaddb0c51ffa691b4498e598f0a0a550426e9f7aa8f89bbeb7717f678b8abc150ba03d7399ede552d28b0c44207483f6f279ead8409b9e8ae99d4985459c97de02e02e3816e61e4c1c7d02d6be7c3bb0d5d031905a58369ee20c62dc625af1cdf105237cfcdb2559734a7f74a8305e84ae71c68a74b72bc852e1ca09f9a967d66c527f8c348a10dc52bf91f73727e1a941f9eff3228cf5a6bef85a9f0b70dfcbd3a6ae72c1bc6075514d326a422f4149e66edec89b05d30453b5f697db4954a6554e4204d3883bb905e9b7aebc4451ae75fe6c677969a3be75d40ce85a21f31345183d3a997423682f32a6afa987cb0b7cde32949b84c7c94c2c1c0cb298ff8bd543eef78bf8c655b51a665e095ed95f49edfed9697dfc3c80aeeff59f39bdc81b4e497fc15f016ca2bd60fd9df7b66a879642fc7e4049ea409d3ff26d1ab1c815b1adb8416f5fad3cfc05c7186ae6c975390ec34143e0c29c928b869182e94ebf66cae96bf93ccb865f57882f10107adf88ef3afe1d34d0b08aadccb9cbc1be28525545113b3c9158a686ba2b7588b5f0cb19b36f5111a496c5b6b7d32d1da4d6fe23a28e0880eb550c84ef9674e9bd6bffbd147ff7fc0a4fde9459cf99302dfc407718c914f9be4406af3ea0690539d7bb4a55f026f7039260ef0ff1314f1effc4881666454d6b8d19dee4b780b30bd2553d30ab89ddb4979bcbe31b2f773ece85bfeacedcc645841e5077584ea80097525d7eb412cc36c0083e81bd1f1988b2458078e3d7802505eddc4010b3bcd44eaaf6d97d2ef0fa4e48aef71f96305415bca42d1829da860254b36f7c991d9806da23dee1d35f7015c88cd46bb6cfcea96dccb95a829db8f9023ad258beca0800cb507a868c6f7f8fc577a0f1c779d3ff167e32c890dfd8d6011881011da5a8be76b06cdab4e9375f8f417bd7dacbbe96daab10312781ee4b74357784a9c87482a1cde46e88f7e8d53d8707d1595a7b8f864b30b1e5d31d08cbd5be75d4052de5fd52c5fa186db26a7a444a9cfa84c039c2fafcfe97c6f94caf9d63c832e439f7af402833aa449dea2f62d5d9060b4bee0a9f8467ab4cf8990db4c71e76120f267af4d0b2999c2b7b9a0d59a708dbdd3ed4ee03242e0364ac752bb37b1bccdf066a24ff2b4d7919029959e9cbb1c54533254321cfa2f6df45c509752ec00585ecb83c36423e90a2813d94457658d432ea704601f253b261e0637ec033787b9425d1b50a6bd51817616a851dcd7282c6d857a8dec930dc22e29ab44baa27574deefe21036f87b192c126f9730a6b9d7819a0da02508f947de46b7decb4c56cfbe0d8789e298ba26883a3383ce8001c7c8a27f12f799d97a593b0c43bbde2c43c655017c00aebfa56d46257512e09cbaa165af4b0126f3e8d24383a4ee20c0a7d8646e14e00a16f3bd88ea8a64ed1dc1299e7a38b46025224ca7e152ec4ffe7d64016eb5552ffd6f1dd0432ea61f916becca2af6b3d919e2da923a783c3771bc2d6afae92826fd63affbe960415f6901386259f1ddea2b34c77810e391c9a542b72fa95eb08c0205ce7443d93b458cce999302a9c82090514be2a7ebecf59b1c10ddee1b1a2cb7b04ee983736ca84e5257becd09fdc0d2b5d196efb1548c14afc907cad1ac80f1c97341b91a9ac6b2d0701a6c3e04cf3d9db8b8318a017c3326da24c6ba28bba7ba1ec6fc553a56e20bc38e93eae46cc058b898f7759589eb897402c4781cc2ef8c868dec7bf5b71ea09dcd1a942d07bab20bea3ff6ca7459df3114ae58dba2952c199c48b5ee2c548dccc0f173d92f7d892d1e1e40f638bf30953e0fca4c8a8b410af2522f37d4f37af47d5d6bbd044daf76289b18b287fbd0c8b05cde24d9fd9278240c84994c2b969b554e57729b2e6dd1c88aa9ae4b958207d4e78e4bfd165700bafbfb1364de41768269b26e7514952fcda29e38796b77d28fe26108c3f5f353803c8c9e87c71143e6c450b8a8a927fc4d096bb9397154ed76195ec7582ba9629b7950a586b1ac91ff54ad22d1867ad68c2527f64717e5546645270aef41f80009ad2c826d36c0159b84ef710b40127886b5a314e6879e9960b69c0ceea13036a2cf0b8c721e0912e05d9fce88e407e5f2529b5c25eaea41ff49782d7427bce5c19ec8e623151803b05236ba66199e24c024e8052f9a13f02d793addfcc5b6307b826198b83b0fdcfa32843ce944e9fdef7e6765789fbe0447612892c2d81008b79260ded60113fdfa5fe99a9b597bbf9a8b6ad6fb4f1390c310948bd78b8c4f9c4a82967b318aec4b4415524b7a64b8480a806a709c13d1a054f06e2be7e942fe4f5d92c30ff23d0b963cac08b63498a271457263ad44ccbe93035f682cd9e2c7b82fcc4d92492406f4d2ce74385738e6798dec2fb5d2f34feb5ee4aa159e13c0e02d38cff0785d17c97bd68acc274f70bde049aa4e630e7f96ec755daa74cc4cf9da5cd0fb7b7e892438dc80c1b0dc7937cf0de714da6a5b965b3c4a7f5a72a151580a9fe9a1a253535c9a53b02af706a621fb587e03eacbc6133df1f043803f25792349293b569c0e0960eb65bf29ba0540d5e498a86534f34a8ea8357af50c3cddf05abd9c5e2b4bf882f05d142abee6c3f6bb5134f036f0b6c1091003fb1736055f44a5179c33939c72e787d53dad30ea5720e1cd6004987c89d51cb70e048500fd32beafc34e0429e890cfbceb455cc119b812cfc6713546ba50c61622ff1771c42cd219a42423b1d71c8f03df09a8cf546b32ec254b553a4623f4f3f031fe27d28978d1ce172d86756dc4c3af0e576ed051433ded5020cf7e54051b4f840cdc4042b59d4ff138ac0a36d184f8a0bbc6c7d76b37e73778d7073026ef613e8f183e752dee4572478e5e43f35c4e4318c26d9ab91f01cc5535dd0390627425f34e9fd7264ec7124f0b6837d26685b2ef12075bfac11a4d1e6dedb8bf69f5f0b1454a172e89e4d495f287f103195abbab19134192866cb95e3885f03ca1623693a2acd16b1e206abb13106af24ce08cdb5be0d392932622cf4946a88c38bc9935ec4280bc8d584246f3a75a176fe9c7ba6f3ac4f7e482020d09e4ecf5169a18875d967d3a5cb8890d894f5abeeac9a1b7e90ef908ad5947724f79bfad7fcd8db888fe70de20b32ce00e22ea3f125e44c2b3023d8d3fa12716d4e0108c4a341c2cf9aa47b4133571b3a601c483641ed7cbe2bfd62b243799497d8822dbb951d2f278fc11a4582a1fc6a2f7e9f5584779b2f15b0d3fc9a2cf9f78df6fa45f04602646f49877d53786be605e271abc538ff633c06cfaa54c3eaf74a87fa03ff11c9f8a8b893de12a5f1ee94fb212ea2f9fdc2122e5911aecf15770ac200b7086b3c9e474b41654892007edcc9a628b9919df0dcf5dbf7c0e75cf9b82b6ae5b6baf7b3d8debff6d9a49a8dfe1527a334f0f0276da2096e262bf7891b2b58bd5b76efba45004fdcadd34ef7d51bff87184a3bb5525cf1e6c3907efe4287f8a9cf80b61d749b1d0fb1cc21388799b672b9832d1ec1676576db7d1ffb4ccba7bb536cfd1f96ff5adcd2f5b41acb121ba9f0a668b7b38259c2b62de94c72525e51db327c7cb3923c33c332bd7feab5693c3ce2534474de60fd752c297d890bfdadc2acf46bcfe5392798f094e179ea909069e892695a9ce7e31c9d239e2bc53f09aad32eee3555e3602f4aa42babdd1810106a09f1f5ba933d7668fc780446d68700efbfa66276f2531f8fabaaf3f0ea4447a1cd666b205eb394e12d22e29166f8c0238ba5e066fe7b9a22d7e078809ccb50a54f1ad1a8bde6edf70b026161c00e3c669bb68bf6b73a15f3aa563d33b3b59274e7bdee834964b07880c0d49aee66aef5e265ac8aa52c88b33883ab477062eb9eca3f5641175e902eab6a36b3c8689d02e8808e363c73af1b6cc090437fcd194ddbb09efbf6f3b4dfd45f27ab2e53926c8806c8f18830edad610f61c1967534e1a0493be5d516495bb7a5639cc9302258e60585900bb600235843ac10a9a692727a9087d1219d79c39388ac6bb6cdad656e425aa92f127adedee097c826ecf600eb4969e8fd010fbf917cda28b4d6189f7541bbdd1736a9a56fa9b2b23234b8ec2b239e6ca29d18a88c44394093ac62cef34d068b1fd040640a856fc04d7bd2b70ce8ee8c4c7f65cf91084567dbfc7ad3601943c0b36b589fd2e787cdfd63e22c4160161d72b428c0c5c1abb3842dd36ec9b1c9cdc88a4897e8b2872de67930a643ccbe0969208a815627006ee933e8a9961c83810a1e268199d80ecc5cbbf5fe6bc1f11fa26404fa96fff0317a1d5a5dd828de459a9b14135ba614eb4b4a5c27b8f37c6c16749ebf59aad60229d5150823a06419bc35714f60a7bfb38980cddfda464513f944691cdbacc938fa4a048a29c7f27a4e49caca3273481c46cca2f2878a14a64c991a6819bb7f904ea3d0c236b423da6443241d6f6ee2fd0702ce6deb8f01f0db2f6bb0d48d2396152c658fdd06d32256b6997225ba49ad66b3e7bf348e0adfba4fecd124965d1bfdd78269db6a2527a80f34e46f7ae91cdb4a38543b64077516e32d752b07f2062d776fc6f0cb97cbe2e1b4116aa03033ecb9a3c4c5c070494ae577ca91d99218cf08c54aa6ffacf9fa42bfccf8c92d810518d31c67da7401699d3c0537de4f9e5437e65d099b4665fba4d4f2359cefc9aa4e5c44ea94dd5ff0b9c33e8f4d3e03f5e464b071298c82e2d19995a93900ee5065db30a21e6e3f8909163b16bcac47897ba4bd9c5e44acbcbad9382078ed51f0e781fc5d2d4b628ff6012cc2538d016fab66c32306f1acb85c00afda0c4f4ac548b0fe6e9206e6cfa4c135ad002be7d1498a1a0c14e42e64213a07bb66127a84452fc67c8410b6d08360c7e99bd024483bae95d319248cba1fa5400daca826cf71d33de4a085b618f13ec776bd94e4caea5015c3f58693179dbeafaea485df36a5d72b9c57945ceca3f9267dec398be5c0a31f64553539fee15564f1beccd30ff8329200369259517e073b633264bd5ab673f1d7006a85295fc3c36e09ff29d57252b9c1235b3e9860147d55796306c15fdcc4bc35fc155d191c60adf5b3040fbe3cf36feadbdb2f55e9919bf7707d80498fd2a7b60e0d4196b06303b47608bb062845e7040812a51c8298976e389c2cfc49f5eb232097f4659c5041e8fa3ccc7c421996d9bfa976b6dcc333d1c37f92142e9b029b3f04b5a1209d8fb4c07b15e38d7f7e35a03d6c7f43b3c3960b24ff1e65dff0a9ee9e37fe2d25bb57d32250917d720c28913c5d53fd1fee3dbb3d709deb7eab2e7df4aabeca22ea33a909fc97f43d60d20e18aabaedbbdb1b8445add09bc2f9c65f0c9028eddfcaff7cc88f18ccb2bfa4a54dba9982a74a207e9a99c6615be0439e96166fb8a6acdff781b6db3ec4ab23ac2aa1eae6ccc6f72d04e0e2116178a8a4eb953828a8ca55927731efe26bb9f31b328906ccf5650fbba76a968ccd7327d3959697bf2eb4ff81f65b649d0ceb516f9c88c9f99571f58155fdd4ddde697310d15b7f6b287bb7ae696f8102634e1184f10dd7d45cfb115a0874ea4dbbdeb52cc9811d7e286119f64a48409073d0f06f796effc2f98703c60b49dcb3fa8af23d3679b1956e22d3eaf45452c81933ee2d99e70b0ce9b5c309e00d95e08cbded468c945670368a6f9b59a51510fb6e8a96cdac6119c2acf7acd31a294a90a078953c8da116a71f3c994e49ded6add196a8895d928953acd542e475d01228c391a90d7fd48506e0d4ef313c7be5f78ed83cfb39270d4ff13b1dc838796b7b2536dfc02daa929016ee789711108c139b8e3713a6370bf316613ffe23af3d78d415cc4a371ca33b6d96ee35a99c5634592d4c2f903f154d6d512d8d243b97a587a95244b35e39814dfb460f75bdb7225cff44cc2c53d32a576ac539e8dceaa4d946ff49acd8987798f02eff9562a99f247064915e55c6c0237022324605fa91703971d3e1f796f9f887f0ba29042937835f77d98f6d3b6d86461b10dd38147d6d8da282552d0516c886cf879390a9c5bad68df8438295a79e55a27ee0906f03a7dcde35cb9ac636a6d151c18c9b9d329e9fbe78c23db7db71bcf6c57487df48c132da20b3897115fd8fbb66de80957ac14422c1603cf62e69499980e146b9bff8f450afe8e85aa1f45cb7f65ef79063d7fc3223662b00888de6e8e0da721ed0216f0f55d564f21dda77266685c6efe0448b70e938010f84af0c1997cd39168442de09caec82e717747085c0d961232c6d027c1674ff3375d26af2a878c20fa81310a48e434b855d9f8382f79c1e78ac4e176125dfe719b502780ba907f898756848e51060a079cc8c47f80a11662502e3a0be226f05031a6483126c0bafca06debfbc44c5bdcf3747a82200cc80bfc91efab55733841e97d4f3602afa616242ac19d18cb44a3139b6574d6cddd051ac30be7d3e0a3092352c54fab67f1fbf85ddcfa20ff86bc9357899785ac394a530b77ba584144a3ba0f62c98b9261a006df0f417506c5abc6bec5e2aa666e4bf6119b1ad7980b58e7bce1671bf8bf38b77346c01b7eb6ee45c4daae5975726f6a4cf5ff2bab35a60837e3020815a25fa30060a0b43367d1b5c68f52e9932de715f0e2d248054265996957357cd3da0f1ce07b78c6716914cc09de4b7e1227786ff76783d5e0e590d535ead66472fbd54d8d126795838b977160bcb985a72b0ba873e0d48551d1d3d21595e4f85499dcb89d2e90ec59c733c010892be656a8cffb99efda2137a7b2ece1080395c2d75e93448fc4351c20c0f2eefd1e4e08f1b3de48d62b6219d8a9bbecf90b84f0c370cb4ed92475ad04671d92e2a880478e6d73486e6788c99dd6190526d182e4679faeb96c1c18999ab31f7a42c1677cbfdf77ed13cb0ae9dd1b1b7dce56117f3abb3bdc0ca58941c6ad67226b5d9e8f48e3175d957f3faa607b6b8c32ddb92de446e808e24516cdcfe4db8ecbd35ea1cf88452b54b237c7f3ac3bdc26373b3feddd83e729a8b8d3fde069c4b3618a5224ea815ce631b341fff7339d3bed424a789093793294f28ebbbdf579458d6c9bd3db4e31e0d735447e2bb326432b2900fc314f1cd8e40f3259d79262bab8a93ee60a48b0111aa56fc64679caa5882d0d4ed9e8621c8859e863062b79bc5ffe0b9dae7d0a99bb60c4a7e9c71c4a84268c5d60e327aa47dcd745752a694d7af645946f051a39807fb1e17729c6bbccba70d4542dbd7a774bf61497ff600fa02c307d7d298d204c12e426d74e9961266d75d733363e86bb373e45a69dabc8baf965dfb0a71c67801897ec45cdcc7ef6ea12d2a3ec8135e63eeb18123e455260882edb6540a81bcfcce04b44417d08d9efe298336bb7a0f54e37148d7c94ce20707c296fb0858b2d5b9c0273ee97970db56d0ee482ef76e532b100e0b3b30ccc65343147c8e5c34f1b230afe956646fe7871f949f1c2560e70e8778e42aae35a17aba97890d173cfd226e0039f8b3e35fd7cc072b4ba2ddba52e5fc5aff67620e5b522b03069a522e5c9bfc3d111e51f19359baf4ca8bd54767cedeb106d8dd8e5124b3f1660052fdec1a32b27415263d11748f7689eea98a82555f74d1a19c0a05bd8db4cd4fa7bda96cbead708bd98b1eb308b920cfd6bd32de04bbe02a356c625c2aaff9a8e1062d1591e0175e0d37e72de4c4a8280380e3e417edbdcdb776f12002ef2822666b345906ebae7717c04336c571ee184b03273b39abee6f46a08ada951db41b76f419feaf34befaa0383fd6186047b6af72c4ca92e8f4de9e25121e7f355f3cfebe95f713a821cd40b57c92c91cc20da96d12f9c1c778f069612f3a0b186eeec490474b8ef5780eb39aee7d990ab58a900a723a4eea0ff91e71aaa216ab994403799f1a84ebdb4654e8df649f6da60ef3b72fae3f7c88ad579d80c59edacc32a115fc961a7cf87397593f3c0f2df87eaf320baa09ebfbb17dadb4884fefe6456de32853c7f9fde74be484b14911ab78283c02738518","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
