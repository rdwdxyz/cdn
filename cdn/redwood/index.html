<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d5a988fd51204c3418f7a0c90a5912bae9889d19ba4ba8766e45d1871d8d946f42eb5887f9c1f079a90361ccbfd1a3da56cb92cc4297358ac9b845db04e5ee0648a8b2e24cfe76fd44e11d0a537d49ac349abae164e7acc4b12f168227e0dd5fcd736ce33b6a112d55771bf24c6b1bc49dc3e13dddd87fb88ede7b4c3d5e1e5483ff884bc068b14bc7249de6acc88297e1fd6f636a53a75cf5120fefb322018d84343c7cae16d85a0661a79a402350b7da7ba0797c4f3c5a51ef68de35822f037ad447d1463910c5d301d809b8e9d2784e1ce98199e76f10716cb8cb54329edf2fe01f871b9ba0b51add392bd959f35942cc23c924eab43ff5609a39033626c6c9e60120356f25ef2d704f68e23c56cf7b8873b840a09da05cf5c5654e7296925061d90cab4237e419b00a2a6d61fe518f5d326bf6b1561d1bae30e0c180916a8e76b104442cfa4b9fbad9706deab4a9a38add0e4e6a9515d1b1b6ca1d68db1a917160c128b070a021a1753ff06e5d0641f357751cf863f582ac43a56bada6a4bff6a7cad3a115ed393b46e6fce42b2cca3a403f52a4e8bbda3991b505cd431c4b2129b674fe124314599efca8f3c9fbff9724ec19a24d7cdd5a214df219109cc57b827f9652fa1843f3cf87e43a2fb5ce67cbf65bed7d2a9f4e38d8426f822e28ff528de60a04c11b883a22f08a0b768a658c10da8e4515860ff0f96e0e4b2e2bc80fd3f7c46968aeecb5bbb852f1f8698a2c3d8d688e9e1f92b105a9ddd3a37a1e5ac51541fed3825e7dbebe773b50294008fd8fc58b98530058cd921ef5b67f8cab785df327b78c044a566e8abef4e6fbcc32263dc8e2891be56de5bc472ab8d316cd4642c54206d57a70ee8b54623abcd994907ca67bac00bf09f5fa5fec9e05e1b1a9c8881725e67cbedd0fe44a666ff104d927c5d8ac803151eb60f8991ff2216435a2f834d1d34e89c83a9a53cb50b454ce7e890541b3d34593033065c102f8ebfa078d95920adbeaa1e8ce42a1ef3258fcaae00568e51fc5f99af708bbef20c73e1af1d3792a4d3ead6ee59f251c1d3505a1c42c369ba8cc34db7ee199649ebc2dd9f5748d8ca5bf66e78f10c34d7ebc09f37a90c42b493ea5cfa4757fbf2443e9c399fd348a554170388cfa5d64e45f6bda1afe93397e6a4e34eaddae5ef8c1d2a352a45479355a9f58d61b6b00bd3ccd596c02c2c4d8a5c1c0c784e3904da86353f0b5a7da92c4e06210d0de803b0d2f2dd9b31499bda0d798927cbaac207e7de2bb08419b1121d4376654d3802fa01f245d68e07730f8ff66792b0e1cd2e3a954eb8330db4538ec5a3456aac662eb653b8b6a4bb530de6469d548c4db372f69bd7902442e6425c04ad7236af130f77256b14fc4da2f927ec6a749cf0533827cd6fa579b4f8ce10d1faa2c698b3580633bbba0e8975d8dabae68e56cbe3c710121476229196276d002ab26230b7373a8b98e53b55dbd4eaf5227b4068c52c1d0030fedb3547ecdf2fbe54b22c905a0833eca88cd8275a909fbdbfb4e06e5beab00a2da8857d9dd82dbc324de074d4cd8f03e5fafd9e0363b42a63ad833b2b0fdb34841a867d76e8b5bdf47364acd871908c9b9a7662eb3870c5a889b490f49305c9d84cc905b94ce1e9d4060712eb721d5272f2f972bd8a309011073fb672df6f4c80ccf539e4e4c85874b1ff24f27556098dae1472139677603fba7eca303010350e4f8d5b6bd58e93c78917dce97c9a0b4014ec7d81652c369c0358695f0c02e5c7729744c083baa7d0739e2f80fe27d0b8e877e0526adac0e8f680ae9317f2b531bd16c453477c6e18838d1d8958c92c7ad59ba38f95b702cf9af52392684cad695a7f10adbbb8df2b65becc948925cd6dddc04afee70561a4aa72c3fbc27ef2214dc687da186ce1128122a85a8324ba8c500d74d1626eb68a1c40c5d2b0d553bcc98fbf7a000bccf04016726d04dcc4a3c5c7db02fb35517ea783d1c1e58b001101291cbf3987f45ae365e73164e3af416a001be30030a933897c8360d70bbaaec151e1858dac93a6ea841c4d82e9af1f808a1ebad9a61ffd228d502a962b6bc7f1612bbba8d8f7bc7939b3e8397fd3861be757d00f080349dc783c2a97392f6c2c295949abfa42c776fe901a7d844b3623c57a6c1daf8947154a29c150aa1842c4e14fefc51aa1dbafaa311bba692be8cbf584976138c9ca3be1b3e1c7363dca0d57a9f77784df6c16aa568bba4cf4d7e75aaa1552aa3400bcc6da5430887a40a58d5ee2b7d4511a4998b6640eab0a1a0ed31c85196e3668bf8db57dfe2c90fc873960955951c1f3968a83d7d41ef8e0ec538482dcfa9a8c3ffaa9a6d189c50ab9da9f3795b6df59c8818643f30ac950fe6915554ef57068e00333657db2c51575fa6d6d374a5d0a0811b5995876495196d4ea63c8c544bb167ea4277d99a1798bef5dbcfa27a9641ec5cde369ffa0dc988611932b6bc35b81ee4dd4377b0e869b62a00f71c820869ea76731537183384d0bd8cb5a7ad9f81eb10f417fe0e607d5f31170adc048cc91879bcdd3b1bcdefe04881cb5029214319df08cfead592af29dcf6118d9ccad765abf829852b5c32621a74e0540fd1542aa5cea5b5423d1ec60257e456ffea3294e0c27723e7a8d393e79f393411c48edf2b5fd12c057e7ed042f0ed24f8cc28b80820b4570c1095181cd7da2d80c4579076d3642072e3dd50d0c850adbf2e8a73b92dccc0e5be7361f544f96d942cd6e45ff6218c98e3e32b0ae628df266518a333118c1eb2e2bf3cf39316db631ad4176716b0257738059cfac35c7368efd747116af7633a45650faf3bc8ce48163d4ac9e09702f67c56da1fb6667f00131ac59ddeaa5ce5ee431a981918b93da51f01c5690dab35b1e0cc2a6b3042ab979fcbcfd50bb6ad2ce1ad618ba77939fe9043efde7819c0d4c6f51f816ea04f4aa24e4f2b228f43431f81750fe25a77cd3328ab5f3be37a11459386f696530cc8d90be2ffd245f0559ed8617a316dcb0176cc213497fc1d30a29ad8795c5d8be9da68c735340d6a39a632af5da37510826434c88ed5d25f3a15b398de9bce7ce8795727ebc261809ab3ab895b20da2f58f1772885c46eafaa59ee17e5e61837b33497e555b95395eef805b2e66022b08c8e09f16c83a793f87c8c45edaeea0fc52ea7d2022ccb897cb4b0ed214c35e3f3bf1c4e6252dbb1c614388287acaa35c86644b9d7a970a68387ae94e904c34091e7c8d7d1c0f981a84bba38bc439790cb0223b9be5031a16632c90e0762699653fbdece491675caf97c25a92025d5d2417d099cad8ea58e6c006d6735837a49a51abbf79968d68184d2f3a1228e734073e2f6ac3b4f7ef45b41f1794db7b972c236da62818e94c3355a82a54118c3eac99c05f6f83688b2b4a01097ad15b014e3fc82036a091ab1cc051d805ef3462f116c675dc7cb5aa8a3a8b45c6ed83f7782aa9395b0cede8a233b66fc580f18fab011474f9afeffdeb1996b8de0cb4e1fd98067882ee6607028888d895a72cc26824dd7ea9f78633b82f13b59c9860ba4545a8edd54718bd5cf2aa76cfa0f17701ffadc81242184343dd0cd97717dbb38bc914d8deea42cb7e57a44b1591feb42e7b61f8622cd6763e07a6db125fae9bee3f438a9d88e3539387ed3e8d21e3ae09ab299fe6cdc37f8d9d3f9e6f1d5912c84bd85105d5cfb6fc932ea4e3ea57d64024d01b85007c887cfb99824b3e6937698deb15ba6f43b658e005489a466fc2efa75b2e99dab7dc3a873431b2c8254be9d35077ab20ec1ae35bf69ade2335fe7a497e7c2e589303c68ded5edcf37913bd39161cae79bf2ae4d84266c45e69d07805b1156aba0b23ed384ad37f5586fc2d437a189f727c6720a640df7f86e6386f144e421adf260fe8ecab99effa6851dc23dd384527acf5321423d4d5c5c748589db5f4fb69f442d77a3701fde8b55a4afa34376eba80c52390bdc0ab3ec8bc2fc7204ed1449e7ef81ea407017b1726b44f98f25476be85126298a291f42725e37134a9722ed015137c8dd2c8b36d5c50687a0512277d02d4f2f15e265b8ef6a1d32196c4a61d6f6438de44e8fac11c1abb65de588bfdb5802b988e9e10b5d0d0d7d79e8e52df9e59b35879d323877f1e3589df85305bd3799b757a3007def654b6f3926e5e1c502cade36e57402e3ba4445e7b42bc5e5774471c0cba12a3d5833190dcb93e8068ec4bd175d87cc8b200fd1a2b3721c091eb0c82803d5c54a8d235d6eb8102411848873c568fae340fbf14e23b94777f8e8ec669d47a5304f39629815e10bdf0b367f7b325fab691cf0fded5b86f125d9e4be731b3fa180eafb2de5965dedb136ea1b78415f8b848eac0ab5674c8b4b26f32618afd0f407278d4ff8f96bc5a766968435724fdad1cd68b8bc7139c0624fb73759c5c2dc7ff3fda0bae7eb6be137fc5d8369f87180c2905ef0b6d248e3c71b8852df281b51b9ad5d505c9fcb8dc9b2f0d35d305093dcb3e6122fc65e98a44df1df9eb9e3fe306fc49d38a537e1f4788cda276dc7e526d3672b2b8566090708d07edf556876344900990eb8a690977b1773a08f36a805bb24c853dcc4f4dc412bb94288acda9979da1d8f13f66240bb3bd1471cc41d99f4c29bd83fa1fd42f30fc4b99c8823cb0ae92d5fc765b226b86c0fec8504a91bf62082229a32ca2fc8396af335b3266945bad0f9a5dfe66baf64848caf343dcc13143b1e77c7e01457589c47b3c8bf292722aacab0036cb655dc2793ed52e7adee1226742152382adb0363dcdfd90d9f5889a4d7619251fcaaa6cbc1aaff84ed1f097a9167c73793ba88ac1a69d861a93bbc9dc68513a63e1f88eace3b8ce412516d3bdb0296895a729041945d7cad76b93427a9485fd60a677df4e038f996cb29abc782652aa3bfdcbdb7301fd8b9d30976064da6db49d69fa165a8790b76135bc81800b5d718bbdb32d5e2df5c7176cd6626a841f2a4f8b7f270d626a84a90331fbdd6d35a328245575cd037d823b6f3658de6dc8b25573555e680ad48ea45eb9f8d9b5228133a038533bdac6647435c87c8839cf2d1fb9346bc3249a51b32e53bae99add2206a7067133e9c58deea57bd14555c7e6972c2703f7a53a37f1eb60910ae12b4ae1003c641ebc7d1fd1e63564a24dac584b0ff8d84b9d3c539c0fbc2a60303be68fc16f86b3f62bdff8b127069bab563834c595046472689e64482100f2938b864a4fe089c26a495413327995cd5ecfc49be4fd57b935d7580961de5ba4051453f33eef0f12db0cc496eb9056181d023a014a53e25045274af7aa796fa4a8c08a87bc2a82a31a80ac26d279f9d9fb63cb9cb02f033c565f30e5208c0b449cdeac5269aa5f8f1571e5882e43f39e373be0fc0d27826e46fde6735178457df8006f4b3ef1ce23cf60b1e7f3ba2dfd48c652bc8233c1acb8a84d9799db16571f3a66c35e1e8379f32c8a103d85f97669c5259809fdc645b2c8246e26f741242c3513d097546defa656c923a5eec69bf2c7b5e79312ab981e8d123f71a97679de02b7aee602faa0567d9c771e4221e4da12632edfe1ecad1b557995325a850611094ea0635d9d561195d82a11ff8cc85c167d5fa2ae74ef56f2227cf60e5c4ba022ad0024615edab01bdc82fcdbb8e4978954c3651b9424a0853cf2c88f377d2c97f1d0278432f004f24a30e503209f660413cc757274e4366b9f64ad45a9306efa59e8c1cf48430923bbb07c298c5aebea4155e5294d2e44b8623d8e53a6c50a1b0c90120cc839255022b4c56ac651daad21882d55bfdaaf603f9eec8a4fda473b7bf11a2efd57798d2ded452f06bd08529ad2897b2ecb553d10e37b32ec3943ae3d709ee092b70cbc5826352993b7584d65df449a0c8cb998d91b4c610ab02df01c302ba837263303086e377f291bd3e73e98e4a90d05336963200aaa367153ebcb2c9b3705fbbe41f0102492a93a3ddd3baf1c2ea88815a5048c8c646d038f1f486a18100de97b428d535a40962487e6ec13dba401aa178b0a83ecb4d30f72653b76df8f5261d33a2847e2a5d1e9f68bb3b0294b40659b3c53c3f587597b3e5dced53349a22a7b33efed3b85eff84a82be10895570872e27c24cd9a47c0eb0609b241ba771de7323c6e2142f4247210669bdab5002fcaeb23b947588ad4b59d15deceb378862d90689e8f4f83e41209cefb3c779a634c34cee85051dec868e474a382dfcd5380ad04c2f59fd2846671908af1146548243d3d2c676b54f666e26dd7806dce1ef3ab5da2f8118207ab0be5123b2b8a9eb4def1d3cf3a80e8ef7a19c07808d7ad0c3e78a531f397e44ba19ac24e7fbc72f90a0488f6fab88c008e7a5699f5404a18651882f254e6df6cbb4ca0bfff34fb66c9e6eda219f9073583186e442c42f7ececbada23a17b4c8d8bdaf2a12bb0de75d61ce3bd70d5d109ada809ff63cdeb502466409ccd77743e850731987b7376baa5241568da39876d0295c760711cb97b823c7a0bbdbe5586365f82ce88cf114701a7e4ffec98fad5eba2bab35ff5b37a08a2b67f962582d960196e24be7e25482b8e6b08c41e4a83c95f19a852f6d048a04447ed2c45b484871e3242946be8efb45417246960ec196b46ea34900d10ce01a6ed18cf04d7845059d28fdd329a5c83d0cbef77dbd27f721d77aff51620783afcac2226bff81c5d5a43b24785cec3de47d10b455b6990b623c624582e5beea12c14f4f6625b9393b72527a79f9d8bfdc1f142dfb08c2f711780e6bad00c1ac156494c5c302785f66dc26d3d44336d23a56f57258573a2df11942a41f5441e6e07a2e8e95eeaeeadcb2fb118937510ce40d36c22e724f7ec4eb91626be9961b9deaca9840d7df77893d78982be6b7b2bf6228b33926f3eb4fe4395f85920317a8681e01962f770ddfa1f01a22a516b91d5cc0b6dff4fc7986ea1393059c2303142609105472351e844872ab8ce83758840d30a94d9d8aebb5b548ef18164168b15dae4e598bfef3588517717cac465fbc49492cd00da1e6e466daf855448fc239c332d779316f37be72941da79760d98a2afe75924ac5b9e37cb10170efc1684ea3f3f4a3bd8836f76e112b6d2f134b494f35c6c3e435172b5f52303b7911a8c9f7f81e5e078af026b093ab20042ab72e0806ba4a66a73853aed6a3b14c86f605bce01f0377c682628f278724b6b0ae5834a268ed78fa307be78ff0776cc457e972ef0334a1a8be0e05aca8be4eb88fd3994d8357b2d21445c960b468104b507455840fa870235807bb01db6231ea5394b7c1e78730379c5deefc2d5a2e66c5be893945260e17cca144429b4d42475efa4d8ec637db0adc313770ebcf3ccf17162d6a43a46de8d18b944620a9204647a82bf88e78229e7b84a42a5febe719bbff06274e0a26bffccc4df522c026094634a5b0de86219348284bd72a56f1762b1255a8ae5653e2ea12a1a0a8f50eca9e1c1c77c84a355b69c705110933a9240159981e9613a2181cfeb8a0dc842411a2134a3518fac1225bb91e3fcb72d31b3d71d545c37894f8104ae003ae0477a37ed11909a6bf4054f68b2f340434affd9d3bb66334f92e1762760d4878d8734e02cf13e3f18786130172c5f6030ab96c54201fb2994a81c792bd3f7745cecac870647b4401ca885eb836ce456cca98f918527c6936058e7f479a772af1eaf180a9f8eb29ca9ec235d08ed38a1a830188ca6766905b05eca6479c4653e610b8e77f9b383d1624edfc4a1f176d48c7cf42285ac5ffe6932cd46741abbcd3932e1f9944841dddf10094ae6fd90eea969ec9b86301e86fef8e78d5a577ea19269aefd2457ead014b915acddd4cf30d8e796bfb9856d2e1f1e648d2883259260fcd8de2645efa3c4265a4d254e3734c92230553f1c88b90b0174bc93aeeabd40138dee695df755e2b7b1e4275189ab323040d9480489fff0cd8cec4be4ed19ebcba716fd0bcdbad174c1288646c11c5643b15b168a0869f2bd850223198589df1068e94e2c09c5fdaa1e14e92a26db1c07420a72f2d50a25b9e4970360688e2d327635bf76883fa8f8bd7a51561ac45f9db85c1aff312b653e486a6ded140686a9856f8b67453a9ef8665c994a78cca335fded4bf0a1dac001889d74928f989b692a9d00f503a9382d9f87fef3b7c5a2cbade2e5c3705978e66a168b45ca27cd58144704f71a3a8754d37203db5107ff762618d579f5aa037f4699650d917933109030aaa90e9ef1e87e5bb57ad1edf70cad68ed8906955515391d10966bfee57d5c9c96148e3cd3b492ce50e55eb3b95951a72e987249dd9e84a5c2e1361ccdd7dd0b986494fa49e6af79f7b2bda19c2f7ba42583b23d71f3d9106356972ec15ce097ad34d7e0a2804d4e9bc542e3c8fcee23584721593d4d87977ab47d86d9e1dfcfa0a8b0847b7fff787e4ec88a939eeda54e4f2ae8b47e295d3b1058e4bc90add359f71a49b1322cbc7dbf602f317407f9cf0e2d0893a169c6575c8c06eb49b0d1d32d57f1e5852e4315138ab56c89b2b3a2f65ff08550efea28dd0dcc723ab27b01ccb00caf496d12a95aa95821419871baeaae40021a257b1cb81ea3c98ca7e835f802a4b76d4ff08dc074fb72eb1eca3cad8a1611b4a7fbb7ab301c292ab2dfcda973204d3c9aac9f5b628afe4805baefd106b2bc303d32f4d01da9af5622e4dcbaee88408f88f8b2fbac34d22c10a6e2dda179ccbbbae5075dca423a76c88a8518d1c3273fdbf4a4c477740ca21d9e97213a92c8e81d391234ed0e70b95490fa7f4588b31a7e097e7f473772adb82238cf9f8a262561268354ab5a75957ee99733997463c35029d26a704f7dfed706ed852bb517fd6f3b59133be2bab0cc86c5f9d2e28f859d3520d7245f6b8f55718ff972308d8008718ac81bc4e39de2fa87fbd5841f2df75baa5f23ab93347cd09473b56e88af749e1f47b855c9e1d3c8559673a4f4db0189bd7f049377dcd0446f4e7a52a514811a3a95cca2762dc78ce2cc490bffd13278a28b62e40cfac83bc0e4d85769ed5ccbf2f3b874b6658614a219249539e5e48f1ae4598fd5b031ff7bb1eb0901443115a95b68442503634d7ae13199db957858d00f0b1cc8254777ebe1633c46eb376067f0b87bb4d25febb51097a60475a2b4d309700843054589dc36a57e11ccc5a2f914d6d8e896a63032341ecb4339c36953503328031a5bc9a9da940da6bf16fc59cedc95c6d8c1efd9debfc0aeca169335cd8143e7b27519b6344e9a73ca647f152bc6783ee5ebf8f4b720b5b3230f6bfc88c6285580ce231c6d628597097758a0aafdb5de854146f069b0e265407cfabc32bb6fc6e4be241fd48a19de1629c7e39c6738074623421a8be8c5a81c8416e17426260bd6ca0d5039b0fe04fd6d68579cd6a8df60fd8ff3dc49898f87ee08f67ef708e55a8b7b7955e199ec0f1b84f65e103e335b657a1abc8b69efbc674fbb8e770881da5b568f7fc52fcce652ea7723f71b3bb8ea3eb2737739422ba8e0ea2d820251e9399c97048371f064c4d883e8fff5ba54a0a3f8d1efbac7c0f52eff75b62404b0895e0a39b2edd19f2885cac61457c99b8036bd610664b1198db59ee82a8142061814e1a4911bfc4910e42577c8506c99237eb937b214f80f3298dfb497093d2f8209cbd6f8a08a3829aee7c88dc464d8fcfd23a32d4bd7aaacafa2b65fab450a373030711e9b8f03607d8db3d565e8cb628ed0000b5968ec2273a358c43acc9ca4c9ae163967aa35a5999da52afb8cdbe898ffd957b6bda342d88976675ef6ccf73f3a6d69dbc394d8a431f39ab6db2d738bbd30d2419a2bb6c5413e5088687750ecdd6847d5b99102af6145fc0abd6241212fa254d1a6ec230aef851672942fda19934afca1dfc7e39115b8f992a6b629445dceaa3045797531d637e20ebd2bdea3aeaebd1b7049eaaae1c9bf260cefd5633e1185c9a70d86ff90217c58d13ca11103fbfbbb868f4bcc29c108951f1279c0193aee4bbf7fcaea6f680cb9ed1f128e61f4ee7f0d96373ca8468c6cf6711ba3ac479f1f6b0b887e2a00025cb942afd8fe00a59d07fe192898336bb0379e716b1c43050217b6a8c99f700efddf22a812f228d92cfe9333790515cc7e89200176fccfa7b38516881f032cb3bcc99caae11ff23e9bbc280fc3ec26d6b28eacf919759daaf92c37413f14d22b999fc1694af9ab7e54e8c7a59a3be64949eb5826d9145ef101a8e203eb3590be3d5333a39b89a37228a644dcb96556ba44dff5c49fbed5a1dc64e896c3335cc66bd21b541e2d9a588874f010aa40aff621aa8b2e919bdcebcff726363569a12c0d8b762edc472e0400e3facba3281b11d1264611e58c60f3e231a36c752400a08e946b93a53295edc5fae2b5ce78bb33d27da6326910f3809809f4f16ec93218fa67e1681486115c66d7a5e8140b4829612acd4b849355e49c4f6c43cb135f38dd96bdca4ad7541d56d521460d9c20ae5c2d7aa0c343c020f765f5a706681ad9979b7d61675d3d1e17bdeeeb41cfb53b6283bf199926457af67f6a558c056f45b338ae2896c11b30fbe07e84243514bf83f5898723bf25e06bfbcf1e90a7490163096f8cb4635aeb7705b64f982ba1aed027472dcf7dde83d6ee6a18802f088ffe89757479ee8afca903571a54120d0afdd6f0dbe32e3e3ba9d71270bee408db4137cbb9550e6e4fde594d5c6bced2d1440108c3e22b4179e32e5b6c3026d35cdfba40727a4974c566a7f9fd45b4ece002747bc243951afc599b9bfb66ca0b5fc5ac31c1f1c528507c6d147a87c21aa03297c1d8d808467befae85ff249f083634853a5496e8f41be1ee511e8f84a96be1443d6043514de91a1dcabdb5c9c20bc90eb483ebab5a9131d72a48ae1d0f14262b45aad58f7ed6bc2e83baecf402d6b78b2754b9815f0e6cc8ed2e725b9b8e4eb5b291a0784099a4499414b175fdcb132a88319c1b1a848ab09c1fa21893acc78c7f5bd1515f18818de8e6475047e34c58f75298a7598700a48c5ed5f25bde4c572b17d2b456d53458fc31ea7dcc43dec4d9607d12c9e6b7571e49038989a93a1eb0a458e61d2df8ae4ab709663e33f1b00a2039ee0ec9eb023bd4300a8d7e9451baf1a745b49d0fac1c54f9549ee40395815668b158e45f73bbbb31ba15204ada209bb46ee69e97b04bd5e8d0c6c446556360a91acf060776172ce02ae5ca5217a410b43deb99be33a27fe9f4713507485b75b8ab2615e189e3f8cdd0b8d84022a6e919453300b3a03c3051af216c0f453c129a8a86e44d12b03b50507d808c45b9916d5364511ffcf3be14346afc8e4291d5d81283238cbff712820d74e46d85365a6f5386c072e99e5b48750029e3c2e328d878fcf9d1f684298a1b0b1e792e14ad62de4dd47c4c6a2887d2ce52fc7ed444abc6737f979b357a4cb405ab68eeae704ae276560b59c43ba4eef49f1d400fd7b731d5c27c4536f4b5e6b9997b4627ec3ddc6bb29e5e13a11f5d008a10fb72848830dcd1a5bb72c6253b94f27da4f53f530e2c93902f8e00f5b7f09084a03ec4e906f85fffa4ac4025d065d9267eefc896d34e26a1625a649aeffe74b5080ba32a84a33ca1e8f50a94dfbbc31c1e23cc17e2015041bdc3582893829d7f41e995b034ef31407e1de59740052851bc607e625d5a58adf2fc3f782766fd14032467331ee5e0e0ecc43805cde2406b3c6732bd93afcf1c885720064f3fe016a3f6910b2e50b8826232e5ccd901b8a17c045fdeca537365de0dc79fdbb77d7ae46fde47bd706494d38760a9838b054252dd963a0f76f7c1e17e94595eba977005287c648b3f53d6c0a9e011550c4076fba3798f40ddfb330f5f00c0dd1405f28cf7352a2a94db2c5907ab22944bbb71312cd5dc73a86da08bdc6547c5e05d45f326a7e2d21ff9e23063d7b7df4e654a76d0fea94b69734e8b681ab7bcaf5d03bcad1e78aaa67de67060f1f6b712318dd5a6458a4fb7bbc2e34cae11a6054ba37ca6283a68f656517f7a62a43c9d881833d5302eee36630bc59b2ec5570339afaea77b239ec2a36d3833b2c8e2cc95c3bce5e6b434362981f77e5acf502e2551a9b5c53885d6c97f9f1cbc3ce720051066d6ec24102ca5413758ac10e0a6e8a92a61253e61fe07738565b003e73414a787eda283e3b0cab16e81fd666e7cf4fe6b2849690ebf0ff0370a55a98a68a59936c82c186cf3b2b523033641af8f25b3ff317b374f5c36e9a15ef981612dba9b1f5ea7fffa6548cab55fa72f9dd3b3925d713ccb993d6cb4075d57953c8f34753f1c43e7d86abbfecd0ca497b27faa2f976283cd386a3fdfa641a090a18890c5755469c1f2f01619ff75d47dc26ed59fd7ed29304f8c34abbffc0eaddc7073a8710847f1ec69289fd7ac3712758fdebb0db464bd4c83328c9d9cfb33d89591958f7f589d21809cd6772da056c499a43b683f84e80d225916a7a5deb912f349eef5ae10443cf2f6c0032f144c9a542140ff26d080f77251d3cf143bd762511b89e7b4790b751743d99f00cc7d7a14970419b8e3acf4f176c1ada41b23387c2b7e87ae874627c0c7cb487b77285b2c1c8e93f6379eda117f6f63d0104189279a69807815cb58596f0c28701a5719c2df1ff824833212f8a9635ccc686f5c78835ab31701cdae4e5b7e689edb30a53ff35048e1ac0c43e82bae49ce30747b9c648f968795482ded0025e5dbc707abd477a3817a6bcc49ddecc0836a8d74aa412a42042379ffe77d66bdd9500f694448c42ca2b920141daecb50e1a027fa2f92c61bd3a9329f08de5774a9787411937e9217b31a1fed5ddbc39eb910e730cc94284d0866f43b0c2ec95643eca4a62510c2c5e09527354f21d22508412aea4c38675f474e307641709a894c6b379a0e5c44ce5a26ed022fc53126c4f1a7b538c8e533415b92a9259250b3c5f1c74eed0607cada3797a928af95db01e4c350238d288c225bf27d1261f412de7750820c63d4c9748af7591955df303878d012639beec0f30f73bc5de8b230e6df00d2cf0f9b021671051a5e89b742b29217a32f1bddb0225c2cb1aa8fcbe4e46f9182b7cc9c7eae4dbecf8bc23404b49b58dd9511e66148042262c157d3a4c881236439558eabdb138b88a23996f61fd3a5b7687f8c5f5c0e906437b731284d77c0751fb6f202e7004c7830030352ca1b64f160e7fb2191128d0a5fdf717a851c61fb44b2d3a52e593cd9a2ecdbf504c5fd7aa25ce8e6c26fe94fa0d8797e57df556c2aa4890501eca3c5ff6e480c8328f8214d6be4db5956bc30c2c8f3362f6a3ba18a08bdd854cd50bc683f0b7d91f96654ab769ec24f2a8e82394281a7d2199d94a88f3b9fc7fbae8b76e08b720a2eaad525a45a2277b0b9e7375703d262e5b1c8125eb8b896bfcc4f1c2448f9f63c3064a06ca4ad4c595fa15454706193c827923c3b17942f316d8fddb891aa3ef59937a84d56c44f06ed82c64bc6f8cd15b611817f7881b1331e3ac6a3377c32652c54321d5e76c2278034a5adee977b4449f9b1dd5fc605cefb182079394699f1987b314e518e26a300ca14b7f4f1756d68571494e3e3a9cff96d4c7bc93fcc808498aa3213cbc7a4627304dab5530907b097f9029d773d4d8843f8ba36b6253bf4b2e3c5d0adbd6b071b6f0f569ec15826ecb94135d5b835d7b22696232147a9bce7011550198ae79e2cdc8ff8448bebe17ca3966dd927e5c5838e06916e9f559318b038c4fbfe28f46004cec92b5dbd5a2ae6b7c36210ae9f043dbe74625afb81dd3ad815e7c5f2a13bed9d84be4e77e0e04aa196e175cb24f81c7c55e56fd30e898ba28a1aa526f288116ece23face02f78bcf1bf1787d825f4329f2ad65684c90133311cbaba68acc2e9aaebf98e1136cc9ad6a27dbba6ef6e6360feb71deef76fe26bc7c19149a7da98f2ab805790f3aee0c499e62c13b543d1f39c0e1c5a8eaeb83e2da6c46efd436ec42c85fab440a00f39e96ff979d75d0fab18fbfca09515d62b3303e9ad2a08d49f94df70596480ec0d7c5d9c7af13238ca4259795dc5afb5b98dd1507da14c203a10640bebbb9a519500a823c73837f22508f5155304d295ac443cab8e882be80781753d85659879d87803000b1d4ee7402c35d6c835117c9977e848b7d87770bc8a4613afffd05b681126c544a55ece82be3b4e2a0aef66efce3926715dd7ef5df2048c827da51844682a50816c8e71d17c3aa2b71418f38c6ba76c0296a17941db60dd10c87dbd7df1ad155c444e26a804b9534a221cf332762b570be373ef9eed0cd8dbc7ef187d8978c3d2d23a4c3289f2081edd1788ff33cbbf90d6104f4867d2dc4be3846f2f3fb2f73c9a84959ea208a7026a90957a3e210a2fe9aab7f59cf4f58a41f5745ba8c9278502e912b082aaf485fdb575248fa99d5b32ef59c9d1e4c239be170bb0888fa0f18be0aa2561497b1ea49b984ffb024bb0a84729340315623e295719e891d04cf9438e26a06f21edda3db36ee22642e9dca5369e627d53c8a0c1bb8e84217edfb1702a9a063536c30a13dca06015194c775350a6e6e53ac0435077eac595d36be37636f87d08fe7abb05a8e2fb4bc3e71ed8f5a4f7b66240219be6cda8458df94feda66db4bdcf000bd84b427debedb415d65085d67cea84ca6cbc59c8b955a190980e644f6d3e372d48247a257dada8a232a0a03394663a53148ff3ac8a913592e7c112e7bf4a2f9ccb908ca1bf4c406ddfba382a6cbc4d8f67b1cb78658fb4da36681e31a523e6faabd8dab18c1820491ca7bfacb4b805c68184609c7b530cb079bfe7d64e31f63f8c80a037b248934a7e712031a074f92967d211a94753cb75075331e16d14bf60b918adda3b9b9a6447863dda3e22adf7efca208b8f16bec5d497e990d167bcfd38fb1a6c19ab68f84069f7f8b28e264721e236188c53c7aa325787e53b3566cf3965224ca876a0dc348635d293db585852c340dee370925b1d2e89f16fc50933b7c8f6a28cf031aaa1b74dc2f6d8979b37bf51febf3cc184e7154e8e58270019b9c55b2e3f3479844a2208df9d93b2d0849c96e1f345c4817f98d391062b68c864c15c3b910fc633f24c039fb3f008ce0919fa22fa3dfce8bc1000c43ce40763fa47ea0163a9afe200f9e94ed3cbb7331faf5b5a93ef0a741250ce6de97271318b1838388216e96175988b2385f73edc205deaf4a1c0b16e2ea55f5706dda09779ba3f574e0347beda04ca870c0e6ea0cfebd0784465185771a7a30e5082f8607b25e35a0030bc48dd88ff69b54bc9185bb3f7e740e5aa62218859cebb541d738314c2057fe098e400b1647cca6dbda25fca1f37e1064d4081176132a5d549e8b5984381d60dcda25f3fa76b4425a8f03f8da041d81282a957a3de39538b706f4f744f0ac7295f0ff01211e0a911033329f552f0d2af0143248bca69d4ffb35d05e291480e5a73c47274917d25dfbb4cf5d71e8f1ab4bdaa56d61cd26e8863229d771a9e2479bc644efc23e483e039b3b1d4fe63acb8f949e2e4860aec06438b5bf44594fc7ce9e3656b84a9d733851effc74c852f4eac471d551a873b3e546bef86f0273fb736a0f70d2e982392c3bbad9b5d8122c37b8955f65af26bdf737d193bc4c55f417e5ea6608960e6ece2ef3d5cc5b17f012b8b726ed174c888d2af178af3f2762ec5a16c25fab7757e0d730cd78a247e01729ab7e62bad5d84366614d815cc3f396ee5f1d8f490c478353c67582216210f795c39025752934a86eddba74a2ac54a52bebb040cb82c227533cf9d983cd4e2c58d79a9f11f3950f51b2a19b30541561e7eba11e6141f2605e00bde883e1c002372c8fcaced4533514bfbe37895138d25bec546ac83413742016665152075a4372c91808b51d796249f8d10b47800a4aeb50c7f563dddcb715b1092bc2615425a24bff91b721881ad13ce9ab6f77420b1e1d027fe48a2f7f9fd475031946fcf8c905172050b7efa00172c133bd1e76739d5087bec28b1c0a8e80b7dae089f36756b2e2fc6e7e5a07f5b3b1eea5cce616fbf982ee867965b93c197e30c0643202b79b0429b41de6c0aec8b51c35c2c0998a03ae043b82dbfc561856dec9a6b45c728509d9aaefefb12e1a7b27a76235c299adcbd0fb549dc7784a5890a38d70e5d0b3d9873bf55c00949e3ed9186a4739bd80f9775d5dc6c9ce9dd6d801ceab547cfb4b2dd87eed9000828116866d2fb15037486829aa5bd92292c3e6dc222b7ca3227eef62488b188fc85d01477045612557a7928d6b4ba554c47da27b775fa3426e867fa5e6b628ba06039613203f48a60dd21793a398b293a042bbe33d1303c2622883dd16926a5f33c42eb82bcba93185867a357c964f5b2e8642feb347ab48e6368a6dc62d4f8d3ade6daa6acb357c9414da8ad46572e8b865b65659a1fa9c47bf7891100813c86eccd17f1413f4cef256bed25ec7980be6fd2372fcdfa74d539cfd145c9893c81cb25f7c0b1f80627a60360a9e6c57c100579f348a84b30b7fa6a8585585e2720943ab4f7a2a8a0766ed4a403f823f3d136cf12ff0092ac04779e022a8c8d7432a4d5deff2c674e4012d039f0b0a8b59d4f3c7d5f888765c69267f0152ed8b91c6d38997f0d03f4eadf1453b49e3ef799eaddde7f9f8c92ca7c2833d6057972b1d06b0f5e616c3a8bfbfa4a554ddc785db4c69a85333aeb34deb0a7261ec4ebce644f8fd0d9f6c54fd3a5951bbcdeb8cdf7f6c8cd6b31b13e74c7c80fa640f6e3b7b0897996e8cf7701018b5a98b37adf1a24094606e04eb196f49790c2742b839c784646b6d09a3081d2bc68c7410cba6bbba17abd6e57f0ebe0b178c533f1752461cfa80444e327d28f30e44a8ef049542884953d8a937895c2b618fb0d3dfb39c70db201ae51c02344c77311ea64379df7e458ded78573c0aaa114f7a2646cf7cae33e607cf9dbe87cce92a958262b67935b4c2358317a320488f3d926365e05875c85690fdc7b1dc8b98a0bee45ae6a6adb76aa31d2eec74925f722d5141d5921faedc8b15aba638b6ff408c7bfd846ba0352c0873ad35474a867991ec921a45b822c9ff27711f063c07c80b4ae68738632b5e787142b01841daf8f9b3a4647e7f65449f6dd2dc4a8b2a45acb5989b1a945bdf8faa766a39cc6e1bbca01d99b33ad3d7d54a6fc8368712fe966d3fb8c8a4ceb3dce0d505f431dfb9de87648fef375020e5337a8e4b2a6f8314d2b5a42eb26296a1429415bbde5facf900a7d69259691e7f46381d7d09f63a5dba1dc3d716eb0fe24c962a956a88e5fc085d98ebb0e34c3a3728dbe869ca33807d7d72a2a145c1ec4aea12259a1e51a0b8289efa332c613c7fd141b89ea711ac733314383d73a471657acb0552829eb02c9456938f9d5024595e252bae68871394ae5ec5dfa08b398ee7e46fd609a65398aa8e1bde9bf3ec7db23a9a0a23ee62eb911652d144aaaa6fc9b84cb675b5c0c20dcff51c7eab7f8f363d47eeee770efaa7c5a090da68cf8201b1e14705a1c7e72e65ffc19b974cc9aa4877b3f3627887bdc0e72e082b7cec7e423b0e87c71a2b119e0292e9b31cc4bf5d25d4508674b64a6604d74d544ce6b4b301803b0778f575da326067791dc4fbafd972b569c08e283da54cb20239b6ba37c8a0e4dce3ccaadec9f7cdd52d53b6de4bf630ac12cee21cdc4318d3ae7d1e45981f293b946171ed137b68de750661e2853e6be1aa8b3e18b4d5bc85d34e72f839ad89d11d596e5562413edd2b9e8b458935cc63005f02f929bf8ee36c7cfad929f1a45690cc46e2e1850c46adc879cb9b78410df348dfd0d93c68bc926fa7bf8ecf872954325372f2c0544ba241207279cf756cd8163af801302621e8d2bff16a0c36b1049306c71df91f94ea5be0c29115dc5972bb4331fd807d665d17e66382d832384e97b4f28580110f73a59c8329d272aba6b5441","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
