<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a4063eeab96501dcc66edb8d767bbdd6ef95101089bd367fddbe31447bd5b6c50d97f9477c637754e48256f93e091e6abb40006af4df8f39a80a5042829c3876a5f8600eb2b46046314cc2550c0cff1dd56c148c31ba2d2b7216c72d2f683e4862c44471374531f0953f67329741f0927a2fad3ff6e9aefc53bef5b4373e042d6dcbacd944ff17ab8ab4f87cd116c262b6df4e67f479e0e1808b2f12bccef1ec85217bc4866dbb7b5d15a0cd9439b7880e2e0746d4658308680d03a66f115c20848f0067beaed439c009272640adc5915f990fbbe3e99b03981c2ef66b2c34caad443c995d4e317a721368af3f627d3c273f75dcbbf580f9cd67d1893a24b55debeb50bdb0c9ac7dc1fbf14829f0281b67d7241331fef09f90aaad16f104729786f56004336250fd935e4c564930196570f72dfa7baa0aa33643db39fda213675ed281bf4939bbf06fdb0d90687c91a2701e16b56115060e87c07c48ef26f16cf78614bbd30892114a0bdb048d22c0a170c6976080fb77b3880600108bcf9ed67adc0ff109614c01a1c82cc5229a1d1e29f3aa64b69cdc583b1465bbf1924b62594657f7c03aa4699cdc22a9d398dd347e92edeca2368aced5902c09fc87377b0974bb793d0b59f5098bb12f8aa407e997654705dcb186f4e029d9636ca0503d404345d6669700e2de95ce056457e2bf614769d7ed638eeba454ea832ce3f089fcf16bec377467ab51d125440b57d226e797889aadfa16ecf82f61e1d69729849d0bc34b3f5c00ba8e4e2758a5d0aa199f1696f0bf937f387b2873746001952176eea6fc0a60d82b706f41058f4da32fee4190d9ce71066c68114c6128d8417272bd398f0b50375a86090ea5b3f963a8078566e036db597456e0718372533ee695409f77ccfd186600e73a9792dfb283a0a48cd9c39a3aefa3bdb4bcf7a1c0cc14bdddbec5ffcd9408825dc2d2dc6ae75f189d6cf67985b470473149b1029a61c039ff82e23421a3b2c9779f48f8cc7be844ae9c1f4d6192dfe9fff063944a3afa6d77d194106c7fae89c70d62ef2c6223a04c599b1ddcd1856c5313897b578ebbb1252b71c9fd74a348cb5615522ed4a138553448155b53ad1ec9a409aa756efff975797e3f177646f361623959914d3bb88160c8d3d9a1d7c4510eedd5606d7e0f17cb5ce38ccf371a11703cef7f9faec21a0084f933c5f75fc08e5588b54aa9600bed0e6d16a4df2eb11fe662b89fcf55afdb4ed9bb927094384ed2fd36ddcf35956dfa1f4ae2a1e94c71067910f5299ca633b2c3eebdfc79f6682eec85b8cef6a87252f680496ac6d129f38b04ab2285eaaf50e012d48ed9882cc7b56302cba91133f5ca9faa54419d4704cbbb1a551286092b4974943b0c500def50e9fb22ee9d304f20d8d2b600e6bd6028a302506f09ef86888da178138af1d66aee4a1ade86611c3694f96a018120b05c5582af2ada2a598d28f126de7129c2ec3f638932262084f522f0bb647385d28d63e604661761a6a974ae995bb603b7e347635c47c949056fdc7302432853866e671c8650564e4068382906c930db408184cb8407e68514c57f2b0e9aed1bf2db91a7f93a5435660fe40459f9549191244db6a94a1b33bf0e9c67d50274ebe14e313825efdfaa5615de656bb13581dea307de9649e1661b7f1cc24caf8c4217ad58e48502c2b56d28ab4b7dc25a137bd5c05dc848f2857184775036433a8b69a3a41625b8bbda52314c2e6d1fc25e5297556f5341d10df00fddb9a54e5a592d616f1021643cbf34ecb7a227bf2069ebf8d2a25ad9f93b8ff55611f948570827ab73d4be3a20ef7a950b86159ee1eb1a9ae57fbd45725a30c334b09d6b1b075490e112c4fa76ad148dd68a10aafab0704748ac5c5920fd7a07cf51898125f6c7158aa2c3b46a1b8c2401c254ab9683ff91af733eb95be73f7ec41ef18974126115242b933a15c05cb24f2e31d1770de7795e64195a9c6979dbb640d1bfad55a893c30628ee4cace2539316863e5a4ece288f353d6631d6e0f67608bb2bda99316ba3333f956fa46a70d5026d52c9c933add51c02aa08074f111fe59ff0ef107265ffd8f335dad0133d4eb3eb964e9a36688d2e21d50c8489b6a72549161cb37d8d89c989ac53bcd21a9fb4f062c240b660f99660cdb7c4e31007021d5882c921dd93fa131b75343c58a90d5840486d5a2573c4d7e66da710eedf6b9aebb91481e4b45c361807419d1c53ce2a10994de64e6eceed48a23b761bc67e256cc42f874bb6abff62f16bacd5a86ad407389733f44ffc26608011642ac2646208f3b28d06b7b5706041504f8359770d19a8bb691a971659a00367a7dc6f36999e5a51402904aeffcd68958b0ce73dc35855d08551afbdb9b800f46f115ec7fea226370d3ae086dc4a6543776f919305f738c85c7ee3850222e9c223607cbd3210924b4b91c83f032dea0afe4686ce74f8c66f9559fe1f3c6e9df52dd7c3477245ddcc4a388b24646e92535d0b18baaa6e2255bf42689a12c408526a7582ff33ff1f697865ce55de93c19864be21885aa49456c726cc894ef434b514ece4c96429fc61582e3ced3f38a618c4fc1407542d4a75b2b4f182a038847b3c8347fa00562ad10f2af6f317681f34d3daf523a0aaa86cc9d0dd5d271b2f4181cafc481cc67acb627063b696d5a7753c73a1761057fd98c52ad33f054f91562815237ff9960af9b8b2422ccecb07404d423cd5a245f8b873eb7ec4305c3b7dbdce23fcb3233f19f6b490f82b274fba23c0127b22c932daec52acfdf51eabb5917b196419d384be05426d24ff58d5c31d8d70b960834a746373b9f9bf43f37d31de3a886ebdbb697b8f1edfafd7fead1afd453d4bc8f243d0fd351980507a0d48474804eb026f1108f06498a8ae46e7b961ad825927630091579fe9d9a84660c3c4b2af0aeaae7dd3b083ec5cc3e22cd8e25fbe34f497590e7826ec5ec0d56faeb2ce3592fe82423cabf811279c00a61b1f43e7631de9296f1e9a9bbbbd3efb77f0fe3c5d6f4765b46b3a24c22efd58d937764ca5e3093a4fd0fc3802a551c367cef650bf46c43815eafd1ab04007f97e0ea26060357ba950899090f59bdbbb04f6aef00f7bc46a322c8b9ab60e46c31167d2d26c70971bb16665952bcc2727ca4d49afcd2369a068e43bd7c8d2d5b499e27ac119e9f7d7ebfc8766b1442080eedbc0028ac08bbe7f6574c2aed2298125735907351a7a5cadcc4048bc10d255f00a1970809c27cda9c32d267aa9effa022063558d42a5e805b5099ba82e207b2394b1543783b631010cedfd203f74f548778b634459ade41552a1b14b744ac24297d902282ee1d1b128bfe122daa4386da0766f909b304354d8c36657377398092b0a7a3237605a670939fb8284f0d5fd737714d9ea6118a042bbd9682500a192249545431ddfff488d705328b17743d684d1f4e164ea19b79f7d9133991ea826a950f8511c3d35f265d55dd1de928c3c4e4614d504f4c42623f9b33061a052e8b918966df5cb536b14bcdecf6776b18098cbf48aa1a666f56d7b8d4fd98065dbdad451ee61a653b118260ab65091161dc3d1e8fb0dc6ef00c5142cd9fcfcac57110569ecf43a5cc243c743fbe719d6eaa8c682b6f295b8cf5b7652f63d7c99a3ce4fb1a3f30eff600f4b5cb71fd6fa8599df784b728ff68b005d7cea49b7ba86cafa34d93d82e99a5f689590005a14fa2c00af5f50723c7adb8fa64523f4697b4fa9046d8e4ae96f9c67079d942f4b5fc089bcc5283c3a1dcf05b8f5c1de631898b2af31683b6037c9e0c27c42a69a86edba1aad266b4551154f7a98398ae3cf2f860562b9cd3adb7243db3e872ac8b341edf173c78423e26c9b39a2dfc387830c23b231f9cbc3bfe1b4d5ed8b9436f0ed509d9e425c93b8dc545cb44efd203858b3582835e33e3ed557a85d2bd90f452b6a416647faa368a17c70244b3ab779cca9990d60213152cc95482a6a18b4f638e81fbfa37a4064e1e1b65f7c0e7c1db7dcda65ad65862b4e01bc20398597e05786df01697a556562d8cbe190bc175f582569a8f12e188827ab19dd3d5a7521617f7e0ba445e5863fe4f9ecbc866e9f27729ddfa57998551a8f0e0e4602e9fba3120e53d11cc77057f82f041c578e272248e6141a90e0b3c37b43703285ff47a8d44346ef6176f4435bf53c60788a4f875424b9193746c249072332e7ecd295d343322e09fa5b5d79891ead60485ef2fad4e381bcbee079eea5a813317f467698046071f3e87628fd768b28ab44d391f7b13f0af1421cdcd649aae3b616701ac56debaf74bb8f8d8ce0e45a585206afef4cacdd7086234dd18b3970be421b42047c40bf7bf216458700a02ea03ce88e3cced684023fc98e207a887fb8c38366a56954501af660f2fe9d55adfeb769ad50ac4a1603bf0c0f6e77bfecfd56be3362760c547a30b9428e598a50c1b15b1e2fb0f914bed3c84d8439dada11a7353f6687ea21e8c6a4de3dda2761ab4ea1459b1f36b0e893b01561357422a92cd187145929f059d1c95d4f32c92ae1b2e73a79521717dccf5bc5b6320b09f55b30a3275267e0d2f0c8f10084fbc0ddb07b9ab0c8a8dfa1f013211696762e3e247c08af14cf9a1b2e37321bfb0a20c8727e1b1b6a8b2869d2a6c0bb93fe100e40708e13c1e85b1db028805873a59d7cae8d4c4a880290a7f8eb2a62fba6f88661c79a68e7db9e7682101977de278cc73cd3cc5562a958dccb4acfc8ed507a3ac67cb169d74eb076de5c5050e70d97896494f7e4626c59c67be82af32ff5111748f31e513d1995279cbba558ebe41c7ea7910ff75b2dd11b6e89d33a6c91e3bf94e21be75a699c86926c5ef3481851d77e9e1f30edcb777b8516d771e3ebd78a3bf11ce05f82bdb5003bdfa9ec677052f5ae1f855ea78199118efb04de209747f7554516d1faab690431459c40e4924d9bef3fd461011e6e7981eb7216e90acbe7c853d38bfcf4835113e144978c18f14e823c9022f43cd85f050884e6e774ee9f70acd414bc7bd0f021dc6ef06446577eaaa6286d2ac7440d2976c26a7661a37a7fc65308df97c2ae10d419382711c5d21935e51f7285ef6e165dba7a129db3b5bac8347888aab1acdc198718b70dc594906e3d9313a23ce4df8a05fad56b112934a864b000b2994e77c6b7e7205204a05518c398066c0f61078aa839f2db9f2548e9bc8859fb942e10d7eb258c9f3b68b880969b28d884faaed1acd6746bba31c0f0b6c5d4253ce96235423b74f6caa3bdef5f07adfe2173714ac62eee9baabb91955f348cada029def07a61e7ad1b4b12f33c0ac4627ee2ec2c8cbb8bc62a9406e779f0cd3223aca1a8c36c27d747f892979180ab56db25e56bec9e083b7886e9f611122eaf5a31bfada42ab970c5d2643770b5dbf1a4b0bc6dd1aebab2c964ee20171f941259a25fc683da94e7e5b2f44a9b35343b05ff5b75c099f2b978926f7b019636e85dcf1eda79eb00b1311c6d0cbde3139fc13bddc8affd06072598fb25acdfbd235debd41123539ae89969b9b23ed0ecddf14070a454da2a37b1ef10be33ed7690729641e0b8cfcb91696ceeb59a9a5586252d4734883d5019f8a633012a11e07e06ca229ad77154f07cba9816ce01b7080ef3f3ef6f9e7e6985cb50a379e313c26184ed7f774a491030a2fe281342a1518816267e6d0f90ddefd7b77e794f8221a4f17310532d973e2c6cd6efccd62e88a452710d1fe64352a066d93a8a9f5d91d3005eab8148f1718101b3f1d745418dded37e7f0fd6177a29ca5ee77af9b42a04fdcc6d6fbad3a27e88004a65c28b294f4546a8ebffdbd6290d3198165e664171fb25c599a5710f21ab469f0dc4ce54c39b964a6e18d9941a20a596eb34439e1f4478629f7edbdbc58333f6601672ed6a26917bce79c1c357725013de0f19fa50f05f198ecf0d6a515f4c6c1c696952cae47456aea6622c655bd9b23f657379d4d827a5c951c5568a52c3ffd37e52b0d31346f1822af606e366942d9c26bc790542d9de1321bc27e2b44bb93ebf726a3e67837ec3d64fe8ae9c3104bd9f9ad5831948f58ca82095a5ce7e1a9dbb8a0bf1156c8208cb08eca4c70ddda278c1db926428279deabcff81e7add755bae5d4ec4db3d6755ff8714fda5f61cc31563f284441719ad5678401301b9bd0288d4d31e6c807979d4b52a37313b75f69ca815bd272303ba3e74b02e1ca00a31c6ea6fda193969f3932b46b7a20e40927794673da60a4d7490a1a9b0105bf6827eb46ef86401c0310a1b934b2d0dbf9a606dddf4511b3a322312f02af328892ac15e053fa7e4e329d2b8da13bd51793cdd2891b7df58bd464ed1d8e99be1c15507fe79379264a8d78b029a6d827be867c1a83689a74bb59c1d14aed8df3c08e69bea29c6df25087b203b5b7c5e807af0b678b08815542e6adf5eae4f4f24c0fcffdaa37d7f9f826a0a2c605c8c5c0200a62866eaaffe27808ef45a807d794311d609d2b2d967a5ef7a7d0e3d91693f044cddf8ea8286dc869b05da0c61739474ff046f3855033bd0b80117c2ac7bffd354db74e213e4fcd2be08dcd98035e8c957f7cf4d7d598e852a00da1ac4e5dcbc7acc0fdeebd17764ada3ec55602ecec9df602e9c87da757dd5c913d5eafb6333c328de2a0dc08b1f03d77504ece10be57d19bdacf550e93a78ffb28a47aef66ec22b4dbd0dcc0da9b06c3d720ebd8e80e2d30e8b85ecfe41ea01f5e4ea2586ee06d49c3436ba4ddc041c23debbfe8282f06109bbdbd05ef09c397760514f3fdbefa1a397bf9bcaae94c4f2bc1a7c36b58d836962e29bbcc10290cd806d1da682be59bb8cbba32c8056a4e4350e4e591fdbc4c0a4bedae9b4b1ae45896ddf51b0adaee29303b10d75470fc465c630cc3e195b27b7cf74b531708942eaf6b6053e4035829d49947830455dabd21260453ed0ad0073959ed4c3188b3ef369b579437901d60503a14d334bef64c426e4b0fcb29b0c89791272f92114a1b41afcd01ec58bdf7f335d847faaaf1a549bb48416416e07e22c706be692f235e23c3013d60fd33c45fb10f46075978f6e26b01ef226d4172714a84f18600e51485c29f3718cee7607b335bc188f89928ab476e0002c379b94770c7cbc213ba420418a31d22b25fe741a10edc9867431695c6c9c6c75e222d1431ba93511d46cffd204bfc04cf5eecb267155aa75994d1d16615266635a25375517248399a7d6fcc81fb071edf5fed4196e3d1237032922442be46eb8c528f73bc2dd3ad54ba91d0372121a76c9cdf18bf0adab11980af1750773eb271b2b167084e80aad8ef0f49a49a38abf890369d2d19741879b2782252fc0cfe4900fc15be4864e175b3aa3e211850879d4c5ca59e6d2857aeb6d9aa4aa9440a725a9510f5116933b1461dbc66dc1c6a16d6f1d83b85e39cee9f4b54f16b64e6cab4d93bae1c7c8f82a2f070946ad691e6a86cd456d47e132eddd6606d4c480ad4b2faf60bf64446ce28ee6f6d15a7c380fa7f89c04ededc4f6891e40843e34395a41a6e4104e5c87ae56d22e72c231b708173995c6ad16469711f228fbc9009269bbe0a142e1287cd0bdc0e58e23be056d14e3606227ce5ea23ddb40afd5137275816f6da06f7ce5e41d7ec2013d330cc5028c59f98b486e63c180aabfafae06f579b6a0ed8842f431bd2310c77fcbb1af240d15a445346438bbd3b27005a96c50b49ecab593341b307e1484f15835705146c3f4dfc6a0db80d131d9a62800cdd99599a10367f13399e978c3d0cbe1536329a3382619a78497232ac4ce6e01cdbbeb315ff78ea4bae29cede15a1f1f0545016c79b4b32b6d677cd0f771e1039d6357b371638500af6db3f360ac50e1e34b396aae52d5283605e797d5e6b429eca71e5bdc596bcad1bcb8178d4e80e3c9228d103e656454760ca905f4fa2a640250ad0eace227aa09fdc997f628a4f310459253d0042a37c8f2d86633037a5fc894fdb62c24e8a95f8d5c39b1be93a1baab0f019dd68cebf0eefbb1e5b7beecf4715f94b5d8950ef93e9993d103e2d6202ecc6486d5976e56f6880aaa161c839fbf7616270d21d8df4c527214ea8ad83a08658db6394e1f4e8cbfddf2aeeccf816b7b0640aa37e6f615c5d03ecab0dcd81d498313d485b3ffbee431849b5f18d1aa8656e6ccc2e33d273f12807f98573d6b8efa381905ccaf9e063082946b5e2bb5de0c1affc3d91df87a3202f84976f404b81093e8c383f817b32e24262069f68020523597642ba371a97d9b48b55b0b2a4339708770f945b2332ab996d38a0e5090e58c26fc1d077d08e82d1418a978acfc9c6498e3875c479b97bc11e558fe5d108cfafb3678f4c9d49206a0f68e598966c479240895884831694581c14ee8fc501ae2bbf336f53c13903f59f00fa4e3e734a87262ca92db8e1debccba179c7ffb69d5ceb09b181c17068f32b0e7fd1bb77610303b1c77f0b729cd83bd0f2bff331fa32675abec9423c5c249efcc23d2b177dcdab6f1c0fce90b2cae293dd0cf3c3a1d143b35e890047293477556cc280255fa8f9b3025e6be8211ee8fedf7c523cf45bd5cfc8c970db2b9c12a9ca74af86c363b8344e23d274af5ec36a3d418b7346c920d8980f4c2c57f06a3c27ef44e00d3393cbf8c6c32e142b244ebc111fe72c483bacf5bd7f11602d5683ce3c33edaf33071bfeaa8f0eccd364b2156b5d1cf2a5eda6b6482e408ab46492087480941592069373ed4de8a3d7cefafc813f3025f61f2f3df81e6827c91dcfb14d90042f6d3bf55337069b03ca4bfc4b6acf4bb1938efb8a5c6a4c7e321cc8109a590a76fb4178fa6db4fc539c74bb7e0a8f8a5453907096fdf3e2e1fdfd03a2d107002f78087835ecd616e928fdd8d96c5a12e6663868ecdfa48e0bd253fdfe80e79c64178611f70b39f997d45005e39801883ffff158bb1312c9a38aaba5e0a670cb134499d4270e98c5575cf7fe0b9af4ad312d75d8ab373e3700059d5db5f59da1ddead767c930a9ae111c09ec24b214cd18dfd71a2f452f78d71cfeaef26ecc1051a5fb7f2ae049417c2cf662f1e12aa6c1cb2aa4462952b347b116a61f6fc57ce0cfda8553f9c2dd8c999dfdd2d90569e9558a13293e122939916a46ea9f8c981031fe3e7207112eb17658fd485184b01fb0f179a9284c70898171478b76664470766044f81531efb2a1216ac26c68938274c5ed1cec52890c3a7f504be1c6551e09b018aee9110cd0b42ad29a37d1285a05604d6c817f17a03117270bd6c32d32da85e1ffffd39037e6b9b2456c7278be438df28cdcf1b29459cada9b39573329927afcc7c348c269e5386ebb4038ada4db7980cd7ef56e02b595667db705283876f7d4e60dec142bd8029555ad7bf0833a6d7caa85d38e90405dac8078c4c33ff168b14d0f410f2e91d73ebd0fbf3bf7e13aa58f95d91e667678e697a92a146bcb3aae3c83ac7c393a57bb3329598e84b42f2538f13f0a2c251087e6ab23d39d64eebb63073bb5bc599e9e15f7f86e39714c44bb28d76daa09931a9de07bb4c9c8bb9793ba50267d93be861f8dfb9c248cfa6c75de3d673bd2bdd1f9852f82ea24acb5133635104b9d4cba8a756ec27861d20a16d01dc8dc5b294542d43459db93c9c05d84015765661fa8bfb1529d2d136b8ee528bbc491144eb981d42f51650e2373dc1dfd6fc9d5820ceb903ca972a68be1b0f39d56217b1cac9ba1fc41582e2d64fc644b8bd72d515ac8ec58665a94b8b5c6e7fb542d8b4223ff11d71cde92f9b54cf20cf72fa83d61f22574348bbc5f45694b74b14062bdad15eb9bf00ebb376874f6d00463ac43c8e55e2bd2da90625fc2cbaf5b01b47d1d19c203cff1a42bf8ebf66d649406e56854255bbe9b0507f2d18dad2aeb7c337624d15a5eb0366c7a85ba68c342eafe5648593f52cd2d86aa390710e73e0148a69fc7dabf35ae55c4cafb52373874a3ac1645ea0117f14a666979c4450944089bd58fe43edef4f958f5f63112c0e340e814c8478a192ac296efba0770c444e134b0ec4959e614085a04f1b2163243b139141234828694be198ea1a13ad5ade394f57a465df45e61a7f45bf462c8c4eaaa528cfde9a62771ded7ae5449e9304afe1104953494bb39966f8be10df7b88f4fd2021c3fc00dad90189faa85e341646dd1d2c9235e8ed5ee3c2af114a541b9aeecec53fd9a6e5dd863c5c1ba5307bc87711d2e0cd6c9230b7e4f76262727441be0e317079c41f68c953f5008987937146eb4a966a9865f6617409fbecb6c90f723132c5c7861d2e9ee71c01af660f96960da2528a6b99ee494e64623efa7b07436ba57112b3d0308f853c7f0a1564b803c9e55437ceca8033fbb645d705a52af49a5dc7068ca130252b5ec81eafb6b3310554dfa70e996fe6be3f646035b9e1fbea66ea6ccb79f7120b5c26e2d7a2b0bac02d3ad308e633619c556138ca7f70f55989b1f11e5634af27f61a79e89efd3c06568e1936a82d033335860fb5b479972d521510867af8ad8010881e5231ccda639d82a93d222e566ccfbf9893f0d3d78b3bc21cbc21933ae1bbc768ed9df75096cd3d8049e75d40cee32bd40714fca21195c4e9e6db8da34c03b3ba395816f50a776a0a77ee68b843300a0353957a93d38e853b0c8a2136191184d48125ac8710252feba9fca827451731d6902c393bc35ed570756fc9ac821ad46efc23dc05f2498ce5d4665dc75bcc3b25f8db3c43ddf5f0f319878c91eb3a885dd83197f9873e9c6c673725ef620ffc66bb35b215e1a4a5dc904f1a331c58b1e1692f04b2b83e586d34f690abaa1f33ddcce8d23c294e4d186093320f364288e0cbd2c491d6ee8863caaab6c80b962dc9d6e1c9c6d249d53e323282405988212443dcd97879676a79b73368c4c257074e1bde8e2a9cce4adc43a7e38eb21e8eed16eb95cd1f5d26767095c09997467b9fa8d0bb11ac0785828a4df17b430f9af076b007aee8482ef050de95e7cabe1d31212922d1e2c80fc521691288a52bc6c7c7b2f3007fdc5069ba42d248e51e9594f26f35cf01ccef17540b7c787a34c43282dca5dac14ff58c19d159a00cc9ef2d66e870fc48557ff5c39743a09bf955261d390d93e34dd9cd08c7dc4709a054e58300fec5ed5bb6ae778d6f5cad9a287ccae322915a53a1bc8fe98899c7b1ebd23d51f458ae67de6eb56ead99685c90560412358fb56d273be62eec3f177fd6d7a79c9e4012e75c062fe3f8fdcd17ce8065b790fef796ac0c4422c598bbe03bfc1bb79342337cd43938d03c58d0f7216e4851f0eae96ffe28170ff3682c8c1c8a5caec5e454293e3e8706a0459a6a70bbfdf54f666e24473ab993e1f45f5913ec60a5e485067d8bca84ce480c3bb67e58fc8b86db6268f2a8da6073ccef28e311fdd3cd43a36f71549c011c642b64f0c59d6bfeb09a53a6bc0d4aabf2a80e99f9503bf9613fd974d848eaa961bebf0d4ffff862b99bad20b9075d6e6a3bdeccb84134322d174128c2e4982b7885506ceddf91813582b3ce7fd71cbc71823a9ee2d14f25d1a33654f5beb7206454a8fbb90250167728a2343410684eb96a899ec0e06ab88a439c86e2512bfe3ec0a1b24124cf0ff5e1249ff8f7206da69d3271469d461f920e5a2bfc6f0a148b496e6747d540dd0e00772f028ddd4bc667938d0eb9cd8d577f2e0ba5b2dfcd5071fd23ea8cb9a5f9695953c3b5f4fcc592a26f03a1f06708e15ebc79812c57bdf0c08fb6fe4f4a54082fce2475153dbfc0cbebc42f933c64b18db3003c9bb951538b6fbdc5d863791c890259a5bc6092187597e973a607b2ea775d7a80cd066b894ed71de01f7ecd91058f3eb05a5f9501aecc39f4c96752cb23ff76abd8502d775ad9b044729492f3944d038fd9e28415fb3e100689c8a18b5c2967a4ec9652b9a8896ec0a222a6e219ff15d76e26f5410b64172dcd925c90c04eabb1d0fdf2aad9972eb9f0616f8485181b5ac9a12ec9852124b8daf453aa4d820052ccb51601b2f1abf57a27f945898fe46871ffc632bd5256e5dccae481a926e2b8cc7e6f9c89df0f12f8697b56ac1f2f83717d4730a05e9079431d1c80b4d50a837c3999280afbd2c22d1745de73a565615e824beeac6154e69d113ffcd8ba28101e507c3eafc21017b8686f7973ed01f9d0edfa8db3dd3716dfa45b40c9b8fa1dacff552cd449685cce45a65e512b9ac139b7da592377a6b5c54d2163b13984e63ea0568d37ad22193d061b1d38f6cb1586186460b7fad9f298ebceb8236052377b1a65d23f2267d02684d8e480625ef45e317dc02ad8114406cab129c8938e4e3ad544701f29cf280d43839e620e428b5f1b4613b618a8fe4cdd984ee1064432b0d1da1e5a865ddfa20d3e58391b06cb7bbbe59113855cb9851f7735d61b0bcccabd1ec8975e26579d331df8c1cf93898822cf1442aa68167944503dcd33ed6b014b74354338b5072ece6707149ceb0e3c1e3796b47eb26cbedd21a9e9abb500bbcf2206550a7e600782311b090519204dd426a4b8918f9035977a2ceb56a718287ee1b6547d13e7166dde02ca59f8eab8cd68c3205ddba2cc4bdeb9dbab9dbaedfb98e37ac7bf8b15d9614beab44a49301af99176265aa4bbe2883c58684a3408a7b71bc96305ccb4ad0d0afdabb95d652c40410d3d4eddd9890985a789368ce3aa0a92f0cc6457a4cba10a54afdb985babf0a36609e8136d38756fb6902a8bdb607a7f7dfb5e5de1394ea79044224ccf8412fb2660a90a55379b7d1dddab15eb42c20d0d206f5c78ed2af266f0419d79ff5e5de25ac150a481cef1ae1c18f4fe69e73667b6e068d070038191cf7dc5fe947c4a6244f4033f67fc46206e2bc5df9ef2a151e45d212587b60ff5bbb37280e0522a434f2348358c421654957b6f6da4005e013dce6f52b592da238290652a1ccb8272b676a0d45eb1e43bff4c90508db21fb1185b910217c2429b886e684a3ae2ae81f0bbdc9f2c780fd85b56a10b5e30eeb1f6baaca3d1c884e64678c79066ece5e3e834203455907c00c85c0c51792cb5bdef516afa49fa75aa5b59f8876c2cdef926268adf19d927c0dce92663fab129b25bf74dd77e953a8eb880247c7be04277b643aad73382a5540bf7294720997a63ea6adc8cddb0d0db20c7d8216d1f6b998e2f025e2e5c557fcc4f8dcf4768212e778458fa897399017ab4adcfb7470817220f7ec1b191039d21a3fd63e3963532ac630d67b8b2479d6c170e893638acf2cf60cbfc14f283f8c58b25cbcd23d7adbda280a143e2421c9f10cf312d92f6e9163a3f338605019ff6a02f68c5b2356a76e258b05acce4b9a5096df34563e6596ed637d6dfc9107fc21c075c643abfe75c7fb055d94364195a88fb66591b891fe3f060aa3a059f169dace4f0df20c211b68b1ea1555eca2385ed8b89e0ef06c07b11d8d4a0537f1bc1a57a2f26ee13e11774b87aa92b61186e71b88d0ad16e0b0b114962556404787ab605f76559a7a00f06abf37fd0afa47de746bc2f94d84b783649d6fe984ec9dac1fc1e5460c4c24f8ccec94d0635c46453b8c7d477a7f14857ae69280ee67006d30fcd890b2d5c7f84761cbaa2aa7efff303fc0b3835771f03132640ae920da223bda7d7d0ff7558790b91f2767d41809e4e6035b1d00a612b4d7842ed8620d7ac716040c97dc39ae7a83d060e1caa9ecd7bfb63af79003a6511290273b91da079c9ceca2c8477fa10c3088f2588151266ef416dcb15f7b68a591d02f70ef9573dfbd76d965ddbd2f990b55265c4dcbb128ccafcf0567cb60452154508bf955865e5fb75cbdee40228dcce1f63c72ce65b55244f99a5a597aab27935c8aa4ea037bac30715347bc329f0466157f7d8904e4e3e4320210474352e8a3030f1bc00de89072a8f0b55d2e0db5e982918ec8023929d04f67679d961d19fc1c378f7c8614bcec162a8b8637326220ce8bbe2bf0cfca09e0857ddce2b5d89308df7fe65df1801c3d0e020b4e620e93f0b654eea8a26ea687cbe1614390da66b1754131cc8435fa3def8042b9fc5243b49bf0121b127ed2819bcfc55f8cbc78825b24b1486a23f38c7bd7f3f366e0a8581a98d1dd9a3d0f8f4544c8dcc2b80f9c057b1245de321a05aff1f8fb87dedbc579257059482714d3990e13a21975eb5262db0718062a31ff7ef20fc98dfa07ceeba4dd441891889de5b7932e96b749411995581a7e8a5a2368dcf1807c1ef1404ed09e37a3bbd2eb847c6ac8d3d3648411188b58a7896233fdef71dbcde8b7c31dd3fa9e6cdc78941635d86f06d3622d8a92a11af156d508d07afc931d6ffeaa1a0e91cab0593d405c0d8ab12fb02055546969ec417ed7d16eb3264bfaa70140682c4bab10f3256227c5ee041b5d7ac32e9fcf98108b174effe3bc90139b94d4d302f58918b9f38d65caf4a507b18995683d0fac3d1e5b1ab54bdbe2b95d1bd29ac4d578652dd770a87ce2dc89a519965251a25e0644099ccf80764e3350cb62fe37f5bbc07fcc37c728c5042a4a978343e2aeceba91e5da2d24ec7c887fee3e51ae959e34f0744fa2f9dc836f058519f1e2535fa27e3e6b43b167b4429706f6b8ed07cbc861ebf9ec960ac2e4f22d3d2fa91eb248d7ebfc67d72b9de038b2945be6ace4700aa086bc89a3b80f252605defc84656169aa1533d8c7f64b48abea59f0b0850fb563e003ba8b849dfe1d6254b44104cff9dde05ed011cb21329db8d7eb0ae02be3105633f89378bbb3c57bfb36463c073da0087767c1607d33945aaf0540ff5269ff2f29e58536778b2b804856236870bb5c6a912d9abdd263b8a799962809cd1d7a401a0c28e97c720bb1ffcd57b2a69edcd6cee21f4a09202e3b822981b2d2714626230f340cabc49cc066783e24c768c04b78cc159c7bd880407ded9b35a2507fabf456d56c35913ff7b6ce2c4fa84cea28a2e906dbfd1913b8871a0960229d06e723def13f951710dfc06e1cae0bae886a33c2c1ea81a7cf7ee44db9a080e2dc77ff41f744ac5905b47c608247417c1fab5cec6b7ab5c59f3ceeaba984295ff49623af30fef49e148302b8b4b6cc55ae5a6b74c78e74d7bd395e80444dd13906cddd777b22684d3d87113f2bd1d76796e428f7d75ab5bd4f71cc720d7b9b431a8ca614a9a59a6cd91cb59d057d360da5a1d839bec837b266538a8f97c04a4b19a6d9a5e20e3e75ed8293d47b2167a5e12645fbfa9c4a414ccf28c3413416c59c902f4209e5cae477062a472d6efa6f28674fc055de5ca09edf7218bad2d288ac015c34dafa42e3e98d415ba70541fca75943b986d0df7c3e2eb6c05fce0de0fef7eaaa44de91069c6d0b94b0f82b12b8018cbacdd6fc31447478b7cd0335899f5aad1da757867ce87ae9cf74a0e4ab96a9389fe94952b0384b90ec1073093294996fa4cf2ffe7fe91bcf18b4479442271d44b5aba6ecd6b942d3972e10d3ee42749bf63eb68b1736ad91613985b39da82d2f63a00ee18c1d801e310ca600697129429ff6643c7bbd3fe68d8b0a47e79833562deed9cf435ad4e0dd0945ebbcd6b034d959b4ac2ba9471cdfb46dd3dea6b6c7eee79dfffb20d14c1dbfcadc5b65f667397a9a9b5392e3a4dc7667752885d2fb2c274a0625d9dda4404e4ac9db98097da9f747e96963ccb808bd61ab06ede6b46fb607330b388e5b1c80cdb360cfc5eb1ee0ccfd3b19991e82efbbc283fabea84e576d54ccad51615bbcef0514cf9120755cc02968784cafd31372b8c0b4f92ecd64ca858eeaaef49ac58c775050b3b709487e245c55184d985b77551de6282c99cbab0074f2c980ccba06615f2f96bf8571cb2d350c22642a5cddcfd65c685e1f7a754d3682495ef484df84fe4864ddc161d2b15a990069787902e376975d6f40412310faeb093e852267b48242fc87e1273ad0c860ffc6b24b86a14c03c1e8638af2fb48e5a4c005d5baef2ea90d37cce89f555cdc09f58e590a7f96ab305579071dce5edfba12f7038308b4a12251d3d6e2a74987b86b3d149e406fa560e8fdc52bd66521864ac5e1f3278d33a1946ff1973195d71acb5019d88b40f2a667ba1b76a66ae0c56edd6a36d2338e7f966f82de28287d7ebb8120aab51a75742ae970a95483b3f36b9c5473550774dd9c2652c012acf87607e3e3370bb048b5eef51fa99f3b39dff939795419064e50486c9d73c7e80b6a75af086b53dcf7efa70db9b1418b1d7264ee34c8df128c9681ecfd2fa4c03654e4bfc2cde4e7efbc4f81bf2458daf682c2468e77777d7a077ef0416fc62dd4e6c1fdd6e1bacb611b2dad0f79cb7df7859aeef1303c610097575df38c0eea1d124e545b19ced1b55b947df5d815906311be88b589616402ed542adb62708ca7fce0e0bb9917485d6732bcdb246bdf789e8bc9d725837e87a5165613635803febfa81aea5a42f5cc0203445a145294c196e7218e1833c6691bc357c0b92edef438f57831afa55cb5530cab010de055484f88b13b415ddc5b52fe4e903f374458564e558dc245361e4ffdf11d37048ac974ccf36deba9f61e8584eefae1a1d7c16bfeefbec1de6e1a4514138d8b5a144854ddce6c25157c2785e424129396f094a64b98661e6cd5ec9978f2e9f01c79780e2d7934a7f0ad424c52c46b99df08a12e84ed5d91275c90fddce4f3f21683b4c76b4850b48c368c2cf87f82d4ec5eb1d459ed1afed181de7d49a0d0c388b1cd7e621642ca8974ca14cb2678438fc010da98f6aebd7c35a5db9f5d5dcb6fe56c8c092b0fe7d49e8537fd5262b271d84223a154b3bdd0392955235ef73285cf5cde73e81ca6152a0d8aaacbd7d6a3627c1513b62c9bd445eee4f7cc01e4779940451a1cbc430423c757be153bbaffb497e43b2b7ba3a43cc150a46c91aea0b0988d0479ce2bddd3a3fe40648ffc43ddc3f91f362a0334a54faaeea94555d1be579bcc40db75b2f5b47c83635fe73029b818afc541f78ef18554d730e68aaa55c138241fdf82c28a9b51f53947c365abdcd5c37ef02e8d410c1baa4f4887584da2df01075caa069d4b307fdab07042b01af34f2387c2d9261ff560b9fd38df9501e5295d529395ce05b0e21d159cf243f890fb1d608bef243cb7cde676097cab596283d5a35f29aa97a1e01ce877f9715edc95107d9863a2adc0cc9e38ed9cec8ca5be578dafdd73a2dd3cbdcd65970c422082bbd9665000195f1b7ef478187caccfe6fea389eb0f91fee1b70520611ce34b5a0d5fa11ec7cfe0e441f1d80685a8f6d52a9a6593822198258c5b5e4072459d1c1ed69edf911c7e918c0673d0d35f1b02f29ea41e6624f694375838ee91fd0869d968ec2c8b51dba105eb2927121f908a9da9e65ff3d79c2c1700373ae56ec45c72f5dcd21b256910f55bf072eff81fb866a789239c345454ab936e7d89015af8563dcdccbf24cd339b45b96bcfbf8dab1cbd9e2dcafbe320391d8aefc913cbcad3b9602e9223801a59f677da4b5f3c8c4a988c8b5b8a9fa9a62be7554e6ba887d19451532f31199df9b94f35f1d34323b21f62ac3a9955852178c48813cc02978c1dab07dc97e42a60371e886eb927c7980126ba186d0026f5bff741d22e86432edf5d48edd2395b44a3a5fff4caf8998e3a8b9569bc55c132e7772bee81481791485b4fb890846df14d18cdb77bd61fee6a1a085f41b22c38dad8b898f2deb6b193854436a27ccb87c616197ca00623076cc03d8e761c510b4b51d9da3cb3c0a7c278efbd38c103730ff2b66767912be4ff00266ab511fbd703b1c32ceae9fa7fff2cfa9ff98b2b8f850fe5b497445bef302d2defdd45d4d01b51879e51a36fb1fbae137b93d61355f5310c5dbbb605b08b73706b15dd1291716280c4ba1694976d39d5d529d1e4cc5e27139cf789e10eba4aade9bf22f3a594add8e0c4d433a3e32b8230b819b7a2cc5ed2357ab2b8a755fd526010d6ed9d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
