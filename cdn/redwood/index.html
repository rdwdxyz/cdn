<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ddb344971ea4b2ae74bf84ad812597e37573bd47cb0e088617e31be7b834458df4996b1ebbc5c19b8eb1abcf0b0c05eefd436fff9ada67309b4ca68b62a1adc2eabeb2ca1bf2af43832be860a3a4a41d9055af313dc1d34b3f6a17213f5c3f04023887b944f40c80a64fa55d8b92186c05503aadea5b4a94a899916ceef4ace4116bc7511236937c58421e41a0e077efd2044c39c1c9b417bf45cba25a07e622f6a57411a2fa472ef377b9c8718eb48bec4af5f00b51dac01c6019fe245a78d08876c4d3264049e9de251985b7ca6eb969262b0f8803f3a741aedf0237a631511d2a122b098d0dc979826b4f91400bf89089397cc069081680d4fdf840c151015962ef6fb59bb91b53245cdd464c78cea531445183abbb28de5498e36624802e6efa2c89b52c6ac1b1957be6925f386fb8962cc76e1aea216cdf976d6d57478386d4df0cff7a9808c39d991e53e6eda82cf76c2d119bd98b106f7d2444e3a6c8539848eb4fa6a8d6fd74e5133e5290df3127494ddf4ed70b87d373390e70a5bcdb04ad6f74b2ae20b0d7c4c4b1a32db02ab27ec128b4fcb7ade5a3e00dcfac1cce6f00c37d2dda59d8c730f99710c54ad5a78aad65b6e18a8b347dc5252ab8bdb9fcd1b415263f0799c970ad438bb7fb3eb70ff3351cb1d3a7a525f0a5caac569228756e1a7723b09f93507000e863a52841c57c4d03f9cca4b2a2fea8a06d363db64daa5af0aafac19c48425bf6f95d750b49bccfc1ef55332259130846c65199ba7b859c464fec83f89aa9f214efac7704bb4aa6ad10d957283d816fb03e8ea4ac1d8af60b1b0e89264eb84ea40228dad6ac2dd20062b16eacecfb5780ebfb8c4039ab3e4ecaf6e64d605d47d09e2fb3f0eb93681611e81cd2bb3b642022fe232c95d43141eb83c9f0320b355da5a5ca2e6f44516e8e6e810154a878c83946c752a1438276d44544adfef0106cced26336e2e331b669a68300cb311619dc70c96e1d2151a55bbde973b5629591c6067f9072ca4fc690be4de1eb0038ec431f1ca796fc0758be7375a3ec117f901bf70937f4114b62b2b7e844a8b11b0ba9f37b20e0a85078aab59e9bce58933c23ce1863fbc8ad4921632fdf9eaf8fb4ee430188a79fb986f35a4a57f41fff8beb3e1bb793ac201db17aa10bb77bd7151f2c1ebc2f566c88b3060d067128612cfa74db5b5c17b136c7756f67d62afe3753f3dd9780d7c56ae69db05107768b6502109e8308c9958925f893f45e931787f81020e8429fea4a6f4c813200de5af7e17fb2ae7b45c61c48cd988d9e324a845af417f22ffd1b6d29f95079f9f58c4a4d3d3189d564b94feef36ec908d413f8debdc6a07c98fa7aaccd6c53767347a7d551177350ff7d08240ed7d0f472223c5d4a54c713e080e5c3d9f88d5803fc63ccaaf151a6002d882055daa033913fb16e68afdebd31f19becd8220b197c4caf0024b63d60a950473d74769f06bf10e6ff79a2557ecd05ef498edd21ee8ed3aa34ff86e744d83dccb2bec84edea5a58d77a2e8f7c07f0f5adcc4c7fea4a42870142d854f8351de891ef91ac896de953c7c068cc5d8aa246ace66566151a57f69c40e69917b1391b245bf6205c46fb129c10f9da31335db9398b9cd1a2cb495d56bb8f813c6eb4d93aab6771f031f688e300e777d76142214c7257fcda28b20056c2e4d95edf99b30800dde509fe5f1367f52ea53451dc56911e19aeae2365b7d25b62f07843e25dc904c6002caa9b25d20604ff2e6630ae5f8cf6d2422d00127c9d70deaf839a5983aac1f4e3ea9abd8a6f50d72e9cd71c4398015d44e07721640aa2099afcf6deaba5ec43031440ba318c1395b4ce07a50ac277968e5b929df561d54c0a1d935d706288975efa09cefef64a01fdc8d7286c68be41e784652b2f597954164609d4d0c600589d261f86d1bdb1b1eb8c12af668a1d3e875f9d9ee1b7ef8d02f242075c7a0e202f0b67d7b633cca0c230444d64899cf150c84d1f270dfd629f29bd61cc53ab9ede0f9e5373520628073ab9b43dd90eff21beadf96a8dfb52f2271675c41eeff39de45043a4690b832e2a80082f891fc5f1b49aa210dc87936d19e144ebbb36ac130bbd5ffa79c90d0572905a772c99b4dbebff02f45775a1794bb957949a97b5c7e26c2a6dac9bf88d4bb60848d24f7728fa30e1e0f334468d474afc59c9b89edc95802d901a6d13aa0e61631672780e62cf166a99115be921d0a8c46f1345573f09d52716a1614534fadbf3e107097570be8e763c8d20776bb36863b10a7c31abbe24f82214ce4d625808822a338b58185efb754be26949993f992f7136c5967ca61bb433e8377af488e475926568f9e38740ab42e915ebe2eebc238ce924e081b5c8042730af36674207dc77fa6f1fd2df1ee57cfbda01ba9ee031756a8fa78c509b736437c83d140597d5191ebd7eeab7bb7f7a6fbe8c132b57cb6f19d9bc96b3633705c2f7e2a3f990f4d1f82d55c1de229fbbb10e25a9d136dd8b50f77d0fc149e28f61b56f00cf39f31348ce6d97e1c6c4114ace4aeb99a8ce93e512b8ae3f0977c636609607848fc612929ff1bc202f70e0e2fb089a68b266d62f53bfa05192ca6519d162cd44fa07abfb865087b640041318e6ab7dcd80c00871ef92689b4a536c22f240c395fb14065db4ab225503f0f0e5a70de1d4e65e573fbd1876db55852f03bf3b09b0e2feb7f6f4cc752e227a39ea73ac9a454a21ef8b4d936980ac55482643fa57dc4d9532ae7fb741474421e720b3f28643932a9a0a2a660c327d3f67e941991b27f414a23b9166c795c8620c82a0375db242bf1b3b4c6bf2894d5c6cde72c3b855dd136b89459242ffc7e9226c9a6f8e9f1520b37efe6bbd5548e981e0d2ce6b8d62ab22a141b1d7ad3b8f2f66e686d90b38baea10a8cd84c891301a7573c39bb93f8fab092a9ee2464d49cd54a759acbfa3426fde6bbaa1041f66e55b83096c4fbf4c110ccaa23a55bf6305b9603e01991ab202058851f00049009bf4f46324904673b4855ab272594011ff846c06bc9ea868a904214ead091cd6c8a45dbeac28ab415dc6427ea200802351689071425a6eab7ea7e5bc73fd9deb39102bc76eebd8ce1f281cc403b92c22bafba25b76aac757c8554f1d600ed694bd86a8613cf192fdf96fbbbf1df62f36e97c0cf8571a0aa7c6c1c0f7b2d4fc676eff13b04b71f5f1b9fa0651289cb2adf4140328bbc7b7fb6befb38a93b8c1f64ca5783377cb886ac9bbf1f0eb53cf894fabe61cd4ebea447d51ab5a2c5aef553d8d166d02635c2e9655e7822a4a03821e6a2b33d17b01599ffa60dffb8786a21a929ed51a729a103c8562190cd91e78a8a11077f476ffce913be6511f526f02943b19661fe2cb206ba790a94f35b9af7f14c1bca59eeb054f0bca4cbc9f7e9f28001acc4f0034dbdf6ec95a64f950e672aa8393f455f553c495e48385a4b32bc3d139c176b3e113e62cbb03c015e02296670d955d9190b11f1fd1f84e3a39c1cf03cbc7c1ff4d88539d58a8554829b3a9479c54a9b4ceafc02a926fbe98eb7e754f41ee6cd5474f6bee1ce146ba5dd6005855c3f49788d80b265ba1d53fabc28a2a4114d3dddea6a751258a3e6091a3c5450d081fdf0720ec78e590682a1a54562cb334685d8ee448d03d5356df6432a89418226e032844b7b8d2cac4f6fa1a054dd2b61d9d63de77112f85f25fc65385fe96651a20ee1f6662ee17959302b00018bc4e36e523aa8d0ec3b00cb57a295377cc64083cc2385f5a171d6080b6310ecc22d3574a735284654ebfb90e9095b97e172152c86e4423b79bd60af8cf5cd1206e0178b2dcc0d4b268de8eec9eed28815ebe8f050bae10f102981400b7b164edcccaf8eac1818e63be04bdefed69e303d4cfd53389d1960256a44ba01538962d9c2141a4a04208e5d8809b4456ceec56e79dfc2e030242215e609588156986493443bd9d1b86a6f680a740ed19b98f59ea98805dbf849029c22772a38f5108742b859f2cd936088a166a31130c2355bfccc5fc2df80178b624fdd96ca43c622624be41db0f0c3b9034a28633a9f5952b661e611316a494c0cf52b5d2d06177aca230e24a381094b5a84cadb08f5e6cec9fd4f4acb61c536f901875d10cc317a6771d53ef8bf492c01fd1a1c4c25fe3110f7db6133dce9083435a1569c3f252355d01485b75cc6d160d1f339efaa9259adadfeb48aa82ca9465ceee02c3a3255ecc47263100d0fab91bfca3a95b9819d9f16828dc8d7f4e7e0b23c8eda2e0a373fff5da5dd823f0530b6cc68fafb661d0c2317b12f77095874b93909966ac70607e4c664d56fe68323603a3b9be3fd0a32de8e38bedfae4187e449b2871a7e92884c07bf918b4e9bacab5737a933c93b53607bac850a221ce28f44db7ac13bf4a4a751b85b75dedf12c39f8aa2927745cd099a042c0b68d395a74e7555a71792fc6f71e361eeb4275b781ba1b29e175898f4e3e57e2f921ee2096a28c91f84849339de0bde93a9ca0ce1a98aed46b308f10771a4b79f7700d6407a7698f65cdeb927527f866163378b24124087a690e9ecebb65c0412cb259b93ac706363e1a88c707f03d4d55bd3665865c1b01bd3294b402522725a74b1bf2a077c075ecee519bcb81e39d6713d149ff4b175df030e6a50b67bb030861a3dec307c2b4b197513d363bdf724030c4c320444dba96f425b5adf00ef0e7de6bb546c2e3f6f810d0e290644b13559aa6008ac078978b2aee1aae203de9588a876dcf7ae1944d0e2d748dc3a5f0929e397ae38463cf6bf552bbbc0c9152542487efb175f92b5dc676dbd787121af877ba97263829b45ec4e283c1ac87a9830910943ef074aa6abc764ebfdb7242faed22046b639830dbb27e9ec9314b7728f93f63fdd34babea46721b6b4f055730788c020665c408e80682d98398c4dc39cd3997e33d1444ac1822cb1112787e05f8202fa7c71e484e287f741405c70d81ea21f955e5ea6c07b80b41aaf43f0d057fce6f55f8e9f1bf9906b32d4ca88bd45aabe464091e7de0aef0928dfe8b617cbea391ab86d1684cc45df6c6e8566565a6589ebb2db7e456133637c5838f3b03222ab77f00156ac84ce69fa9ac6f2618d75718f1e9cb7b417d48537a8ad2d1397f4c671e91c87344f95fc8e6ba4d702b67bf1996d2af04caf8e5f06339e014da85b4c4e7e24ae2b2b69f8ec04f0ed4194985c5e47d52ef211e71a8c4b0461df721501ae18d0627fa2d1b35098bc031265a5889753ebe4215e63817517ece9a9c5cc9737e6faeb84c07bd52839a772f5534bae6bb27c22b316d3096db3cbfaffc851d70894bd9a0887960a4dc415ead7c709dd063db97622850593d208c632d8d5e6924dda525f4b8e6a555d9cd68b19b0ea1dd4313c9264ffa792f450406f0ef855665b9bc77888a1d18a452b71ab33ef0567bb2a56fceada9ad8c08d91e09e7d778dd073c3affc94a227263c555bac4394cab43c725b8c314262e7565ce9abfd48b0f7b6dead2e4a56770e0581b70eb8c9faaaa3bdc8991ab9dd78b3df7a8283c82026f3ffb20cb60e5984157463173dbb341df1e1a9238678299c9d34957123beaa7f1b2f55db9eb65b862b5ebac16193f3c022a2424fa368a7ed32cac3538dd70d43056a79ceaf1dfcbf7511e3fa4b650c503f58f8bc3a064967b3d5c56118ffed1ec91ef96a1e4bf9cf8e68d75058aea32336a7d6e616e255bc910498dc087f1cf57ec338c0678e5d41affe2664a7f56250b2b65d597e32eaba6c8a05808d51f27491735c7816780b912310065c2d63f217b4303886421b28b79548ebd0ae0a1a1053878d4be024fc460f3d1c4ae71ed9dd746a4c916507e23bde6d99acb3aaf8693b42337944ddfb26e51feed0d6a797f8f9b66d475c4a745053319f8c4a63f2f09cf9f5068d37043e11263c4ddd9fb7fd9ea68265199e10bdd74c5ac8244518393aa92f672e459e4ae8e4e808bcd51345ad88e7653b60647011a0e758834c8615dd43c9b4692b67c2128c774440dad4418a8ae77dae47d2fe200c153329a6a3838bc7b202e658c06c64d6fe39baf32ade33c359e5aa1024f7927668f6bfe2866683f9c6381fec41db54129f1bc719a6805f181e28a8b61a70a4c16ce40f7f62410e385ffbed0d4e4674195ab2d65d306886a29fe9cc4bd35ab726c882e8a6cf0caaf5589e42a7be1a41072ce8b54c6a16ff0f1486c4edd190b4d1cc719e35ffb989d1dc7d9b2f58bb30547d5973fd41719d386a618240cf9a98b83e8ad9ec3500c7d4874e1b9a163c46cd777b04c1a4ddbc0f91c492840c85f44a28951e94fb85ff482ed4fcc5f36aad6fcc5c365ab543aec3f6ffc60e3aee9c51619f6f7975e5d9ff8af8a2d94ddfde5962c913d1ec49db23d104e6d44cf39e2c9d4512ef2d15e6c2d1e44823cd178a598beca026890238c7d4fcba40d08c06937ffb740e9a5c997bec27e64bcf7f7e3c0686924a65bac77c011af830547afe4b0307abffe6d03a1ba606603c164d967d2ae41d5786fd822689ab46db659f8d2858caf58b4e879b674e2a7ff5d6d339c0bbcfdeac52a284f2ee4770edc3251eae204bd01d2e25eec3d0f4eae266cc8fa0206ce6c5705848c9539ae0176e715e588ad36e49935b10d35b5f6a0e0617488b5163a25420382f1f4b4e5f5c6d870f6187bf16359ecf47b276a9096937bc3c241fd1b5c47890a88430404a00ccefc75be6d5532b5444d9f2e754588b4cceeabf292266cfee65c0bb4ab08bf7b2b922967dcd9026ce550580a51dff668ec95fa4544b34899cbd6b82b03296536279501f3e501b29c14c0baf45ae4e1af8b61206bcf0c69fcffcdf1307d32060b5af8b2accccf5c4b46a6f7d99e4f85164c3e8177dcdf41b9182666b13250296f7c7b9f2b7c67334bffc869288c5475c0ec00b6008dc0f867753daf4d8be296c104aee4110f72acf86e0b41b3b1c546c6f34e5b3157922e0933dc58df450566303ed41254d638bd6663853164925f877e5972bbb56b83b8e99cb0fd1194dff0c90f8bb187cbeb71ec15f10d750a7763c6daf0f81fc7e2238f3ef33860bb1221eccf8c1c767e961f63d178d8cbd4a0d417a3b26450b2c90cb3d9c9e2b9aabf5ae16cc3a84db093f0d55633fca6556081894899947c3a719bded134d7de59f09dabf8e095fbf511856b79aa6014c74dd9b558d7de3d70cc477255feb831c406aa707c5ddda739d647502ec762e19eedc65d8a48615c9333ce69250a2ed511988ecaf6b1372b17e4daae12e8ed71b3de20d68813f6840e6a5ac7986efc6aa17445e7052900ea781af075e122cffdd8860a150150fe3f56f10bed3574f27c27e1574efc88568c2565eec978da7d514de726fcfb7b4864933ed1f73e6d525c665e18e877d7bfaf328f3095ebef2af1fb20240a51435a8f08f158e17798b115067e0bb60921d7002e6550328311b52964ebee2d7912f47c72c305e9dc6d37a2b5733b601f43dcd949e827677bf5dab4d7cccbc047979a7cef02d1249e2d4f37c8839c0c395a61afa7de8a0dc71a2d7e548e098e490fabf99871aed26f9214db2b3dcfa02e50109fd0916b3f96facc3f6357267c265d000f2a95a519432da46a24d605d53db2be417d53ced627840696805caf59ca56cfaf2f1cc939429f9234dd0e7e963aaca61d96c772e8ad074c041a78734e2de08f1d705b66a81fdd5fd4a58a2787c43145b9245dd278accad09a97936e6cc31397dba78b2d08e8f86349edb2748f6c9b91b002037b23e402229aec627812bb59ff7e349d035832dcb8b3af12c6cf7ce3fa628d0c0ac3ded02a968241671eca13b87ca9f0790309c40aa26099e888c7bf91582df350055d26ce51e1489d6beace08ea0ae92fd13abd6f9c340e7de6043c77c039f5df269abe38839fcee0e5ad7890edc73ed4049baf9a1789f72cb3755db7b09e356977df7cdc18d7ecdcc0497cbdd78c63bf3470972ccf0d650d9f854698e3cec84df7d01c7157a2544224a61ea8e0fa9a4294b5a3803f3f82dc9f91709dc3cc1f70676a5e289d2ff61196e071f90e4dcc54bc1068ccd7abe65f907c2be2ce59550f753b4ca27512a7a7bdbeb8af29d7edd416ad6d741ac6689563bba966527de6e7ac80895e570654f9ecf43358dbe4f32acff2043369047b40919838088ad6cb0165ceca3efc30e60300e79a8469cbc3136e6fd528558ddcdf4ac2d6b07d1a24f76909450c86283d6d54b7e1b9a9df02305611f0760fe69f385a06626a752aa80119b07ec1073a248ad45a243df430fff4691381ec964e2366db875922df63072a2ee2c0b7d8fecf0e3e4a3ac854dff03d7166193a61e8cc3ef523385a3ca1339be794c2fc9f07a8f6476cd19cf03abd6e5997692349af23b2b3ff263b6ca6cf3788434d5f2113f7124ac6e47435cdeae42c857be5995179097367a9da2937402d04476bde167b1af18315805d9c9f2ebacfdcb10032dd89cbc9be63017d1a331717b356646cd9d57b9ece165451b423f69255fa4464dd75b58861d07b68d8386f61353ef9d3ee4046b13a024213c6ddf1664f27fc2254ba6cfe005b76e1ebe0f4b495894694a66e99147e95a085bbaeb16e2d7eeb99aa5124befcd7fdbcd2d7f7d53f94c54a31f82212558d5bf446dd7850e04de67e6321408869d9346d644b936dffb22327e116103b14095c6c84f983a957354c84a1b62c3b39e2c4c2ff9e351488d4b4d65845850f196ea4f2e656408575d5320f5a07d4b12d6a4786fdb3f78a7f5d0240134d237c45c8e34b4d0ab4a1aabfd1ea2051002808aed4004cd748c4860da65e8d7aaf151568b912855056f7a2958623b11114dc33a4569fc7c95e262cedfbdb6a9a9c31bf262e752a94439b74931b17c595b3419e43782f8d8cbc519d6aeba2906af1d62022c50dee15582fade47180f7c214e7a30cf5cec488fbbe6075492ba1f8621aa6766eab3e400e97cc459dda7b7274bfeec136f518d3987959dddf8b3ad78a085a570a8111c3abed4037431d4f07f5fcd57c61b33dd24e9de8bac00083230fb5c2817c0152d9374979f58e5fb0370260867f46cdfd9f90736e92c5818be504b60a7f2e5aa4e9b0ed6f58bf74d844b04d8f0d062ba0d8d4fd70e6b5373af6200128be43610cd3480bb328134017ac7ed6161af7d2d0774cc501ade86c4dea284c16a3e3a804d9ab5b3b0a75a6098e9f810cfbc6cb4985637fec29ceebf0fe59cb70f33be59254e47091eb5eb872a09f631e6158c4ebff0968ed92e9e61c788d40195465d36beab4a1256f3e1cc8712dba05810fd3a1eedad3bdfdac4a092ccf5f6a4440b8ba9dad51afb82e92fac4abf1c559c04ef48a408d70fba81f2a39c0236d287041c9bb84e839ff139d0d6ea4e9413a7668c5b4bb8700a951f8c903aec7d411027919cc463627322baeb2b95b222972468b4088d77aea495cfffca0fa3e2824aea654d07848253172bac65353ff66596b418eda8b307babb41e50c110596a02ded09f8081186bae27f465daf6bca5cb040e1f0a3d57e9ca91306a8ab7f33ce4942d7b8c3c0674c73bec6d6eebc6b8342f1cb7f5e600330c03c2fe0846dfd560a7bebabedbabcb65e6e85df4b6f1ab4ba1f1f80f90bdadc0dab0109095060258c6e5d8abb1ffdd29568e17afaf9d24e7f17753e7ff862b641e52fb9b611c453beed5040e0c121bb73bda4d0870f21b2e69734ad2b951b85cb1346d6f420fbf78d6c7ac563d5aa05aab3eb2bfc132823243a3acad49a9c098ef37ee0e643d7ea33eeb4c0c90f8b5537d2734b20e6bad0a754ac3b8de4b478f3092fdef6ee7bfdf5343a9aa6e695fca9e04c84a271095a122b67e623287053908ac2e3de7ab4c74f8b5418793ba95029aaac04d67c5980dbb55b84ac85f156e4f4a20eb54048435b92f5cc322a1a59bdb8562c44e0d4a579cdefb6233ccdabd978f45e546e60272101da7ce046e6afcab8954bfb92afdf270b7a55f66fe6eb255b07138f9f9d82fbff8f0e1d668fac96a8efc4ef5d1551ddce2fdcdf26b7c6dab17ac142ce055967197fe18f3106b46ba1405d265631aa91c452dd6e67ca859f703fc721fdeccdfd2cc2863f4cd7b56f82aa1cfd42b02d018800c10f2f75f4ec596a79b9ee19f299bbacb12fd86a1e7552b63f1ebf2d75a460ca7f84a419843449e7e8157cc50e7af0d37f50eec8aeaab8ee78458466bb14fdcc94e2d46db841666d910b7cff96d2573999a3b0ff01550b5f005a5ba1c2ae69258042fc1be1cd7a5eb639c95a101888559619aa2fc8a64f91cff0d51981bc3fe9283ae2ac6fc3f0e10e190d3762445be52b617690a5bcb82c7f98d00ba2da76738ee29c2097a1495eb2bffec38fb271bb0070c0cbe6be79f8ebbfe0c802330c2cbab1a0e657ec457b32522b4eb3ede9aeb6032178ca0ea81eacc254d732c3f8d7b145d30d35ba8659b6b477853c6148d560f8e3f4c9134109c00c9f35320c6da71077a9e7856d958e50396ab1a210f65fc4b3625cda652e7fc5700cee677fc93d93c7f4507f05d4fdd60e22acafea488e56dcb157d1aa2de6db745417573c195749f62fc81c398daed9b8cba8cc6a3c11e66070d2c41dda642ab0f109c06019492443bbbdd849501507c8527b112a54311a997ddb714bcf930af70065a8153e929cceef7f70b97d7ea43bfc9228c0a3ce7c059935850bbe78e215f03f947155192653ef0f34c2f82f5989941705da992fd29f9275e3bd4a2eea86687951a98b7a6ae90789e5de60a14513e2d62e2772c41c732728431b6f9bbdbe8973a73de7c5a3e25ea210ff4c760cbddc154e18322a13a44c9a30e7f85e82c5294ae9ed90aba34ac17f85981a767142d8305d907cfa469e8a44f491a6126fa7af40a51c858e0bf38d581f7ec8ee67704863af267be6cb5c02c7cd15e29c2816e901330cce131e99fe42eabf595b9ebc71bc4ef6330f27db5028be0b2eab9bfbf0a661593f5ca27e057b6b2e418beb6ea936fed3ca3b7f57c06062bc5610be31c2b35ab91827e7d11ac7e2d95821430ba8333e26233a3363bc838b063ece1ff68552e106259f38297fc824e41b199d2445658bb2ad7dc3d0062d9479e95f3f13cb08e4633a805d3639de6d95b7466cb8a91636fabdf09e85fc49faef91f438564908fd9c5b67b6ef81de5437b4f9763ba1812a8fcd81f89148753d29eb2135164ae18fd45da630a21bab9c87e096882dee9b3bb03a8635f923c67e982915cf7926c8c58b965bb00af1b3180ca741011eb75db6bc1f461083692d730c14115d1b35078b0f50da90b1ae485e054aaea607ffda7cf97da0c50c4a9b84cc12fc7ae837c68c7e30edb997e5133f892287293c2aedafdeb2291b5e50798a8fb48796d9809661989a8b8166ba3512455fa09b2a976882e3b064a5144f1d529b9acc192fc52dcecbca7992f7ab11801ddea652a9d50518ae09290040ffd701ac64aac0a8b3817b4935cf1be5a6a1e1c9b3e624dfdf975f82c1ee9111207c777a25e4fa30b3dff75f4619033cfe52a1bf6459178416b54b579b526bcdf6472091e210598bf922984d75d02fceb22f411def7c9d77b79414dfb1fe41f4bb69352e3b124f714082778f34afead1bc96c5de39549c51257e8012d95c153fa5cb9ab6dbbd7046d7a889045e1c61cc66c0b989b746e9bf6ac4d3749bf0ac45e448c33ef457b4df7e17ca6a06cc1b9f18d73d2570bbdfd2ae480f701dbaa2f8a35efd85da4cc995463e7e8c4ecf30c07c7adaa116409b5387e087d9ff6d1397946c46232dd83395b23cf7909652caf892c59487552e1f26b4fa8783779a23ff24ce77432fa7f0f102baeeb2d0967f7065e1f88dd606f2301ba84baf2060645cc0f81c23bd0d71c3a8f13063dd554611c4f5bf59f035186e1e519ae0574e0ca12671ffe1e0313bad14deadf010287f402396689d737d5f798379cec1f2a2b78a722afa39c7e63ed475082d385850f11549bd3d3a1a8196ccf6c0fb81fb9e4bf153361cc4be40d8e3cfef812f90f6086285bcf96afa1195ef1f8a78877f0d298b8a6241c71363cfd0accd63e795f584a769390eed9651be6f6aeb91192d74f9682d2223be69faa52cd92b4e86e7ccc24dc8ba795e94b2c8fa5468a341a94b9efa9ea9f42a96ab1ac4ff1eec0962d5e177b0de5aef5b4d85319fca6c3cb98e1bf1dd0082e245b51ca39519ee43b3a6ccf46f73bec97a1f5dcff1d3d6b6b44735e87d9efb91b001566ca67ba8923daf5b81939aab93e6e045b23b55ab96d7a01c2e5f61f2a66b9c7609268694296b3f937857754738ac1c55193f1712de3d0a4c7c063136eaae652b45ff4f69fbae0514d360a8419b87d759f56b381bc590e5825874fbf90d30e6cf7651aaa1694d823cdc50822068b807c2e5f0fd1be222a621dd73e3af1ee322e7b9e6d038f46b455aa6afdfa159a90f925403e996c18111fd51c2bf54fbaa7717771e1ce6d307cf7efecba55c4932fac71a954faec0f7e7c519ba894bf74f21fb802e61502b923cb3514bcc0efc1f5948980e122e92bc5d442ebd6d58212311f0bd05c665797fdc99c602a0e93a51b4942c067134812e5713d6bdc418c669b43d303f75978ddbfcc3a79a3d85d26cc0b30fa301517b8f3e24ddc22eac87b5bb8233a41c9ce20148589df19b7ed1e70221cbf4649fc98246537b2e9aeada91a3fc33343e645c62de7b02893261c2e27314c4b7fb1d5448ff958bf2f292174d78ed059dc899727808b7af03e4215faae69be1c19a90b3f2f1f70b76bd0b1c0719bb0cf2981bc062b8e6c7dd2d9665ca55b54f3009d240bf7e8b332eeadca8c1f25e8dff146ab8edc5b33eed1a3d3cd073c1dffc3d5dc851c4f6c5ee4fd999805ebf8750a20170b298efebca9ba5fe892ef6a99848225e0c175ddd5ad7e227b8e96a90ee0855889fc0c365be6f2302a5d161608b42b005c18559125ac4cf30ff17bd5ef6df46b7ebae5b7599d96c12d169a587b9e483da44b0a09b958a50006469c6db957f781fa7b6d76fd41384416142bc414c9913883587124cedee415b0ea75ad24173f6e44d04e0a8598f548bc2b8d61ad2f8d5454f320fb25c69ae90d898c7c24f14a3606bca68cfa9bcdbff88b0ccacc68db842c4f3c2b900abbd8349bcb45dab8950438ee2323533adf98a1b4b95aedcf1d1b3399264321d1d6a81704f347590dd38f8c0bc08ca6baf60b56a4573387057b71dfb91c6cf5eb1eef6b5fd75ab36f9131d2893e535c12267f8babeddbf3b0cd44d089fe1e6d53e2ae6be3e0f85ad5d13143dc8b44900c675c05bae927c8fcf6b244a41508b4648eb8c0b02161139498fc1f09e89a8d781643e629e8bb71ea5791b2e6a13893c3a4d086bfa5f11ceb3d36cab32e0c09bef45d8e7904c71d36f70d046f56983d1023f755acd1ce1209ee8553c749bcd82626ba4309be05af11c58fe6f814b400325f4fc64d99e4af80edf5336ad15fd75550426690a8d30f14147b3933d343ee284500dcc6ecfd519665e2edfb095ad1b33c56c2782660245844769ec73cb0e4d9ebb3d7c7a7a6e405a907f661491fe5a0a0f2e1b087a2a0f69b90e82584f3de70ee0ebf32573d250934c3fbd70443a8050416d2bfa31b368aea6cba683eed867248f7c56c47168db97395007fc13dfb0bd66e12449cc52850de8a203232adaf33b55100ae98cb8e606c728d36697a74bbcbf96740f3a628eeb0b8794371d58b3345313ab3ec696f3f00f29b41c639ee5fec0a1b538d6801371448126d3d93651e1fc2ab9dfc174fe6f25babd0bb9adf9345e90988dc485df79c0480bdd2eb5947615ad635187cdb36ebac7e4d9e4dd3b3984bbf2c0327644c45b184bb9c171f73ac1ef878803721289e76d975c8d095fd3104354bb2e33a13c5da4232e7c99ae24602d33d37f60958d95d340213753e9bd8a85d6cae3636a2313ea204023595e8630d2f0a52729eb5fccb981d8c1296b6aef22df99719fc1f6d09623797516b25bcff3033ee5175bd9025e73867c3ed7456862d5c03e5d25d6c77229bd120acf1b885bd106ecfd6bdcfdb234b1eacc6bd0b34704494c032911ef770b17744ce50addd6b6634811865202e456f52fb25e192b6f5d32bc2cdae927e971ece5d47de62daecc81fb740c4bb5a2b0f7609dcac5bd1aff8cf2edce91608584e555bdf366d171c28e87f705cb7f77970fa52a6b5e15191cb214933543bfe2569186c8007e4404ce82f15881ee1ac22bfab07037ed05c5dbfd9afb8d784516206f43c8933f5ea4308cabf9ea081ee9f75831ad44c3c713b4a69d9f8cf4222aee440f7b7e53ae1fed5b133ae9234697cf188e7822ec45596d1e10f414575875dff10787e0b7a9405368d65c74d5b13f5efd57cdf28e81205fc778e19554b1dbd887c2767131c3436c002953e13b0db0250ff0159d4665a8ba0890dc49b50d336fab07019bde07a6f10610b7576ad353c24e748e8b2a2faa3921c8fdd457533fb6c7037094e3556e6569fe7815e6f26a6f79647c2759bde98e9bb2eea9bf1e3ff02ca0f80f04729e4ac3042f02a51d8b84b9f20057c5df391bb377d8b6bda49bf8891a1d9d517e3e9264b5344b727596de9ec8cd49f397ed66338871df1ea475acb647e17941d4a5e9621dde75d87a0ca3ba8f86f9c0c1bb7068ea143ecf3692d520ec30f5133fc7363c9954b6cebd039f3ccc9fbb9041b87e83feda0cfe729c40072ae653e95b20aecb4c9ed6ce5e360c603cf0773a27bc0d71bf4f5194df20728f71d020c2a8cd6872858204c4a7e30a326e41f4cc26ef0f03186082d331a507a679377d3dabf730d965bf092b98f651998e6efc7c6f84d8f04d0cd21692c49cab6e75a24599ff33b2236edacc319006996d8cb2d298c19b82afd756ec4ea40827572ea781bbf436153bbd949b355c8e7e3b09bdb62209f8d9e045e798420c1bdbff7d81b1983747634dbbb9a12a3338d2032aeca55101c01a8e019cf469ebd232565e980036cff6fe27f4205b1d676146051b11b2f4243a7344c76988ed8cee48fe27da9011b85ba31028b656610d4b2454b81a6882a03369b2e713b2c415656aacded7809a409c32d38fe0f6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
