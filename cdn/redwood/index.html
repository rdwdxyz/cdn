<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd3dea98ddce57250b2722955a4ba1884484195381823963a1682d73d7f8656db6e4e7fa83807787ba4c04034acde3acc1e42577d6f9b3b2b874f668130731de86bda656a5659e12f1988dd7e70353e7979095eaff41e6b736417500e8cef49c6ff91160a92716cb51cacd5818cf31237dcc6a0a5949782fd255163692579775dc0f1a31839451410a47504a3a6da83abdb3fa8fe8314d8008265108222a2ddc811ae72e46a4e113a1e486999f02a23e6ef90d447dfcdb0027b5825a239c3f85a9500a842463749a1a470d8e0e22d999fb06663cc0342e09c78613e1e1b6ca977dae509183b06664e3c076e19d4a96ce5eb9bdf6311b8dac67cf1c3ac3c94aeeb30971d48efd8958cd30807dc50c518338d93bf7323d2f15ab0fdedc663283b2af851de9883efed232e4f0e1e4b237fd45b0c51448277d2bbea18020bca5709b39210dcea5738f2e7a7982b46926fa6b9d0ed726e252f5a9eef527ac68935fd2f5511ca0d9dbb6d8fcf9d8fc23cb5e58797154623c68cbcca0db13fb7f6cf17fa6416066836e637583f223852edf5735995b4d5bb89d598cc9d75456d700aa0cf5104412aa77fe90812806978938aa9e759cdf2a33a77b42359f37ad224a24055e1402b454a248efc1e04bb5324a562ec27f503d00a33ba047067fc056c747b0f9c678b4b79322f11236068f3b2fae3bf01ce222fc433400c70824a74aa907d3e3f43075fc103295063c66cafe169f2d2844c49e4019218a08bb002f2d9801e2825cda7614c875ae93c86ef44cfcbbd92a695c3d8919115e08c32ca21056292bbe1ef7ecc1e634686ca2b67941d2e6ca0476a327fbd16d5caa5f0a9f469edc6c41db415b2f6878314203b8f6043fc4c6600f149af65e8675b1f7bab7c4a078ddabb1f9cf19216e09d83a48d1a31df6549c87724c9199a54e2505e876c5a30d481a7ba6c0dad8b9abdfecd3782ee967a489a3325072b47306577ad05f70412e75daaac07baff7e0c21b3ae21621c71505a54b18cae44a0360dd35e2a0fa11250fec4c813ad2475c67eb5416e6f1017b27d2be374068f5e6ac49573b0dc06b536219a68598a7034b6d3993ee3e83afc5ce348b1da4f60e15ef0a76229cd5c8fe48fb3cce753d3f9cabcbf166508f7619d951ed6ec9357d3f2d2b337173f1ad0987e7b5af7386411c78eccc0186584734fc624002c31c0714c639359e1bcde4271ec1cd7b4ba992fe55b4a28f7860a1d025a1353887af27d04bb26d7a509d47cb4aca6c28ade0102c1a53587e442630ccd020f5a46936ced43857adf525497e6fbf98cf111f4bb4890949824ba7e5b8d8e24be298891e2cd5b8f58b87ac8af1f519b595b3c53717d8fc2b3866f4a7a36459711d0603168ddf0aebf798c607a872b7bdbe4644c7fb3404eab776c8ae7e272638d784c3756c7da84eacd89fdf773ea199a77062c6a9c0aebbfed664fb6b6d091ae27bd11fd7b737683cb1e2e921ead8c34abb145487b037f0407a3a0d3ed2e4079b8d740d88ee2a92a525b3a3ca48d7f24a5ba3b6805eb55e2f8e63e193400abd086a88e8aa5c17f0b4746e05bcf1f607826dccc62c2c0cfe514e0392d5d7e18ed0a6c47c38237a80830aef26ab6db855cb408d0736f880130d86262e09e15253a0d44255c29e69db2a1a5f3f042e6e5da593560d06c3f4c179764d1e4fedbf6765fa617ab60b2226fb98cf8353f453abdcb40507e9912b2cd122d0e04734dd6547f353d8c2df070b70efa67b97a326819a28f20905824b76ba787e89caf806cbec4ef79e7103a80c21b8a8e4b13c3dc7c2532b5a8369572b04b2674629819c1663ac8d2b665f75bd6a24ee3aed9ba664856b5a08ee89acc729aff33d9efe93c7c746b211ea34523d7fce9c2766bc86746be9a8c612772c5c93bd4e93c4aa3bd1bfb92f1e1f4aefce4395b986a5363cfa584c0df1cbe0b935c390049cd901511e7140653aef6578d1f48d3d2bb49258572745d488f2a952ba447cc6faca6822402adb675f549e0d71178183c7d32fa28ee56076dd5eadd7d1f8ee7d0b23bcef93ba68a6c21c4b7ca10971de4402fe023fa3f0a9cf3b3dab3656bea1a7830e8b61e3249e8dc9841f48fb4703113c596bf5b7ed512b8a61d7144d1d7e2a3a6a9d72109010d472cf9b25d2b3e7a74987e709e382cdcb70815e37162fc6e3d580e8d17b5ae012e81c72c2d05f2205ed8d25d018f1c581d3ec5ee468fa1c37e183c32717ae985efb3041de5afb839587d2d688a6633787afcae4eb02f213f343d1024063b5764aa66a3b18a67e0b8acf24b720a35d83bba8bee515aee9147fe965b9274899952097adc9809ba04e5787b43f7707e424f40f03aad389c81fb5daaf8775e45a1994c798d525601f9639ea2ec0519594f7c3d98b70b4d7713f3ad119f5f193fa2cd197b76776f558ca93c6c2dedb9f5f14295f8c7d401f358921d8de24f14eaab894eea9ea7bc0db6c6c5f44fe8caa80663bcc06934ce9fa1310f6f49327bb4a4ef57da069f901d1f00a56a7aee0befcca326852182d0138dc7cd4f26e1df8f185c6ddd478b3e0d9867d0f6223eba5657a79d2c37adfc7697b12d5a693ba79e305348993e4c609e32a96ebe22e3b81ae09621d3ee2e372bce18195f47ae0eb919ea8ce8e9f017074d5ab8d56e06659c03a9b0b72ca986606ebac8e2871df5c665f83c6301cf6a66838252a3df1c87a0fd58abf092041126dea1e13d0f045819825b1751156683696d65dd8f0e86993188313b0054c2b8f899e0d5fc01ecceb1ff0b548ace24b521775fd1134c01f328b93df805db06f92648daf3b026100ed2534abf25a025b95f64c080203ec312662e5da24b239ef2abba6aa89dcd4bcf723acd61fded61d674bf78a0943fc4247e53ca0996e93620ad02f6e171b0d325c0e323054d4968754b4b4711be56c6e8dedc3fd038f0468a3030ee829285e24fa45080eb27d4ccf9232ea99f772491feb389a7c18af29a46aecfbda069f95e980f12805cd95deae37bc3b6cdc103d9c295115c1762c0110bc27d85e5a43f338cb411398d3f855beb7082d5b8b07e3ba2fdafb3d8dbe818381e3239f28d8f9190739832bcae8f05378e908e63892b756dca8ac83d995c3ecc0aee2f7cc22c7f0b891796e4fb1de68a213de6d0278d51eab0566e67e5f54706ff806e8e0d1471c4488ddd4d677fb64183be6ba78bf385c120104500ae5273cef3a770e26e488af7dd100554a978fa777daa9a7abaf791863a37bf5cba4e95d048b54cd92d24b7f664160dd17b17cde7c8f085741ca536bc80ba09ca5a5c5f240e4b3ba3c41dc15b2a73bb0be5d423cd77d5594e3727a43528cd4e5134a5b61ed285e66fa57b481a50040dcd0b0da89f45ba06f1a71696dac6b37eaf14fad0fa94b7ce1bee572816ac6737b166857d2b811b1fd9286fcdd7842ccbc553828ebe293d74949555dd2b84f8f99f2b520078fe8fa468ea684ebeeee8ded015728665f98cdfd39726155ec8901606f453e8208d63885b74c42d900881d4c1aa39a0940c266fdb4e61df1b99a8bee607dcd71e74a1bcffb48a79c04289135b08a6068deda02216fbf78a4816078460ee7404d0b65c5933e26e1adcedef62a5c6eed7b89d252c118e174ff55bd32d89ab3b911a39968b3c9bb93df5abc563c746e7f3b9c32b91e479a5367af495e7ab81f1fba639352fee55c25b029b5f336b236fae9194d83beff1b1926f27052c5a94dcef953812fabea4ae5bc604db22b1f53a3eb24753fbd67c9c306db910ac96b220285b1e8f871bae047a3fc569e10b02fa558b8ef111c7fc70414292881f1a6a2991e63886755be243e238ed1d8cbe92c3e222a4dadf881576ab2bac5bab483dddf12e54a5a965e8dc9aba38bc7880cb81c99b03444037d62d06f54b8c888acf68e783a1c5529b7d69a3c2371a3042156d40cb40836dd75e8fcc3cca23ec6f178fc334dfdb02510a5dc102867ba357f29a88b03f2442768baee18ae95101826219de630da90a5b4f837a4d9352278583f3500b4c1bf3002d839419ad9894a2bc80e3348a29ddfb1fcdd8742060b9d46d3a9cbe01ba5a3226bafb959dcf9c1ecc9c7f0afe518d277e46d6997dbd6f2764ebe915e40072f2ec9f698cde5df2352e724b40fd2725c81740850c486d7b316f417a93815dddc5722608628c17ec84fee22061f42de97191e5dad579f42be13fa87520ebc899bc67e9f7a8ed402e07d621e8cfa56dc52e8723ad1ecd7d9da663207099a6a39fc576af44e79bc28bf3c305427ac9b263ca23df847b3b4104cc278ea6539e9c2b4d25be1991893a5ff439d3b8175d033e62f77a5b7fd5d9087a1351a91acc3a6dff011d542fb2aa411937109cbd89d7aeedbac0f0103fec635aaf4a8a802f61cc88b6420710d5b87234f7a85c389b5d5536eb48298ac10c8748306ee02f4a6994b46911a42c727fb8a5b54176d5c96ab5ed6f90115ea19ad236a33d5e6fb04dd7c605aa8c2520734117a80d343a583074c28b5ab484ed96507bc1ed50c9efe22e692ad1590ae9bd080f3c2beca7503546332336e1f7a241711ec929df8f385130a2b891bd9eb52b530bd55980a6b3531c679bb8c605a49820e067806dbcf70b730641f83f77799460822a9757529455a769c8706d5d73f2eb621ef7f8382cd9df41b5eb7660ea8b0266431616b5e7eb261b0868cc6458b9e40b5fc659042872393fd6945626b5dcf9c61d7dac45b9c70676e42d8a332ba038a495e81782cdcf1815fe433ef4c6d46a009700dfdbe8c2dc8455069f244d9e382c53449018114955025924392c9f4675b2ac4be111ea6f6d4e8791c576bc9683ef473c600c3bab040043c4c1b046063405c24ead1b38a2d3b3ecd1f16fd232e6f82631a364e67541fcf29cd7871565900c9bf46cc16bdf49e9c7a3f6a8f4b874e7fe3585ebdafa574f040cd54bf027e32b168bf48b23e9080fa55fcfb43e451a56db4c4f36b5be2b6d7c131b4defbde81e0a2be6f9dcac87cc49682ed0c29cc052c9e4204d57af507159ef1e93aaf76a3c8ef6a54a6aea8b5d639d3efa65cff5d3c4f24a7989572cb4709cc00798203b524add4e5c4725eb829d9e0c67fea0c4abe813be2075528796f09f1779cc0c37b5f812c53b11d0102b4302cb8b721d14a5984ac45d62f1f1a8a79bf2e55d3444bfed86cfe17d5453051d38133b71c283620369d56494295aab8ba06c04389e33b1521d4108b2b475fabb58cede4e71f25a1bc6e95288c267fab8528fae9114ac7f8cfd845aeb2723088053b1cd1458a8c1b48698577b5377a14a79ce60451f9395632ba20dd689b01a478cf0a70003275e9b890a3d154b7c5a0ff6d7289607847abf5e673b94f7f7c431df6f5396fce471cd1d21d5d694ac8719f67b45ec3ea63ff06bff0e7dfdc745834e800ed8a24230e2fe1dd0cb6d9882f4a73e64249602251dfdd3d8bbb388b91c9a0d465e35d335d34d5a0b80dad1c361a86f5c4d0b898e21a4171f5586a932e65aef8a057270f4e0e65162e3fbfe86a87d7b70989b2e5525e1e5f448948882f476fba0005d69619bdb6777fd092ad256eb7ac4f0f7b8c90fd99ca9c5f2a2c05fb978e6be0b21867f5e72b01864484f9dd056da178e277daaf866645a0a91db634c7404478d303337c2f66f1a3a4dc091c398c058b61dd79b2b738ceacd4ca06dadaea5afd35eb886b02aaa3c5cc849d53c8d2b1b5fa86828cfd854aee06c56f63de073b052037c5e4d70b673bcb4d9d674a496a75b6ffc8465a2cede7197aad7984ad0d874c8d25ce023f13a3b687f9fa64688ee5a4c3eb6823c9d03235393f7c20265de8880f9e1914b6a2be91eb2a3f383bd40ac4dc2028df19ce1a506c1b729caf987e058ddae69577b27b2060cf4c43f02b7402c414f77c1ee8b604977526bdf30452e88ac543487f5f6578070eded5b62d637613c5877697688de4dfb8af6f0a6f2a89bf0550e21bc967c6b103412e0c5ab1519f40d2123235c632491ab442153a690ce6046828908007af3ae10ffe39ef6c7c27f742ac77f64f6a75341bdc367b7f91abd06b1184298a55bd95e4906ce493a4af48548e00218663639bfd36c748481f7622008fa8722bab6a62cd7b4044d0f1b70430bc107c5e9ba23e7b59d9bbaf74be217dd1ab6b49f87924d2cfef361c4c81b32cf940734496fd912594530c9d29c9f4d01224b7d0698c62ab3638bb07723638d37c338e7b15f0c9c7021fdfc2f731615f8918b45af1d3fa410c88a7778f6b43b85482e53fa8a305fc2af0ddeea4881470bdad03f8fc01583914de0aeceaa609e946811d4eae932adf1c172ba4143e33371dc531b76b5c5501f6c207854cee0632f090434b380d7604d7221349cef6207de05609d08b109d3acc1e549306e8e5c45535856cf68a2fe5eb4aac84778a0f4c6330627ba37b98116f930359cb0d60d6edb52f579f6df603176d643f85e5fc8083edfa94118d6bf2895d970ce42ea1745d76ae6d5cc5fe3ac284220fb28a83ee75f27af03a862303902c46d294cbe2e77185c384f8eed645e4fdea5008b2268699d61c10c7f6f47d98a91bfea173eed0e860edaa6da353c054a6ec0e77a21a41596b4766f3ad332060d82c8a1620706ba445cc8c9e7da4fbb65443a28b19f1a11603573929f85cea6be0661c0d67bd3ea8e1444cef4b5715a65281c748f1c43b31e4754dfc4106f965415bcb4170db41ff0d24658fc40d3ac4c0fe4b98813a15c4808f12180cd74a3b28c6292fa4a25e5bbaa2cefdc23e7b2bd460d4e0f2510d8e23d24b4e1e78fe8aaf36cf5afe7711a726c106c25007f7cc9e1f136eab88fbbbf0ab58ddcef3838bfd68f28c7977b561bab890091f74a8a85078362bc0ff6f422edb4db97e365cfcb26e3c462fe4042aacaef8b1b49a722c804a2c1b1a409f7febd60fee8c849cc963b7121f394f282ff7e8e7b7bc940cd474c865cb18152e5c035daada1b27c90c611192e0690e2f3c9ed8355a1dd485560fdef4186d15da33682c3dd6f494870529c1a4fe4b13565df54e847b2a943b4275d95a37ff4031420c3ba34b96dab208715c80937ada4f3e8af29efbd6082d2ae67bcbde0ae053d11baa91addab7efc77d900957500757ce47a4cc85b067a0a27183ec2712c138f7165b57c996433792e6ca344046e5789138bd32d78ac7b8832e87e19a4661d5ec42f5a480735039671b67301e87a5d314ba83564e0b127e358b92759e7acb2039a5148fa74d5e540542974a4ed502e4759f16d4677989d9e7162090ad22744245f32b88ad617697b1b3fa8ff20579c906923aa43dea6a92c8498b9038c82fc56eb4d50b440456e3984195d27cc03d2214c1330d37795a0aa927abc0d183ec5fab6717230f5dd907abe80e13be7550a8aa933e0a7024949dd4441de7c25e3c9d525314cdcc94af30d9ce4656e07a35760cd4bcc9018a2a62afde8737f50a16014c6a9cd85c871cf0ec0f9d6d91459ee191e37c336b1a870e82ae874052923e54e745f1f42c7bf46f1086d9d4bebd8bae0e5964490e41687a19430aa8fb22cc37160ef020ad0212d86bc2781517e40c6a096245fa13a1ceb4c49e9b78a633a5ea776d3df017ddb6a124a14a3b30af4017ce3ef60cf98943de74d9e8238b3bbbc6a076db1283e8f3ea1e4ae063ce44744d43b1e555ea9251baeab85702315543e86b8c1e8b42841e2730f96520b685ddfb53240ec680f783f1f6078c9574f52ff48517eee9d39c864356a2d9ef86a41b0c8d19343571dce813ea12410be3ea3aed4a72989f9e1f807aaa81325770e607ca871b32c9249be42e78a4d042b8347d5c81528b4f47f56c9c9c28dbb54be45071df187cfe5116013119b2126f8ea326fefbd061a8cf9012a374d975a952962218a23a905d2a89a67456d6d888ade0a1bf18e6b0af1dea9fbaba1c19e0332cf96f162246a4c4ed0fd83172dd0d7ff21346424a09c49d73d80cda057998ab88d3988897e3ec96968581483ab3c25446a9f3eb0e2b1ab87d3b8eb42522833edd3908a38933ba0490db88d35a8a80dd1177a3792db5fb7efa3a461c8212f9fe90a6411597fa713933faef9d71d941909504b1dc9631164f2080e8c66c812cd0d21190b0c381ce35e6dd149a2bd6e4092bb1a1833ce9c3b2db7f50a2c4bf5460f267cda8f7b47cce24889bbd59ac307403cd22ec4140b2c4f941307a6d39fc5c4c7b044c1d61d0f8c14d78e781afa99ad2359991204f8917a03265e89188f71ca45b74ba4cbb635e35c8f3be151446e37c7aabca0af7e012573037317246306e77feffa5a26595a4f9eca37e77e3614cbfde10cbc7a0090cc2317d08aa21832989a0c833d82ab535257c48f23f460b533b98a3abb05eced1cc485eabf38e84abc432cca2c3623d2f209d8dc129b1bc971017c4d4fc04fd5ab48b3744a472408cdd13e65e791e5f2f334977c1f62824d97c6d9046ea97058cc575880b2ae7f25f8f939af9926fd0ab4c5b0b5e549119f323e9a67aab80dd13c836087081a141e3efe5eca85a69e95a092b99d3fe23f54736d0f6bd5b049d583dbdc8c34e300b010dbb2bd2f500c8efbe90138b7210df636e81745d9291ce4762bb3ada5f6535918ec834b52d9c20dcb71f50d3df65e5c5fb3b4941cfed76b1f35cbfebdce7d931d1c3f6391ef55911b797d0d95dbe0ecf14212f1a3e13817430f4f47f0a6b741be050f0d07ba772f2edd1966ad239064c636e13d937428ae09785e30491ceb252739dd1de5880a6ebd4b176611ef5b877f91908cba99f69850b11e273c59bcd2114306606ba4d9af264283f23817c5560717899d3e615a6f4f23d6c7990a09c8ef5ebfd3b4095126cc83c12836a184162be8a163b7629648a57ac5cce4b97d20688186793d21b1977fbbfee27c88c239be8d9c97c0a8daed02eca210a5745d5565cf0fa753fb6e8fdc01bcbf12972308d8e3c7722a495c15939f6adec8b62438205ccc9591932dec5a6f340908a0972eb17ce7053ca6c64ce3a1edcac6dba07279847e6a843d13928c9b56eb33011ace6eb5c530c29a84f49b2a07b817fb1c3d7972090bbd51a81c588240159966a8629aee36c4e2f25bc899b6d31eaab408888a8786a6284ab6fd3a4c2c8122db33b5515c159687c4ede2ad2b08ff4cb9d4d43c377e695910661f524d36299192e3e35af92ad25e025aeb9f96b428bf8b8a3efb9910627394b9eea184d04be15f4423ecb6cd589d42c66f11130361e23673a1c8c3ad08628106f21f6fc8eaab080b96d6556c20cb6d267a1251fc2714e0da5b9cb8b44c756c05b6113bf7cd013be3f94ae0c7087cbb03e5e7c44f1ca730eeddba012296c1a9b29aa0a32aff2823e8219936b0fc6b233daaf5e68daa817c36be6d765b46a90b0d5077f49e12fe6f10a1fc03bd0a1db377ec1a967c7b4d171eedabf0c5cfb21dba26c002c342d1c4733e8052ca8fe8d5f97255702206706bdee736b851cc3c7e4c96213bc5b94d340016ed9012ec8cd019d189c79f841e64fc66ae79d380202907a33e01df3a0b4187a432002c2dc6188561ea4c7a2be089bf78894b6d1d2b98ae73c422d065c0ed84af6d7a2cd8736e82721d18e40178ddb766beb554a7c62048986b8b633239568487e1b87c28f3cf2178033d0af4e7b73e18967496bf1f86d2890f66fda6421ac176c0d7bfc255dc879312b75a84a52bf1ae72ae819e13c24ba501ac8213ead183b7c8761ce6a01058316687f855e7ae56a6eccfb6e8558ba794d60a0f52c9194ad1f10fccec9412d4de8ea92d12624ee7e2f53ac07bd851c4197e1c68c912b47b5fb365cd84c99aabe6b57bbef170eb424da9ad1d4a3d8f522ed6b656c1eb3d20d6af023d99acfcd971eba96ea30d26fcc30ee2541980da1393a363702db6b0936de74f1352d88f84703e100f7b31ef3f6a14aba5ee3c5d5b30c1bafceffcfc1c2cb0b2a89b5c96e8dbc1e83cea24c64797a85db124084117a9353556d1c7e00a3ce5dceedd7d7beef33efdc769c6a844c756b69ccae3f7da087ebdba52ebb0444ef393e2d66259a34ac9876ae967c8cb17653b29df6e181ad364dcc2867687439335c4298ca4ee4f9db6349eb6c834c2a669a8a7ec0cf3f61ddaf98cd819a9f743bf670a2c840a5690c1525887ab504645dbf11a300cf72111b8197e2cfaf4d6889392413d4f6cdd163bfa20cbe064d30b9b1f6099e6c68a8828c77027efc019b3d80a60f9269600338f0448006f1b1453c43666d5dfbc10ad77d9dde7ef6b0b67615b751190f630a0ce30b8985ad6c920904db3f554b99556fc85e14517719ff6eb09b7d6f9cafeaeac5c294dca37815e56d443590c5585f1c5b64df338cf45f9cd328cef42a2a23683a9230cf93a6c6e071ae361055bdf5b29f42472c14ed2289424c3d82ae2393c147c6cb73734df6e737f647496fac5d1a7f933bd4b4bb08675beb2bffffb8a2296079ce9a24c52ca1ef8bc402008741cba15b8398e013c32a3cfaa04e4484f79fcc04d38bfeb51117d5781a70a56b151845b9173c911025eac899727868792231b7b9206b5b1a1420cd7a4cbb3aae105e6f40e227fe5b770a7329280f1ad7163194144e77aee73e88f1141ef6f500d673b0b4b5d81a42f03be7a1908c3f63127a5fdb2f21237d7bd61fb69f0fe07bd9e62e82d53d47461441fb2b59ddf36d424d6220a0bcb59dc3063b331a6cf1b556e501ec1e64812a2d381a64021a45198f4f213823afba672335587b3047d690f36ffb7f8e4dceac84d4b7d55fbfa059f48c80f44a3f4be421dc891afc8b351d84273cb543a3b1e96310d8090c5b96dd45e568e791f3db6cde0778bdb4737431bbe1fec26bc544dbd2b2e1240737b413079ef58c54722f03d2dbcd9fd157b628c49cd64599b86be5cd0bbaff87c80689370f1b3a93faa28312227e475776710c6545105e409f372ed7cd817c609f29458edcb26218d433113be0f1043a416fa94e5a8137b1cba1ce76fafd7c8a73ff9056b75b8a57e534bab3786aa5accb7a9e9b111dacd903be27ab892bc73b0cfe27523ed7252aa08ed67545656b41ea8211b272e611a27c09ec0a9a154322146b1842bd0058ddbd613951e7715bf5d08e5ee474f3dc02e0ff50f433fb0ca5621634d0f5f484eeb9ddd903c9cf919ce6a95fd71e915d3edc937e9285550793cc103b054c196f86fb330f2045408bd77435f31ad5ce9bca92ff7c2886e1789e34a7c8037ff25a234ee3162e8647169a8a28440aad54151682aa9f5bbdb8717fbd5204e614efd681a3ed6e21f9a87148949cbdba0ec6f8913beb365cf449f6d98e16565cf15cbcd9362f46b04891a8a9f57585190200033a6569937aba2c39fe538c392cec6d8c4c1a90d63e652535a6096987eb67c611f27b312e09c30bc5c4cc0e18893f8cfb66724025114cf25b407a2ab9f26a3d180b95b58d29ea0c7ad60d39928e65625ce136fec6b6b86722c8007b8fc373ca6b06b5a75ce5cebb464d97f981d9ef648ef0dd4d636cd9c4a88cbe3d0aaed9a554b97bd300642c619f404ce7ae02b6cf77e40305acd520f222f8a47d9daa971ffa34f885015c3e32a4e6af5248e6a17a0a876d192bf2255d00d258d1acb6eea06fa35979d740152ac3907ff545dbb86d9943b322278500e106ea1754a381986e2bc9609012e8546a43f3b6685116476a979be301160da8bf488496e3f418458d205e1424f3365d2667aeddd9d95d2de569aa356f8653c8a3541accdba6a86f5bff3ecf4f177bc5a0782715e663477c5b9628f38b85f9ec558364d4bbac73fb0a7aa0ecb166d0c96cd33dc8be28698cd5b81a87e737d7c35b281b9d9cbd09fd8f2ab624787c76d79b9b327bc4caff08618fc979192df6768f32c8dfb9ae00817fc515ca9e9ed308c24dbd69add3acc845a45f023a49a7e6fd845099368f789fa0a7d453605455145c73211c057b8d0d1f8f6067fe563745072e7f187930b692c9535d6f14b23b8c0007c724bc84ba575c252d54e2ca655833dd7d329e196a60268f570ba5311ef322c312ea3461ec776b8ae38ee083836acb2c0b2c5a95569329f92320220a19630fa2a3a99bd70e7fdbc260a733d8b07ef6c12a46ddbe10558a6d40aa864dc11f88516bd9ad866561ab8ec79428fa6a4ecc75068276c8ae8e9faa98a2fee70abe0586e4460f4adfcccc24729bb79bde39f9029b0f5f884a1dbff5e20ae1c5a29ace89231f11a87e621fe2269c3355f631d4ccaf585c10696ffb9baeb629ce33d9fb815e59b71fdbee20604f70f6e512369e21e6189f8cad014025d89363a166ccecb0879e1b46bc9ba8bcfc228797a99051219f66678c3da1faf971be7bac047467a4038c201dc58a409d96fb9f19ec05ed0f238c9a2d796c3455d0290e132486b6e7586fe9f0d657d023abc70e4f3edd2855f042f333f3fd9976683962c22f667fe1cd4d564a54d2fd6a0b40a8ebdc0c0ad7f48460567cea9b74575628032a989e7f2a04f5c38c77e1e83054adceda7d5b13de90355fa181ee1bfa77d8cc401af025a1ac89ba0c4af3aa4d8d77ae22836b6c0d8e69c76e477e3337e24fbd342c6448e1a2796b41948a100f3d780ff62d28b5d8555e547e3f142234f75fa0f764f4a03f52e089b5d0a32fbbf2139ca017f7551715eea307310989b489580fd6ef5f08550253d32d107bb9319063b42781be35de5af79d776a92d13790eff091faf04d008c1b6500bb96d35405e15ef645f80471dd531bd2a68a0fb7feedba3f7db6a5cca1a89a31a3175e738a4bb70b850459eae67689ad40df8f6e630a8380dec95eb5911aec7693a2529cf499bb66f7675c94804e5ff8b238731e2c5bf3a6ba9443de8f19170d03e0da63d877148a879922324b5fd35ab273fe9363b1e76f573befd41437b2b109946c00083f62b2a03b869d5fa179645e39e2e8c9e9b9792d4f709750b38c433290285ec09ad4a479ab5167f02f0d28f73a4f58cbae6dd5bc9becdb98d6ffa988f52104c464aad520a741bfdb04b2732096e335307dafad1b0f698bc99548df895f00348a87d321bfda1f30fe6362e94032a48dbf9b0a1352654dd6b6c8f2e06bb49e49ea9220e36e4203fabb1c94b7620d248b1c72c913bb1931154dcea48a183871d01a01e404ea697f6bfbadb8e3c8200e1e2e747e9b56535ab8db057b758f5979b675ba645f17208e52e04f55cf3f3731d06c8b80c71dff1e2fa809d75f2786d090632e542f19c9257b4f646290ef591668e254d1cefac5e89e7cf48e97188d70e33e33f882a39766a5c517ec27661d708024244af12b120a3f658c68783bf99d36c1e15f75326a3151445f835a123b08d5bdc012af241fe2939aa4b9ad9dcd0df160514980e6f20dd4213a5372dee52450a6f5e52a1426a078a07b5a630308b4afb48251636c935de5e87e22ae407fc3570f4c75666477e46a27badf062b4bf86eed69808ab0444cdd7c528133b70aac6542b979802733544601f49d333be118c82a791622132d7eb36db6ca0708a6dfdc606d948583f270e40e70dde66aaadb67616e4e03426d84d70279bd0f488e607f02f3e72cee08e46078cd09841dd96e25cab2dc1adfb3d6ec64085a71fe2bc1754f019b73ca0a194f5d67bc79fd04e34a54dbc58705ba27841ea1917ea2f96a2a60944bd3a60a01f604a065b5bb5d5d1e5e00935d1916327ab28cc8b2871fc6873babaa1a7e94445253ba2865f18aff7a9ea4b55131be9777acffedfa60e5298e2cbc3d62757fc2064702eb7e2771c54ba8e69d0051bb2168460bc1de29a551fa99d0531b17ddd00d79270b04b04e8e0373e07e7762a9ffe774942c3d334ed2546bbbf57e665b51e751fe47c1019908ea2d4af9163e0f47a1e083103c53893cd2810791f3f6dd51753146751532f24517b84ac4e340a27ae8a65748f45333a957c8157db085ccaaaa4bd6dd8287e35d673111bddacf30220fa8a05389e196c49969be2ac6b698eee1dffa6ce70ddfe45375d89967e0d241d8adfcedf675b714a6fda5becfd325c26addeee9390af32f7f9425afa5c43d95983b0c86df3f4655e167ec3dd757848a88c22affd8f306dd62c6fc5f0d6d21ffebc094e0f217be868548c3f6fcbd0864e851ff221d24a6aeafbdfb99b3f3145ac9dbec4e23f8c8a21fec37db9e706f5e2e3b9e53522d95b35fcfff33a391088f3a39478249b63cee18a063ae9a5413f14e727d351ce148c8a95f97b1db161c80bb957dc33132d766f1083ce9db45fc50929e2e5d3265f9c3d4803e11205cfb40bab74460687e536f1496ec57a1367a2a3c2c3591c0fdf68ff7bc140af20f91e9e3af5ce86013e584e3887fe21a37d550e7e1e76c8ebb51ef927ffe06bb021c0641892c111c9109fd77026242b38eee235ec46a5047d22f00a393449585c4ac10922f3d5b1ac91d94e76298b2de8091e7154b54fd23ad94fc1466cf105f29e84bd8c7697745852313e19d110c2292b6438ee919cc6c9a1bffd2e46201e3efcaa8280bf9b7a4880f82f0b93dc729cacf2952a238c323e7c852d398a1a06a847d71cbc8e645b28c65a3d6a3d8342e0a71a4e0f59af784ce18997134c2c337d03ca343cf07a8aef7854c6b81d4025377664cc0ae252f9333a2a93e9f4dd7e4a3f803c9757a5d6fff057869b7ca645ef8feb23ae322e5218da6752fd2e4c8e33e95b9b82ff395d4e2520900a7d61c827f6ebce0980831bb79ebd4ddc0ebc7ed413d7f590dc19a59a4974d03217514b9a4ec62009c176536b9382bea35a7fee0a3649c90ba58f8e07be40341bb25b6e3a663359b0d6e726b6656dba4fed7021f1725bbdf49982bb054df52bce66170a155286f0cca2de65404a914df6b5bc455f5d11ece11255639c66106b1f0fe32480f8042833f6f587cf5999a9fb1108e7de2c412eb0119b66c16b947efa1e482dd6639619d1049db62c3949980491561d228cee49ff9aa10fb8ad821a2b11d31c340427ad5b3aff8a0a10e979983c0336290087fdf2ff2dc441cd185f2dbe0cfffe1ef5404849f4ec22fcaa7c516b48e6d8d3bbbae3558e63727da55a48f790f56ad83163951ce8b42c2eca24945","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
