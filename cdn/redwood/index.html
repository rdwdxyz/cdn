<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd5cab3fda3c74dfe12e248ccb767ecea111df5c7e6346dc13bc4df7c9f4e99d021a03ca69c65088aa969088d2e3535bc31af1a7dd6549bdf6afe1402384b0db740719b22ba1cd290c830537b9ecb631ca952c2600a22875b4971c506f0fdbd6b4db0bf8fb0df7acea3484a9d6bd7367b78191be5ddb87d3d67b210d0881d6e229c91ad98bd450f6f807147b589ec00af567c3f67dea13e511af611fed3ab82718154c720887c778f8bb43871895dcd122a9bdfcb209a661a94d2844a9629f8a7329aad2968dbb61d103cff205775bbbd215333c9ac44d3b2266f5a3d4914584cc6596f5a0c9a055729190033bedb30b9872f082122b445b7f5e7f1337930a08fb0bf725ddadb70615c08e8bed19cdde3e98ae018f3d53e4e137b7b75ab478802a3aa3d4149bb1df9b7732b0f432fdf39af05e45055ccd6f38f2c48c9b713679a1165af44861e99e56dfa88ad5550ed04ed9e482cb26dafdfd6af04bcafa9ed5d5d900e061c65d4d8c15a219d8ebbe513417eff5d5d2858cc1a73b7dcd73a0a9c8a8367b33a1a882e2591655db49c5a0f0c1d5cfafe05f8cdc55a57ff81eef639ae55c35160b9601cc9d4c9a11c04d70007252b3e21e936d9f94c6a9b5303f0e8cebda750fd18faa9ab3d95ebef76e8d1a82fcc0c22783736560868d5b27c26620e71884b091f9be7bd0d5078d8cea2d4f8d98822f92959b2ba6ed7f7cfd3e0c18623727c327da7753ef3130e6451d0512bd25bc4ceacdc21f60ff01803ed0082b4941de746611ddd3ee0b8aad9886c35ff907bfae96301327d0c08ff0b9eb09986f09f6d937890e67ed98cd273daa23bd4a0e1f31207c1eda773e68a3b698d2e357ab14226fe04ba0a999839a8eb5c221fb8f350d89bcd1ee73f231375d5e282aba7c25289eaa7d92f366fb7268f9abfd295a700aac0ebd137b78c0e5ae3343ed5e1c5b081f761daa24669614c60f0c9fd3c79bc0fa0582e9500a87fcbe2f305d98b62e4bef164e039fbbf9fb6b3581916fd258db3a4a067977938033538e317fca42d5595f182b9d3cec106cc6c7bc0db77ecbfa8e3fcbbd52ce08f29a1319094317244af3fba5fc04af7ada296ec79662870e6ccf009708c366b2fb244e017eb49c8c45a3dbeb5302f36d028e32370a5282b0a130d316421de945d1dc9bed57dbfcc3dff2f28d4461ea7d5a6a2718ff14ea59f0bec9ec87c1cb46705dc9b03c5cf2fbe62810d445d99264160d61191b9c618de663047eb11fd18babcc275d3cc063b44ee6f6c299ab15831251b177162700ce8e359ca548556c8047caddec7bfd47f6bea486613d43971896e9a1634ae4dc94d75704095b29e197cfb143d1efd2bc4dd74c0b7f89547119b99ba228c34473fdb58f32281004f9dae7aa10c347a9b2a7d3bf2b4cb7788ecd743c88a7630c4fbd8c05737e62ebff8f7d6be5ff9f551bd8c802f764072a1f3b2593b6cc3be9d19278935d43e6eb1dd4946fca5d2a9657998550813b404d69f976065905138b71cc2bd266798165cd5884deff36eac10eefd7a123d2b50be669d2b83438b75cc576614298cf2075247c9b0151bfe14fe503f4175d62789c5cd5207aac334ef2183529faa6724badf62f279cf7778e684a0a9da2adde7c848dbdf0d109924f0689aeb60b42d6567a0a1cef67dbc51f39bfe4573be43fdaf6177663a87ee61dd59bef88c7f809e0eaee212fc9794e8978eaa71effb8c89c824d5d49a77dc2681fead31c5e1b85fc989c2afcee70b7bfe3a319d214a0358f4d097dd0909615636a0331e1b92ee65fdebf051d88a35a98b829068e67d02aabd917f0fe9faaa2801d56219df9748f57e1da89af63dd11f20abf40e615d3bd234d024d67348134a9a33815886a2e2ffebf97b036c44ddc8f28f00a13f156b3cdcf08cea9264e9347cb4885314a2cd476d8b73fdd778027456fdb063117ff6b812ea806e5a42d6f8498dc9e08ae0db317ab4a8b9291be6be6357dccbab46939fc88b16207d4c9629af0678dc6a67a23ee746262accaf5d0831a237c4ff94344679246edf9791df70b256fec91358fbd9b09041f9d044f5eb7e35d89e78890427f20ddf595d6445f7fea2d17bf95e552c35a390057fce75e6ec6fea81b1102d926aa8c84b62e3a582ec7524aee19ddfcdcdb250141093ec0e8e462fa889c691c51d9bf1153cdd4a54384a4f631dee9f57f5d092083550e678293fa0d9d8b85d2a64bbc5f1591b84a6d9e509fc12026feba05ebb1a8baff6d6b05fa01f0bca63e3afdfa088b7b76711404e9739626702d2c466f8b9453818a67aa09c6d201f0d5ecd2b68835c0d6c77dd7fc276b2db1aaa5c102c67812f6132f8a256e0a813bc2897fcadb3e3185684bccb6c9c490595731491ade75f8234324a7e760974830a7cd8e2b5ed9b444e3fec55fcba2ecef84c5e0ad197ec533259e9baeb2751729af89b44138a67159767c110c03d5f52049ce6e698382344b833494d03522c6d342deeff046ea10c435ce1e692d42170e2faef0d0a703c2da2407d4caec533004db64f222ebd13490c04b99a7a5576d5fc35b7708a7ee221930441fbf5bc279e93d248721b955c07a1db7f4898f5c7c40f2967be26b148106854a5d4c7c40828c0abd3b7a389efca6cc7df304336980d286ae98d933897ea622dfe0647a51ca8deb58025813521379c42fc57ed4947b750f296397bce98de870889c308ca93528a0d00c0ece3ba10f3b8ffd7654dd6e28366a471dafd1512cac0187424e0546b5ace4fa2b230a51242af4875195be842d2a17495289ad6173312cd9ec22abb81327fe3cde2df5cbb78c142ffe08cd462f11c6e9c11280c0825282ebd90d57ee63d9dfcc8b5da5f357f81dac29e67b5480ead0e9c4833b36730c0ebe2c43c00306c6c2e17d525c4041c5434ecb5c249d65a1235633d1f5bd6c6dc49282973acb7ffd9c96cd25da545efa54cfbd12137add296417838a3431307eba7cd4e77d25fad87978ba686b07a0b14936d2066bf6f1768b12f65f7fb9329137f2d7313e74b231d4480bb40e5d7c505107f0453333950aaa35cdfcd6fe85b286e066632a849cd01a6f6c8da45e1ed2c2f14fecf58538bae7b64e7644ee6a1cb2ef22ccb9f122ba0a6ff8ec0feb6034fd5292884c0c6ad97d24d047e1bd4049b238a09ae5225cb1b81e649cc66aa49a7e014cbdb63aa52ac7325a23f74cf995624c0d580525ecc824ddd27ac1cc4a96d8f4ddcb15ad42cd46fd8ba394335866b3d874d88403b66fbfdba82e8d1a0e2af787e14bad2b503feec26fbf6af7202429a0d3aa889206569795c6cfc9398bb6ad8622a7ba8be94136a2d84d70895aeb4374b9ed57af9f6499715ede8b654e823a77b25dc0059183cc2420cbf772c7fa010abb7fd5e333a853922a4d4c937ba9c4d481aeff192126a57e248308de3e7c088f95281a5f16db85ae6441d74f9ad78d3646dbfb7ec623cb2206f787e9e62b8e0fec1a98729feaaa2054b415587fc8d4cb6673c136ac8f0faa9478c5bb306f72d2c7d52d4415b7a056ded7026261f309d90b8c0b642a4d0bb0b6930bfb81c628e13b29eada6a289746e4886598b9f248866026d4bb110631aee8af9fa33fc041338b69f6852376afbc818e75d9476890a679cfff4b44413a48b3473e97142eb8b060ad051dea23117350346131aaf01625609529bc16350d5d087dac50ae74fa520441bb000412a8d2459fc25934bb1a671e06677ddd9dff58495784b8b5d7b67a6337f112e17dbaf6fb5db5fe394e2950df9f01cc9fef330fbedbbbca1de2503e9d79571114ea63ce76544430207c344fa8e93bcda7d9eda49a81805a41476815b937fbe2200ca0ede8313f9ca3d96875b8eab1c7c364af69f59d09a54e3e0066e5376831b0a90dd4ab7053c08af3f17d99db84490ae3333cbf2dbf3f8ce64fbd176cd35e83e09d7a89ed7f23037eca761aafee0eace6ab62bcb862b8d77aa61c7ad2421d2ef9acaf9f9f2391ae8482f672b127903453e8ba83e8a8a64ca4178b411bc74ce7e280730792e9e6fbe3147baa3c85216e9d110fee36435b4ef03018a313bd464636b6ee3151757d7a38dcef8f1d00ad8365e097d5847f9e5e2e80188361018a79ccd7313ff9b13002668e3703e96679b2832680e739f60730ce86c3252d1e8f58b5c53122e787be7e68c507168113709bf5628d1dccba5ff1ed6b165be2ab6edb2070b776f767e470e0ebdd6e1e2ace9b0b0d487eb64572507c317797ba9572a1756a6fe02c30aa16ed22f47ea832c100ac109988f73c8d996e4090be60082eb8f48f143ccf1a3caa0475288fabca9a7ba02f9746d3f00b5840e37167360c6ee8cb2db9cd2f3d41010d135b3c57ab9a1c704ed100a92bb00cc991972ade3bb201ef40db1515464bd512c1171226ccb65aab1ed399441b73bb21d60c36335ba7a96fb4417c60fd4e513c673ced2009f5ba9d98fcacba0605ac0ac44bb5cf105bee492d0158c0d93ec91afdf574459ad6f062787d54c03dfdf5c4e74b2af0b5a4bc216c25a04ac0fd122dcb4192e78377a0fb0e0c10b4824cf532a3cbc0a296b36bc65ab05533d79d4c9639867aae327d33863c37348c3295e59659c909e451bcf9b0636f554cb815f05abfba294c8a951523765903509480e7d3c03e1939ea07bfe7fcf2fa9ef9b39bb19a00b867c2797134d3a7b34f46b301f293d585666796aa744368ef17063d71e79af66dfbb0611f237c46036fdf9f89e47c683a4e0ce134fbc1178aeb1bc833a0fc72c219e2a881ab22cfb7e025cfebaca10e5218e1e27cfd6f87f13fa914892a3ae1090fe3db0776ac2eddd3ae7d3c5920d54f56a1850b78a0c02bc53347404a08b5bb2073376f29dfb622aed627081ebdaf734c0e26bb7c249601f5de203bc3d33f61aef1d68db2db9f2d97fb6a52ac911203f6192b9f84483b6f0cae19ca9d9f973c86130669b2e7e9c80f9ec71b0e095c26eb0bbd0a0c7a0386470a8bdb28a31674b9f5874a6e0ceb43f6a54c27c9030447b2e2b8df4a7ff04139936f0462169a2d27f13cc6a9b69e07bc506d0676d44bfc547202520ec33324cd46840f5f0abf3d301d7dc3caa4a499004a7d3fdf00bf703f2fdd79cb18ac060cde4bd298a6c384e2bed8c7ed5b924917b31704c4ce7b2f6896ac45242be4daf352e9b4983a15647e0cd8a7c13cf005ddb19420e8ee0d5ddee121f379748462104970041910f90606acdc109dcf38b516c6b94839d5479128d90c0f5098680e7885c70e3fe3b20c0f80019df4235842e11626458e136a3b787b56dce880af9f699f512f779b76fdf15e7d12810d3498c566b5687e561392593ff34957434fd9c9d2267612f838c5adcf735c892525661a07c7e2a12d9e87ee05cc0b6494daced4cd3eafd390baa27f5ab4a51eb79c4076e580720bbac92a2cd9eb843279d786095a70cae92ff707f67deecb582696244a7a4c55252fa5211df3c9a8e0f19403bc67a289bb491f4143d2df0e4b9d1c09add8eb6fddb7d7a68055e8619bc539fb60a04ef73a0619c3b21066d2e9149cacd47795e191243169974f2b3a16929993a7dd5e01949c0c8c3365998bd2059af768ff9bd092be58d77b616e00410b35380e6986cbd248feab35cda64b93b9c297899f0c41fcb5e70e1e4c6623f51cd80a7656faca07ee54420cc38548b2ab1e902995dd0854637dfd155f634e6d5ed9b0e2bf02caa6413a2487548daa30f6621111959b1de6a9ce6fea10179ec4f09be2e46769eb95379f4dcbc58b8849c4706a798f46ee96eab10370793ef9fef8f581f8955145bfe361209cf04efb302bc671a2ce8a0a016ad5608c93424efa1eb5a6455c17ccb6f1d2e509618d8423da3a3cfd7ec83ae8d695ef59470cc1d66dce8bdf55c8cfab02961d0b17c078491ea7ffc7dc6bfefe3744515f70662df1911f55247740e27a8ee7c63a8e9c15f4e54206f638a73eac81a447cd13cef9d0b8de0e2ba085c6f2d61b8db0361a3c89ae8ccd698ed0115764b0ad5b04386650ddfc3c78009792fc2f2135e3cec86bb8cc5deb0603e18ab389137a4a8e2ac48688c8f5875121572c0d36cdb469ce92c1d10ee99793ceff26ba0782c0a72696aec72dbdbab6bd9764c84da629bb72877b911cf24e341093563efe0745c117359bc6478e756cc820e69dc1ed112ff0e548d5f3fd2f9501caefc870df191e2d2be1d8b4879416b66fa2fa4b9f188e8e19ad21671fcd6cd7f9c17c345d038701ba21d8ac4f2bc0de4cba660ee3d7f1b7ea4f2704232078b4f6684049c6483bb958200bdd9c3ae92d0721070b70c23525ae08e3107dcbff8d9936b18414bf2f63922b38f7fd1094bc13b5445c697cccc975614ecf7238204456ff4006a964666a67701b2b8288f93085d4f6be823ae952773b744cde70983192ad7dd094832dff40b3a66e015f4d632df65eb3e8a5196305292ccfa0ae501a059f5698cda85bcc8038a32d3928d4a220da0559a8e9b9d147b5211fe13810c3ccb997e4a17ea0ee6584263c46faace8377878e0595f64b678f7b8add6a666e889acb6d80b6cc5ae0919373daba3ee9b5534d91d8c34621c52b01a85e5263de9764de16322b436784fef6725a18c5ef4674866019f1fd359abfd5f640e53802ad8e789db29e12eaf7393ccd0af4358172b105b094907ece6fc1078bc2772a1409de576e0c88afe281e34ef3529b14b6b08d28030f960f71b41bd28d18c6df8d69dd2ca701008834b1eaef834892c82f5577ce84a431ada677d435b95e06eb94ff7ecf68b921dea145751c7dfaaab6e61126649a75cf29185cc53c2e7cd34908f8ec340dc82ab49236385b91e2178294ace6502e42c45fd676f42752d4f555766fed09c2e7a7dc9ccd6bd792d31deb8f607b9b6d8633231d9d9711e706db675349dbc2cd11e275df721c4cfabb230adcb793fd2f912c794a5ff9cbfa2fbe7370bb8aefd137a78852427888228afa0bea6226412c9fd09ebbf6d87f90775b999127b382d1ecce7f4ee706480850e4e283ecd474206b9b42ede2cbb2d50995cc4db545a098e1447658bd091405692e1611c3eb733931a521c479203db1a63c429609184318d78dce668ec1aa71561144739371ac438b5c0a6994eb863ba3fe9314f4d585b704b89bad92c95bbebc80082bf187e142c61da79fe6e3b889833d922efd89006e28223c6d6bf03d193ace8edd6184160b89bcf048323bdd86a9741e2d9d82eaa65d84d8445c65203dd34d6293d90b0ba8039467fe2e9c07fa7f0ce2af9095050251619b6b87a6d68c097bbdbb40eb0f56f69c169ec0e30d464521fb67d48a8ed52b50c7a0d5885139f2d40b7d1931cc18d3a6c5a7d0cecc3b1416248ee68e4301964b62a299efce538289accd563514d0f0c193e3fecb1dae1e77002d112b6440eb61568dd15541015bda19e295ea860bdc08d9242646932bff34ad79233592c50ebe68612f740d8f5782315329c0cc793211d203c49ea14cc26e8ae3531a5bdce642b04943caf9ab295b998664832081ba47d46d7724e9e0aeed7df6b3504cba937f37680985d3079ffbaa9cde7db982eec46e74fed4ce938fc3ef20b1028e1d2f29bfb3547fe71df6166c5f3844a5e47304bfc9a05310eb47ae5346d2a94ee03f35b79883be717a3a491baa8b3b27b17d96fc4f05fccf2bd00179ceb62daf0dcf7c03454ce791b0e778c0037483a0f006e1f31f3f37b22b4f06f4f6cda2268a84a60162340af1a490262aa9482dee1ce7f22d59781cb153570588ff19846ec541e7c6f09c1c48722d87da819ce9ac4254942f92e32fd8a67d03679efea4383f54b9de54f1528e2656ffc0120d7224825955639865104540c2c368a66f52630d8b8ec1d2c2bf7020cd64eadd26cd4c3fc15e413b655da0fdb93bba293b5a5a16bd3545ca78f08e20c45f6662e07cb3ebf49a11442778bddb1111549d3ec4f98a1a9b7e6127e433dd5f735f205531235d70398b72c0a2dc4d5496d5b479442539fb20441d1164bd1f821a3f3a63735ba85e0d171aa4136999d7514a951b75369b85d1f969ee2bcfc427c25def4f1272407baa4a4f5f6eb2e5b56afc86da758e1dd5fc8c2efd97295671772cdc9249c82ef2823ae156836b5e4e0bd8d413c732c5271880d0eb80b4a391076dbc6ab0657a4be5715c65f681dab6e2be553c1322e58a2b56459968c2627f62e214c92fb65c9ad8cfbcd2a6afc07f6a70663cd157214506786145d223a83eb62cdc632a8d4ae63799a3eed8626b1fc92acc56c75198a394f9bf0fac2c4ae3ec8a63e9f391fa9bcff9884a11bbacd083ccb6ae2585a301b3328aa0e8a6d9729e7ef2ec4769fca94c91cf9769806f67d49f8faf8417b7dad2958a6ca5f42da0c0541e8a7811ee0ec1877d1d1af0418a91254b87484a3b23b75136d41d1f6d91a333a501cc13faf32e3539a34e4e7720d140f5fe70c0667cfe056cef6f27515a16378a67d8b1763bbc4bdc5f45b88b6b940b4f22d0952fd3afcc38b2f8ef39fd8f95f94eaa3eab87b2edd11d12c4d1375338e4d2824c7270d7a17a87f4cae23d0ea99362e2b84b02b47a09e47b21b64c71362285e86ad3b323e7e2a16db84d0c9a445d1f27d14be292e95ce8fd6e7a4ea51a9cf62eaca957749b7cd3e164d636d04732e7243ebac83154f302203fda401b631c418d24c324f1204c61aa5085c79dedc73d0be574cfdd578505a6a87c19faf386a2488949cd51af1a7fadca394ab177d490635a4344a320f15afe98824837fe3400ea42ccc085183425ff6e66baa102027f289214f089fa0066bbc67a24be93e5bde419e34e3592997f489e353a08f792d5efeda3aecc7bc480a3e314ee9d083003ef4b0f655d9c79a5de7ded2f2ea260dbab89e6c4b8edf1478360ccc49e09bdd1eaa3266a0c06cae9d6ba650a5f63dd1fd43f8c6372c6d9b57f734b65190935e017a4c1b50a6747d4bc797ccdd50515daea97b16a55a57df58d364abd09db84484f477d372d8cc7b245477ac39a0427a368e843b6211b1a2bb9c348a2720dd4e17d44dd20a6d2f044d7617a0e3982b730e8054b7dc82cb9626bfae1a7df86cd51b1824a23617d3f37f66fa053841bc1f32472b78022888957adab23d3d99ea727dc7ea183bf5e1086c22f4c749ee6dc7bd53f58c0e24ee88a39681e71e8d79c4dd9fdc468ae734f6d3589a14fa2956851e8a2d8adec41db9e22457381cd3774a047cecc9f103fe646708e7dc3ea10e7cd60e95532393c4db00e88b7416e7d788d1b6a5633acf83a2482161e63b2329e1e5a9f6bb27118ea1534385c2c0ab64da4484444e2ac07da6a688fc44be7c74cfe2b761562a1759cbb9d93ab222d86cc3fabd4c4152ad7b5f27c70c56c4de3772bf2d3fd213fe4ebb19e1dfc877b589af87b286a1cce66ef6d652f86cca1f637b506038d2305fbd66112909b131e0afe752ae6c2bf8a4f81be0c918ef10888854e7e0833878d6c95e4c29593b369204d481340f1bc888bf62dd1b16d16ecc7a1510d6e0aaf8373b39004b88ca795c96f512d972cf26fbc53bf268c45ba77abcb46a168bc7d990eee1a4abc583018311e7778feb3a81de4f31f460cadc2c1d6fc485ddd01ef80f45ca5851bf5f670ea0ef26fcd0cb2cab9b83c8208b352fed6ed2e027c0cc1e0aaa92aa105e492efaac4e05257e37169e88fd36cba292a7b67c26d99479aeccaa02de1f13a4f28d28c5836fb58382a08b8f69dcfa8141cf940da537e96b19cd36d03e4eac4bb28c0dad8378e9c1e9b138160f60db3a915b1cc06882da4725fb6a7fa5f53bf7326c883d5b3b748b6389150b763f57044cc071002a46bb7cb7efed9ec39ee7ae2c79cc24de0475aef2411fe484d97e483afd96d6133efd3c1597a99e5ae3e9c70f543ed31fe3669c90268106c085e65ee61293884391fb90ef3e29b7d5a30d8314d14eb50744b80fa9f92d85068f8f5bf7dda46d7fee1cec607c8d3b601ebc7dade517ffb450e3096694a3a830aeff18ddd179462aaa171d09e446099686bc45917dcc9b2250a23ef6bea6ed7fcd7f4c921c7611d32143c36c780fc1c1157628e90ad298410177c319cd2453ac4ad03a43e2318bc43492a5513b871b33c3341ddbfa9fa6cb698fa9fdffb35e172e35c94c07e123a340f16c0c53903eb5c441ebb5be37e32c6c8da98e93e183c40fb5be624e10798eae7bd72e6e3eaef24314698477b92cfa102f6c5793bca0f70ce2fc334ce7598039e5c5dc17084e411f276673fcea90e39783f46f19ec32e8acb651bb7691e9fab70fa4bb79744edae9a8fe6fa101a36141c24739fa52e7d88396b3a56e28b41eaeef1b5b3feea748e9ef720b8ee1b69a48cf82d1092cf88166ccc9c9d5c2741433366a354da0d74c169e6f9ab0566c2027b703c4e1c444473b08c520344b652113eba0836edd55c5208fdd07758bf193dd291c010ff765c5a6342a76e4e533bec840ba499cc01bcedd86405eae8d66ff3d942660c92075052648b5f0e44bf822a62d10db52f8bc4c022b107c21f25dc2e3d552c58e5b55f8a863722b6604b2c49d6fcc1d81dcbb295a38588003cdd1bdc7c700aee4122594fe1c786609af933aeaab32258853be198b9fac4e32c4d76795bb41fea4939bc2bcd7ec71b07b2b4816ae5ffa7c45e8687496f39c51e62cd1b7cf3c39cb933bb3fbe90c6ce8d953a59e157c94b4dd562d63c711e9e76586cf0add82f5fd627e30eead9ab0b309955bfb3679d2cc5e8fb1b4ed5a1bbe71e933875cc5161ed74b4c5d1fbdb53c4721f402407c2d3619b09f552f2f60a26401eec16dccfa08f83e1102d99e1cc441f5200aca1d05141ecd1da67d4c7c43cefc1dd4762dca22b89a31fe258654e54f4949bce77f8858046738338bb349db84a23a374a894638ef04728607c0051c0f5db27c02f18bf4f99da10ea08508b089b3385a48f4ec052972a68a3fe975e70613ad13062f5e855589b88819845556075a1f5fcb96ce72f85a412c530cb8352c95cd157b806ca759922b4c2b64f0b0be723ab377f36c1e69c5c19293498b8c21a1be040b807a766bd69d6e5e614cb402b3c265f7d9ebd51555e924bf471bc3335b7549824c8ab25dd0e099a0b415598711417a0b9ab3250368a9116acf3c6714c5de925a0f8a08cb3df4d4dc5fd5b2b473e959d9e12c562e3580de54bf436fd406cfbd34dff4647d9f1dc80d1ad3201f70ddbedff61d03c446411e39f58b304722e3e76f05081bfea73f01eaf46601ec3d13aca4d5420105d00a41ef38d2173a7c37d717bf49750513e09a48802068463bcb459260449caa4ab99b012275e17acfdddbbd22bdee795baefa304e96a41f69d85e3f464a30f3114fb4b63cc6e446ab9df9517b9e7cb5055a5af173581e343ec4a8b38a774bf0e0ae57f76f567ef183d4ec923b3f8af229ee970028dc47a1638edf51f61de332131c29cec42309528fa1e7fa2fdf23de28e347549d7935debc8781906030416190ba6ea2ef7a2afc55357c9467da7c7033b575badd33c2f57edecb455597699ab1f84b3b1596ed03e8c33abb63010dfee16381f73983b05c53ae1c5c9040e89637d18e4c3312f4088dfe488c6cb07fd27f1f34c8699d7c70fb8f814f53deb473a8af8fe2fefc6b7d9d1580927924385dd188be02fe441e2a051f6d58215d2efe195fe8a4c1b9704f2dc66339f38cd6a017518f9c2155281a33042116efc30a0cfb985c06154c1ea056986783693f2d171056d58b45f17c00ec5b3c69b78fe7f9384d11a7735c8269fd317a573006e3b11ff53b8c827a19d34d390e287cbf38bf93b928d7ff0af9f060b4e3b57d21f4c066bebda9fc09eccdcdc1032df7604d859c4d95519d575336f0926954cceb2897f3519ed18c3ddb9e47045bd503b0f6816f86d02fcfef16974d1f2b670deeff47d7f5c60382befe11eb5b7fa392a3d7e01f91b2155e04ccf5196eb3b5392769f4527fe12c8b8cdab01ca5f7c21228496f309f385b8b8728a8d69b23bb3668b66e2624593ec3e305cfecf6ad7b0869a758d64b4ccdf4d1fddd519409b94d3130587f735c3ef09ca46ec740d6b810df6705cb55b0138ed3637cf0cd841eb86d1150f4801a43a093a63efa5f0fdfc67c10517a7605db714443611778bd182bf109258308d972471311b6f38ea0d0c132809b15b67febbbad5020539c6915b9e1b8fea2e9f2e2e7a8173699b7013b66a8c10730930820c3dac0f21581f44600ab04a38d744a608a6ce7c99b6617fa691744ec64a1a3bf0a06af2ea63025a62d6a9bc1ca02710a7bfeaae9f82f15c85caffd0978c85156be8e3d06c3a08f84cb6c8ca6b78fcd69f54b2e76f1c78210a27dbccc5dbbfa8148f61859fb32d4935bf87c7f5d9ccfe7f5e591eb568fe8e63c110ef37515b28e8952e79a4911394bf0d37660afdda915179f28ca6f4ff9c1329389f156dab0332e7df6ca0a0b32a46d6f5151082959d8c647ad65403e7943f20ec98114833b068ed6f1a5d46253883794397945ab97e543d8df107769cf5c33a5db35fd2d19ac8c4fa3d175c82c235a278216e6a0a8680b149f50ed92d0954e320638e23f0908d4e79ccd3342c380169e7c5c2c06c40866bf0ba50fe69edde293cd9ae14bd6815810f762b30ea8b50df074e014bdcb4e286d9ff3508948e238def07eaf83f9b5b9c4da9da0164b0677a50c0673c0172407d24a5dbe392cb94db5805105cc9f7c1d3527d3345f5344d1a4f9a06821fe75ce4cfdf4adcd39eb1c7530ac7f3d2b25f298639e3bda025ad6a6dc6adc4d4bfb43d7630e8215d5e238aa5d12e4596fd2d00c09d0b0321a23868ac8a45b5160b4b2a558be7b3ee599c85e4a3acab6f98dea0bd2e98f006de8b0e85bb279a98eb334f99c1b78eb2b3af587f57a3b3b162d686154d81bfcf60b2d9c24075615a4303bb28eb5497445c77e6fa98bcf1ede602eee01bd7abd8fa23fc285dda0649f2a90e8aaae52e98c7d788a08474d0cc44f98e7f7cf73380907e842f72df1b21e54a37ce4397704fe7bea89778c76565b1cf0942c5634ef135975a4e404667f64d0ccc6d5f0ef2307b8ff3359df0a6bd4c838d7e31b9904677a2f8c2654a0643cd1fed301b21bff11a7b4471ea5a39af21d79d6594dc90033d7ecd573ca4d74526bc440ac25996d598b4449d22ee507445b359cc0334259d0a5890da11e83e94f6946fea9ed8bf522f911532b55a91dd0abb7fa275a85fc557a5c508c9e95764dc899c15e5fc4cd6bbbdbc7a0107d8d6a379b88388d5edf5d685e835be315d9b6e386f15e5c2f2263a62c1265ed678ec3f336fb54a6f03e0f2b8d89c5193df0da8cb063416d2f65e2d3085672bee8aef08bd63153459d7319ffe267fbcaaf09548e55ac8098c0473c51781e786ca340e3e844cb711b0d9ab29426b172ca07d7069ada452b3f4038764ebd936880e13f943066d667445e60569bc35decc260f9014ceb89e34b99ad930295d1048509923d4ac849f9bb33932ee7b011f75a0c9eb5f2b05acdf327c581b4d5ae9be5cabc8f17296c7dc1222f06d4fb52472da2f5a1ef3d7e56327b1ba604878acbffdf13e33945d667eb7f48ec5c67e7a8858b14976fd13080e25ee96b26342660c5845269ec72887b96cdec3a152d0ba9303e807b217e99ccf05f5e80abf4eb52cec00f4ef36c787150cd3103204637b710d2b43fc7190f372ecceafed34fb5d1444c44430eaf1c0e78c75dc561bc4e67ee99359d65b2c872e14272acd7d939c82fbd691275da2f3b73fe2adc414a518e08a7234edab8129797ba0cc5042752d762531792fe77035d6168f4c89d8e87c1d83b6069ba90d54a5178b55560b686a88eb74c31a1be9473f73642e4e4a54174742cdf32bf8b9996067368f7bc7e2478b0084c71b95d61eb28cf0a1bd5fed54b7180f2308efd70a8d99433aa8ba4947185e1e60d29ab8a318c1adcba1cbef596d0c359aca3fb95895eca2d084de1be3e958975a694dd1f334a615d95519d3f141ae45d2c581abb0be9fc86c920965036173af92d3fe56d3d883f6808270e4283f10263f568a4fa59400e7b7c06a0f68ab50b3bdd3199ab840443117216470d4db533cb8a48c68096f1894dd6c78a88b3b52cae6ab626636e1af31a0dff51e0031ee5a7523d52035297d6b68fce746a65ce09a586dabe80c9ce8284077a9c7cd0a34473f561e246030163c3354f89b428f91fc6a210da95e832889a7bc5bfdf1fdaf5f7f36f09afb42f7e8197591952cd69138fde4d25d68063c29168bc99285cbd301e759a548a1e4ab1b77efb011d9f871ad82cb5b20e67190bb02cf28aafe8c4b9ab3baf61b82689ae52fe24153151ceefbbf0354f432e334f3c0ce92baf7af4c7feef675edff962569fef94da34e1536bce464e2b30cd3c3e93307eae1b2ab330a067a334663d3f8e23cb531f76b9fdb6c009fbe45daa99d5f3e291c1e9a3ada0c3f2211112a83abed3a7abd22fb01ec5c0b4aa61250ad5194fe4439e298c4c37660bbb9f7a7f05873ac7236c39e0dcbfd162e9d3acad63b625080b16ce897d6620599079addccb1dff479ce03b2ed24979aff201a0fdc129f22a4ec0827cb81f21b450ed100b9ffcc42c1cb56bdcca2d47c4abe7420f78798e58f5a9920c94708fac08ebb7eb3302ed6209e6e6f358692608d846ce8832e17cb5129a961075b28e0f89a589920d9126b06e0ada0b2123e67b404e2a0e3bcd68653a1bc2fe8936b52c316b6fa3a43dea67d5d6388309cca56bc8d996f00f276bd31ad07597e1c2d39ce4e8aa6120fb374823611c501ca01fba8d24340ea6ea07cdd7eac9e993f3f653eebae70341c5c6a851345f7fae1954f6d4982485a6056b06e5c740047cdec23c38806b42bd308abc6f674650802cb32905764c318d4f9577859de4402e87f5552f08ae2c6bccffe869025248a643dd28384cf921cbf77638f77965834971f32233203e68c2344e31c848d16c91a3d3c99c4c9b27f87edc7000a5d3901979a2abded92ee60db8c983a05f53e4d01acb6c1edddb7cab68a25eff3e3b55b83e602d83d96c9862398e6d766d2c27a3da7d4e6548fac751e3457d8c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
