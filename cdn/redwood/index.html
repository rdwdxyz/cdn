<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c0457ceea8bb48e10718107d281af52ee60afe29c8c95c0faf5ce78b79b3ec8a60b5fb7f558739c98f47af59491ae4c9426a883e1e61adbd7db0f6a121310c5a981d096bb80bfefa9225d31bc41cdc15dd7b97c92a37a4d56b28d14910621e5cd82e28971062cb809eedcc2ba6b7da637f657dbab3717de7f2558e5d7bb07c806c7e73219eee132652abe29e857c6e30a0c1f2389c3296b250c97f82ef73a414d12ec55a9fc6e16bfd62dcd90833aeea8ea8b71b71838f644cd5d1ad8f97a0a0b4669e3dcb99bbd2d4c4940f047247482ba0aa8b3b3c9afefb102b9be2e29b5b8084ab2b43c7ad01b823b6185c2b4f801731470923f81597f6e3ba5c5fddd994b94f94ea220d4ca39e8f3429e90dfa92165525c9e0c65003d47215cc9a37f1977904f89a6339e1f1be5b3bf40b7e808972ceb5078ea05b84b3c76bd93e1703a7625c1a721a2af862e586807e1dec4c55f3c7848d96ee40e35390922d7bef3c521449ef34032640828313f0ab6362385dea81f8703e0df5b69b53b9881fea329b07bf0c54a5b2f4d965980479f437280da230886f4672529e75c9584b0fd3d115d59804dfcc99812fa3c060aaa2b0da6fa1edab516e0e77027de8145d1f2e1f90c81be57777651765a5addb10148ce6167b82788c8be9ea520142393aa904bcb16ddb124a4b3e62fada82ddf672faffb61b08253972400d20da548bb841f4bc72b73b82a96c725e1c3b162418597170331e76c460aea75b6375577b9cc04ce73971746268f673b6098111e90d38df3a054a8109b4fd3997471fabf777bd74312ebe865c0674b2024471f87eee5b84e593cdfe7eb32283b18e463bfb8df5711991154fc7b229ad0ee415f433e047ea3abf901abd2fabd7946895b1156ce84b1e224b25791a711718e29732f6abc7239326e9e271e03fc2a281b83e92b4e9318410b388afa186032b26c23d3938195535ccf41996ee0e5c44202888c691b6662ed896bfd3dce6c055b8d5a1691df097d24bbf551027daacf0f0da62814424f536401523ba07436916f3ed43d9cae4e2181fd735c2cc8dbf2e0f405328cdd1e02d43e23c6e9302913a7c31ee04a8162b0729ed8dc62bfb5eec400dc06cc12ba23d1958950b7e7362e1b1e66fcad85a95f5da8b778556eada575855411c96fc8a369c419bae4e13067c4200359d14c3431aa8107544eae5fb9d3f6b1edce13f463d88e60b1926d9111da7293c4ec107c364f5c5b180d704d3396afbd983fea9b3aed2aecfeb5b3b400407530b0e6e212f1b2210fabb0a440b855e26769e3bff708deb888fafb693b462a8d6f56e6ff7ab34f2f8e29791e01fc106787194c04fe31e9deca93e1a6310dab01bb49458f381fd90998e00f11be64cf600b9fd17c4a98262b92810517747c13939d8f323be4466599e1312098eed285205d00b2ba09505f91952cc64008825268d89a9d2689664fa5d767c4f2c199bd3497af00c70a629429b8e64dab4d812f7693c50fe7298d05379bb74101244df3b550dea29d9adac7548b93fa68b458a0e6d2dc3856a47d81569c11ba4f984871f13e9c5bf8040559eb712c0101e59e26097961f6872e09fd5690c6f6f2a30784f0b0c513bfb17987005ed1e8e0f165d108911758aba7753a0733f769c9274c5caa561ac57c27d6285f69f94bddb4d38055147ee4ef5683f630cc86063366011d8fe87e63d09e27aed34e8bd0477e4562f5970e7038003e600221bcf26cb0de19e72094a1191bd0a27f759f577c13938c937ebdb91b9fe83d0b6d8e61e99370520dfc8f38c52a8a83ee244851838695b70ac9d3cb6e6e710e1172d6d75f0cb1f0dd89e9021ced1f641a2c21426ca6143b3ab35fe95bbcde9b30d1885ac706df0366e35ede4f2ab6eb3bc33116f5c6890be2f4b7b2f322b6763b3ff97329883277cabaee576766e843c2a5d543bf5d3ad7b9a42e39bd9587385a1499e156c6e5fa8937306080bb4ca2abed3759ac336a3e02a2749a63796ac7d5988a18d10a845592afe62df9144fe442f4f0ad834ce277eb2797594fe3c408d00c1c7e4c305073103b752b54e2d938435984693431e0c22dc6c65b2a8f4b1e1169fbfdfaa4646fc4938e55c3913ea4adfd2b42c06f890f01e9cc12d3a8562c7e8a583eca7acc7b9246ad138a9b4ab26c6a2ec66c20ab4e9ba80caa18bd88dbca203e2b6aa4a4da096d3871aa96f1dab363a8e3dbc24e6b975161409bd77ded0bd93047defa58b06137d789e1c3100071eacee1509ae1752eeaf5fddca569c9bed060f25544b83efbdb2fb7afb2e0ae53b457b70cc8ebf428353438de2655a87b75c244c579b2d366987057c76c28ce2d0ddcf5129dcd3b121ae99739fc2acdbfd31c85c23975d9e77b1f4598132756564a039f4cad7a0b89c8ff89b257c340988aa9c5048dfcea3acae1cbbc7475a1c5d26fc22c35dd08db72079816afebd63415328e0aee25223a21e777e6aa8b5dc2ac454aeed4e106f1e036f162b5803f86501b577030fd03078218d6036349d5c3368bca99cb257eade1244e8112c031cde165af1edb955d1abc7005415aeeb8e0ffff264fc8aff6518f69b80873b6146e010550883362497b5a21818a88aaf7993cef0aa9a23f0543e3f0448ae8d73b61c3414b3295ecbbdedb50d90b517f41dc185ae8968efe7c752c8839bcccc38170fdfa67d27756722e06a43a6455f07ce02130a90b4b43d86b05f4e91e62066268af98846dba328ba2dfd50d4fc4f65b1ed30f1667470274736a84ab2d7cf603812805257dc7a028342d7863fc2f1228a3cfb3787462744185f5a57f36ba4560279bfe668eb701a6ac151a90add1ea18d2e9872afae1ea55bb748100133c7cefcf17c34e75a8f1517e8c18e5857df6d70a7c43872573f0afd1929686db52014884e188cb578311b24e6eceaac5a02d425b6e8d0036ce31c8323a90924ebc38da882b369f780414bae6985a703638fcc5e8f62b32a1bce11cd18eff8f0e6ed1d67923ae275a723918ab2e96a27aa4a0a6b9e5f64a127bef5d0949ba60607a65888f2ffb8b588c8afcfed010a0c6588883d1e46ed07f2003a69ed94249b7aa6ac7b964274b17bba08e84cbd8bd4eff50b646ee9ec0a3a563199c83465906a5d631ac809483845472f586c8debd587bb40d55819c2caa21bd798ba757b83bbd41f636ca286a2443eb3f093766a2ac6661b437314e97b02949c67a6bb56ebcaa6c51d1e07d9ad488d40b43577d8257a394737a566ea921a2b0d707b0290a490da9a232bce346bab1397f521944af0641994a8bfcdce0dc77c31c8f96b2183c5077e71ef0f5e863401e0288b7261cc1a92ea99600a1c56069d6f5d56332e146237fcec5fae74da2314d8d97875bb593ef7de6dd9ab96824505a61f286679d235535de82b2ae7049b4e2faf960c984e6e1835ff21dd9562876f113fbe687e50171252b5aa729dfb348322cb1997c62b77de38d85b8b72d205fdd872baff34ef006b6ee119d8ca7f30a50f394ec33653b2dbac536e95f16885b28b7d51bb6731fc878c3b853f9a2b6e62d3796095aceba96eb6289cf7ceff42cb28594573fd702aec0c0d5dec0ae358d485710d76e78ccdfe972c2b4ff85017a1467cf8df5e0b83a15ec9e18d092d4693c24f63b4f18d2530cd7c00e63daeb0da2e8b3070cce307df24e9bbee68b3ba0c1348b1ae0a990a04f31f9504739222c7b5683cea75a3098abef01e947f394503a1ecf8fc029093b75890c3af842105e066adad2717a78ef687aaba1a2cd1f7b5a22e6c76b65381d4d60d46088b81c19b142d7e34b38cd2ec18aa74df9cd8c54cca8d88e5235f7ec74d7d6efdeb1796c3f16f03cba9e03cdd01b2a3575ea46246a707cd9640bc104f6310d07e4fbd941aedbb70914c1c78ed8c591adcde554b8425043d673c7cd24a4381e021aa978ef0ebb2418556c07cffd3e5d4b85c50f7e23d4def1598b3f1b8160ca4e5ac25190b6bee3cd2f0c37ca927b6bf24be1b1428faeab615555d5f87b91123c12af4369fec38ed1636553f98553b67750fb37b7f251101110713d7c69184f5ae9214e6610c49826372607f27e30a926f062df7e405407724dd1df3bf559830a5c56008586599558a46c2d015ce3b204f3f2338e1e800a5642bb2fa3e7b68a3fa1789ef8c612d3ebfcf7baae4a3afc4317a2b1321e0dbcb4625ae687258f833303efa427659034fc8bb12539c13a19bff0dcafc73fd76255c9825456c3cc85c037dba61c519f5215c165d464b134254eb45fbcc37c400505b88dabee5828d0fc3ba3e842b9891483f76c8d1dfefc59d2e1034f702d254ca4e9b14219410f8857c2c9e15f62ba81fb6d2d10dbf64fc0eee6dfb6980195cce8555efab11ccd326beb06c76b604f8cf502ba6a8eecf1c57078a2a8fd7a4e2371a5ba3def177200bb34944d11c33594ff6fdd81e54e16a57f45a43e2469eb38204da893cd23c2121be114120b80fcb05d0457ccf813b9cdd6a58345bf343871440e92c5856b0bd097617c2fe927c92202ff2c15d17258f38e45089ce6a419417ad7c7404c26c8c6873b9c91b54d2ee5d4927a8620bd0ea84868f6d8b0ab8e044cd7d8b9aed3700e709cfe64055101f03e877e562c327381796069fa9586fcae23510edc21b91164c27266bb9d0c1ff968d180c8f6bcf9d2e41f8b0f68a1cae883195650d6e0ed17b1464266e72634c228d0682cfa3f5a28740e1155d75da6fc6fe22c2fa08591f79346cfa111e56c7a4591c0bac3a0acebe4378a1a7953902b52817948a36bdf31e07a902191b0f5fc5fafcd9a06748b7ec28dddaa3ce63b9222a3777795ab0cdc1f7a5de8998cad1f6adb58020408b58fb7f96f682cedade64629dd637fbd8d5f3cbaf5f1f6b0b63679de7b22c27b7c93b959a8cb074e7795c1623adb8d8702af718bfc41b559096f71223c1667c208e792fb1b276e834c1a8b84baf7b286abcba92ad0fa5d58ea87bd6ff6c82835cd0eae195ec49c609750b2af7c25e7a004c7aad15b575f15c95cdcc8f616e0fc970384f8229b9c46d3ff2ccc1c09e242dd243bc460d6326f45977086b43050804626e6b8058dae0e2a47c2317a206ee7b6a4351578b9d1cfc321387686ecdc7dfe4eb827786b63cb2e213a1aeb8f0177e1f6976219e37c5d1078bbd2b89e85aef291740ce158dc2bf1e06ab0894507f59a88c6bd813fd7171116a6878f30fc8eefed089a22cbbeed75b6ba13244a81138d6f700be36b8ba5dbad43f69696114f9c94027fe87b6eb61e14edbc230800ef83a4401deefd94f5fb9480f97516a62e667e271bfcc5fc460e4598dc6498e32f6eb7499c3160e13edc8fa57d96dac56e4ffdefbfb23e30f01617f1064ca940ef27dfeb3054facd9cef973cdb7fe795acf954e50b65cf65cb8e76a6f3b26a0f0b981d8afe1852db715128009f452f4f8fdbe2c7cee88bfff25ee026bf3719851fe3c5f8323ea688842f4a1970d4ad99c2188e105a0b4f1f2de8855d1f19fe47a8c4bab63c80d8cea41830a8c851269ffaa9d4d1d6b7551ce2a06ac46bf5e921a4a2839f77ab2c0c1329087a73ce6d1c2350a59534f2b6eb5ecde0958c19c0d041768367c194450cf011d807fc4db73b3867278e2391be5206e5f27284496f913989d8ae4255752d9dfc6ece501d7b34d87adfc93ac0ddb52439b6c089b8df925f75cd6423c7d7d67c4f4299aef3485007873b64b83d617f20a47d977b12032ab7e09a471ff11f7bfac6dda157f111cb1950af7a1bfcd051f1d42ef0bec9d9ac76e3b330400e00a3784f9240b7d2feb88a5cbf38429b768209b7d8c3722f069221114c57e0c609af4e59159fe68497bcdc4ca12d139f3ed579179bb07a267988cfeb5f5799acfca9fc15f1a11ec275d6726fa335fcad2285cae4de53bc21cc4b68f8cdf934f0f9102df62e5be34af720d1e867b5aae863a7d6dfda6e0d6d28db0d7ee7c1c8349d1b7007e8e7184e2aaca6e9c6cd8d77c2c3d6537ccf22038b252881af60801d1010e5edd740030f1f62fab5737d2d68e6f93df5b3ee5124c9c8d614d9bdc512c371d103e818cd1291bbbfa2f732ec7094539fd2155cf53577d99c98a42d72f94e477a41c15a56ce579777910b6d782b928e58474bb43d132988f6365c6fd9b34ca5e41933768ebf82b6cdc67068953df3acaaf73303427ddacf612873f441b7b7bb16bad9abb9abe90714fababec8a7023d09bc8dc747bfc982b98b627e421026d8a5f866ac40437d87eaabaad5d7e740312b3ba0e09b56c402af5ba107f08ea6e2bb6a84806af36ccd0d21e19ae70013dee24ccd46508de307e729766767c5b47dea9540ba3c080a93cf5f3136c5e5be34fbc7570731de33f8a21c157be96210085b336aefbe97cf4480c2963cbe35111f1015392942865fa25013fe74c4b7b488c2727a7133dfe0c527c400e3fb79385089851963a0347e03d35447f711cb9f7f186a39333fbb5100804bb35bd84753f3904831b3931e4df915e4ae6f53804d240a0c6dfc96d3e88767aaf266cccf1c353686ed6bc00b93fda70c8be138f64a0f2140b817d6269f91d74b9a5525e2eebda3ed02b4e1f49d140dc8f2dcbe1aa8f672f5c9fe64d8b3e542b30d1015abd60d5b1b52577730232ce3cc25af681135e517e5688167365a89b0b416bba655b41e5b2dd85304e078ba6c039ac950bcdb32ad9ac307d078a161db6e613bc97753bc118aac088a6c427ad31c701e38f2ce682285fce9b1bc211b50ae6eb478ac6b95789c845c0da306118f20de1c6dbe3b0fe2225417f1ec4ce6bd3723b06a75bb7f95d919e709c763966a942012a9f08eed186c24d303579ebb2417435034a0c6710319a27a8f9c7fe3ca61923a3550908f44d2b086e2c5b91ed5d43665abea48a545e201de7e0cf3ac68f9a48599a838c63c36a2862210d97392043aa7051351b38183dac2560d192f2279302d833ad78dbc5fed73947eac66cb29f5dd3d05e1c95027eb1a9e4b7d936c9adf57a6eb94a524ee8adab15d6edc7a30c0c0ca96c070b8334440625df64189b07675a22eed6803b9275e89a3e39d395b45230878ee929b0a417e9f82bbf170d23c7e285b5f86060211bcccc7447e216e3797f79cbbaf617dd4a1c1795d3149385203447039f863267f0afea805fcfc4d1654dc0bba479d76931317d6b30e2447746bf18592216c83d71ad4454640e3bae64f2279990b9b3de620d08793a64829f69de84224fdd1f4dd32a3baf53bc2fc5afc5fea00aa0685daaae68643fbd4215451eb30eadafbe3fbf855b1709bd01aabd65a7c3a6dd8603fc54dae5c8269a4c96b9898cc880791eed0388e646be252db2393c213e76728e961b6796d39e87a6cfabe400bdc6fd7e05c595795fdaccc15f929f81c73ed9d52e2684584730c37c46c0c4d621d4e1fada10063b0848fe0bf30eae295a0ef2f0725d509dba4cf5c3576619d03cd32c4cbc2fce3ad9971ba8466523007e4aab04c84df8ee471aa529c1e1265338d7d202b4bf09a00a657fb16dd52ae7790d91c9fc6023e751aef2dad6288e8e389bd0787122c7f006d2b223942d10fba7a655a035ff1a4ffe7b167927e94c27d278af03facca1558dd8b5fcfd83e6435af180285889f319cd450b81806771f99543deb5c3188b5021347a2823a26e45393e90cfecf6a2d19b030e67bd5d3ddc733cc985ae602aa540660de6dc02f8856230802f0d7aad63ae0ca8e44400f0c08c98ce6d4de73c3d7d6636c2f79397544cd84a8669c09d53e7d871991d5ed059a13794808a12901842fb1b42078436266bddf7330773362843729911e5fce704a3d6ce1e6beb3fb00a1aaf3f57af1e61ec4c263a10850e1dbe7b1ed44d6626eef14b60573121c364e18505431e5191c8c9acc3aa1e9356d540a38d928a79d762721bcc7425cb1c1a548d01f035b065d23452bb54c259e93267b570ec61c968bdde65f6d024af6e5c5758621e5d92b573a911c0c1c7fa95b3af771ad511cea5f7f96feba470ad1e249b9c9c7f6241ef7855374ae4c4b916801e8b1c86c5f8f540e170c13b8d70602b65c02a421c58c077e9ca512c177e045c93484b3b9fb4fb16216233d3e99a2d1c94aec18940167717aab75f8b8db24e18fe6094f7c4eec9f25ec5176ccd5a37af0ae445977ba27e96e5dddf5e6aa658a26cd49b7ec449840f195d7104d5d942e8b837c7269f6f19ce3278cbc2830f7bee8cabb1d57ddf4a320eb01f47b0c4fcbcf3117162088e1768891fa47ad46468a0bab7a9e6dce440b1b3e3e92df3b01d8c93be140af592cd1b21ba119542c0e3557830076759c1be42518e0b80c5181b0ed47a063ad470ac4f7f0b8d4235e423e893b9f861504e2c3694fe02284d74aafbb5568644392dca21c9846bd2da04b2bb1591df45ee1f2c96a1265a14cab91ea86dbe4c81ad4249f43b7a561755a3b25a35ad634386015538a5463a853b6a91a429acb3075c477ca224def4211ee314d0194fd76f41ad01ef241bb04988211b349631654f24a72efbcdb9a062bace3bbacd8f8ad6362f724f535c80b0bf5df9d2ee643beea1fd544bf2bfef243210942e11f7cbb0ff897f8c8659d338b38ef7b5bb93d5625c3ab1827eace4d47059f944157280ea89d6f68362d4b48f690f425481403fdb447219dae7269ebc2a3bf48054d8b2f27bc22fce32a74f90247790f215e0298d032473a509ced6890587518a693c2dc1130a27865cee4aed6b69780728d0bdd07544972a39ed42c0add0f2645b14e459a373994b43f2e5a6c5f54fd769bb1b5b1596726e937980f0a04fa920141de28f1cb857d68d4d4c13f240c8a659dc3bc48a4fb27232f2b181f0c5efc0506cfdc875dd3dc315c32ad540d008af16e822baaca3b472ea23e4e036092a269acc85efcba1f300083ee1b53d861df677530f74a26d1f2fa5524666af6d972b435dbabaeb72bd903bdd1fc8743351587afc9996637ce7e46dc5bb59ed108317959393dbb89167103ab0f7d24ce28d587fe67f1b0d906c6cb96cb96dc56d81a5fb06a5040459e57990ba2f94b30369f67f903a803fbc00d7e3bd4aff55f182dc50348df59335b0d41d96a99ab03a0620177f05f152c18a586eb1a1d9c6c7d0f96d3624a72af4cd2ed4c47379aa12dbc4b857e9a7acdb85a21713e907e4a60aee1a6af969273a1b12daa9ffde77610932a8292e7e6685abdb00dd5690ee48154988cd43f4b569861eee029b942cca6b4029b52d338c2a625a252212722bed3bfa6c069234e1708ea80614a87e9031b8274c11c49a6e122f8379d00b719802ea4b3a5d1968c1ae6e13fdf549c0f38d015660eef5544a1610900e2ce895ee0b2193c5d2122aefb158f2889be251c074466762d252bdb19ad6981da462272ee3c16c781e929d669dfb487860260ef87502938c5dfe05285945780606559018233624484b0d8874c3c270fe91080f3a964959980f779c1372d1ab0b9d7a74b3fa4c284205ceb4ae80f978e8bd6bdff087919a1b509d634675b10dab9b9974b38838b9b129c407a7b19b82e0d26eb774ae240355d462f6dc1dbbac2494ed50e7656908cd0ff141235632bdaaf800c8b00e22ab298c2312e700194c27e6e6805aa04c052f50c0d588c45a8b258ce4b5e24e157a394fa6d8d06d89f1bc606d2c00c4e57629c6f0a15ec90691428626674e782c8ed4f84c86d24c0c1fb628a1470c977c2de9a84daeae227177c77d48d35e5eb27714aef32a6cfd5a47b90422ff74ffa0e1a6f8e85f23e825a74b5de1e3269c2e258e011c9351c4990bc0a9ea854099e84d9507b27fecd54996118794e4cfa710f2d061026b760d1baac9a03d2b595010b0ad69cfcd15e5695bd96198e800c5a0df5addd31f13298682f018476f2a547de16ee5abe1147373d944c5b13fa6baaa5dbe6e2c78339cada24e80aa33b19312438f9fe111c203e7623b1bce92c48801dc99cdeed253434ea9a1c67ba628bd5dbaca8dd6a649a3cca4c31eff0cc25ac26937c50d959bf876e31238307c7b079b558e2690b52ee0ff94a7359351857e2ce5b36f4423acebe423de4b6a8f3c3852c3c695a5627819604c0d8bdcb196e722459a440451c289ccbf0031b021b5ae92a31d224c0090ef23eae0177f9f892f8e98f7dea6570b9651ebee0b29019b31b4f6d9a6cb287235662d8c208cf515f210cdb070e043d76b20119f070f5a1263f8581855739f04a4668d3631ff5834658c85fa17198994f461a04a316cd11e2626c9751226e90044366d17f2f20bbbb0ed440b82d1b5754c6fdceac133b21d10d3444370a46dfbc97fe794d4def15bbd430d9b5cc7dc5c540497d0d722a548e7beb1979e350d78b0bd2bf108d68802428b9aa914f5387d693d9080052505acf3003ffbfa3a1be4fc5a29c38995a171fd199ba8f0cffe53d6f3b5dca8b048e3c53f4e5692f82c7215bcfc5d4ea63e693e193ae99ddbc0784fadc058214729bac6717812de0a1a4da1402049a3a7b1369f4660ba79aad31cd4d7513f596daef8d9db78e2b89fc5fa12360ce3af56cac629d195a2668e9021805f34714bf1982da1ca8f4ada5b09faf22a5016ed255c3a87f7a678ddfb9a46eccd765ee409fdc735d1d17c15b52e1e5a53a6adcc374746f1bf1298617002cbb3ae897560a5c126eaaa377fffc26a9a19144e3e4cae625a41cf2310b67fc7ad8641fd459967b233bac9163b4c3bf230d40004e01976ef97bd31b950b7561e360374d7e03a2390338653bce138d08a1549fac95d99f6692134116c6123b56cfbdef8a7b02860d27a14b0e8b11b059d4cdb56b0bf22166ef3fb1aad7c35975f3c1679c3629919f1b7f03c9486bc5af27bf238054eb95d591d6a189995c4eb606d7682a12129836e7780e176a0642e88dec3b87a0d14fa81590d008ed0cdc80ab1fedd233b6f8c921e985f101530ef00c52e346d275fc6360f26e36638ed74c6754413cd02a3873743677abd58493b78fe5d426cdf6f2c0b6ea588435ce840080e0fa9dee592220dc71875f406de1c49e7fc7bbe3d44751edcdef8ec21bc654940ba20e96aeb8f0029f555feab8d214e80ddee854ff22e4023b6c79092f4425f2a22c50f1a28b4a00c9d173ba85c5fe6abcae94166a4a1650d6f3b4f3f9c62242e7e9a5db9dee0916f96e8b6556e952ff1d5c23e0e34e3db17fdaf5700761862091e19e9f1900d15d2a27a626a2323dce4c6e2fe5646eb185a3926addcd30b4e4eb2c47c3cb6157976615e1ebe306e4badc77579aa5ddcee65b2a9d28e3a3e5d3d5b6b00b3cdb591b98eb9a77efe3607d18e7ce22a7fa39dd9e0f469fe93c3d64b5369f03812ca6dfe958c3ef2ec2837ee70664c1814fb302226afa04f1a532af8df62032f1f7668446068d88c184bb35317775e185f299466829337e2ca3b7fb59b2eeb07432d769ec087293bbbae2db0e3588542d7994c2174a70ffb0a32cbcbb476dfaafe71f5a6514d6ffdfdd6a8c02b71db565488f4ce83e94e9282f30b7dbd14c615449d7e0a04095a6bf0b186cbf55bebbc75a3ea91701ad1013bf336d506c896bf5b88f23ddefdac04a47f5e341e74b6e4f0c327a0afc838da6f3c54fd9ae8260421c297ab8cd6a77446d85fb4a28d6df0b145c0fc89914e02a06304a90ccbdced6ada519651711aca4a3cac55ae5b343db71523ac4838785b2e6776b4b994244516cb22d47fa7de3f44c7e64f1317ab15f49185402bc1a465aa7562ec02d9a29e122cbbbd6c1b981236963e58a02efa7b84abd2b61d2d8dd70eed0c7c71df72c1eda663990361e99f4519ee6144ecda761f76dd9e26c899d9d91fac80038f20c687473c8f91a15a0af06d59e8dfc252aee4fa5ea8baba826e5c52b2dbbb43bef312fdc5982b43048bff2abc6ff3a0470ea0eb710ef2e1fb0c912b3bc0598635cd9ee5066ebd9caa9d48d1ffc838594cc0e6ab2d05eaa034f48b6a1c23805de995373f45d175ca2647af99eb756e80d8801daf8f4e65515518676b6cbaef59826a3a9cbb6772bf287b498a0f207cb5303f2f0418f17b6922693f40ca65f04e81bddb27884fd537e5f2713af27c95bab49267c14f6c4a29eccce6259e796023720b87289222dbb21ceb24bc4e2d67e1f33edd988baaac246021af294e21271a39b56f4669d7e68ba0901f3c240c463cc30e9c455c7a1b1228e8c2d0ce55f7d7673eb0b8d7b1136a4ccbb0965176110eba74624832768909ea6de90838ed8d7e9f1723b03f3da581f3d4057dfd2953d61d7100d54c677b7abe350e0831f80f8401a1b17670e91c2b27498f74c8ad18878eabe59ad8bfceeaf3f756a53b0756055f0fa5673595e3da9aac7608b0b803b6b7c7cc0e12be93cbf22c1affcdec4ac4d850ceb7226a4cf0df38fb43db013ab574ad144c28f205764221505dc2b2ad2a364b880602e48e905ecb2dce7cb7c1e097981ed5a3013b39ab36035dcb26fe5fd7265964b969c7d1582d3478c8f2e524c19b3e148e569fe2ead12ffe96970194abb15bc2c14d67278fa257fb88034cf6afd71c4d6c34521fcc946cdc6c9da76b93b6fbcf7a4fd093c327b05066f2426e3e2251402210074fb229f2c16dea6bd5545074c2556f6e583dfbb31a10a6b915d9f8fdc828111de2d37d1ec606c068be16d746bfdf379b9d12e2ac985d18d3c5df765f570157e0f5e26e8e41f4ddd929b56ae5dc1589965f3f3bc0f5b77827cd45152272de1263e97c51e5fed9c20c6f77755bece9711edc248c87aebbcaef306ef8d80b6af559bfd870f0de0921323021d2047fb4cc8774df328864e628d12c68191df09873e71f648837aba730fc7656300b96973eb0d8a375d4d96be16f20c10d3706eecad5b585c354f54b7f142cba43653c7341b48d3eff224e8c6a75d596dbcd368901b42e97d4a2ace96a2eb97388cddccc471b8f92704e2e00e83d7565c0c5064452286d8308578e75b1c6bd5196625b743a678a49cff8ced5e7087c11ab86ab959c4661a00cac0a92ce5977bdce78f922d8dcb8b01c0e9b10a61a17723dc85201e925c374579bec4bc83be44b45a653672400296a76408b787f843e400308c2c3a1c657146c6dabdf9189c849454624c5197adf5b4c05e6a8d49e5372fa0e586be411632d59f49e48bf924ed77a5d0e04b707fea4ade58ff5dc257866c7c46f8bcc41b95b677a597fec9963fbd5f3a0f6ff3117870897ee4ad1c06a0eaaa6bdbc8cecc3546214553dd046740401e6a5703a738bcf8e4da52e8d5059dce275d1734ff656fee1d3caeeaf3523182463aab14509c487a111215503aa4d885b724740347c2999d458ed2856fc89eb231a54282803d89c02aef6f62e82837e2f5144c7c802407c3251f6c3c96481a4c1de6ea00a351fe20a8aaf08f8bd56d84e3b124b2391d4d0ab60d0c5935ad83086cebe4e9e60cdf4556a4d43b03a2301226b3bd3ac6222de4a3790fdb560e920f83adeceb125bafef97dd3c9ea07983b9ecc5f55efdee90e2cd29310d834b134c402d892cab518ce8e56d4f01e1bdb5e4e92ebf7ef7105b8ea6d2919f18aaab9317130680f8f99677adc58fb5d87cb1b80e9c646775bae76d12bd4134dce223a6349445a0c3663c8b0b7b5687dd4bd8f0b17aadae75d8c1b9b88a001fb847e6b5f7f9e8d9fbada50ce153b8e6d5430636af1400fe4213bae8ac866cb79b1d4b06e907fd43009d61c775995a7d0ecd62281dbed00d4410640aee1418f313dbbe091856e59c207a446cafe7678f254c84b3c2812ad5ed5c373f3db9dea033a39a844a0ef35e45200ee9092bf4f3d0eb33c38faefc35fd03085d42e6fac605cd23e837cabb9f8fd41908e0fa32a3e886fbc82031bff5060e10139d25f0d1b102116b988ee5e1f37b48934223de5133f38d06f6c6af6fb860d80ebc12b525b3dca79825fa36fd97d8ffef918a0eb014213001c5eec91a1f63e603370e9c1d159ff16e0ccd9e2afdbf7a6be1c6db0d5ee55651f19d1640596a4a199ac95e8d857cf6a330ef40d60c62402d03cf3e1b002928209ea77cfbd4dfeb8b73553653c45a36f431674748d2e8ca54c312366a7b2591c4ad4c8de3aece01f0aa6d9716ed0ecb3ed43ab8a184ca7fba3b58fe7f5d411173565208711a75b3e0e78ac8e8b81ce7581f35af454472228429dc891411b93f4c8e0a4615b2f8ecb54d3014ed85ccd01de7fe44db84cbc72bf0975ec6152b6046c452f18709e74a61a6a14256c0152ed120eac77ae390b997d3ea8947f3026ce6a4ce34427bd8885b3d5735ce82c89b2fa93503068da0c724c7017904e1c101276915be9ff8d81a2592d88f57a6b2759cc9d28667a186da2adbddccb47277624002c9e0cd9296c7dcc85719c2f7c5ede05d3a67bf9e74ffdf2b4e41e54ff79db04d60727e91518cbeb1ccdae4469d8ffb499bc465e4c2106d3e32a53ddb91bfce4bf3fea1965ce5e1e763a75b27678da83391f98a5fee4995de1df9ede8c761fcd517b724fbc3c5d3c66c304c485326a0b83fa275df7f3aa24b81bf8f297de161f4c442f894b135b4270db59ba765d8bd7a770054f6d6d461d984a84b364bcac28de16a76bfef502b374211e5ef4e672c9d3e5abcc67c3763b0a74c730c830bde10a80d223794f64525f310c67c34d315ea726e8f2b94dfc0057c8fad7d6d8c8e6ecbf32be68086e1ae12faed597b3753ecc3ca8673ea56d133a3bb7f3c2bb42f6e61451d4d6ea00d8aa4f938b484ab5538cac7a58d084e3bc62b41091cacd0818d0af5c51016678af9ec15067499c349d6c89120a54eb7e0f8e173549115e48672048be3c21b546f388871b92bf1024143108e641d0d9915514643b024ade740881b9910d90d427e041141ae95279429b7c98ea82563d1822d1bedd186ba4529b424378f40f6ec21ba7cbce521dbc3a27eee7c643d8f3e092f70deabfc9defee7b21e380fec148ab5ed1c6b7bd1b324f9439bdfb59fb42ee71ee0bcf14bab3f955cf08f056e362d4fa9c636831bcebe2f1ed0eecdd5143fb985464470a934b00a45db38e413516ce46932f4dab07e60222c9564f4cfb10afa1621b44d0049c9a156325ead584ada175d83746f0a5f2109a01c5d8a42c8174e04619272ca33657a3ef9eec7243c06f5c9b71ec5df07e5fc92eaaafece25fea06b616c453d9bf17c77742b2e6e3b6a470d4f19691d67faf9273e2c6e965977aafb117b1cde4a53daf48a97d99de51a5d6e39f275c2d36a8b73c0e67800f20043f69d4eaf1f28212873602d66c829ea672b5f7f23c490fa7be17afee12d5a85e2d6bb05fed79829618780c54cd1ef4156a5955c06d72ee64c6fd9b650456edc49921621bd7eb01dfea08b91266ed8d7450cfaf14e2dc3146764cc699bfa25658dd2315a75a3625193b5a2bae1b755e5887a6c2f09bfff11ae899ec2678dbe3bfd1136cc57d672e923531955b2300b76dfbfe0e9c9d4d76676ffcb49b48c53985a1b3e49bcfec90606476e06457da36fa74a12c8abd0e662365b64adeff58b77f14eae2dc63ccbabb65a1e35521f34df08ce1ce9a43f949ebd65ce3226d29083f174a311c370f0597a03da238df528ba4ebe8c033efb7fed9e1b4f4cc553d6e6f1add360194512186f52ec08741223dae640f01835f2b2b6a6ab15b870563beeef4d6024c0abd8663c157456c181e826ab0f9ea4c11637fdc6fb9b304ab6a2aebb3b48aaabef973c5275b9539cb273521c7788bde0a173947022e96bceb51b368d64e4678f1160849e73d8becd78106f34ef767b2abb102a2a9eb8ddd1403ec7bd5d723c9e35fee3c65d8e5dbb3eb522f9af0df82b9370a64c4824f6b19dfe8b463619a95ea2ded4f7329300b70d247008b5f0c1590a1e9797feeae28d4882db8cebfc56e123655bf2858560b55a90c242d611ce86cef1489784a230c21322e4f3d2e7df6ac345f4be6563f0b723d41558ae0aaa7ea631d2823ab5ba10c82df1d0c1440a3d84b08aeaf0631dcfab5b357ee1d030cd33293982bc74ed2855246f2475ffc45e1311d3d57c72048634dfb74df590cc933b9d57ad7ff4fca8d33ce2f5c230154cd9256743c032bdd08ef998416a4bc1d35a2988001e564cf81be48ce7841f319c08a7a7d853aa4131360a9f3ddaa8da373a995813eb01156a2c911caaff973ddb767980a452e26b56c41b02e438ffa961b1de00ab65a10abe6feefc7d73d4bdb436ba92cb55f8e2defa189917a65fb0ac0c9dd193a1acdda03e6fed20a1af96fe7d7be1a800660a2fee4bc3b8c1932c602ba0318aa77e6dc352b14d1405cc867c8776e976c74bdc81ce64f2e2cdda3127cc890abd399413c0fde47d75c880623bda3de93c4d4d1abd06356e2172b6430eba4cacbde03b8f171df06afd1e95885501d75ba1a400584c7d8a3ad5fd4e88ff86eaa7ed4f78a6f824c8b05d158e72802940f964b7a44ba807dfd15f63c24c1f4e46d5c36149f252e24392dd6d59090ab6c45ab510bdc0e4e5eb6249e883f45cf52ded8b17d01967a5abdbc8656aa206d99c0d76e688ae70083d3c095da97be3c52db6fcd672c1e58c102087a5abac2d79c7f44c17dfced48d223525cdd2b17c58cc267e42377df2f358c1229041e4fb122ce3e81bc52a678ad2eba81db4a9fbc1d9fec839d2d448a5f538a301b07f2697d43bcf890b909657394eb80ea6d9e111334f074534e3d5b96b7acefd5cf411e8403d21b4ac1a54c10a515f751412734f8dd4652859bb4b07f0d3c3dc3ee959eef64f0d58547e2015405550cc34924d1728449e7e16fbbe2069b064e51e087b799ac5bd0c53ab24cc942fad872c0b7dd4054404f200c0110acf90381b5b35249b9f5c1e300795f33f69a2a880e94ca6bc5c914f297bb4a4efe7921744bf93a59b62123202690aed9a210ecc629cbd62d468df5e3efb11cdcd34cb31038f79c7e849a84f45adaffc4a6954112b10cb3415474cbd06db728645732e5af22674a40738862df50841429a53668f2fa0adf9a71d793c1c5e5a56c417e869a78c8663587594418c2f6f84b8040dd59582bd39612bf98b81dcf8015b05e996fe84630c808e9bd8fa0c96570022d78a01303f0297f9a62e7c07775aa6e0406764c50bbb9e3572df64d450ec4521b97eec4f7a116a20fda0d5a936af7b993af56fec6fc764f928b44fe0ba4e737c8564048365f508f45d316fd0caf925745127cf2a6d58fd74f421fd7118449e1383e8e4c7aaf5236b9f0b98ba532191782eda4c15c707fffc0fd48c1d8442db6ff01c86d2caf379b88128f430419af10f0ae290d71e0e905d7f46087814bf78af530db26d8560178d637e8cd3f3a95c33f1de32390056d3e37db853a11ab505580a9908155a726faaac5c3cd706505783bf20837d2ad9942b82855fa352b4152862a7c5fa7c679bd3ea86453c278772bfa5b50d7da82838ebeea8c81b22593623bb65401c54ec91198583e514c68dbfa156d01a1b259b8c04e0e1bfca9a6a98ec5f38d197381b46ad758058124e171492499d93899b671f4377c873134c3fe2f06f13db182472fb3497286c49daf93aea8f986e23843b114c63376aee45c6fba132ef174c81c02fa504c45d29f43d013bb8f9101cbb3c56760f07de67d877fcecac914fca6fba00310a6b54486d67d505b9e0024d5a4a4f65d11d034f1dee2da815a5ca0802fc1b55aa33d31df66a73ce410ef3f19a5e2f985fdd609b9e5a6ac015953a340f522d820203f9516fb63629e5775e9c59625b9a64df5302eff60af08bd2912d147e67a07a91752d8928a8a2ff9a716d73715aa1fc2f6e4c86db763967d03ec62e1c6a573c1d451b6d7da7860980eb7950c9eb5b9f869b02e576a3d3fb7253775e8c4d9b7baa38b2eaef788ad734d284d024b6551867ce117c4fa72ad7f15854b1b96ccebd00e628baa3f1c252a52a0676a559adfbd35b1a747495a41abc7b2bb0e6c41f28dd53bbdfc6818f2dc79c46702831cea61091b0a74c72370ebb2be8d8e76e489e3e119e3ea52e4548fa639938","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
