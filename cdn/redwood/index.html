<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"563c1d6f4140f3dc847da50be67cd841d269a9c4e28d9e3aeb7d4e820618bc37cb46db4de126d490c0cadce1a11cf797b55fd3408a3593f4d4e3ead494a06525fedcbf3793a95b00a0ad55448c7adcd585189f487e135bd618de7d84154f283f6b92ac63dc5ddab73766176c4e3ab55e6021ae2cf10139c73fb4d36252be8636377f577314f0aef18fa0e909aef3bbae520de92a8666afe9be455b91534889b7eca0d7978fb1a5c87bc42b032cb2c5033946498d8e6b7ac9ab91ce4a81994a3066c4f3498690511de855a1303cd2f17176e552a0087faa5f6d472968422e635ce5590b3f6b79a12223976e1a5f1f90500030e697d81854690c122268547ff5093d05d3c9f8735d45c9c335d541f4fe3da7462dcfe0114b8c9024b66187903de6f75b37fc0fe3afabc34d7cdc335c5043b51eb74eb004667d084b4c57f0c2e62292ad5ed44d739ae92895e4754588aefc7f12c825781ccda411e4046c6c53908134f985ca8cbb61fc999a5e6b4a74ba78b607e9dd572e3f5525d5ef05e260a12f0449c242c2d4bd8fe96cd7d9df2ff0b855af018e3a2cd737ea4bd3e98e81e77da0b4e891ad94863bb84876757e0e9e08490c5e6f6d9083a386d827dd86aea2fa6d6af61d081abd8c71bb31b37820a4ba05335c62274e157d20a6bb5ef18f8eaa02b185b4db74e55f337af2f879d5be46b3d917f7b2bfd34cbe2706e80a2ab222e5d79a2abc9292f0ab3fd7a6f3970579d6ed6d28293dd8aafea0c646aadaf0e48b41127b5f670c3d9a3523551165f72236a95d11fbb0684ea5847261280775ec53334a96b7ac45c95fb5ae0fb29e2c3d7478c571711a4456d909c89c7ccddf34aafec0d05ab1de0339518b428dc9e1bf86d41b81ab09d31004fe4f53a1995ef7af2d09c5b42b3b4bb5b8a6f1ddd128775731402b1db0986033dc47db9b1139a638cc412b7cfc70834f7e98cb313df68a4586ba6143210ae90e625d1dd616e05f8f3507c46779ca8df6d5989a120382b01ef1f9291c17833354f7e17f0465b527498863886936877d1d2458c5dd88340a5b4796aef6766586d07a79ff661de1463b3d755057773234be2b187440c5c00e236da877d1e4a0c02771b825b16f5f2584326c3a4ea545265d1b5cc4a6010e3f1730f9308f2da17b8793aa1bbe4b6f3a8beabf7c033c70cbd7a36310850d877fa796ecd5ba9210aa005de1ae119b0eef02a5d1388dfff9fc5f04e775a0afe6f16d3421e54af4a65ac9c14163fe2371d3ef5526e895d9a4692587fda5548a915398016f75cfee3b02568605d14f1db79fa713b510055ab403f3dee9b180a3cf170e29e03de6b15209a5e4e9615d8de01658bebe32f34a4f34f063f6608a10d7777bd759d54f93189392f5efbeb518c96632e78d1290113143e517ca49b61c1a2f27ffa5a36b1ff1876ab4f8fc463e6579e5a0f144449e1941a254283af0cc7aa58373b0850bf2875968a2c1df484cb0b5f5d106c685a5a2b339a3a30f649e301c0bb1d08b33ef7b3c1ab42e529c5b8a06e08b25737243e43d087c0d58fea9f21c1e4add096adc6aad33b0cf3a4bbfa0818882b01baba9176c6a75f8f1f66eb6297503dad9f9cfac62460284f0e87069504a8eb61c6a17288f9a518a035df41b543eb7d06c5a1e1a1dec85aa18c36eacde5d462e0f9cae681f897c7e0c45ceca14439d16738f2e0de16f1356e377d907e2b526be5055cd3ee67baeb29b5f69f5b00928467311e1daf2f05a5d8a2c4b180045b16746eea34af09101d02228aa25a0480688b208e320d24b574cab40d08f08e3d3bf78b737acf3d311b34bb8873f26b7203909e2a1756c48e4757468a3add1cd3c0a7e22e117044c2d4e38fdd401134ca6c41db7aebcbd4237f25559a8a86caac843d9355c4269c3c834d9580acc09706def5078a7fad07a09b700c4f22dca54d6206269c460a6a050c8860afbff3ad7870019e50ea8ce6ad660db9708e064f644ec8ae4a9c2196828bcb8c945cb02869d1048c08f08a1b3ed2e5f959da090c76407b31938da913bc35e08954211a55fc467706d56c4f2f72c888502d02ed2d43a80fa674a35db0d3df15af57d60d2087b68d5dbb9f5cf8e1f6d77d49760eb80fa889bbf2a9c9f8f6bf73f6fc25acd8d2585055cca690dfb5c8e4134dabebbfec8de5669589f1f1e6c1d1ecece2e6315746dc1d2f1cfdeead57406486d02802ff1b70ac800678f5c7668ff170b0b0a9961c7baa636eceaca0ccaec99824a680cced37b75d916d2278e6966dbf625ba6a8f0a17e33c73c1dda4a94ebbb465693dc01059d90bda576c81f87972a0eddf8856c939a98523721c4871f893cccde65a7ea0b55ec384441f962a14affaff4aff9ba90536207740d949ecc0b0fe90b839b8ca51c6b901cf7d8edbdde569fbc458b930803c144cf85d2fec78a5b5d3386f8c0c088331fbbf5145c35bbeb82b76116a5f02d7c531e06bc4f092e5164450c9585892e0fc6d688bde82ea87e4b4b9713d13e92be99fc40fe22825f8142ac56a65076f24d8b08097658275c5b50b978033888cc4c1a3b2e895ec759b33deb56ad5f5635ed4eebbf79eda6175cca0eb395565287a940dd0407f32bc4eca29be1c89c953f8c879df2bbdea71d6fbd4f77132df5d331f2d7a43d59ba45407a7a572508f97d81bf4cd549e5d421d71737e739097c33b404bcc46217e1e071f8536f540879c5f9973c3a0a3ae0c43868ba74e9e8da76c6a4ff2de7482c0269cb71ab49d5b387c543249d0b8a846195d801fa6f12c49a94f9561b9d8ceaa4a1a53c706cc885f65bd6d244b5ad70aaf944b63700967acff025667e1cff4cfd4a7cf88198170693c2f23fa7020449b9467cf2ed5eaf25cbbdd647a3ec7ffcf6999e2591dacbdf38b8dccbd38f7a2ea17829846834de8df461ff6e675190afbd80cc507e06de6b72aec592d93d6a14c69f07e3dedf315ed4616028f2b7dc5cc15fa493584730996f4ad9ec7e3f22678958eec6536a731cf7ddecf1e518657e7dab2aa9c33eefda62e417cb18be6967ed26628a286a32808838cb6ba2d0ba3de3208a3d0a3610ca2432eabf5791403579228db38195d5d737ab659202220068128e051369c2d07fee9fbec1ca7c92bc8d5729a319a910ac358b6dd1eed92e7108a294765206207c7f1d719aee3697e739174c7dd77e7ec4b7f6b57f2b759ca3257a522840540bf76f78b66075075002c717eb305e1d44e3d7a818754ae9e1591dcee9c3b22bce4a47ab8df1024a5b9d799ef7cf805bb01d3c8b1f55fa1988e67d023c89c5eb42cddafb30b83740f49276f836a8b39dbacadb53be440ff671f8f4fb6a5812ac28d3c29994592876958cbf15926a39f3bea09a5fb7df3c693464d066715b5463a5b036d4188aa36147de2ebf1e5a29250c5365794bd6746b8b462d739a8a8821a589ea13cd69a84a860903fc27b7f8231a42076f375b96118cd85a503988f233014b0008df1c636a4525f5339fbecfe81c4d4aea4931badcab0cc6321393b27d0209b0fa70f8fc3413ddd886645fc32eba111ccdd0f18bf944800de624a2c889dd3cf73a141596194b4fbd98eb4def4bd5500762b49f9d6b9e3dd1cd4da4baaebf36c6238479b4c52e5ffcf45ead95ebb9e23d63c9cc9b91940aea2a998e925b9a35b54ae509fdbf718f4655ad11ae88392df76e2f73d6b0e415c8a153efbe265643c67815e7dfb198f58b6e63c5ed028d4d11142452f257078b4a9bbe162590982a694217fb8d0c27375970fa1475eb078cacc2bbe125933b03e0f3650009a45e0e3f4ab9750d81d449d6c31b624247f0fdce6c984d2c166702c0ed3bc704f182657cf7648ce1d9490518e001de6b3bc5179eb95a254bd7f95525322625e5d4e71599d962caf42789a91bf8864bd79872334451102041c3861285c53cceb04d30a0b14b3e5f55b150dac2030c5f3e20680656a0f37ff63346adc49ca7a4d53b59baae6bddd52f9b73a6fa8235e3dd953aff3a041b4d9e9ea38f0fe4dc98ce5c9284fa0f672710ea15551c08e21d2390a0dab131056be2587ee74344543c0420a7aa76e7705fb6f9029b92da1a8bf215a5149610eb42e32cd5520c25535359985c7bee2181ac9bd32e2be703a2b797c57464e943d7ef7c77020270c375a90c8524e18f828726ac0146ce9c9e50865b72e33b98618fd7d773ca069d501d0aadf20ce9837e605bc9dcd11e288831e2c71b6d7d87ebbbbee67dc2abe3a97480c201a09c14bdbc42eb87e63f9bdaf454abd7efb3259bf85a5bb6d4e201a574f6360beecc443eb69f64efa6e0ab43abc80f7ba2b08cf27aa3723460324cfd4ba78f33971eec73e584f4b7d72a72baea7c99416cc5498492f96c009245ddd8dfa23b447dbb6bfe1a968a789c5dfbbf969bd6c5190fae67eed7e81a6bda727975883d5e259845d029b861ad6a96bb528dea568c92eaa5919e313708986ee24d01b7294a6a4a830297ca463d5cbeef3a21e9a2be7558fe6823d33811f43cb25ced759fd1dd286922195f14ba1d676d537105761aff3ef17ecfdb55a96fb4305b293e2450d3686cc791bbf211c1cc56c4dc39f2f88b04e0f99b8840dd16f2c4c7c05698ca34009320bc162beb46b57a0170f0b2f50036a73fcd7d5a4558594e645e2247cfd12c3d8e3fc543d1952d02104f6579acc61863a9dd00533a1d438489ec5f5c13142142f61bd0af97b2000b4350264f764513aee870d4b77c306f8ec0f7a51ba302cbd84967462e0a00b500adfd8dae6b4e184c45ac8d75eea7542c272ecf7774b208582d1c1187642441355c06d38ac8e640074cc04845d63c288f4c55b78e2a8509707c82a0cefc9607fe4add98a83df8acc3d754cc1ab3da60780172a3cbea07edc2ac6bdad6ce3feca9b1f80ea00e18e351030c43a18ba2d4e9f9ce3ced3ef54f27a50d317876385d4757cb71321f6bca13e768e30f7ce56375682dce6c85734c7716267cd9cdeaca5bcfd18de75b40d7b6cca211b53b1fb15a7398b61476110b703141aa70f5ab4a984eb009155b438918cbd29fab3e7f5ceb35fa5c608eacf0e86266fb15a54b70d8e29bda3f7afd941425d11268b788b6a0ef7f8b60cdc557201e90be16149fbe13977508afe284d8c8987236e4326518945501e49c498d6b6478a3c20f70148958d8ee2301738988a520c9f271642f0afa7dd8abbd6e361581c92845a17d3e9d9df2738eae238af542f92cb703184510464c181501e095918ac5b23ec789ceb080ff55a6cf14bd8dacc7a152bfda9c334d2d12f4ded34da0168386f451449ec4fee8bff082eae52f8dfc7a7075590fd8ea1ef560b0d05e4abab2114f44e6e608f62dfc4f95ae4fd86c1ec0f74717cbdb7bdebd17eef8d5b2799d931e8ce06664d1c5ef8d2722dcc019ca78b541bab918ee0f8b130e9905b758c602176805073f79b0691daa11e85db278c059a9906ade762293d42f1d6e493328a79d0d32628ae672402cc502f7420163ea19323364bf3c551aa53c1130ba6cee8ecb21c0fb3cfaa0456e5f18de64100f1c88a3cc13aa4420e330e2521b365a8ffd0445f342cd47042d9c912d800b8289b35aad0b6ffb38d891b49a357ce9e3c8a81e73ac806e7a1132d29b0beaf7de4e9a7b1b83e535900a853427a3043fa53be93fd9e9ff71c07eaf82baf724d3919eac8fe3ed52883c612923aed32ceeb30a11abdc871e630604e4547ae89fd53e15d80e5b26fb3fb126128d01b9d548d09dbff0f9707371c6c29ae9e0e99b5dd667871268208821473c4d573b9eefe787c85276f56798e3bda537571968422b7f4b69c07442e1e80d35370e8e8cb0c35ddeeea1f5408e15deff33bf5eae0eeb13e6341f352a2c1824cd1c0c705aed4de41201ee0efba292d7bb9357d3c3d8a9b3a7e0d81d3137bf65f6a0c04a7cd267337a1ea6f09b798a5e45ca1fb1184ecaeae83e6ff3ea82d47ab2255a564e39364b58f78f7aba4d0fe5a8d8915cd6107c1dbb96e812881a5bcd7ab6c96993e047515879bece572809d2a11bb85ae5733332a4fb0313d86a41011f460547c55e6f6ea97232422779cf01d0bda1e024d7472f2c8675feea30c687b583507ab48024bca9f09d0c9fe2262d549e7f2af53264cf33e830b012db781083d17dd792a4bb427ba747dde7f6a9db495c96b29113346b33c8dca9b64d5ef7751e8eaf328d3486fefe2842a236bb45706b5fecdd3506b7292c765bce78240a5e68ec4e712288f43da97a5cec62b1c1cd6e462ccb44b76dee416ec53fa930dab4e0408eafda59b03d3568e0cab5ce7aa7d3db754c43f959dd59637ed9d4bf31fb48030e23e2f76281f8d0b27071b5e09c320b9c26e811e21cbaba3c8c654b3f73af5caf18199f0698403c75ebf428db4810fc6e24ab921cbc995467ecea32190adf5d426a6d24da4268fcbd648211e69bc84a8ca4bf85dd707632541c8551c5fa39549abc190fa2c59e40a514b649f6f1f3bca6e59045f62ca6dde2222ef996e9427bc6b576fd2842bfa943e2568afc54cd0e06dfc10fb234a92218a6fd18cb27b8dfad72263d0b2ca08781543b69df4f239a8c4b5b06980b1a29fe85e1d9acb74036139bb84b7d212f28a99f5181988c90d50b5342939226e7ad554926dad1a82a226744013044864367368b67a9b01612e1ec25cc5d5c605d2ff64a925860a4bf70211f90c09061ac231ec717d9462927db628486c47716cd7bdd90b2c5bc27480283a66b34e0ae03b82fbfd0e9cb120a8ba1f45ec5cc587db9148d1d93ecf6c843a1eebbbd7251af2d0707a3c21f8b6c443a53a4b97c30ec367cb945fa1633b6979c3cb93741602a2c0e45a685819eff4002c900cebe4ecde9ecdecfa7f8609ff67bceca912d2bbfedf696f8aaa7610faabc13b87a2534bb2ba55bd75b165b043a33ca8e14162e69f67b034cbc1e2df486c494ad008ba0ea69450b7f05b2bd52c5005b6e15c46a5c88cb0ac08e56d47da06268eba0acedbc97259823650907ee1f7e56eb5f02051322528c14ec0f4740069a3b890fceecccb6475c69bc5a93ac24b8683e448857c3e0eb4ce511f69438184ef6a6939b90c0bf0ad763639c0bb74de70022063c730c3e453667022cd2f124aa36bb2104af172b8a95a1399ce2286c7e270370fa3e1ac753d4f345e960ba834d179ba68015539ae48a42bc6235256ddcd7fd21478b591a41152758a574d824a7c8b7316ebc18435487f7fce66bae989c986d4b1ddb58d391e0497623c39276b93ac2439679e0127fe334b14f8a36ee3757fde0b584d128b107212e938c5ca69199f3eb2a8451cb395c86a0f75c3e97fd35cdfebb5c7ddc8ef70c754f355124ad0864ba226d4add6dd7baafb95893d8b3edc781fbebd9f6d0b40688d998803b7d96c991891d1728f019c44e3baecebb1b0f0694bb4e9dcefe848b0afeb70207b9be7f3230fdbf085147fc3a37c98c7aa1babf58dcf1fd915fb885278bfbdf79ac6344580d1882a575593c87b3b5a9a63d861424085b2cd0fd2d9fffdab644a53e5d94309292f6b075305c617d4dda42e7d18f09e29ca76c32fca54b5dec369ed4de38b22a5c40c60b611700e0ad5a13c6de549ec0c3b40c5352ccf5d7052cf0f40b357c712ac7b81756ccdaf6ae1859b49c873c57db74730a1ac7e038e63c058c13c4d10426753e3184d588165e88c22130eda416ef8806750eb2dd150ef52edcdb600ff8da2d66978e8e257828ed93f75da9410a010e9ceddc3675b76bff4cf071842a70b89fb801ecafef8b540ecc153b9d1d7a014c369309ffd7ce47508bde568bceb62460c8f9445b7752171550b4c2566c2e2f0467c19624a01dc90c3f3b62262a1b986dffc79f8239d6a300bec62cdd7e588d51f08d342673fdc066ce60d63fbda92c61790b5e32a9d650ec8ca5a19cd1113af53d8862f8332d725ec39021b1c0d2dd9ffac8cba3fe4b4c46d71f8bae05b6b4aa713814b3b12ff049005ac5caeabceaaadcbe625074f810092ec7260b663ee7759fa87d992f5501b93daab37bd02b1cf985c87897c50658ca52273629145807faabcf74c35057e8e00a5378d1a8ab9b83b6cc0d6662ee7b242e463010431e8df04823c330e81a89f87cc0d7b30cc8953d3ae1dcb82558a7aa9b7bf219229ede60e7a4ffb3d9809445d3c73b4899f103f5a40463c20e545565b2834b1053df4e65a587ceaac7ef52eb782b3c78c8093d57bfebc08f5af9a7e11b53f022f3b71bc07f6962e7de62b463bc03db6e03a914b48b4e77343ffb4f2986d1548b1c440a7d3629476f9fd3ee8cc5fd7a51e8f4e6a7be58a4f3d04a22a180e6fc5476603d7aa764b7a672dc5556f66a1f30589229db8d343e6a4986ae6b3dc25acf12973168371bc19fd6ffb27427dca18c7134e9feb6c7b076a6643dc31daa9935d770c77906dabd47f85f2098510118eea99fdc54adf366f1850c86f4d945d01f729b15e8506464a2000a9d6f0fed56060ed54f92128c985ad87b226023e3cbe7e0340bfff16761af296b97cea35aef08332fb651bda67ead9926eff781e3b401de1bc542231664b9edc28b89281eb2bf577ad6ffb5232ca8691b3690953dffc1f686e4871f00686bc7a782952156dd54826699918813b5e702916ab63899833bd56eb357ca2baf2062ac21674571ff24ea734c1e98e40d3628de85fdc1ff1c1442eea9123b0d4873de1c3f67ad6d590a0af9f044f0b2e4e0a045ac0f7508778200621ea358b205bd760e65aef9bcc29f592ac91c4735c1966c48959d40f50049a1db7bacbfea776ba01ac3b6dfc65b7a3a357a9903de754ba141e773e82b9d5b4bc3ff4e0d24043bf83f8d05adc2550fe54b9059d75fdabf6c7ef381e7d42498a6b3b1162e5a2dca511bd31a788f08425067cf9ec7fe0a94947d390a1de2afd7452cff229e0ce75b5ca7ae926476e277f54db49b6ca62c9a45e56307d89f244647c668d8a63044e84a09f71c1cb876ec3ae2a1d428c2ca87003d8925ddf5c258de9307d97f666429df58b7f6c85de80bf037accbb080796efd721aa32e693baad5e7278ed171830d4fa258d8998d836d3f5c4a124435b3f4f081da29dbed4666702d7ea7a18273cd438dc3c1d3b85e1afd3dc2aab14c6e262b6a78217287fcc964ca845ed5d66cac176cf4f2b534d3b737cd3ba6ab4052d85e95f2cb7a0a7273977165e8b9cd4405199159c25176c466f4040823ac6ab1eeef61856600fc2812949d0453568915c95969d4ea4fc7a4f8fa54fdf74dcc5ffd6a0e781a3139d83664378af0129a17a34397adad03eb2f1bbc824d2a7c5d22d468f4596f80ed9c78c8db4fcfa7159deb120356eb0dcba136aa9d617e1fc8cf79cd48076a640a31b48f6bd92d5b60b6249b31aa0a6713af4f08fcbe34f357ecf58184a8e4776d2bae6d7d3f693bb057de2b7062c1f187006dc50e7ef49e65d0e022e11f99437834d58a681fbc7e9d4d6b549194078325ba584480a56d3ce9f6f37c366d0ff84097eafc0020edcb64457101b3ea9a9a056e237e89f0fee3d8d12867ccca6e73b6a67512085ac8c17eba7ed672844440ca06fe8af75ccb5083533b00b981c423a2b6605214ebf633e0a7fe4e31903749987ea922eeb07ea19b4475900982d63d25bdf11cfc82f43c18cd619afa31f9afd6d9183e3ba1a3e4b63bb10258a379d807f32e7a46968b8ecca49ace2e287531a2fe445a90e8c151852a0042e6745e24a613521f3bb49d7e89c14956d6412e07659e21a1f2183ed7378572778f484bb811de248d95db4a36d3bf09508004ae1b849d99e43274a44ad7570f4e852e4b01254bfc33da7a6fe29d1d0ccf87b0ab8131f810508164230a77b72d6e9bf20b0315444440026a3e8e5c48cc13bb1b6971c8b7c588d708988f30f507eb7c2d0df0a23e1974fabe2efd463a3885ca0d3d575f7887db9f86dd2302ebaa95f432ff419b1aedf1540367d0e04fc92de4e1719fe90a959004bf957e794a526674dc6e38e17fcd806ed0dd4cef598ba4c01a867c31d3195410b35b0566f6d67eb5d53ef90bbe2fc07aca442a41bc85892a21f734d2a86017755361710764df865c7e4ba6a41406bcec648e423bb9340591bde9d24784e08e52653247c03fb89e402fc62b9ebd66751efae7c686cdb83d3b291dd7ee2f11b4e5094823abee13c32477fb3508819d33630a370327e6a178a6b2e8da52413a73142a33674351e854df5279c6e86594a8dd275f3578b71c67c1b2b5984f09a971e1dc7f4cf5cc0a7641395516ba9b932d5802567a55b5beafd006ea880237147ff63e3c61250a4eec34d69eb99bf6a1fba567cb6e08b7f1098bdff0bbd9a165aaa4ef88c4e702bd63ec0c837d530b27f694fafdd5772d4b2aed0159f0cc6b7561d0daefdfb70e155ad37b5e6992791befb5c16acc86dc16ecc03cc7ad4efa7fc35f1b9aebbdca2ddb8502b943b656290f9c25d7880a615f01c59a62c2fbe28e0dcfea56c35a81f8d5adc16d2309f110e03ca5a273fc3eb83fbdfe59360d7a7ac658c0b8f6c9f96d4bcc19b6dd89f1663898c567644d44367d1cf22517a7b5b2c61066e1506ea371b769baf2b19b24b87490147e528c1c275fdeecd969f11af677e27b7b86d512ad57380ccb4a689d1862e3ff5f60e0639256476ff945baeb214a7747c995b07421e8f8ee10c51a1fdf7b7b1d978b569642253abe485e75657299365af6c8d5235e8d2cdde716f307603cdcb71f635d5b7585b88a54073a59987307a05c4f9c2e2aa46156b2c2de387e89d0a410e4096ca9e141e696f33b5dd0a88949e8376d64562b83cd3a3f4d17cdb8edfeaad17c56ee0af528453f51eb1e2196a92e6d406b30ac3b6f23ba743e51ce6a3db7d608f4ddf0a7b4b071df1628b01b1dc5dd9d0eeef943f71c3893b9e4d16c1fabf85e13d3bb88840daf031443f3466a77f98d507638c524f7ebe164ac35c672d23f9d9f62f800611d82552979c39f11429e1193875a44c7dcd377126b833e3380cf45bafbd9de31d4538a77b8c8f9d229a7a6abb73f2c1c2c8639ab66743b98f7eb40fcab0b1faa818a379340931285e2da33c44a068d06aff5ed928c9b61d6c3cc534a1c12c01e364a19e6e120798387d7cbc861ca933ce2ee15940e3377b175128ed7a132c34b8e908a01e25064e7d36f24cfe474f4e06f899e1fff823fd2699611ea1babae2ddd6a06dc0e1164c0b114aa4e6642e55ea1cfd328cf0a0532d4ffe8c0296398c2b5578da19e15c78f074d8039a55d0ef79d0dcffdfe82708934d57a5b658cf953988696c96052b75786c10307d5382ca89bfad6eacb45d9124af13e09132ae09fa90707774295df356823702402f35e6a64ef68275b1b325e8b9d63e1a625ef630ad155f90d34202bfe494596082a83cee7aba542dcfe20ade2dc2b3eb7d82093c7f1382fecb440f90fc019495b6b4355bdf8383f719e6151dd9fccaffc6461b354501f143879f81a2bdf07cce0811c4ecf8c287f072f6ed70c5bc26a95274ab215b5bcb92a1aa259b0dcde78df8eeb9ab1fdf90c711f1b4ed7d633570522586d50b4c8c9f9c64aacaa953afdbcd2d432c577e08932cec1175667add72531806a7a7e56ad654844d62b1d060f73f1460261f907385d8da2efe6d4edf8b79ea834777b03b38679d16bee213e65d6d734f3db7b82d5f37ae236e395af8d732c8bfbce8a1f1fb652762a3a80307fb31a1d15df22b49f11753be3657b2021840641e468d11ad51b4c4738a2836941b2118f0ae88191d9fab795e09b77dccb28ed2a7f0fa563430cdfe9835bbba7519dcb5c008f93dfe331cd5f4fef97c459a207b49a88ad4aca59aa18590bedb746c672d8e9f7bb0e86b16b6e0c9281eca42ba40ede656d663f376e76eff49aed83cbdeeef9c8bf05c46d61cff341c07242a2b43ef6f974811b34da9b384a48a45a11d5be79cfc3108ed739c9c11f4c5b8969d8f2d02af616def1b07beac5f5ab3ca250770198bc7aeaa44033c97147fcd10975d9281618416b3afe02c2e9eeebf83d3905444ae07b6b87034a57bd45889f6635ddd83ad9f9afb5164b06d96812a350cf1f816c209d504df3c250a245d560725d5a06e6df158bea428f655f87525e5c59b5eec7ba66dc0b397d1dcb5d4e47c11d1ed4b416870d536ad043dc6cf78abefb5cd48c42eab253d6de079134599e6940abba50bf6768d6468dfa74a613892242e73aed252f8e6436ea98d277309d226b5c1a65228352993a8eaa17ab8770257df8c85e135d54942ac07684a4b9d8aa895c6086302ae5366d7ceb9574178e7d3885aa8ed06e503cb7395bd4c63ccf3c553e7da7985237cf5d914eefbdad2ccf8154c22a6f752e0bb7a749078a4864cf53a58b76fddf2a8312c6a41d570b1a6ec24af358a329becafdf5ac1a765451d1f61a4de7b041595276a1c7516aecafc73680fdfa6122af3852adcbf8edb4cb8c4c2892342390bd709fbb6f3002cfb1b6a077526e365bfba34dc35dae4217c1950d76e575af5caaa904538990b41c0730b08ef9eb085eef874d302ea5e62b6b52cc6ae773f8abd59dd05a4d27d0c4043ac69e13a9991296e23a967b9075574c5986098b93a6646bd27b355eb8b2e4cd89455939aadd54e8d805e13027bb9e53e6484aaaa5fc8aef3202aefb838f0947ae7c317bbeafa074e75f4dfc0253464f6ef50cd4b2c182c1a54192ec0a7de1143a83b8d37a5af1842214ce5c63f4f806498af16c3406fdd5c987b3f67243153913000d6ca96e7e4fe632111997379196830c34b535573d5eed6bc1f851628e576a3ea0ec3a952342079d879f9c0d5a139b91b1305bb32586ba83999dc8320a113425d25d802b756a9aa18d1668f5c285d96f94b7d297eef5b32477eb1cd03db5fa41a19c7e2e3112c7aac3c8d1c7f118f1de875e7cf869d372a8cdefedf695edfa3176097c10bc6fe27881f623e625780725f97c74baa92c1faeadb952b81e9dca31ecace6721b7030818e700654ba7a1bfbc7d4348915571ba2aa7fb32e8853a66b786a4386c3f1cb6a81ff8b8942e10fadc6c4277638f384c64623dab4501bd668d61544c257849d9b99c0128afd63ec016c08ac3189a9c23344b3859121eb11f4929cee93068503a9e25432c88872b9847dca6f4fc4e281c95886a42ab42c380657cba30a940dc28ec1bb210130491f87762eb46ccfe1ae1837da28a9b39b57dae6676969b72f9aa79e70f11e61f9efe2a29e0eaa5e38a9c58729aa2f084ca92e87ab7584276021ec5e8bc838a0bb62328ea4e82f386ec705bcdae04d1ecfe2a768a4935e3880d4247d5abb04d92ef7ed930affbd583607f2cf07b1441e0c0ccbb3dfa5fc47a06f407252f9112abd71fea5aa658acea94bd3aba6b0d05b4a4710519b74ae8702c50a89d597aeb22e87acd3d8faaef28d3b3ec498b40f0965bbfcdd26d280baa81919394836f814d3c3e01c4929ad36cb465278cf52e748d656bbf1054dd6560fd5303acb78a092ffb7ed8593084a9aa7141cd68c6dd55118a7a79fd9d9ba2816c8c8395f8e3bc89f7fb1c9a1aa30fc302b7046c85e420cb23da481516dae455975dce13d0d15e3ffd2f350ec15ef84955fddfc967dadaa9caadc197e4ac599a0199ff7b27d93dae9c0cd2aae8fdc462f97e297e77c96a85cdb5d775bad1cdd8151d51a9bd98ce211f16099859d23b60c2d3edc283b60a465c3bf9d3449b507022e03d6c38b07caad85d635730531ab11a7efa0b267e319bc3cef16cecc781589c632f6e145b55a7b10c74e50647299119fef4b3d52a5ff66fc89b06f040754dc991ff1363cdc620204d04eafcba5ee15516b5e17be9b58ad51f86068c773ea3f9e68d346ce218b33f37d7a9f3923b31ad229aba179bdd3bb2c26452e30a6b8a355a57e664f322f3f29e340bfc371bf7d872c5072ab7d0a6abed81814d03c2bba116c5cf96664b39052b93464beed570c3755142bd92e093c4fe954bb087034f8d604131f3837d5c632fa18509bf46e09b9cd3a3036cab2ef8d63e8b241a6ee90eba242a21e2f446104331e4a0e7ddd70086712747264666f52287ebd1303dc6530a39268d7da50ee36b9bee01e8383d7b3fb6680fc6873a98aff479ffa89af2e177c8b94419088156cf4c84ef17f21ec161c7b4844836ed97ae999822aed38dc6735411e9d40aa93708a359e90be255df62e901f10276247eb1f5a23a98a427057ad5d95d939de99116ad7b93832742d382272330a236159aa8d11670f45ddbdd04e05ce97af1c2462ade1b3c1bf60a12692a9941881e90dd9a0f5b41ed6e2dbba6f77b41a39a1f5b7adabfc03dae87dc4f250b7d48de4b160d9e768540150ef6ec4a5e924f68d9f287791ec366d202d6d9fc177da09820de372bb9a5a9b6081cb22d5873d116f22b47903c3c25fc5f9ba18614bac19ce4b514e28937a0e5e0e7affd6ccfc37feea26e78698e239c8689352b6fb5c554959db98e17eca0c9dcb37af673f30628e0bf43c08f8ac619fe5c63597953af419779c269119882238b53215e7b97b09a6d1e1ff2f7e1b427327789c29985e91cdb3652a5c014058d71e101e56b8fa1fcdc62b208fd0f4076495bffc72c35f9dabe419d9a68b831fd275898119f8c79e7c0294afb0a836896061e08637c3341613ca737489d2ff59ab042bf6a5a8cb620eb8750c31f2982ae1872cbc03c9d73b1d309092d348ea78ed0e0444b35f8f6bf6c17254b996149db468eafd67700e32c56cbe3c3054d224d166282fae0812e5ca3a6275c35ac215a2c48ddb15c3ae4398cb19cb665ecdf26b92af9022aa1ac51e5a0ff37d2a4fb90f00b347bec4e759826e23c3aed9c4409711cd47133bc6675e12aae1a06a1cc7ef19621673968d64eeaa881039a3ed84fb93ea065c99251128d656c7e5bb3debde68f95d5bb8ae34d74c1c7a88fba1bb3f647c3a8e44b7f59b8a1ea58ff31f5a89d4d7eba86d7319683b6f34dc01e48e83d7448ca68eb5c593a67a45f6fa9abe0430b962ceb8a085ccdf00f6e113c672673e9f55df0a04f50c4adf38d39c40ed1b2107b6960a981af31b65fdb0c6d5966c114782420217942a8a72d8e17f79354cbbe958f798f9e3d57075eda065220c6c64eb512e3ac62901f3c1372c0ae3147dbe080a3c6fc9dedf8053dde43c466b5b28ed149fcd975286cbd6b5a41bd239761a6986b0b59fa784524d9649e1636fa5cacc4f75c29eeeebeedac4a331e6ec0104628f69390e4a0023bfc392433ca8635eb2e1103c9cc4db7a6d9ca03f00cbd9a08220b8ab9c87e29be9a0a3632427ffbe8febda4fea4193b26d6b2c3316dc49011ff96e9b4495ea4fa8304ece3f0b16e426679eab2815ac86bad639a192409aa302bae5a01c71af4ea6f0b4459f41d4cc5b0c56f7db571db82f5b054cea57fe5728999d289037cc08766f3146f73d731daf779efcd28f7903a309603ac9c3ac82b6c59edc4914d9154722aa1c37a9688eec5cbaba4a784d26210af158b93cccec379d8c30554acf9eaa9286493a4cb4c712c711bbd1a8632c20c9795e988cb212184a5fc92d6f04206344118bd7096db481f4b0ae2163eb99f94ead30163f613b7a5c03ce7b13129bb49d1f472d39c84cd21a4d2038890ab2ada8374f710657b7c6f87ac3664d604911a8aab29e52a33878d533d8d6c23aab68aa9f05fd2afb33a7269b8a9fb03c489eb2a08e2ddb410a0f8d3533d2fbb22795c7e17965f075c42aa01f65a2f499ef23ed571d1a5223f7945f207f8008cea281498ad9b07322b6d7951e8563483eb3a044db6df1f26c009676d85a563691e3b8f89da6bc62571e1f4215b25f9512aee2b529c439219e77021c3e150b75601a43801660f1e62a6a7c7ab0215479a30c92dd3ed713e7b3bbd502ae201ecd87e5dd9d71da21d4477990dd6d1a7f2e3e75462aea6271b4d6aeb36f30605261db3713d9ea01391c698760d2d49c4b49763f7c7817efa330ee192d0b73ee1305674c9b739a500c4be3ecd7a6ca8e7f2cb6c3750c0d54714c2a278ad565fbd4e1ef65059acb6d2fdf990e045044d3cceb555400d60bac67c87b97975a7cde4d58aa69d81cb3a75330d14f86b362266daf434e48eb045b1ddc98353b6337165e6979c13522179068fcdc3b6126796dff5625b954f90207a905624078aaef204208bde527d27684d090c9b0750684b151396777370f6ee3980d0fb013554fdc38439ee9688e60e561c563b3885f4eac7c61fdc461c80d905e7ea8a770794d2fb1eb084426fcd73d9f773e1da49748b1fbd4b80cb6708690e85037e73a51c09f683345484d0a508a82ca564a1d427c177d4b29f372707a828c42c98db26b50b28dd7c1c1b9e1342ace7dcfe5c696eeb258c0956b65a5b622fbfed628f22633d8fb6f4568356e914512f17099f2701f4af2e93973cfac4a5eaca6db0109843bb611ded9b4a992b01ded9da37daad395340b3c652699f9f1fd1d943c1931348af0afdc40e789523f535bde47f16e4376277a293034cdb287f62b9053beb2ed4e99f6dee23aba4a7c63608038d7b6eb802875b2e03b0b92f8b8745883ee811cf77d02dd92f4ccde39b494ab00ad4c01ef666d9c357f425442fc192694f256951b6b141bd573ebd310702d4041c35f3b7346b07fdc0601502efe87101c28d0752f953c19413572ff35a4346180b608317717d151fb6f602c2227e2291e6dd29ccfcfcab8d2358305217a1d51c1217b60df1823eb4d6493b8e48e5ebb3fe89c9ba20b4db61dff959729eaf306b2558646b42446b4a78287bb802017875543eab8e4e491bf6b0c199a6a6288a112a99d97cd9ecdd102365a0a8084a6cfc7fe915d710e9dcb3d832c08ce372e84a56d6cce187ce2ac62f3bb13a85627a2d2af9a8cac285c957b55b1028f75554eaa6b1ff4ba59bcb0679ad5c18677991f6d81e6b48ef6d440104b6c7610a4a6e5879b4830b6435be19a98d497d8ac65dd59eb4abf08120b832063271bf1a9ec25fd9852c36e0adc5b01ca537402df4edcb2bc8bd78818556963bc3c16a9d8201af5bcdc82dd53e7bbd08eadd4625a5877a0b3100ce7db4b2e05d99fa9b26cfc2b47b489b7df0a3e936b8b2b231a68ea4678256a0bffcb61b4c8dca7d018741d3845e535003388532d041a2e1d7f67aacbe2b1f1ac963b47fea3b3d0a31d9383e49dbc60c75c8d32e36c1b6a25f7a965f762f895597f3ef08f31e115f1236260a0a3520eef73169800b744f7f7ae299e5daba8e4f18cb2e540689706e152401c9ed2288269daf4ea2f04f194840c41d25e80c2f6ec9bb661186a28f618c91c9ba18a02f82a522033f37f46d8a8e9ed5a8add612041cfe13718f5265d08919dd2da58ed72bfdbaf9081b6549b2b2d1fa5ff26cbda2d68e239caf933fd619edab67739751c6f5552eb680511af13a778e7c770dfffa635139c978cb43dad2363107e8552d0b1221555dda94a5438f32fdb7d79b322706ce28a47874efc0599e6b64f43faf53c5010c417a85199c200232d446b13d3b7b7885ca5118b1e19fc34fc08d24b1eba4f2a2f2a3caa9599573613de160a2443a6a2b53c4241e5a1d817942301c60cc0243ee63121d187037b5a1ededf6ca6c952395c94ea2ab0f1a8aceb0f719fc65fe7560d43656f6d63dcca4c19797a367f2ef6f84e5f91718da9a5ff8dec0871e5bd3ac86d602598e23e030d91a73d0fc4829d4837a349d9969405ebeef5b651cf4b02655119bbb9e557155ebea734e7f11f8302d44c08a5393dff7bee7a5f29a24e4a399a2813ccecab73b9f6e83abb3d8a7100cc28a54da9910e77cc02be2b82766d44765725cdab2655d66d27d3eb4a9a383886b07d27c937d68b301dc7036b659acbce970e8ee184891c91641efb58a24e28dec8852b7831e55bb72c7b4f2826cb830aa3b7d3dbb4ab99546806bc7c9fde7c514578113f97024c93573aa793a21b722ec14ee643377ba755c677ae8bdb8c42bd8b1a9ebc2a6d18f43ae9fa4572e1d40f31302e0e0cd48b89c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
