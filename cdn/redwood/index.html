<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bde7e06bf964eaedd4834c3e86bd9cc651809f666e585ab37a443046de2ee36b8a2ee508109e98e4726fbf8db0bf7c5ea72950e7de71bb8f796963055c4edd7a175f1f7dc307e6ced7bd42a68f61db303801f7e1c84e498766cd5e1d1251716bc191579d6fa75514688ded95b1f146e97914ebe1b223c69a709ae89382bd88728b58b92c75743dbe155e9f6997812002722f4b27373b6e470a40cf0e2378f63617da057ced10ead3622f414772d09655f79beedb07bc7880bc2795e59d42aca9681e77aba8319aefb7ac2c29c48a4e5582d3906f301d68c543f34247dab8260506d513af6383f1c02ff58fc661e35d8f1be4a62b970172fcbfe24c314c447cab107846c406f8da91c84cc1d673a985fd09a7166b5b658cb286155ef07c7a143120e94bf0ead8dc64c5c24117707a02af722f8231fff98b5151a418cf6707fc7c9137a669b6f4f15accbb416368aa553ed14a49c4f1cc8cc81aad96bac191103d5512ca48cb5b261d52fcebc09a2bc7d10fd1ffa3b243f3144029eec9e9d377f34829c50f81bfef4f5079f8adf7206c39f5805b2fad81b200ea087378b97d039876f7b40ba5f2eb6968f7e2de113faf052893bf6e1123d74512c9aca3c5554cabff29b9b6669971d6e73af2ded46b0afa3a049fc03e629c19624806add57a38d1b60c128c0d8aca93968817870817a15a875bbc11471ead972cc211db2393e3c0615e9e64d73461af1d1d109e592c76284afec83a2b32a564cacf7220a1a45d9b83bc0a038776f594433fb383a9cf780b7cd77bd365745238d83ad32fa5284748fa555d791b0e426596d4f574272f0edbadfd2f06c636f1b14d32a55304c1600d15258b1c217cfa9e37097032e5a8247f165021240b3e8c1452e96760ee155855ba42399c00bc0266cc036da38c964301e174a1a532ac88dd34ab630265edc9926c668466d46bba94e5948309021b62e1942960b397c453bbd0396e2e73915ab6213bf98bb3690416fc6d6a392308d689de78756265c51dd6cf9d44627cb26ee239f7eeba63b77bc4ebea5ad02cf2e52e3dead192cebb29e990f48679523245fe7c441c50cdd3b327f70ece7e6a198d1582bfd13f86a70a64c28dc96bb9e8d8a37d3304615924069f884a87e540b48472b7756217784589b05692d5b0b23c2177a7c0d9b77b951e35c3b9e61f060c0198169e9e92e618afdbea83c2dd003f4edad2e592ebd9a8fc4b905bf91c7296e5a9e6187ab18926058abda27f4539bfd3b7b9dcbbfde067b34eb9acc57070038935d2e3a3ad3c8c4b251748b9c0d46f52cfdda3f59f13950d0e18e44f7f7460acee06db2432bbcf809219a9b6c41c2d1df6eaa60b1c4d71d8fe6c55c90bf4061814420d0f90ace1f9abe6f47566ef00104fe681767b85541b21d88202adc2d961614fd348d28fb69f6856014286dbb92d063a748e0e1e1d32db2bb89d395b2f083272a50b2ba597374d0dbf9d98e807cd351ba3be0920036366d291334dfc1e6f6cdd3913a522cfce45a78ea27deffa0a1aae9dfa193ef84c7e116fce18876006eb4213d25ea649e3db477480d43f37eb624639d2f6795b27e3973b9a2d8638c4cab34daf523f44064fe762dcc4a80343c3c3904f6a249deae6d1348db39dfcfb2bf087a3848acf427ae7caf9c9294ea98953d56c0f255c979b8b432bdc9033380212e0a40743aaa73174be1caf44a7de107e4c33340a91895c8dbc3421802b6997efcad0887aa4699e387cfe959cbac2e285c35421b28b2186abc1fc1a123b3b8668bd2dcab57cf0fc027390618afa4f84c7c42f58360a72db7bc28c63dbbb5a04412aaf3bce0766b4bb6157f1fdc09147117c1204e41c952e19818ee09cad7bea2387aaaaa3247feb87ac31a1cb7d43308927f817a61a22f91f494a7efa73f8ca9aedebf06daa1445105110ca2071ad6183e53337cb426cc98ba1e53d9d9389f19002eb039c93e1105fa87d5ea4aa252c07e66d4dc20a559208d4e9d6af1df12ccfc6ee4083c81dbfa0b4f539fb6255594938734067c2e9fe26495944c7ea501ea52d71fbcfd8029c825b08690932cf61a42eaf30a539bada979fadb4d4b9837ec9b20b408e386ae63d095ac45f9481f3f51947b9de114d4844294843681648fa55b6f75290cc0c013c034a42473825436de0660060fa02d426d73799bfd7870ad2c6be18338f6fe47ea88e5dbcb808b60e8dc21c48fd0b15228d73bebbb5c60174c9591969f2ae44b1276af7b700a1dbdabd2fb9e7fad1286018cb93563bda9758f19a888c43580a8649d80c337189d55bc35b2b16b29448df9b3ba12ee732c3568078e20a4d2f8a067c1852310671bd7706801b300c742373962212f714af0aff1fd4bdd0c90f86073f5ac0bac300beefb6fec775f3369c15441d246afe834c5bbb53a9efd4d848a0b614220ae9119ca28d741a70ca29de9a002869fb05cc8809dc633f55cb31c9e6bac6ae01835acf4f19ec9fad38ff5fcb34ea3eb83f826273a50dcdd19f638f8723c408b1b6fce15a9102874a93bcd46485a7f3574ec877bf3d81c7154c9ccddd0ff112574689950d3af14cf880c22be24819d5a18de880f716f9903732a8bb0c4b17150f203854a5bad4781173e0583a5a10cb23af1ca3d0bf12f8d541726d6834ed879b38b2bd7b55f381c7ff2c35e7a4ffb932811767e7ccfe902289c9cb3b29822b6592ffd43218e27979c1f1cba5a894818754654227d8f9a01a39af54a6ecf10c6310a25594fabc6b4d8d3f0ee680f89492f70146ed57b9448e2ff5e7323fb0b15ba6c32d6d375ea80b846766db36197884e2cc80c7b1a06b754b62dc76a66ad8d97dfbe26e543329aaf85d72d49d7ea93c71b4bb8976e23592edcdac948a8f32c919e3ad88de9e2ce032d49b6d05dc2e4384c629aa2845d617c5cab49e8d5299f52553d5f257466bb532b3f539a7d5c9dc11d82f89c51caf02f6098772958b9ca598b1a18d918609ef1408ce302a911cc7a02b104e66b286c5393e052be02c8af7451ac035f90b7dac3e63b1fb091afe168d783177e99adfb6fe1524a5974a11c02804ca63bb40a711aa341906d2274fc8b5d5b962ac4ac749972d7d0cde46a5485485ae900e926077a6866557d95ed699b1e23be6e602dfcb0962687d7f986b93d9993b30a05977a281c1b59cc7363756f42bf3dd6f9ed86dea978eed0c82d6f779b455d6737e2e9b70e6ad9a3739893c98deb31eeb0b65d644fc76490146e729e51edfb17395088f659d58ccd8960da745ed138424ec69687eeb634a307317f690fa6083cd74734eb48a8165e3164ed6ab8d33c8ed89aba5a9efd1e6badfc75ca55380eba4f2bba4f0b1846a575786b3f5dbdc0c7870518e5485e789801c4fd424d024baffd10a84e4656b815758a498cc13b4bf571beb36f93e9e2578df1fe47b9fd303c85dd9c0d5dd6e609cdee4e20f5e27361cc10a735de0d14ce7e2f4e448ec0d0f0f353a83bbf3a22c0ee7a54d8afdde8c7ec7aaf4f2b34400b52ceec92595f5d83abc1b8dffd213924705f6755e690c9ca0b264842844c35870775e3fb28fb34c710d8e181a2cd40661eb41a36c4cb6a9ac421d016eba31f72994acfa88d01ae78137c5c060cc55217f13b8dfb537c6beda789b7b36e32a00e980f3fb0369ebc666dd2182cc2ba6457456657ddeb06be22b9eee51a1869117268fc3c275e204b121267b84c72e32e5ece031af7df067ef81a86882187bdfec8878f822ac1591ea5ea5cfd74602881c7813075170c82bb1d2036a284e2ffb037c7fd10a511bf96928e3b23a4b0bc5db1ebe09b36a0047a5e4b9af5853a2e107046bc9b17bfd35faab76b8b7cefb3891e52f78cb09cf7032382db544c19b006df7d9387baeaf7d40dd5ed15de7922db6336aaf035af28f2347d23dca9d83e45e0b35e46d2051682da51a2aba361735def43ef673e05c594be99180148c489f87f863b4201073f3da329934dda1f963147612faab03cc3913fc018e8e68cacd4dfac8cabceea839072e12820c02324bf073688fb3cbced55213da1949a3d265fdd6a91a031e6a9510982ff38eebe5976d78f3a82916d18bcc874cd8c9178ab56a2d2b021bce6da49be5d74a68008e295d9d27177f30fb3db1a7611603258912d390dc886652ee322a7df39ae5c2e95513c5b4bf1966619847b72eee6860d85ee744e475768773862a8d59c44ec87a8f3c761f72f10b004121ffa296c56c521eaaeab30ec1f1336e1f572a8acead7f0e1025e87a8885613a2c64b816f08f8af220c5a190001aff473b664732249699c3f3ccad44110ccb5a089d40035f8f4be2d88136baa3d3b4393e7b9d3626eb67578229c926bbf9fc23d8bf13a9d49d29109cc86d6a5c557b2e2985219e1f9ee76d72445cc11ab23b326822c27b1b24a5b14eaa962bcf1c41dfdc793e69d94fc43f0d501213d2b6ca5137dd113b3405854a127615bd076c896c866d81c640f1ac68a309e5a27d9a3a656967f958f5b396f1fe1b88bb5a9a0eb8e312d606e6856087cbe1c7d1fa0fff21fabf4432b48a3cc83a84cbd7e4650a25a74358f83438ac6174db44618b0004722d80b51c35ac52f10e6f25edfbac0c7936feb16edea6700347790a3ccdd0babf5510ffcf61e98d1839b869a427e8a697f871055f594f0cdf2d5f7345b195b9d95d0c7b6335ec7a03645b2dee5976f23c14543506d78fdae58c5aac86ff37ce5655d010d001569dd7a0d109414d979baa05a5f61c884b4503fee975c7cba8f393885dacfca4902f283e82ef272f969e262d704690a35913737460c10b71baae320fa7a3b0c17e6132518b4562fae1bd334d937af234c9da339f50943b9e000b8ad74136bf8e6bc9d27ffb24246a38bf190cc97f33c9420c03dc7280bc398694a2db78cba9aeca7961b93e2afeafc4bb32f420a16433febeddd786ed93d5719a244eaee683d52ff3ce8261b32a3feec1c035121f1032728e56ebe4b4be8124df8ca8ff3a620b333d1ef30e7091811c61afe8f32683b0e89481055ad699c7f1ed7c32426e544093306f178524842d2b3d60e570d589a74dd15e9472a478349a93357109c100ebf6d3e32ab67f092bca56840abeadad19a3c6c0826338d1b08a239792771a18f170433429a29239073e403e67e37be420dc036ed48329ae1a19cde32f208924be96efe735f53231a4052a106e5a3e363d1057dc560638e88c71ed67eadef639187e06c0608e2e8d04163088de3f5bb0df5a7bde39799a15a765227a0ab4a96a9dd278606f6a0dbf2fc540ff1e814cfb28db55c106fbcdc4915cd391bb4b7e50decb96e637622f38ab53943a09812ea25b40fdcf4ed6a2d4c84ad6705ce3b8f2e76901672956f5e88dddadf61b76da04a256159c00fd69a63f2deb39946f5f83a37ac8a4b24c2106ad6555ab3f2e9c1c974af5d89e45672007579cde8b7c843844a32080f14556994b44ef4a1bec2e4a2516d366b59733128a92754aaaba8d605b2bbf2fa87435c644cdd916354d1b4875d0861b16644ff57b7e1c0cb6761f1f9091ecd6d5c9a0468577f5aa551375420ef9ede9cc5e85c720a92724c1649992eac9ea29fccc0d3745ea28823da4f78313e67d46f6b2f2b47b536fba24bdcdc7fc1571f21dd91cd895deeb443c711ab55d48ddccf157a15f95ad5fe85acc823680aae56b743ed233a0cb43463898285425511f6b965b50deb94e24d08e3f2cbee88d43f734de5f42e8125b76f7616012fa197244ab5351489236db20ec1f06d0f25e51a5f41e244f35a71a988e0f0e5fe6622ccd76771a6da4a338fe6d22fd491e6c05045a92b16b3ce0dd4cb4c1d418ec643852f63b6440d63e9bc257705237672a42565a7ee7568998afe55b6aff2a0020df3fa04d25719022d06bd48525f165b538a186a945d0a745348dcf8a81cc46e0a4e4a998afc8cb3b12a2e7f88acb03116cd9f209bd43b41be3d363139e186306cd23a286ad1099c8e4851e757a822ae2c170ac28b1f876ac1842f79b90d07addfb235b0185ce967343ba30a947c6b66e51a2a8447b82e9cfc551f70777ed7702d834e82166c32d77998833725989adbe5e03997c482c4bd4ddda73fb4336b2cd54553b4505a831548b685fd083d876fff853ae018990ec27c087172336aed01facf84d915c21c8596751ff3fa9dc86a5e9c9d16cbd2cce72c724af5373be1d53b6dc3ab7cb489af992dd24a309413a92aa9cb752c79b6af0aa870b37b9f152dbad9bf7b3525f1e493a6c8b5fef74722730e018a002e982be7c095911d1294bf4d69b235ccc879e3da5dc9b59b161ad1c2d71ccd8d3a9f475309f35bdebdcb8282bbec73e33c21a98958926a67273205ab3ed975d0ee4825019c107222ad1c8a48cbf732b7a486b406bf2260195564ae389317df367778df7750c48317a56162f971605284327d2c0d824cffae0874605663116627f0a1af71aa8200a248fa1ee2dddfe8030f102143f9731aec45c6a8ade31f20a08d8df99b7c949f7434cc40f9c2a14f702e6e74c3073da7f6437fdba0213ceb62c2974ffe915b54a9dcbb63bbfa99e2414549fa2c1cf3c527f7f52b4e580138bea7c34ba007db7390224156deeb2a6dbd677b5fc07d0b08eca8f6035d9f9a123d8095a6cc1f22e9bce3b04c967a7aedbcb980ccb233f03b3c5a5a34a2de242b130fda0698d8c3dd44b65a53bdc3a85b31edc84e65f8f2168a61d1f995bcb3a05b4a768816da0f7bcb13daa9073fe2cdeaf38cdb844c894a182a98908e8d7c78f0f370fe241f1082d0b53eb36832522746f6567de2eeabfa549fe8dd524e70d592f784f6cc2b93a1e0025351027ff04fdfde4ab3049d61506e78b5ca1c3365b96498f5ed4128de8a779067028e47a77899771c428ab37d339a09783d5005aa1dfc4d8b781aef240dd1133eb24779aa20e0ac240b1c96b8fb8e95822ca4995561d6fc995b7c185f7ac0f53cbf98ab8e9fc0b565a65276fff81e97cdb936afdd4e6b4d5125b89c45c0e08e84c32558258d319418efe45d8a57c07b850ba83a16fc24f599a0870872bc537c246d464fdb2ac35a9bfeae7fd6a1f3ba73366f3a3bc14f9d48f2116c0bbcd1f2923c23ec362fca7125c0998e39a41aed0d0ee185abf39d79308f865be9a365f80f974ddbc2a570d3a95e050cda2d400a9029ab04d8d68c7c57689d1caeb9d98e4e186a446de8a5d7e493bd4c116a83a6403d0e0a1ab6dbe938c73f23f458222c00d6373c87f46a13e7f012733977c17d9f3fd2631a739bcdca0c438de6936d631eb866038af4829bd4ec620110bfeed0e1434e2eb71479c2f428732aab9f5402e1152f5dd3af0f945c13f91c090c4bee730367c3103209d8b5d8d1543b3605b7637c4e7840659f9a1407136c31bd96be6787ee41802eab3073bc4ee3501eb582f5dfd60ef3b95399ccc72c6a10354a7df1fa7ff98bd668d21d87a2b356c47d0681cf2f7ac92abe8ddb9e8620e268faf3c1ef3ef2bb30debd161ba75f4163b7000743b43652de64af2327845fff2b5da3dcdde48ace49bd6eee0486e20f95274590315230a942401dee0dd03b80ffb5160da83b719a6534c73e80d355d558ee422f3fc3cd74ff54b039cc1e2b21790808b6b897c37a7a586269c0ba3c35edf4978324495b2c15da9d27ea3b94093e3cb10e1c08bb4274cc3fd9464255dc726b69283028d4e36dfff43186756119e8d0bb6668a540efba90fc9180f061de240b563721e3c1e40dcd8215bd68b9dbc00b1c44b7cf4ffa67a1cb830e0f8c39d45c40d05a501b6bb9b6ef4df846eec35ca6d760d10c59f0c7dfc7bb6e19d5411d0bd8b2a34cfca7bc9ee55c75c44618b36799380bc29e3ed59a7b6f61af5bb4f45b1e980df7671b484c5dc2806b61a2cdc3811dd7b705c68352ff6155285c7524429bff1bb1454b81a0f69836544f52bf8c390c62b5dec6e8e496a7a5c62a9000564988636ab111013824895b313eb1de97d1f200c01de54b5e450a89ba388d80ce5927bbb7d9367eaecf28684de5d0b11c1bb5ec8174547175a0875b242dd56085df93597fcf220a6dedc9a97c7cb44733da973ff0466ce1962143686f237f4e9710f7f09d9be85c5494bba0d70f3c3085b73460542c011864fc9b414ef5e67f902415f2c51dbb51329e026447143bc27d75ad3c519be8f43a0d4dc76590449c1e5bff80c24510cf40ffce2067ba921c2306c49f9be7ad79c5a112f1fd819b3a597bd1fa2a2c0aebd515988757279361c12fb2d069026bff53331b65199122e8fbe326b0bb74d1f51bfbbb900ba86f5d41609972e453f5935e4e5a703428f3b209f0cb4da7b16bcd0fc2199571b02912647d943bc2f0b10991ef8bd826af1e1f5f91ce8c75a0f2ac9c4067dfcc710f7c06b2b3c0e942dad83473a1fd0db7c0f6553e9956f8656c7808fb89caf1954a2d29849e285fd8d1254adb60ad3c08e6f18038765d1334820040800fd3bfc8a0dbd4b154d1b861bb856df15ef95afebad1d6e21b9a8e8721fbea7920c43afe8898e224a2721d4bc245983c0dc358cc3c7325a78651a494cf835cf144c11599ac956ed21c3e31ec31e3f8cf78333efe18468799e542b4784f8e0dd1fc49297245dc19c308f5cba37652b3dc0bc4204d2ac47065e871a32774a212ef842e6ae22359d5cdbc689d49d51d5d5c1dca640e7d157a6da71f452d1a07a6896ad0b73d06214abdd6e48381e86fcdb2fb04254632d29b10064eb4bef7a6fdad1211e5e28dd7689f3290f4c23b503729090dd2d6f03d8e096b11f53f028c7d281da094abe519ccf0a76ed392f0bb5d12fb753c9cbcd42ae885fe44a01f4b181ab38c1e0b5048bad0a771d58475060b8e9b3ce4599ff099d1a0b5bef4fb481c46cb8231e18c16207ff59056e714b943b304c6194fb0fca2c00ad551c81079e034c9da4c6943e107f40d3f97e3385ff5afe224411830036792a00bcf35de8f1d300cfbf9f8f5929974b631b5293085ce2cd8db846ddbdced02e6d817a1f4bbfda21829c44bfbe947df293dfb9d3129b822630030ee400a1bc0f9a163136c63a3c3bfcb720aa8b31e3ebf7154686dce2171750c2a91e95da2fe647918cc1064fdb50fd0b53f42ee8ee2e5bf2d8bf11d0c0af6a7a9add411daa5642b994e75728648df54701fcc10fdbdb5f05ced5f81e2e7a3e1ac4a26f1f7482b679ac69a08dd7eddb33dfb9445f81be8f8e93e42127b03dbb9603fbbec4ed0b699c5c6a016d7209b4f74178d2c2314ec37133a2b7d88b6ee74857a65e9d574ff86b673a1bf33afd51e90dfbf5b4b78ace156a79fb1bec51edc871ab9346d7e3b399c235d94bc7baf6b2a060a1eddff8669b61c1211ead3bb5ef53c97a4ec935772f24186586afdf8927137bb1eb6991a4175b10387ba2f963f1f1d4854b5111368efa2d20496d61e7e0bb3e6f957a5344e6b3da31e76ad281f2546fe07ce36ff34819b150828c98077ed8776f601a7263fe9b22ff7088326ff27e4a44ecf762ade73c5dd742427414d0552ed57addd722b0e90edf4dade91f1a6e1add74d5200b54f76e57e1b86b62d263a25093d6215ad627b7e46dfa1aac5aaa1e2016d9e5d431e0d11cdcec90123bf261f7d9c6e2116be2c31baaf6e7b130a00d522b5eff3f18ec524577c54e18561c0954e30caa87aad20ebb4bc5470967d79f16d37661e459618687b9d97e0210f96913e227b7f7c8c827392022fae818762cd2239d3c93c4be0f9e08b98be4fae802aee66fa3b26a6de31637f624e98918f024195fd83207f7f89221d7c5a0724feb6f523fad74b071741a51a2d5dd2dea2f5c40102248170fe2778763e24a8dae2207c6b30e60440bd37eae7fa3db1bc73df666f38a6daa194e705733e9bd9ecdab7c46afae2fb6e3f2c7859edb6fbfc2d0c37eab2ac0769d8c9465d2b158e5b2c1c6551e25024315236686cc2b6bb2413e28cb57d4629c103c6476f0fc08b4b978a9d965d58d562b2af0f3f3dcbf78d7a3b2ddf7d35c1f38fbee9ed4a97e30ec4f2e2870020a6d2b97af35384fb8cf3609924baa5746b9945950b580144255cc4f3f7f33aad9f1170d77acef2c5d016db4ffbe4ef6d28271f9ee710dbbb8497ee10e683a72876119c9753b41fb846392ff57900337c0ef19bbc200fb5ef5df86137595de300cdba214fa0510405717e4c8097b4ffca9f1b3adf4ef014a666fe272f1215e020042cb6f1e074e93f95ce82b3d0d86364b1544df950bb45f5f604cf62d0976f91cd54d940a3be29e2380b97dd7bb2c8f4e321f4339a68ea6ad0f7329bbdb1082d4e12c74d012e76b362c44f9772bbd498107d9cfc596434d4eb58217cd3d061d36364d60f9bf972bc2d77a6e3f7b15fdadce4d907ffdc5e012ef90aed3bffb35fa14651c6db41769c6bea1146f1f107943db4b9962f2797a4ad246d8d6012074eb480389a62e802c3ddc69f47b1ecd2eaf388311f497d241d433d9e4484e074b83f7da486ef0e9785616285169540a678f0a20f1468d87f7f3f8f975ae2bff254d1de7c1cf81ab10a7ed4f2dd15741bfd8ae914970578c0ccb9a0ad4321144498e4aa546e5f75c25151516d086163ae90d36ef9ed60bfc6daaab7e454ac7da32235746ee2522eead79e550d0f80c9abf49453ace2b7a2117da3c3879128a8544ab3455350304da8967b196efb5b5d96ffc165663fa5906fb8635e88bc145d517d96afb12c6446e17bada5e3023ad271dde12e95f3ee5ef8aa53c82dad947e58a1c429a6b919a59a7b9bfa2705568918064fae27b9334dbdc9c1304595746a9baf1209b2ef38cc67b216963e71cabed0b0a52aaaca80017caed333b41cef053adade2f24f964897bb4d2f2dbea22ac2125749317e31ca00ee7c1f5a02753581650e6aa3619981616b6472b8e1aa95a5684dd9326fd419a0be1b1a0cba6dc988826db182cdb65b0ae9cc797ae56bb1247755e15419cd56ca28bbc972260a3a7b485bafc630cd821723b5510f200871644d203471e4c0911ff9bdad8b3b401fd886b620272345117358b45d7a7372306f7e9c65e47ede88b9891cb891a7b4a1a75b026930f2853551719111f0604e71a4af46545309bd3cf71ec959c0694b62364d4be8f9a8dde44f5ed4e58c4db7013000f958a35ca353afae3db76f2a15c59044890ed6a0743848f6b7a233ed5520dca1826e81ecb4c8d41b529a2523f61337474ee416519bb0099bcf858f2220aedd160cefc0add3ca709508f5d01449da42dc77a3d3bf0bbfb31c82b99fad109341652c31163679c45926b74dd6b00689b5d02f851f360a73e28facd146d7bb6c1a67e426d36e0cd02e22080fbbe071d9bd5866511b4f0c6cc38437d3f321117b01c5d95007ba26711de5a7ccf6b8a1ff87d55afcd6faba379177c59728195d9a8c021df2df18721e3600f61312a44a695959f127178cfbd56fd3f1aa98ce4017bbe656f56116927491b978318b28cac33dab8b0a764a1c29b2d282a8b8d632130c60a6ac7ea71dbb2f216783a32fcb541870730abe465cc7d128b6dc6fa559e283c381aabacde6bc4f50f4f36851f4ad9ec6eaeb1f50f047a72016ff9d5c3a461ee6ec602345d707ced085862bf305e7800e4c68671523729f8ca8e4cd4f69c653e8680f2c874d7f59e00e3d97e4d3e8630b7be90ac4b49e022f81de57d738d30ae5cb23ee0cb56de7cbe0da18c8a23db7a3e6c4ab076f8a0081bc29008b6b02e7efc1f6b105163bf8c99b5ec4bdfebdd325489008882cd070be1efee794a75efafc403a6bc9a9f743261bffef03b9965c316259989148c7ffc7e8788d19e497587595bc55539aea002aec9b84d951c2203168f60c4092c308a5ba88d07a936b6374d7d63d7ef816af042ae71e20a121137396cbdcbba05a60bfdeed25da2f71e9900cd3301ddf844777467c4c6c55aa4e7cb5be2538252a9b4a7e95539e0e4f12f314c958866cded69cb819c3979e7cd951b1297f62060aba942e6d8a816aec4af7947d1766486a0dea079a2f8f16812a4f6421d40ef2bbfef8358774faf59bfcd4de012f60726e791371963099bc89ae3dc487f7f6f7f04ee69ad46c1cbcd4fbfcf8f426ba541bcbe53cb89b5a9ba728311a15189389ae8f951c54c1bc9a206b62c5525d5140b070509610f090cb984d5225a7c6e8167032b3b0f4bb096ce9d434dae2f9b087eb9db6349d270c3e48829531be4dc4edc510bab619a68b77f263e62ac3e63a230bed7e0eaa11e6652f0dc85ca2a226100ce8348e6a57aa891aa5daddf201087073cc707831eddafdf43072b8e94488dfda52f933bdcbf6d2abc5f7076228ec376d54d3c3cbf7050d02250c19da1602c5f7c2ce6cf68af0a7c274666671999ec6146dce5cfebd94a2ede8df4cc050c2f70e7d974767e257955e94e1b8633c316e3ae3d1c96cfb17eae7d9109ef0558193590a4271d418e0e35f1a08dab7c426e39c941665dc96bc8974ea2e383193bfc9d92e2eeab2509beadde7483fdef55f24ab877842f1e641039272c02507a43f2dbbe9a3df7582d246602ce2ad5abc4a43568a106b7bea15b7473e8ba2f5bd81d2a8a43b659ea232385614226dfcd01280c22ce28a53e562bd19e6ee403bff27556962c68550ff7b86c017f5facaeadfb1418db3a164e78ce74324a965b8310b309730ae5a82909b5b8d63ff64c1c0cf43f860019e9bef9b3926585285e1a870ee188b1f8549715a70aa4ee62c15c04c85f7e34162dc4d41b13755c5d73aa490c397a0bcfb0e9c6136d463039a2cbb5349e08be4594ef53ea1867b6f40111baf87950de458b1ad9ebc7c9c7c76aef28cb7e7eeb6f590885066503df421984d4ed423f0d3ecea1c9a9b8396a28e980dc949b08370671111a3cbd065694feb278a51df78f347df0d252159b6e2dc4816bdc7986bfd300ccd65365ba2efe27c3dc80198effe9c54c23a034544a229b3a19445d77b02cc54322eb65602f80c9380466a9f8f5d961514dd4c56b876e83cad3d8237833fa0d01a2dbc34215dab512ff5a12432e99c4bf8af8c3bef651e57a74bc3eb97dd416fdaca1ebb0966dd50f53d3d4c2596df35590529ce4dc6caee16a5965021563a23d599668d0e5a4210fca8d44f45f641ec5b25d69135722c08ffb48796ea880a37d4b48d0c7a2177862e761e8f3f3d9b94d28e3c53f6de9f9051d478e4ae809da7089f472277fb6e6b1f151ca2bacec41cd5d0d9268040d1e615f9a63ca893d4abcf54e996790c3f79859096ce75f3a94654cb500c46bab36994329fcd6e39106ef866a46233ac2de7b80add6e10fb2101e31bc479d6f3f1c42687dff9d50df932256487f8f1783b13befe198ce18576fcc1e5ceb5ecd461a4400c13f5f2115b3456180c6d473afa63e699922202baea5d5315c1bb832b23cda6b18bbfc245d0f3fe73802998b5989523302e04b226e242a29ed80a585b2632b6977b29f51854ee76040abfe0b56c1f53ea6620e31c35c6fc6820f1fc71c335d5267e79ff3a6e20e5844da3e9001d6469b783cd45b5ee9d435b7e08edf14b2998feac4f4997a2f95f925110902e857c27aa67f876922b9a1002af49a405f4c069baba4ca10f80b3d1bd7c3be75bf134b6dd09608e476d28f7fc625ff423b816739e933939cdc5cb0f309ddbbfb7ca2bb86b5212cbcaed825d05c76c4ace0ae07eabcc6e510f69685050ead90be6e7ca047739ec93de545115fde967ebc6af3b4018def0749b393b50901620cb40856bef1c09f0ad9b0d251579e315e67d7ed9d9e446f46476206befa0d025309f3f9112796920531eb2603fa9cb775aa658436b8db22e75e7a39ad9344d25308f98b5708973ade1998220c18cb38e7476100a13a922aa28869320098a2ec828f5719031bc62510a02e1e831d5b97d1bb4c9c7dddffa96c378851c5a3ff32756d5cd7f9d2925781bba6402e0895e480b6e32aa0fe7e564d57e19a16cc385b0b24d0330930ab4a2e637b446c997971f41c4df99e1e136989753b41d5bd22cb86442f4c279b62a4575b46630319ca4ae5e5d0f42ead5d682982025660afbc3ff5bbdffc7776116ad579b3db5abd84004950616e9ad00994a5d4d0f08647a90d1cbc7f9e9ce819caea157421534544d8b4f65bccd8ff835fcb9c6771191be0736b452d69e8a4d6edcc075a085ae2d7dcd80cfe913096bf599b51e5f82cca9f9311d26794dd21a796845c5e120cdd7c749d79c08661b401a5ce28c760e73d87e0f68f5c7ce5122c93d9f3bbe0ce89e21488d1f8f86b4edb68715a7603a143e8a5af685b7f168b256744af9ae65591ed0daabb85e798e572ece8cb0210a49b1504d3d35d3bd8e75b13778aa6a4ba8970792b1acecff0e75e0a2234f1a3910b224b3eb99fd36f41fab1653e59ba7cfd09acb2ad7a84bfb18cb7ec08dc0cba4656f1d66d823f6fc4d2163f155a2d17b0a112822c699efb22fbea9f53da04a6d08f663624dcc628778e0b6f177a3194cb8e01322e1e0d25bf671845ebc13a11ea77c18ba4c503bfd82640a2bbacad43436696d9eb5a8a6056c91d002e3a218663c12bf09bf1edb08e815929a5fa47306973f8f68269c2321eb38bd56e4c1b70883d8cf84c0be1b58e9e18b11d5be7fe05edcd575d7d75b736494864ce29915865884f4983afb49b4fac23af1bfec1bedb2826cd1c31707586e774e8b35a7b27e163dc46bda6183c528dee575e4499f530f30eae4becaed5a713ae01cada35d3552b84fc73a8329fa8ae19cc371fbe44f62db01e5faa7b3b2382088b40ba4636d82685a66129e6d7f8cd53b9565ccb7cd44299bb6fc1065a2bacec399adae4684e5388b1b329a8ad4d3dd2c75a2c80481fe1e7e571668c4547d56765fe0597cf408f8d7f1c3640e58b96329e8c22713854f5b80e8f7c1432f72b504208dfe382f92c1d8b45269935a5cf33e0ff1447427e5f743408d575772c253a4a68c39579494763bb281420826544cddb793b4e02b9026af1fa0a0d1cc1d1b15616ff62cd9821e32ce2af8da6e36c28603f14174bd83c16af1bea2489007d92297b50f9d38ac44a9233456cc1e09182ed216501524a0581d2b7f53fdb09963fe7dacb2a4b2e5e706bc8ef519c53ed92d6909505739fb8002dcfa020519adca707804c20d4d5a62546fb94cc3a2edf549fe3f9f101e2f3a4ae4db7b076d351bdab14b4b0b2d499d569543654bd8d7624f116f532fb77be53d0b635c71804d46276e75fadbedd31325e174322a5849a2bd1b4c53bef30d79e0aebcd08515125d66f538e8bf7045fd80f481f4d64516604b475434e3dd3781ee1d04a5795b0918d036c38a1be265a6b98437829f9330533394057ef44af13c6f1b29c1228fc9371a8243d51dc447c88aad8fa83b69ac373b329d72b5ea1b2a5682e5d4a5fdad3eb098577d9c245f813af8e501051e329035b3ee515aaff5384365efc0f012f2bc1654127f446d140915d67a97f57d8b213c540f2290fd091dcd12e8166dd42dc75c42e65475720c7ec66086eb49a337c930993fd71870536399eebd9622d9614e60d6ea1e1560c5750f226e75630d29b7a503ece58a55d76d223b343cf5a6fa8495be2e095c704d1a664d62769cb5bc766ffb7eb4cde6be5f521080f3a8249ccba9df1cf3455a16235461d44aa46ad17bea39ef9c7241d754d1facf668252be4869d43bc173dad426a98d1dae44d339ed02808d032871f30ee758e5a787d5bb2f48338ee9533af447fb053a98052e10a51de1af0ee2a4dc98ac8f61e4f9ebdbf9481a9c5eea7fa8f889eec6ff6d3b20b051d882e6bad193dfc6fd8ef398cc6fc9002388b309bb5bb7592347ca2759d4945e7bde23e27e52e2b8f17599ad7fcc2b6972f3504a265509fd593d598f8eba8fd9ae2c3bd0c1bed61fcdf343bccd6f643a00087041eaf768752349718db54afaf0f0b0624dad5686a56a1a4dd8d6a8a5567077bcbca03f4ed7329ec3465804dc8e3a081408c446a4ab2efd11dc528cab0a20438cd14140c118a33ad2fe1773ad0bb64edb408bfec6eea2a0316f3e44a2d95abcb7c1910c6741c2221f59d8f63bf066d1bfb5b71f577396ac98f13cc1edb5a69a5ae0be10fadac9202ccacca71873bb2d7944643b39718acf31669e338246215872605193ca380ba2a448e7f6945c788f885cad361bcdcf62da21f6d42e724e02f8ee8eec90151be0e5230a4b3a1faccd82b24741c3939cc6370ef4b8ccd3a27c4961da21f51fd282c5ec0bfc40206d55e945cdec2745ed5d93a377d62be07dcb40c4ba3a69294919540d61dfe7a7f10f74a2e540ab72229d23a508cd6776f0408614eb612dfc1d2b1b76ae152c6c7122621c254554c69ed5867a5a6097cedd865c9ccffcea940893697d87229d1848aeb7de5d6691e0be024840132b52352b97a9ec93d1025fcd6104020f60d70608c6f20753e05a4e11ef93043313ede326aeb0bc61e7e5fa6210770e81ea478d03e31761d56fd67287e546804d07491f640d22ae03b59e7c1b40d999c11fd651c086b329392983baf4113ae072056f7b6eef5eafb7fdafc4025eafe4493df9f201db69363354045ac553d0e09d3c210697d2a7119fa1b97144721c193402d992cf51240462877ce8cf63040c1e4918309c5d52e843d276547e601976136e66a5f9c7647247d44f99eee44287d0462b7947549ee1b71c7f98ec44a8191a651761f8380a80d5b80122b2f7e633df0390d5113df4727f2d207e59a58087cd7dbd695f1e307ad97d12d3ff40d4e9cb005722942c190f8f8f208bc8acc5a7e2b9b91846c8f0c6efae6ca7b82e1a1b84b0ace0efeb969a1bd206e7f3c2dadb9d51ef365ba7646e99f0069da444301ee4a9745d43531276d3c293a85599c415f78c4cac045ca1d6d2ad69f04b9f2afe55ecebb893e867cfc26894f3ec5ef344e70d321023532e35663d5bbdd21de80c6b13a87d4f326125deda5b3d55f443ad21cd020e7bfcfe0929376e5f7411ce2a3328975f70de70322a6b2398b1afa6970573a3573bfb569c438c70f31a82984d5230f7b6dcaa00ec6a8a1a82cbb1a304a78a526b9332fc159c0751bbdd257314e41a4f531113508e7c07c2592cf353a18d81dd34f39bfa0578dfd24e41c910876bf6bf7a028ab63b75899f74f55499921ac948ff26a53196e50b89a7e6b5833e7866f323bc4167ab8a0437ccb446d9e40b8650f4b342943b0f92710ad71e0047557861a67a96792a3073ed3be9b9e6aea0c7c6bf6b473698d84212d513b04abc636d15d12ae7f607faafd6620f1423611ea9360c71798c32d47a419be07cf01139278fb52c957685bd2ab553d508be3f3f9db60f681b24dfb40440608fa1e5071ea3ac2bed5f391142da58c2035244765a5289810ca8f8a63d416371ec629a6fcf294f6efb097b99808d931db0cdddf69568200a0e48a17a446f57d401ba66e2487e9a2c83c712316a10109e4b765907bb32c08b09022aaa8c7c1dcbcf382649f59fbf9623e77689e0742f6ba017ed7f6c278dfbcd723ab6be9d06064d0d1ed9c817103480bf790b4a273786cc57c4b93c299e27546e7540b62730d2c5db01b95a859ba8a1d3adf0ba98c3b38e47bd4ed3c4599d63a851c6a549f2b76b63de6d025b7328440625d47817a01cf5547227dd5d6b31d0e2d00ee6ffef2e52199780c74accdd3fb72879b29bb6db36733bfe5bcb137ff439e22b0c3fd06e945976c74f54a8d9f5c0e1d7bc19dd6298ffc1d7cece688d826e8d9035b7676474451c9a868cea51358b8af9b6cda3db65eb03554fcb89a9484af6fe27bff4c95b777554bf38b0031a40c61703c9ebf57683ea67a333873879d4923f3cb10e697bd6960d5f10b4575e94ce2086217d440a36f3663ad374b21a5195ac7b3b8039f8fa65e5878e3aa8b5b227d9acb02ddd38a3835221ce8ad788a931e8f852c80ebf068b4addaa14b9ea4fb692339187c3359eab43de27412c808343ec1436d95d04fb6137ce6b719b0278ac41e53872c22bb77e812e6e8c9918ac38be9142","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
