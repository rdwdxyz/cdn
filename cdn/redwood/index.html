<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a3945119750b04684cf33557c4f195f066d5bb5805640cb204b1e9566d3eeabfa6d61e2857f7709bc2a0cce3ccd5c9db20b0a1921d28951eac0b7b17e39acbbd64c98b446795d8c4b05f0508f4a4c13e10182a655ef460550ec8a216622ebbb8cdc191eb9866f0b5250f6b140136e0ad6f688768260e8109af0107ec293e34316b2e30a020baaebd39cb631d1f2885678993de9e11f73cecc5f002be9ce42eaf651e1419050c05085d52589f30a5578f644264ec757f5a5977b924522169e91341d10163a9aa57cb1f83e4021289d3d0d176e890a65e7410bd496a7432b32c829c2eb200c368776bfd06f7fba339bd8f645085f2fa5a94b53f3e377d038b4a47f8f815ee03a981d07641640f24d2991e8e4a7698eb75fe08083b0baa9cf1f55d91ad244c61c526e1399c9069675072532213a419d4801b3d96387cbd28811c1b731b53a9bedcf062a7a006186a1509043a37e2fcba5ebde0ecca099109327780240909931f0c043d7d3e6c28ab5bf59231b1c7892c62e6dc3ca0fe65a90f7f329aef7ba5a92547586469c80f9a017b6906045d1c1d0aa111a23bc0bb1a625c66baed538cfa26da90a618f2fa7ee1faeaf87051ecf5d66e90687a20f59d8340d66b89e1841b2c7aabf95beb2c6e8bd9c1451cca916d78d55cca39b7bd6c44623a18a18d0217ad706c3faab0cf3536c660c912120155e7db66ac13d28f7763c3a650af528ea3de100b78c6e8e65abe91f73db723563e151cab4d23fd10b1e2a747ef7ab503a7385e10048dd803568bbc37f0f64b40a2a005ec9ab3a7203c1b0667c8a4547f47e6f298c171c8a0dd3d88efe9c9f39c4b924162a96de64ee6b9e4a4db839790f13a7773541a212566920b42dda842765e7d9a0028d3d44fcf9d4d2e678f7e26587aee6ee5d138f94f4e44ef51c60380e24f9d9f13d7f9decbb004d97619d33add6c29e979f894ebf7d9fc7cb0710a8f0f87bba9ec18f959e5b2cdd3d91a2de8d41651763cb10a536f642cfa1500636e611fbed8ae11815f858e4a971a2c413b8ccd23094b43be64f32552c2ac99bd6c59803f7a59ab529d1a9dae8af17c6345e0ecd14ee1cd418e7a96d84444b4a35f6cd42bb6ad1b2b5a3a1223e296431cd04ce46daee5ca089a9eed66745bc6764063753efbac542e79b02aa5a87a6b3e0159cb1966a6cc53cbbcfa2b1ff1ed25dd114f1b9788b7145c8c7b30ed406d2289a2d8210943a79ca2de85c6c37e4fe9077222c677296952f0ed6b1451b3ab939c76992d7b797cc6c726b5d997225d39362e7e1ec1e7f5b4bb17e3b7c684089798500dfa86a177d06fab59748bf7b1d1d9c02aa718ab3833e2ba4aa882d3093468afbe3bf3922576ad86f1acfe641b84af33a32b9333cacf159f4c63249cb32573c1ab9f0c136d6ee516333dca7b32c525b8e68b9d455d7f921c48a2f7af5c6e491bc0233a9e9ba4508c60aa167956b8ba131ffa04cc47903185ef97f146029226f384306671ca49846d79b15c39a743f37ddc378e128a1b4adeb0fc14c1f3c695471b77848a3071a2de08a4c783f0ef04fbfa4004a142b1af822653a5e1c8b835b8e87d41c0ce12f6975896ce70248f5c66e6189575cc1e5d1207d8005cf04aa84eb8bcb80a18e61c2af9afe865c68aec56131a59d6f84176e261f76fcca652a4dc4adc340415d7ce2ddd64456f77eb4cdd08c84fc88d4f7ee3ee04de620f780d839e7fb9481f20ddf4bbaf36209abe25ad15630a670ca196cfb58289bd9ff50b3a9a674d2fc9ad32d08fed2ac07af464f05aac6f968d92bd5eb97e4d93e48fa4a519da07825040d816b6190cf684935644da849e7f8a2b9f05691cce69cc4f66921f39fffc0c660e29afd25a56922546af1f0306c3eeb8eebcf7acd323a6c0242774c128369d96831f0adbf24dabd88283052a87f4d1ed7f6637b2201743ada58b5e8bed14a104e6cd565881dfa16eb12be52f0ade9c675a442b7ff1edaa21262fe9e3213734bf1319a6a35f3c63a0683a364fea9d74107cee069fee8bf6bdefb4087489773c03e7350ffef9d182a9f9365579b28f027c682a6c6c70a9260c2b09adacf2bbcb16e7f6a181a7b4ce547baa249a53e5514f2e2903b701ff97b7efde26e873f940ee5dd9c31b95146e4bfb3cd43e0c9e1757a46b8d8e796e054c068acf74749dc8b9be341046ed71f522abe08b3154e31d847ae7a548c2fb60f9c552088a5ce1f73eccddc400a7578ae38fe700168c48528d12d22c3de304148b276cdc972cea25f31880d03c6f3c39a9d8ec52582da16c4bfe1e9492a31c7cd1e460ac76c88e82e51196705f01335d3fd53a314d131b0d5896295f9dd1efbcd47536885e56e7e073c1dd9ab2a67af9ab82072340e4f7bd432b4a9534a7394cf604a495d649b792ce5b7c752614d5ba7a1652514e43279ece1b7f4728ded2ba03407d9f11b9a1d6a4da22b7611c21cac54fa8de849b4e8b07feea1bfd0d1c1ff142521b91a4c5bf0deb51ad3a17666372902db3bb42be4e0af378c8da569c2fb2cbcc6fee38a886a1eff717676d83c1aaed6664e08cecd0f6b8d986e736bf804d7126be83e7637b16ecef7c3bd5d3190bf53d080ade4a65c89d510596cc6eebe20a79c144f698d71ec994e805a5d36fc71d817de5d4120b40fc5a6cd64b9a9ef4a63cac2b94229f604f481718d39e67ce24abfb00ccabf8275a74e8102b431fe479bb3d91b8e5bc7faa2e1f4c379bd78587f99b1271bbfbb2aacfff4277b7c583283a8a89e87c121157fe5f237acf4986527177be72c920201d9d5819154207742037f6ecf0e7d0bb773323705ce91090469f8af694e2ae23d0395bfa60d1793f921e55d96b8cb2bdf24d108c2b03280e9dd1cc28861d48628f1f0210f19117ccd5e40b3a2f9313167d5fa17afc210037527524549856e1d99c7f0b68a557adbeb60da98646bb3a95dc3159ec4ebc1ad03176fc83edf6955ceb090872671037774a3920c1e7a58465a63c9cd52bb1852febe86afc1c243e61227d545e654074fe790fea4703bfb9ec92d1ffb85358c260377eeee8db3ad1385e91e387dcdb1dc1bfdd51b166ae6b9055ad1a175478ce7ae0cb1d1a8b92305ab26f49be5876fa5e78d37371a8bfb06f2d953833e6480bcd9eeac0291dad1572d05460464bb81ad46a47fb1c04a6f823782f9802b9498e85ce91229ae19904f7a6cb26d9c263cd749f5cecf56fb88b034bd9881e70cb06db49a1ffd614e6a69ffcb0abe1262e5b83a000506ce0510be2084f6ab200572c8ee922873e9e8a0b3b7d4b0a141fb6550296f569b354297611b5049b8641a24fc0e5c93573ae8b467521969c5b57d53f25c89c2f257b48978d615591690b920c76f027e8645e1bb245bde4fedd97e1ffaec34fa7a1481575051ae33700df65885879ff10a5bc64bfc885d49098a763db4eb3a570584196bff8e61b3ced53d3c8d2e66a00ce5c2b2581a719d0bb6489c5e2da387156c2a00e618e306dd15174db2f9b98ce06e49acbce764da7a5e4dd53d23a56da5878f66aae1d12309923698f6daade07cc1ebacd231bb3b116a62524768f00e71362f332483e50d1d0b862d0699583756e3e38d7d3fc75670da7a13325f9bb35fad9ce544ba3e6dc630fdaa0ec39ba0353eac1df78581338aafc70f84db9e11888325809003385dd99aacd746f81c64d02b7aba1286ea1c9c60c737aab11ba5b971fa16f2081dcc3e131d47de0d5dc7a205c29534d6a05fa31c0dd4f9418cbf1d1a295bcd5c80a2f4bc2dc784755aa3801608d47e60b435a42a70aaaf8aec2b319e535b23e3accecc1b1cc671dab0c74e4a495503c67e481f0373f7ab1515648de310028f928ebe2cae4bc28ca16cb479f038c5ee3884d4275204ca627756a50bf2e81e223089c43dbf7c12a46a13d414901f41c5da3540c9b9c1382264df997da48dd199ff28a18736d42195d51c8ee37071242cca844eb936e2b2fd52485e52f449628d291967f8a5e9b22f23332369fab4a1ae26b73a6ed6dda3d23f76975d40c046153721b3180ba28918ea62c171991c26a4a20f27e5b7c5aefa735634ec0724e9e872c224a6ba9f9c9e6b72da9f4c00f4721ae67a57bd8e567817010e790e5cc22af2a5eeb60dc9e7590cf26d72e29fd9fd3c9890dce966c23f22d55d5012ad53a36d84b035c1f35b088b4417127b4507efe16fb1c818a3cb38e9d69a8b67adceeb224deb77734fab08fc94f7c4aa56519b6e15f18b8760f2be43e53440066829c880be44339137151d32deae2d150613921ff8e91793ac865d995bdcb0b3b41e00778f74476eef1bd828c19716e0b2a59648bbc991748f1e4a5d6d4adc679716781ce6bba39f70936746ff86528532ea825860827cad8df2ce4c5301adb5703806181efb96538f800f42f2f6a9d8e3337f4d3b814fa333cea63770db2605b9551e45e11be880a7697471362c114d5c402d0b25536040191b61682177046359c62ba2f1703b3c1f28a07f311b521ae420f792ecc5ede2b7fbc1e4ba8a8b3bf5391a386997fbdc5ea3168b74bcf0e92ece89394f0a3452a3a7ecfc9f83a2b72d3e7b75b036503b119ccd21e744f35137e45390ab8cab5984aec406af1b178c3456fd52d068ff5925670fc78b8bd8df1e897211caa42117f2895ca830cd2253f01b4bf255633995a8a65a95a40dbb1a5f834cb4cc2c48a164110723a9a124f182d000ee2b4dc6d52879ba8331ed964f761f588d48b3980828733d8c8dd94f832aa406d06184157fa195c3ddc24ededbe1776ae0659590c565eb124ae63ad595fcfd6ed925b64f2e52d6dd4cad047a5548a533a4821504a428742a3924e81aba72ba54cccb5180461403e1792fd0d0022afb06798f3dc57af6ba614e8e0bab9b6911e840a8b33350fd707215c923a3c3b1341f4e16d0b7495fae9ee6b909035ce4af330835765ae35cf47b752f80684813c212214817b8857616c798f1691529d5fb91f54127d72b8848f511dd7f02278574c42cf2ba80c88a2c76fedaf427fe8c9a4c7a100bbd04388f5be44906a5cb9bac66363f7087f1f32bf869e46cda31e8bd60ca8d06984a2dcd36fbd1784d7949ab32ecd43a844b21aa7c7eaba168621e5376801f6f248a5b0503320dab092db5cb93dae5be31e34efcac712813ca5fe86db6b158d8af6f7f68c81ad2e2f40dddd7808f2fe0aedef0d0ff71b7e1d1be9326bf36f4fe44932052c2bfb0bf226c66c740fd978bb9e918f0a1162c61134d779ee99e1294b533039937f29c05e95d6fbd4f9b91944105bbce6334a37ceef36d35975c74d9abba6ac9f9a868e29c8995f2f3b9c8bdfb44b3213bcb0e4b262176f154f7d187a13d157c0e767162b2e2eaeb550b723babc4d7a7f7124b0f2ac67ed83a3bfa3c860a3f10c30e8d3443845efab7b5bbb1a5f5d149e9780c2438919377bce7574fe0932ddf2c40e8d33be505e6c08f85f9dc3df14051bdf05a90063a8762143c01f2af083147481c3c31fbcc2414013c82743c6a1e140a0ceafb5d05fc90d25ddab941486038f4bbd3d7f12c8e7fdf6456c3e7a6b7e0c0e596eb5f57f0d57a3044e20917dbed161b3a8203f8bc751386f2964cf7c01bbe0e11c874ca43b36379a9724381b71d64d9275473ded6da655fb2f416126fffa80c4a8afa26206a31022d216fd655c5c24d4453f28db0a974e91c0ac0595974c6046ab5296cc7950b1333e706e77ed4f2c44da11224446a7aa8cda43d61c9b1b0953bb5ab2f2e797228d5060bb6c97abacb1e3287e2c5d6889d29b697fefd472fcbb8f2293f5635fd947c65c95fb37a26be59e9f190b3d23f42c5d5a9f57e06bb9b78287744e9c7771dc16dbc78c4547c575c9b45f65ed223e51f5cd6d1180c920ebb1c5aaa646e3c1cfb3c1c7633bd6b7f3e3b093212ea048c502a6e8ae5913e6261e885ac33729e4bbff0111fb67e6e1908f540388f501b88a2c64b3824c83e5b189876334ab7329bb939c0f8f6c11a322a1a46921f500ae5b733dbb4f02c01c034fddd936bd9b1fe63cef010523e84cb1890a1551a96f23911e3bc05cc22d21735d626a97991119801909db2a61a6d93fdb6baaa564068cb0084b99b34f2571417d576ca785fd4cef1d5718efd8f39c7177271f140a5dd3f4917f2a3438357f04214021c18690c33a0fb82ec14d821112ce0f57fbee0932be8f2117470f50195cd5ab7e5d3b9a666edbd7497cf23d183c5834db6c1efc08e67c9ee56ff53ca2fbffc12e19de42fa4e3a221bc73baaf17987772b1b9c04d54dac0a0b91c859b988c59731ac109f049b11d8ab9bcb2c45e41940d6caf71e29df3cf999d99b33d57c85d870c19e7eff65ddbe0959403ebd6f02363852064ce7486c2e9288dcbbf4abaa0d27b0f194d2a5aa687809d2fb2a90a9410caec1278a352c6900c9aae8022f1fa997805e9c5239bd5813e703bf1664e5d87ab8dc1b855763a467d0b09f3823cf28dbf63ea4d7003032fb01a4aa3a019669d45cfce167aff60b6b59731a764d36a304517ead62d9d8c0418cf6ddb08d316f7c2bf67885bdcd8a29413690a596836015577e038910e7140b868d8ab311dc700d2ffe10c89a2245d0967f712643cc371a4c2bace6dc8ce24b693ff2a61e928e9bd9c9bd56721ec88138510bb3b0c76612e823049213dc581f297dcc06afab710373b3b53cf6763a60b4586bf13270294242fb4ee1143bb35757a98bf0b83f7e726866b18a6d161e2ad58493b61d8dce472cdf7264a4c502dc69f49fcbe41f947be73498cf0ff17c372ade32e0a029057241067d1563a2930b74a9d2072417d93c6ecdcb0432f16ca658081288ac9d059d10dcd0a71c44c19a0a54232d753774574c50ec826a36cff4c59bfd9edb941b42a500081f6c9b6b43816f06412b56dfb156340d8eecc3a44c996dba5a160ce94fca6a90a34d6f06f49edddc4e78fe7de5044abe3e1ebf0fddb92b0d5663fbc5af764f13b41c7481c11d6fe6df54b00a164acf74c2bb4a4109aafd19c7b9864fa98db434634ebff6be78fdd0e82d520ecfb3cc07a5ca406e283b304b8231c2380d6bcf76af1783ee87154e2fad90ba9a261ad66b875c244016cc8c78130d711641e568fa1646b44bd21f6a17aa800ce0044c4d016c0ba7acf231beee32da7a2b6684f5fe99054bdb7e40944914c32c08405570552cf65828161a3ec12c874d7f215cd20b96a04f82d67b59cc147da44aa9a9e0b87e9fba61b20692ca1eb646bcf70dc0e503f49a329faf0328dfd72a8a2184c139402f22e5771252d5b6ffccf30a16d0f1207bc5c5ba8e21a182f51e0c8d301ec2fdb275d2c23dfb8909ca1b526a80f1846ea88e12b65a51fe713c17203fde41f4052423c58eeb6e94290d2f39f36375c5a9f9624dedc302fa999155ba1499e4f21c2df4b7e4b7559acbe63ae8896d5d31a6f677912cb15600fce2e785a7956f7b4d0192320b7ee5786fdc93c904662c5300bd6dd56c1950af3df65ca56075c825a5898cbe2df5133c0674266cc006bf765bd920f0725248c4aae3c561a4b29a241e636c00f53cfc0ba0ea7a7a5dbe412c100b5cf89e660167a30e888c829ad14290edd2f3effd685e0cb8278d23d2f78413f86379e1f57b2c19712e2fed687a3ef67c782232922c7cf6fe59fd3b7720ebb832ad07857b9da892378a270f8e2e7acc92df5ccf0332130dad2a12a7bfa20fb88869f57e5691690b97917f25a7a0dca5e9d2bdb47d5e44171bfd89137be2fd6f7434ea1d723de8816e5c9f7e8417e67c3c249e3f989c02d3bff68f94eaf9936f2c50166b9088ad0903a00482452c2cf15f63cd035f3978830cbd1217370d5396465c02e17855cc6fe7128908f688a671e5911489a88928c8b6b01561b387399ba239498218731bb91e721bcd50ebd610e5f8938dd2c948a57085d0c83168ea81bf7bc4eba50c00ddd835283004c96352e8ec76faf9a1f53bf616bc2cee277cdc46786fd5dce71c965c2d307a439973ba007ec704882386724137a62a93292ad553f91dc23ed684a77e22693cdea83d1f0351cad1cda78430900897bb44e9feefd6f1a5fab761be825dd1b6e547f2d005dfd62f19df710e2364260938b347792fea1d52c6418a9e1f88ae5fe5857337b15aed1e8b2588813f9ff34da38d17e2c4a5c607f85dd6c47c7f0aa0914ba4586faea07ae4c71aec699e3349d6c385bd7637f6c937cbf60a0a27cb97a00c3a6270372b19e333e31897da85d02d680dadc7028ced3525305f85da27945c66d987dc60717368e32e80b8c72c6cc8573b3172c1c675f67e074a1fb066f99a9417cf03bf1b922602773e9e737f3753563ab7f3d690a0d14e8275a79f304ce4265ddce62a24f67024fa24247bd91b3474f0090622135df55f40fe19a3646f366d1cb9217c0bb674479cc25520fe5b657addb26731f374008a4add2fffd4523f90b46f707b713946fe02c3c1157d7d122d327c5ca604c41251c5ae5688852ae2f151fc5c1279f1cdf1e0324c75ffa2efbeea74e267e9119fd49ed4d1a515d326b1c761e6d0a052da4464e91127ab8ba617e9bc5e1812897756736094169f55b815af3d2db12e95079db5bd7e8736d5e36f6920146ef7151214553dcad7520970b9e7fb7a95946384cf9f01189607db351f2e4d9868d3283b6e7e91d95d530fccee930cdbf340e058a6f99777d83cacdf9344ecf0e60161d0cb405fbeeee4d19fcaccbfd650dbfd2940f9a5394c919fd904c8e8a0f45471d52824a0f18346ab9d7d028faa799720c37223297949a44a1fd1bd0c01fef22e075d68bd1d06b25a79d352ff287e34dfeaf1a3a31977edeb5b9006f7d1ceaf28e82b5480b67282db26c658de3ce1412d125be5cf72b8b8a2469c8c24ed9305267b8b36c06a05281e3e127bd70d857e8a45412c50fbb8659f983ea6eb60fc86f9d736cdf88918fbfa964056e5ce5fcba7c60de7db0217e6dd45ee86323f97f73f1c9e3810f8ddc29683bab0912580b908ff47efd3ad20fd6d489e00dfb5711048046e807365cee1061909ee694151e343af12a6d08bc576091270484a32306b12f62f1bc7e928031593f90d655ca344c018a7fe607d61c9fa382431bfcc8e5384ca2b6114177b1987b575e3b9ba18ffcbe97c653908873d2eb100094a75c35b11b3a82e727b0e6592b13e0a54c03f2d55bcf5eefca69b2c1ec7edc01ba35a736c69e7fdff3037806945391b6cd530a50cca6af2ffa302f94f04f5b96af509b9b7660ff33efc7359660843d21b535dc3dcc7a9419de86a8aa3a2f80129e0cdb556d6d54d021a29d30def9e4952d6836a6fdf79bad89c013d47825d5b867f8bbb513e09895f89c26f45a50881e7663aa59e2dff872cb3e0c54682fb5c5aa35635484652f2e62ed9b731318bb25e878e8eecada98526bf3a5cd51b700682374f439db7386e127ea59fd736bd5aa681918f44a2643684dde95bf59cab88584b95d4909fe4ea7d6e35f8fbbc9a04e8ffe7a3ff116fc26c2c5bda6a79cf34372731fd86486cb3cd954d147c411034da56b166c41d42efdb3479604299e95c504f51eb4986b037f362785ab94f0b2655954856367a12b8b92050729bbc9f2fddc0a545878ae9396b2e0ca276150ed78385edb5393256c04fe8515e2d98b28d952a3a33bfeab0b15c9328282178a959756f4086899925c24ed25ad4d31faddbfe0acbe2aa1b916df7f4b73d23ae514717dacbab58019ed5edc82abb8ed9b7d66251d2410107a45a490164a25b8b9de3dd901f4c389765ab67e9d7b1e56b4d9bff2717c29f00f860a714ba4a266c679a37180c63229015a3cb6a328363fa4a8cd84cdd0a33df37239fc8db36b209210569b59dfc4f2c27833bc78fcc320a9f894dd12d569101b8747d633daff71fd3e7a0faa677e0081d683042a001a0bded2e17a8bd3b074e2c51271c49b20e759a615765898e9f9d87d7624dfec431460f128b6f97fa5721e2678e4548f669c9b2dbdb7e18ed22e6d3597781d0876a84806f6d9793910bd818342b7d23732178b433f29d1d6b2802c337d3d46b8dc8360bebc5062f5de3856bf24b3eed46698c3f6a9669dd4645aae7c07bd6f5bb618397214a6fe72adf73d9d562bd81023cb63fa5694462f75c214544851971a8ef763032c922bd82ed0dc7b0e83b8c5e18f7b4bb8a165df66a672f1b81171e92e814154314938542345907ed752ed30c5d9f0bd2a691e58450801eed6a1cb91862b1eb78c8b52c135d6a17c3f1c3611b066ef21b4fa7a641d13b0f000a39c57f967aef25f61b654d9397ba81b77ff79eaedcbe4a55c7b1ec0bc9591d293def9c4d4225194ba415081001ae897a04762a027c57c6735e3d2ef080f0b059a444de341e82282a906ebfa18c81148c10afd18081ad0bf3003e09e2da07ec73e45af9ba40b6beb734e4c70b1845de8bbd1384d6baec39fc76393884fa55bcc7eb882b72012bf72643d862dc196c47cd97fa30e486a51ecc963786b5b2e7886f0d8bd419df8dd9668fec92177b7d446715b5b1666ed3eed6eaa7f6a3609397190713e1b7d725f974f44d9f4fafe0f2c02f535bc76800be5864c3ce3f46975dd7cca7a3c3fd200c300c881c8ddff9da2a9f2e6bd82c1a0dd5b0ac9b2320860632fc35953d0a45d66df0aa008d33e9241f34799b47ccda38ab71a31f921fa302cc3ba1c1c35b753e14b43b9915246b91afa1c5bdf88097bca2d519fcedbe0f433fe87047328ab67e9ca0232ad2d7243e1bb8229bc38c4a14db10be21752110cac44fbc19405f345aa9c8ad6932b081225e050bef7f85acd8df365ec2a7c2009044c509f96c63334a9469060c3746282d5261ca47a698a1bb0d0f6825a15f3c819df45354c8ae1486f35469c247454e28add8848e85fe3f4df7c93d6c2eb719363baa30c07f9c2d3ce4076132573953ecd1520595c809eabd3e165c7963ddaa02d89f7928ba5ef698f9e4f9b21c41034df532ccc728b0297e5802b48f8893e338125c5f6d2da2a1bbae4f207033c9c19f19daae4d8d7d019a7277f1d10436a2454ad1811b27c2a2956d0e5ff1a789c68399e05b50a6ab38104f98ddda8ecb136dad28ea57716fd606a5e2e4603294aac0415024070e4bce48dd12220e7ae7070364313e50f5a9122cbdb6ecf8405b54bc01f5d9176907b4d124604666292fbec122a641d26541aedf98424821901f6ad38c48bbc472f10ade576b0a0f0d26cce6e0e0aa2a78bf1edeee45091898d3ef1437db5e3def77a46fcb0c80154539a5a962c46293a0e3ec2c9a649d20db940f963ddd7e2a3f8fac95ea2b01cbe119da0b2f1407f77199e293b934b86172ee251d78c24893864df00701cdfc1c8cb1051648702dfded5311d1a5d385b84200244b86b1da2902f7767d611e6f38614827db24edbaf38b6f243f45d55feb252356a3f7a1bc84ec7d536169556a259a1320762a15af37dc9e59761bcbb461799600a65b88fd73395d268cf4bbc126bb389a7abd0283f368464ed5b26db62f211ff94118bcb6fef8b414481880f0ab081164a82d3017d546304ef1d5f43e32155e766bbac65e665c38196469503e32fe383b11c85b14f552086e6db6168fa72bfc12be5693cdbc682589e4751cb0495c69b0be341456732d6ca77792f7e02767bdb3ad242b069e2f4dc44aac408e60a662ef9dc765aa87eb569c062d552b4c47b7ef7706f7144c79ef9c1b792c8b2e42c413ba6aafba447199bf32813a0a3cc589f9cba79ab645edb528d7245d5c52cf72c96e90ae149ee104c7bdb8ea8adea6b043f8814bbc4d6004b0508a9c999651fe7cf8d872becf993f0d318f7efae4a2cc3941ad8721bee7788100a96c4e2d4df4fe7d3b31291249074f541cef59ba9e3c174e6abc41ed81a5c52690c934fc86eb99b8cca0055c14286abb52379377d6de3fc31cc511036898a51d2adc10ccba7b053d58464254fca9b414fa1edce784a1742faf2429c993db6e06ab771e2ccfa5752fdbad8cb8452cc9ba0e2ad5d92c06d225f0c4dd5be8b57e9fd879d2a78b9854dfa6a3ba8253a8125fdd7f7013ad8356a2e3ece0d627ca5e0c21419dee26c7021689a4842d45356383fc671e363b93485c87e991ba2d8bb5eaacc92492b4dbd67893da76816627c8f270eaa06ae3f629ccae0fa79e79d843d3312b46b16dceccd1c9cefcc58de2cdf3f12633c52cd61b3963c9ccbb6ce8d6403f30bc7edae7d6912b9ff0cd800d0225c135ffad3ff0528f0fef8bf279a933eb6cffe5f7a2baac7206e924c19150371d85a50f304142d10ea55ca8a8171c557a1c1c502c382679e72617e6b9f9cf62f79abde612ea42991f2f2dc2312ce446a06184807d13bddde3a6810568e3d3a77b585e9ad913154ade10a2defd5747bd0b3983ae67e32a841d0b17b2bf3e74c7575153cb633ca643b32ce3f4a0819a4738076cf02c18a42656a4dca3931467b34a00285c6b5350fca53f62089400cc4c9f1637a45586fa925f2c15c1aba4ab8b42cbcf03a8500cdefa40c56d51423ea51e44570feb84cd90e4498a3785a774e5d6bcd34f68497bcddcdfd3a3472caa29e13fbf320984ada008a7dc28764995844c8f238202cfaf7641514eec1542f753839b74b1e6ddd57289a75e0ceca54b874e9d1adf2b7f509a8c04ace016953bcba3986bba4b175fa0fccaf85c8764e7bce137b40ede4818402e0ff3ea32bf75f8b781182d35f0a09f6004bbfbe25f0356bd54495366f2030e15e2cb7c8e1b122141c79f9a8a292a0f91f4dfc88a3f0b79959a568803f4a9a68acbcceeefbd2987b9b4b198c2ab03b8ec4eb4cb28a4d47e3dc4b02a4c0443b3f581ba8a3f0a05697adbc9b40e0f750bf403cb4957e6a40eea8c962bd8d6c1f1d24994a0135b14ceeba3d470fb6594ffd9a2395b97515f73ef852960c57269ad84fd2b8388e28583892a9d6175e0247438bcef953666f6ca318a3ffc7862e2744022888de363427cf202651ab6862b2416daceb32dbc97ea60001d427df08aecb9e5fa8d45cd5bb6f546c891e675d61f1c349a7294fa3bf23c214f92fe6536e9bdb35a292a285f42e66bb66b4f18531c007dbb2914ca812d08155074f940b43be7cd632dd848d819df4fcd09a3fac234c02304f8c02a83dab3d4dffaa422d2ce27115b5c77ada2f63a6c042bea124dfbb2dc972bf2457689be6e0b66634402855f8edc377408ee7f558d5ac46a72509cf65184c63773ffa86cbbb5b2124ff63bea544f04f9ddf7d9e2705b220a023187da117d31ac9a75f3f5e5ecde15d37c241e02fe563fa2a976a37056fa934aaa65f9e2d2b56302fde92bd25a46eb0f8c33ce171c70e58ed8a3957c2bd16d3a8733b8645aca02e2a1b6a042cc296fb23a4cf398e3344392719ff12ac1a9e803f9a77321dc0d3a8ffb3609dba15069e6e27fb0d11dbb8edaa79ae1b4d0b1cc4b782cba5cb86fdeb16c67a01cfa5d8176b1ec0f2a76d52188590f0b04114f826598f4bd73791ba0f6c8d79f73c2bd79285885f1024783642a21927134d6ae798efae60df018553330ec8fa5ca391835ed812580c1f7bc43547437bcb6a42e7856cdaefe42cfc93d251fe16ee15570b35af321062122fc6758dab43407525c3adf89dfb875a1dd5d3db3856c60eae80b38a7005d77f4192cef51c02fe7615c798fb7bd09f4652f9d3e9f32c4282868f017f02ba51f5c850c5363fe41b9ff441c5658636a3fac4b45cb942c272a435af7408774b63470a84173764747253c32b6282be3c9971275a3f5d6251840021258fb45033038dcaaf1d40add307860a2be2a0fd08c96f6aea09a5f1db38c49a41fb81817f55b5482d04887feae10cca8a8d9f3e421f10b3f4bb88ca129e79bb53f03da846d488d898bc63989ba403833a86beb1d98e71f81c0888c17f1be41d32c75c9a5986abd86d8d0c56e7c8d6ad2dc0097426a5e00d5990e24ca67fde9b90c496e19fd7531fb0400bc33ebe1c0b1ad9365af26db1f5b4a98180198f2f5235f30cc13c478b2a387d63ae1264424ee83ebea91d418655a98f873cf560b3000b1d31951925d5e7763e5388a2251b26c62c7afddf550ed08a282d50a5b553ac7d03746e48df9a0906bd1c594246e7daab629fa888ac54a21f2858c57786f80ea4a91c2562b70e394be8db058c84e7b547f0f826f6ffa0ab7c41999fd63a4066905ed1ab216ceaee4daa07970c616a0aaee26f85c662d2f39e3e13e27550d4173bcf586cddf1cd09be6edbc01a251810057181564e17ec633e4193c703baddddedbfc9791111de0766c0f733f31d596ff1c27b2f8352b3a1c1e13552645ff89cb9c6cd38020805a98d45eddbe0defa83f5aa9b00a805efc58735f09031a974ae583d3117e0aec427e2d5283436b986290e0580a2c00dd1fafa1365de5c506867f1007558455299d834b5ee51550fb35203a7f6592d70817d858fc4a51174b7dc02e5c08d4146b24df8f9e0741153f607118713e58a39107e8ec45182fa989420d694c1009f77f22e41f1b2c84bbca55fb065ed619bd6a3a2198e380af4871cde13bfa0bcf67aaf0365668afc25086e80cd79400d677ea38338b83f113aba5058e72d3f5633bf3c86613926b5f1c50bf69058478f5e54dfaa09ffeff3eafc09fa2b6a157477933ea90abf4bce200f80183a67257a8974631609bb83ba82432c99def61e71b4ca3b2ef3085e7cec64927fc8cdbbc2b48e592bf78adabe709a004dc7b492734ffd1edd0600612a81986d09cced16bf5734ea028c2acab0bc69dcb5d8eec6cb1e5e762cf009751d0d8797a449d71f9d6fcd2bbd9541d7b61ac2946c1b86c169a6d270870317326d49956693926176c3fe4d3aa615c5da88e996fdbea69d8c30f3dc84c051fe383f52eeb43763477697a9c7fd23ce0fe0343620a034752cb90c502d7633fddc4786b13910297095dba16b1c642ab096258525353f151f0d483cce44101d1288f8b7ff88160ac0434475e3f5b513fcdf130699420f8654908903fa61c6122cd892c7215cb9338dc6f3f7b00449bbf2b3a2f109734c190b9673ae2dd27d929f5f412ea432f7ca56451704385e47df61591b3f39cbb4059fd370ac92335a6f200e18c441247b5959c7af5b47d4efdf8e0cc3b37a6653886573e434bcb4a060e0003e428009550279d9ee477756f58313caa7d95f10fed5905bef8b1266256cd99d9955ec52feebb7fda6cf456d67e3a8259e8d423fb7bc4d31931867c8a39fe56a709a8f86eb95acdbb18923625a65d73337aa2f51a282ef736c07e8f4fa7f42509ca75e13be4652147f8e3c64f7d553b213f5e52904494e86c0c370543927a7b549a45c7178fc7a513fff60a2be48c07e6a0d4bdc0f85a0ce3aa8b90399f241203a60cd929908d1b6601dc2031c697cd56bb471519ee588a7e585a7a8979fc48a47068bea054a38fce2d74c3883c365afa3c4404112b42d6a9a6355a3aa18d0c0fafd66d5e832d32e488fab488333aa41294025c518305d4167971c64b501fad6d88f5b1da231b25af3559b366e8193a81a66fcb219524599e34c29a8c6e1f4d800dbb1a7e36401b977be1918f41a180ca1c00bf5d25726b622b9f46cc584e8db04a5033bfde353e2b40d6d460c7d50ec81aeab9945edb8cf2c8b0252ee0128e28fa29f0dc468f2af380b055020cc0e8e75d180b67ffd57d631258f1db0f0406df3d412b0058fb56a8def57f36c5d968f51460a96197b4706b38bcc91afa5e2b2438d4dc4a0bd43f9f6124f299e2ee2009ae0a6568cad7725ba68b98d185d8e7c324e69d9acc2f7cfcdba01c3e50ee2abd4093d78444cffd6ecf16c7d030a179d19ab3a23217c25cf1e79910aba025ad58ac1ab1141e25843b72eb374bf30ca96b7e5508cd132dd4f67d02b251194a9c3c8b3265a65b626bca8b70b627185238d6dcb6c75571b6d52d36e0a9e7007d07818c8a97d67b2676e871e4d7494aaf59d1b2072aaafea220cf663328e8220bb81869af376607b9faa5ebd380cab83ef99d62f6ce18a0467d2a8e7a684e85f248bbf874501e0d030caf34782caf6d5cba067646c09061638d80d048264fb55172468c7e999e1a8438db863c10684c060c3ec23e989073c1f4f549ba817237ab75d437f666a01e8f4a6fde7e81d92b01ceb47e9f479b8173d8e04a83bab5e32c8a784ff649ab0cc5793f7099ec8d71d3b2e8c93853de7bafacc85693269c13f7a06432c6715d1d0a4370bab955764fbdf8d797c121efc6abc72c7db605da375cd0df0212154bd64f11a683a1c4e502985b62596bb1fe107eb04481dfe9b8eb6bd40f99145ebf8308c5752c151ce9fb2c3181b8bd2a51e9cb489fe5445973b2007200e24fb51e1368851c54c2d6ef8c88ea170bdfb31abca51a08fb593fb54b6e92ba48917816419056f79b5980e271987fb8fc2c61f418f6af969bdf4aafeb671e1c86e5bf64ac933f969707668dd1a58d5ba226dd503cd7bbd4a067992524848a9c051c73d129f1638658876e18515b836d78e433e8a5874c30c5b5776146b7646c28fdf5a84f433113b2b7ff4585be5700604611ca19ce6d58ede7a9d9d0f832450142941e582b4a3e1b41b1d25291ba5a4e7eb4b1549ddba87e4355d10169d69e71d5ccd7b36a247a265fbd55249671573bd623cb02ebde1da1c086a2e5d4644f8bad1098c8893b790316e0a299de08e78996202bf9a432d8ce4f17e1228b4d8455fd2e0779e685f488b93d3ba6e1be403baab43fbc2b7f5b34143d9a3584fc7ca1159b945bd57448723c52cd58133a3fff0755efaa087d8ac2d0fc342dab01c871a25f603515da1bd5e0977306c77f7512d1e70b898c656bab5495545d94a4d97d3c8eec36cfb35e17904b72b13651c69d1436d336337e32875e0da9ea0690a785ab84d9bccde5559218dbb9a3d1e3f31e6e1f9fa05be797e1be6b987df4664d6444f5831c8a8ca82a7e5f6051310f16ba4a590053d19d56024d4ca756a60e2de3177c2b6a898cd3ffc09b63348ac06ed3e93108124b61ff3852ca51442ce2111e781ad9fd8a85a53fa0c70a8a8f89e27fc4e8dea978f1127e8cd6d094ea81f3f6b308ec7798d5abfbc3fa84e903e0f73eda26c4becd352cbdc4af6b9eea4635879ddce7775da9b89ef524c6b2fdf9f24717e4ba4344e691129c8e233ab5be252ed290003e4b909d19640a71dd309e5e786c0da73299ea619b01fb2438d194a26ec3f50e43bea4d55461418b863b044d07c79611730efce2642253c360c57c08f43dea6fe1eae31be2dbafcc415457e2518a35df291b2a1fdfe46b3ab04be54fe3a6a4434c1c56589f3cf0bb20f377cf77f0b14789e554c4af4495c554342dfd81d64da525ba67f9a5af9647e69cd51c62a60c1f58f72e8f09478f3593471aa0cc4a0b42bbf0bda36f069b849fce1dd51ad961350ad1bad46bfbfa7302ddc9366ca0a4b742160c1bf6901c07b49eafa2688c6af431d22ee0afdae3686bf7ab2a6cb92969ca44dcec20a9fa3cfb2a02fa507a48fd408cbd50c6f95330570aa207b79270529322b10a859451fa8feb7033f7f3c4ea029added643732fef44f37f27339e14d295721d711c3c2fe0b4d1a40f466b097c487fd57cc1eb7bed469aebc6138da82091d1e6df368a94624a7113b9386b87bafd1a1da12dc3f31dd063e381532f3ab18cc96ebe40b8e5acd45610e98353e19b2de452ec9528c667fb9ccedeb5891dabc7396e91e73bb9ab2e4a01886805bf72299821bc472ffbafd0d2f8c5374ae05252b55e8e9083ae7d3b69b4ba5bf1cc43924efd2d2586a31213abfd995b9a27bd1ae6fcb2e31bd135b868d68ca8aadc3d0becc3a952e4f977c6ebdb122bd502787e4761f65588d9c848afbbd7bc0ca63d277f849fd5fd74cd153bacdf91eae08f8be14638166ed913962a4d4ce76d6d973471fda8a2bb661383f6add91c0679e1842a4aa377378c926fb735b5a6732d8cc933d313125bded4daa4d71ccad79ac17b559375cc956bfa0569583c7f24154c9b0ff689a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
