<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b48f9d711a913f4ff9c9c7e8bc57a7eb4aa8b3e765467c131b5db15752aef81ddb75b24c7124c856730d76a51fab2dceede8ed258d6ad7fdadbecf8c81098539758a45aaa12285b58a1564319cc64029efba1f5002cd14e15d1be0f705ecf711ca2ba2faedbbd4b9d8f489bbce6e97109b553cc14ee9ae00cc646e7636e0db59cf86738b1b9131002c55eb376bad6d189343c3d8db5de0e0dac68ff5e0cab000d7c759cd9e8bc5469cb2baa4e40d1b1ec0930c8a2515cdcb7bc7166e42d73f8a6f323ff029d36cc47681df20737589990ad7aea07130178e39d772bfa365f99c64189050c935e599bf36e25a6f1e809980d9fdab3e3b6c9cbd4f7f127a6c3abbb3d67fa8a2f3c29520019a21a9511cc5566752a8aae6ab397ff289366c5011e5d9609cace6ff9f6e83ae4d8233ad3121ec76ad8a3e3aaa2dc6485529050789fbb77196245b221b65b5f01e5cd8fdcd257bdb71c1b20805894164e149731f783371cb065d9f63722422ce3c895da9bd8f7dc38c778a6b9999d0de7c7c0ed00ad2d3b5b49136857fc438db20a4e3df621f6bc2a52f28817ad9665f27397916fedbef66fe74eebc38d36a3d91220e35b5f1ce7762a6e339e6c29fdcc85ad3e42086b77ad6f9d1e363d1ad4ca1eac62c499665b3287873fc8c67fb4f151d54509911c4607d63c49a5bd295c85dea2b0e331085bc36d74afa7b611c6f1ad1fd9a9d47a77ca87fa505b1c7d943c433f0dc79aa644f7a2230b93d8734df79332f1f5802b93c5c2aac479601a6a838f53b3854d9ac383ec27907b7778015e234696889cd578b59f456cf9c83362e15fc5e8416c3182bbb1c7fea44a9e25bc595ef5b03b4ddb953f4534486ed2e47d810444dcff00e492772e099628cd92d7167137906dcdaa38d3b6b5b1c70eda57a57db01eae5b444dd2de8f088d0e609ee7c34bb425edca3091a152a53808b4b578b75458e13769f2c6963a87f9eb5132c882ed28a1d586a25c7506e1572f2382c862b052c553065b51fccbe9f25c5c3974b6f6843d03b39973c600038a8fef2e564a5da63d7d0bdc39d6075190cd4a7fc1afb6f5b7a05cfae8781280049176d9a3099bdbb7edb8e010a23b1949cd205b0df4060502fc68b52c0efba5bfd72fa4a54b22c9358262fd6549e0da2948f6b4685816a461876c05d392008f1230195d40ba11fd6b8fef70cc3a9cafc6aa69532f95d16835cf0718e523da5de2e9e3aa155711f80eb5da01afe845705e08101f25d85dc8f1a75aec3814eacf2edfb65f989e29dfba3b0da98435f66a91bb16c9cc89e62194c3cdc93e03b1c5d7390a227dfe27d8d6736e492933350dfc47d2d29f0e91fd4d496928c86b20510bc84bd33e9dc01aef9b1cc7aa3ea24c27e6ff9b8136bbb1ef8647e8bcba68135d8cb1f92256803bb439af3a7aabd6e35e132e710421a6f7e266bbaeec26924b50b67a49df79ef860209868696623fa4b858e467a6ef4633ee23b36eefbf91157a17aa825f900da954da0868251744c3568d76c74d607d86e46ae144c9e39fab5ce1a7e8bc27fedf7f8ad374de5d6bef9af0591ebec1c731c11e718854443035d05f836b7876d373864e2bc5b2e152dc780f436c723665090a7694ab633234c132b11fa5084bcf2e5bb515fe8ac69431653f5dbd1bda1a8680a01f7112a79423a0b7aab033dc6c5dc8af91f7aa8b0706c3688830c773b42b3a4681f5cb554c3cee9aa5eb716c9d84accad47f9dcc7cb7c41686ee5f4e87a116d74d8ebe4251cd77305e31b98b173724653d5b4cb3d80c54dfcf56ed220b62618e44553d2857bcf2fdbbe5a83c3a70c4a75ca0ecc24cf0a6e403b6b8d2ac65804b84a179617798d81212737657382f201a161c941a39974a89a269cb51bf5fb3a715782873e82cacc40e0e384c5a3a874a1c76d6a9601bb6b0d878871d5e2ba09df6dc79f46457537f3cdae3e3ced4a6623aabfac60348bd7dd92271185cee6cf842a86b7dd6fbbd6410d4a08a46abc788599d699dd4f24ec5b10fd8ea617c0aaba9ed64818211d3c10956c13907c5fea38ca25251b5bc12c8b6002e118c5cc5a4d62f94dd0f5c3e93f0708c12a8a1a6cde395e19fe0d9c3d2a312326e03d2319eb9591fbe14090a6d8ef7521e5550b536639b18f816b5d9b5d232870cf71edce02f072ea3ea17b529b343a1dab2dfa3f614f8a8be84cd39284f67c292c5956fa8a978f325cdf430d49711ed9c751985218d620305dc3ab9fdb4bbb4f5f9f06cbce956f2832fc4f8f6cbc69c326b24601c77b36f0f36843621a391292f63eebb868973695e297491d9338ec744fee7ef4e83fc3bafad049f95d1f2913207ea50d0b198a56bd6b642e3b40aa0ad02a329582a8373abad50b089704f21888779e371238bf6e23371d8b558473342a5285769d022786bbcdf2c674014280cea3113c2045913931ec07cc0c45cf303612d63aa5e3efa2209a1d79ce8d68ecb516628d3fd6dc361410000721acae40fc5914cfa4a15357a0345b492f37aed8cc15fcd7da9aeddbffdb4c87e70b8828be37df5aec45d5ef9f9566cf43c43b663bad3c21fac7851f9a30f0e82e9f80aaffdafe588b7cab96cea2b3ef2089b57c07fa0939ef5ce5ad8f9104fb4ec18ca535330c76fe78b9c7c530ae48b04689d79d4b3059bb46cf4f21c5f16c4ae2b7d5309e1cf4e2b43a3f2599b837aa9ad2c4902ba16adea248c352b3f0aa454f8d688d197e730daf02f30e576e1055b3601cde24c0b7e0cd39a6da7ff83facd6d8744dc3125537c923ff7e54b19297d4378dcbe9b11242f5033e7a8636871c90a59256d4943eebbcf0da0eef47e200516bd92d19ceef77decf994d0e95c2699df39bf84bf2f2cd17f2d3ea34380367a6dc87c534574fbea981510aaf9f36f1b5ab28dc699931ce265cb1f840eca1a2983066ea7024acecd620f7a20c3bd3f6c0480219c1426c5a1e4cae4b14a60f71c2d6891ae82597e9492b4913b432babe63763780252ad3acb83dfb1744bc2fbd93fc0e4a15949f407b856bfb068fa098f9f9b842ae6903f673b05c1f5d3106585c3b65a907d3a23442f448b71052dac2f0e2f1c4cac2e9abe5bd10be7920e7709103fca0560cd992fb59338403de98aa3cf23168c78b7a90f3def00b8bd2eb05fedae2734a22266b2c2f4ca3cd627ff95863dd266f298dc51018a515577b8a0067b3ca1641ff8c5b4e257580a937d6f28e87a623d2a01b95767be04ed92eb7653378d2d164ee2162b685e7a01596bf150c808cb33fd3a9012277252cd17de83d951d2bfddea7bbc60cf11cb02bd9edf3dbf97fdb5623c42947af21a2978a3acae30cb70c4d413e68f8def48ee4c0fecc130be5703801807febb9629642235581f5f4ff366d4155e7fb4b55c3919b67fbaf653f2759879c5101fca8be5b168484f99fc99d104d4da5a5ea8e0d2e20e0dff3efe2c86038fadb9fc5ffc3e65bb2f831ad5edfaca657de00ffc8de88c9bf14d0ac04ac0496520764ceb2354bd6e3202506121a3353eaa5d364bda211304af7babf45d38d79dbe25ceccc4d0336885c9d9ef4911af8025f6d5fe6d36130de09b8fec5a01a463cf7abef125bdeed86e545727398ea6a733d13740231be889118b6c4f4d26cad6304eadf006b9c83524bbab5c0ee1fc723883c3add312aec87856e7c429961d9d5eb335290b03160ec114eb2259dbaade5a329f271664be59ea3f277b2cd571ba973b6ff6d3d907215a5a4bd6584437ec21078eaab44d43fdc9893bf1f5b212a8a81f3e3570877295794ccdad58ec1963dcf9f5b8b29ba75a8d03c89d0b492249d9e2b8e2365332f147aeead7dfc6697efcf6b262ace161dec00690fe60c063dab95632f2b383990cdd2682800a9daea633996d944b2c75d40ac40c15508178eca9a4e6ff81251592665e1202979e9341c86e22cc303d114730d9663dbcb54e0f051b94ff8235f1ca7736e5f4c5e3514bd527fe2eecaf1ab7ab8a55e80bcc72d617c0f6259f594500b3aaa8ebcbfd92901009740052ac8a557983ca7de24d57280a96a88c356a9328167947a72796cdd2ca428ad87ee8ebbd201721dc2186b7c755b2c8916d385d6fecdcb1811e604c6778903b85f17f0b4e147af1a62bb5c8c1b3fd4ff7220ec2b7a5e143867a2f90ac4573c046ce349d4f5754d8001d5d403cebf501ae69e74296deabf25a30379c50f01df39202d766d8bfb0b87225663637ba383d3616b54aa254eb433ff130907a054df26586587ea0b63d744f5c352b6eb358b847bb22815d7fef1135d42b45ff61f1ef396f71e2adbd027db085c2799d1fc8f7ec795bd10a27e08fb4c9946454be31511ab13c0d1ffd93240321f21d7084e38c777589b9a2fc0e2644abc7075c3d9ebd7a5a4281ef149e66e44997b5ab8bef2b603929fcf9b3ea2483482418ddba40271a4e0cb96e80c97415a835dfa766521ea3dd02a89516e760a0e6f17eeac5b60a49856c063801435843d22ea41b6dbf631e38bab5388a81ceaedcb360a56c77a55ce2928ec936ce48b0324106cec3552b46c0e4a766eb8337565d24c5a96f2321c8a78f7381bcd6fff4e24d3aa44f2d0849e8f3e27e052ea811e9b2dbc28039207cbb2e1e7209597aca5ca434c16ff9e8465f9adc9926750322dc9c09034c4e85f6c02bdfc5b9bdacdac16cec0ba835e871cf3f551cce8084f773bbc6645c24f1b560977386219769e86029f459c97e7752a482b75abb7bd852ffa6b87d32c0811be4fee3704a1b5d63dd4e750ff83f09182f52f82b04b7784b54fb10be72fdccfc71b96e80fcdcbe9be8f3ecf11c50b2b69a7e7e90c2511cb32882e739b61a610ef0d5b16408003b7a2b83cd707641d53d4f8d8d8e2216796f5d949a4dbaf63179a33b6ab5d6f105663e08188a1a4a03be81e93816f64f6430267815d00ce25a03d2ad8cf443e074dfa1e2301b1e48166c65f5adaf981ca47daaaa79ad5eab9cc2cd5c5b695c9d74d39d4b02a64aa805e514f096e5b04fd0501fb52e642a63a8ec7f9f342d36db257a26d71697b5237b003c62c3cf59d6fd092d1f6c264fddd42ee3e5463fa983e5d189c0885f827f260a0db4711329c4633404288fb00e84ebb2fd378f2b82eca37989a42ce94a3042cee1bcc5ea12f10812d86a910c24e7be5167df913025a052428af5c025dade6401508331b0b180870b7289501d0a64a12e8fa113b6a672063e79a18ba54346be176a750c383bb17acb3c94db10f144f0db05ea1ae1e8120377925bb9242dfbc9c56354378006e17dad35e4b3c88a1477acfbc9c4446d5defcf64c5b949da5890ed8cc06d391983e24c7580810bfca79abf6cbd46b7b8affdab7e2251a44130df0c64365fcac14238f56263f17531c3eab6c8c39183f634436a052f347c6b731b57d7587dc545ac56616c45a85cc50324e900ec7ac1ace449c008d12d31bfc3d9ddc53317628ac493f59dcfd7485c49680de61b932808ce5f15122a6f33e5edb64621d16f05e384d935f134076b4c3bf3323985ed97375db803838afd99160ccf1fe0713235e2a02c0830d8318ffd9fb104a8b28129615e9c2e58723f69040bd610c9da42beabe0c6a22a95e2a5861a1776421001be2e2273784d0fba3806d692c1580107d315018ec19fce942238c0f2782847fa5001f5a01be15e1049db8f1658358400b69cc94f8bda66511d1a039ac7a8eefe84636e5d32ea68822c3d83eda0818a1b985f68e7105a2dc04c89319148dc2116bbd056f02c2acf1d6180da761112555b21779bee4b07aa17d2dde711d72e76c16b508da78fcf08c38ae63931de369e9b07b1d39b2defa54b8b6efbcb0ec43a36ea75cd08bf4a40ab8f1e43940a40be602467da08f17d4108348c357ca39e301a3cf9e6c2d87928a5867379ff8c526d6ed381cd884f1a9098171c847d7547a26603bd2ca5d099ca636e0c0afcfbac7697ca056ed5950f253aa7c51772d49ddeb9007165b9ab9b97131112d1d1267e05989f5ff3c7545dedc01ec2aed7990a17aab56025304994f8470ff796c0d4b216449d7c3d5e4e9908bf2c8ea25a6afba5833e4ed692ff3c1cda45d9cc319714989814bdb627db2b760e3a304751d4b06d10de21c1ad600ec85eb4663df897654ca7ff3cea924b729b96da6ac0ff7a0d40d815402f2c8832dd63a9534a421a487c94d0b15009ff564c9746dbee17ba73423a29798781c325596dd4df950bcba2aef1bbba0c568a567f5ac51a310ee7ce57cd07d9e914fcfe416e400903085085ba2729af3bfc72c84c2c85604cbc7453a23dfb7e2649af0cd3f19e4adfead5f4954be6916904b55edc187481333f69fdedecc7b736530235f7b187f3939236f4a21fa91ca9881eec692180521a279554bfbc08a0b78280adb2ed2fcd2869376bc88ece0cabe31e47fb73e079071b41c15047ef699cb59f65cf5ec3255fec4c0f25fdfe3d1751a1c80bb3be7764cdf246071d0c38c0da0485f4e5ac5394a064079eb3213c0a257d8483a2bc4bd2480538a54bc55a94ca74c295472280cdba95bdff64f4b1b17cf0b11d5187aa1b79d25f861a364bca129b9df254218a8a29d85b07d04090beac87bd6b35fcdeeda9bae1d74e244898af5dade0acab00ca29aedc2c90351a2cf70f04f48c0aabf33d189dd26cb3f7e15cadea60cc6546851d89a12ee2c51abea0db492bfb2a56d574d8833d51fbdae7538410bd5b5e9a57ca48ddf44a34433642bad6276ed2a031524b7919a6a10cabe6317ea46cb52e6afa4ffe06f39d7e2db1f040a1aa11133aaf6aaeb213e2e840767f3eda9f1f2106828da1ae5ea2efec7ca896feca93d3f06b8c7e97e4a193b0df66248d7cc4ce2ce690b56e259af9feb08e436eb9085226cfde7d133504bd2c3ca735aa1c00de89917415082d5255858b1527508e1ddb93511dbec783c7d3a0ade34bead8b46829dfabafa7a2f18539864990345c440e70d225154e6a1c3887dbd2fd3554e9a115cb97b13b99f7e50c517d2aa12f6be6a12d2c835b2124b89ad12e358683b7d9efa8f759b2afe6f458e6c98c3772276f5afa750529ea43e3ada82f3e8f2f30fe43105294c10d3bf6b5659fb3082479882b0a093917699e1a9bc05ebe22cc0ea142bdf183f5a5285368f32d37e2ac79dd95d030b16d2b5bc8dd4f1adc0287a3913570282c2e43cfc83431ac66b17ee63797bd1a9df9b3deb2c7fde2c704d6f3916ff5adc42ae6b02bbd8f78706efb2d9c4c293b9859b822c5c3db8847b2a46a07e1b914fd52bd4d7d41c5a137872e966a05883905b2db19be4f384bc73c89a0097fac50f0ed5db5ad6bd3d4046759431e9f4f97eb2646f418f6cf052264143e7aed3712a2ebb1bff93685c04cf3253d8cbaab94c601570d369a45ec0572fea55db5adc896fe79aed3a69fb3f33a48e3a8c4d3e847ac01da8d0a08bb80b5085f9edea351d2e6bfa899c75df7b56b9696f05066e3272f486861759af062933a4693db6e35ce05d5d60e4d75ca02987471834fb7d821046f2058437626606ff9932acf43b1acf11a97b7416adee0bee70edd51e65f33def91774ca6ad9eb300cfc782b522008513cf04976eed272c16a8c92710189fdf015f3e924dbe4e87908b37cdb6c1b5c99bdc72df41b597e1af73df8ed4287e5265ab50f908970ccf1e5802334a98cb24531e47afe410364fafc4cbac169b7c6eac42a7f56097cf24c94942394ee77858dcf652e17c15e81a076293173eb2819b2f69d5028576c138e51ca2e86c4e017fee7c15312fc98dcbe3d200073199b0c32f2587b28fe056b2e8b99ad28859884f02f157de35ec700c8c7b178dae5e639b66b9db804bc7da7f010d6ebe316032480d14093c627215f9333563397cb9a1dd2c95de925de3f8b9d4dfad1c4f92c6cee69fe1332f3424b5d31cf2faf509fe7f9dd4fc5bc570726e2e56f3c2035e2a5882b21901e9f785b56e517bfa5a133c5e726e741ecf71d555b7f435392b7467f79dee5e70fffcd557c6bd8a89274c6bdc8b85b5bb6d549925ef7e4c69c6dcf2a19e14692a5f930e3650de1f389b877c0865d8205808617255df33aee8219b47ffb6f785fe9a882e53c42fb85905efba3fdd256ff4ca6920c51ce447ac885a56250bce9306a338339865dbbff15dbaa7a9c1396c0e3b00576f8a57d3a59131c5dc4ed61e22382a87e543e08eb60e71a6e66630997278f0ae37fdcff78103a0362c769379bf0dd6c11e8fff6da0f3752d9c0bfe290af8973ad821bbd50e518d2095af6c223438379a226c6ae6e7d5d744136f7c56cec699ff9a16e658d2fdcb7e63d84a0e3ca3c1ae186ff58556758c889de2d610864ba79ceebb1f952888868f9607f8bb0e38b02398f125db29f92a1d36f239ea83833664c5a729eb6cedcc08dae2baf0c2e840914e42d31642cc986811407d8d142a5993ad6e8001556e91141e4671a5deeddc52ee14599a4282a5996b53081d58e113753dda0fc2d42ad79bbad8909612d618a81849e8e22a160d82eb7b73ef00589969caf285184b96227de3b397dddeb6322c87befb51049571d97c6885a356c1be9b44a2a36cbe97bb7357625e43e0da8ceca6625866037e0615e5c522567561b164a505f89315a9f2b54781e9af75f76b209c4cdb3e4bd52e8f4c9018dad87af33dfb5d448d4036348318d0c1e6cc6ba3c2abaabca43e61c95e547c23b128c9e460b7cab66ba5b9a440b413e7587c8ad9d1253fcac420d17159910a17f184ffa6c05f1df7997b83756b5c6294bb1d3001be34dbfe09b30e3ad3b10c4bd8422fb672ec4ebcf35589dc6aed9dab667114b911e554cf5e785becd4db1f6ba823260711d9a38183e549eda50e731234a8c9e21b2e6cf1fbd829b0dbba6ac406ed8346945a56b26dd9af2fc9a6e6c598e345fedcdac342b3079635aec4c388a31835f3e65c98e1697c47b6fb50233adcbe4a63a013fc2dd67c04428e574a84b7368b6e00a46b757ec91c2c3ceb872d714a4f5c3e7c2c9b62a5a7bfedd578438fe94a689f59c14a2a20874be2070a9a02c4f6f68c7bfcc46046370c13c119a2e992c79cd3a6da2d1eeeba3ce19d9728b50dd21ab5a6fcb174a12304016dbe918c4d356627cc2f56b150bd3bed7e6bf45fc919efb95e6cc4ea79478dd105971a4d033acc779292117df1c34d29e06258b5ad52e69fcbf6f267afffca345798ed17cc6b840bb5789cc7ecbca65ae3e5ed7cd46eea8ebcc1917733eb4cd742eb5680f3879d42e6dda83a0a8ee0c925d93f1eda550a08fa1a48217beb92f057ff9427dfaebf8fb98819d713958412b469cb915a53cdf778ce5efe90a8f59aa4386278e811611afd466a2ba942e7194c6aa36870fc146d4ee3e6e9e1f670bd33313ddea8e32851394d07ca0047b67a443875eac036813b55143739587d100df74acafc274242781240a2e79efbeeda089ecfab9303cd1bff5cfa218b4effb13274b8a4974bcae2cc211197bea6607d4d9a74b8148f8165c274f6e11fbe8d3d5b66d9d0a452c17458c5cd2edfa3358e2b67bcc7403528c10242424a3ca0eee7330ad4a17779cceee767e309c8b1971e69dbf264a7e77f1c074346b3e5e1c98440fffcc55be8cf7c6b13c67441fcfe88bdc46681a36d050eadb55c3b86db62471511a6c01d86dd03aceed38bffbfd77ca25f6b4c5a4a96bf4b4338b7a0b449616c41f6db53855b537e3766d9fac4c26262a00186bbd59e6afaa612e8836be438fe33e75787839133aa75409912bf9175a8728ad60b718adcc2b9e2a6b79bf83ad1789bd139bf9338d34d0f4f91f22e52d4c5cf42b42be1b50121aa14eb9eed1fa3ba7e6c8a2d4a8fd480ebc06a9a5a048cfe779c3c6dc4139fc17f79fdc9d5530832ea7c8b43ecacac9bb3593f501eec858244c16784e0fe0071df966f14969ef9bffe5432ec6de1c0b44db1d0300bb822be6e97a00c1c64de476c1dc2fdf9f9719c3bc4ff63b9c37074fceffb3c150552d9902f90ecd2802d3626e1843c1af01b211ee3de6b6d4b47a6f207ee2396230bf5f0d4158fc8e3e48db771b7ba797c068d1bf9a23d7bf63825e15cb9b2f73579b3c1ed4143fed7ed5841a4a65c18e127000e01d8e770b5dbfb11d7a7b5ee0b17833d6fdd08c8b30b3623b4c2332fa597a5f7c9de5a985e9ba288e1a43dbd03e3d0b035bdb04fa6b9cc783b088a2a4823c6792ae3e44ed6075580be065edd8d5a5304c5faab0cead305f475378d89263d6287ea6dd8175ac3b7f3da92ba85dc2a915226f4b8c69b637230d5f170d0874a83e757772d6bcb7d22c6d7055237d765c0eb841121e1c9e8a97d333ffd2d3e95c16d94aa8be34efe55d4a8dca3cdbdd69a7d55da675b7a9f88732cf818a1aacc56416431e14836e197e0257dcf25020587d3d5ef1d5b4b39f8f3d39d8621c5df4626c3e8a14f201cc4d95f9f11cf27c1ab88fbab8e86adb6b5325760eb7ec6081388560e29cc1d61686e12446cc8113a3cb3fa656dcf7b84f52a1cc8d5288c65ca7d51c7d58fc24ebf815a8b32f6a63f59da43d29618b933d8685aabb055d388f74ca91cdc16751fd3bda07400c71a94595beb8421e24790c338f033492b6ec4d1e6554ce8e38d0c47547f327199224ee860f344d622702e1f1b023e2d9ddc84fa148fb8a8305b86b1075404b1f5b9c9001a39c5f034666b7b73f08bb02f6993246026e23f39731f46f4c02ce3e5e6d0a91040b271c3cb9b77b48d1a1a6d7e3adc513082dfd22bd66bf691077c29cfb6ede816b62272ceb6060c76540067c5aa8187bc518ace621d626ddcfa00fafae26c86243435615ab0fa52c331ac52eafcaebc69ffd62791239d9a46f1a8ec6caf1e8ca2636659d09c402b62cce4765a09c961ea802c05c060d9e353222e55c5c6a17f44588978cddc9bc979a7d3118abdfe71aa8f19621b3e29a113fed5fb1d3b89fa34bcce5764050d92960336c4735dc52174834c424c328ed1b7e94086e68718ee133000ff54bbaf1827fb5d236af6a76d894641db074e2849d46e4fb3fd9163e1bda870dc63353f27ecdf63e1556e1ab294290657e6c0737f1d7ad102ea2da55da691f23085e182617fd4e628003fb6eea1c89586daa59795b8c1e6815e4656b917b16f9c5f3f0ec0dffdf84ab7c0486bab796bd76dd0e7112633e361d101634e20321abb58dd752713b11f9799a97db63677400368351e8e72531b36c9b3ca54277ea77ab930dab3ffeb1302c4fe76a8ba69f1242173d376762fb1d92727b34c223337878eb852be5158c70dc4e1db0fca0e529ffc1e52fdcf06132ef19adccf83f8af4bfd836d63ea687835679add601105b87a3888eb113c80af06568e25e27bcd30e44cc7dccb589a720a742def16050af5dcdd85ba14ba3d84de2d9c66b76496e286f8b845a4e217211ff282f0434f8ad46ecdf1b5f0763a91faab5927e5c6ce9c0ae177e6731efe033a818be6ba73d5999343327ac5bb70f407f8b043c0478e55c22c0848d331cd17548c7a8d1337042b1c9df4222af0d4dfefde791b947dd4a3c212fed3e22f00ed1de11deab185f10b0d512b948c49e169f2e909dbed66b7e349493b165b19a4af2f537fe4ac58a3f87600460c3edfb2e395b1edb496c88a86ae0327f0886a004f7ddadfec114ff2ab310a95ab66c4406d04b4b30c47def25d7d99e005bc39d716dee2d8113686f8fcd0752896fa11825b9b0f38a5ee06a73ddd2b07322ff2c031b087d9d235247c6b285f7054d5bb219f84179703ac3192f245d7957027890b503b4524a3ba8ddae7393ecc869ccec80d585e7613761cf101168d5efaa15b7ceb5a47d8e36433f0d3e76cc8157965550f87436f485e706140c046a54aa50c08666acf3d24fd301756c02b0cd90d2c721bc697a84373ff0e6f00daa6318e7ca63b866df1455aaea5c0ea9b0670f53bcfdaaf9c1c858448e46b640c4a12539cd24d501b9f1d8f9a7bee7b1e8078de647804bb14a832641638dfc8d3693e0ca5ab3d1d7dad7005131a6a12c3d0f12ac6fca5f3b7bc27442d99be40433cf5fc657948857b4b9a42b24ba7267366ac7b91c97a25d46405544b264a91a3e1e3f0ad7307bcab6f0306fcd618bb9e103dbdb04dd35ea15c385b9b9455dd4c6eec5d5373305a8dd21ece1701b167a3641b47537cb9143b3f9addb520992092e2800f43efe745edd1a0247b856d84494e5d11c3ab909d1c34c956d7ffab12d964eeb0499f5c659e4804f9c4314d02bd1fd8b88ce9dbe7891be78ead91340f6040c907f4e5346a18cf122b3daf17e241a51bb99cc1b67db444507d03c4e6f465fac2cd455a1ec149efe19574367167527ad556e22e6e994d148641ff213c8c8f7ee9eafed145da2e932f9412b12d8c689accda2388bc36581ff8b4ae0167391551b0e733fb7ac6d24f26b1772916eb9e0f0bc0336f73d828b4e46a065acc3851b479c4430d41faf3d318fe375860048d15836bfe00554c8b5365a159079cef5d8a8f12535830049809fc2c301306f4e1c960b31298e3fcbceb321a5f0c1bcc0301f7385b3a0d4052c89f5608930ec5cc57f5b62827220e589ff67d3f75fa5ea3e801114797bffd420de34965df01353c8ac107679977fa70fc686e4493d0d7722fe1469e508bb949ad22b8f5aee4934e7b901ff240103e94ef55c401105ae2861ba75d59692b19a6271dcc38d1a75e2d93f45dfb5009453cb29a9fec5f12cb07cbdc4dc64fb2e85c867853f17dec9ec570702c11dd1b892e7e8883f9e5bc16eac8e142465d0209380a488e12ec4e2697d91c897b75b79cc2508ef2db0f6df2e75af5feed6dfff816f8650032cb2911d5ecf21149603516f2ee123e4cd528224587cae8e5fe2f8e3f3adba261f4cb104f72f018085ecdf9c23badd86e414e9c012f3b4f18835fb36ad8c8f7b4cb94ad621c926f244bdf56ac0ed9ae1d641167b15141c18b1184cc51de0522c24b40afcc5c0ee26e3f7ab9b16863d6dad5fa7bbde8f48bab5e67a7416522a7972a38eb0edd17868a60eb7c57f0c525def15f2a9de5bda36ac6598678c896b6951790ff17a9964e61da80b94973cba270c3436a9e4239e6c4b5daba96e84b2b73483e157976650caa9ff31eefe74ce67e34523e793327ed097148e95e76cc379df377fdef083a402c19f0e7efd2063ee4c75ac7d93397915ad453ae30603054b1d9c0ce26fe7dff454a7608acc08d812ada6763b0aa9f3038576542621fe1689066cb600d53f894d9600a4864ca8c8e2794cc30c18f20233c2eaa87ded9f70aac332b2c971fee66f17c523403e01ddeb2fee33f6e8abe5423ca0bc7aafc88153dd2bcb05b879df2c123c7ab60b510f6c539f036c98b911a14e0c1e2a90fbc4365dd7cd0caf71a6ab08f133b424fd6e5989ba43b79a8eb22240cc511e9d738bf0bde5cdbbc9d3c2f3bb1c43f7d709678eb2f6e59af1c73aa4db108721e55fff7a77a87cef62ad37f0c378922fbf72bc9fc2d9ab16b4de837f3e7ad409a9f305f7bfb677d7d5a4b749892344521bc18658cc0ad09470dd43e4a350999c7d5bcd0be14dc158671b941611cadf8589a05cdcfc4b3bf8e41af81e7c460b59d1fbe5db0b14a3e2afecc8b3d19ab9492cfbaf685b8878def42d9227a5cf9d105624d36c0a18d20f264d29823a092b718606552a9e033c369eceb42681405f6ae0f91eaade2470fa63e2dafbf2c47103eaf5f19dc872b9025dc96a9ca600cf07793b1a0628d77efa293580a835c7dac60bc770e04edc263392c50c63c16b1154e989877dbdfacfb52afb7e800aba96c8a052023837dcad2a386cd4aa6817d6782df850217c367cc930bffb04b12577b87d3f06b436ab6346690aa0f173a4ccb4cd15b127d6c1eaf851d4e7ccf33cca4781df893adc6f24295edad32d0390666281d07219e5a6372f88c179123a777bbe239ce34d202ba5b70676fe34096dfd923d18ce9736203b981fc13e0c8a358f61c6675f993f78b1c9cde05c37c33a8ed86f858fae51316382cf051c0f5a213f53b68526915ea36499388b2427803697348b04f45857632a5b77b3fc28af9754a2c74c42723a09d6891a238ad110eddc55ca11134e9c3ef80342e21d80633da983d9e2c0c86558f8283fcf1eaaa5c20c9b841aa658fdb43b0aec8a7ff89d6a2367e04b08fa86451525018c3c48f724598da33f5a11066f2e9fbbd330c807e63cc7261ce4244ae258d8f9397c33835c4d81ff92c064a2b669188ea4c8a4c20935338cdbe0fd2c76dbb95256ca7153962faf8a94a5f94fe501a6049e0b95cca401f7b3fdc421d7db35e0e69cb3b00e3781f4dcd16db624035a5f48df944313689c7c3779e7029df9f641b34787715a3c75bb233e6313f8f81264782c18088c1549c43d90a662060754e8f3d58c8ac1842527542aebaa7c0788c829853482be0c17668cf116c1e49a9045981880682f6007b69d4f243a8e497c7cd9a6e557d6f824420301b4e8ea269b53b6e73fa37f3783c2059ad9681bb5a718e1983e3fe4b40615e8d869eb51e812ef94e38d55f513940c60cfcc292c2a54dc862d246297419cbc6527cec9bbd547c3462efe7b41b92c7df98cc52e82bfeb47983d9f8c01303c79c175e250e6c4db8934cd71814b5c02ed406bf2833f5b25c7c264df4333eb82a9f55206b2933f93a0f6c1df7cd43e64394a79c137bf04be2c7a8fcac1534290af56ab80eff079c218ef3aaedddc56fdb405f9c571e69b966c42403964beadfab66b74997eb15ebebf7925bea0e5a3e1b651225d0f0a3eec1bd20611642ba5f21c80e437b428bcb717f223b866c682c81a38bde6e117b7b1e940ff9d4fd6016658f1fb4d145145a2980042dfb9dcdc98436e22fdbdb9deecfd4808566500bdc04d4823f16e6e72533595a2ebe6e1a8ac935c78a78378dcccee68f781e006908b0592f081f6525507700506dc76daddbe3a34299be06cf13c35497be793ed11284b319e6cd67380935aae254e898944c255a91755e58e824aa06922177b7d1f46dca9f1bfa68f6c4475a925649a9f96dfd1b160223ae85c7b2ce68a7188c781233bb610f7723b7c379d01bb6cb3cbdcb6d90a9fa9b704e31fd42dd1d5fd87e58e4bdcd4379612083fd9afdfa2b888868f2a764d2d0c219db60224215519223a1f5a25fcfe70d55987cfdfb4c4f2594e7204111f119915ca5d51ade4729f5b791afb6748adb0be96b3ed5339f71fb83c6a70d50752498978a749bc94ae26f2619b02aff23e651f8f7386bf24ebd8c35db34de8647d8a7b08a92d6279f7b1ae604d86e58907ebfd524de4b5fe53f0cab694fc502167e61fd02df76ff56137a40d5ada80fd258ee6faf49c874451a7a460a5f5ff584736f2ce0c9a361a60952ac9c99e925609c5e105681d7af56c530fba3a4471a932c27e719a7c8bdc30dfdb3feba250efe4616b037eda05c633448dc97be062a3f493c3947390a436465465c53378d7436c5da6ef848838adf5294b7f1dd96e59f698dbd91c8ef112cf6f3d3453fc986ce218aadd7dc9f11edeb33cef5046d7a3d51761ad852b036487a49f93d398bad5887fd3ce649d85377195c8aac023f3c0704caef5009619fa08ee20ca54f8ce06dd9c1f4a52500e5fe1422a50552e2878b9327f740a719a6a741ea0fcd38606cae32ea490d6df4ce1a3e023108ce99ada2692208bac44378c906435a41c0935f129d3c5ffa098797b5a61c4171a8ffb8164063400ede0faf4cfc6573e5991c9bb79b290fd0247ce252bf466b83305eb8670214422fb00b5902af6595eae8f7108b9f3058cd42fc9d0db6ba443952cd5636964ab3c321e2019b040d8a9e4ea2d8eb26533a8ff36df68e6bda76524ecdbc56aab5184e50205e1fe9204210bab9ca95eefc38ee21800d91d7cff6ec24e6dc745dc88d1773cf34bf5080e94a6dbd960e279f8158c39f739914f4cd2b935f9fb0c3b81656ec27602f05e8b26305b4e61b1a9d988ed49de0aa46268ef7ac235f06e4946fad7903015d865fff3d01e8fcbcf29fe235f809d92ce94fb5f8a926620c7f9b62a9970751db6b076fa5d3be8d600fabdd579472191ff9b59433b29156576fb52eb2657bf23e755500dfabeb6752e017e5585e2a9d8f8bc693e61ac56698b2691370fa59a14c9f901e108c16bc7fbb1897d37da478fe5640e93c8399139c46ffaa75be1c30930ca05a7b763c1350d86b9e125e144d5ff7aee8896982ebd03ff72f4ff1b3af025495be0de011a29e8176b63755cc6e8d95c59c4eb9e3f4b7ed4a2ce0e774e77dc8a9c5ccbcb9dce821f94e040c10082ec80d63a1a8cea6271e75b2506d5254de8088991b15e18c0cebc4a83c3f119a07f1ad7664cbd26ddfec133694e17a5100d605f0702b7173d4bd7fa959f402fd9e0bdc8d4117ed599fea163c4e1aa392584b5a71de00b7617bf49b29a62f60cfec045860b7a49963bc28fb664e1959fdc96a47a0509b19ce4fce69d06d3cfad35fd8b0dc596d5e88eadfafa1fd6b88182476605f4ce29738817ef54c2cf3c0c4aa55f576ed707550ee4353e5e82d2f000958ccd180809deeecd131dfae50092920dde58d6da4e0f2fe240458893fa5802ba4f7c38358ec87f8815a929001661e7ceedf47322c3c544d8c0bddbd57cf442e80f4ca3eefd8a4079d0bafe54454c566f3038a65dfa2bf398c1bd9c4d9878704f7aab307abd4d764ad06ce38bfa173b1ed897ac363cdb82cfd02fd958c31e3ee49b321556adafee0c104794f0adbb0eff8c23dcdb3e5acb4f98f7674e39791f57d7321e67e7086a9f2eb3974df4c348473652268eaf3fa7f8f930e6d7b9fccc8d34efd6e0a91005b37d766be6d5c9a7771cef3cab24f88b2f91abaa86f5d864074fc147c1711356fe65d0f7c179183a1e62ee389e8546c3c2de43ed1bd58da92b7688bf78c581a0bffd79c556c7030a3fb703a9f4cf45621d7d1df90756cc7860e9b89b65206cc17f1663155feda4874e44198add1b7db189f77826c18301536ad48807b1dab3c9756e580f3e1fea88b5d2faaf39e4dd8f7707e58b83841c858755d49a2d358eac9500bf7dea33e7732482cc0c9463f3c3ed47d7117c7114d5ddded861123c4e885933abdc9c29ee2d936fd5032f0bdf82b656c19ce21bfca7e376c862a6cfc4c1588eb0dc99609f3626838b1cd0f8bb32447e769c8f25d6900af7cf9dcb59fd5863e14099a8eeda5cef6ac653c7e71dffa62a153fc149a16f9209ce767e4cfbe858e2fdec7bdd2a4681bdba0d3462c87bbaf5e5df98f98a84da441c66a14c4aecb03625054757c1580581c2b1ae8fe528353cd26009ff5264c3982c8357c7d69bb68fe961b60cecb2b0f514b5340485506b077074c2162cf127d2b6612fa0d9588370ecba88286fde14cf92c6026037dfdfb15d316a368f0c957c1112de34ebe5bd243ea94e6bff7159530b635b29bee9ba073444807fb9099475e3efd5b38a90fe6cf530294ec8d9e0dbde2c2bfdcc8c4608a37c2d8090bd673f6d18e65f09215fcdffa3effec36f3f03ea7f5ba650d28cb0ee0c7b7a6379338f6d431939dbb30fb5ae775801fb0bf7a881455262e6d95fbcd55cfadd1c09adbac300177b2cbf06287a71b62d302dad95ef8b5e61661ea92e385f80f5bc4cb1dfaf5684fe5561cbad6a21a9f2f75ea6ea2046ead1024e1948ca44d6f31b96b767be86d24976dd45831e0ac81a18611c92c70f32fd6e19fae639bace99065f3ed3bc02d0e4863bad58d2bbf2f6d1e243becf3a895f593e4c223ed20e94ad22364c3bf186fe8a57ab3b3818e107f9b220515efc871fc5211901753b5aa89e92578f5ba7544c515f36973d444eb1aef5ac060a55bb69944148c0ba603d99954112f991468c0c10c9b8aa9bad9cbd87fe7859f83237694098b2e06eb7abcfcba6171168718cf175976c043bb8536ca36f66068725d5885d00d40bc9235f511bc8bbab9616012cd762618a4efda7c3a0355bc1ec8e93bf8a8e658a10874a2b928049f305ce6a84fa24a383174c3d9d2270bfcd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
