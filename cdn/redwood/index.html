<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3aa78f39205572a1c4684962db0dc9d83786b706c64213ac9d7941c97729e2b01c6a204ee070489f9633fbd1aa52cb176fa09b460f333892697c4cd1a4747d8afba5ed23e9d00efd75c1d272271d3496d7093a6b8772756e5cd06fe3061ed8e6e6e67c3f8f4317eba99b3fa56cf4922c0e6e832726da9724ed96c18b5ad576d1b853869410aa702577986ac34f6a7d63d64721518e38a796ef09c319f45e58dfb6bf85dcb3c71b9806cb64f61d040fdb8f5272f938b02c19f5b555f29fba0bf631728816140da4e5bde09f3740223a6ff88120aa43eeb8403976992b476b99b1f71ee00a8310c9ec5561c7167038d1314842f84826948da7dfaaeb40c304a80d398a760aeebfd8acc558ef41ab57de133b3f9cc39faf0ea42edd607db3374c87685df5ddbc25f3b04eaa4a2edb1f80bcdfc267c8a6836599f7c1b0021f28581292c3f7994d6be3743448f029781e7b4f58e2f2d648afdae3e780acd9c98b4c1c87c36f9710810391fc2978a3bee670c0fe044383328653b7eaeee0ded92a3a8de46b22dfeb7923a86566c75c16271e52c0ca960f477428d5f71781eada314db059098aae6c31b611f667d73b278cc965fb004621f28887f58ffc1dc6574b2d15c67a3cd580902036374321d19f7cbae0ac8f5cdd7a4dfaf99eea73e90875cabd8250d0fc29cb0b57414db73e6f8852f5ccc704d9ed465c8d3ee89dd5662dc3e759e7d1efa2471b531506aada22697c1e1fa52e76b27c3ed04536702b54744faa42e8d98749e959934c51f490849842e43bedba537623fb0e00228a891ed617f879e0de7afd71a58cd41f0e1fb57cc0ddbdf2d0f7dccf23a333d22c57058a7ca698d439220b390924b6c2bb220079ffb62d4351b836bb0f9aa2bd09ef291b56b5c494cb74841fcca389c9f6091dd27c8baa2c3ee740f8d39b4f2560491996979f45690f7ace289d92923509c5ba4e5b7a43d10b3b7c47e8f421dd74d1cb0d890da2dd22e3e540d076cfe7a658ee66effcd0d804afc6d53ed727997ba1f11a321632d0cf07d863db696822fc9097c5bdfebc8a5b50ba645f51b57ad37302964694282bd477873068e649916f3f5a48e997ce68fc60cf73404c80724a710d16308b5f85d55d273033e9cd9a1a95b935bccb9d76215c66d9be73760281995640420a9c1d9eb23a74d10a911ba01e52410b7b0100b79addd4035047a3a954a92d6862e32318f3a9c5f51844905dddac23d4630e1f60f3e9a2659bc400a66e3a46141df8fedaa8c209dd9a3460380df8d5ceec2cd3dcb0d0b30557c7d0fc841c4c3af8b6a4d84e569f91410e9c39c51ac7629b2cd79532dca2f23b86d6cc846e790feaf09cace0e4a58c20e1c4c192416c5464889c299dc97159d11770692a2b9ae4856e0378269b066240a90db324835f4708c11be663a854c226d66e859f4d30ede65b080db356ab244bad15db77e6f677dc581e6544f266526a1e6b7165a06c836ef34e92f8faf7090588ac9dae8d5da0a412ca5ced2ae68a11656b95d6b94865701e0756d04fa66c9cb7aa59a507dcbd6f40a3a71273577b38c730cf5685864c3153cba356853acdedc2cee8ee4249038559e3f4db7880d07d02cc52b80e56fea3cdaa631533bbcbcb466d08e9251114082fe1cf54f9cbfc8fab4f85db353df439560b2fcf31fa75327c2a784e599f4156247c368b14a2b384ce28caa40e3875f9302b47c489730d87fce5c252eeb32b8458bb45e5f69d363eca4b68f2733279d034b70bf043149f0871dd3eb7cc52cccd9e018e5890aa4031e0b35a7a544fd4be7c1abc3aac6d32b9a7185da62f3d12d96d24d01bc9c80bc7c35a9592e3387fcc02020c925f0a9678d8f49410ce35c4396a76996224bb002abcffeba40dc038a5e743d39a429ca15753833042444b66b74f30a04113688a06edb6958861f08958674ce1032887b72b161c19a9fca2a7554ed175ca2249878c05b3d89d8aa7ee1d83c770de927969838af7c14073d2d0126174e546b3c6b84dceb710abb38b86fdcb8145a1133c13f9013b937ae3d3cd12f1862d947214e21ecc7e7eb4383721c472f04d0d856400b9a967f6ffd0434e1d8eafb8eb45a98386b5426e544aaeecffdc9a35416b5854519c421782b0386da73067a0f68eaa541539b81aba9a0fdf468c4d6e6404b58f30737d9d3df26f4865e4da2efdb275e240a8e1d0570d81aa9847ab6a6fe1d2193040a8cd4c5fd70cf976b6e0c63d798d820b952c22d07e953f4614fc0ed018be3e71726a84e402b2e9c8183aff359f9ebf700c785dc4499021e1c15048d966f9c5c7652dfd64f52549792ee52a47e7d447b2a9e0b4333ae040d157daf7b58f94d3e85bd9238a9a8c4008c62433b725f0e8d522ef6ad8957af35309f5b9245c85b14654263e95721fe71c58ee36f35a56b5ca268db917a53ac203ffe4a911f145897c716becdb0190e76d5a4ecabfb866e8e2edf96872c1fb160ac2c3212482313070808e5d7b8987813ea459c3b4bb0271ad8874a0283f65c269e9c8db668ce277d5a9dfa33bdc3066903862b6fec594b85ed89f9111848e7a2e5c9b0d047a9c013e36d1ae23bb38d5b1d7c4c440643df02141584813743d2b44d9213897a3619cfb0f59434beb57d3af53ccd791fcf4233c3aba6f12f5e60637b17af13d7e647ce1af502500bcac2183d89b8694f23ba24f08c22ddde8ee8ffa227887e42f46da3ec823f19772fbe5c0fbb1e20bc91f79cfaff05d093c8a28a711e47f4ddb65cdedad673452a921c8a07453f7440507d8b1ac130f95a700f8e34692845bec52d57cc6d4cd0583d93fcdc8d72ee37f4d1bbc2190743e3eb636e4d57c4ad755eac01468fe9ae00e790565a5a9b4c6c8e6cc089287325b2d2eed2c21e8ceef19eab0714e07d7503b4a24e895a10d4bfd7a6ec5cef730bac41120352e8b3afc988239d160f815ff0568a450d5a8ad1486b4e7e9af72872fa31c2a0364bc9d2ee10a92d463641c73c46baa39879045df6a06f1bc0c3c015b0733e4a56a138a6fd8626393f2185e03441cc408ce077557c61ddbc50efd722f7dbbf2bc2a9df3215f88047086c35b7212cdf34e6e91313b37a8680b0e98b9e44855cb6f9f110f8fdd764632a8a0710a521c6ec0b8893c5d62254964babd19585ddb859bb7318d3a69f16ce6f5bb8b463f2076e7a10364d1c7a9b97f49ee4d9bd8adb0afa8d2a70aa593f44271d47e8d3979f3707cbb767f3bfc6cfdce03dc9f005076542951300d35b9227799837356173c46abbb2ff60a07391fbc779bbe7c2d1682b9ff6fe5cbc7c96f24c3963e67e13996157fa1adc105996eab22990aeff97067cfeb733ab52194aeb897012ba27355467b24bf949dd62b3d2e06c99f6edd5272e1a6b0b138ff6ff827642cead30f2f0c9f4d7419fc99218393764231108b6a22774f8b1962786ea4aab8b58bf2d83e403856daa11d0d4bb3c4ab711ed838c1664c09e30f04ea038ad73f127489b453820ed4fe30d7379b90ac89c24250a739ba10229729aa630945bbebc6ec7fe9b84dad5e4aa4f261190e69e03d9024729e440b18ea6a7c6e9785046aa122bce21eeab339d7f5c915213d4145dc351a91f9271b6f4ca5083ef7ec6c6edb9e7e5c1368a26ea84103f62b6857001243e0197bcf1cb00f2c23ffe68abea4eefd361046f4a9fc5ee80f815f2dfcba4e68fea06f573b0597722b41c26c6d223f479429ec543308c6d46ade7fd3395bbf747b7f3e8c88bc550e3d967f459597d3906433e94a7900ac19d614ee7021dd7e565d8279b863112b39c3c60f8e6edf35a2ec42379559b9d85ff829c8173503568125129dd878d13a80d05e45bacd65de8939f63bdeee529f221a87bf256c3651a4d8296dd040b59d9c6238001083106cf1cb30ef740026d25780e41997d0c97ec7b90814614377bf98b3481cfc3de7ca475a97b3f07809fe87be9e46b58071662c1d58f16c5ca45ffb9863d9f26d65d1dae6fbd20b70b7c3eb502860bf94b3dc92fb398614509b56e3c005acc8af595c3c16489dc4d28361c9da7c22c53f41ccbd8ab70ab25039f01abdd14578f01a21c7df5038ccbbb17ebcf68f0ac7fea868d34dbb59cdc7866ce0fc6d72fdcaa70481bd83da6d8fe5e1ec834c02631502f53b99dc1160f59621cf8055bbac72a7dba918502457be8715369d3f272a86de29cf89dcc52229abf473d9b0be38b6e5974005a46ee0dcce7c97674544912a3c04c9a6a4d38212ed29ff65c7e09cd420dbccd2842cf6b77dd08daad2f6868e4f7092f6fab2dba83ecb2bd44733c3082d09f2c2bd0c7b79cd6cc14952734554d2ec7452b353c7034f1a5a5a25adf260fdd880b6950adbe39cae32c48ff1f4fc969170a0406be485f0968f571afecab4f7c87490f34fe78e056917e1f916c3e8b49fc002af31f07375507a64873703d5ae7f380456f21f816a9aac50c709d6736cea5dc3c60e494e57c1888358ac6bd40cbc77d514c4136bd343616205d5284beb95453d14b570c9387929386a6253146426fa7742c51ddc3053a789cbcad4b670b157850c7118b066e624cd5a2e10ff35ed781bc29ba09441c760f6251d4a4078de5eda299bcd1fd825685c8dbad29270cd51967d7d175bca392a52515709b305f58ae5277843700ad77c33765637b23746c71aa530592cb5d032792dae5719b0f52b3a9c37005d9bc067caebbc0e953ae35acd50f5ba2548339a006e97cf06959989c3fa5e3b950c7e50194ed1ff8bb9a77ec722952e3eb31f97df768ba79b73f1d6a1df88a187f1c8ee91e5ec8d92f21a569a4955b3fab45d0b282ef8ed85a6a49c1a3d562c8c5d5c174d2485ed6065fef097565b75b106969bf1e83d8dc87a35a7fcc21cfa6fc7e7a0051f16ba5c23ccb049e3314c9d984a5544e3ad3e9da49a120fc0e918e9c92a223fad95ca5e6660928c3c772be508748692c9772d3868e07cbe2918fcc9de11c190348517f213dc2059061c5a02db79d2f37ce156d69e5a65937d50f2c555a6de450fb85be0c6626bca9500dfa4227b6c7f402141d9a54a31229e8dd420fed1117a23bc7b63e18cafbff4523bbc2060ef1d804cb3ac795f7244b5c520927066044ce58871ec8b90a52afbf703a59dc4150d21b9381243d06256f0f1a17c2c5d34f21fac4d3cfdaf9d2902c7ce5e887b2b8f98aa2b215adaa45250872659f7d251a496fe41ab075ec147128a0a22aa7557bb3cbfe9f22e89584c05327ba105856db031c715d2bbb1562b699724652b31a7ba78b494eb01dec89cffa220e3dfc3be765b3a33dd634813020c52a67bd489de5b8dcdf1ae7c07d5f7aaa12884f6ec5121b13c7a2170a776bcae65e548cd66bcf38d14438077ab1ce977912d7e898dc6d768602daa82584d2319f6d98d9cc1378b84eae786c383cf32f9df66e704a862130a44e0a0365424833b354a51ffb0058052fa47e9b9d21e2805a34dd4ec212c4d5fb79be773fbf50ff3e76f11e4ecadcc5ecbd1c5c94d56861e6d2935ee6efb85fc6d892679f80554ff328693cdd181bd7828e47d34a6e10afb564f6304ea2e2a4de1425e05ecb592ec85cdd1832a2b35e96cd339f847ce0eb34992b1fdda58912c54647cdc6a4bef584f1dc68fd4ea083434d2ed5816db2babb2712fbb703361c3be0f31eff494807c137c37952e4d24ceb832c7f50302eda7b57ccc32a08d682d378d72c07597c1871d9d7fa0df4e4b7006df1c1c60a119070b32ea2207a4738252a545fe37f1ddb3162e87fe39a3302bab3f3fa4fbfafaf38f8e88c6a75c91a61dd57ff3577806cd23190cf65e942d48ea0a98fecbc425d222ea4b230899ededc071bc602d9833b59cfb0547f9d29a0c45e85b918e65526d80ab7eaac38ac0fd1cf2a313c3d00128f66c8dafec917a17f86ba9025111e6c1fc9e880aa809f9dad051e7fc329e9ac94ac0211a6644f72de79fef3cfe052fb38881a04ada0508044446ade1a491d0a2edd021bbab735feb97cb259f06de344f692b9d4ea9d9f2f8cf6438200ac04bae82ae52db737678949b20ac7e1a0385448e41e1d27a28508fb593a74b0b76bc00232f4cc21af74032401f14ce461268cbc8cd7756cfe26716901c8a337e4704b25d5ff5f53299ad7d13b60f81fc53d3a0a1be5e026824ec40b82e710bb702335703e90cb1362372dfa62b45e7cc487381d222283a904c365ad9fe0684da5efb3678543606cdb3076972df5c280b66a4897870df9d2f991dade9b76d648f41ffee44f52823499b6e48cabf351943be5b0e0aa26da0426317e33cbc6af594227707b56486547bee207d0b3462a5f0c9c65890f155aa6f6abe869610310377ab7e299820103de1c6aa1ab8ebba92d803e8ba0aabd23fcc657b90ac890f2f5e70dd973a8774dd4a8ffe343fd73eb25949e759146075300537b063119354d7c3a6c9e5de276b53ffdfd4ce41eb1fb9533737cf0bdd80b58cc00c8932e449fb4f860461bd020ec45970de5ce19df542c01f8433087be8d287a5fd66bf852cbd57be1a942d72509a2f8b5d530f6c8cd77f1d300f3da3027a74010de2a5e8707e93afce79e249aae3b6aa055b3209bbeb5ff45061172887a43c56016e47e2f215e29c62c62f41670231ab82fc8fbf5ad72d70c5cbd99b25c0c87f1ff7b8db864a7bf33b5a66629cdd7f81689feb89dfbbd0b608faca723d5b9f41a0b9b4a0c098ae37645743ed6c5620db2e46cd4d83bb1d59f893559ee26c9094a0a5832bdcce32df612ed1cfe1f38e53fea0c8044bc249a99370af06108dbc94f1c2ee318414ca35e4dfa9b6317fdb2f2f5c89aee544054439d2382fa95898c3a0523e23e8ff67d22aa56cece5eec44c298f837bc484ad9cc4b841b89d4b7f700bba9a4851d3917654c9350194bf1aa7e3d64775e6dc93149aab0897f25c21fe80f78ad87e7c3e881819f94ee2c7ed9c8608542ea8618d2ab97fbcf833a54c723554ce756aca95aab1abf185f6d848a4583af51ae045cad8229ca46bbdb32294e6803cf42e038cb73ef135c65f83babe19afd3e8a453afea8de1a8b24ac56bd8dfc7a3506a6b23fd05ca0e81d785b80a6bf4305b7ee8406ed3956f04f2c3fdcb5abd13e6ccc5a9f89daeab694f9b30dc525b0d55c64f32625e961b108d35b93fca749080c432a69f6fd557227637ec49780a695ae42ec47609649d03c6646ae12b127892689524bcac16587ce946aa942f3fb18e55e985c3302c74f8ef112fd78348a159d2f537316fb087911d50afa44bb72efd6b4532e527615fd9a42cd0cedd5779c1ab8bf035c7894ff4cd55d6560e13ded1f6c306c686872b70d7bc0dd46dc54e7a1897415540a28f6fe33cb386a9f8f75c4c9c51faacb9b7471c97231c2076edc6f65fa4ecdb996fcbcf38a6d15d3f95af75ca89dbf2c765e2fa36f1c38ce7acf9ea3dd62497f2304c6b50ffa96e8dec18e441a7d306d26ef46e884269f5e492a40c2784a4bd7087e3a6db8de18c606c5299ee387c1c8a1069be80c2710a8402352b9d2694999ce7e48233bc0620b0044f3e6dd5a5ada60a4dfc571a569ba19a7c7163920871ef65c29ffac6a13ba39e91a58a54d830c5be225d9cfee767548c8c98fcb0c2191f00a8d5378d5d9bed3585f3ab8c0b4b7a1ef0a2cce8dfbe3e237a8767253e90b4f7e2cd5e64482c1b8d8831e2bae86f10a43981217ed8a23781590b04a85113768323df78a51a10dedeb0be31ee4527c4388fa8c855712d5c2c69ca93b8b6d653c558e1938f15e12bdb34abf0780ba26b5407d8d7dff1ad31025e1a1846a91c0f24b72c82d9abb9359da2eb65a21fb12e6cb2cdbdc7a485ee35d40bc8e3426819baa6b6b713a657f0113f53654f36dd86bab3f107e776c8290690257cffb509eaf030869a1a61d7ad9ee07b682536d23db1a2060f9d583cbdb6221649a6d2db9ee87d8048c742f94669f52394de41480ebdbf6ba134f082c034abf1c9ea4b323afdb78edaa5a7605cdc677ead581b80f33c7c951cbbdc3c1083d49f901f6e69d76397f8e1280bcbc70b802fa4957a10bef0bb025de68550c4f864bf1a6968c1997fa5d612e148088c53a69dd36b9824e46492f141b56cb0e34a8ef64ebfb87f6121a2888c16934465fd90b242aa96e4ad5f9d4322cddfa05d61012c4c2acd096b577f508b450517742022236a7922b81f5260f7f68bc6b07c0bd0bc484e393555b5325ba122664ff76fe4f7cd3e97c7617a0bf4277abf575e47a812cf67bc4aa02cbd21bbab24789ec4a42c3a73317feba39088b1ae71b7966108760c4aab21c3383dafdee0e79d07cc694f82d2efcc5ec4b078c6fa89819c86a42a4197c70279c54237ba6dd5812f56f8b516f08825aa545ce1de3179f7c553e84a8b572c2bfd3ae681f58af563739960a3e672b426ffeb43ed953a3167d5ebee99f767c25e4786b801c7aa80eaf3a7f5c54d176fee639431c2651758d66a7433dd797d90e389743734688a5e2a02e3c78a79d92a84d8202d3ae8bf0f6afe7628b753ac4027ad1504e8182c73eeb229ea077556056a80e5344b4a940558f4b39d4be222d248c695ee374ea893b67f80936f43745f641dd805bad31047a784a53f22918547dbfc2f07006aca4898b26a04b086b282f9ad16cd98fda7079a06ce3348a163741f3066247d19c5135fcebf089ba031f4bcb9f610ce1a137d2830adb0d70ad925bf167463c4d1b2e5a47873e14cfb4529f7ca4287a52c56183da5979cb09bbd2e56a324cbf049fc54cf616a0ab643d33792576909bf445f84595a72f4068abefec610d2ee006cd423af489de89646015f0d6e44ab85b5c89220540457afee49e10f788aeecb44dab17800cb65cb3756eccf7926a1aa61334e2a5981710e0fe68902b3b5d030ddc1561476a4181b152a118e4693a2186fbc349b37a7eebaf65cdf6825f70a478879e01723098e109c5f8fd6ef4dc419fcc08d80dfa19dba59a98eb0b1f9268f5efab901e618a69067c8fce8dc155f05c714a46aa68d729be9bdb5d8d09341d78c0ced1394b61771d8db0354178db3b79155fc904bcb05d996cf2262ef52f2d13a14c4cad202c820810b3ea7cd5a44c8e9a13fb8dd1e3b53aee0c90e1c4fb19326c30484c65a0d597ce5b376d41ec9108c683469ed18c5ca909f81f684694d71ca3e853203b5cf6bdf5ecc665303cabe0194510d094f57bed37d3a9855e64344d7f0d7a8d76c66d8c744e9adfd841a70957291c2da26059b4c688d3381d2903d65ff6cba2de8c4c2f829708111086c484db4c30dcda1fbe014e2e3a4bc4ae3aa38f36372942e40c1fc37cc38a1efc09d34902b3725ff1147506a35c90095e5cd2618dbc82896889e07554fb2c1ebc5dddba5bcff26d0641f1a57ecd7c6bf07a3c20488e4dec23cb50a8ef0cb6170e03dc07444f9b0f3d6a60ea24b616660e41a99325af922b9d507f136a3aca1e2a8a194b7bfd1011e8ac2f47afb509727ba1eefd27bf83309fa8ccc575c5045a62725126d65004a979fea20e8a047683778a492a7962f61ab758216f84201741c1393a198b7cf164fa2b97005f27f7b7e615551ccc05841242e88a176463b2884e4b1d383e7f45882d5c5d66449a3bc3fd2847193262c87577ecc21721d826c6fa3ed5552f5c7391526a79e2926dda30286033b26e42fdeb506f5dab3f32f76c23eeaf3d33f549c127d8e2798f93d118c5f2344ef1a09693e9fd13be6e8763d151230bc58985fdb29d7c40dfb57498aca98367333f18da87bea017f5db2b97c995ff14307eaab276744ee8ef3d0a1dab1db96ce7d368f5b0361c07cc262e4a6c8629d3d5d1c6178fe5f9498db1f72bc19447a350ebd52eab2f0603b30da6959a3eba88f2b9f264c44b727653b8d6121d02900f7371a205754e2a7cb6f4e75a1074b8e660dada56f39c88b627f5f3438c8fb5957000a25cce7e595f8ac5fe9fd74eb7e1f1f2643826165bb952d4bce1e3938eb794d78cda68aca11e56ae81e595f81196067b4a39c26f7213d9ea5f28f6a70b059e98ea65514bbd5097b20975b7c40eb67e13afc748b07c95681fb578fc3a9ba90c7897055df357f37034e8379313ca3e0ac6cb0a2f12cf4603cd005ce377a074d6fbf19a2c6a7e52edd438f9acc4885b595f7bfee4126836f08c753c96a6fcc795b1755cc835c85dc963bd8a6541fcbfab24ed8fa05c831aeb8b8c213be4baa20cf3db3790d33993b1ab92a6990906285a5f7cfdca7f56b27a3491b8c620b65d2cb1cae7378ca350a20ad21711ae8d3bef4c923d0e1a0db54c7d4f73eaf7318df9129efe037f3235d03b60ea726d956abb4cb77d79730c5889d18b88e74f70029633e8cebfe097cc1e7315e39f0787f3fe1edd91cda681b6219d006fa2f9908135012e33c14dee4e593638de0b5f8ab03b775b034bdd0ab79d6543f8274e9d88696041caace94e109dc02904519c18c191fd4fb4585a110a246490b4d4e4dc74abc3687db3dea5634605c6c6bd047bba21f1565c0de232f770c62a138c0f94b1c4db51030216f747d930ae378d4fee4694ed79a8c506b009fee74c7fc9cde9a175b13080e598de14063d7e58662539446c5fef8d5b038f4ad75cefe3c62b9e474439101be9bbc662459f0bd1890d01634d3d9a18c1f3d6b2858af9ad9c943a4cf18030e34ab378c759a5e47cbc04c9ee5de662e012938bde0f4fa3a5afad8f261136931cc29250d35817ecb054d7cd6f34edce2a5e00e86e87f6e173282f17bf2c2ae665ee1ee6c442392c6537e205a8db91b7a1f59f45400f07d07c48df6bc1ee9f182f2e820226c79849827cea48761731036350bc56824a1f5b025fa9c251cd17aa67674be83b9b21622ac6ee89fc2518ddf60787a2f6395cc0f2f4be6fb335e1e33eeca192d45b87638dde4d79e5097e9f043bc4000a703dd822a37db47a9bb705685fdbc5a0b2b70d7e441634ebf3a8be4bc6915227b24b62dd25974d283faa0b15ec814ecc6a182a8d38663058a6d1a0382923b57c58f194e33f53a2cb6def668649f419ae8f6d3ae186f5627200433293d9bf5ab5fa8e11abe4a9a9ebc71b2eb02cebfbed4f3f1601e476f242bab160fd151e3ee0e84345bbc6b1cf2cb80f70dc9b24c7d4fd7bae0ea03bf5ae39036611e807b202a309c1253c430236c525a4463813c43d535779bd3be3f76bc7b97407b581b6677ae6907391efbb7723e4258d2d59f8d56fe908e42dab136d86a792a6b75c48069266378b65f11afd51cf0273f5c57819659e707b239ea1ca9f67114cbebbe656b807b7b521a2e0d17528327b240ff61c8e4a759b6c9a3e668b57628a57a1ad79a716f860a25a275030a637efd87607bbf07df289e1b9cf4b7b7c426905c1512c71ff8aee46f2a0845c9395c2b9155efc7c77ecd0a1643510b52471d258a4bddd956d3b868f32283648b674f4b7ae358ba8c8734bc5e19c5460ab4509c01d70995cf19973f117e7242372ff2f8b284962bcab9406da010f28dd170a1570236ab951dc1563849a59e8bad00c0887c90d972c30163c2f6a44976fe991f7eb84cd0e0a261cc4b9d26d26df8937681f88d13297155d0f03320a5e68a4eb31f4d3e0aea5cfacc316ca808cc370a15109e681c9314205f89abb1446f50a7773bdc7820315d14ba200af398a5177a0491fc61e99d10cbcd5b00764eb8713929fb0112e4281a85d9f9dafe7f88544458f405db0829456ffa424f57d4ce4138c354b9cfdbd657dae69f15369ee0df66f448a2327d6bcc4884b86eae357687dc3f9daf94573050903d655d2d1410b33f2099a18af95bc523caea0d46990acbd37ca213729020872f58481cec41c2921d4533322cbdd9492e002d42c58f4d6664e392aa40c993bffaf47051240afca76e018c46f654d856c4287c5f2e41f9b9b3f5aeb4299be7d69422eeb6d9f2878233b243fe1c572d88e0403108a12bcd21d3131d3229fbeb3bff67c54de5b6695af5764628cbf3b8e7d27b855cdcc90d3c483c9634875a720448af8063c424989798f65e89ebcd92dbc0b418b7e6726b0e2442e09371321484d8d890daeea1a3c4d4e9d6cc4afad3f7b7bf125f2137f5c94bb3ab12ca91582577cbc086b0d96104b6d97e2fd9a12b90de83305a74a7f26e76520ca002dedbb62fdb010de88920f6a37a331de5794a915db2d5f811cbccbd212d02df8efe261451b0337243624a7822d2773310b8f979f58edfd9bc3e956a6de021669ae341e6abd3fe54bb3eae65db1f583047b447655286c0d9b42745c08b4262b9bb089555663ab1229b33d9e0e27eaf246ab520f3169075b14a29f78a0b0decdb7d14c996d4631ca61c2fa74b81cfeab6f5281a001278a9b3470e118c9dccb7ede456d7de65cae511103686a2b948e150235bfdce032b99a73452b1c3e87d52b448a90903763140b4fd7d4207f87eeba603a458215a7e7538b8ae808919546a1fbb87c46c558ebfaaa27c56ecf5162f9287f1ac05f873feb4579015bbb51d02463b7c6f0453b54d4a9072b9f5c1fba60417a19456162b916c11293ca8734b504d12fe71c54212b5e40e529d84ec3308c7e5c4ddca8e73f2e4657721d86ba96fa37b568f8f449aed6ab8cf7b66b5ad4e788cec8e78471cfac2b4111542b913e4a2bf62cb94aea98f60498873d90dad0f506336729bd11706892aeb2eb4da0e227566369807a638d1db6da40ceeda54e3ef260f3a8141db023a480f4b5286f996ff093f502c424f5d7a91a19c459f36d2b328897d7459c625502191a465db94aac96f34bac4f3e806163e21d2e2e484d3fd5992b392fc631983673605f758d4a0b37f1891587f87e8e499123b5d9f9141218dfe481a89930c197c3b977253aed76443a399fdc4dc3542caff1eba3b92b151f36876f186526cbdea1261a5eb9a5a8f615d6c1dd505141f1a91ef3b87c6fc2402d379eb987d191820b4cda314a68515a3b734ee61995e028e56726d6a330b7a1f827e3dde41ffb09c898edd3eba8827e01d9e7e2ef3ad270e29a87dc1e47c09576996f9b74411764a41e5e5fb098b0ebbc64ef665f91cea1af0eb9d28d826a77cb58edd0d2cd79192fbe42534d372cd11d57aa14b4bd62d76ac01aab66d6a32c75a2cd9b7d691c67b3225cc8474f94eaabae43383af60fa9caa468ce137f54e4e82d37b10ca4406a9d895cb949b3b422d5104dba03fdc4251fe512d272dc9b60201570786c31c8d651a652290d1f419f8233c0659fc3319f7ce4b5ef2a2a13c8d7f7447994143165d24bdd59423f755b7c9355009e14a38a4a6ca445d1f672c2f397ef886b0625765b0fa3c2ff4af045f0b7b8e946c40014b166b41194ad7c6d4f5d5f578030cb7359da717cfd82f4e9c199d60f2d8de6650fd98449937cdfc2a489e3abb4093d0010a90486370aff39d3378df9a3c1decf326aea6774fb1f22ddd65892f3918efbffadacf4f01e1138a4409a4a54ca2fba82c34f2d386f5796d4e2d859c452f6c75f9d43eb8b22d65746f7142f26fe1ca55d766eb092460762b4c2a452c0250691f95970f329182311ddd46c6d651d23335b8c060578bc3075d973a01c0bf7bb6e891303b695f3fe8ddaa578041b8aae9d334979f4650c1dfcdb31d8cf7313b979fa36444033aef4d2686c7683748f2532077fa8424d886fea2a2ccf7eeed498eabc11a56ae917fce5a4e9646c211cfd3c8d11000c1e9f8a969ee1fade0551000fb6ef9a63f49282efba74298d42a287da316a758ae2f291e48bc4c09f52337dc503497030e00b368f116ceb4e6aef8dc8a8c8eef715bd1ce480b8b9b3e7601d8177ee1536b37e93c51b31592ef361a8926630fc156bdbb906805b23176c79c1098b7708b041163541c031f2146aa36615f2293b3ffd5bf0a675009c6b4923fb8d7f5a6687a9bfff730ee5cb02c32391f62cc447bf7de8e583abf2a6571b67d329239272da98e0a6dc0bf4fb116b8e7acde5e78605f9baf61b4e6bebf4b87636b922705b9b9cf041704652911de21805dde58d3006e9cb5caba4e8001ee88cd04a6088ffcfa7bfc200977bfef0fd41168e26a3f1ce7349c4afcc2f3466de72e52fbc88f8331283c2637ae70dfa90a008d4669164d2ea5ed9ee34fc72ee10226103c0e05027d9028a3845a36dc1ce1728c6e3c5b98a7b5362a6c22680bd21cfdc3a540f53ae4b4588b3c3744bda94ab440ffb2f0584495bc148b9f9648e59d4c03725c03c9a0d664166e295ff64ac4c59c455ac7a1fdbf6e6f592fbf2d2b4041e1129476282d57a839a0c22d62b664e4dde73f33d271b78222d84d4633cf3cc559609b39baf14b390847eceb6839609158ffa74a8e7c8e433e7b50fb1df3541a7ac2495f19ca6669df3c4adbed770fd058eb948d36816f0f3f968fda01b9341dc0e49773e581cfc0583b761c126755cc489ca10591c6f777ddd272dee40d6cbff9e9e0feef9a073eb65ef116ab2b5013722e0749c0ede9dcac47ff11e009171ca807b02ab6bd18f8be5a2261f304f3a0fcc447eefeb717ac50ca4e1e90b7bdc450fb94a5222b53ea03cdc46a627aabd038e859ec9e3d0b713573dfb08e1747df86acf89b61f87d2aa5d2fe4ed719a8cd307a074897514fa7fc8a5082e734bfb50a60e3f6e08746c1f7674d72fe4ca43feae74f4f452a6bb96df13df44b61c1b18ad136d5fd7f62077e61e8ad7f6564102a7d6d3b6cbb8834cc121b49c0763e809f90b902f589c47d772df22912ff10c428e79b4a254aef230bd92043ef9eb988f9d14f7817776b3eb210df958524ef6f771d27ddb6a829b25f4b49e70e673bf36ada012e6e829bb5cdcc8fc9e93c6bfcda020ed31d0b3df2543842312a1a79aeb44e37453ef52e8f41ed52ffe9948e15d7edc3bd8532055407c4b796218ab786515bdd06fccef292effa48c46eceb9a365259d7f9498ec2f0c4aa4b43cca6773b452fc9edb0c5263e02f9c845021aa6fe3767563f438f8bf0659bd0a11dcbc7df8b3a4932a74de262f0b6b3bc56b3c0e0453ac341dcbad66c685b2bc4f8a9c6ae935141df51265f63949a299b0cd122b60096bdea646ae1325e2bee25e70e7a8fc07ee3cda8b64b6223b6b13cb13d54821d6a8dd4aecd08207ae38c5eaa79124fda8689aad3d9cdb37a741b2a96b35e05aa986b9f6a20278cf13db9d1fc4d8554b463d4615d6db3ec9b4eee6f4230152fbc879831b0f54adacbcc346eb05f26336b81838278a6461b4d68ae6c64b4f2e6a815f903157559e441995412e624b5e28f93712231a0b92a4ae0797d28b7843ee37ea29e738697141e6b0fbc901dc1d45ea49180ba927d60221526a3f8ec0a15b8c30620082733a0293c7babdc7fcfa8713044fe39ffea84c92873019d8d3b37ac665da8a0246624e52801cfe023a571e509cc7dbb1f55b82b159572810cb6e5a20d8ab5a0d0aa70a365088ab931a468ff5234bd46ced73cfe66436a7c64be09a3cc32474113bf5d4474f3b74864adfcb0bf8659c39082a014b48d79ee44f9df1283c1255d180a4a90fda06abe7b9001d52d8009c3b9016c98d2db04a787c87786c491411345dab573192d75f17859c9440643a245740c738ff0a957c4b6acaf76f265ce5491ec55777eb225f72f3e0536bb5b42f36d9cc39740ee0d3d1e0643ff3efe426319d621928f6e8d39bfd58d392379f7ede455ff48c793526336d81a863264f7e1efcee592792cd5ad336f9828ec69cb7fd2ea3e0f1b402483f2d16d62f3fd8bcc6b9357238e6744158420b2de62e079c186d0cb3f0036cf8b2a5ffbef4a914978980bc7290e5dfe437542a89c13bdf012142da71219557c9c94ccaac58d2dd59c9d62f4124b69f3ff9f4c6b611f33500372019b61e0df69c6413c80b2ac3d615a13b0af5aa013245bd3a4b3c857c7927bf34d7eaf28a5611adc715a60d11320f097d57315229502cf2e9065b32c68558af29357c7179b83ff6829f0a18184dabd1750c527713f762623cfa2edb7a5266dba852c760c35cf93aae40f9d5c00fce7fad7dcb9e7812f75e0f045570a2524ebdd46292895f2516dce966c0146e34194ca787ec96b8f2b322691f5d71445d7a9ac57804fa85f7067286f7f853058db21a086f0996455964ac1d73c3c2662c89d5ea0d1223831b79a050d02e118242d57d2284215a1aeca4b0c5408b416af845b73b88f5435ec37eef99411befb3277f013401cea999075d8e65342fd2af95f44a980424ba39b18ddf96b7c66c51717faf6babfe92565ca4b2976799cf7f52a4b61bea451f1ad33ae7c7f2e925202d47a496104f13513571c354f9b52f627e7ba085c2aa3f6d66e10bef8096fdd87ae3a47738d30d34ad2f86097ea8b73782ec2e49255e396e46b09421dbeb2bd40c75674b39006aa5afd74173827846a185d3bfd8c541afad6f9d9ff0125bea5e8d19de90a389a2755003b2bfd5fc00d2ff27170e716df7da5af8b841a1c5175505c47d5072e9a0508ea6d7dacbc9c982908e54d3da4c238051f30ce723afe34248b68bc56b65137d2d287d539eb334f49caebea5cf887b2aa12a8e50c1275dc3d172829031077a7456c8a636e0edcdaec1fcfede2835abbec1408780d493f6e169c7accc4b641ac786e06fa5696127c70247160580886d0b0617093b1eb723952945f1a4c7e8d1559ee37f7d795f0942679f0037ad906d55b01758a9b18f9e877956500d04374e6a9596c5e307b6cd234c793d974c1d428683cddd9a0b51c6aa9de458baaa907817646dc7af06fb6e1876318562d3cf176cef8862ad34ea5aa739eecc0eab4411532340aebab6ee35fcb6d7f2c9087e4604c78aabbbe4e5d531697001a506bd2fd3d95d475574cca2509a2b14685d59096eddba86a6fe6d0dfbd5bf8ce5c1d3e704eb837a389e9b5d01406dc444a4b5e9ab7e3c51a5ed4cfa39e44a76ea1e68053a3a52c1874490db7e4801a36e8d5e8bb6f41203e5b4b861f3b4444885e5fbeabd7e938ad897ee272d1e2ea05f6ae5002eb226967809453eafe424b6a0bd3f4b72af50cf96d0bcc8bbb8dd3167326cd1c80df6474028a1d33fbe15690e0b6eeefc91f517b6a05332f73848c42795392f94a479ee9d4243c285e5c06517b72760b1715424c4b6fe8251f572cea72de43ab947d919ae2ea5707a5190fc961355b5cbd833bfd864bb0a9ab21f55c341c77eaea045752ec7e3c4baf703eb64629822f3e609fa02b57e08c960b03eb3672fe7f0d7a44bee15825348a8d8c1fbaf5035a48fd7bd707362c7b0de215ab54ff082d9698c950483f98b3ee3694eb4d440a69846e4ba309f5f7d3a3b66660b382216e3f53c0a801aec95641328e9107719fa1838cc68cdf90c96314a6adc9628335d7947caa87483969e0dfcc523d6a4b669b136ae74224c6711e336336edb82075f5fa8474cc6429cc65c7cbbd0258da85d36b976761a89205aba5ad0290ffd422809f690f87b51967a0fed9f3da49491f38ee7c182095f3152d1f491bb86e1e8ebeab4640d2ba3f7529b9b8a16f28349b465afdbbae3f4de6e2a62f9bd47487f91d635b2722627b6f5c4e7b8778f66df30661b5861c992585275ea7c9377cc7005abb83cf62a0471621223cc337df1ad2183228dee175e078ac539cdd3b91c68d45f24bf459c0583d2038c4f8f8a8771cba162b194e35e40a2b175305b158429be35274c64ddb0a5427bd87cbecfab5b203f0bb15574821277c1edccd9ded1d1f4ea320935655600efb3b6ccfbf59bd6ea29de7251714409ed9a9b8155ab64506fa0b4044b3ad70b310b65d643740cbd43ec65e71b97fa83755c13446bf1ff5b4a4d1d4b72bc42ba52e129a0138227903e903752037591a7dfdda29bfbacb357ab93bbb432f0ed65fbc14131bb269ad560de90307238084bf47bcdbff4b41df3a300f2339d03fb1053a2629566a815864edbe9b33c20842399d9979bf208e577ed286c417dcaf43079059ffd0f642ea27b7df202e6c762c72ecfda07ff9f7935ab8d584dcf02ebefaa3016c92a8922191d5ff471c1d603a9c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
