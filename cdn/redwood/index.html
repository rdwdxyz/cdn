<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"32a01c757180c15fa4e5b41a420bd328053a7c2d9a89dccedaa1fcba153137d27d0bc884fe147951f86ad6452e957a405e0a4f3de20f68d88a122c5aac7463f0662b45990d3b7a438c707d2fd7e02042c0694b6527a1dc0360ebfd92d28885dc586c830f1061af34cc9d14d248c8435fd05ab9da061984732cb441bf4717df2852381f765510b8fbe5390b5552ee00df2ffbbe4eac600912b7dc1b6d6c5c3fec3c3f54ac6c2a136474ae87593011d32628a04da203bae04822cf84ca56908e31cc2cad244c8a373f722b843268d3e4e41d7cf7a1fac84d2ff04002a8a4d7d56b62d6f887eeebef69af8a4153ccaccc086d418c6f5955c611b54d67c94aeaed5712089346bc52eeadcbc8d6ca7a50b31ede29acf1ede662c3e145eaa0ecadbd99974e845435d9111daf62ff732381fb81df417fa9c6409076b934f791f479ddc6eb62a55feac92fd6baffed517299f4e8f22a249932efa908aa0493a1260c6230dcca736ae9d6dd1f95af3f26583b852eee6cf2b3fac49dc737da52bd17d47769ace05466612759a7b3f3a01020f578a7a18952536bbfe79cd908f3df5a4c237e2fb85819457a82f61bcb11c84291decc06772f206da265d0b0cc04712fe8bd5cacb9c3e7b4c631c4d4418daa431e67f66a78efa96cdbcdd2dd8eea60ffe6bedc983891e60774556b70e9eea5329c36a079f3cfbd40fc1de10d1a3dd7132ba1c4922efeb5bcc6c4a052bb9c4dbe60a80a41cc4bbcd5f8dd958a41e103dcc409044e0d796eb8f09d047712472df48fd2a4f2e613c966702962d8f6b657dae47de7d36b0cf5c3683c3b792b3416bc52080e25d06b12b40f4282470c563d0ba0d3a86f18e7632c4a65829ef2b7bd88fd23bc4d2ef723354e10da40df6421b79767768b7cb3e898917ad83e7a21660281c62c99fd5a000be68aa9b3c46698747281eb553be5e5c220e38046f9945cf3d2cbd937d59ea48c1a32ddb9dda36bbeb02ed2a9a60c0dbd6e0d87154e3e9c444549b227392ced88713b4feb5dc7a06c519d6611f01ef0ddadcac915238da34210cf330227b535fe34b9c5a2198956922ee627b58c37224d67dcd7bfe0c642b5e81a37a5b86c2c437efac26c5ebec7b176f3b45281c3c5c26dea417af37ddd43ccbd18918f80188990fd39b6ed4e1daa063b1b1aa7b4b98a56bea1914717e97a044ae4cf3a01416ba351abf66402a0bcaae4da42753b32704687f7795b1db8ba907eaa8d4dbf1da7781fad57d4cae9cbba8c647995e2440d4143c4759bc641a9069cff314b5f022bbb811df73e6ee0930aa14608cd9388334cd24f48f265fa8ab0325030d74cde2937a45d9831a43f56c2e05e1915745d82138d117408694b0c766f4664413e94cdef4625bfc235f0759b6e270bee15aed7815fe40ddb36c56fe2d23c455d686f8af03b8afaf3027adaaee680161dc4bb69d8ad281bd42b3534d1f5376c499391b8a04728471b06e5c4089aab3bfdf7da08ec2366f7bc30c1a4b5023c11200d6cf673b6ab21638f97f275e9aeab9787771e1aef748cd54799c224a2283c5ca72e1bbdc9385f1885f964f744d8d9c7395106028ef0282ade277fb6fc341e4cae7c0669df9f71171a8c7f5e24e430a378a5df6434d84f168069097964ec5ae2f5535e78d65a1e0ec788d1b148b7d429badddd3bb8c375e107a2a88d7a94c2cc91c5d8ca6949976fdae53cb2728c04c741196cd1bf3353d08a17f076f92193331d5fe2f34d901bb54e88e52c5322f0e233d9b66061c04acb4327e0ad84eb36c3f4e4d4f825ff6fa1351a38d2ff68c214ac9276acb41455d183e7b73864aadb3bb50cc2f68ad5f9d73c9fbf3af2684ba8b23245c3692430dff33c2a4baad0151e179d7ef38e632630cdb95ff67d9b5f40f8cc88aefcde8e7d27f45924d0d0b45d9f617b82538fd0b183399bbf3dc8966eeaf4b590eca281ccbad5f9f1a6dfb52f39dc21b1c990caa239f8c9d7714b999b8a203b0528ff6e5b2d923f7926b8f5ac8c53bcc3be1b83b1ba4c8df2f938d7de1ae76b2ed00ac34534accd89e1cf8865ec3d989b2d5d92a8685831988176fb8952419939a1f87e0cc975e7ab05f35dcd4f352b461f025613d05bbce038f0bd802eaf26d4491d3a5f607bb46c5600b750dfcfe816f2c7f6f8b94fb4d8c555918b65c39d94eaa710551ea51a7a8c12eb558b0d8b7436676f76f7a2851e05d31e331ca3f2737d990054dcb72dd092ee2d275f7b3dbc0b493590fb5619e404058d7cd980fcb9439285d700ac2c4d3f7a2f08831c3c703b6157993a0f979ead8b2cff95b1e728a6d0d501b88698093ee7894844d0210d5fb53d6c71ef5d6f14d2f8cf29755ad3bb40840d146cf07275613c6bb22c1de81359594d869404044063b65e5e3e81b1a000a5c85a9d1ed58530eafd6e6a1f9648c0921570a10fe0a4e15e7a0b0829420502ad11741a15cf2b71948320b30dab57b46c50924b670f7bdc17cdd56767b7a94fca97c62ee0bde56433f716d0970521e8ca69bf3b8c89ca332d23c4daeccc534ac74020944aac2c532887737b0b8df5853157c5e460f3eb94be9d3e9ffedc133debc2e7d7c27cbfbd01f21022e5baf256429f8c2f3320108f909f66967de19b2ebf3c87bcf314bf7f3a0f407f108903868645dab45b58e27c6452b136af15a047dbc034a0786565de2931d4aa01d80b64b1beec8faf028aa676a8061c4a0fde8e9064ce0b3b352bc4a776141bc02e23716fee211c1dca2231f945b3b5eda7b6c7dd171a2b63d5604cde1ae0da53397e164d1c8e8a54ae9457eb9342501032f0769caab4832adf465725f0a9592fee3934cf5dd163a1c1b6453c35630873f3747537de127b5a33452ed7f6038f2b0a2b012d403e61e1d2421434a164396c26ed3a6f95901756af8c1df1159324ddb30c4b2b41a68ead1262bcbf0d631a370847521611b6e9e912cbe892d811f1d7b28018d6f21522c0724ca05d36396d8dbb77eedc01b841ec16c565ca9c19746eced929c175787f8311e448bf2063ab4fbefda1790baff4c4dbf3d9b29c5423a8cdcae6fc3cb5f243206fc19036db234205d8ab737229d21afc7d525ab7b4acc516d11331436fb94891bfd77eaa8bcf46c80ffda94267f89d8858f597a99ae574ab5fedb6700af0bd24a90344e5fda13e62849f6ba7062a3000ae6a6153828501b1fd8351f38652b9a21b9832edd7e71b1f8649d509c097b2762ee4cb9fd627dfcee9721175c0d5a45491ac8b0bd51e1e5b89018efd678ef60eaa24ea8bded355647086646794b183d8bd9d4a954b84675ca0a212bf58bf473476987ec756c5d8d7dc9917f63396c65b0298a41087eb834c739614337bf537128d11b8ea1dc3607db7984a167a63ade7677b74ef3b0796357646e5a311f800aedcc0999da1427039f7271ccf4e1cee4f14b72eb95e2773cb70e0be0c8a834e54fa5f2310985a6db534f343408911a34e29a266b236055a1e54b6423846229bd2e96377d203074b9ea9de8c59e6682289890b45b931bb1a928caa9bc43171aa9bc1f0f7767c6fccf74d3728e1fd5794c71d6d0531fa9744d8c6404155f7e6300d8d53c67caaba7c8f3edb7823c42344f285e21f69f76c2b1a42018368393619305d6ee11b638a11e7de214abb34e935f1ffc988fdefd894dc18ebabf2448055c8f1758d6f120dea2848776f114c592c4cb37db6a785713cec7b16a410633ff06cb02d5217d039c582875237c4dfbfe222c7bf95b3f5ea72500b46c64ed080c820ed4599171311b94a6c6e0109bd0491a182b85e77e68616b5e7e98bb11fc78496a9b5571eb29d2b166c726b327995901143271b4208be4306537f0cf6f18e0ae900a9d32432059e071c67fb4c004cef84c5201cd9c61ced133e41b77dcb3b220d8386c94f6d3e7e997d74149e398364dea6f29da5e2dbc9be3806ecbc2e6b78d47aa664bbadbc0c244cd2efd929f723604dbf0308ff07f86d7de42ed39160090164d5521bfac4a94eb7b9606fd75b14bf8f204a8cb5cff4c7f9967c84efe5da0043b30ef3061d19dbbadd66744103aca12dc77b8ebde3b6b3fb8ff30b63c882e7b90eefc978b46e034b0e823fcb566e4d30bd2fccd5fe2ef808540d58c3b2459fba2eb2ef6445743b2c3adbcbb878930ec025756e56d25dcad02a9477ca3d62e9d2b09813262014ff79cde5a0a365095e1b4a76476bce5102509f9472c8b8a22f05d1f94ebe8f911415b1695f3a3222e2bf6628e11360a636ac40bfa4d860c3f65629116c626f80ef61abc4283a71b61d1824007e04b463bae0a39460778de790407c8eda0aa1bdf0280cec65299c36dea288d4959024ec65e06be0e105a650fbf24e27bb22bd561ae7ab6cda0f4b639ce46072b50e1fec6bc66bd72e9fac41013f6fafea1bd02ab7e2fe1009ec6f27a5f2168e388c4344ca2880ed766a64accf9ec8781f05feef806fc9a4b453f5969f1f1d729d65f8855576894d4d9927f3b9a1517a3a9e5710bb8c9d29e7d4d4806757412c050d2197e79a23114f9d4069e194fff1e9e9085000ef75a7ac05a5741831aadc5c748113414b18b58fe3318d31ee3387f305c75d02f2337a8eaa350eab45dbf28657a325f559f93bcb4fb4c72bdd98f3743f24ee515cc5f3c04a49bcd58b6be809adb83fa9fb1a1dd4513cfe5980f62020bc9486aca5036597a909c439533a2f1baa6c42eaacc886e7bb2abaffd46d4c64eecbcf72a532263da39d4f8bd21f0aad7715b3f8f5f2c96cf8d4fa3410be55a2c37a781a4d0cac5b3b7370d0796fee3648579bc256710b3186b6f9570293142a9fd583fefc334eeea3aa2cf3bb94ba324e13a2ea16e6a5251297a790ed0d81e67ea2feba60475f5cb82088f034ff5359ad5b0585ea3b64ce5218651019b56c817d13d6005d3bb55e632049aee6035f36f253cfbb57a005eaa476cfdf646798d913d492a072912505098ec48323451abf887514e31a8ec87ef621b3e18abf6f9782313186c68b9e6ffe0fff5ff2bff228f8a6f09b51e27398f9c2ca5f72a1e05b1f7007f28fc72a8879b956090405625b2d55bea439521e0521d9757b6fe464c5e4c4e1c6f7e826b0f5d04c06879fd241a4c9ba05f44ab31a8defcd5b22065ccb1c24971f2ef8d7645aa9900ce8cca31f5455ebf2ef21bfa57bf36ee9bd596b0cce60a46c516895b25219820f282fd1b48e8f49fad615961af2b8de05e6a2ad2d675f19fe455badee1efc188e6cd1b15a202e5b11bd126d9e1a9d49d91b7dffd58b4d7ba21693c7cfd0028af5f1877da629b9efecdb5962afc4667c2bdec24f8ea68e490cb062d122ea68c65df0278d7136d2e1eb6fe899658461b443dd7cb44fec3302e0ecb774779a57277b83e9487698f3adf0d16bd055b37e2c8d526deaf4fb9160ddd1c9bf1cf34b92425dbd48fe61667739c87604d26ed8acb3e0ba77a6767ab1fcff157b16335940353424652bde5b79b05f1c5097b66e2e2f57b0ad57502e2c9607d2a768a417779f69014e91fcb7538d0717a283a84bd8b2bcf834f008e427f380386ba6459fe126bfe4f2a0b8d5689c26e638d23ca220034e4e4a245d88f2d11ef98fda9019529db5d2f7ff620ace27bec5f8390907243df9a7270509886d91920445a0e06ec1ce17652d6d17cd1602057a56f24633825455a92413b74ddef63afd7c41867631d31c1a469f77531a155169343e268bbb4645718109ea1d62a647c88172f2d419a2c1ca5ee8d7af48851a9c7ee64765d44dc8c02d723503ce21d92f2c16ef94b209f7d810a9d5651775bed5013388c5f0ed84d642b1695701e534e323f064a336c51cd7a8dfff53eac979953c857cb5a31b177329158cd6ec9e94c87e854267ed171449828a6c47af47bdaa7a0ad936b0dc55d2ce7b9b2ea7dd2f9f84cb3423f0261ffd66a903450c9ef4376beb2292f790cfe33b2544fd15d845fc01c501cba273a510bcdd1944eee80818e1aa6628a2d9fb646447f45737c1f7686239949573873fe485f6fd937243f68ee8943d058bb5ae39691962e244586f31de9c60eed87cb07cf8a889831ab200fb34383a9a392392041ec40889fb0dc08f60baf057a56c9af47098bbc33bf9e1f8dd83ffa5921cec8860b748aa7740309a8a6b34888b875a1c71ef7ed87783c8ece4f79b98ab92dd2cca3712c084e0e331439ea49255388e32b226b11a1fac4c885de26cedd4efcc6b0c2c243f45a37b41af8eaebec85f8d14523706ed94cc6f67306d05d5869b0d7a3821417d5b018a2c8018ad94ce59d53083f4cb236693496fabdf56aab289443eac8f3ab5afa0885b7e93a7ca04cac3075497f30ef76ad4521c65eb0f0c67737877cbfb93e7f9002fc4d7ceb37c9721b25456739a798263afb4c303dee54632c0ae205bd28afaa9c092d2879ef66a2dd58fb84c76a37a0933f0c9ae894670e41db023651852b6fb7eb4d96b32be602c7280fca0261c983180909be3f12ac2be74001da448a4b461e5bf0181310239a085de756fb38543b4084bc17f45c26623a2d0bd548bd2224d28a073bb8fb473d827ac72082dc3f3b8017090abd487aa3db1c72a87969c01740a61f49e1f90ad5f207178ebcefa814fbeaba0fed66a9186c7a5ccfd204a9e830bd4b5ba9ac1a866cfb619e352563d5f59b49d9a07530a867ca966d85ac6b3871773cdbbff3a7e6aa5be30e5239496dde2829b06abc93e2018ba325c35845bbd0a280b8aabc3e93a98eb8703bfa96c752f451655acce40bcbef6016e39a4aadf9dde2ccebff8f74199a5b2b37b9777c2811d8358d472a171fe3baf3ef172a850ca765f704ccf24b29082055eafe683ae6e90bd90c30518ac922d14c6574190d94abd0aa4ef27344c62c2a76da12cc833d84cd459bb60e6edfe5a269c6a80f584b8ecbeefe53074b11b15dd1b818dfebc1c2302ce2d1092b8d8dc0e691e1588c7dd7f7f0bd068422ff1bbbc0438d93d228511a3e2ded1658aee9633ae17d3945f142dc3cc7a7c0a3a84c04c3b3cf249bf1015c459bd7315f0dbf7da0b992cf31c2de7b4479b9de8222219151d206e3e45a3b857a19a77195f76486e60ef80047d2cab5388f62cea29abdd958ed9f371c34957f2a0f5741dcd3b4c6fa848bee2c84826900b83d5275b6e41f4b328fbad10ddbd33a0aaa4ef1dce986c339824fb1d75c035467ce7bcd8cdbba6f10aa8ed86772e8b8b94a5d046ac0a528ebb4b0f4570f1ec622861dcbff2c4a63b50c40459bacaae38bb7ad29c9e6bd87fc04b53cab8d17d7379217c74aacedd155e9dea7cf30e9926debd9af64140a241abe0e0fc10717c3da5f7bfad172bb56391167084a3bb5a84124442216c0cff71eacf546dd2240dbb002159dd40dece769228c6247dfa3d0e12b7ff2467bb955f6ad4df2abfb21eedfc4a062f3ffdf728a38fc013e0a4ab22385226528d0c264a47572b2806b7e0f477b9807ca544edc251faccd466fb1a2be3a468d9152c540e3f3bb6a62c8f877af553a5a9ff9a3b9e5849e04952dd3cd298562f9a24236bdb01aa9f4596524914c0f20dcc97a6e9910b4d3bd20a59196fd7309585d54ebf4116466a2226721515b9313b2abb3b0ffb65e10bf2eb8dc7280a3a2062474ee16070f800c3ea4d46ff481a9e653ebd6b5304df511390798e109aba1a808325ff98fe514b4f9fe321492fa7e221d357054bfd7f0891a6b4d16d7d7493201d765a2f7b92771d983e76a38756cceb65192aafbfe5d5e18516e36a7754af81e3280260666f8becbb19dab3ba5fedefb3ba4efb5e4e84b2d6738b303b87006e9f9d5fdaee3c1d6edd8152beb8c782e1a219c32fe7ad5054f1e794ba34e0943c9f668acfa14d9b5bd79eafab6297976821ce2ca627a223e726ffce72979a7936386f299804fefd861d6fa4081fb62dc4c75c3b0a2bf12cd78bfcb51c001b72316ed6a420bd3e7a8d0156f2ceaa22e7c78304968a929d646b42e326a3ae3bd974c965e8ebb9f1ff3288fa5dd1141962a5ad96db1de200547c145a1423500c5cf7cbe575082a606e25073ed786cc9de0a420a40376fe665f325448a34a3dd1f66fe9cdf98a731146c2ea494436623ab1619ba937ee9cf8314a6b855c870c998e0cfece0bb43ecd7b2851f765adbba27fa23a4a9f0a08a34b63f7ba5da65cde759308d144d07ecb6d19888a59790b02541dafba5f934657778c21b6f826e931f19ad3728b8f64ee157a27bae4fda695e612088908fc91f8cf3ea69821ddd69884104049dd4b576a3d11eb0d82a6e5e88da6079570707b2dde862fcc9a46222139bf2a8887727b0d015dff53ae1ac0d499d992b43f7c064b78477cf9d0a6c8f9f0575b3c86179ec6021f8ef980f5334af9f5a5968cff43a6cc339fc743d9983b54b227cb549d49d76862a4f62e815b20173da0b5c973cc727724515d8cd6ba4740f4f7296dd5b3c47bcde32a2e4b45a0fa67ad54c5a2e6d011d4277505477d8973f9d822a6f0ad0f667a4f1664fade4d60b51400db86e9718cc16427fb4a79dbb36e3cc309d251b56d000cfba198da69b7f582d80c66663324e36667eedb47f15d968eabc8d66b4c357e80759b9d2612cc8cbc720494bffde62f817c47d983a1c0cbc6d62aafd3548c9fdb619c02a2ab41a3f7109c0993a85aaa7024fbdb5775b02fc3119ccbfa1cde9253ccda804f5c93b341aaf74bdadeb8ef6da5f77d79aa95099f6bd6dc2737e263806d23803b1c21b2b09ad692140214bf72fe073b2647184139a1d9d2e66764896b8095322b147584c8b3189733075bf82d58a0549abbcffbf5652a48a51dd050d11e84279b7b863e7a963a86421eede47ece6c3e4661f629ef9ee71ae74b7137e3248523045c0adf56010224418a817c3183cb7be007dac998553e41119c1a621ffdacbd9ab6e0e7c0ae1e59a5d00995ab430d3ffcf99e4912c2bac5a9239caf8622d3d0e6475518cfb7d39c20d79cfc746e8e67161d69425f45f378aa432e18672c3e9ff4598343ed84e8665469667815d0f0deb7bcb118e4cf7fba252bb5a84b7c3d1a2e356b8a403a7d7de7b39c07fa834a6be1ae0496710938d9b153909f021fe3e053791953c6bd1603d29d1c829afd940c6df370f6c259a42284d139f7eba127037b342ecf39a56fc4478a5e6982d4c164c4953a199d2d63c3ab205b5f6513438c4297a5d4a3292452fcaf6625cb7fa668bf15df492ec06827e14430c29c36de66e0a95f68c424bf2c72b31dac0dc1547a3fc4f9f4a628e133a6c9f3e6696537dc9ea9884c3093ed046d36a529bc35ae7932a698c45c87b724a2ea106cca44a4ce83654befa50e28b9e2b6443d0dcf6cc2b7a11a47d9ee964f12a1ffe07f6256a23c66b3a8ec4e95c1caccf17fedd0f4a1510f5a85714e744dbeff3d5903c7c7968f0539b21b64119919e1574c3e1653d603f64291f0951bca81fc9505fc8d6b8f8daa3024fe9abc6613468b09ea73369a5753571dc24410bd8271e7952b79888c882a9942ad422582c6cd6ae440a98af8bebbb65f4c248303324d681c06adcadb9767d96c65b0fc2854a152c3d574cabb39ca95a30fa9da698a57234e0d61941f9ca967f4abc8a3c87ecabef71651bf2ed223f538e862f042965a5aa0f72496c0bb4093b774544be137392eae307058d9370838b26b2351171c5805802b97f4032dcfa804f14bc8c50998d6c1caa466d92c5371693f468c45bfdd763f85021cd4d8dfc001ab29dcd58722b243de67bc1ddc19b100cb684c6b68c187956c189b484ce8510485b66890cb90b0b993898c052b9313ee0eebda46c249d4afe2c34e93a35e804722e746123b87d1fed3a5060b732d5820896c42232c8b6f84b99ef59a872f211b6e98be09ecb783940c81b439c07bfd750e4f0cbfaa19b0b6158816132645c76bd3c6a80920320565c5675f6e4d8928c2841817387aa4c3f40743b56b422458e5538e961dfdb1c9f5ffd3e12835786b83c53db9f8a23540f80959a0e62eacf42ea0af9653c15bc982318d1ab710e2fe2b56be58062871887ebbf12c9f402f238aba163d7b902804e9c1e19a699b1634693ebf305c42196a84e115de31e538a0230f2fd6f73f0ada75242b4ff203503e5391911dd3c33cf706314684e337f9908d1153f8d6c8746ce211a4a16a75844e5047d9df5d031aa5c42e9264a530455c0d06c329d7c74b69f03b917731ecab74c5b0c4a12f5d677a02db0e23b90482ddcd8e9628eacd35b796a11e1c7061230fea5e860004aa0378b25bce043a70bfb7e73198e26b569539581941d53f191de76667c7c0fcdf59fa9f75fbb5bf74e99468a880902d69cdd9d52568bf5b9d523e8142c4f542ef8454202920e5a236e33a5f308d7b10b3790e9c69caba3f4b94aa6a0326509d15c60a8fbdb521b9a4c302a8f88fdc3f3730041a81efbf87a8fe7e9333e3711ed9d1a4ce825bb91c57ae2078a7bd66c4ee018fe4d3cbe7514ab212fa14c7464b92001e095012927eb79399f287293635b0fd2a31d1aa85beb1e75c5f4f1e51af7b77dd8e6f630f31ef31642c93ead02f75ed49d345ea85c339882714114ba4671e59a63c150591d2563aeb66798d4b16a2ff554d96a1ba662b91823568d81aec1433ae2a60c0ba25516a1ad2f2755c1f8d2ff7d56c7547e2359946833ad7c4d0388c9f80d4385512cded7d835ee14462f97895f5f1a4a86e41eed9d6fba88b59e4970266953cd1708fa31862d2978a4f332e06e07b5163c23a7aa446c7844bf7449a54f7830f9356128d09f6253cbb73b23d875b070ba4e995bc86bc5c3db71df39e6b2d181d1e44abb45e887198d44a099e9d91b8234549ca85451a95a1d484ade21ffcf459ddf377ebd3c4a6d3d726fa4e0408f245eebe4ae74f31478509acb5f7e41eabd529036f75934aae7770b2806705f4649a3940b60d70b768fa93a5bcd0eb6bec64d0a2597abc163d76cc00cef2f08fc4094375416bbf9ff092c2a1bc6cc0ae1e9a3d387a46bbe80e0f9e6ea0258b6d46cb5a61ddb310456aa10180b82ddc691a1f054d388b207bc19df28af747873c062666d9935da627ed3e32cb382f9b295ebcd5867f30bf5b7be30ec25348ab33f9229438aa035f39913961630737ad095536afd0a94de3585ae62a8bdc966bb07ac1ddbe70e8ea394ab076f2d034f5b66ad011731c697353ca2ffccf05805b713fd58894fa4b0d7d1fc414158c529aaf340fb9b7087122ed16b06693c2193b20f100e216a13a9e8d4853447a515eb98b1da53126811ddaaad1a60ab791c5d3c4e12139747dbf2be9c79a83f1b46824da8e2875034af06ee73d25d2cc6905c8497473dac8ead5920b023fc446363bcb6a31a5eabe462876b79d27bc35f22d13bb89e8ec429779efcf026481853ba5a3b98f0636431884a659b987771279807eef85380ab5819e8a0bece446a47bdc04865f6a1b33b802d97faa20b3e9ef84c2247dbbf64be40b71e0ab887ab25149d6339ecb5e8832cfec9431add02fad0263df57867c116dae826fa9e0da4414c5dc52f1fec3c38b47d339aabbfe7e1f6d1c8bf6d89206cec32e2fbdef03a3f706f741eadb7bbaa757f7597c7e5ee81917d65a4df657b5849cdb7a0e2678e41719559d68d168a5f5fa9613b22a9218f2a09b5e982efcb1aba44e2d8e93f9f61225f6e42f919b8074e97aed8c4bad3d6780c10a445d57470420a65bd5c9b3541e758de785777561acc8fb67cc67855d760414cc0208942f8e8c533a4021506a975d9344491e2bbec89c53952e65968d103ba3258159105e983b2f4b55061f01d4c12bb9fc8453d8da778760b07ec7b183bbb4572e1840025cb760d7ddcd8fdc6b98a470c851ee5366db055859d837271c9dcd44b558d74edde0a4c76062584f1c0dc121ce4a31bc29836d634b67d3a863f89214778fe20e37f6abe08dafe730f05287342aecc25b1c28ec6f8d7624dd22b7d66ff3d5645c773963d706e18cf9ba1419dd290b0502968de254c6b882d730fda4545addf29e7bd2e90d6dc14a52c479e6baea11e85e0bda1251ab923ff1f8a5069a8a29862bfbfdd7211da3929ca92849ab8bc04a9f74030ebcf6a7bd88bc48ecc20150b7d3d9e207b52c1e192c07bbb700f58f96776906e02f05568ef1174188bfcf2c6d8bd111e4069fbda412c9ad03ad51485e5f0fabf22121f4eb88d45041ddd6e5318f99c422d5698a5181c1126d6878d9b2d9b0a0b2c14400eedf6fdb2a856058ad03221cd83f00a3cfa39dda8519cb93add1f50e692f98322248cde7e10a70311be346214b3ebf46557cf95aa6b1343b2bb4b687e4687867cc31951ae1e977829148f82b443a37cee3b6442c03e11a894d2cf2d18b6c471bb99ba2ff809d23287a421dcc1bd55c87bd340e8c6568c7ab4fb5d427bef27d8f321d72fd86fec3b0ead3dd70e48c9495f66d7ea545d627ac9974ac12085e4c575553f900690c6349cf44efaee2d418b818915f934743d74ff4bcf3f02140dbd0fb4096fd1b3131e5d83557aacd9a88c844cffa49ff5df62d69dc3043c46f00352f7f4660ff90171a9510d01163d666022dc03aff462cc4687deea622e31b08b0de96c24c05df9df2a2c36e378b1424fdf7df82e6109773d481cdcbff0f5559d1958585b0a802c978556e501bfe724e7142cb311a39acf6b1033d2a3ddd9cdbfc1bc096fa531f90e6290d2f98df178a60f8d5850aeec44e11b1decbcb826e5f604a13e85d330d13b82553d8c07bf3506b487027518683c004b1a3eddc35261a23900a5af836ebd2e13cbbd7148c9c4f7aa0a7a4139ef3c796321d276faff81a9d32a27d0de573ac174b253f27b85505785780f30f67b1c02534921b216fb64c3d8905d8238a2456e780a23f78ced95f48e173a3451d48ea06cac6b5b7a8aa45e2956ca7381b0faee5834bcaebdbbe1740530cceb61f90fc265a36e231e9bad8e4a2cc89b13153859fd18dff193e60018a682acf15dc7653d3111e5dcdbf13a546c38b128d8ba6eb6d5664f52da3fe1b1e3063b9daef8e90c73cbc93061228f0d3f6771604b3eb4231f0fc34bd849243ed06cddbda2db573416bdc37681852ae0d03a5bbec8dc1a5653c9339efb5f3349f7de6636ed091703c4f67bb95452bc6f7c84c3fde71501f3c81d54e73fc891dcd14279f55a16d7e8b145137bdb4d8e3cc923081118a197f61babdb258ad67732fcd024ef12b18684017e19068b716db6ac07ab097efb677d24a5667d284ef0a084add85e15e426e67a23ab307c2ca15f623cc8b2d0868461396669c5dcb33671f6f8d25e62fbe4b529da1c64db28f363a7afdf4fe90c15a3a7c63f854db7d75f17c52446ade60e14410e2298342b6d696606c68d3b93c0a9299b528ca30159d596631403475274b04495496c54959ccb26a842e17d2ddf31fd56a0c0fe2d8d593027b33aa84d260a9dc1327ffebeea3a5138cb18f5fba09bb3c56373030aec10f5813fd9507e23cb478dd1dedc219815bc3f365e8710ff0b86276801c3d9234be64af48486b62e0826f158032c0e308db91685f24ba53a79c8723192350de2212b540195a937f83ca97ed5189e4c05e0f4dd87d60a1f720f8ef5dd98f3bf2f096c46ab20b8cf786bf451dadba4cc96211adde1c64dba81bb6b6fb4b77cf977df2f7ece48e51bd6a1cbb9c521f4ef9d4a70939b816ebe02b7d202b9000254cf543354041f1ba032dbc10f652debe6468c018e338d7df7636c2b92314a234ce7d77aff84e980d315c3ce00056c879c53c4d0999cddc845a14a6c890667c3630ebb762d4cb229a6180740ec8044430ca9eef754a983cd30b7ce8d76be98c3f79f3974fb634087255836149133c93363a6a72bd04a98023749dbe62792877ee101466a220297f86b03cd4668320f87483304a530aa902e14e8aa9f88fec5340141fe0c3ce878e5422b6394073be9a1a71d7f00bbcafac911c5884b490dc5879bcf67bb4d1d847c4e020bd3502a18a4ce6b18012b4bb0e2fd44755c9a3b026d3c28850022263a3a9e792fe5376bbf499e59af40f082777d013fe49754aa4be58843cd2fe6b1d38925f16f62739984f2e0e3e765720e7e494fb0f680f808c9bc6af654eb15372af9b8b700422f2c4fba08e9a51b76322d751f81fb7ee7d23a425331254deb7949735ee24727e639f99270c2f0bc974de45c7789af28bca1a683b159df774a36666d9a5358c30fb2c59d5525db1fc1de0f6755f8bc656439523628e603363494a2fcfd39066e42bbf15b5edb877f4116145782ff873c781448241efde7eb1049f5f9dd7f6552f30db7d2a8647ada0231d7e8759221dd1e4499dfaba29367bb7a624846fc6e7a5c031380ccca2c57e25842aa3152b30cae1c8afa307a279b1e0d2aacad079a7fcc566f6bac0517de1473a8041104bd558f4135bfc5f5dad9d758497f20c5b337643e3a37b1dbe3959fa49344b372c68b877223edb7a3b368fafd1cb25bc78f26fbdcafa6b0db78609b076a2b92f8d96024f9e33e9c2346e67f49d20c7ac5e83bf757ef14713580a1bd1030b3b76f80632d955fe6578d2dab34b9169f962ff23c79bad021f2171b4ea01a6a25d58a4dda25795de0fba182e7e625782ca144916e0ce18bc7eed1b671accaf1ca5bdbc0ba55d69251ab0ed57944105f271e67cde63fb23e19999fc63ca6ebbed97d47217ac36203054d33db35f87d58362eb636c0c432f6ab20347f447d5f7c8994ea6b2413dafd3f2b1fd26db3d3369ba59867b742bc80f2d27180669d4b09c154c2aa11261af148844e5f29b71e7d29ce96cbf0cf76a74f3d38a67b4ec501de3f9c536cbd219d2bbcad9665bd198e56248df635fc93b87e6b5fb23c7173011f1be6268f2c84a04408ff276130fa334d233a92dab6c70a754edcd805223705f4d6d5d23ea21ab602be1e3a15c540c3a46e3ff17729d39763a8396e1514a7bfd46890eb1bb6b05c2d3abbdc7861746ef30606b26b30f258a9982b5ed44daa0bc0dfe3b9bd672444eb32afef93945c8c17ce129ea08960b471b5f69f5799d05ec26593b00718c9deb6c3300c614e1caff20ef2a1ad1e340255c3e5a54bfdbcc60057489dec69ff98089e761beef540a1f12d36b3093b089e943f1242e0346a616e78320e8d6a0baad4d6d90e9ff8e1b5e8b82245a450b112ce31e9dffcc7068d66a1779f451d647d748c81db55dba9f21e777d0516c67d7251110c5739bce870110ac0333b24609e68a44a34acc48c9874560ab8afadfeec76acf3a9496cba6311f3ad806e6e380e7fb34e0d6bc8b5f41043c2e16853261a6606bb3e5e12e551a4e428b3bb33b7343e2869316421e8c687ac6fee97e959f4ab6383decddd880298aa14a3ca53673a7563b9c51882672a2c5e636e0efbdf372cd73212d644f878a070fc2007c3170415bc0df31ceaa1d0dba3f9c6e63d3e18da55f294831b0cf2e090cea404ea1010ddf77a9145457c3ab34d5798b82c37551d1dfba85ae3618cbd41311437dc1df22f19cfa1537ed3865e39cb3b02dbaedc858d727ae5e395fcb7b58e2327fb0627f0d573797b77d0511cca4796825ffe9a0f7203a4c58d6df2b2bf439decabb6acbaf1641014e2c4bf55b18887c7bef75d3fde0c1d90c39e8eaa90d3d35ed3a71706f26a222798172adde650914f92646aae0d0c59573c7b8c28c6d33a2657d7ce87b2917a0df894aa8b5b5c166328fe64dc86aaa62750719ebc2855e15dd1d8930fb24c2484d6f81730507382cf434c13ece679b6b0f50d408986d83810e42731051bfff45bf12610cb841394015fefb88a1887290599858572572efa20b0ed7f34e31547561f2fcc5de7d1565f4b465cfa83aec7bf112a28097a6cf38a205d9eed15316a900140f40a0eb08086b8e1a1b69e100fce70d971410531c1938177bcb8ae48ee0fef19463bd95563b959c38a22bfae191acffd9e5566cdbe756c23cf7cfc6f92685910bb72d6e49c87f306a29594f73a324dc262fa9d0a9ec73bc36fc3baead7443ba1ac12d95122265e6bde0d9c025aff90a5c4bd60cc89b92c71c63de03b5641c2a37421785c01f3c7c421a324edbbd30ed7e02d2b60a423684ff9bcbb870dc938ca574c963f793c697bc04097fc7c7911388285f029c6024e635e9380241d68f7b64c091214e1ef3ceb31aaa237c26d4cb8413e38c1975e0ef2d47010080b46dd7b3eb87e170f26a7f73769cbea669e176b79b82d3543d6260470baa957a7484bf811a662f0ef7b0a16f30961a3bac206b8261a0e1924f24c603e8aad0307083117b7e665bd45e7cf7ddcb222ea114a8e6282c457d4ca5a7e212c00a43cfeec1c02f0c8f30f32fa7c8dd854acfa595694b51e3cd0dbacae9108df89fb7c07f2600036995ceeb4f71cd7d1365522bbe0c9907fac6c281b8ed53a93b679deec67fa07cdcd0115038260181ccc186a4eab3cb5535c8dc677c3cf81fc9ae981bdeffa5c744f7b3ff5ffa03e416ccf277cb88b58b23645135f10b7b56be0397caee2d6462811648300476bdd2c311280ca6ac1379384808325926dad2366e7abf543a51c56ff0149f4c9e82ab0539cb5e8aba40f69992b96e48e4356ee9e99c3bb989314699acb9a043918d7e4554429928a643015ee5ce6d03aeea4a369b546d806b7d3fda5340d3a02fc9f46be1006784e83ef9fac8630acc9e4b1bcd268cf829e2e129afd2b2b999b79f4301a690b74898d4d428b1e44aae8dc67f45989cb6b33a5ab578c45d9f761d9a7ea53f410fef722bf85f3dcf6d788357509208a17ccc9821a3670b5f83136ff6a577bee9dbb22e2f97f3f321cbf22cc8b0c6d4559e46f7af182a42bbb60387a5b6f528f137192ef4054b05adfc18d0b8e050bc3a6bd9d7d38239e788a7bab536198a10f6b475dbc8b83b85e39532975b9ee852e0723618df6f7e55e8d6d783441f02e2eefcf5ca68dc0fb2847824f9d2c45fb4981796fbcb70461f69ae5ecba92828e74a815685fd7d1647b8c8256cfeb2792d5bd850e68d854975e140d0b62df3679ea68c3537fc11b7aff58b61af050c83d654a2f76f1cde3384eb23adbf007c4c933299db87ed17be2f8e872d258a0fbf77cd4cd673ac82983ae420717e2bf2a53784ccbe94eb5aeecc030a692ff458b2d67718538e48fbb10af8658709761ce0818d8e22f00068e9b375f77f40ce176134ac67694e4717905815a5d7be69d76adb66cecbdd908398f222ef2863c95638ca95ade1bf6d8dfae5e71e9d3232ce55c3ded2c7f4373b11ad282780dd49c35fcd8d95320de2a80054b8ebf63b21edd7d5fc9b104385c89296dcb749a912d1e81b5d8a12356b406b839b3f018fdf6ae593b7dda6032a5ff21350a7d2027c2c5338a3390f0f077298e42c9dbfe19fb0a7241b013ada6cc0f4eeadc09bf8e0c234f9ac2f459e72f2c08da67ca189c4df7ede6fe56ebe1ab74b243e04cad45bb9473550260b7bd0e0dad7b71efb4c44167a673b4b385f59727fa19bbc6a62c6dba7e7d81f1ae56999b9b836b54e54f056d1a308660d42693f4909a64fc3f1f3adf7a514754c3b06a52c8b057f9158cbb25afeb82416e402042c928a8b8e74ca2848c2e35f07404a2185e404d2a4efb0cc5f61d0d70b3e074f89f5833f7b4702c6d536fd77bedd4748c8c4bc6e71724efffb1ae3575412e3350305760e84f03ad90f68b846ba207745b3acb3f4f7945fba11e97594902bcb3ad05f29d9416a729052da7c485dc59ef2bfc4d372c3408f4b8553dbdde965b6ae50f50de5e6d2d663577826b66b22f45b37f8afc9c739f49a6825b047a19607a39c6c9089146342839de1a03609d74e77512d526da6cbc0553eafc080e8d77ecb0d12add807eadba4fc6e6b287c43b243dbe5b20f5271bc8e46e5b4de2e4b1d725a82e064db3d26883563d748c29a6a04e3c52eb41c565239742aec9fed56766ceb6a07ff5b48d5fd418077736a9bf3900b2b514ac0354ca8eede737d8001a4d1fc1ad420097aa4683779adaa76733e7db284170f8f59f03a04cce9e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
