<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1473bac3e7055ef24ffae77a6ad6c69c46a829894ff01ef6ee45ca36b28829c4b674261b87ee3bb97988661cab34626339d32c605491cbce214ca8b5bf390288fcc7a9ab3a4d97a4a4f684218db80b42c23566744c5b0f23ca42f207e569b3cc57564d47d9a2f192d64987e9fde1b42af7a4b670c5b139cfe3d9eb23fd6c5cbc845bd6b886b42c6c01644fb2c3d5730f5ec08085aa0138036e065153e122bef14e823b940b83e77f92bdd1ea57eda82ae0586772b4c81bab867fa9cc8db53c4fccde139cc98123c91747c36cb571cb998bf625559145433dfc5c62370dafbd92c45be234b5256024d492059bcaea1f884e64445a1a2cff70ef9e0408f17820cf0479a55f0e3cebbed411b8d10e3801cce5ed2246672a559e96e9227bad04bd09d2d4560cf8506bd39caffafe4958bac640f92f9f92a00a59563e868bad39fb0540c459154678452dd874e1f79a0837cf99360177f6700f4e717eaf7ae6cf7dce4860604b8c46fe435f3ba0f5d66429304e1e4ae0cb4749bcce24b1a799ec3bf538d8edc35d857c12140370d3f058fc3631c6bbd625d8292f89b2316498430810479d15be7dd7ed47b9007c2fae02b4a0b0e1a19d24b486e81fea5ee26405be9d1d64c8ba1c81eec9ec0d9ad99500d0ed5df98795a8e96f016d56b64afe723186a6b5c416993e6d38258be3423988a9991a31d50cc29f4e5ea06fd5fcd3c4a4fea38656b80ec3eb8e3226e2ebb7b0bacb79b8184ec70d3da619eed30a75cf14647776d2fada2ca0e5d91203320386724961da60903056a3cc65bc364903ef57d9267c0ebf7bd254834a9e025d43d32dbe303687fe6b7df47fa6a8e4ec9b0052cf19d6e36a6296fee0cd58f06013ba1e235b684dde7aef8dc3b2e0d898bb314829301f2c745b55c127c823dea3a57fc448c42757d448a4f927018d80e40c60945f580137d097b91cde72f4ce22387663f2da0624c7d2cbca5ac2e574666acf1c7d050230a81f203643b8915b25e07072bfc8e5c0f854b2c5985cb7c2d78e8fb9479ea2419081a1ede9b8e3959e91eb12fec21a9e74c4d380aa56003e7373763fb93b80c2abedcb06cd021634381f043a196ac6d1a71d9e38509d2fe64bed801f9fbb5c6a02715dca6118dfce11f05175213e88487f86e7b99799abe9db94813fca81f410937d086bd90dffbe90d164cc974099561269e2b823d674dc57155b11b766f76ce0db4dd2052bafaf396e2cbe8e2ec7cd3595dee831d577e06623c6c80dd92c06f4c9d357377608f210209b8ed27b2fbf0fa72be555c49a260e44dac5bc9a5fb1e20fdb001f9932d1117bee6730994b45bbbeb96cb94feddfb0e2815108db357de8b9419ceedcb5a95a08286b7c468867ae3ea484347a196179836cbbe7a5a196a51b85e6e8dfd0e3823979feeebc8d2866fe02975d0332a1e8d8ef2dd49477c2825362a34920e5406137b1d2f2190d7dcae2e4620fb6489f0c427a3042437ebb4692c063f95bedd487140a90dd67d5f3b41451bbc26272a7a6103a19d2cff5e6544219b3fba69a157970a659d5c1ed2dbb05f00e3065f084a9ae851dbcca00d313fcda0e2bdcfbd1782a5ec6696c35f0f4567a500fd6632aa2e8209f641854c22e5605d7196b12fb76db9475907819cf35c7e658e5879c80d2bfa23c5c0103f9d1c55dca3d2d1be6651f83c70ea2cd0cbcff2d90f529f73d04ed083e309a236b65d2495c41faed9aa73b89283d69de51ad393d0f8f580c2c6fdc5b5aa1a501c4d7c8a7c12e6f60d34d327d368cad0d59e3320fc26df5bd62b70d204e1fa82fad7ca0d66b41fb31d3ce43eae29b05cdbfa0eeb3566294bb7e8b91f4aa23b3e608ba76e9ab61e4595e0c889cfe8e8607080e1a036542102a371cf957fa3561f8f8b7f715515c875c10aa34f431cac469beb7463a5e20ddfaad8c87e0d019160b9071b57264c6c5153c2e36c077c77e681e1afa67225be1fb73ba38ca8cf2a51d86c01cb8b549f7110c695947ba21d5cb631e6a92a32bd58b9eec1519e6de123cd2dde2ffedac388615dea3e31cb229fafeb4373a28d760f5b063bb97d88fabd5e297c10f650279838edafdbcb9c8e0b0b457dee0224a4fa9c321a5481af61ed2181732122ac39c47e665cc57299ffc2aabf0d9c7b73bfd14a8be64f1275d558b5f3c49b41267895bbf93d9b7af0e8ac4c43f529e35beca6e35bac5e21ee6ad9ba29fc605d6ab6d2c7d6dcf585cd5291879a457c89e88d4b833bb7bacf6866151b3c9a9de46c743c1b9d50d3b3790cc3f9a321254850298fd0e19e35c27ec64be0698af04dff018daed1d0d80e5a474108004e8aec75184294d0214c2b8ce9ada747fc362e92d343f04a272a0e1e1457d6bcc112b5b903bc3a0c0671112d23964fe3f4c811bbab2af842124a191f43a2bb5b60c5bcf4054bee911a69be59490cd9b0646c5abe9d38d962ecf980d6244653d7d76d633e16ca1863d6254affda7d4d4b23356ad0f1f033daaf0722229f541b68252e04f774a4cbff12125fa09a45a76b5c92da5736b0889263cec12d41248e3b4584d851638de09e4bc7a5797619aa11132a726ed044fec7a4f9301a9b74d1d618d9a8079b3d7af7bd6ff36329f4761d43c118b9065ec7264fca23664d182bca20277885c18a04463986f577744a2b85dd363d27d72a3beda4956695aa384b2ceb23349567ed4ba410de69566805be26fdac9cae235043aade74ba9d3c6aa88521a231379aaad279f7ece84c375ebc9a71646b738c2da93fac37033bddc00bc1f68d4fa84fffe3e510e865e9bea0e06e4fbbbbd5299695a0221f2b96b3ea76e0ef11f0d5606d3cc8cc4c236c5a4adb54718f3d37ee7cf88856fccf7e0f666d1105b54982b6e9f4aab8397d6d47e7608ba72682f240d5663ac7fe71efc8a8c6cce7a05f9652e09148c2e3eb457696e137f2b6d0f118b8f1a9c5b66a9d9b345229ef0d631d780f9f5de8d5144bb175ff3c2d9273f459a63afa272dde091371d7f04f7aeb9040613e1438e5e3237d8de12d3c7b49a6c1f642fd94f2388e3ba922bb61ae7885e15063bb5da49d16cfbdf4f8e4bb4c15d133f6e954a8208bf94ac1b42be2d6cab531053a451afb8d1da1bcefbae55b913461ebeb5d6689d55223e85c82fcb31caffb6ae02764820ddd1059a2a48d9745594ca51ddc78943a8cb0f366af133ff55e66ca3b61349594bf3a0561da535338fa361b4f1f78cbf8b781bf4253cc1bbb96074f73411b271c4b887db5f53f2d9a782935720b08512c33fda54274f2583848be45b4649fe850736ca6a960b307fe3a6daec74738a54efc1fea9c836cb5a4ce82d57293fbf1ada4197036e9b4964826b57b68ad86f881d77843a937ae61189b0c274ec3f1640291f709f7e25ac06d31ea54b24dd78cdd0bb8dc8e6d62205edce6416f57f8fe86cc8e3088d320466e4ffd899dcee551ae77d4c15ae2629ed42219232c45683be3700bf45d128848de15c8a6ac437c5c3d9a28fb14e01ce5887f9b8421d01d7f440f892653b599d995b99e4c0dc1fae5ec5e4ab90137f39d7b85f36a6401b9ac6faa74723db500d0be56a8b1f53320e778c50f3ebc781e0bbe2f1dd1625e30e65c816bf03329ee9bc1f0927350b2eff937a903a49aa7b49c4b6d15337373ddc9b6c93e30c6a99ae0f14c03a0677d50c8b11a9fb7396e908edc1e2439de5c3c91060247b38a710ce254fa0e387f7665c7cd7631e90d6c4bdebdd0dbf4b899e23b2b6f17243dedf75946bd3bb57842f7a5f4a20ee9a970f8b05339352bcba78fffb3f3ffc435eae7d2a6133184543796cadd6094fbc05cc54e0f6a0966880478999a1453f192dafadf8d1b9767fbc111ddf7a3ddb0d73bdd31515db85922e060803dce632a5ab751f6e450a2054ef6f880f2eadf70c7560320b2e7f7ceefcaaca255021e964a78afb5c38472e0d25f3f5d409697d3bdab565b2a8dc22539fdc40eb3b995bf9698019ff041520542dd5418a4de5ab2bd77bfc2deff1324e9717be20f1278018e13d6736b00ffb9e65b634a803285367d8d772be556630d440f0871dab455b0d51602feab84e94c0ce6dc165587b0f7f6b49f942d9c2f7f0cc4fbed551bad2c2b31669f78f080d1a06b246bd82e63f8ae2e290850948981880429c8549aaf8de48491bca891a4e5238fe5e9e57bf5a8697209a9f868c895817e560b49ddcd3b46d64b089c7145e26768a4988e79adc79e9361c2852f8f6d600f7a1e190da747f1a9da0600621948b0b1fffb63badd6950213e56d7a234fe21d8ea1addb588de3c86ae7dc4467c6656974d2db2e5a6b9765da4c23a1c856b78a64c0acb1175a7a92a833d380b82721c0b149d9888e436f650724e792c542808b4ef63eae13e8dc7bb8ab064ad4e7f5ebfbfb4ccd3146979267ad72edb34721a2ff44f3223fec53fa3a6d92df59e1bceb568390b5cc701734a18df81ada685b3c3e55b310cdb5c39ed4df6cf97f0d10fcca58c69b699e2314fc2dc751641f9e8dcdd16388f4cbd06a6fb9b7852a0b5f8c3349497a08e78c7b6bdebd8415b404abd7625349a737cf37252fcf675fdd4a8ce92b241d7ac0e3bc8fb7e63354c5c66d7440c4b20d59e2ed2e168b4fc99a3c108c71690837ad9f045fa025e85e2de45d3666d021fdeca8c2d95ad0bc6d38767ff988a85ebaa11dbdd7ddfc68e5b8015f6800c2d0d1f9c4908330390861e41030fa06779b1f999a66c8d77cf09db28dd62f300008ccfce46d3bcf65f2c59764cfec58c026a66ed269a16270b8f594cb56da95c22cbe80b9d099557499e5764911a2101065e119de1d4eb03b44cd6bc23fef59405fd0c10b1750dfb4940a1e77f6bdc9843ca10c80f9989897a098014a4c1de71a4c99c1cbcb48c4c54c209bb7d80d8477dd114ef6d8c5aa3836c20b0736a7637f5291991da22543f70aae2ea95ab475be526426e3b2ba103eaa0787c6e8c5e169c1d482dcebd80f81b81805b83486ca77ca58d34fedd61d914b7c201b1be153b7855a2bcb6e2c6f0f9976a40f4b264ef0c9be256be60c5335628b755c03a44399bdfa8b793d366f250908edee8fe3dd5c3337ca60ae4712157f8ea7f11f167770d2966dafa5894d5fdf249697e4dfa96f605abab8f6674929258ff421381b630d40d87e2da0fa64c6854565b6cc1512c72988c606c73ba9db00c2116b3630b96e82f3bcdcf98544dd3b0d0513b35909d7e52253b423b3420eaff606824e571a6e21100b5e8c2bffc619b1b9cf3727d53e7df64e588347deed63b516089d023f0b0c0152979274095c1765d68847b17fca102745810165b8d023dda404e720cc2819fccd016a2fe1b60ba16ecd0bc7ab393adfee05c8c94cff2736c0fa09c7e998572ab144b65ec194f58713d7f40a7dcc3cb4c34dfcc3e774b0891cdfccb0a6d60039dfe5f6e63f1a0d78bacf4391bb415696bd04055555e94881eefa633511c56b5c3d7028afc65f8cc8762054ca9f5f7f8c927530a457511c4a669744b5728670376763e7f8c2ea413f31ea07cbf4595c6187ebf2d5347db40919fa45835bcb3085d7b22e6b09da5604fff497629aa119e8044c18fa6b5d8ae052cf4f621be15418d6d66c38d8a26765c11a7eb2394b1ae04199b085cef9b57f073f518340ab976285273e0da5525d6704d5ae7153a03bd890e18b157510c59e0d946d4581cfcfd0665cc095de7ba61f295d6c5eecabb1fc8ba6ca9c3df2645258f70fdc241ed51d585d43e6e77c6fcc2efb0c9407372ce9006f3177f527c282d8c59185e5cb56cb18eb5a0c25d105e9487658a393662b57f59d1cd28ab31c92357a744a1e8c68a1694ab200071d302c576d2bfb21def53ac4dc943133cf36f6c1fce83655658a938ca6d10bac1053ae86adf87abd4f358ac5dd0d2fc99509dd1c560e9f1d0ee059bbf3a989185ffee78d9922b60ad9092895dda4e7e13e50164a2a0388a4e7b5318382b9b3a8e5f09d705cfd10526516858b21b7ac56128cf8fb95a72089f3065c5f9520bd949c763eb97ad8357f50afc26de685216b4ffcb6970fb185362ec6d4046d289a38840f439ae9a7987a8ec32640958b5ded0529f5fb844d949f744ab5c3eba84a60edc0ef565969c56cddfb70ecd3edf27f4a9423752bab7feac699a26e0b63d45f3e96147c1a9092cd4b261ef5771f6125ca007ba660881beafbb5a80854e8dd297d2fa99d9d22aec16a6f50e89b5586a6e5a01188d6e38cdfc9ca9ede674e8393b5b564368a99560121f0c5adafeeb0857499ec95b441668eb2166f5040e9468cd58d58eeba93dc31ac69ae3ac77fa871cff141e290d4b2e42cfe4bc8c5230a758e4ff3efe9cc426e88cc4a123cd11029f304508a5e5e417b5c4ebd7352610f09daa1bebe3411ba97b135806fff001881daebba30b97f0d45eb9c5197f94313820ef05c86e7d99d4b427ccb828aedebed473b4b15e4d35cc1c39c09db7a4e9381c7fc62496999eab881940061bbf018872b8733eab0e1ac6b06d4cc8c92071fb4f090995fbe323ba5aa12024e4b27355ee572bfaead82997c6ea42163ae734870ec385e83e9a5c784d9500ef200eb6d0397f196f19bc9c5a91677fd2c7526bd34eb3c392eb64936710e93fc91b2f2bfd635f1f4b851fee60c8e9a1fdce25696a13e39a45f414d9f58e166122d101dc1dfadde33e319da0729c8d95973c6881837def21b1a7a4472bfa51ce9d6630266516a8c9a845fefbce38824ed9eb59fd66dc036ba7fb898b2b060631bd813ae83232525a96600595c2fba316626864cca1d559535136617e40f57aecef01b79bf3163f8bf0842562af6c5ab066a2e36be8dadf8618ef8ab9f389caa2e8f11062432c1c0557ce3f6bfb18c4bd374b72b59c47ce1ffce59ab9c683a8157d5f583e8c52387f57b22268cf781c1a99ef357cdd6ae7a8304797403f6c7d149c5f729ee4e80ff8d080d1c376525566198b2d967b1857bb847375d6238bae3bcf12208687aedb32206b433e5ea1de539a3bffee8adb7264bcc61dfafcd9b4e189fc720bb6638b0a09efc3d2bf4da61d2fd597934ae19264b3d31a6086f874a0238c15bbccf8c47aa86e882ea3b429594d2f7d8ad15d68e2608bc0c4223e7630e48ae0c1a4b9af19d0879323f741dcc2826cf6a4978308bed99d25a8ee03650f7830b2ebb34c9a7524a87b7b9f82176426d0740879e02ebfcbb091ccd7bfa8af6d421c31eea649b0daf6a7e548249a235df0bff25c6bc048ff0710ab787e8ce2d4b71f2f11f08eb6662e78ab54445c60f209ade49c4fe47a8cb454830d72c834563223d73997764ac94e8ef945eb0f7eebc1a7fa8a0571bcaea34df9cafa67f7cfadb97246cea2b94994b4b1b60da6f9b7f11c7b80d09b2f251f203bd745c5f5828656e6ed04e984b063f4b2765f03b07ef3274f33cd8fe911ee90f84a298f2d79e3c63651dd4575a7076dc2fef403572fa3f1bd21b7ce453479756b954599ee4ff5ebbb4ca34f1d34e4b8d675266b3015a9258c10e05d9608dc5e33af058fcd9c464edf3ae743d32f15b8df7ddca02539b2498fb5b9d41de97783185aadba2d9bebeefad344eb060a6d83485fcaef2d20bcaa80ddc781ccbe3020b6957ebbeffaf642734e37a11868f80126c4ec218bdd89b3b254a788312fc0924c6518126c06556d68579f527dffee3b2daca3460570aff2ecaaccda22405073b5560ef0735265234b4d5425a84652a781cc443f5d90f63f5191eb21172adad36c9a55ba68971241b666d86797cd620406ae8a17e6e419ac55dfa96ee7b71e187806140371874042823d52dde4a2d3ae495175851731682a25d1298854711ab52384c7c56103d7c90078be9c9684681db6085a3fef0ed2e995e360607dafbb8357c483c97f742aca6c9129ea4a7a4e531117e99856c3389240e124b94885d4ed61b264bc757df7149c45e42ae32ea3903aa67eac674b30f3541303d4be48aa68cfb9d6a9a40742212f9b731ade13871ae17523812d590600eb1aa9449b40ad4a1072c6b1b724900459d7e8ad70bfaf093b77aa8338394b515caccea30f9c0f49653578da5c304bacfe765afb982f70cfaaf67f57a1a578153bfec197380e5147e6c71edbc478f5bc300414a21698388668bc7c309a8872c6f269da3852523133199dc944fe138dbbfabebb87dda14e597ce1c7c8c1ad1d9d95e87675b3243386a059923458dbe08a43e1cd039040eca632ed7503e89d52fc00305007fef46baf03d19f67364e0ac23551c377c79b78886021d02411bd38cc578acda1f4983cc49aefd5111d6a94baf98e4c685462c44888a59da9d6a1bc53af9bcf65fb43e064766ce2f673a3cf42fcdac095014216bc2912259295513277fa0fb4a430fb75488da385b1899a5da82121c39de6daf7f9785ed8425bd1bdca9cc767f28755f853de88db18ef61b3774b4ee35a053f3907e8a6603240d4fc32e5cd21ab68e9d9e7b6ccdff0761dde1a44fd8a20a738bbcd77c342a4875dc3f521147a7feb4a1c76b90648752667ccf38fefec4f807225d95c79897dafa47e8868d4c8df3ab3349455f797caaaed6dcf1ce836d55dba1dc5114f9233b59cba673d5788eedfcac6945f64ca49b2a4895e0fb785217c10454d7c0e74f173d434822e1774a8b617235b30e73952dc4ec9dce9ac118ab06ef7b3e3a1e1d337ce6a7fff6bb0b9e532fa6b3f881f23f5b9156b2ba3af120b25341ebe44fb039a5b32586f972c144f2fc7bd7dd3099eb789dbe91a811e5f3606592736f1ca508d50ebaeb711b2a629b1261d7b5d86a78072c3970d31a2f08330bd24e4f591169cae5d6961fbf41b5040d0bfcd13c4b9feb1a0ced35a1eb8bb82db6b9c279ecb9f3cd512e9dc6ee740e3974f2e37f6fbdb1521d60d804c68f26c374341554924638db9bec5e9526981c681f0d11ed7e2e782948ba331030c69fb41c7465d1f54730854036535a99c71c44952c3893ba5aa043b5fee52221c151e01893c36b38789270ea5bd525f6a6ff1d15073a3b8964f72b52e6e4589e6fe94f12a0311e9565b265ad2d152a1cdd212f1ccb95248082d59ce49d8e75245ee90859387f747c4fd5a0a4b67680239449e4c3d7c375b824d6a0da1d760bfb787fd5d04d727ce4a584dd7f51cd5346f80c7cf9a7068b1803c55840d4c211743d2b70f4e87bacbd4441c48e87c745e7ce237f1571121b44491e54fad1443121963d95fd904b469ad8cad61ddb2039aeebcb5380cf272a8cfc3269060f2982c70000d88a8055f3a065a074f3ce84d6eaed24b42dd39824785e97fece6efadfca1c2bd837b67991ec816228cb32faa960a9e2e2d03d6b41d463cdf36bb11be3e1ac4bd34374ca149c4514f2c28d14d52772e0d853714debfb264cfe1236a6205a552b47373e026a4d979b68294e35d467de1af2e41405142e758e01cc4c3ec44a861b7e7dc8d0d1c1aac21b07fb1bbb9d6492222a3227b3f78bb301d3096ac5688f96ff9af5e074dace714a23b55ac561e52852b09926029b56ac9e9ace760d6cd243c99b38fcfd9864504131ca563af11b0a936fbb27de5386dbb87ce02eb555d7fcd2d2cfc202c2e134734ed942096cfcdf5486b2aed4f4c820150d385ee6bd12169ae25584656b85eb9017855f21100fc02e7f1eed69fc1e8986f6dde265e7d9aabb7462a4f9ffbb546f50fa5b0a9b71150f5895ebc5220ed7973ebaaef5168e3075cde2a60434d5f16bf62e15b75f9104fb3b1256a3b676a8776405d544934ed4a89855faf961282f542a2408c673b696faf0912ad4a039f5aea4a20238f5df72b4bb11d6b780317616b3ec015f9fb62252f7a13b152437c66a2b93ad017e36ba6d315309440be168a2ebfa0ef1debdf0825e979038e65597a5a9a6caa0202a9b6f8c576b367623b6519672c9d575e8d1365a30d25f27073660fa1236a962cc1555cbb99deaac9a7b606bf4030a2816fb08a6db35681226d27a247971566a57043705343b0919b205373e87e6ad61ffa8dae82a19d14127ba306dc71c4b20a721820c239fa39c157e60d81be344130b690860e140244446300ef9737a7ab3839c0450b26e9d0cd3401ec5d83fcb14d93e0c18db27ca785811c3db7f48f54a098dee083c6f779935b6d6cd1812bf421e4367dc3b71f14807b4db0d818b5c87999fa098b3a7e1e17037e01a6c7cdc72446bc6073a12b5ca4c940726405f98fdd798a9d19af788b84509ce5ee44a17208c944e931818cf0dbd38c1d82d6dcb924f0cebf6f48a0250b923666b94af300a7d9206c93df90cd91df4d01e98fd3c95c0b3897b5daee4abf38dafa8342958156c41803b66e7043c3335021aec7e58c8cd3d3acc496cdc047cc0559deccb971475541229203cf732d45ae6fc22df4bd90ded649d3e0833e5efe2f650f5048f877647e2dcb45dec4487765f02c8f600105aff9ba178813b2cbd4f4dddaabe671b8144332c767432ff808c144708ffec9d16c28b13ccec43036f9f52ebe06ae4f9ad05b77d48416c7e130c25c50d9a8d1852b9ed0c7a38c2c08377fe1c598c37471eb0f94c51b2ca8b68db59d892962c43a4701ae80c9299b97e988877a739c20d1d876d4ea72682506e357cd632c444792511cf1b959eff53365da4bde4907505e8f75a1591d9e2a1fac4e3e2b56db94e45e318c793d47666cc058c63ec3833e054969b738bf06a5d61b67090c32a3b0cffa86efd8c011dcf72c73a079f5a72da5ed712d57f24861d22db316cc876d3a80c8cb72eff1915b7581ce42086f515a23995cc3b88aac3f21b2699865e11d2e23050b19c844be90bedf590c2b32e7eaac59b37909feaed5af18d367f25e354add39c6c6c6d7dcb0091744ec83726698a124c8267cdbbb39fe780168e15186678ad2735c647b67ba981848814161e95e36dc2d86a3ad46c7873bc1096cecaa5bbe6fd5d3c1567933bf54536c5792d813b0dccad7b0f99dbf1d35ed0a4a8be99f5d1c25643145c52cca39144bc9f5700a70dec56d04fb10ab91b44626c29fed2d221a596e9ac4856bf04012edfb694a06f0f24b1cafc6bae59ae0c642185e9a4ea0c0b6d3ddca0a210acda2fbdf5dec46622d92f30d8738f9f2bc46c8a8d49ed75639dee2a4c68b8a91df6ea899418b998e34fc80fe49548fd0aaba0dc3984a9edd582a685c07822ccebd54030220058cd04c5a291cc48fc074a8ac1684157f28ffa8ff59f7003308d2ed590f23594ace7d268e55b82330ca6d551b94fbcac925974dac0a481767c4428911fb2d25f08e34f619b5c0dd96d5df48a918d523dfd8145f5cf96e9ca71ca58e677d73c2da89945e790f24a34c02ebc3e92a61b9bceb5f25e36c44feaebcbd583b380ff95bf1c9a44938aa27c067cc14421c571c8fc6edd02e2e2293073f08c317d7fc4cf26c5af593c3254d0befd3fc5089aa668bfc43071589c1fd0879cc0890851094f25d2d39b8df0eea43c1d7d31927ccdc7aa7a13e59762fd842148d7c24a4bdd349d096916c1eaaf7aade85117de130f5bf918d1411d46d29ee2b6250e9a3653bb610cdf9920d34f54d472be683a7f092b3fcb0e72403694019165c2c015d289b1af9363c220196f508f85e59576ab7420dbe9ba7123d707801939c1aa351496a3291705aa4955254b48650bb3d109fbaecbc30729035a37957a4834ebc84c4dd0a4f1f77ca15823888238432a7355315047ffda1bfe86d913f708b0da9312d97ca87b03feb2b237bb21a6eb9013782d40fcebb0a13892dcb3da3839c072adc6d6a64740b57219512446b0fef813c8ebf33860d410ef2c16933bdabc01fc0ac35798061f3a4479b009c97014c1c88c77d6d34e85a658916b5cdaa7b105b39772d9f3972c42b7617d3a954ff669e3146390225d1d23ae204be8731228c145418445a29991e3fec550cbf638176f9f29995282ea2ee9f3f1fa8fd68777d37af9bc7675f9445c75f29ff7a79816b82dacf86b80cfde873b88a792a7b626ba63d7a805128e6cc280dc90cd605810b09dc014b5a88f04d14e5672df7dfdd694754b22df73575633617461cc738b759ccdd52fbb320205f8cbb9fb60187334f175406a9231843351f422afdbc7ffe7de8d53fae7d73e92ee431ac2a15aff7a351bf96c66a2b564702a546b0b584ce5b88bd696502a33be3201969eac190c25c2293516d00e63601da64240bcbfc3b05d930574ffd1466ba41a20d030d5358235792b0ab006ed6ddf2a1a847fe9db19353014e429acd5594ace543cf3a9a6a8271b2a1753a5aa113099e69d1c37bb6a5baa2b173709bc751e7eeb6116be9bd1d0f8537436ad4c8982aaab7dc894a73eaa6c82d50cc2c16321fa61c731a544f5cc25707ebe3e9662f07e7cca054ab152ec19b23569c36bcec4df6f6218fffaf343340115ce9ca3ba19d7954ce3b127c3926e87e51e104535230f9158a5a15b4615febb58c4b2e3f18c2ad3c32234083aac31c977e9380eaa32fa4e49e4d66c9f5915aebd2d6d597fded9884281a480a3428c6a9ebc55054d5310ec2c41d7946c7c6b14801976667ab074b272d3145c8eb269c9a7ea32da162d27e56932a6ad228ad5cca68c2076b45deebb55ccd75aed6c0eea9a8953effff43520168fb14e2136a09e62c8bf107834a198b8612c0c5c7c2c21e06cfe5540d2d7f5a4ba13e00d79741bfbeb3304e6f29a913207d51d3c047f97f773866f25d5d27a624c69f345a3cb44cfd7d44fc745a96eb9ee08af78046b5fefd7afc58620a7eaf72b9d730ab317101ecbf9a13f715ded9d842a22ca6a65656c0037d9b7af191e4a18134c045db78d17ee74790f3a2bab2bedf49ee4079e6ee27305bb1811f1e884456a0f7526705bd6714e351e19e8cbd29d53048a0dcb05a3db9724f766efe9f28c1477103316b464b7c14d5070294a61e81373fcee4d2807393140bcf29978f054f35a94af25ce97bcb411759dc120e5fd72030d36468d02552c02bc63445c2fe554cfb1b6ae95b04e40936202b81d64c2f31c54b744e679e55c3b5ee9dba7bf82c3807be416db14c26139cc9451e7bdacd82acf8f75b29131f0c5a352b173f92f0bd35a2c31c6d24a62d078654c26373d01efe44e06a48707e266bb479faa97aa33dc2c30b302401da387f59d3bfa41825ea30989af35bccdc707ba20f09779b0931acca6ebd293dfc25d2a06e765d46a01816d9f18bef1befdb9ec732c5d9efc6c9928bd8d59a51bc1d0c06735dcd4faadf3cb48f054a4103d6d22966666b051321f61504964e158bde52280fc1e53bc21880749144eac0d9202cfd038c8bfd8da339b101af56fb375f6f9b13f86f392012835dfb133442f22ce01595a98f2699ded4c8d603357878fa7de6fb78cb217ea578539433f4568e03975d77b58c521c02d9e3c8055f1601ac5887d2a404c3205cf820f557d13f22aa9a252a40525990a0026285e054161b9b1c5df8cd71367e5badc917e3e46cae8e1e80ee446da628a2c4d5690f8d72a6055eca3a348d58729c806005b0ceb5d22fad047655e8b26104b747ae9a4d7d90ee04f5d9790a4aa8adbdce9a7f94e76eeee48c3a2b4bf4d73d409908a1f97b172afc88873eb6c7aeb00e01562597dea1c90a3d91212930ed8b25f78317fefc568d5650097743c704fe140cecaf0be42970971fec297490a0f04f0b4e67a744fe4b5bc92d7f41731bff54fb5e0e4c1102bc642481866dfb2507d0b9ed3259c7406462968da58aa65a2bf1c3cf858cb92f428891b0e183ff9c822e0bd053100e629df2a64351fe3c13394187e585c176cb1a1e8d59a30486036a3ae8d305881f2e20f1d5505825c8a08484e485cc41fd0d10d76ac67a5e2c0310e3a05603dc07006f38c5751f7f1dd728b55c2ee4835ef543d8b80e411cf6d4f8e18866884aa3e1da5fcb04fa6a8c5f8c0327872994186f375f66b944670b222c0c0df0e215fca6ba7fb641fe3371c5452210da84ed971f840c81719c682e31661a8bade3bd8a8d64da2b81b5b07f52e8d518248fe5a56f7736dc0f7985ae2bde5b53e00ba521f6a4ec865a5d73de8bcfccc28a2d82841d1ba191aa54e25fb286939d17f0e76c35defd8e70961e5373fbcf6122dd8d3dfdd71ef5328aa32b5f7110e79e11416f09447300f84b7290670ea910bae08819de38b2127478d1014245b9d614209d29a511970c33b4d4fd7cf9aff7d2a2194d1193612947cbf993dde5fc62e8c43191e0a8fed60e743fbeeb3c21127839cca53a323be858700df061ff3aa836180020e2fe344928f2ffbf3724dc9edac5fd7739037cc610561b4757f22dcdd0cd99218a50092a627fa6b5089ac12ad9c2bb4de2be5038f7f289ecc8f1a88588ea1633ad93c4393c413d9bd0557d7cb48619fe42c7a83920285f8100c2b7fa133325e27ade6219b8ebe24614b5c58f89135a50eefdc2b9a57350f79124424812e54b55caabb8dc6095e816505e3dcbe5a24073206aa4a1d9eaa2f54b7986a64c37dbaf92ff5a1fb00adbadbeb29bd736610e1276e369e4f76555dbe53d18836d2ede7b1ea5baf254ecb5574d4ebef4acc59287946cd211e7c6c0886032e583f2a29e1055ef1bb6c7ae4d328f2e3384ad533f0bad308b68100168bb9fa5f48d9f9fd755b4836e5261067bd290e65dc42b018192e9b20a701d82ca59784eaad01722f153614982b2606e91acaf2c0c617646b692f636e411fd8f77bcc57b62046f9b446c16ad07c4a6338a3d1fa81c2f168c01cf317623eed85934164e056340c04bfa463da178fb82982c7c759ffad0cb8b3fa2c8442e01656857a53c06461b4b00e394b4ad3142e1fe1a8dcf5fe222e51bdb2618f902c798f00331414a658cfeca1088e8422ef05bed1310d13195e54ba8d61ad0417956954011d03eb3e56b8f607bf887076f611e46505909521e3447f8da2509b6e1e6cc6e7ff7343f3713a9f44b1be1e4332a6446ad1ed471577b5ec282c42cf839565ff04ecfbccd4d5380815b88688b641a397ecd5dc75f1aa416ae818539a7410ad5937d46aacbca98fdd2da9c64f213c1a4690950bd4270eb956edf9c0e2da3a33668870bb72337e97b2db4035e5ac7aee28864fb3fc2c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
