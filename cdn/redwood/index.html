<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fef6e2f07d2746e18c192d5cff42933a2293808a9e02b91d18b399f3d70ae8fbd7e81d09ea32057fbb1918217d768fc4b64fb679b2297a91b3f648c7791c722a045807f8da93a69fb681009277436bf46356f8e9f93bf60967d024ffaaa76f83b88d07f1d8b82072f067a678acfbfe6532df84108cd9674d20eef31791c5cc146259476ee2021c62e37c5a3ffd9cf2734710b084fb462640a432b7869572ef898d48a20c60ce0f541a6a027311a6d94eb802f8ebbf0054f1328e73b6dd3e7a5ed7568a6a4fcea937f66de50320b895e85d4e0bf27860f24ee36bb3d32286bac404f987d8cb6f54c39973233422207834c74edf8429258f8e0e787f506c95aef75081693423dc6439c6fabf6717c295fafbebb3967c645793156208d294de6c3b67db01c1e2d6f9459cb33cb3568d2ddc3725104ac4f91717b35962dceb4cd65474b1e42fc31fe8acefe729aab22d1de49f4cbb0eda94b3494a8243850808ff34f707a3233cad88f27f565ad7fd8ba1dcffbfa8663f1a4b499f0c2d15d5d4a8d8c07218014e06f72fa3dbc4b7277788c7ae5f3ed4f6e97f1a38e04aea7c0b8b5da68f3d3c9965c3fc794a95428ac781d17b53df3efdbcad22613b855938ae0256bbb7fe46d9ad1f337254baa6873c61ce7f836a940a8be6b89bf8d9a59270902cbc33ad0d4c6878e4a9d947b3dabfefe5622ac50394411524ab5373862117e19be580c738428edc9ddb53d5bf399beef72d4e4c4a902fe3c7c908cdcc3323e655ebaa715e3f91301773fe644835cc4acf4fc23ebcb9371563d7995b59273b48eb0ffb297d96ee0bb089a824087debae785e923dfb8f25aaff119b6c7a409fbe15db5f6100ea109b1ec2fdfacb7347f2d669434d4ef6e21c7c4f1731d60b00fe5324ee67af15faf530bed6bb13bf2e7062ae6218dcc583ee0125c8a12804c7d04033a98219351ee6592eaa25899f5ca4002714177e18392fe0096b053fd8e604bd599c98f0ef7586ed8b3a7f01461c51caf3e2755f7fb2ff9c55beb4d71b63a85ffcb466159b9cd8ad21fee90a7569f4ee956545f5aee48ec891bb7cd12c30c8fc33332d102fab5f0ee6645a8e0f9ff1105a7c701e194d1de290fda305a88c9a20bf76ecc8c18adfa3016295ddd7177e61946024abae5a9462f1cc575839e3d879ed801695afc3e7ec066005f1d79a0122968ab0b81bd0bfd53141755ebcc4fdbe8c04ef1d60ebb52bd4938bcc124e2e58e4a0593743269ff632c135958034c0cb118c86336113021c6bfdbfbe5e9022923c2125bd708ce127b84676054487579757c16151aab6ae12f61a0f6ea150a26b8e0a185e86d9266ce442af26b07d9269ae9d7dc02f19a7730f0a4c1800796334e498093a1c52a90a4c992275c412f755b1be481fd1b028b19d66d2b8945acf277035337501ef503c03c505a02559d13a60ed47b682bcfa2100e6db4d4cf936fd6aefa05c3340963144142d0ce51ff2b0126cad3f629f92428f15d3c5b6b7b624ea00fae439d60d65808d0e459adb729a241de1691cd8d748dd8d1747495a8a2c049854c77bce0be5f85fdba8dbb7f2a55d3420f2f8220d0844cae9be304d4824be85cbd823c79e2f35a5eb0bce9b5b190122938730a5f2d7204e6a1e40b250e4aeb0d0c972e750b32058fdbfaa3b296e033dd3cb3a66613741dd7aaf8db400bc61c4a802a7e9fa2e9b24a449f1ccb0c769ba8869d2164e7cf40dd8fe315561055d2ba4c64a71ed13af42f8ee7515240aa8c37235540b269bd6d2dcc28e7c4476b14dab25367dabe3c03ad9c5adab6c083a3569f8bf462ddb5d42d2fa6b6efb2632ca92f31f72443220fa24da8463af1a4aae5c7735d7e50ed4ab8ad4eeae70544134576283fdd2023a62fcf5d2538785808e2085126847c574866c76cfe0e7311251a6337ef39dc2eba85ae141f807bf2f084f15c552f827cdcc3cbef51e5dce46da121e29903c9ffe147bcc10470b9fe631322a120b96d05f906b76dedab77d9b39a1adcef7bdea8b63f0436dd79f64bdc7daaf682230db10c957b379c4e37c8c48b8f8acaee7d29e7c6c1efcbb7840b06c5ec78fa316146b6c6c624d77f93ec56d74e7c36b6f2f7a9681c13f10b394cbb98b10f3164f8f236728aa24dd613f88f16b2bb17d8148d4d2d0808feb50079abc92cc0a2c86367bd60f8570142d1656a733c6bc4064a28c6011a89678f8d3210bd36d8c225dfc83112b136be369fe08f1924815aa71ebd60391e26d2f1f8cb5d92322cf4c3e6944e933c938f1a200d26f45b79f57f7e4a11412d7514d9b96d10b7296510aaa3fc664a0d0e90dd45f0c4068655f2560ea2c4ba35eb1c0f7cf0ceba30d781ecaa3a40778482334f051b512bf9ec6df4393d00b4ad30244b4aca77f2cc193b38572ff8c69078c06d92e7b7ab84ff5b89fac3b827d5feeebe6474bc01256602a685bf90095789f35efab5fb32f6cdb101c6caa8407a6d5f6003091e79fde4cc533475fcfb69ab666d65a578a1c43ce615e9b12f3b1f26fd3a32d90d03f3a4b3c286312721d6c24b97e871068c77db7263882b5178e2c3bdaa94144f3af15f47d55ba49745213931999bca33776d1046c82100a28e3d9844532937808df78694554b2e5fb6b5aabeecdedf89ba686faf030560d5c069ad813992fabfeb257bc2ac3744e097b4f918df1adb88b1897dc7a26ac12705efe8f1e7fdeef3ff2f125909d6f6958d10f9cc4e0bee6d0f63a477ae718fc6eb1d4da4a62af4fa8cec3413ec0d9af8e14eac5970602092456600f4414b142d369ce59d92ee34164e702bdcddd2eec152ba4f6d35a35d5e78096d270426d16f433500d4defbd9f17c49bbb72b2b49b992c75249660538a24430872d539347fb3927fd14d2868ccea31080b55d9d8233915e098694a2129c8f778d527b2fb4ffdc4972e2a06ac4c91db2ce9a1924c9ab03818fcf0a3b6dc61f6066421d493264e8dda9e815ec161dc0d1854e9034d0e838d2488a8b6471a987dead5a8e2eddea5ce96631e2972c3e2bafa770d559ab7558d3ff31dd300f1cd837aa9e8dee4751fb827cb9f71aef5262fee7cce0a311a62c0e902abdc3b40065773e762ed5075e1b6182bf82c5d4e6ad41d8c4b7d7d000ca578bc82f98f5bc63c2bca5cab467726a83c6b76c1bd73205e0a6aee19f692374c18b356f02c94594200fed065055c4ceef2beeb7c4b4a63a1209bec658be135b741137c533ac9b34243138ceee196c11429c296c357bf577bfe3aa2209bb97c477accdf5593042a242d7a5e9f13fac27c2edff2abdb4532fa5899125c3fb9e7def5682609959c7c6e9b9b3d9779e2db08f68796aae84a86d8408cba1a9acefa13ee934db8a096affcd1e7db547393282b074235581122a7d0b331d5d7b2547c5836e738ed18e326465e8e4617d378510a9977c66c4e1b03efb6f5c034916081e7e634b87ffadf91d03c23e95247460a7826ed76e27dbcfeb0fa0cdacda93e7f6b803d579c04c2d37e696c7652cda34c85ddaee9e78f93e556da1d91eb00ef878d0db7329a4df343822f56ddb0c3bddd26487a572a570982ce4f01277d428a1ddb6bbd7ca79f18e2eb8975aeeeb449957fa43e409dec23f94be6c74e68fe88495c080d1a44700f3a90e58f843f2b6444c96b1025293d4324268becaccfae5d8a02e35307d174863715c9470a3c5e4e092b790324bf8a7e1fac922d3dcc9806e4759f5278189acc60b58c92363bf29a5cd7c73afc01d9f9d565449734d92ab17520d2cf41f6228adfa40beda2889653fb25c9d12623850f0e0d9ed992c3606450ae7473789a4db703d51cbde153bc80daf4e42cea4a766f821cbbffa80f4b52e1b469caf3b2751992eb2ced11146dfc9d8ff6e49377d219339690e73992f3fe15025f488efa4a04776fc04cf652ed875a3cbdc964938a0c15a078d52dc812d464038b050f0546387bb1f65ac5418b24bcd8ce728c047d1ccd4ba387d4af5dc969ff048554efbb12348282d91b5b9e752ab6c6f76a9e2e5bf3e17bd7637b5a1604b3e3d266e14b2446345f9a6a73705a24f4e63db9651cdfd4e19c3facd89622d418ae0f6e1fc187829bce329356ddddd2e841220d29887535119f76f7d120af3f56da92a5d7546257910bcd8d984d808d2145d72ca18255c9ee823a5479d770ffd10629c85087881f6beb97866ea78dc34c15c9b6e49cbf8645bd62e384b8f573608f1d2ce67370ee662762a66c3cef1cf4b4cf22da52607f92080b1c2180498d71ff589cbd3076febf3b2301165b3675d1e2e19026b1fc128ae280270ccc085ed83d98e80082d0202bf186575425dd633fdf8dd191f9c7f0bc54eb18139531fdba9e7df86b5404ba55c5750e79961759d3a11261c3e8f09188b4f8d1ba52f31ae42cb8f3be6e6c32f87c8706c6da0f52c053f345bbabf55a047f732e298325dc14bc638be460fbc9be65a3e345259f814e011a7ccc63fbb630c1753576b838bac99e80179a80a74afbc2e4ddb57c553c0497f64269c7956f60e4707d151f554274d48fcbf934607de413cb7edbf05bf6d2b3c17098a756ba1eaccc9a1797ff06f9fa468e8328191a0eeb3e5fbf1b105256944f81df70853918c2ce3e08243bd453e8c0f12a4fcc123e6ee7e986377a3794a049c7715f5f08b9aa395ecf9a259d5b41a3c18fa5f3478875328b492eecc9424edd789025bca30183a412493c23336e425c8941c0cb062f29f340cf8583bc1841908d209d209abd9b26fbdd16f173b674ac0956fa67f55d45444ef560a26387f3351f70a462ed6233b4a1ef0b9e4967c8e564569014ce553f919e129dfc56f9fc29b31f65949bfb7e38f29a4a5f9f50fd4cc6a54733e40b1ab9df5e9c64d415b3b4d93723179e0f2be2945e2994c98ce392ba031a8968e77170db9e9b5f0ff9942326239d580ffad2eda1efe5ae5952b3178ce89ae7eff14c380ca65e973b761a8ba5bf3949aff647dd1835d39e45fe801c9bd74071e960014b3d2caed6e3713950892d3b0a493c974d5d4d7708bf3f3a90f8739c79cb079a6ad0c6cc18f5eea149581a9c59c10fca96bfa42899185bfd870b17f44fe88a5b3afe946c166d103245fee391c3b6415968434146b31c79d259f40619a92c696f6e4d3baed6dc93992b54859f458c3fb1f249e548c61670989f46763e915b943981aabf1fd29841b714ce365e9082924a381405fded5b330fe33950c6be48da9dcc223552e90172717f9c9ae9f11d347ba08bb3a0bd56294eae2f12ad0c96241d369c02bd4155647b56bedc32b6e763149da560f77431f704f1e10ccdb6c19d29b95a4a0fb7be81fda35965508d2a7f3693b49c121e5fb33ef6f13a092ce20232ecb0a2ec447844bd6371a5cff4e5478baac35b38758dceb8d1479f3c8e2e0b2d4800016928ab966cd21f1bee6ec8a5643a938b72c11a4788cf2bf269c4e9f473f2e3b9c26668482b20507c995c3ed0581c392dc28e31ccfa9fa1f231c3e74eb7b9f64aa850bc9a9ddd959770f944ac1b6cc7664deb6b02e0de64e47005cbe057b645d225eb2a6b0dde44a8739aa27343a6cc3073c8be136130bbbc5cef5a4b868c37cf049afd5685bf483c977462c12cb083eef3a7a2fe480defa4705362cf056d462b5224a5f306cdf2c1a3fd649b934e48369f5834196f233836a4b58cd785096d12d598f6624996d2e58a8c521d05f3c05750c89ec8426cc02c619acfb4dd2ce3dcbb5908fe75509a84c74f52a602b9b8ca79a9d9b0ed71337d561474ba9e1265b458e3bbe42d6005c6e8877f188c8d1a9b63768d9ff7ba4ad793d86da081fcd93a7179cc93eebcc157df7ba4e08b42a68820eec3305a969b922cfd19c037d56ff13196bd0720fa522ba64325ac08f879671ab09014fa7655d145e8ab7000f7ab3c588b0dde43e761ca3cd36dd1172bc6c72bb31d77ca1efef2b5c15289cc0670a877cf6be5e12c9f59f8918eb0fae7a2a3fd805a4214fe6841d22c649012448a44ec766f46a27648213348517e65f8d80cc7ab5e92d88272d546aaf87f89866f5fcf8493ae498b290474bfe3aed0e0aa42e1f3c853e3dfefec6afb6d227433bf03b86a7f170e70c8ad5f68db466b4910bb6719b30e101abf604ac07dab4f191cafaffb13aa8b2e3fe068dd2bf0ef29514d665d9fc2dcba803f54a7d1f61b9689fc4215dc3c16237613a4e7e0f771a05993255cce3d0fe41f525b32885ebf71d09076d1ff491bc1f02c52f78df18c7e81b6dd7eb9d55586b3d58d9a8135a3ac4e4b29343e1662934519746e955fbddf9d1e73a22ed67da71f8de323271c0d80be5de51b1a5115eda18f4b2f088da5152364ca899abdf653b8119ba7eeb90300db9c46eb22e0777bcf6095eb34a29e5f3cc342b1caab75af0634c50677ead7ddc52b7c26893ab0ed38677d024c1e99b56a9e290d99d9ef5373d2be050ef18a7b42e937ea70dfb801fc38b8669d18cae33cb4ce7e3f955690e89d2ba188ce12d060c9f501260683a4aa2ddbcb59cdd88fdd8161c3288e07b0bac45984d0dc76507cac5bc0b645112e265d4ddcbd79d9bf1c7179e8400f29ac2209904d6071cb674c20dbdc6f5bf162f07cff520ed8cb7318ce814c95800ae131b4ed24cb4203067fe914d5d62e3a1b590ac8f8c5be765478bcc56d98e6010095fd0380b268bb8922ab1cdeb32727ca8429879645497970be561c9a872c9dd4b39704beae946b998254999a98b2d3ccde54f4ced708cf869aa9acb83290a6b5105e6a33b7bd292445f8c34dbcbd8110012149d285861951a9fc5c515c263d67d87e0a2e4ff90b9af4ba46b4e4834cc0670755f640f82de8c58c4ff2efd60a878ccea1f461680ff2808f605868a3d435a73af77a3a98242dda74c34dcc02454842be15277b2477c8a217e1dc023817841ecfd9e2f2de0db2b6991a1b5b62b15d5a327f2a10aad8412e4e52fc6443c42b493150107a59a2c2af9104a3b9c8c481fe6036c8781c75c89728dffa3cd1a157b3f88386801459464219a6b7dae59f47db7b708aa48548ab9ef396dc10fcc2d4c0ba4e793a331abc382daef9c0ec6fa7367212dd9c0c8f0803f6d516b87270e1bc29596cc5fd6bb26106a959ee6fb98984b0ec04522ed8ba97361a32d55482432f462074a7977b77651536e5b959ee3e6551e8dd406a0fd9bc46c3b6473ec94c6bd32832c4ced4958aa069ce6f3178e5e4b2a84ecd3de29c9286f4f4bb6d32b5ede0171b2aa52ba5c5cc4b726c3b1445e29a728ff91491498a43b6b08ad3ee666d29683bb704eac8f21a2f2992423c405abd3dbe70d30d8b746d3c50ad430ea488a63b0ccef48ac3c54476dbcd1ec330287c4a1efc2430f5dbd236ac70e4bc3c0b4cd9c3ddb9ba2468f61e4f7aed523594e5fc09c508ac98366b345439d0e9e09b14b2a2ce050e09f09dff00a4b1694a65a56818517074e0486168fa1e8f6a58ada695a8cab12c701855b705fbd2df0bcd69887585ad84ba9d1f3972c618f002c71d4c0f802075f7f92f52975bff05f6a5ae9a282bf53ea97e8db322ac155ed3050a94f1ac360d653424a8e77e29fff582dd9336ddf7ac1065b10bf8cbd1aa822efd47b8e5b59f38d864acc0842df36a7af733184ae4cdb7fce975b952c1d5634545b501d8392c1dd3e9ed1a9786f672b01e65f086b4b65282499742ba6a78c786514d0df9b469974f2fd5d97908eca5ebf182e3f1413d3b1c6dc4b9e1db8f74e24102c8987f13485452ba686754f78c8651c1693a78b8b29276061dbe3f01c138cdfdc2e21cce11fb1113341d2acce88840aed2f2c47a0cbd585c40053d45f891b6c3f49c9b944f6feb6ffdd9b9cd9b6f1ea86c85971ca0e8bc0a41e34955dd5595019781c304f33c1920c0ea07ca97127de04c0ac0befd868a8d68294095b76dd085574cc818e2d7c2abe5f9781fcb476ee5f11c083acdb425e86d9f308a21695519406feb3a7e13d2bf2ee18f1b0de60b92222e6081a797f95919802c5b715018f31a20a369665d6031cd36c8e70d8bc7a54ec25c8486da3ba2c82655c06a0bbf3f10f4ebb88cc1b32b02ca52615e9fc7a6af498a30c97c0b643071d6b7a4d1b0309d2693da16bbd4acacc31540329789de5ae18f9bf6e6d84b00e8f0230149528c8a8b7d43991919363941cd3c094980a098712645e867673b69b543a8f842e7ac1fdd864f574b1823e79916a7f73dee41cf34774cc01a8f3f850449378928175cf6d80720684ca6a0e5e500d84b132651f823c412bde3dbf3a55de15820496c462cf2e43b558f8fd3efdf6624bc5dd070079227f375876d17ff5d83ed9ad9673e67e5e75c318e4e330ea2be7c23ca22ce5ebd2baf9a434f5cb669b97524f924b441ddfbccb989c7bdc13c814f2498bce7bc88bc070a439c57999ae50ce43a1a3c2e3896d4c26954944bf409d1e4ff1b929ca2d27267883dd740dc74e80858ea1000e18501079a9db9dcb387dc73d7d36c7b028ffcf4dad2634aba334fa4951189ab4d3f75d6f712da847806e430c5c252aa47edb5edea43fb2e7a276e621c615e9925b7645bdd50637e53e228c05f45f058bed49a384079e5990bec4f9b552d86bb732336ec9ee9521369524a147683981714ef46d2f6bfa1f3f58e22a9380b492a8189ad2d6316d9f9beec4d716edc2600099bac3e4afe4cb3ea6b5e4ff04dcee732480a80b51bc2002de6b0b8159140c0714c9ff059f740f6dd153e93a01595db6d0443ca638cf58af5fbc07569243d8de931ca4c2c8bfa8a86852315ec3bf82d26c32ef4a5fecc41da872e2f4e81bbc1586d11df3ab660d295744f3f6ca7cbb2b504be00ca82be39deb1063c939e7a91f54ac89cf3c7b65dbaab696f513a43907c3962254863f0860c80835c2e2d1b46f4f30057a719b6d994e6759a228e44f029a73726ca5e84bfddd971f902398524bb883ec568e34388f70a2288f11898473973263361d9855694502cca8fcb507f4cc7c6ae7321b7a02ab4c399a9b9e5dd2652cd60362c46bafa1ee255ea260858b80d1aecaee9cb316b9d4cdb131c9b17b3f512fe90ab3114dfdbe052cd280dc3831ae9f0f851f49e3aa891d2cb7128be261ddb535048378c62a826d6d0603900f758c8f49925211a19478434b73e934fb71de54f771657ce1feabf25e7c419eb21c26ebe0f7fbb3a65b46280eda7a128a7591c2b08a7bf8c953bda3a11bf7dd49d46b42d939e35d131dda236f794dc1fc8cfe4297635d6151dd9b3a0c22b258389b202b13c798492cfc180330e79340fac600c66a7d208fdc77df34e2b942451f34b4296ba1695123e9144db6bca2d0421a75d3ce3981b1be851ab4e36c510be631b2fbdd0422f9f5d71d22d07f5d5a96ce38a8e15a7eca37f46f63c45f7d97ce69063e589c7db1d59e7e0e492971ceb360d238f49cbadcf2e01838c8bfa78983e5df3df7a1955cab442598cff392e0bd990386b550a0a99d0b1dd44435d8ff19cf856e51f5e8684bf668bc3a763e102489b35028c5de86304624212cdaf1a3d0860d10cd943aa6568e52977ee8a62ceb0d5f4ace6eeb3de870422d080ba0c80eaea2505db374163336dae5dac8c044513e2494d196a0431b464bc0a4a385524298125276bc31d9851ff92dc52d39b4b81d1094dc44efbd7eed05fc0f726bd1ce14c78906bfb5d64ad448cf6c181f7e574d6256fd977a3fd5a2f48be59cbd2a048e51d8a7672b0c37540b5cee3eef3a87bf830731b94c2336402028976c390481b559ea480d2795efe215b69f69827e697709201d7f7d5f61f910b2dc279030138c0476600b0f099ebd0befc7983182fb85169af8ea8bea1f344369b02f90ad30823cd1a053719a5c53629bceaf350c9342e214edf2e9fc565f5fd04c5df548ee05fd7d61ba89308a6ed2f762ee4ab992b91c11d27ce92185416be58c96b51ef245f7d06259f610c2baf226bc470cd91367b38406d9f45fb46732fc32e1526ee4972eba8b79ef17d170c17603a00d30710a0f42bf1d1724ddd59545594b22d3d29dc70894078412f68661d888795e3afb22d1bcb3f112afc8c932ad5fcf88569bbc690ec0956daf1a5df61db8e919f1aceaa5481045e9de5718b7082a6b3793fb0c7d1412cf4d350b92d577e85c1e4dd819c85c11eb6939e8d01b67a08172aedd57e937795a7609ff1ab9d774bc26573806bd139b84a35bd1094712e6703ab8d215348cee1415e26a3bab829dbe695ae8865608c19fec498daf888b417222189970ea80c3e33589c453232e2bc6f31bc72defc81597541dfb3066ca72afb0a1baaf9cc9c6937b59dbed0c95f72bb6517055cbccfbede3b49a66625d26b1ff730da9499f7ff3de8d66ae5edcf70a5494e54ebda27a26201dced8edbedb54ea175f7e67f9b1f5e63dde8ae040514f53f2c72523dd1e63daf0de0066d62aa0f71c43bf4c4bb83c638a868e58709fed624e69e89cdeffbb4e29277b311a57fa2c836fcd8fa0c8dd440522ef0ddbd50ff32ccafd987ba6d34fc675f274aec3de0e53d592dc2dfbc3fa61812567ec7cda65e6b017bcc0d4124ef059c0289253ad63f6ea458abc9fe7c35bf21f4e2d1c9c3821fe04052f83144d74447c39bcee16cf50ec6b917b6120c72779d0223625f05c360c4553469c55bef7c91ee6d615131763330d694c83acd0634405082c164002d29059a98e5ce785abb998a518bacd9762546cd371a87101ac6c8c98cd6886d583d821d99432334f8de8828bd78d0f299cb9539c4aaa6b14876b22f8169149e9ae389c8bd4714e60fc188bae3157cd95c93ec3bbadd2475e196b6d5c5f8e10d078fd21632eb3e963f4b96384dd2265ae9a261c67466a5f8127e22abff726b78722a9399a0e79b7b21ecc850d2066bc61ebddccc2be24f557221312426cdcdbaac18beca8fc24c82d075bb955bdb0886c23c2a7a2368474a564c7c3caaf24b4aa1464c769b20c0004aae0abe9d6b777b237590525e42f68d2490d24f0ddaeefd12c396721d608f22178e13cdd8752494e4b462efd2bd4819b1b797e13fb9e11b88db425918b133e94317da79f84864c8d0d096b790d9300b414d27e2e52abd211502a22460d8c521275c271bb2f19700b3937071feb89fa7cf276c1e277cec6817628ad58cfcc05dbab7b884376ad2f3fe6decebffdee6ba90807db4e38b3e42696a978f88044c3ec37d87a576c5c7887d1aab042ba72ce20c64a6b0c14ee1ace2389e5f46b17f19adc16e3b7baef2aecdaa3350d5013a8a8ed5cf035335362407d25543c917d6ace372998901e27def53835e554cdc832c1e705215287729c66fd614e6d58471b995019615d42164143e7888f80b77c9c1ffac0c2fd53d4004b93f7039e8dcf52ebf6f090e967698863f6edf4a9fe9981f8de1954f7e5aba89a6d9596f87977b30c8e00a68cf07d302bb55cdd69b8800e2ed861f8a00b1e25a41efb237df5f6be6063627308caf9f6a7b3bd4f40383ad5301ab2c30ca65e067a1790c112ce8a944acfbf5d4151f50fbe6e3afe4ce2fd9ff72a1d2e2fb194c4f2472006414108ddb8408fd572e374c67dc416766830a104f573f7afd14d57822d212cc6cdddcd286c7e54e7ad06bdd805f7876f20873c38672849cc5bf7803f385bd46f9d6db2752aff60f6efb801d6da6ea3228157eb437405e676daf15d941df225f82483f5db2e2cb6f8471c3f3180c59557acc9f13edc8f3c650c2b43f79629805fe46e8fad8e13969285786194c3bd89cee548083fb8a6d6347e51e011065ed639a010ded44a28dbb9c9e7edb5ad4063eb9c561916f32052bad56989f96112bef72f25d38d77887f27542ebc25bf3bb6af92a36807525296e5a4aac531e54793cbdf03a857e23852d0a4d9e3ab3d22ae581de9d9b08114fc23394fe8085989b97725f95843b8ccaa647726ac1a7e0aa39e2eeab349d133b97dd9f99baef1a1693aa9baa2a878f13b48d7101384e7cfe4ca5a206e0014bdac945e9876106dd92b9f9d5e9e9922821f9dfa5c1f0b3a9c926e04dfd65451951dc578c8bd14af35a7d8fca109f661d28399cf09ff727dbd8a1039af90d0bc3d3810ec67a429dc8bc1b7c47dbcf08012e05fff0f6205ee575df4ba383f105d6519744602aaa5ef83f59744bdd7ca91f364e4a36c25c55d7454616b81de07e849151cd60b04d48661fb49210848591dd474674b1f700b2422d9cf21129be6b02ed908380924606492b28434ecfb867a3c8c3429a27f4b33e4499751210b6dee5f0c0a521a67983a93f71dc271de49fafda2f51cb378e62ee4440cad25856cc4315c9dff6f8267c39d7e54e38f22bf6f4f1399099bb590e547d75427fc7ab2336cee1d79eb7eb1f58aa8fba6af609dea98942d5b2754d28bc4935bfe8293a6beee0ba9e6c4a03baceb8c668ca7b144f130e391d49e4badf9b3c46f47235f63298cea9338dd817d4fd538931bde7512c2a53f21e5913f0af29679d0dbbc0fc8fa8ff8c4c11ca0cf1de6e668f4493809b66e9c7db0c4f1eff51e1119f480c2cd7cfaebdc6a5a1fcb7c5e0700cc93ae92707d05907359ec007b13246b2626fb2e68ef76c8c2c2c3b070f7bfbd5cbe519089ddd641dc70cb8a703d0d4670b7af8d3bd4224b6e12e0a723dba1b58ecd4b1891d57bb61ccbc203628bb9868ea15dc873e45a7a8cc5fe459bfe3efcc077d9cd4c01e5e4ccc3966dce4e8899e5c63f4300a480cfe0b89899bbe44aba33c03bd0676a81551b6c19d49487009e909a16408ed5c6d4a99d9f7aeb4cee315de9b7a25715f7e37e592935fd259a9c8045bbc1ff81e0e8ab68ef7993c18e2b8f001866b038aeee6917d1e701a4f30c39ccb0175aa905f131c0ce1297e401f30c9f972d84c3b2c2c3d0b437359f59608d7f1928ac733d55899ff3e629f4fab078e52f24195b6a1e9aa6229f48c7474c9e191b53189c32b49358571f4377fd0a222171a9b4061d51d5daef939fb26f2d6f40f51126059924ec3125ef4b87c85bf7181b152c2f687e7bb670e2cbdd99a16e1463dda264405795ab5451d4cd39eeacd8602938f188e036ebf3457847488fdea475f205048ff3c0f20e1a65af102c5f523de346dcdc1b8b34ff2812700c16037b88cef6974f3448852b5e435cd79bb1a4e134860cf124f255beeedcca6fc1a7422992fb9d254d9b1d529f020c9696ddfb2866dcffddcb8094f278463c608376739c23ef047232eda91700d2f147ec0a4cc96d5c90b0aad78c8ec8d2176f515aa48e6beb76e05bb17a8dea63f100b670152b4a35c6a02826bc094baa6f56e5dca9638ca7583ab44e3fb556cc73f4370a876a24c42711ecd0ec3bf50501f8edd402488f53fd48873bd1518ba9bd99a2da3d1827a77ba8ffa4b91a1600664c760ccb3be88d89e9bfd49758bbc095bbc295290af113ba8718edc2b6009e449988b7605a23010fbf8eb4067b10a11f1bd47b27dd2837d71e995ef57b9ef8733277a48aa1e805b96610bc8406e61990faea8756d052579ddf63f50d8b807566ceadc0aa0630980cc6f2405ac370824e280882a3754376d9bb076959386a4ab94313ca43f82d2aaf2a898bbed20c9c4c6d218691231361c15b07245f29d023d22dafc26adc0cbc3d0e47b3a2b6dbe75f2572396ffd112279682405ef3b6213c60880910b41ecbd77911d0bf7ea2a50212199680fe50a10f4510ef2aa27b4e511b20749f64e2386fc52a2ae9bba9de53192eaa58682b3344e7125cce1d5e8ecd0cf303cfe49e90138ed379b4e1d5a8c37c30f68776303aba0b98472ae8951d356d0a0999aa32f99c47a83638f596d222fbdbe671d6e869e59e77bd10de2b11f393911601de6edc89704f9e746248aaa77602ccda0065ac36a9d1af040084c2f7a0e57aa96212c7680b479d19041472908fc559af3dca1d6f8ec7091cfe42c86656b649f3d330d898bd3a9dd05cc4fa767368a6830b34dd2131a3edfad332c9a8cb041144cf028521b2b939e026ee68611b8672d367d9adb3cfb5ba7ca777f32cc500e3b95355b2b29154a450cbd2f88970a0865eb2725c3e0e81ca6a753c0afeebf6164112c8f172538149582980bfb67e4f611727b51ae20af1da0f31fe903832be473702219bcdc5baf5bcd61d397f65cfcf27b438993bf45da8b07f672f8f394c8aaf31401b469a1bff43f01e2055d72ae52e4bd9eb8a4404dcc07c4a45300672a7823cf13e595ed008c30076b15fee79df1954f222e6ed4fa6881c7f52c1e28c23f3ecc8590f9cfba45d6b33140cc21b5e08c757cb1cdbfde301aa6ce5e41f410f6e1f923f27b054aaa28a6df70c730c8de938221cd16a8dbcb512f779aba1610569d3cdc5551a2521a0861f51604dd71c1cddda94f2e7323e2fe14bfd998669385dadade25c3ee31d97a3f7e5df95971973b57495679738d15bd8ebe1ed17c66a92e3304c298fe9fc8a76da1457e632e933a59c1a09e4cc1a1e4bafbc77ac86c59e158ed90160f2fbf451d930cc10f093b99b1ef2966a466ec07b4604953935a859ea9f9204887fe8a88c73da7ea4f235137ce517e5da151b3d8bdc8ba1345335e7aef2edb457b687b2edc514d9c9e497a58ed52828f500a01ee8a627d87c0e78e49f3e001d7135c9c972bd46c77c421cab88294c9e507290157c5613747c7b34d0aaa5bbe44ad415ee0c829458e63cef77da230a92ca7237411e4a2b3858967de9295c1f9164739079a5da72f5e31ceadd11b60dbf7d9af174588cc42fb01aa464be1b51746bef8b065133a1f0da0cc72eedb297f7c10e3fb2fe1d0e55d1b9dab77e86f4622e4fca05317937bdf2213be2df69924d8858ac6b5fe81a3fc1c93fde22db475c1951e692e59c7f6822dfa7941e0a0ad0445830f8fd50fdc0a1be5a469454aa14ea648325074cf815a9189318eb50360efd53b66600d8e68118d029e0c4ba39e5ed134e1810d93ec2442f3eb64d00b5d6516a6ba1dcc45ab0034f2d3f189998ce89eec78625fca44667014fc9470d5526937c2c2224d4955a242226bb13b325cebc9b2f0bba2f7681e675a152455a0593aa038f7323a3c6d30500a29e0a7f9a111dc035a7d59274ab5dc1482600621f10d5dd329b8a14fd91fbf7885d1a3519e624dfd9ec805a3d4604973472c134b721314f6a4580c1002447ddc7a875506f01d9271e9f4e7b9ce195d6f7224c736f780a6ca18066b3702a7920e437bcd59bade413a8355bc6d100173d0699643b4dcf1a3ed6f3bc2c819f6a1fd5b584bd606afb8472278b76393edd024840f80f8b125f77a3ffce2085e422f0808dd6819b233914ca58bf90590d0238808b0f1d322dea497ebac06e0e05b7bed4b462d865ece38f9f648a0d482c5590b7022e8bb0703f40e8852594ca45eb6c5860e5fd61175745f4fa7648006efd0d53cc75a0b99331003b644b359ddf324b75793929a4b4351c8af524cf0d7f2596742651b55c3e09718f3eb6a2fb820a029c3c0ecb490518bcd73a60b669fd7266b2e177caa9e724c3d0ce2e766d82543d4c5ee6133ab6428367cfba93ac9f295a7090dd9bfc679c9dd5f630b8a4bb8e71ed782ffae7606ce33ebb397d4c5a81abf4d440fd94d977507eb0abd7a23908187a631c77e7799cd7039dbed02699ed87d78460ec0c58e4269e2b67b019185a1e13d5337e39dafc044b273a008615dc8864b61e967e8b89b438cb75e7887f35f0bbbbc2a114c4e15049bef17f2dd916d00ce913ae01ba93ffbd177118b1795484b1780a8ca4a56b5a4f7278b9d904fb17f3cdcde826d9444a3f0ec87375929f80c1f351e972e8c22e6ae276f748a944285f8de84ebef1361f8433b2148422ba0d408c2e6a850ea53a2da5b38818970f2cfde3f297d90cdd6e696a173a1d83b4b309c69b0589ca20ff9fb52ce8c5fae2761369a458f4939646c9b2ff9e7c794278e6b7a882b41b3adedf51c16d2c15c30082cb0f236b8cb4997f9c5ceac1463fe3768cb610e0bd83e03991fea945a516c6231e2610c9b66f39a64006acd46177051a8627248f5809ba61e1144f5d38775c0ef1cfa047038e3da5765098b618bb09d0bf742fe724808b21692c4efbb2bde25b42c7df716560c5a6f96b417c0cdf340ad92f726a32396a4aad2a9bbbfe7c419667d7795d148d0fba9be1fb534a2adb86dd24467a31eb074639b87219a6fbb2e6772d158b51f7d7a16b7e483da50a5907f8cae5f6740c3c733a5c7dd7f25050a7e0a50b9640a53495be3d8c4f6c9e361906897bb45cdb9d4d159238d7afd79fd7977b628cd5139904a381a8abe51b784b3c4504ed499d183c15136beabce109a8338ac3312ee77ab8f1d356a59901267d95ca55262afab15a5df6fc95ffb124b48c4a6d55e376579b3376260beb4263b6ac9934e9a85b3ac89f3317e65ca7bdd908be351688feb9cb2ca10beaa4c0f6e4dee746955caf6acf0d3c47cb86d9dfafa5f706600fe623d0cd22837738a5a551a7216c4cf3584b9cea983e8c1014a99877372efa0bcc00a20100c0631a267f73a9e7e62b9afd1870d991aa947bcc47a6352aa588f3eae196941f133e1f761e170350467b488c4fbc72e3d236e72c4b41ee2fdbc70eb463ba3b067b8ade4f7cdc7bddcd4b69ff19f33fd134b664c5962fc1f64555cd1a7b1f04b236881fe761263cba5a847a4fde92e02fc3502cab9f48bd4b70957fe2ac01474e8fb20c43ee00f0f7b33a599c2bc1fd0f6089d973d34b903ce883d656a1ac6a58bc93694a35b9b7f570ed2e452a8ac42d8c9756327f1c4709e9d55a486e00db341a9541f0a77f997d94b4c1fd05c40f31f5c5ae601c677945ef120a7638c5790c8fec7d76198ad6496d2082f2402a0c3aa88b4eaa7b2d6956c9cb91467ec67d36c49b05065d57b78c9f82451ed2cd565d4e1d5ac1d2168d04eb8452841f052138192eb6a908973ffd4bad696939fb0a26d0e7bb5cb523078056927e3f1c29bc100084b57b3a3e24346f8fa7c9e6dfdd5960412e2b42ffcddfaf78029e7bcb5fb19120a414df29a694f692e4541a34f3a6613ff1bda92c4bf2a879d541b3504ab30f16b42e335e2669f8bd559582f0e2a242578024ee1afa0aab055fdf9a05bed9c9c13e03db926de5ddb0c19f069c83912e6902584105425473c74eace7175110f25cbbc4c347e923a351d9b337ea61469d094f4e5b6c7084b14aa4c815cf352b3b3be3f101e664d56176ce67adb125d2abb3d2b2f74acb7b41b09c30626cd8ba33312940ff2db2ba38901db4ab675bc0605bab9deac8baa9137e99f90fc648fd1399a8486ecb86ce5fa4de7662bf74f3e7351f7e05bc1727f9f99bf38f4d843475577197228e96ca59148820bbcf2f1e2223406d0b8cc1fed4a8f3497abe287a84b3ba3d887d7092359c46904bc5ec333f3b6e87a53b2fbdafc4eca1cccf2e758e78b53ec5112b152364e5434d648902903fb74f7c341b5eebbe5d6cc92e0b93f8ee60f6605d0ef3b8ec0692649ccb656aa728664e5dba7cd75ceb3d4829469da999a12a59a5ee9d1bcd7ae98c46383e3b678ef5e0f2b99934503fbd3b5ef2cbd2596fb854b852e922f8d83c457175ab45a43387a600af810e56511939bce4ea7bda9337600eca29adff3708333cf78f76e28298ebdb4f6b2168bd6d779f6a46d4e53d39728405e6f6bbe6bed56c6cd4fa948e5048c83ba90e270da97f8d4af83d7e2668b1ab5102f4af3fd1be5f2edd38999ec1829f449127dbb85ea2db8d76cbbad1b838e77e330ff7707434a3bb3fb42bcd8070e20741b7a6c6131fb0e92343ac22aeddaceff908cc5fd2b77cbee9ef5c4d54656f42de373ab8028c26c76ecf68f872c7e29c23cc84f14795b199bd5f897a439e59dd517ecf06cb5ac99582905abfbf0e09c4f0ec8bd46971ae4d48342cfff33a9f4be003e233885b9e1ff6e186ed8fee63154b16c671ca1ad945ced01b129087d6a3b0f36ea280daf51223ff5fa27aacc075b7e2ba627daa38b61249258894188828ce6abe5de8cb1995d0262f1a20781f33a9e695fa1ca820c3c44c6e74","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
