<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f5085f0a0c01fd27d51a437d05036efa1de31bab8ee291bb3b05c4dc59d539aff6c032825afa99a7941dc058838a98e30be1fb47718c4ae476fe725524c799f70d54c8ab753aa605dd8a1afd49650b036559d836881ba5a5a9eb36c440f799f8f4d449791ca9ffc871f29c0009d02a5b8d7bfb2b13ee0cbbfc179170911496c62e9ce77a467b96851db179b6d09274cc2f33bbd69b5a071cf91a26ef5392365bcc7de40490e1e440e50b5f37b61bfecb6f298643f805e2b7dbd8e2e52a5925a61c8b9cf8791af9bcda6aa4c1a164d7c430fc422f6f27f30a408cd68dcfbdef488aded45d8fa1fdea711f72ae9e2a7a6cd288d0e65048c1ac5095ebb97834f72fe879c5c4ca1cafd4957b040f5663b426f38d945c3cc7e12bb9c6ac0f15f874b7e4575509ac10dcf296c72014131ed19b867a21da648476160f046c2789e45d0cd4c30f1708b930ddf9793eb0de5368ec2c50552b0907f2dd694cee4cf4fbd480fd834ce03381979c2df5bb8cb0865e41520f4d3b409cddf89a803c1916ff0a4395d6bdad0b9a30cd2bd010bc7efb75d74b1a756c22893d9242b46ecaa07c95caa7cc8162f0a57ed91998e4170928bef7f2d8a8d823758f21d25c728add80d269055a87860656a542867737afc36a3b44fe88fe2333670514b06ad72b54bf4ccadb63a08416135bfda3112fe8b4ff96d8907e31cbd931edbf17f74cd0fac0eb163ccc919f26851d4e3ac1a10e96a9283adc85a6e3485c905cffb6afff5a8d00e62d00a3baf08748d355428977f6a64d021d956b4536652e909e1f5dcb945ab7460414f4dcf285326d7f7f651b1fe998fb84e96718503bc25772c5a83042f6e2db3944f2b4f6caa24b1a0b332af6c5e764dc3ed517dc6048ac870d06f4548ca722307c9318e0872bdd6ce3b7f2c17b6a36a4ac3fe6104f2ea85678b2d412b17aeb2e2b99fb037c140dc22449ab02d854db9d2108bdec0a67c7a945e2b50baccbd3311336a66910ec82dc2cca22957aef9ec53c8d8571de6146c73ba88b03229b73bd1eced8ca5f415c488a2589d5cbbaedf6e32484b3840ac524ea36202b88ebf114eb951aafbb4d8da85d5e66b75e7a40cdfa0851a3431eeddd9a4c5136bb9af4fcf5430c98db43e2ade642fdd573d2e66f5406c54b145150fec538d8f60535ce9b36b478d62a53a9ab6965284e9470bf436938f5622d562ea42cabea6f1648407231dc5b6ddd724150bd826d317abac6b4af844a8f506ffa1ab84f90fed0ba55e80ee86910506feb45f6fef81ed8b0e8ae84c09abcd904113b2f4e11642c8fde9005af8130ecc99880c6ec8019652a7833ddb253be4b7f42b2f7c38734a527bd24b7951e3b9d1216b1ff9ef681a7aa8e5a8d12d747006b9f076a0434b965bbac17c3464f31e0010ef4db1de26d777bff4c7f6a610ea18c20fb8dff0f100ecbcd77fa4db4d427ca135e8c5c5459658bddec9e4ea909172a820843880da35e9823037de9b6eeafe9b7928eefe1c616f4dabe86382500e1b935d3b1f444c24e9d7e6a99b5bbb35df6b111c653210bcc4851b0227164c728cc813fd1f4cc7f75daf53048afb00aa437e930977bdfb398409459b01817e4fc9d6e107ff473f902f094a7dba24f9b9a618341059024e1972f15e6c16491cdb651bd3276aef9f5da93d1291d68485f9c06846d26c780b61c5c6c9756b0115f5b574fecd66e6122fc83579bda4e3e164fa9274bafaa80714f2c656889620fa3a2eeb3a8a7fbfb4cbdf2df15cb63439904c53a7da31407f5dae95cf5229505a835f88f6e8a94504fc86248d7dc8096671e8c07001a3d40784cd332cca021cfc2dfdfe9488b982ce8d0ef10cd4fffb4b0ae40ad50228d829c026df9e8991f1b84de66a1d6d0b195a1bb25237cdba9030ae64dad6052645f904146b09bc1795c93881964a6560de8dddb8d27fdb71b93c00c2ebcb540ca4b24c4c45fba8b62bd4197182aa21d3628623417f643480c1952c1845ce8cade74158335d79899d3e7cf1ae7599522cb5be16dab668a96edc7019ab0f1b82ac83c87e4ef1f5e88134dd3ed17ec2403500a45d1ae63c7d4c966c0371899d094eca4fa9fe3df4d56ed561dcd0be63fc36452b820c1e652122c6da3f9e60341f1dc10e4613c81ccdd0345eb1044737d945cdeeb95fd316d61098a3b32504a2e9f9ebf9b2f1d09ff00c091b43e90fb83e262ce4b4362ec64d5dbcea6a480ae09fc372af2003b9267e524f83de5cca1cabc391c239d75800e528745ff26a28b103e4709bf0ba9c4ece172677a1d4a5aa41efa9b7f96a264cfc89208eb379cd231c9ca936bbfa79939b1e98617abc13aa9b919356c5ccac964ee2f400d0f0f777e30cbcaace85ce64ccb5c52681005cda31edaefbd9153becd38341268529d0e114f2565fbd4a9a7bece21f4638ad876efbd02695748fe4c4c284ac33f7a57ac00153204b336f7166b2f76d415d5ca6a7f85c772130fdb03b85e85b0c8ef7830cdac76a2f0351686e9ce47522e39a816e4e4757f2f8e5825112a5f32a994d019e9153cb7ad417a9a378f9d7c92c32f5a2d78c37aa2d8815fdd69dbf3b7764ce4d312a8e56368c5d97a3010e9692bc7d66af38910954a524afd8a74f8035fe392bd0d6f3d7adb07a7ec8673c8009decca20c0954fe5856b4b809721dba68b63e3180533a78aba09b375714d2904675ae0d34508b539e2dfdc754fb2da0d3d7a39c37928d644b205869aae71c1b2c61bfba6bb3b0f4c26c388f51343156da1db05d7e3f39481788f470adee240dd9c3d67f93064e68bb8a96e059e89fe5b70a0763c3d859e1ce9f6da30e9cfa63c22dee3527ff4dd9362a205d31e3de63073e00218c8c5b7c6c5a6e15f38cd1721167785b4205a5554e64151ef0ba53e2c098e5190473a293c64d3454a30a7411880bc987121faa25e552dc750c25da6cff0084aa04fccaf8b8caa401b36a2130c910d58cfb9928a0a9c443cafdec88fb517de1e247bb01b2f028fd6dfc5619cdc6d793edf1101eac807ea60de8b65170d43c5c0529898182231ae9d4c9f0cec641af25ca9d829afc510e0d3f5594f951632bab6dcce3437d3dbc23616c8df79561d28563d7cba5e4d1af48ca604fb4e7b75536f4dfca3ac591d8e7c6154ad812da34073a0b348106986c0e801baeca61a32e1ebd8074a7f97b45a0c4052f1ce8f497de05ab8cf810c698f4e4d5a846c74b0b795215dc16e98ba85d6348c8e67ece03219f8e89d2c7c60f938b8bc9cf32e2ab56aacb0d50f75d61aa3d18521b1edf30d2f1f35767979970287bbb3a8c279d04dacdaa0d6a6dac6faf341288f385c742dc27767a848e6016ad2c1ec8ad50d020958efeb9a79c249c22f866f8aed8822b50715a11b37d466e05305469ae61ab6e85f05463a013985d624d3fdd7ad5b6abebca09f79075ab102069ab15f2edbfeefe82196823bf24f1e495ff18a9296850a3cb7828b8abe95629e4c5481919b4bfe88966df14da13743eb92c77415dec69acf99597965081005948b009030f9c9aa1110ca55b4d8944693d9f3a089cfa1e78492482d04a15e863466d40e01072916e2d33f7e9d9f11001fde0f4ebbc23efdc98ad1345bbf6c6804ce80c37c53b396517fcb1779f28c51ad1abe6a584b4fbf175fbbd8ae4cdcf8574c44ac3e8187a64a20746d7d5dab0c753f79dc83ce2570a5942c8acac06754fb2ffadcd686a75bd3e6fc8887950984b5f74345a5cde4b00a25872dc6851a218199edda16c3b6ea4eb081f527b2777be963c3c6951c51a052572cad0aca294b991903f625f4627c0bfff07a1efd02823afdbb7996b1d583c2d583c08a7ca6a792a4724854efd3921d102c9ffc673ebac9ceeff5030c4b7cdd01000f0769f1c4304ef693b4f772fafe14a38b652edf36c773784efd72797e4b23efe5e4291798856d6911d2e279247f6e8c4410237ad086ecc50e0c27ab34a2688df4d22c378008470cad0a1437e772455a271db7ff2321347144ba992ba72fc51fb9d05e66728aefa0d348bcf6d2486d207fe9b7a05c8789675b24317e7fba314d840dd2cd27274ad7dd8ac2b7e527db4ecdae338f78abb5dbfdae467bf347960b61f955282bbca5f87d2d71b04f996b3e52e311b7c783de30c6c2c721ac3f0efe7f3827934ad999ed32350447db42e74d2b3f943a2db3d9c0177e46badc5d62c41ec8fdaf27b2d683f2bfe21256bce6de8223ae12fa432a7a32a0a2079078fdc8157d16e4280ba1d9a8248ebed71cbc21f4e44e842a9158055b70aeb4fd4eb68b8fba282805eedb4555b85bc5b6c983f333282d90b0109e4db99bd1516bcb02e21fc6fbac1ee7e32fd49f056c63590c8a9403f8bbf0859d8ae7fc5db4729398f7a8b65a85a6215612c1a7184cab232af50c1a324e8f5594d235b68af6522e5d821b52fdae39cf5d4fe76d2dada0388c093e3eabaa19f466177b0c8df14fb357fbf8a3bdb26db31536b87584762ae18c314ecdade1bf9b1d51eba61464b5ec7a57ee7da215b42cc8f69d24280fda8da361e6393f3470c5cda9d7d8d52203e1bc8ff8c37c13706ac43250ff8e65974e1c0972338e3cd2c9807800462780df06dd95921203482a3edaea4af827f42be219d880f585dcb1515f854e54b49bb03fddd01f8e86910a461bccf67a9e0ab7f591b42414227f8a5b276df74290fff63df2813ae96c054d72a370c2f7bbb8b9b2a7841783fbccbd91b5f6833665f9590f59beb5e08eaebe602287fc29c1fa604c4a21b356bd33a486bbb4d075a60d4e86434d359fa72cd8b1660fe9c42a68358d2e293e135a24cdd70cae78bb2ad70a4dcc71c5cb6222d5f031f20edc1e75d952064c8bde73b36ba6ba1248b163532c5d00a3389d0e6f6f90fbdfc6d301522382171519f7a6596ec1132a117a98ff70ac49516793cc3d7cccf7ed2fc0c05960f270eac0b4c5c995bf0b7bf4029ebb108b6ef132ff98a555873e54a75ba3ff685a4bfc8b9a94ec10ac748bcb4ff70239f41c2fa4f2bcc39bf71b4355bb831ccb2134ed0cdf4158dc971a60c79ed88528ee14b6697bece2604885771864082e7bb9b15366df76d3736b66a2cfe062b743bd19b65f074ce70bfb50c1d0710c0cd521c8ebf265b4c688a1a90560b8278a8476be956bbdfca225810259a2c12e547e7de94d1efb7d87d658952bba4a918c95cc8e60b3796fea74810ea9dd8ed913a5274eb9a14071fb0524d89cbfc2a63be7ef6667045a3473fc054ebb7b6dfa8e1769ca262b6cab70dd66acfcdf32570ba66f14a74999d39fda25a334a9e0fc2699b0c57030b641ace5de4a1d9bd0e5d53cd2c3ca9e37d89fce9d398153532c5ca9cb790b8ac5da88d0f8227510a0e3e60f09f1080254e201c473198c262ee08e567de43c97538e45fa65530bd2c549e18052d3f96eccbb46fadc671c56c5542498c9815d5e3468f405c2ea322927eeb590e85a2364ff276abf60232173af40ba6c6a27fdce11a0f4a589a94159814df0e54aa8e06ec9c55016e705932b859db96af61c12a6c042aa387784000b3050b105359e64ce8800bb9dae89d15ea137649b730f6bf0b2b74a254ab0561d19e867437ce0c2072066b378f4ef6ef8daf6e9d1c7a13abf53136b8fe51b28b8a4355f081b1e8a5302c3827d4b3f3fef2b1cda148e1f22279dff1c5522293cdb93de21c10b6caab4a5a8b9717fc5dbaece45ad07235038316355d58a1f804f966e341f796dd48ebc26b7102748aa9f4bfffd74cb5b20a150e9eb259ef278ef30f3a90f2d6093f073bc42e84e14097b6d8dbfb6949b3f7458def02cd573263db6fe1b04ab3de38108397f4ca692ea4ae95cb509d26d7479d7e0a79b9984ccdeabb1dca1fda481f66bddfc2e6586a82da66f1f6a1617a7170ae099b00fe305525fdba74e5b3380be3845f66c168b0c055e1fc31a67a50d8ff909d38091cd3289af5e8cd53d4e572dadbbd0e90b820523ddd56b88c744b58afc5f8f5ebae750e920929679a0e03787475db537742ff783aa1fee539a0c336bfa3aa76f7e9b921e97e29aa2bfa9ab504cdb8b9665bd31addc6a4e0b3832f3b033ab284fca5ca18ec1fa737ee517fab85e455538862666832b9871e61dd552b2d47199d28940f8e1818b32d5f66847cdccca3d9fac9599d8eda83ca807548e346211462d540bc6a382911b8c5c3f2be9f2a614280491153c6a765cd2afd13fc643a95b762a7366f13463b9c8b6ec2a857e1051f485aa3d6ba213e1a637e9a3116c6b676dc15e3ef7c6cc193c69e0bdca24a06f6cc4a2f91666c83801e359867b7267c4c42eeafe4eb39e3597bba16716038f21eb173fe38287910063a9690d23ac996ffdf86b7b897820b85affaa1c280cc0643c415625b1e1e38203c7f6fae02b64803e139cf1bf419eb2dfac11ec5f0654ae1e17f13ac02ed2f50183eab1acc9a6249e8e8e581c1a787d61ca6f89cd94fa486a69393990637444ccf143ca4b68e3eaaa735a4ce12c3ced737e7e0433a91a9b0be80909d47fcaaf5b36bfcdeb4656a0362dbc82154bddad52efa03252928b42014ee614181fc16092b13f6ad8545cb40cbdf7cb80edc19cd33757d53a3a4efbc07fda0858c9194390eac6fc2421a838a2fc21a4d25cf08bfcb80f49556991e039f3f786adb4c28212e57bab95f47587aa30b08190510eaa638a0678f3858baca7fa44d713f6c5008f4149c5c69563a951c1d17551987da35e4caa89e2da4a4cdec0fb2a242b62e6893d4aa52f8a23e97cb7cdd0762561c6c14102a9060639f60c1cdcb8a47dc7eadc64bf63b1bd2795415d9ba0d56b749189a6e7ecf1e2bc6d67d9e52cf4b1939930191a98fd3f8ea2b7588fb9d35797fcd957f60bfca8f0e8143f032d67e1caf7a54ff25d985fd0df1aab1c38abe56b9d70b74709b8d90a05da354fb1ec83721a347f9007cd23961822cb5834a6d2ca8d2215bef5a2f1de75a38c4d0abb55d464e530f78ac21217be43b7daaa85219c311debed0be555797993c7d6b82b43024f095ea6e6d417d575971554f21420afa77eda9e88486bc3ca91263c5345eb8103354c9bfe3e4ebaefcd9b1638ec20aa5538e1c19ca7651b58aecf7eeee3874128d81594ddad24ec7846c74850140513140d3090b2a5b44a1a1ff7a9ff002e5dc501e022c6b04559a8942cf6681f76a18b0531be8c21ec226240f7e2e73c352fcdae22d792e7c7a51015982a90c8d439b59d5aad4f2b4bc132c4928eac9dbdd38936806819cf2e27512b6fd7340dcb97587540d731e1da3370bc43eba8fe6d3b353d7f7dd42af15ea26b7f539afc754660c75839557c233b803ee08b0407d48ba4c3f347a09543e7c5ff5ea40f5c56f3d553e60c769ac5dbcc6770c78dcc3f49fff1be55e0669c0cc686d2bbb13772da402f148c519a403849b08deea1f30cbe5c3b366d7b931214f90d7a5dd7313ea4477aa4c6164d499360796a4a58d7e701848750bc9dc381580bad39d37893adde58586797996a74f5771155f24f93dfcd425df621384bf4a70ce9de9b06fc49ac1cf94c2d25837e93f28199e4b1606dd7c2570da90c9c5bd1fabd1e2faf7e59e4c4bb7aa100eb90deb68646759e91e25b87c999b1a510c6a98b73b38b9936c0ce38f54d77598c0f3a0e21a4e4b833630f14cd3b279032fa02bb03ccd46a21cfeae86f5f58e28d21700ab1d902717132cad87d51419ee3ec599b8c7b7d78292da1fd5dd8ad59fd43a44aaed16f628eed16b6e1cc711f56115483bfa0b345b82c37cb35ef93b5e2a608a45f71ba349a92f915e19d028cfbd952ae15e0db57a6c4f5ad6e2b1536921ed259b90316a4a50f47e1a9cce8b162377c2f195a097a15e52aefb5258c2b6b9a5768134afe5e206a184a2788433d745697b005e573f1196951460141d9aa981cbeb7624a5b277da882c8eee7f1cde3efe00a1ef7255125ed4c35abd8a00aa020fc1a86ad6d0c50534da181e2e2406d1097227a943f6ad0f69672e48bff64fa418f4263b97de3bbf838eb0a5665748863e00a0bc205e681f8a6245d165f0cefcdb7a0bada899d7d4a7eb098b09b6841599955bcc73793985c6141c32fdbdddec067515673ef9ad9cd84827bc22f85cb8d44be57b698c271d0777e3dd83f87288c2dc8fdeb4504624ad0a70a277e4b03d2a9144acea1c80cdb00e29d0734aa725d9364e17b96d6df81a8b0c506d10444b8732fbad928941a626d2ed662da653ad50348b25edda3b3c958c40a0c999d180957a931773ef98204b07d677b6338a91a37832826156f8676f1979dc114e89bf80255f6dc509fcb5ac17259699c56ae0b0e8ab63b79ba0331d84c2640ca7640b09479c78a41123d7d98eb96df54221ba39b35c022cf553f19c54af76b90007d5b360bc3eb14dfe10de147450b4e39718b3387f2668e2d12682f0a35244ddf8869a909b54a840efe425a20eb16378c829c84890466e45184d5f66ae823ce8d8910822471eea2e92df1ca9ed24f75b30eb576886f849ef6c625d4ba26f37123f65d99b963dfdc828e891224ab1da7d0a408a21571e5bc9e44959d81359251a83a2e1c35c91ceab80a5fec4343a323a953db3d42eed45057d8917aeb2731e22322b6e9d828450fada0f4d8887e6bbf78ec37b824ed9b032f14ca0e02f8cde79c5cdeaf143364340aad6ddcecd93223cf9e84a3908d12f4745e9a7225911413054eba52d02bfb4876f77d23576f1bfc36c8b0e6cf345edb68b2279026732d3e5c2371804314c94d6c6c256a9554204e7ff2accd05c60ed8be08f9044a7748d1c9056252cf3bf39b31fbea69fb378059113c93dac4ed9f539b7882a60d48028ebc57b2c8025fa4db9546a1b10e65ab61c5def03e7549bbd502624389ed9e5ab62e3a558999875035fb4342b8f165d61dc10b741e3f6ac1cdacc867e944acb2e47a1776722edacbd396c82ea923350684514f2bbcdbf4c82f88a7da3ee723deb551ad8a54625c7e2276b10e8d248c768c4de6e7a984e7a73f5fdffa2593b09667740d146f0f1cad9da2fe872d721d3a97192fe4105ccbf3a2e270c87d223563ac58e7229b3bba5c71ec1ab025cc4da70cd96936d3a93540d8c35e879a993e8808dc44140ebbd36fdbc9f22c410d3b8127e9d4fcacd6fc8ffb95d12275f2c77e1d3517e1c85f38ed0e3b8589eb564cd18f27b9e0f8b3f2c2f3b4b8f870ebe816d1972ab4fa016a4c24a542ef724a1c60d4adeadc71ed03556714c253f377f7bf184385dfb4cca0d80e658bd984dac5361fffea3cd4b9ec47aab6cec891b4da3bcfa5b64744eac3810084b049d352d6237a86cf9be7f1f501b84a9c3e51772858950cb8b011fc3be0fcdb0202e6a222acfe59df7ef520793f146184feafc552eb3d126a78bb75320d1f26da9006e21a2d3633ea1ccbf9c6970a2a28eb5ee56c947ef9e64889d5cfcc855a4694d97974485ede3f72679d9a6dd936041c45b59d9b559ee7c809dcec018ad567c4d21f2b81c889a53b7ded09621cf2b9c3b6801a7864b49364422f401b650ee04b5685555a9f576dfc9ca6e0242291eb580ee8a7d79959cf9f85f05ea2e564ec606852ccb367d17bed775e9b178db90b0a3d3f3ea63a51a0e06aaf4b30dc40206bc1de47ac115d979fa681655f838e907d0462f515f915743e2648ad6c7874cbaece41957da613a546b70fae11b62514da86edb7e40a98b1f4d8e142c36c7fec8170c1d819c0a639f1a484bc6599e7c1894532f51436a45ecf4e010975a2dbb15bf85ce01abb31e2e562c53c4f5da0e99757d2a91f0b5ea5ef246d4ae4e5380d05a2116902ebf01d76a7d1fbd49ad122e4d6536d99042f61a5e099f9cd850faa6ce9b88a62044b5d337b3682eb3cc6ea486bfc7f1e6c218d99a87e7184fe01f2aa2acd6a7ee16b3afa496ac419a0ab2fb116f2dde465652980da97c0ac0008d1e9815f22d74689b488172618ce219216f9348d78b49c022effdf95e6ae24dd9fe1d642497394c306d18383ad11ab4146bd6af2a220d35fbb32cfb0a3cc4234ee92fee093cc3a6e9e7128993df0b884a15a1de7e878d209fac70cdbacc41da2114f2016af467875dbb21a23a27a1e3861a8ff72201126470a08103808a9c6e0c20e12922f8d5f759f02e90ab90b60adc5b3cdb93b522489ba6b16c68a1b5eff58262916792d7b943cdd7335ac775bfe2dbab215ecc36edafb44ae2853a9f3973a84779a9fda2107d90aee4e1a3fda56d1a5a81bbda0e9987bdf5467240820cd66913c8242e8ee038ff11ced931c7e5b05ac6aa3fee46b983a39cc4f54dac5a89105cbfa69c14b489a08797e2715d6a3029adde8bbf2c079968e62af781f64365a3bec9c742adfc20b176799894797032c982835164730e85e669ba980b187724642ebcca88ccf87653d18ce851517ed3cddda60b7b48c558c374eabc3b2ada7df5d46ee061434ac63a3b001668a1f093633b510da621a3ca2202d9b04b087cacac5b8903ad940fbb54cc790af6b60ffe4b10a9b02101f7584efcd74c8e267af2202b10a76e3d033d7c1e005642dc5c9af86a67de4a23a57b97894a97c5fde1329a9967e855f4f1c6bf2e1ec0146606623dc866a9ea8199cd04a0c71fa4b7bfcfd09b1b7fa867733730fffb6db39cbc22947111db7b0635fd07d7a8ae7934524aa158d66415bfbb36979820deceaff0e0f39ecc774efa3bd919d447d99fbeb67831d10c00e8bfd33c03374b676d93cf23788f9c4f40ef4bfc097459b730f495054c127b760a38306a40fc2803910b37bb593711af59c4036d3244b7fc734bf6d30aba89c9aa3ca91f21038529ef8050d3d9b2b79e7b585a501d4a3157446cab980d65ee4fc1a445390fc2fe6a54f97c85b0ab36421ed16dab64b1f443b6873cb1734ea3e9f4f7431909d6e7dbebbea48d241dca26c67c2cec6c786a33707c6a6c5255daa98041f668ec18358c1c71ac95045154a4b590ff7f3318266c0974fc76b4cec8dc2af9cf56f86ff99a79b69ccd8c9f5b9766439fa6fa3f897406478b7781cb44ae68d4efc7e3f5df1de2a3472de8b8082a0963f0d390f747ccd22d1457a0015bbe2b616fe799f03b7b51681d38a282094808a0645348f9688372d4d2d1645b140ef55aad27d6c6b721fe341939f0f3c168cb8e929ba79984f1259849d414c2fddb837f62f9b96d25f00e9b156307c41d72fd979f979b4cb860746f6b5f17f772717a3b6ce36f2f2278cc9614b36d71d80ab342bf26d12f3d98d405a6ec76d90aae87e15ace7a68f6625bed90f3f3025fbd6390cab7250f4ba1f6065252fe86140e2bd8cc32d53c4150edc27681c153b2eaad7d9c36779842d2e0aee29c36e5ffdbecbf871be2f513535159b9d748b30280c3f62c4843563b78c490abd5609e2eee27b153dd0ea03abbb3c01361c7c446d8182b363006b5e34598450fbeadc4cf25a0da05d8caf146741877ba1471961037e26546f7932f2102ac58432f0f55ec23b696ceea748f4f4d727efc82386e9d370eebf7c0054dd96f2cd11a5b5d8f5a83032ead4bedaf8fabafc844c2418c021fcbc2b3e7f26a6856b2f632beb8ec708f9126b23fff53eb1585d3fa3f3a27eab48e780416e9ca15914a0c8c118a0b1a57fe6f164683ded73a7df846540c9d73bc9121ef2b9a28ac19008c410a32bd9e18a534f1a4b2db6b3825e744c2dcd54989fa57e46425859aa30f4eb693b8abff6cb74aa347578ff389f276fc5858dfdbb65f4ca72370ab742dd6c48540d564be4fe1c5af1dc74f959a643c8f70221e8f62fcc5da6a147378bcc4fba8fcdeae3fe7ed2fa4d8c7129c02b1808eee26c0d1500eb0120b8ad61dfbb494d4ac2fdd95640247e67363b624463eac5711051d07235cb44f6784e58cc0cdae6566444f633adbd03059a219ecef6196fe7149d8c98303c75b283c7e93d832e9ca59e3563a5d5e3d992969db02fdec05b6a5ab3d51037601b6f733d27f54f9bf1f6d159ee7e10c54b1e6f0ffa3a7697668dc151048107561cc4e43f6dd06886b762d8b843462001387dbf86f7327562b2b40bbd93b7dc2f24393afe202ddfe47eea1c9d650e2a0de996259a4655a10e0171b05b43ba3bd9c00ccd9f2dbb0f4175a8202b5091ed899c5e8a061b343afaeb237530c843d5fc628bd5ff9f03d52f155f1a21e13c8445eb0dbc51c91364183f86a6a5852b94d3c8cf9355ee636d4633d08b97849b2317a44aeb206bdb2964afb3973d8f30d2aeec2f8e4f98878209f2ba27b655ce591d7603b09a98139a235a1784d83fc5959811b6664f9831f42efb63e4aafa0264cba3aac33603ae29781c791b67ecb7e8ce024f3392a7701ed1320e4953aac2554b80584decb913cb1916232b8eb9eee6b752a3d2009392710108139f092f0648140e39c4bd969ed28a902534024d629968b56b5ffdc73f1452e8d75bebedba9d336426206ecd0baeff33951e435f7c943c0ea94c4c0dcbb254fed33a172a27588a09dce40c3f270e1d959df575017ba68a6f63b697c7dad9ba60c734d0886e90a6b81bdac8345812d0d79da918b663afaae30a3eead4f93a05fb33a6042e8dd7b5e4930cddaef5ba9357f4e75847436923f61e970f169c202c8c5f3d4055ac82a2385fd343362f8181f7c50a436b835e957d7fd306011b3a7ac82723ad8043ae7428797aa7f81ed90ad129e67aa1f473a03b02d8eda83ee854f249a118497a6d11eedec0845fe7047a89a05ccd44fd3c70d5cc7ef08b3afe19d318dc1adb204ec7707735017cab7011714f4fccbbb548b4fa038ee5d3b9a8e79b40e6ca23afc7e1836080a0d2fd89b3c36ed9942fb13b6caa591234cef38b4d9f63d96342b525ebca55be7b75c4285c7aaf5a2670cb76ec93c4ca6685d7f79341329f829ce5d905eb6117409a18d1db310b41e573b93295a348cc6783c8ec0fc3a60c9bf6e848cc9872e8ddfce9fee0b4d1ce51be40939544a09bd994730aa915f67160dff7b70d339e19e035bcdf6c22be4862f7919d02b6ea364f45f81d7fb7c7b83c749031e07ed517bf3d6c0e1fa02b0298cd8f7f69bed4db2cf48702d218a05984a6119ead372cb4f4588360c13fc1ddf5562a23962622a82c1f326c3aea658ee3fb974ad9c92ab9d65a7b0049110bc177230ce672ca313e769d48848e13dcd756d129630cd49898b305047e41cd1cc669ec0428a961196eca0650b2b483cdc98fd18e2ae13d097dac6efebe851f3f66d0e401b15e4814b71231ae379e1ddbfe4877271fa1e593f80c73e5c73178206e4160aa74d93918e278ff5f8c51917fffc519592affa9ce0bc51d1f38f080160ede5ee1b2d3793c88c1f3698f25ea8f89006d356771856bf512206665fb030ad4f8dd73f4665826428cbfc2ee1b73d98bedaae105e98a7a53abf74b57ce4ef0e778b1a95cff638fdbdc4dcdfa96a7955a9a811fe6828c20d22046de0163d46561b1c0fca20b1e870dc4aaa8c1a76c919d25f6e370f9f104406a3d5996918049ab5eee21ca751b81cf38fe58ce9d336d9d0df5a937d27677c78af02ca565473071cb3843ce44e2e83f0e68c33b9ef7b2031f64f66d11ca8588f3c5a0d0a744c09d4ca8f10496f7c798b5f013d501ba8679f91e6ffb2cda2d194c5d700d9ea2e2867fa59c122fbbc0447faf027a72a1fc4e93e505dcd8ef83ffb170809a7cba21a357aac960b50a8853f0074e23acdf61e3e8c3ba0da8df0b9b269f38463083660c09502641d6b65d785881e5500ee43e54d9918225eec419a9bd2fa9497908efb368d680efab4d498a0c49a45b1c25dcd2782c0d810fbb9de894378eee5df6d60d7b338562e3398c179da0ea7fcd71d8b0eb04d6c2a1630f6a3517e527e9b248efe01574f001fe046e479c5c81a54cf5240e720ed3ba16f7f50d588d5788be96e98b01608b6492b4de22c89cd17195e56b05b9f326e0438cd7ddb8f913f9b963048105e54004204d9c43e009bbf2ff7ce043225f5dd9fc6ef1e7188c58830acf45d048ec97366d50ad6de494d79e3a93cec7a791e35d03bb521afe594a249e850e59ae958d15da3c7771ac1355168def77bb2c38c9d4c6f2521563d4c14e8bb095541a10b94877cde3dbbf8130979af36e7f305361b0d0cd4da1330ae40e8bff1587766e8d8e072c0e0cd0770051934d153c980b87b7924527dc4b8f7f483feebcd03bc3027906d6a1b057df06baa3b0efca9142ca05a44ad3ab5c29257b4b39e9b5fdf11f1f8aaf2a9248c45c84b25dd88291e6c91136b213ff87c19f5a8c613709dc63f7ceaa5c97bf2d77ae06d5d6dd3b502b24ae7e25776bc98634c0e24bf9247452a3ac4471fc2dc25df605de0086d2669e28f96be55daa521e68fbeacbf2695f4eb19002ae338eac68f79a8c7b9959394c8718649ec4763b3e0280d9f3372d80a5290f402a85603784fb130d327e39dd2e9dfc031d461c3043490b81d8fe5b60bfbc9929d164afa1c3ddeb1af07202100b03d5cef262fc71553fe2ca1835690e93a9af9d21007526421eb0bbeea4c38ac393d7c9ffdcf7a9cd1fd9f9205cc7d5f831d42f7e6e75ba72616c425eed2b5cbfffa3ddce890263eb87fe16b651ab1db1f976099559450447ce1a408c274ef5109eb92cfc64cb0317758aba234ba1119bff3c55292626f4f596565b0d55fdb82f1ddb106c0d113494543de0862f54d5bfe6a3f938c01ea10dcda38b596c317d242fd0a8227698443c1a6d0dc1ce88106eae7871d662bb72b6f081d6273562e7cbef4ce9812127a10f16b282348be4e621cd17b68bb07a15cdf48126ee0a2cda4f2c0a79d329678a93d8e5d09dd33fb516d859fe6f6b3e078907185e17f2fffd93ff3bb50d5f5b394091a31fab51f44469d59c692f955e97bca82650c0ac89eafc3e38b888361ac3198de3119db668b26dcb7eb7fddc3b68eafdddffeffde5790728fb57af07be3073c3b446105c472fcb3e54eacab4540238347bb0de304131427e20897aa0c28335d790ab8eb92dbaa0f0b4bbf51fbc9e11a484ea723d8b2c38613f09a8ffefaaa04b8f6e8f0c8d0674b6eba530f527d054859c105677b914eb01c0cbc77e0c59db96db7aa04ebd109d76d9b2193407e904a804fc1e13e220f8a4996e4ad593b8b8a1b00effc5bffa274f0a39de3a8e6a25d290937ea07c6639b2cd7a69c103717bb1ba14ee0a51f227fe54423cd9fbdf1586072b6aa43dcb47db1f6e447783f9daf58b97919fcb593a54d6ce168f628eed437803ca93c02781a64093e9aac190b2f3f4d97d7800ee33172841cf9b63e1c9d351be0dfe0d29a9cbd73d5c0067039d9fa094301b3b6628169ff4f783d4a9afc30510e3b4cda105b1bd59c579dff3fabe5d44de28515e645a485cbdbc17333c09a3ff45348f2ac8b48c696ff42fc08484bfc6fb2238eecddaf60c71e5033c48d27d341d7a57e6006c9bf463c2f14e6a093fb6d0f10490cbf67ee99d30c94b6deca7bbafd0cb25b02461e5eb38810335842df9362bbce249efc66dccc601c4694f8a8fb33588282b5e75a671dab641f62e22e918db1e6a0eda758e3b98cb92e355d573c5bd3a03af1233004eb935be1cfba5f96c5f61731a8c099dca66d5249089d03e1129e452eac3d26cd472bf07f1b2d698dc8826b2dceef5f2e34a9b69a4bda62dc43804b3439847c7df043d05762195c6f36b728b8acec69d08dced0db64d6497936a2430a5254f8be613c2d5271ec121ce4b45ba5626c73e900e96d57d0e47c5503d5ce6556efae87e8245b873a18c09203c15ce2c2397a7c8aab44c67744cb0b2cb69efee26d506709b40e3b8369baa1810e330843dccee7981822af622c8fc6d6b69de6b8c33a63c7602b82e0c68bc30082fa725d33afd8e135c7c2a0ab3d31abdc5a0c1e33def2ea8dfc4b51f03ebfc0c13434f3c58559912880de9f4f843d5113c5e3cd9260efcd250cb6dfa2ada54b6f5345149c2294dcf85269cd7178203e4b89d172da88b32691df68c68519026abd84534abf2952216efed2e4e7b71dd65d956e25f0331f78db454ea15c0fc85d12a4c7ab1f0bf4e687b8a58740017c93172e2aeba847bb9427a444730bcab88e144bd88c7d3f217bd385ba5ed9df36f6af29cfa1fbd31c16770a6a371dbf876be99f487d6df5ea53942983f27143b73e30f4426f5e334424160cc9ce53dee316c11deb2570e336ff3f3adff16261753e207b174a8a0fbf70bf8ca067bfca9a024a909c155c2636f805ee2fb86ccc29a5a0ccb129b33206c00229a320d9f7cef097e7d8d2732a114732424beb750e3cfbc326efaff44cb5183c58dcaf15826e9313ac44ce8aa46a0688b70dda505e2e7df437dc4b2aaa6c2bf7c3d16e32f23e2298205307f0f9481a29fd04ebd15362c78638e1304e686461a01937152251140fd34fe170085d3388072aeab4abfb64756437dbf8775d7a73f88e8f7c8d9bb7624eba8ceb081f156b48fab78fc3cfb93cc3c0ed40fc77dde5fd9dc417dbf9dfdb751e8884e02d36472688fce4f36f65df6abd8b2cca7c8f89601343517f84b9132ab65bb9468db36ac3c763a1335d8da44d2b11e8c11320519d4b4375697ce6bd409dc579778eaf4673eff9f1dfb649a0f2e9ac905d7896f8c2b74d0aaeadb92ec3c31b4b917625c18f17c7e994e4cc067df10bb22b3a1735faf16198ea4b9552813a85fbc179bdeaf0c4149b6352bffb1d43992c3793162e0facb962ef2617fc6d943161000c2e099620891d866f0c9b18a2f4268fc5f31d29f0ce6bac19d48b9e288137bc1bd897d8872e77dbddc3451dffb18ab96b5bf7dea8401b17920fd57d4fac8623194b763de12d6d3684b6fed34a86035c283149d48c35af3f868cb26e4f940e259bf21d1b273571d3beb2757e5807daa5381ea0bbf17e2c1d93b5d271762468ab23a1f215ed9494e85663944d0f119816cf588ca75eff10900952ee6ea6da184f970799c5bdbf2a0ff9fec8e37fd54455e3dba12b298476ab8acc2f9576500769ce3f8bb56b3d4a2e4cd95cc6359f47c9806ec7eee9078e8c3e72ad0734e881b8082a69f0b5bbfffdd3cc1fb700388c3d75faf50bc4e4086a9f96c3b95ec564f3f6d761e599c0ed8598a0416615461595c8aa3d9a031e7bf1d5236c01cb8cb5e2fcbbeb044131c2febd116720785c29de0c530db725ca294e7311193d8db66d2a8eead7e0d34e578d91c5edc7d1e3395808e249efffc2391b957ae211bb23da03cc2c5183ddb2569dd0eb5ac61a2f4c561b44cae48ee6572a882e5c33f6026a6d7fc6cd763521bccb490da7a65a2a8d6c34c31be258bc1ea0ab5f2bedfa4981ed6275210dc1499ef795cb541e05ef7bd75e824fad00484d3cac4352aa686c0b83bc452a1a710921ae147a1de2ceca5fd5bfeda871e17c769753cf39bafd19fe0aa3a803fd346645c837c0fcf6cf77ac277cd3ce9eef98cbd7247bce9e1883c16b38261e88bdd145d78aed263f01b623a83a7072750a627d2ec1e2ce6a842f9dce948c4505113bd44b9a275484c59f034ea050c935262f7ec76945a2d0212971263e7b4a875792d4c93d91f9aad75901853fadebbbb4e5630103fbe129e31af867fd58fcb126e7d67b839692fd3ed07c5def71ef6e2015b671476431ff34589ff76990bab4e9683175f2555d17ac6a7efa532c11f799c6e0294dffc83867518061395687d54275e20a881411e810fce2ba7ee8d2f3ed5605ec27cbc91f4a0f5f82266a712370233349c8ef589f07949a80769464c04c7064a64f106e327539aa1689b3088a24438e501960938f47364df0f0b7689eae2057d53522a4781d1dd45ed85f4b6c36f90a531c8e81c5fccc05d027673bb5cf33d11a3f82eb3093684e6d00f016c7e679c21aa5226261189b824d987c0707fd2f50185f0d374235fef619e10ac5e7fa591bd7da8af547733494cdf01621a6c8bf85af4140be83a23a13ddb234d64a35733e4ce8dc6d1a13ec9f62c5498bea76e245234895dd1d44d5750c319cb264f5029d401be45396f12b38dc3f513c4182ded9ee2c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
