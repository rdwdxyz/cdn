<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a843d012de7c605f5deaebdaa7ee39fa5dea146d2ce9146190ade1623f28507f657063a571a52d8c4b830ec8f05d4681dd90089a669bc17ee67719928531d07c7998d8966c74c75759a34012bf0c01574973fe1f6b77131ff59279ce35a5fda67c9c9e8ea24c2a68b9122ba60b6a3b0fd9269f3a307c1f0c9fc7d55e578d20e0d0ac413a880a47544ceb27bb126bb57e42bab33dc332c2fd9e6d6e676a5d87d6866d1298f011b42bfecc713046c93a11b3e153726d225266cdada833cac68c46d019ca777be4fd401fdcd20575c3fa870ee23e81cb565ffc2da75a99d1c0dab2a5c92be513ae904232bcfebfe80d4f4978dfb6f7b35b5c89194d4f91928e7d790573d6a5e5ccca33f8ae84b29037fa3b26d47d7bf0fdce088d84e40aed29b53b5502e7b12b6a7c2b47ea81fc939d1376b718062a5b135c110c2e7efe8426d277004eb84fab9a940bac08e5aa7c010711b31a0837d746f79c4484bf94a1334801e2b14115bf900535eff85d973369e2163e464e25069ab34fb7305716346a8f9c26659068cde3ce178209116a352345a134057cd5e1a41a78d39a3b4c096edbed4415b3251ed1b87c76620de37062c10c0ec3128ad7473a51d7620105055e550d5c277bdcabc50fbe29de48f5b4a9802771cd4f954c10400726d3d3a793429b792d8843022ed93b328a526614318ecdf714b3a2aa86430a5957351dde90300e9f1e3cb4ff81e32c03b9f92294f7a95da3a596076fef514d169d2afd63c725fb913a6a396b16fd3ea3738f84549e4a580dea114bc5e0523ba0ff08e86befb4619c38fb4d152c8a901d1fe1ed6ec6652df0cc813630899c8069b1f8228741541a99ecb28910565521a8f9c78f69e9b730b8b9ba0c51278d1368c28c0d6611a7510ae6df035536dbb2834d70fff9031ebf121a4c7090d6cfa47fabb936a1da3e0ef249d5fd90614f961490abaab07e1c1c34e4a9ba0f6483478adfc961c41377a8a09eacacc5f14a967e88a894301be7478c75781bcc6c1a3a9efb389a3f2dcff2229553d2f90ab51edf7eadc25439a86949adcc646f89f94cdac44c8d871ef0ee8ddad3d475ff183e50ea5517d3097aa7e1c94aa124f9c47c6c3d8dd95e8d6eee489b77dddc2a3990097e43216832b09192375541e91eb68b7bdf8397434261d689b6ef1a194a2de8eb6e2f7c72dc8108196f23dda31683eba5ef27c59680a64d5de76738bd8b8ef8af64428d52c17978913b8bdaf6f1fb0e8f589110937fe26c1d8bbdd213481375ea0517cbbb81ce6443b9fa0da2fa740403cb9d29cf9edd25fd538fcc8f9f3dd4dcb9d0a23628dee3d789a9533a06220ea6684f1a987cd9964e1938c4fb09043260f2cfa0f843f258bb9ba23d7d5a90332843f8dd9cbd260a2f1133223e7b042c0b9d83bbc8fc7a7af794bcfeec1cc0a2f14cd2c52437d23741ce49c3f574d05346b55b440ea31f4f4976653ed75cc0b1d93df771eee4be43d28ee806cc89321d29e0579f0c57c88eed6c516b675f76ca9aa1a3348b44dd7b37d9607aaaec394b19568fc2d97c24b8d3bcd5c77d4eafe863103368fabb6e15e6fce6996e82ccea3e7735848792728a25552e07699685d38bd88f83467bf3ad3a7e8f1021c1df4f299d8c5e7020635d209e80e176590386d142f345ad63667a438b837f3f80e92274004f4522cb33bff5592d8637d0679dc2ec557621eda85a1345a53adf1c7669889cca54ab259cce92e2ba86e05512a056d13b7f492f6ec47b5501116944d3465e17dc3f7bf37cd08fa4f0f70516ec1e9c46ca933fb790556a0cef33058a78ddc794507c0871485ad788724c823fbdbd53f2f9f3140804f3b96486b2b2f9605d8da120e08d7c6c0894e2c223219ec8f95e7a10979995eab3ddc2a316313fc2b9727ea5e9be0437d47b463e5b18c432ec2a1be14945215a6b1b8b2d925fa201bf63ca801fc384f7f6c05a33440971fe2347f4e838ff59ea164ff9be3716cedd99547b7f76a6f4ea21c11f08a1bf911efa57f939ff61ee4a03b2b86c42104dbdd640a5e94e71c245a7edad314b8e520f9c655761f4e09549251c196855a068810e10a252158247ec9ca97965856e6b29b7bd4b1b30ec8b75074f19457fd8b095334a819ca16f3f0fb599acc9714aa142838384a64ab96fa72d9893189bda1d27cfbefd910baf093fcc28a30d7f5aec21b042d1a9afdb9c607dfdee4156cf8a1c8872e9633c3fda89f9b7727c0c02cbdba7ced6ff04d0ec806b5de607bf48f693eb99d159ad46949737249e3f3670c51214e027df921980e0ba3ffb391e961a47710c738547807516c0d92dd6828052e4483067282104b700889f4e32f0cb4659cd25463be29b5e3aa2abdba28fffd9b33312eda713f6fc9832996da743720605519224dff75a1d0b54518c1aa42df033f6f261220cbe219e129ce7f094ce9ac45207c445a9ef97591b701a390d7e48c631b197ca73d4c08ff3f5b57c1c6fe2456535bb62186d5aead39b6b8e324525154cbfde899e9dc918cc9f308b38752104095735c130a07dbb7797f362d7547b22582fee42b63250893869c5d61751bfb6f14d1b3e406c94bb7328fd1a0bbe77cf1ce4c7d98973a580ae1a12a4133c0190357d70434edc9c6495fa0bccbd2f8ba05e3d2c5740dffda07b17dd7f520d70b9ea7c40c8f7e9ddc0cc294ba22bdf2839446392d5261750feedcbacd4366cab9dd80f2bb7751a364cb1e85e8e96c1f78c264c8146ff93317eceef127c907f4c194fcc610f1d4ff8b384a1b22906011ac54e42f138c1b7787a1453507ae9f5f04f2071ef63ec53d7fc7db52726d736c9c9a6759a67446ccdaed365322d64c3f38458fe2d6222752eedb2db44e454c03a36d8a172d9ff03f7dc4cb2eed42ddc2f42b3ca282f59da12c4ec5e38413ea900954791b2573dc6b413b9c2e8979ee60588229f83d19a7f039639f01933d857bf5d2a8e62e6bb45763b87cbe599e7788b62e1412c1bb6b0b87b56c2711a22dcd1e41a56d93f5c496c68062546ba63fcc9b108b2b6ef389ea4295c690871f4e730cd3de4bfdcf759c7b3a619bdd160331cc1d83be6923d3d52d2e147eabf6cdda61b685859f62342a90636291ffb52d254ced1cd982e617308a4c2fe148272fc226bdf04c80083e04d8126c6b14b25816dcbe3b91aa7d9effe1fa8599a6ccbd52de6f5722f432ef152e8fc3a291e4abebf084688a99f0ad59384a0a2ca5d2aa8ff9140b57301565fe081ca8e583af6f9b34c428ad535aec2355e6d5f47f4d4f257ddf526d682ce2f6c7b5efbb403afbd67f9fbe402123d96d92ed47fbfc6559df64ae0cca30e10f9ba404ba3297ea36ee45739f8fbdc36be8b5eb5dd089292b43846a95b1b692d1d727ea9c37a19d2614d7baab7c2c7dfe385c528194c855dacc34bcc75139c0041ac88a227fc9fb2c5dbf4e9b30e41126b3a8813db05546f7ced5d4eb172a604b2f6a05141c31fb88e71da768b7b4adc76598cd30ff2f41c38d4f9c0012e44c670e1e5558d42d9948faa3e2e3d13093ae6f3e0de56aa08cb8619cc7e4085c5f0a18ff616e19b2229a9261135e085a78bf7e27349691303a41aff21839784ad4786e19c5090f3518efae754d3cbfe11439e9cf3f2e4f039479687ab777561a5e340b7fe29521b3e6e4da186e12db9f0b1d64965678ceb983d68f6b49520dcfd23b72c7e998b19fde92ecc0f1e62d7a4896649478d6367dd6879b402b9e22b49eb9b38fde1db4cf9bed136adbe5fb68bdce0a1ae5bf81caac132a8e51d4b7688c1b2c25875b4bb250f1d1c1582f5a08a348271dac73d0f350515492e9a6b5d3d405fc31400555e963b94d96d309a7bfb21be0f3139e8ca0b382bfbc861f82214dd0e1d84ed331c58b4d4b7c3a7ef5d14bbad6fd65abb33ea40014dde830dd4c30529ac0a505f32ddb91c1cb633a95b5d9921989fd452b735788e6ce2a6309b2d19a248db42bd291a02ad3433d62b1f3eadc7ba1ff2c855660340d04e60c518a31fdc603d2a5ee9360d7cd7360207b425a91dcec5b0122ab8178aa8e8eb49564e985714d14c4ea09a21ce260f45820875bccf763e47542a4f39fcf45c7c290e13e5bb4dfc8822299ac13c54c97e0554b77d6d6865f9d51e697298dc99c66ec2d4fee4abb773e787a1c725d9f41a79d0a8a60cb83bc97f613a96a0cc8a9f0c821e4c949dcae2a023f2c2e05bc0fdc574f441c40f644c32dc2b69d24a8aec56f27b16af58331ec6a290b2cfc3ac2a1afa57ebdebbedef5b07e52b9d23ea3adc4fb9ac9331ead375ef10915856f128f59ce977562f2fb6843e73cb4886ff348c3bd7687156d79f69a42459cbba85a68fd7a5a11cb2db8f082f0d52b7eed8c13f53f85b03a73f1e9414e6fc377468678c77a831778c41d40fd6ca363f667c8e610bd6477725d5cc2de7e46a5805554c941d0fd5143216cedfb30f68a622fcaa85bd13a5ebf74274ff657312afae6c068dcecb37a8d9238b27844257278eeaba86bfcec3e87786ec4567c2c8ecb5c73ff1f7320a5b82b4df172872e5fc07f776261f34190ea6bbe29cd878805f81e693234db97233839020843b0ae7949785a5ab4ec86c2204d6816ba610a82fb1cc341fdb329a00da8c53172366fdf2f9c96b93680fe4edc687f6f79b5e7a8bb2a8ebd52eceb05d207783b618e6d33844af964bc9cc619c5c70220b75d37b785b3296651b78441eb0c0b36b0237f5e9686240bf881171bec3acc5d0e069ec338b93b3005a86e9953a80774cc84aed7a5ed3d80e81c357aa48b7d4976247d94858ea2ee9fbc1b564dad4d983ace6aac8b5774ccdbc56b9838b2c98bfab1103e09fb9095a5a751f73678f625976b09746041a8dfaee333e5d94c5c2b3be6d283d1beee3b2e677ea8f642763f6d83ef138a7d6c3e74ee332db2ea9fcb810a502d09ef2567ef8729b2dc008db32fe592208fc6361eb69f00025fdf90925c179f7a60fa5b4db47df8ec78d0ca39d3a124c1a7c93b17284ad40509ded78c5ccf6333b034b5c109199e236da1914124ed86848214f3d73db908dbdd615d63546b3caf6a1b2c2f6a077f99955420c24c8a714c79f4e474cc304e90087590087affdd830f7c46b3575aaeb6f73c6ccd6f60715af27f2d64ba66c010416d9f44b084c8211123ead56020c99d8fc9e0361387426d0b99346a8e2e7dfa0a2172aff90def4bd3fbd06835617a3a6987c3cde15bf1a8eeac9b3c89b6e9076323e0e285abd586ec6c0f01f05de432a45b789729c0eeb00aea880071a190b595e2abb7fe0b4576e6abcdffd1894331b18d4ec31dab8e0f459410e5ae3ded87a984cd835d719df0cf9fa2684ca27e868179d52c05ccfc9e407c1aaa6c68e40ddc0238595a6554a6559d19463e8319cb03d709cae1c6e7c96bedeb13562902cc0c79fe5a04bd4e1b9f2efe57ec413f3a9682d810e324570e44962ad9ac7873703da0e01bc8e2fc98dd44d18915a55351f28959bbe0e435a8595308df428c6b8937449e2f8bf9606f5a11bc3506e4a55d880d0538bcfd40891efbe94e329d276186fcba41e7d6380561e8b0b312f5e9dd48ed428a6f01b224b444194d606bc88504f3d3dafae88eeeb64373efb4a8ce04dc531fb22bc121cc402dd941ea4a33a7ba47359569c6d53b582aabcfdd2cad2ce81384058040192d3d431a99cfe6e5de26b2c533e6a14ea5fa6b5c27fb5fecba18d5a3ea5206fea460c0d1dad9d9052613364527b41aedf37c20529d2d475d8613376c8cbb4a32374b9bddcfe50b579c142e9926e324da27ec96f1472c0216d057c4e96f1d81085966dae90abd2d14f8e253a0070af3ea5519e07050251447fac0411d1edff22f10adfb98cdceb0cd27f5ed9cb071861f72987a9f34ca4fedbbf5c2f762c15e33329050b6529cebb2fcb696f7c6afd00d6282efa1be2ce9f913e1d56f0b71ccd8890168fdb6b7769e9e22ca552e097343773270e6849e82e792e6aac6b920aa9a3a7f9be8bdabb98924b43077b48e01ca64de9fe45283b0838062aa444e933d975fe6810650710456d58ab9a4f6ae2640caacda93dd615c757d68ba99093e8e327b99b6d037a4496aa1cabd86a1d26d1cc6d3b6f9f3e145c452e79badb555c4219721b205c51707846711edfe7ba188e5152f16d572fbe9aed3a7bb7665062e89054a3de7699352b21078f424779e3d3a604ac96021bf3d86ef92112a7b52b5eaceb671c17cea0f82b84e984a24843c40b5756985da867f98b0579fefbf23cfa80d80b7da9d9a76c8da0fd7b927f7b78dbc336548e6f83a149c0f237541c314d8440e68cabffa045e87fb03face18e3aaa4530795a705516447f45acdd255207b2d9f3058be6a326434b0166b9fc3edbfaf5e93743fca3cadf8786097ea7d6b1427f142bd12259c25efa664d0c008573eb6aa8117d6ad9a10120974fac343dfab1178642091de7220844c13f12fff4a3bbd4f7bd3352fe16e2e66eba713e14e4ca0f36e3f1669b9fb844f11b8afdef9b3a2db8fd4292db8be34e2ec93c156fa5e3a5497548ba09f374523ec1c5fad88e4e4929b31cb8156d86e08d4cd618badf532323c59b800acf389c638ef10fd43ff4c4b813265aec8887def5807496fddb94a4e74be7949cc4b0a9b86397139e02af00a50a09617569c03fda82798b56e5b4b1c3065f3b56e1718f864b5c85fedfd93e46e08c7ec1a8316e7bd0e55db524f5f6afa25aa4837dd88f45e2ae09658ff6ba609670c9dfe92884a271c4a7d9b3515a571fcd44dd55cf424cfe2f8ce9a478f85a9a2c7c7d763d7e65c3be33e8ce98215e34ed1fa6252bc30472b3b1275abf62614f9d585b433f6ec9253c4e8ca2710d8158746e8a10d26a913173a4d2b252d68bfd70747ebad0b1c84e37c70f978996075f4428f1e1a743bed89117498c7676cf92bbfd03fd1886f705cafb647a64fdefede825c46a1cf09d3646cdd770b2219b698347b20753f05cd14dab569bdfc6f157d6c7b9f44ffdc6d886d3299db637bb256e0510564732aef3e55ec2bbef2d9436935ce181f3a1535f468b43ab1f4b3ee3b49777b6a7324c1aa6ac08c55a81d8d98699eecdd0e45aa5af32567d4c7f1f3cf18d817070e29fa592e3f854d44b5fc132c6f2b79b0e970fe1a71359175080aa25ea35951134fcff671c0bd3b3f81e7a7973627fb6c356b3bfd00cb2f090a8fd247ee7080086c5872f0201c13fbdddd51cc1dc123f837d1e64a5a529a429291782c245b1a743c91dcab4ee68c362380498267d6354b66b2764b3efa65c6b48a04aeed69fb15d91ddda2b54af179a0a55d7f24de67fcd31d214fa36bffd03491ecc86ae560ddba6fbc3862a7a685b4d0a0f5ef70d6a9f04fcd222f6139c830a7285e789bc9d93a56f2a842cd827f5a57ac8a4e09b3acedd0508a496088b45eb5544c7b826e173999fdb513c4da131d7525bb8dadd26a88e3d9be3aec33db975f9f62ac995d5429c096dffdd30ebaaacea6a52f4be7a02bd1420f76be374d37a7db0ae62f111e38f0fc8d027c04f456c9224d8804369ce8f0668ffb84903d55c977d7ecb0fc3e7c9703417dca7459c9d59bded99d758c6366c2c554d8991d13c166c485ccaa1ab9175c49ab131a5b8189ca29fdf9c9e266169ec93de814409703a4d907d84389e7dfe98c9bbd73a37daf58efd1bd10a0e2ac5f6ff0d5d41255d36444dad9e569d032e5197f9f429d269c4b828e7539dc5094d8ba33d1d24a2ead2912096b223f5c9f527e063c838a645c0c5386188aa82c623cb647a73d35d7b9e9fda30e177ff01b4cc157123a9d335d40ae5e1099323561c79c92785240d430931f2297ba1d24746608a0fb3f28e9aa4e5453ddbb010eb9b7cf7c53bdcf9214de548513001bae26c156fe9178ac1597544f12bb22a02cb9963c50f5133f72d59ac52ed39ac69d454a393575493b2e2634fbc5d8caa76102f31d7fca3c0002b1966f7d215a2ddbf19a760fb961c4c646332faeb578949086f31f3b125b8cacc8485a5792a928ab3567ab880e0c015cfbe1434379c138fbcbf1799b35c058c52888444a7856592c65486b3ac6d48c63bb899285112255be0bbd7ad6d47dac95ef667fe8e69d8a3ef017a6fd61d6de0ab3df1937c433a6b20642a8e0e2500922ba4227d7db81dfadd88bf5faa22957c63eb699c85303a4672b7db6dd1d86e953d75e372eec373aa49cdc15d6e19af35b064626e282b0a15e03075b08d6db48e726981abff1a07c0a4ccb561515f3dcf6830b068e28bde734676f87409f908ccad0a677287c8bdf66c58d6f3bfd9945871cc8696e20c20e4abaf13bdf40e5759cc3baa44afa27e18a7933bc840d353dc4a68359ac1f53212b6a9dd82e8e0d8be95886c9ce7d02262f50673bf1f40ffd9bbca4870b5149cd551ba736af3587ac9105cf4981af513dabe203fdab0dd7454ca98063ecf8f408e1961fab9472acab7b5116681635ae96e23d4ca0405e47f0473c4048d904edde6116534a1c9289408ccf0db6fd5c8e39bc3990135a2cddfbac74c3b63fd53387da8a9177dc8a8af1a5e47dad16aec6cf365688907f7f7c9cd739dc58ba8e2bbf3ae5bb2bcef4a4d4cdf9bf0a48c2f6114bb03dfe13e7fdee713b2b839b36d22b1f37a55e20a6a573c4ec35a8f191067a4fdc81c8daaee8637bf85f6264f962cfa35dc1776acd9c8d73224118f60ce0b306ad8c0095a9aac6f502ececa3b0bc5d2f983f32583fd2721f88af54da044be457400b801b8a9bf4ca2ddbef2c2beccc34e5acebd6bf4b5e5c8077fe58d78d86a9bbaa30b13d7addee61de6c0f7f153d5ce1c1ce8877c0c0bed61e7006e90781372b7c15a9db85812388427d58f578f8f6bea86739f13d56fa6fc142fe3bceaa0a86e800b9cf8c1a7036dc7a462508331afe37e03ffa17afc5bef7bcd1ec6f7449368b4297559452adf8d7855be7bb2381ee2317c097a3bcbccbbe86db54e9d4d942520a923a82f0604f94d51f2d31d4a82554f93a8a6e204d3fd6192acbe1189f69e91acf5f083e550f57761f2f6fb1fe369644564273c62f7c09bc01ae18262547511440960ca0c6145aa5d25b1d09bfcefa05ad47206ab4557b28a5defa98302cd03802f3ec6769165245c0edd174086ac122a6f0018e6c54ff3958e7dd880740a71c1437f8b00b5370233148b9a2c75eccc8e7fbd507d709b93dee32ac4608ebf73bf99935ac6af5600d0e8011606c9613c637cb18bfa12e95155e7715ad320a65e8363337f4be800c3f2196d4c95e6a5d5667994517239a78e3ab12d71720169b556b80d9051323ac65b3bd138f3143e6e1ec27ca7ee26ae027ec82065b0d92401819d3feec148b91a78722b1877a3e140b84fafceb98f0779e8afe493a02a7c6f27427c755cb868c6697018aa7dc2789cb9af1f81175ae66a70e544a97d4f0950f11c1db7de503b5c9a2cdd04be1e7ee782a237f4cf9b6697f5a4e3248a318a5979f8e05cb8e1bcd370e611222904c0b8d98ce1b30e4f73e9a67a85147c98623f7f1a36fa673faeeff0345e93109ba836ea33759fb25171611f966139ae34e4b616a23184b55e13204f7f0bceff37738d7969b01a0f4a2e119a7ce959f83035855237ab8298833f2428add5e2e3e698d68ca8eebe366ddd845012c2e283be7a5e0739e7a3fb4b99af5ce3fbbaabb5296466c1153f398db55aec780e6a8cc09f24ca011740b7b9d59ae3fc95300e5bd739570d7872c350aae10b90d021e3b4a0d789bba6f96a73fac6c3135ab4b29fbd5ff140c1036e56067d115d9ffb5c2a2d58c60e1a5e593d818a30a35f9707d48e8cd3667432dc4cfdc1b4da89e798add0490dea424cea3c011c5cdfeee1718b718a149307c67d1b5d2fc89480c55ef672e03d2627ae3023eea34fa510dad158e594a5bbfc122d473c5fd8f8c0cd707dd1aa1dd1dbb893aaed0a1d2657ec1ae37ddfe29ee2f02cb88c0567229f0f7425dee71f2397c1af2698e22dc3d8ebf2d9a80889611767533eda943b36931469320447ed4bb327b6aec20c73deee0baf79cc65d0210457290262002a38ddf0823fadc0014ee5e6092b51234ab38b207975f1c5a84eeb683935196d6ffc13da236cb83f124b8d75f3e37360a782afd3e26dfc8905716c58b9d18a1e5e9f26679fe5237f8bfa4f5b410dc778e0098de9f90d7c7effc8455c67856c877ed3c2e1aacae0b0e29deffa8fc5b58dd8251a62cd32527764994a2ae3fbb4d46789fc0d7150b4ee77d3c951e8d7fc8755e33b0b4177c6e24e493b0dfbc97f5f1d333c9e35128f9470f2b3c45311a421e4f83b85a829d802b1b8ae8cd35f49b157698ba79f6ced593242292e0b60c63123a889fae4d7e4a2a7b23929e697c3c7d52d8fa03f7ea6bcf1f6c358d850f4232271625cfab84b75aaae6dbc350d83b60a7a29338a9b9c872a09a7f3b461984e0a75bb3e3512aa2a61fe9ac2a95a2994423637941ff8f0336e91a60f409c08d9a7f48e139ca8d311e7a38aa25d10aaf2139f3683794db4fdf879afa47ede86f9a61db830529b3a29dde1ef19a8af217d250a70bcbdec01e7f54ca299f7bff896bc350593cf88a4d0c0182c2e6cf395fc21d6727146d9240003e9c92aa1e39ada61d6ab60a4264ea71fd6d2ee2b9ee4212928c43498b60dc735d70bde61e1dd871e6de0328095ecf4c75c1c2f4808c3cc561dee5d28df86a455d933d54acf66436e5ed0134bf71eb0376b73410406d27741b0c6902377bff9eb60c6c6d0c1855694a23b541ca85e2504339ce60b14d05b98bf7cf60db758ba4f7ea0318309e6a9c0a6f711fcf5bb5547ac6091fded31d30d7d1d3b50865c985c7ecab0d88f75020f550598365b926d9487b972b784b801cd41b50b512c9010e0e323e0129761d948391e80e67ddbec8a16d0d4d442aaa904fa3bba300017c29df547e2fd44e2ce2d94ba73e0f44413965c218a464d2db867d2e429a7fcb9fe9d66872034ca2b77a412a2daba08d0b696be5e6e163344c6e8938faa68270b54df6d0241d9bb08a62ebba1fb0a2926a4d62c28c4869c6638d76e494035318054fa926b00898a7e4dbb6e1d67ba3ee49c98d4405401901f0177ea446266171137adc6b12d8a0736c0ef84b7a02461e3cda3957e0ef959c1ea4ebf842034c4cc106e06a6dc2dfec079bd2261b806e6bb2c04c311528e439e8b077e6321260ef074b6da33e14c7c108825844df235bf3422e4ecb266061842c89c70149a572f0a5a005b67c8a70de6b5bbe3d8a7c45230f4098eb6986b010ece66f651184b079828e26ddd75439f86ac3a4dbc7f9d4be93472474361278a3fd773f045e16340f5224591ebe1427e5f4979deccd13a958e61759c5c622ea9f2ffae520b939be820e5e4c5c86efed5756c3b6c89699aefd387c3039afaaff098dec1329403f1a5e0c37c5de3e7a288b09afd38e028b9c0dfaa62e53d099b9559f20275339d1ad2201652dfa2bfb9585e9797eb3591d54da4b6aeb219589a0a7bd537f94aaa41b64369d6bca67f0fca9f3ca69c77ea2a06fb309e0b4e892c227431141152a930296bcd94af58c837bf5feaee85af41ae0ffbbb2b60bc47ac22ca67f173b5c98b005e328443aa93b88273d537ba92490415b28d19f9876b783f9d6bbc3871c5a7213a1a5ea93f39f32095be7b1b29ba6ee0779652bc40b9c1748f766c840c6ba1f362e4fc507221b13e78652c378c6dac7304889fb1d77698662931300b15c6319e62c7e98a40cf3e0d93443ba57233cf07c3db2a8dd7ffed797e120ed792175ad4ec53975c97195e36b03423feb82dd0f954b624f2e18f6a30d631605e6981d1052ff06312362a79f2d465ac5cd9daf34a5f8fb4edecddb8339a090efbfb8ead1f9d9b33ff72ce7359ea814640e072d2a27bd40080e84a2557a5e3d94ac45e26bd9476e24cc5fdc2830300b212bafc0602f1b4f404728d4db3588115e162b57258c2f8f705347fa6a8221bdb6790c782acc9681af0d4d7dd823bec5d4a0225a57b42c7d7d7fc1269cb1f98ee194592d9baa3f33138f1572732892bdd0da0c4f4f111eb8a6880d21e2e07f4384a0e59f4eedc1138901af6f64d0cf37c97c59bded8477ae8ce2a2ce515cbd457b8a01dcc492ab46d3aaec7912e14a30243e8474f577f9d36800ae8b0d9468ab6813fbcd74bb8c712e79c96bad455649d2200c6f42c7d5df5ec86707cff44e937ae697f06af519a36c043bbb3a4be7c051d909051627289f18c58e14d79d7170a64eefedfeb701df61471b45761c8c5f82d53149fbcf9ba709b9b1b7816648d3ad474664304277c4ab7c764ecab8bced4cf335fac421978379fd17b91c7c8921f1b2cbf513d214bfb67f6bf7f6376774b08012e996683adf368ab13b2a220c67818f9a7e26d9106472c31450be3c0fa573276097aeb2bafc5e8facc256bbb38ce6df905d653d9f8f2f1575196fcebab94a7269dd34ed9c6375666427fc82714f4ef47938fea8123061df424753e18b71b974d71a877c43cfa7a1c01cd000a3cc577f0e87e5e3e5e5746c026921aee69037fa16a800c5413bdb2801e62f19b4c81ee0b2b20909d8d10d2194da19496a95e5bee75935ab2be334a47ee0cef9df1bcd15353d1669028356e68a2138d6fe857b51f236598ad4bad5e87340ffa9d15442a28500f1b0280b16137834f2d4bca528d5f8628f70496ed10da0ade498b139058a1e6a5dc13077588ce2eb0390aadb97020e034ffbd95ef3530d3acb2ee1d9e5082e35dc1acfd6a1c6f7d94b63fa10e02cd75560207a20d5e1c3993e0f61c3e756629fc25194064ab824c7deea98984df98b4ea4373105dd5a3c64a16f65872104d6de71ae2d2255767187accfe31e845d6ca24297df21d24e704e14392609e8af9dcd58d4b7f194051cf5b9528a0be3773c4bcd52b30c94ad57dff664e7a06df5cc5fba6e566a4c5a40ad55c3ba798350d9f5a4b30447387dfe4d390f138d6af6ccc14e8b126b1e5b9984d9c74a72d1e39869457093c580acf24591f95d80d2d51480d212a92e464d604e17cf038decc3ba8a2fd165df10ea519e1270cbeedf30518b3c76a4844664720bed1070402da11472758980d5c6056a27e145d9215c4437dea2a08bc4dfae991151aaae1c6e2148208719e826e24d7a058c31426234bbef4c80fc368eb890b3d9fe44d22c97ded6500eabaa772f99259427ca20bb875df9748b956d9289ae1797dcc3093b0e04566513a72f8d0f4d4fe784ec427d3ad95ba75b013e3fdb17bc9ceacf741c5344090e134d856e21a7774f275957856c8720cea63d1410ba15023ce83742e434928a56675852c455ac069bd36bca190faab30c61c257cfa948b53a1e51f135da343b4e6c2ce9d7bf1f01375397c5ffa699316d93436be8de97ec61c095a80aabe79dbbc6317e89fd6d010829e17d656a8efd188b641e2d62d1cf7d0ec4b6092e526b1f97c000daea530fed3b264fdd9f1135339f1439e209841c75c62228d30bfcffc6927f0d33b9510d3a8170c82bcaa73644ebb6e9bd6d1932fdb0a9ece62205defffd1f28066dfb2ddbc368bec6eda9cfba2b0ce08f748827f87a9c9abd2c0192c3368f940e0a58d7bfb142a9595301e2e7f63e0afb0e2ebba26eea76adde464e7e5294174676bd9824e0ca0846c130b8354e06e81f8e8ec4bd2e747e61364ea1434674c1b9420232dd840aa1166749e6f3d5157828197ff3cf69b8e8fa664ef044813ecd708c2fc913f18409fec52155f62dfc9c0a9a098b34162f4e50d1f5da275f9d7fb7731d8a9c86c18625637e1435e245e0640a7fc8e1f15e199f361d8200035559f04317b106648a7451d3d786c738c60ff04e7d8a8aedb93ce77743bcf3d5df1db8834eb67fcd43d0dd87c7179abf76a71d5d223db7f7a54e1a49cbffce84e81053ea559bdf3e8614dd4cfd42c612e46f73577a9e46d6574981cd311f8f2257d1e9e7bf78d9ba273ea9c3be0b270390e5ec796458a7d0fc3e081612e40e57856a1feb8f6181466519eda34c969be1a0136d3dc1faec546eaa20181881502126d558bb95bf0408d5cfe537f02f22ae1d59a1a5d44cded5c48167a25064298d248f02c278176148f774cb5cfe885c8a6241e7479f47b6bceb0b629ccb9dba2eea184577c0afb7c2b62f01cf873606dba01050c94ac767c5cfd746b236e1944492d0fc2c28f7dd691910de3d2af0c1694bdb44bf1bce7dbb86d727d29db24fcc69804a025b00ec2423c2fc8cc8f47f0967cd6902514a39493f90db425c411c33724f8f62de945916c0fc585c2165fe7f303e4ff77e89f7dc23ec9281ce5e26a3caf0d9ded116af9fdc42c154df98932fb806622bfb8c60c79d51a66f01da7ab2741e5f0a2922fda8e4dfd73a1e67562791e645160dba2eed58de238763836b0e7ea8a4d7e199a6f405078997a7dcc8593f8458671fd169908092699d6f480d810a73ba99ade01e77d842e8423a364e91727d227f29524c259607f10f9a270106a073cff21388d4cfa0ae3337ec8dfee990745f49f0a7be32cc109039e5f03492e933bc2894c32486f2afc8188dc853ea8da79af01c03d5f6b720b0b37c11ecbdd7c8b5051b831f31e5d4df4cda7a209236232d67fa9797f0462381ba9d6158e8d31709832d43324bcc05011413a8b1afb8287124d3951dda8a6ee7db540e6c9d72fa49a38d36526dbb1ebac24b32e2cabaa0ebea6ad7b2f48471642af97e0093223f4eac816af5e0318334e2887148f126a176368f5443a83a863f2d73e34d2e3329896f404a3a0fc2378291feed158df81cf28bc9b70000a80ab1b6280ec229a87b49b2e09fdda022420c31e79e38e3715f97a401a408d2393d4c941366fff5c04daad868c072ab67a97e104b8614277b8637e86b75a18d4975022fa6869eed656b3e935c20bc5f8fa255681050926bec4910df39f36853131afc94a104a4d32891983e9de1a3321759a3493b93874ee700f3d55f6007ab99398e5bc81ee504078d87af4f6009993ce809dfa85d30cc820a6ce7ac7403b5f1e373840533381265b0e4d95e1757a5fca8d2558f817950fef78b881b4c5891fc8c64e057daf1c1fece34e4589bd32d1d264e7c2f5933750019157beefd1ee5103e7baf79bcefa736647c7ea99551b7f8dd6b2051f151230408921798a0e0c598b82f52ef70c418afeb6f4ded005db1c9362942f59f35bdf1f4a5cc41f606aaa14a0a459c8ce61b80b9d51407ebb859c509ed5fa538a668f8bbb5a2a9b0a5f573ff8586b70d9499ef6f999591e5696de2f8d642133208798db8750390b63d01f73057d4f71d89fdfcdf93cc5acba3a3b88f3c3d57312deb91cb3d812aaa8a92123e7e93c721df5843bb7cffaa51e9f8926cc7ccfb04370064408c9761bbbb005db3b37cd0f7f4102b559abf8f25d5bd0c232e8e9d20e3cced089d1348fc9d8d9a2f379d9d1749b3e812f61fb2610900a6cb0094238a3f81293a3a6b54f2c5d6aac1c997ce512987300383e552281532f80e7375140c70c72f4fd3ed0f031f486cd07109e43eb7f8e68531db5574fffaf21c7cc1a7c3af47227959869ebd1540a803aaf7806961021b856f86d1a40362333afefc271440ec0252ef18720ba8bd65bc2a610c01fd8c38b5a41f688d66988a122fd4eb655517d939a0dc5210d2e55fdfaec9b5e9485e39407e9abb02752e47298a0fd4ec58973589e1601c749602a41612e5f6ceed58d849aaeadd6752658fb2b8c93d6f2780b43931412c8d0dedda2c56e17d8d3cde5967d3c3f40ba91c0abd52db17d34ff5b74e2539b69290bf2ea955022d96abece24fa41db0732c1d1f62522b58e4913853a0ad9417ffc719666a28dd04fef8e5d9033e4d7578e95a5014a3441b39cdbe44e286c0b244d308827908df8116f7c95c57bd72a0e4e374d8399cb4c047287bd0914b59a108e31e2d9620817817f2039170554036d38af93652d0243f669e47e34622dedb3619adfe3bd92f508f0be0fc197df76bc0ab17c7c13cc6d146cb9578fee0487bdcba7fa23e65efb69b2313fd6ef83c00899a9a379ebfe99e1e18eb5f4b79372edeeccdd525493f6a20243b4a6635859675ed6ff26ddafead4c34779f158408dc5d19b1e8e2545a6d0fbf71289c8b4822ca3eed6ab924db12881f2445584f9cfa99a8b671e8c438f675bd86965ad6cea647fa335e98231f435b5604a3da826d850f5cea4e6878febdcaef75bc9bc9276f4ec57140b2c8ca1d2173528274836b776bae576caafd31666816f3b52de55c1d92b00345940c9aed954f23e7095fa54df5235664aebd4eef1464e6ac5a774b3272e4d98f9d261b5578a6bfa8cef1fb54e980e0b95396db8c462e0e889592c1034bfff2fb2004fb732ddd10c954205b30d5f8e5d39e4292cf90e4f2fefe0c6109918f2f293eeaf92d026b35cabe683312f5242f3f659d27168eb6e8259f77451dc0c01f31908c8cea29bcdde22765ce3de2e9f7666a0000153ee47319c8b6282407d3932ff83294cdb401b360c87ec1d96c8593d1751ddee1720d5bac60b36981ef3a2d2f45fac12b02da91cc12f5c73d0628ad93f40df7aef656e449b2f087ac4e1362880550e22028a3c57e450e6b3da865b0f2e1be9af5922f262957164936045c37e908b98499cc9752c61fafa359238fb9c2639c6705b0a1c7a9c0152dee73cd26f230679c1155aa75941a8ab869c458df152d905dda6a25d9ead0c7ecd0f1faf29bc94702ef355fe4eabd08e7190903687a5ce97cf5348de545ac753ccd8bab995c1c734bffd7786c8e2c72aac2f7632120495e7a3f754f423ee16508dbf8eb38b6a5df6ee6dc7e098710434682bb2b95c36cf6685c28269084e61632fe57eec9a2e0bd04b1797df41abc1ac6e0dad7087208d97820c32094c41b01e639b62d5fafab7b235a3ae2cc78d54fc8864ff7260d3996d97e5452d9623285ea9dc5e0f1fe83dfcbafb3384e289818cacb1fd890146d1bd04e62d80563a20894e65f5c55a2f8acdbd61b41ffc5eff8fcc293569a1355d7a605e7845e651ccbc04b4e78a98ccaecc26e66bf4dd805bcf958f0d4bbe9c293008496b63c1c1b63fde46deec03d841f711e3abd69e00bd9db75cebdad349efaa5aad7a4a6692b1deec2e3e6ef6c4cb72483fccb189283d0aa1a386101ae7a8712390b77e5101344256eccb8f11acd5ee24c68180d67adf9f8fb549b647c7b68d335b2cd57324dfbcdbc22b669783f95206f7a1f070fd4ce0ca0112ba9e4ea895c1be86046e8b5b2cebadc5966ac1aa39baadecae49a92281d8346154066b2f448207c524ec66c1c525427c6da276ac23f0b53efa37ec33552bd9e022d6af16800fb3813e22e4acbcba23bb528816b55304f807e273b56661f172cd18b88cf61af369d8652afa8ce8f3a51c9c53d802d9913f14eecce22672764f01bce898c6c6aacdb8cc4e91795189dc1a7ac596393f69fb23bba81f4120d4d46bb8b2e310646626e47acff9098cca21bd89b4f22d71006a27cecf8f246ff3b10a8b3897fbf2beed09250875b367a14a570330a8210c4febbde96496d6895667de69d6e86505eda7588bf93b9c25c7f4c8b5107d17fe25c11df836bed14d41100038db7a7a421bb676fdebd5541e6476e63a0dec84b0e4bafb6daf432425fd6bc7bf44887fdee338a49edc7c7e5a4c18aa8c39170c72539528942e655253c56cea6e2970fdd705e610ed25cb88f9fe5f3b73980d6a7a6142b0398d011cf453591326ac17304c32de25c1b9b12a3fac352b3478bdded7b04737db84072e663a46936f5a798221d52cc4fa6ab8962777c20964a4ed58f8d756dac8e18e688d8fe86fa1efdd667f7e8a882d634052e1db1578cce9fb319c406d10d93fba8463722f6538bc0b4e4a2ca8e743c2b326fd9aff8e0a1a36f86053891d2759e5f1edad4ddcf18a9c4e69bf7ff2d44cfcac3e9f46da337b4015bcbaf0dd6399f308ad7619a6258300e0e05e1bf81f5dbb20276cfec0c479810e52d8134c42788c907c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
