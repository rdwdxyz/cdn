<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7542b1da43623812b9b4a96c32c5fc51a1cf125829f68dae821c4d6d64bf2adf3f58ef989b4498d2de8ffa874b517915ecf0b61bbfcd0365ba7bfc3498b11c967baa5a52fa7c4b885fecbbb9a60a37fdf02ea0a1066e98218f61b99303d97fd8086e1896c2f3a955eb739a77c69a86c177a52ac33d24b04928ee60df2b69711662c7191af03b874c2433f5b9263e7dba74fc62bb05d2bfe8572afb666feb0a16152ba8878b66858d80e658a92b260e78a965c79d5df816f65203a77e57fed2f2962d015ebf22cfd984f714274da45b07ee3b01c71c61045c73336dc8bbaacb7b39c526b8789cfc4a37ce47dd4d33ddab4758c2503bea83764d991445b182c93f0cd9b343668217da55fd9b3a0defb33aefea6f8093caf0e1bee5421c4ec1715ce4e9dc3dd526bca2aa371549e5f88df0dc8c97c5e3e691dea018ae34e0a3bc4a83edfa9d1f51778678dea06751417704c36964cc5c0a03f5b3112a896c12ecaf02ad62c7d1be1e358bcb4996347a8292f0bb9eb702ddb5ff3144c8fa1251f3ec2302b97d2529dfc635633477e525f2fe24b1028ddc5116a9b80d3548fe41764e806e888f5f19b76492946e26af508dc58595ae5a295dbe28570a1ab65198fd6794957989303627d2fdad1301df43b56ff03bcfeb7bddd7d048a6d1067c9053249e47c1b41654cd8e80e5957d8faf82bbb8ae2d4402608042afca08162d985fbb8a259311e96346195d0d7a59701bedfd45914781fc75722a100adc9bd1fbeda1f9c26fa6eac0c73f3aadd8674e0e758096b51f72bfba0729e4f9e6a86f736a9b21bb17ae75fb9446b9a7d514c98f03659a35e2f4438aea610e1641f9552797c9315066bac6dea9dce12f782956a49caa357fe5d51ca537e5676f3563e78a409cd8f7691ae7045873c9b93ddcda614caf1a6c34afceb35e96ccaf32e63b7c49cc79245f341a3823e6162cbd74a883cb9d3ef4acafc53e9db99fdc854bfc3cdbf1d9d6ff26e803f6c3d25621a84fddbf5770ba43fbcaefa978bc12e4c2a67d53fee4156a9b8728867b38bd941127f80aa368f05137d37b989df769a1edee453105acbe476082039e47f78bf56c8dfe4e939ea110378c639c933b6fe00e3771e6b8ac7bbda08f8fab97ff7bc96ccf752bae61688e4807c019a11a63da9c44addcd5b09d54a670c5914b283baf0d1c4e204d584c0f5275e92a66383e5d93fb229a639efc4173763ed833c33ff6bf4d68d22669b92219d97caaecdac230ccbe0a5a83e01135457b839bf8115fdccc53c45368b9f53ead47511bcebad3a84642669a36538710537f75e23dab1087066048ea266f5b8a79664b0a8bd016e63d8dadc6a814ff7c2395f94170cefee03478158f0fda286761507bc92aca9e5bab9bad5cfe24bcd1d334d0d489e2f6276149136614160a8763db85f3581230900ad6e043ef6c54bc7fd5755a339cb2e40492238037e678d0d1f79007920729e9a2fa81255047c9b5c403e8693989c2186dace7c11a8c8b36150bf34e6e22a6b806f7ec35c9fc9272b76a2682dc987115f9b210bac9e854017e6a8689625accfa9d7374fb3cd95f2edaf84081fdaf17e1bcae95905ca362a5d021a0656881d6495f620a3e580f43a5197431c8273764df09bca916797dcac31217bae52a1218f5f8d0a2fc01a5760b3e95e0c2316fec6a214d229fab92c36e148c64281e3f7639a177bf5201db76707697d8db2db53fa1533d102a102549ea0bd26015e4ec4d13b19010241e1262b635337e960b782bc20397e18cda56f0be99e0ae504174d2cf88db4429a4e9025577b61f18ca7b5b99efd26b42b78d0a9c62a17a95f3768295fe5eb2a85e1e4ca610a52da3f891848ca6438e5f53921faed15652254facbf033543da7de79ea2a44e64c59f6a70c4f2d08b8a7d510988d4d50484c36d85f2f0b19137c2d695020f88896f345c5a6650f9bca59c13c7bc0ee2494bb1dd202c7a8268f5805b44d2fe1772052385412aa496e6f0242ab154460ffd9b6723cb2a9587383ab9a4fd3090df8cc0a35b2ace81f1c8d8f610ae3473f8fd11500a3d78ba7111754f75493b6ae14d1c994d1c234adb35deacabed22d83271b1bba795fab805b8275ffb4fe454ead0da6d7ccf61f00832ed09a7a4790031137fbb4422afa447fbece00d789ba016bf52d681adae9682f250338fd694dc03941e4919b6b6056ecd7c77ec011d4d45eb4e79c6c76749abfd6f371afb82763ba24884e712aac1e2c82eef65092cdf58a68b7be3693d23626b8d410396e173ed577cc97d077361272f9626cd97a1335cfaf9099a92dd55590ec9a858c67cdbec3670e00281ae0d2489be049d183fb123eedef8b05a9b224083b8aa6ca28e077d1b09fd0bafccb2a7b91dd3f4026202cfa81aeee37fd2238f49b7dc6005745dc7b165f50e57560049ea91fc1c810e329aa9f1589ff2feda78bd9494a9ad1546acc1b4cac1deee2f686db1fb08899055d707ed9caa5d05d7d6d166a43149dba5efd60ccb81f41308f9a19321ecfce0290c342f41aad3dfdb56e475178a36e68df9235251fc07bd496847a11367a8732497eeee3207be7654d612b47611058eca24347ca030460a66f695e4eb95366aa6af944c829332be7380f148ff21e23853e3e55624b04dd77f579e20497e44303b8052abd54246f3f48a36283b72ddef0f97290c563eaa836de136a2d3bf9ad33768f25cd82d8f15d960a2309046afb2507682e92a7fa97b39bf50a9b2dd7d0fb0586b41472c9e87fa3672ba72fc11083fc9b690c42a0bd6b452855023cc4e5d8968b81619764c442c86252d3522acdf4ce0a5f0249a75ca6bc97fec0c2d59901d9ae3bb3b9f5ff6dd1de0d704ced4bdd83a7de211b6c737cfb125d07abae952b9225db2cec54c1498ddb8d19d8849e28fc11ade288e1c9e887773642e7e58f7d705c31d6efad511e0cf8a529e2a437c34588d6831d908463b00fb70713a76030630630baff3d6bedc286fe419ae2c59768f2a5199a4238e3f98356307f95edb7618f9d91bdb8ad9bd2ff47a347881bb4e557a1c128619341a7a52547191b5b76bf8d440f2e0a3f22e0f30341e7c64d96a8d1fe6435f4027a28832b3dfe11ccbf8dd1d843c1ff980f59099fa3e1c22921ba6cdf443e8f95f32e975c1105c52084053b62f8f382efa0d959b3472b129098c5e62d1f8d901e3ed595f9b4f6ca78ed7290ff2618315cb6cb76746ad890ab78149a938ba84a1a1322867f2b1a2157411af0d579f56ee67665cbba3a823dce4cfdee23a40c42518832381f7236741e001819657c25368be5a2a08cd358741fa4ddf5799b78bfa95cad645bc806fe53ae7427bea36d660f0448c44c1536957b12eed9895e7c0e6024082bbd679d3e6f2444548535e7152c762549c7f6f4b835b97a212a2317d2dac433ce52a66ca6a004887173b1f2198d55c930696c3ebb8c0f7b13e166832686aaa81ffca29ce02f421a66d19197b0e7073e458fe94ce488c6d849855eb1b36f02d54b8755274f04318c8be8d4e5b2b444819aee541f8742477d73bb9f24ac05ebf2ae17e569daa7c9f31f3540563f2d3d76387cb0d721ca438f2d34c323167f41d872200e76fe6fd7708030e5ccb21dfaa411d0b6e40cd25e0e915d8123ba1c44570c4a1122c12385ac3b9c9d957508026fa014622225265d7b617de8c62ec11c588483236d49d1811bcab25d0244a28e7e1b5e15407f370589e84c317630b0d0cd33088e5850e239384ea6e896770b14fbd6e1f6bd1fd3178b08c24ec64d16f9cc9d90d1d269bf64e891b517ea221fa372f0d9120f23f5c71bb9e38a496775e677b7bd4f07a107bf097460d25d30034f6985947c2714255b6e369b417c821b3b1a1393281a546000b927a6ee59e3ddc86f4c6ea65bc40e4ac12f8410e91a5d4bfe4833175c5dee9d56ad1539171451629413717a2468cf0353011eb7407f1c02a3ac1e4eaf9fbb193a089f2ffc26fa06fb6f5ab27520b14b0a17a647399795e63750ba28f348db3b346837922997638e8cda43a5af4840df54a374f7ee785e0631acb4b881d21fb91242d68a89fbea508444a0b7267b59c81351b1bc6a392b34d939344a6ccf83afa6ba7e64688f9a226682bc8b545fd8ae3b12a17953ba6cce86b162ad0f735f2223c198fb52c8fdc6072150377937f1c45dfd98a277d839e2ca82412e859e93941dcf33929a5000b643e99024d81c208dfc0261ab7b9c2b8d61911077434b0ff18655db209d47c4cace7afd90dcace5674049bfc81cc3b8742d34a76d4dc3f3ce7018d0423b8cbfb8e587bd4cf334d4e48ec4dd0306b586e1af0bbe8bcee827b377f9e39ed0620dedeeae1fd411e48b605be3caa373aa747ceab40fc89852111dbc23be62bcab60a876e9f3877f612c8f8d23bd7e075bd581baf65d7858dfe6daa3699eb3e02ad11e62ba4a0f3122c4494235ccfd4e094468c991e411e61cb3800eaa4cc396f34c8ef8581acbf9ce3886e3c4ce68f2c481f33a68b10c892076bbf234083a330993bdf9f6ceb3c706adc5f587895a5b9ee5cdf5a1e7aee62ce9e2a7ffcd0762046f0663174297ceab9b52b7606dfd6cb66129e89983b21bdfba71f35fa66cb434e1f6178e0b482c147369615e33d6fcb73b18e0d314d7af8fb33a3e85013ff733b66652512163fa42e102bd85cdd8c7f12f5421e4d593ae84bc8f0f74d071c3c25a9080c5b2d1c8853421d2a24cbbe03dd2751a716d5ccbb0b15a3c3d8ec167fc9ef9ecf246e4f46e10887bb07130a5c0a36ad5a42836d1c7d281e706558acbd7ce7661e5b03e51d4b17f6f19ca35a9d02cc7907f3229177d1c7561c5e5e3ecdeee5cf4f8bd40c8ee37f8a3d230aaf8f4f88b49ea9fd68a2b48db9cc35e3041822ae32908eafc86976ccaadedb353b211bb951a8629130b1154f71bc3fc59ef904880e84812cd097fab70933a027dae066ad80138ff1c57f735737be28c6370486254a9b40f7e971bc1481cdb454dce4754f1bb7de5d9b20ae30874c87bd6bff3e77899cdb1427454965f99d9b1d8ad18ff377b160c63446c8303741cb5b2a1d1e0d0c57f799726840f052d36353f569f262cfa4e5d7bb346147ec98608fcef7544c02428407473125c4c57d9bfdef3b498a6f1c82ae15e60c781c13b19984d03f4e42151b9cdd5e2bb996e3ccde9fb1814f333dfd35f6f7133b755d1095bee6cc16e72b5ff73415687ee07d4f01d7ac37c607c5ca757be264df2bd2e8e4c6cc9be42cdd5c601d5d0eac9f2628d6d28cfb51f18a222870f518c6b14eea889c49050d0221b028ea199ee8b80c41654f380a64fb6193ce52fd4fb6a9c449bdeaf20e732adb231271b03f65f193da3107874acbfa4900f1b2cd1fa5c0868f547d584a7415333927e7d0832361be8e690b9747f9fc40c875f15c4e623854e9017c65406b351815f896d153c22e44f904186c66a5a4a84b73b6aad302494968066275c82c9bca1e3a9dc9304d7c35f4f20582627d984ffd0c26f55749917873eae1fb05f7f68683530f0d8d535a7846dbb13624d90911ac7ae0dd14e0562b8101dbdd08b35158b5c9f39fd447ce38fbedf98cf80dde57919d90b18ef5bc5d2820f22ab2ef7c272ed2159dfa69613077bb4864b607f53d7720abfad1991e50ebee34deda9b38d8c98d2999bf20958ce38c190b9e8dd82096933356615b5bf1662bed5e9d73b4af6bf45a802251543d981ffa8552693a9d3a63aebdb3bfb6abf8642b2b8728964f350c0ba1846d502e92db9dd8e7055afeea8716c61361ffe07d2b6140f56e68fc59d2b99e17677b13e21ea1cac18fa2776b080e24ab695795411003fe0b2a2c6367a3755196bb65d29ef5d79d3b8a20e490d17032223ac268c51a29f08d62302444ce004c99038fd80c6b8413d8bf1077f93db3ca3ff3c237f5f819daac6043866b1075ad49fdb0b87251f5482c5473bfd9ce206f0576ad2bbfb2efab78f5929c711abe35a7ec19c0e4be202cf8784a74e887e87b6ddd07e182b5c9b451fb806a29431de10b2669613d547b73b94200c49b3becbbc7a925f7dec63d448f22e77a7f363c598d97e878cf9b71943c18a1cf878c825659c638fc05b77caa1e421d49008c37a1c011b9f2a77f9b9118689666c20b0983910c079ec92eca94c39bac30ab3b5421c9a40fff84df70b72ac6107581bf50a94d61e43a73052b03acde2d75cf5bfb1d192cad02c31172be85e078ce724f8cc3b1617dfb723393b76a14ecf09c5ae071e166e0e8b50c1c58dbd4cd87d1f9b2955e1bcaa16fd77adcd9fbcbb9193aef0f95c724db215e26946cdec22fd7ef826db1f2aede4d05e59201ff54bd6205f670b050e376ce7c8061647ab543959722beed65efb844b17f4e55b5fc1b346aea091eaf4fae291e185e213826ec3dc7caf53f16a6adbefeda1fc3d8d61955efe8431e0153f79f5429b6e0798ff38d6fd34aa52ec971d99654f6f6d924833de89874e550d3965c1bf65d693d94c6d0c2e401978be25866a59e7bffcde03f051140045ceee0444a466288b27c79cd97fa66b81bce5277c9fafce79b215f7a3f604494a69b1803adacd578725e897b3462cd4d7a34228de700f535ad578e7aba9338f8c671c17168c0ea653e19857509ac4d76feea83bdf69d501d01499f2d030fa34f5e24b8b34e378e2b1831aeabda1232cf720d0a331a85ad908a5dd03e59512cec08c1e6c81e408a34bb83ccd9a103cc042af8982f9743d060d530d1cd96dc002d2fa2f50dc8c00c8202a6649887f355f63f2e7e0649044a2cdfaeb1abf7e73d5b87abc7780678f1aa9ef012a32cf6442afa27bb7ff6f37f98830b2d8ee6a16cbcd2055f483de7d1e892b1857a54402e474d7acf9899f7cc661a820c32f12a7c5a7a84408a11d4b3d690710787128c41b81ce77d5e7e2cf938c6cfed1e75b88e8e99a5e04af7a46f226e17e2a1c86815b44b7e64541324c4760bd7c7eb48eadbab228c823f1f2f855f104bfd3e852937bdcbd1315baf89abbf893ab401291f765a65d416382ba85a4e695fd48f764a6344ad31c874ef662ca5f5679fd83d42423e865e55e12a7d9f0c80806772890eb9c81de2e927a2035cc42f219f527ca4d30a9c2cc05960b7e0e1a56e8266b67c5ed96d647cd996ba67ebfc709a08c5947fe6477c341fc30b17d7cf9efc86d44b300830f1acafcc8c2726318ef47c95d96937cd61173cf32006f8ace0547233624839c98390bab1accaa2e500967d493e05edc41b1b5028fe46a31cd4be2868851a9e46b8fce1ca2fc8ec1eac09eaf0bc0de73079602a9b1a8d5af042019c6aafb34ec8c649229991e15e1c28117346a4b4b632b741f74c5c04ba5d5247ea6f72a70a2d283a99e05a0fc7d6396bf49de6f066ccb6c2550aa8f4129f6c57bb190c8036828b891fcc4e4cf66198628fabf7c58ed0b65492312d32c20c8284248c6a743b6187828439f74871094c2b79d8c77c60400206cb6e2a49a2e38d1fe90039a20fec05430b2fddf0572984c6a6336590a24097b322411cf65c788c7805e9dcc1bc7efc1932e4c5fa5541343cbddeadfd5eed0ca264c2c9582be7a36a1adf08f2aa9166bd3b85681006efd30714a78028f470272cd29c038d36bd83202ce81d2226e7b697f8ccb1cfecf1e6ba5f4075496fd0e338ee86924ff01416ddd81755c6fe390f6b8643780dc5de4f2ed9a91dc3b2176cecd325779188060b4c8c75a9164dd65ed08bfe0c8f953fbd2cf302556dda7c3de3ca0cf45a35003bcdd6df7e0e1b973f8f77eb82dfa160056fd0ca71e823eaf04f704b55ecc588fb22327af99edf79b0b8d74e2e181e859350832c6ee74747eba74aadcb3c79e2f117c9cd9e441bf7c72bdf6c5de84284575764d77348ba0b4bd5806b69520f58ba9bf22eff13f32b0c0e2246283c107c4b9a7d0fcd9735c7f3a0fb6ec48c304e947f41ed44b51db3d6e5b30a64f428bd26a48fdeae0760bc615db7bc35fbe2c8376d693ed4938fe649922375d3deb8899d23ef9435369d446b063a06200355108d4acb96e2b7300f061eff90b49dbe14e374d6e9d192f9d0615e7050d9960b07e761ee01b90a585f63105a4d8305e2d837d263018a9c7f74c65b08781fb4e090305d57ee0ff8bef942fc064790107497a2e68ad6a15d06a3262c3453cd5c9c3c5f15b25aacb23d1bb7011c0e879c1b333410051865e350aa54f4e7d8de181c825812796e69998b04383fdd3af68631d188e10e44060a6178c81ae00b71bde057e71b1eb6dae37cbbcc8924d8aba5c83611186a122d3b4f4051ab07adc4926eaada5adb8b10104b590e0e187a5d7d9d71c0c3f74c58c544c47501682fc596e328097f0aa6bff4ebe7ddaf8a11294503cd92e857f4a8ce819135c1756fb2a0063bf653b3264ec39ab0dc576b2c51f1a8888adfcf0aae63eb5932687119c9dbba885b0538ad566daba5bc24afb1c5e46d8dcd1c8c47b70b90b7e3bb7dbf449a08587c1304862cd1d951a34d2ffe21e5e508ed754bb5e3fc1a902c64f93a7f63c064b7f25a35b3fdfb34582c1a8617ad3daa9a76f19913e707ffe162f72c37e1901d89346ab8d67b221f09077610396d1ef6da304930034b7ac7052b8620e20b3ed85d538fa9fb77c713fca8793b4418210d769d0fd3804b815634367d5cef29dea4fdba41b0ca9b132eb467b60bb9dffef26f74783980a3a6e5114a2733cce273f8bff1adf02685e9dadda0e3cf7ab1c8f4e54cfba14794f5c97ca3c7dce6cab48586aee80e731c2d3b3be525560b1a1c3409e71f706374df06c604836ee92c756daa4afb067c53d01c5242457d9b60be038a11e0359e6d5717aba2dc6b9458331b8190daead807ad4844787d2c9391e8a135dd7b137249fccfe0dabcc6e2a635c9b8bfe7fa52c4edcd8c7635d23ece3903408605d58a613d9af34e0ff58db6a37737b748999283b6fc711c25d7b0714289b9e9bffc886167b61c1bc950ac568ce403129eb580dad5263b2f70f2eaf05419221bf44c1dcccc9e71811b497138dcd4eadee740ff94a5b4f15231233337d182f4c8e2f71771f72f6dc40f3dd8559609435b254ecd13538d898fa94d1a8a0cca0d32b2b9eccd2238417298dd6ad519e17ff172588d02148f0d1473b73343efa7b67a5bf37e7ea4bf41c109eae16691b505a18e7ce6c7f6a3e6fbbfd3364a2d4f3ba7975da02c08de4e92bcaf6079ba99939125aaa6cb00f225b003050671088a7c2fb87cdd5310df5d330ab95f14f0e2bae8891965ccb52b6ef7ff9a012c4616162b53dff871185017649badb79fccbcbbf921346d2c6906b4169f105fca6d07e60a3224a37e615377f1c73f70c9819a1f8676aa3b0625968536fd87b3d04e6d632c5c83e744640845c2135695e39aba0010ad3f2fd1267b9b2d49e170bdcd0f930ee0205d88f4b8bd7f2ba317aa3bdfbb9e32419bb7cd0752d71ce8ce80d0618af7d9c0daf81b09ba64808cc2caca2150a08fad9ff44d43a5a49209f95eb6fe29fdfa7b40653d4abe7b821c9303e574c6cb35d331534858ef3bb74e410c5870ab41c8b4c723f4c918dddfcb2c4b3108cd193acb60a694f1d6983fe055521e7b4e5ce9e1379c93ab053226a968be6a92cb8b6ef4fdacf5e612e0112ace3a29ff72f3795648afdd5837b446b853a3c025d670e59e53b1e4252ed5d88d09f6e0cd416018afd11926cda9d55efc4c4eac8e6b25ba0f4d8fe2ee80ab8072f009edc90d0b170387c09ae4d88fed71148f10b8ac0c8c08afeeda6f11a27a3cef791fab7fd9a86beea4c9e8de5056aac3ee2dd439d119b36ea183cc2fccd4dfd663ac7f4f4293310e76f2a03193a2615c48942f9710341ee0b5ce51858ef545418d15e4af77c09f2cd30ec34118243002a7cecdc09b0e7011600a2d0b66d8e734a426979e662e0aea57d09b38dd49f6a736c6fe2f4575eba19bb9cc8bac8167a998031b97a5ea7d6a2db584e864880ac5ef5a57db8e473884ed0f74ea33788ac5272b73f540ec078ecf779d5ff48aa3f8ae8175a2dfd76631f4f9ec5675c8fde291045ac0e2bc6c1bd55b8c8809079ec6af5adf3443d7c9557637508309ff9c37a81419c625e56fb85e7a4f351329a3b7e7d87cbde564946c56cfc2a9d070193e3faec309d65c537aef6984a7090c18bd0bb1e637ff57009fe02cdca2636a12931dab976bd105e44292c2d5993ecb8ba3ed3fc99ee140b780c8b74a35ee4f34a3a5168e6fb0def5baca01a3d07c7cc2f7b09ac7ef28eae184185dd2e5f62a3190bef569c9648a77e8b02f584c9d167bdfff00186189acb462a117b54d92f30dc30acc26c56b59d79b8a911430eb775cae0423893de4b43209b77cd4efd42562f4c8f135a857e7812755bc8d7f1691ad0d68e497199710f5cce0d55b72baf4eff143ddeace2156e8360ddef0cab977dc255354494cde591e35172a7e1b5eb1094c8adfef44b29d257e6731ce126f255e56493b456c7864d3668f26a703b629f690bee6455a7a400e6a55425ec89de38d9a8c2aaf548b9e05c9400d59339e0e04195568cc0b14cb2acb8daaf73972eb2895b05f1b59da4fa77a26f9a19f707e5e804d26a4819584f2de1cc94eb511254187ebd2a76f48b504a8eae55ba30c56626914b84bc1c4e9d5450891efbb1ce3a171656868fd96888ac942e168f97ead2b7494e09fd88b323303a1b1b49789d9629b82e522ce908792668829b4d8a4060ec9f4ab348a900195255404582b5b7d9fe034b063d8bf9ae85716cb98f9bb48b0127abdbea6a2cd1fd63c97633dff1ac66559ce6f8030af76529652c1ea35ffe9ff08472aa9de9a29609787f364d7b49d600d5047a978b6929ce9eeba8b0fabb200246e123414e6aa2c9421fea36d1e4c0c3e61db8971a5156d13578103dec9607da59f427661900a2c7dc88b09cdcece44843db2e909300372e6f881d26a8a76cd4301398e89845891b08ea17a56dac0189e1dd28ec606fd1c3f87b9741c1bad89820989aa83dd2527b2a55aa665e787fe2a5a21869162c43b1ffedb9ef3e8d5e325d18044fdfa6ffd7abaaa45fbd7e406f77601367b69d23f98a5792525aa044b508a61e64e8d468b7c38ece3f422e7ed2e789a6e600603564bdc79adad38fe8e19ba140d024cbbf8a93b830873afafb99b0e7eed97be5a8597c400e17f335cd2bbe47e7bdf7f38fa183e46e02ed978dc627c999a071aaaf2d8d2b829f96269a80e68e1d8d26816437d5de04a400cd144fc08a31ab8c4825f8e397fcf9801212161c9e237b976f52cf923384aacacb1c577b75985ad96b046417238f78e24ff565b64be4e97fbf0d412e05ff805a66fa10d835b55ae641b26b1fd54627ec63c009cdb5d324fc64196a6083aaf37a2f39bd6f794661c6c0692418becbbb28fa25f3a340911d25a031e650d958fc8b026d6e1e2bbd8c1b2b8096f76447620934bf0ef34a0300c26fa9561ce78667f84c68b164574b50a0218623895028a5824fc6bd5f563d48c425b11aede21abc7588563cfd26e28e7c91f33918f3a83bbe6de64197f5343daf72c9c999570590782f34bb6d1ce04dd3d4672199b40a28cfc0ec710fec23008c39174dec9f3ee9102f1fc4a60817dd1502f114e1e8e0a3e0222edabe80b761df1628926a02bfb3f9e99d4be4cc49139cc1ce533723edae815e29ea0333a0030ad5318dc3cef2ff468655f933d71839d002391c04f4ea545c17c6ac6e06638a881c39c73d3e5a8da648e2cd7cb2793b78c4122ddbbcb6614c92ee7d322d04683657499491bef7369da0a29acc80e82c13b69df50557ec6fd54f4403637cdae53964f881c8eab290cb66d64e3582d6029999d743071e1dae7ab4a8d864b3d9687789b2280d3ec1548cbbbe322e591140eca1e296062fe77db1c344f01a16cef291751236345909ff29f19b1d2606d52d174a780999e03393f94c14fc703b2ab75b44205d622ada805214e4be35830c4ab45522aef14e2ab6daed2d68f9b1066c777bee210d925b5a8e42f28b1f1df3f581ef8fc49528f4a95d475de664fea8a618857a7d979379dbf410d05b7a5c079dd0cf73c650aa43493faf3c4dbfedba4ab8ded2812e1d5407eaac28c282d800f489cc9ee9dc9319126bffa564d4e4ebb9ea397c1d2c1d5b577715162a9a5b86cfbd9c8ec97a065e0cb2d735565d09b664780dc57fbde684293d87cbbd525038077fe593889487d2ed672df71fc1e1692d92bf46e691b373c9fa1b424535a6b18294cece50ea48b4d52b3f4479c8b80361ef2183b6ee6c25268753c658ba24bcd2ee8eb7561a522ccf98d8422570a2c6de37b62d67bbce045c65cf2cd8b430cc4cd9c1db38b6328db0a097097414f23b18e1a864cb339bb832a664700fe5f3a3aead68e6a832bc0e9d282181c241cffb262d8d5f9578a44595e89ebe84b2df67cb5364a0eedecebc202fc84f10e5b1ef825b096ae973390d1b28a9a1aa67f440167275318814a2c1fffd0b47d8b8868f520fe52348e2eecc991c1c7b9649e4c2cde79ed541d3eca448e30b4697d01fc92a3f5e3f87f01da2c55454b53cbf8ca610f991468e938469602970f341f5f204157919bcf04cfa75122967996eceebc36ec7d3fb1a4a7f3c1893ce15ba7253bbefdc1bddc7507e949c586f893ea3162d396a15de795a8558958528484af653e091e1c3de12552dc41ccf8af8af3635ee5791816172b30175af72e13bcf29071043c7a5eecffa1b8314a4dd05d84f187d6cb41ed454c3ace7e4a873e9969097b583101941be6d587237550d2d36a476fe597738aa053c1c86864bde287a88e10ddd5706eeaf2002c5d036f68eaa602c67be4fe726d6daf8866188ab84c6e5fe55ffb21d951a9550639b3e8477ea01dda0a52d113871f5f8331aa81f185a70caffcaed310bfbe35c4a6011e594397d664cadb3e1d525e37fed4abdff5f9aae71a711d01e6488a4a1b1228d3feeab886e74eb67c3dbabdd8d72237ea92ded09a1cd73ef9ed80288a9baaa395124b2525839dec9f70de26bf91c31fb002160fcf2e204bbfa76392a860f95a04f00a8985b3f625afecd37e9b3fcb425723132db22b72a8b1327f03d074e7f55f06c4c18ee3ed6375d6936ed14e7030e9c0bfdd948cc68e527080b91a16246e5d1fd847e2d49fcfd0d3ee1d8f42ea6bd1569f65d1b4218e876139292394b15bbd3fa0161fa5451207f2b369d727e8b0ee544c7a97b24adc7819ae88e23a920394c2393f36da5947c64ccf0afd326cf575ffeea089092002489ea407afa688ed081e4518c59223627cb74d6033077c160561a1aea9c6dc22987876bd451a606c4487cdaba161b1dcfa193be9f2c5e0dd400345025fc55ec97b93ff2936a5f852bde444d2a0daaec3bbd6fd1d724a457d289d56ada471a2214db1cb9e62da3197b6d850c49e6bd108eb3fb6d3418061037f551c7a80bc2fa05b80b9768b3f8d5a28ac84deb33084ef4c679d834077327972870d05ef582af1646e6b3c398480b9310f6954b548d4cd63676f5b475f323ce59a6ccb2add2b1ab80e4f98e98a4b541e0588400775b79a5447d23c630f2f57923c0c779fd540d2df5c109807947b63be1454aa7d4b25627fd4458304d01f84dc8947557b59e8c5037c5c9d708ae35c602ca43d289553937e6f95b5f9f177ff7a825840a4495defba226290ac56e255bb7a8b2c94931f59d51eb592f9a6727c936088b732b98327b9a57f54633c6158673d506d70e1443906dfc23168907ca9a58749f970c097977540aeb8f275bf4ec4d1fe1540dfb953b7281d515469f424b2f1701e6b7207dd88440b6bbee07fa47d73aebdc8390f04cb382b37df5ca3b58b8e1dc38d19989bd1dcc504db5f569f00b1ad712c1ddfb1918f5bace91815ed3415dcf60c9cb8e17eed636ef7071ae01184cd044d7eecc224b8ecf878212c16cf8b662aff9a17da4d7dd836ce564e5f87eb068b6d9c1b132397d742f9b606af04aa4e888a631acdffa6da6c0395c3f3a4c07dcc5cb67149f8580697391ba0ad2cd1a30d6e9ea61df33fb148fdcc098c1c64cc2b062c6af1ca31d22b82400abede3dc826b5da55a5faec01ac90739b9c44014b30cecd6b0e30b9fe63ac9c522083f2753dc8c3e907cd13620e0f70bf0e88c321a9c5ac2180ccc9803c0d745c20c693cf120ec7b74966a99fc19856c007bd7b1d0eab365b86fa6f20c14c6e12edd925beebd0e0ca20ca2467fe95fc2eaa463b1d34b8b2f9f229a64ec9d297a9947b96555a24e0b144daed95621b37321d72c03e22260a7089979ba49f15107209ab4f4334241d81071c85f97a2127f97b101bb099107b2bcc8ba40a0d8d39cad266c45d0413381ffb07eb24896088a1e17c06a87970342641c23265b7061184f0763e765788df7e773e96ac8da2d256c8bc171565220489aa398171738fb6ab2d1a10329f7c9be33ff405a7b0d4f06896bde45b80a39589a17cf0deea6d6e6d25bc67d314ac69f5874a90c6972aa7fdfec2ff9c7f5ed028b6723a1bcbff5fb50bde8b379bcf7a5f95415cc10aa72fe0b4b98fc7119993eac81d688e65b9a31a7fdf2316818336a6c870125dca88fd6650934df2e3ac3853fc3b413eb9cd4e2c7ab3ef8539ce179b4926d97da4f25eda5b08b323f274ab5ad19f46d4b24b02bd9420238698d879860a21a5dd3bd38f16c7119adf39cb5d11e4ba0b088e024a71066b19de60ff13e196aa876bd381c1cea43e51bac2717a24c3012adfc2c7299be0190c2a12eb062336ad489e1a4facd4f95d6f7e2d69186974e3e859fe5418380ee1533b2abee501ed21a065bbd551b87e1617e8941d71f1fafd60f2edc7edfd7392658a5799a10887455c2167bbfa5119b593e4aa006e9474e9b26d3f3504dec771905af4e8ef093a2f4593636856f337b70685ac9c3a41096581f087f8fbd3a2c14a0021e08e490110e062b8f5594bce4dd60707d7c989873aa5510236b60e36ce5635d49727762d944df51b0c54eb5576f1a5c1dc651049a59f87093a7c8cbb43ba7aa5bc5384539f0a5cbf58b69c7c0994f7e7e9a962152be045b727412a6d4acbbc21f715cd8ef44e23ecd140a03a448ec3bd66302859d53c7bbdaf3166893f1a195d9c0a4cbed6697a31c1269e65c9512aaf596813854b09002ea0f81703e7caf398cd2b2168f8a4cf2bb2428c946ede4cf422a9c35f08b49a9dad0be963305d3b4196dcc156b44c1f5623539f9f7d6ac6fb91ec811c50aa046f24170a25e49af1a26a4c0ed1dbe62110052d58a19e1c6d153e193a0745b96afe24727d259e9b221d0d64f4630e80b43a305eecce5c5fc34b111e06ed40a9dde5d666b198d8216dead3d82eafdef4bc81a39981dcfc8cc0d5268c1bfc6f25673de0af32d27a51f1e7604061508decf6cdf632fca4ed32d60754cf4d3ce370d502fa8ab37775d37958804a34d136e15f1d918381584a68668d6af02854a49658450b9b0eb37752307133672dff79cfd8a8402215c7ba74a5aab59471f29c6f60723aefeac6cbbf91661ee148a55f4ebbeab3d85c7479995cd1f5c36632bee8593679fab67c4a78720bc364711181a6bfab8c13d0d41b699a2ed9cdb0ace6f77ac30023e13227ef843c6782ceeaaf4e3d66567eacb991fd01b17174102cbca6a5b39a58bde3b9d6a22dc9dd996e9cee324af1e8874aff3b8fbc411f75c0eba777b1ca4fd6c296199c8bcab94dcb41d7529fe27e713f7b1533a2f264fb28b49f849cd543964ac353fd9424d2978fe075a3789877d4ff0ff20c8583ba0142539ebe7a205ddc604384138a977dc025d677ddd24bd8010312ea5f8a9f5ce5c19c5ef781f09b321d77d4856775f00d3af97b8f42bed1a04b9b083caaf87cb142a2c7a76670a778af613da3ffa4e2064ee75cca283901d8864da760a1fce63606da558c80fad2416598dddbe73f751d6599d6bea26bbf1944d3689a3e5ca3483d464f7709e26348791f69dd15dc754811a585f306fc979339cb11fd527da0a28457c8b25b14e475ff9e4c60548fca5a5ca395ddd9f13c75fdffe0527768e82eb473fd4b90be2a0104f93b410826f7117e145a3477a829862a7c9eda5d1083007dde54d57056e7e8af10e10698cd3f07e1b48e09786f3e86cb667c8c423f14bd3e30851b516a6d28abad4ea7183d15fab5d7bd5106f38ec72f027108ca0b41119d5c860eda98fb07d59d02716d982a89ac101f196acdada16aa039b65f12040d24691b75e797aabf9af1537fdc43161df57162649da0f8b435e0d7f9c7e4f89af91d9438ad2aa278c341b7cf92557cf36f9fa36cf7dd58f0d18f9456e8ce558152eb99c62cbe3c15c74f9916c303e7b8f18aaaa16a450ba2cc790bfcf39b528d41dfe3dedb2a859b77ee9aa2b7ed8d08654a6c471661624fb5868b44092eec481741e5603bd333f5d33cf8606252aa17d5f9c8459821c61b017c8a6fef81e3d875da899a3a12aad7013d8fcd5cc16821523f663f1bc374377ab2222a5734b0fe669c42603c7777e3dc19683fa022844ac260922a81e8787aee1a6a731196a18a818f55a1ee649e668c9b22a298eed4de7a5cc66d255a5ce013d5a2541f46ed7ab9e6580c11546e111dbbf032005945a3136b19c0c5b76fd4392f5b08515c2fa8239c8aca06ee51285349f9f65ead772bcb2202bb4229947dcd489ac677e7d71b347e75247fee4734167b63efcc4874b7e513b401cd14129f6313c29c9cdceb8b8a83e137ed870b27d0e593f7165f298e2a5f2b5a5f5c947cf906397558ded8774cd6e72a49ff288702a8b7641f4a5cfa4d85fefeb5b0bf27c48a2f53490cb1027d7bc74377aebf361bb75e9a258832f8cb0c204758947d983c902b6785bac44c5eb3716fa77619ca7f92f66497b85e0d6d4526d38cedbb801da9ee214e27621f3c1c5b2661c712fa74b1d076d6c69a288d7f975246c8161e76b936e04a5136686f49e22c3d91566bb08da999ea6fe821f5923c90891b8f4083471c5ae9f15cce54845bdd349420f6ba1e14b1b672129484a74f86e5e4bc1e8cc1b3508799dbd58dbb0fe04c3207bfeaf1a77bd613e07e8b117710b60154624a27e74818e2cc6ff0df22a53c2125e2489fc827f3002c781b37f876f9d4ed5dd33d1917e4da66e06df4718ce663c024f2abbdf7a9a57a0e395dcb8ed8cde3f35a8b35693e3a4c1853c720273a146db9ca373b7cc34649e931be0a09c354b5567ad44040faefaeba2046a5282508f849b8ba04f6441dab033e4d57087266ef677dad3253e233878711439626df4bf845f3822e235c6755db3827688ed5d73120b1e3c7bacc582a98206bb583a19263d9b7d83f89abed03ddee608d33ffa158e0af155d3e0ca4702d939a90d493732925dd1f292c76f2d021dd067b61795aa0d03ab243800101ad24fcb7c9dea5dca348731031d7d6fb09c5b5ddbd08023cf719b385b878c6c39e5e605552bc232e92f0a62b8e775bddd776d31120883aee6589b14413cc344f559d8df0ea2cb23aab9a3fa27cd25c9075b4564bd4a72071b3bf8452c69fe151e1c16999a01e48870da30b737d5873cb387f5d1f94f0e01a21fc82af315d8055f45e6a0666f2e7578bd0e429a8a5d25c4cf402dd76845d07fac4c126e7ad0acb6a995b2bc3c1c5d9384bebd54eff696e46f76e74b7bcc9c074aabd887b2932b0898696a512abb994e9bc6fd39f5e95f384721a5a78d42ff213c67dca6e911e72de270f76b255392e09f700d4de67c3665ae4eb8eec1eaaea267920117eddabb60f0f5f0b9123eb653aa08e0bcdc2669087c3a7bca180e4fecb8f8382f6bd7b933819ed03add6da2024653cafa80a223bac2481a0991ad536d354088823b68c00c70d0d5c288ead9e5dcadadc7fe660cc719ae413caa72ad1912839fe829407eadb834d9d29a83e0a141d7fea2de644d990592c61968cd25bcf013e21773d3b5543bb9676217035aff12919c8659eccbc137d351f2f70b30d2d162fa25559b000d7cf3dd44ec5e711","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
