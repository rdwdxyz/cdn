<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2227e3295ec720c2ceb5f1f01da2942071a15d8394a6af5e49e0b444ed19a70b17e07fd44cfe0c2f6ebbc66947d0ad0b5069c797f6f4b62e4d9e68ea4592b62274a3479ebecb6c4ac4f83910512f44f74be6682edeef6176ab358a0b2357dd1e56a505fe4b98b5a795cc8c83b73c3891f3d3e0e5418e346a14208971f5f4a4c3dada42857014b31888c3de3a4ffa486e7abe37438502df692481dda64fa36794456d9f8e779b1849672e9ea7383bf49357b3191e323d91931192dbf8c19fa2efd92246dde11d56331e0e3d626b2ffa1a2bb4542138e7141b02398a9130e77670ba151a3a0c147c85e5565ca12bf78925cf3601ba2f796d37ecb0878eba77b94fab876ea17a30a389a84948b8a3ebaabfc1e4b94cab7b05be1100a58b9108aca3016992bf744175d7048550b5fdea39d0da286b64938b124717a0fa0310621ef578f9ee167010f98a3aeb4a83475f1b911eba4e19a1b5a0620b703cf79dd9ed81dc04a83bda7edb263d3a0898e4e6cd8b3a4374d23972f6f3b9df946f5cdd0e63bd71c66720a399a7d990f1dd21815c2cea358a5fab4573323b30c21ac5b0093cebee2e960845a400ce129d990cc21dd701059609ac028be8f7a57e703b977e6a9259bd56cfffa315b29df025fcd3176ced37325ee65fd2a99d82094863a99bb865ecf4225f264017e0fba570766a24379e7ae57c225490b37df4af0e3b172347093efc51a8b06f153c44b7425587668ec82746dff02149ccdc7edc7c3c92f4ccc687834ac6f9a695885a0725a1db20bfbf1a41538ad616edc3993e55768a90540dbf048224873ee4b01ae75d7af2d2c2ed788e7d848356e2e86f4271af1eb5a537d59b890289092d21653f37732bd71aa134126680b6d99cb5218f847faf5b27b119cc1f7bdb8fa630ad8fab269fc21ede6a2997014cdb6e49148ac9b2fb4ebb57576cf2c51551bfe85793fd02173426fd9ab91a331d476254870e246dd2d40b83635ffb1efdb99e9747246113aff0eb90ac0f6fe8dc7f7991eb8e1accbf64f11408c36957918c8d1b9c6639dbd894ea780d7c026c2c967431682a1d32873efc16356be86a5b6de3c37196f1b35b1071c74660d0a59f7478b0432a42e815467f6ca219f1126826f3a1c6eb43e86887c33f42a680b1b1da9d04119841e821c54e94999ca23a3afe50ff6055a5fbbe257c5c9fd9947b660fdcf75c96df0145287c8e0a53a32cc93f449f5c6f4a4849b7410423af8c21de98647812adb905dc18cfe5e66e5e53ce3281ba011a95f660a1262c64f9e6e319dfb32cb8af14b6aad7766b8b0540f3c164dfe773ba4bc9b3ebe68fa73911b5cacdc864eafb56cc84dff36cff7b41ea4908e7fcca602d0c14196aaad8b198d9705346baaf0acfb681765b60e60d2b1acd63a333d8206847b5179f65d907aa9ab0ee39b030c6eec8dd2c773a302234a014642660d8689458232d815638221d3cca91ad8d9fb562d6163a823d9dc6875d8bbc7a311f1dbc99b253802669620a39fc17e83cab442b391ca42b2431c340fadecff057efe16b4b4caf919411bf97f8fb765d07c8056f22d932ee59b28a3f74aeba84c184fc842b144f0473c65ed695bac0acee817f01e497479d54e0aeddd565468cafeb09b93086d092ed8a02ccfafb2780892a5cc9cdf5f2970938cc0a66a97c06499115901c2656fce50ec7ceac094b9432d1c3d21630d1e2ff73f631e6811d6b470722e3a00f74f37f5333112f28c61cf604ad7151c241744c11802a288d9c8000d525df968513618de2f8f3b1cb6b64b3373de930919991345c300bc1d24b3459956f78e16dbdf8ccd89d423d14f2c6e97a8c3924cd2593c1f24b01dcd0c1450ac8349ba6ca0182a39bf0f74f55a447dca24d6cf503739bd59c66db2b99485109e85846f5bcfd39f2465308bf2864c85946269df8e5d089b7e297bf1e7f9539064150a9c66e20f751183ad5151037be8ce0e3add15365403cf3fa1b68406e7d23b454592cbd59f607362dcdf149943a9175a39ea5509106c2c597ac19e6a0a367aeed5d0e3303b6dd42315d268b8cbc037f2df9f4292b32d7bbd0d25bc4a26687c435e7fc5d4b0c258012425416dedb589af39cdc97e199a5d2d1a829ffff1bf3dd83846457069b3b7eb3e550dae98ce9460af232e89c011eb4b93a253519e7c820d54e12395d588b0278104e1c88dad68d65a31441fba467bad7cfc1910c5cd3256abec92771a2536f3a6aaa06d704fbaa46842eb4f88a51f0a13b5996769f92db48eb3ec9f8b792534efc5f2b859964c45cb5a38c9eb84d13a86a861882be691580e242089f78239ee7328625c23f2c8abe9ba4bef6fbae32351e0b435ce78c0a19774c86a974bf3351a59afed313e69cb84653f6be4e81c464419a8d71d96281e01d5db0f5b6645736001f264e8ae0fe6134108b2248a602c1b158b1d27d2e2e6120a332c0cc85ea6dbe75f9be4f6a26183e16dd401b52e0153d48f1ce9b221491f4916e78cc400f6e68ee58a90e1112926eeb72194f44a65e7bc8c288296d3c79326065fd2917d9f1142f05aac0ef07b61a3cb2d63e4f53511eb77336709fee7e4902f21686d40b9b33765a0c6eb281513f965d07fc381fdac15fbe51cecfa079a7a98ec8ba7558ac1b150ee7f15591070b5b843ee2b9de9a734e88eee222f81444bf460a60d6631a6256a611533096ecc533c3e35bdda6d3c10ca72cd93763fb74b47390f3af907bafaf2a5a5ada7e13928fba0ca5a3be03eb24296f396700fb6852f669a3abbbc5c3e18567fac01805ef20f8712832f7d26b3a75e2acdeb48f0f8d85e480434be224916c246a022998efc537a2a9dcadf9b3871d574bbb9903772ce2b20590d4eddb196a093c9d1269aea4e9de8f17d685ff6c14542d25a352155bb5d6a27a9cf603d63df8774db1b894fe2e78702b554b73040e038402bf063fda040411e24b38e966c2234242bb2ac24b21459ff8743c29e39dd7f081326009aeb05419e8d7e2ea98175c1c5cf05bae3e6b6891fe639b60e5e7c125a58dfa02aa146cc25a0ef0a33f08cc6e58d2612e3b314ec03e1332fcb921d544ecae1b306c6dd63305fd25c2d0970e085dc79573fa0c33d2a90088f0c01c08cd83ded5224e5a5a026b1893d70d32d4830fd8ad99bbd3652fd2653ced1ff3932e0fbafcf38df3b4a111bded028adc6490218b52e16cae1f26ac2d6e866ff27306f1881b378e6ded318c647320207a5f480f038bcbba2ec2a631f97c9a18ee29ff609a9d4403e2d6075ffe371fec9fbd5334b3f4c5b8e2a7470338bc91d01f14d2374fecdd0b9a5e863833e3d519271472545c3a3e99831251cc59715e1e2871f63963357b5f25e3324cf1d402645309e1849da245842e72bc1db0ee527de5432a42e4a717e9521816d851642181f87fa93ab6ec0146e7f5257cd1ed615d88415a93db22c6b94102524de34247854881d7e8326b67ff9642a52ee8e692f9efb381531b9c156cb1b8ea5979632adceb9e3900a1a37012ac5f0322fd0c1a3df4df1c8146572ecc5c00ca29c63f06df81ffb8bdb2668ec28f61e5922855bacf56dfcc5bda05f53e33dc1f131bb9b7c648bb2faed57d2402fd64ba31b40ef131f8a0eb9bfb8a09a200b367a0ce85619cbdb293e736a296ef3872dac002fe447f88db57b5a3b0c2cc3efa458539a6ae87b283591cbbeab0febd1d9e842cc7b49a29104519fce8cd2728893dd5f4d679697576147dae63b16f4dbae030d629565cd4e2d5ee77b0826f9010e1aa205c36635fab0ae0bbda544b9e9f220ec6698c05fdbe03390e62e4f0f9e5ad56f5d0ba105a242621e3cae1e36add4c5a51d41226b5ed186962b612bed11b29251f335b97c0149157164c18f8f93b30a0af6fbdbfcbc7926b55c705349e596f1bc5f77c0e419a7d90caa2808c6370ada4995411a02db37ee0f9e08774d37ab5bf3a45d65ae6c91a60b28d2e667d489e4f012a3de5fa1a60f80023652caaf923384f6155a38f5fceda8e55c964084f8d680a89362c381979e5d7250aca7ee87da9f82b32f8e80de6974b1e8c824aa5f9a5ad3a54a2bd76fbf4b8edc99313b5110fd5a6b3897959bd9396c1f47be86419f838434e11f29d6b80da78ee44aa31a23955e11e678b5a1701318cc35f4b9fbf2637d560b7e408c12bc8f8abb87b1ee4cea7ab7d15e2544c90fc233aa2683d1d910378675cb02b924d950de976ef5857dfa15ba12f1ebb57246ad89e016a0ba7ab5d9fd4fa004a1f5730bdea634ec66eb401608e521a287447dd3fbd7fe50895394cd32c2d4bf4e93676e35567c3359f4cba6019f30119c59d7e449d1b3e06e756d0a9261994ed1debb6cde7e85a39d11d9fac450fedf85e77b3a2fdf058b92003e9674d312d227eb67dcc5fa49fb1dff87041b8ea6a44f6ed054ef4b4e271a8e8fbb2fd47f155a88cac8af1cd46d0a6ec4acbdf7cb374da8fb6397020e04737eb3d4a7df979cea875d8976103ff29573ceb558db797b1727de59f8dc71ff8ac99820198b8b8b8c24ef07b68ffc7990b63ec4ce491c9609f2c2b6595bb74b98dc691e7842ea5e3377eaabea482f5d750fe5196464d526ee47dceeb3e5c53acc13425627b8dac2d7c8dc9854687a5c2fbd43431160f2761b030865c1f6e58c1c6148a89c68a7c77885b3b57bc41792d663ff34ae514ebe28243f92ea0ce1fe4463df4ea29b5743104ddb064bdaf8acb013b6dc1e90ab6825c53f90481078285b0e55e64f8ccaa4db6d98c74cc11f9a313528c46621f73a822f249e41a6d703b7b735abab529d1592df3db72d6840fcfcbb35aa94935a58605dbe6cd9949b9c6a2113f9398309083c00c504352ab5414aa5b0e10613cdf870aa0c03dbe9bb579b78dfceaa3b11a16201b9b96cf59704357cc3dcbb989f6dab5862d45c61fd2fd0b2186805460447ddfc202d39e09424461363bf2e8b126ab0a4eeb999f4b26810d82c56fdde8976d07b7b1d77e4f38daf9eb8d43ec95eeae6923cd0e9efebd57d08270975c9ff7ae2b390f02815ce85623647d436c3969bb2cd7da8e1caf8532ba3e7ff683cb3a41c5254ff37e2ef328db18ce704864d7e653324c6177084231260ab38b6c98cb821a0d51882782ee06d1ac04a22e6f727b88d693a6babd31b9080646ce294d6ce2890fba515855fcf09db4218566b80c189e4e5d265f1cb5bb02fe39f508262ca884cc68d4df83ddb1af83600e4a24092427429180296d99cec1af032f403dbc0b9950f336be84b29a68a66a05811ef23a5abc84a525c58a44cb79541fcfba94570ccb137aea8c0b109fd053eee923e004b8010e7143ecd9e9082e61b05ffaa3dec495a7b93a4cdfa077b92baf18e0cbe5000f490a29b70e716b5c1dc52bba6254fac1a13feb40895656eb2eacf2770e5ab930f53e930399efaec54ef60fbe68d2fd57d51a911045f1f74e5ca5c5a9d11432f5e510fac4441905a09a25423043780a24bce7157b6dfa07d273858f77dd68495b2b14a3872c1a49436c75dae965c9cc59b141c57225bca66689e64a1aee8753095242f2af74cb68a3eeb22b139b80b02851da67308cf47738fe375ee34f44d0a93d68f54b74ddb675c464c40ae2f2d9da65a50aec8243e41b941f2594d98c7498dc243958743374a5c881b55fb04e74394c1d88daa875389a44c4376ead32a2ef0a95f9d0f8b699205cb1d4daa899c69cd8b5c209d7d81698650f77233614a287c34f763e9ff0fd5771695770e81671342d22fda341924d84e79b88a5b121ee0f05e317f2ad50c4ef5462778aa80a560042a04cde8b87aafa472eac52662b19e355a2e4769be392e52289eda9eb4948e41dd98a1b25a316359a62bfbf5e14a81ea199254ae41ccf8549274447a40b3d6e5bb2475a1ce1a852ff8ef20df1921d836fe902b0d388485194f3efd9dea81546022284162ff0ecb295f8b0d3b61e546ff82281707478db488bc401557f22f1f7b58a467a77e48c9bc355062de3cb6e217e72565fcd20b314a307065a315b48fa605ea0b6330e8c0bb615450708ffcc83a331368977180b3bca4ff0f9d95e1fa9e795729c607be60690992be909abbc2256a828615b4354a897286726ff0e4f6a1380f3588cde9648f5e6ef077b86e5951fe0443b13735b4277a9b9a8e31b02f5f00281d0be62918c6b2b325f60aecf54831f2858955f5ada6133d096646f0248f3ff5888d66547503589c6825899590ec1e81b3ef92dc390181c70506b5dbf043fcc328b873bb313638ee9fe7d199d91a7029c9340e6c638592db4de58b401a2e5efd34f3abaf88f8a3ba39928a213b57b7704cd89fb92bf172c0295e2b716a2488fdedba9b09a2d15a9fd7be85c5a69d2abeffcacc1b62a61dedd67b67318e7c17be88d9d92522d31984492d735b5300a1e7226fa273e3b04788d1dfb84658874169958ddc5d7b6fee3fdec051151338936f040723e82825a6715f1c40114741cbb7f9c085912a0de5f4ff4e9a5ebf4b47a09e305f981e3649df705da615d159941b889d729a4d74a906c5c3190cd9c8b693b016f95b1495efbdb9c7e0b9427a6173b55655dd212ab624277d836f327b87a531b546f62e038690209f4899e9e47e13123d39e63800124ebad3feac195ba6779efd260b2601d73925a6d7ce4bef7cc4b94f2605ad09bf073244fbce1bf5c80ba96c97343752147656a80971e39804c161bc9dceb35c421c0b43088f6ae3d62e75407aceaae4a9128481aad0e17f8c1eb79702c1ec6811289304e92d61b7741c5bd2055c47f54b51fb117e57b0588c861fd17a20d2ba823c4a0eece6a422b2eff9af8ef858c7d71b89c3487398e2eb103bb66bd9f2cb23748ebde91574c03e74c912b2bdaefd87076d86159745072074fb3a748abbfe067f6efc0cba7c6330433f72fa92bad26d661b009c0ec6acbd49eac063e9d96d7c46c0769994e1854b822af9d8ab1121ad7235ebe3af818a7ded8530a7d2f8a01373c8bc1890519e927bb784f92e08322fb0e96746242f385bda81a28f7dad64229e4cc32d662b6ea6fe9d715bcec7bfed3eaab0e300c23d725530ac6a827a818152020d002fda33da3203246c212e09bf6e207a65f7406ba979abed026bac4980a68d848d120bf35f01cdc7b12069922ba10d46e9a49814d9d1a9fef8f6719a8cc20f92d2108e517b479904475d7fac9acb6f9af38741d76270cf4be5de6a7ddeb132413802079854a355d49888923af946acc776d46abc083ee0aab1f3bc4883b13bbd23f24325c49e87eb2b9f4678cea3d0c974894a30d945e4b9d02be503d00bf1e3fb896fb2c45318d32045110d0a210c72dd06489b85184f4c4988b6d61cd8bd810d4721d89544aed09665f03b8ae47bc3c335caa71254ba7d3789266f675110685bbac4615d03b2c246afa257875d05bb9135e75f18f77c22e96602a0b7fcbc2fa534eeb477c00b5e830858192e4ac2d4b8078d9ba17030d906f6c24db3ae7a235a2c35a32734dd20b7c3f943374cee876b1b7f0a8cdc087900946c4b3cd90433e9dc88f3d71855e00287b362d3db4bd9fdffdf1c133bc25a4e472199dbdadb4df02deb49df2c8575720db21506ce159f49ddb7f856cda2a5e4a9cb0a5a5b73033744a8ca870f6ed3bafb1d55b74009292f4f86191a284a2402fcf7442262f2f5244652cb614e6aa64870b83e4a249c2bdc9ead627f857eaff6ed847f9044c7500bcacbda67447d97efb1f7bb6bc2b5e855935acaed1f47eec3ad5be0e6f87b5c96401c2aa748817841eecb244bb5c1363ad38736b175664965d2277fc212e5b097611dadf09ffaf2c0f10aea2d848e16ce0355118749a7e4ba5da6a3acd32c7b1d44a4cfd28dc35c4dea1fab2e20de145bc1d0b309021dbcb86832c06b5419f2414fa78b9ceb06c7a1350288b89b052cce45a7c8a1de124d4dc02a9b588542e7f13eae45ecfc1bee990d92fddb15c53de2dcece18ea1b99eae26ab3ac3a53114adaff7a4ff7a27f6c341a4729bdc14222a75c268b2a5208240362a2b9d301ecd062c9ce184e425d568f61ef4f10e110b43681416cb6c9b5c9299d1d3d598cd3ac78296718f0172d5e3b82c6b8bde4fc17e18f10cb5acce58e079de437a711253a03d06a05f40a662f4418b6c9a438a35c686da8f140f1eb36ee03f0069cdc0d8bd9cb7ba9b3ed909c0e47677d18cae1b9d6b8b24860d1b1c27b7c6598b80592188eb7fff709391918884eb468d38f0669ec78ef543f5531e349c2962e031f126c00799f454edb58cafb08324c8706a9add037ab305253c436df75baa1f6b937ae282ff83530654a0d5cd9c25ffdcdb5d49022284260d3c0d5359f7646caae4d215cd5b06845f055df9761dd872c29549c35642d98e8ef08682e75d244ec8f1a3e1639d9833937f7e713a0776c13d977817af47c7f773a62b1f2ea4e6758daf49a0e29c44894df05b135066a8cb09b2d5ea9022d6f77a6866f574a3bf8b7f6d210a3f85747cdfb3ed1e4a04ad72696749f953b4bb6bc8fb670a243801d2eecd1ffa6844dc9fb311e69fd7b7e8ac3043dec225872bee3aaa7e8442915432d408307263167e043b8faf02ec2b396381eb23a0d45b0a03e8d47b19298a139f9bc191ab3267b19a77912db0bbe1e2bead91103abe29a5e6b2e36082142442ee896cb1f9d191b497e82f435f34946d0944e9643671d9d4b3f1aee94adc35720e3fd7e74caaea244f97378a74f2a16837c1f9e9cbbc1f60ef7b03880ebb53d231b6e6d854244f39a85bec5cc7ea32ff6f7ca85d23e5a746c805a1bc98e57138beada676968f7328dc0f7e3a70780a719b0886c9f76904b288f78ce36905a48c4f3c9a198406d695d949598ddfb40da811de84bbd16eef8fb76ddd265065aa930458807e568f689040d408f37b258e2685ea74788a68957248b9647cc9be68e4f8d1c56b0244b4a6b3cfd7ad2f901b392d8d49205196f2098e73e24803d7c0aba337b0909318c24fea75101de47f9a5b2ac0aab53a795b446755a9302cf2c12b5f1e6fe79d69b20f7e6775ca6675a03d523b33e538a7be58d1f82aaa0dae5676e7a253abf7b71a946dbcd3d9b2cb67f370dad384977e8d4771acd122eab682fe0a35583665da16c4d8a66fd9f416b6dc84fe8512e84ef9563981749eadae6e984741ded8d39368ec23079372c011d4c6e73b9e3b0ea9da8afa1eb5d91660ca269db2d9ecb7f3b8a771a64eebad86e639a4a2a35080a7a95cb900238029e77fb83b8e045ad0fa92d3e12a080b2c9805156cb48667c966b81af9b68a18803b23c7f8c51fe77c8a9263b171f8d55e50f886d60cb328603e05d6c5726a210d9465fcfc58840083e9c237029edb743131d9730292f48a2bb80d29e3ecf9af6f9c2415e54d58d9dea904a498e716ca63786d7cd98b92faac26a067b87e6a688d6f6e5586d497c903b5566ee0179dfe25950a8c44a028729c8615a9390afbd6da8325ee6dd92224cb16da7b29a1590477c838c5f39c39959583dec3d9263ea1c5c40339ee7628d3aef9956e870eb9a11b50793e9684684030c998c1dc3801c0566f0b5f5c2d78eb8db5a248212417c6afa1d0d96e356fa179a41988c29bd2772be16fb03914ffbba0c937d245e7caac346ed1aa0335947e955f2a1ee0a9542b8c01df1bdf52b71b0426ef6dd8d0e999aeb781f17adeec4fb4aa6d439e182a0b67a3c2cfda004f498ae9584a5fbf4afd5b7542a82b7d03ef1d3c952847f4549c0d1770b2d9e5169241cf59cd461376e8001a6fa1432141b01b5698ee915f7191849f399a2b0869e1411dd457684b2a275accca8e4e12ed379c27ed30a784eeeb2d596287d9705ac5ada15f024417ebc854e6741e55084acab09faac564120d0da2ef4fe241fe5b8dffa9ab76915592d840a168ac0788d4413cb588a279b635e274167397009dc78e6bf90c0ac40fe0c88b2e2e65bb63595c70e2f0d34e37026527a737f0376212a58a6c1282ce37c10357381fc02ddca48b5dc55b6065b717d1aea09750506519012a5fb48b7058adeda85a3f95763e2120398e0dff17fa553ae05c930e1632ad0e01707e107a24da7df3e80aa91b01eaf9391549c8b8b5192112a790df2b53a4d28d56712e4e2b9285b1475710717421631f70f72210079b9a14181ec8109c085a473e18209d67d6093b33349fc2bfb295f3553fa94a31851a6e41440edcccc7f16359830a09ee02ea4f2a160e1917a4bcc66d94cacf05ca1a96cb28c4ba30b1d52b3ea5a20017336d1245c3b94ca8e8b703e9e9b9482726c574de0c6e44e06a8942d78856087ccae447999f002c5e1e919e2193a35ef04262d2b7cdbbbf80f53e7e3b9397b866325cd4ef475fb67b0430a0aade88e7242036d2fcac56385d1a91989b118585c305a1414b3504e8449eb56439a20a662f0996b3261a407cfc6f581f9fc7a5be439b81555387f7036cda08f5098228c72ba237cfdcdfea8f984e1909fc271053c739bd99b7914f1c019d594b777409f52c1c0094f9be477e61d1e44162a1ea23f7f5487c186c5175f89e4ae527a78c673cf346dd1d9ad2d5d0b498079ffbddbc53b271b28fc46fdffffa7c18f56434d033c930b4b4bbb85935ff19d56601482d90bc06ae16779a1de1ac13544cb067700573297a59541bed7919b90be06433d2b4bbd1be5fb9abd6fc5c42bd47db879e1ac2084bb9436a6019d28f3d3c4c2e4d64c71e37b4842e4dcbfd5dfa93029eaa3b2f3e01eb7567db0b2844fdae8245265b82a984dfc301e9688eed15da2f0f8a696122f49343d0339c2a472ffb1abf8daf2048945852abd82c38d351f315d2557d12d4aa2733ffdea82467059013dc7e15f7f527e30696b2ee2ae39e5834f72e9481f691776704aeae4c1ce9c98a0658d659115487375ef2ad0a391c4032c4d2970a295c1dbc16d6bda727468c7ecd5ae3f46a230bde015438d20880a4fcdbd915ef2ca6bd0e485ea89a2bb3a5039d9e78c8e5d63620398d16361b47677e5be5a6d312d037174b00305e36b875280e8e3d2bbffb29c47ee91e54bbed80ce273cc18f1cab01884f908e6a3f45e4248dd611918845d3a02e4329ea902465b33b4dcc71e2a147b056512b40ebc8bc8a1932e6481d48cafd63788c96635acff2ecba0918035c7582e7b988457000a665fcd2ff7024c4b1d60d0374c8523205bc5f86c9fc2563354d3386611669cbc5e74da1b023b29400387e4243c559b3a336c28a9c36a14e7b07bfd793fece941a6a78974b57a7b89536e5f7cc385a86b2c846374daf79f019ee095c9290e6aba2af00f1039f50c312596b0e6880f93ef2d5c58a7e23e1aa3b3299c618dbc7c387c432b4f0f8dae8a1404039526acefbb35bb28d5b6b3f53e8bb7f20a2b2f2824b57fd20706aba5af6c69acae4559803022fc55a65b2612f4fbc28ee851951881b7ed9f84f0f5652a67ae6d64fdbdd77133296cc7ec76b97d072f7d59293bfbc30720bf9654d02becda5ba27b31f7845fa9dbbe44f1cc6c57971ee9caed19bb482f1a1ead832c7d7890f004a33e09cd0479f589406aee08d3182aac091b68044260e7a1bcb00f0961fe2d2a9df3af2106bcec7ae05ea3acb6ec13f57180626468211b960be7429b258881a7fdf1a161803d28a2650cff0a74abf2219cf3225b5539c006e957bfeefa4d7d86d6b48047f962d406772d2e9182f9e8f6fb2789384488dad4ee8841aa5bd15e9c24a4ac60e0e66b97377cc0d5f173978b744b6a55c5ea28b5f6bbdda4422850df89ffb0e183cfe3600bed2d81fd96d2542aaeb048f8e075009331dc3063d612abf7f63671b0236cb7811335a5557c02f29bf7f93363305f8cc421c9ddad76605865cb9998355e369c08df65e9ba337b6fd9a80664f2695e91b0d6b9524df5f309db7739cbba3e50d09ae265b8a10149acf88165105e66a52c9d2470e21ba476304737111ac07fc83f7f0dc785554882a387636ac0607ef1cb6c8b06f4d8c081097b8804c101ed6e918f88a383fc0b157225e1dff318259587cf8f928f6daf757660024ecc323d753feac3facdb04ab7eb1a4d6d13b407121f14a8fed35ad7cfaaab6ff6483c1a20e3fa2d290d11275b70fc4bfc742f4be65c5173b68847422729ef1fcf8f00339eeab9fd6f476ea1dc04f2f64ce1b5124e7ffb33da68d1f086c28538a98f28a0ca2a08ff60fcfe9cb6158bcf31587d469a7de029206ebb3c60863a98a94163869701df6e9cc4925d133fc830e72bbd099717dd99d5f9ca565c0a28d13c1925ff88ba74ea26d1b4ae04d91eaf7b3c42cfc1c05a13e27b270b8d7bb6bc99f6e31478ba02820eeed516de285dab07914fbdbfaa7b8aadc818b6bd271e358babc4d5b145e7f88aab169f9d346547f4db920c865d837197e6cd39e96fdf205c7577dd2637818c147f178ebb2837bdca1c3edad01e852ea91cb4bdd2d279d0f0053aa9e333f2fe08050bc56c97bd262050e2c9a155ce51a70efe52debca4f9141a1e08653b2a791588e4525ff3f123ede2175cd030e44d6e2bfc3b91b9e8027f029d7f42058a6f2251ad9d8bc3886342b417a23e15a2e3f9a0df2f598236408d83caf50bd3f25e49315bb107ec8e41dd39f00a5da51d7d637bda6f6b2ee1ae51185d923fe3002b8ad310b6b424e3be4348eecb121d2245051a479f1c72a1f0a33fcf874077db8b50ae844300df130c177ed5c49ddb42b205a87f39cb2262390bfd7d4aebe3cb5ec50d76ab139cc68df23b026125cf3fcbce101002e1aea2630a02df422e7fa1e4061080b37f297410edebab63cc1268db3ce8879d33b875caf40963983c6446d998d400d6cf1077ee730db4910f920a8c21fcb01191b947c3807e2cab1116f1862a2839e04fd65964980b3f69021be12ebf03b4488e2db7949bf58d38b51010e584d68e3bdc1c91e462ee0a49111bf0e6d042ea55c673be1948fa4895b2ce3aeb1ec3ffa06a1b824f63ba8e2dccbc6f8bb84568a3fb53a412544c1851fac569a90d1c523d8051aa5028c0993add1c8bc4fbae948dc636e5f41521a2ca446bfb192f75874ef2a2fdff3849fffff16ce9a8a8dee88c63d522efbcc0d5d17f7e70788a78981a40fd87d59fa367649dfe1dee5b8a28d4b56fa8dbcc94fd63edbe2db664e78a429b9b4bb9f55be25c46e226fa1cfc66f1bc6557a0c080bbe01af0a897731679c81a29bad5d8bda4eb2b63b5d2c5cc15e9531d027a0a6c96b02291e63e0160210f8210087cca7ddd774a36b4483d5a85d35c7b7640ebcc091f1b0eff8a7c6006d2d6e605c2571d09dd4e52ea430c828e3e1248bbc13f15224d0843333ff5657af3b5b04283ae23b23c583f6ed90171460708ab5a5f2bcd6648e0b8f9aba0e916f05ebbcc883459738f9ae0f267be6878f2964c8f6186896def913d8b24abe7ee921996f7678f4f716aa55faa30713251c59e98a34f7a70d362b3f3c89a914bfa2677f17b581833c9e540bf07eb4d87c25f228552e8a97ad7879568592e58942e79d1c22199503783f0ca27afc7ff8027def9c7b7dcb34747e03a40e960bd9e2bb7b6931855595ea00139b301196df1d372b2f38b7826550aa7213f2b7922e28821bbe1999a2be32a7e564f99a2380f3a24f3eb4691b23063250052fe8e120916f7189c8f9314193b055efd2faa8fa88f8f816e95ccff6880a838766e1cefb2b015d514047b3ca2b7c832e672cefd43f68291940229977e716208a85647badd143ede108e50006ee6cfdee371b9b05364e099b752f937988abcaf9d5048538745d04e43cb6741883e4261dd15f2e982bad2e50bf1e2953957b639b92970c02951ff150a047e43fe4c47dbe9284decf45a15eb205d49421f59060a68fb7e8c8830cef2ef7b955fcc8d089c393c556443f788524f8588f4a206f59e7e3c631e97630144334564a84571f6f1115f55ed9f4f1051ba62d51e917e5185225f8f00038182043b3568ecb0d4ba57e7ff97b5a35fbb7becb2e02cf61efa9694062a5b9b0c94f8df49188668385eb83e3af784d99659f17081ff58e5029c6ecab44177b5f5010b40da918933fea504fd90a77b7829e7468ec4936000878c85fa533d0c3cfdd6161bb7293029e25b0201e773398b378ce494c41df4b5f182900d6c3671684feaf0dc6835146483460b31c95cad701e4e50ed00291a8d686229fb8ab0fbe9770e5e6c65cfa1c0bf32d27f1fa0173cdc8ebf0446c76dd3397182331fd3b4a930474ea001fc04e053342ee3e7b9c4d51a1300182c36a65ac56edf074f0436a46d156f976e314671f91b2543b5a471bcca1d8180f70b2a3713457b6acc88867fafb6a7da00dd4520647115a827f332e89b140d9b41b7db324799e5aacd877d0623cfba35a5f025541803d85e82098d76da9a40b6fbd8578b172a2a6a060730ca7352b309e9e0f63a50462a19f92c2f1f3148a351364d7f3e07c26b6af491f246c49e3d7651fb3663d395aa01a08fcd9cd875acf7270dd673d9e06911a8c82ca14cc3d3f696ac783e12d8130bced0a7afe6143248b075af1a7510bbc5fa62b02652a8f96e0613b31c394f32c69e9da7299de5ba9d97df45ef3e19ee4dc9a5c6580293ef7a1739dd67b5f786b2be898835f9a957d362f7134b99f215d2ca90c6407973164ed1d04908ed4660e8c104ff604f16195d47d4cbf556e3fee58815a62fb85b50770c3d73b22096066ac7ca4a1e1fb0f9ee58d8fad43003c856284968f6f42326a6373e1bfc03f4d3e46766add352bccb344b2c8090d02b4d2cfac402127f195de07ca3cdad57536877e8a3175381481059c65a9c63db2f3539dd3908fb5c66ff0fae1f4fa4776d1dc5643b62f36a11bca1c38b1c157d2f1cb2dbbd445b1e6629b98f47558286a0334c4d5b3ad38b868aedc53b6b7185786a127c07e71974ccbfc97ba1bdda996bb04bc47a2f33cf615631a7a76fb15ebeb16722b5db01b032299de9d6aae5968097ca9cfbbcb1cc20c8bc617be390e6e2ff4cbcdf6fa046862f52ec0299203193f9673aed088abc94e3bb33b18508ff4da40c1bc5f9722e58022aac1825b363a3fb4db07a9be9f6c07bc7baa43086262209b453da2af91804","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
