<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e788a8632d847dc873918d614014bc3fe6695704082f8cb94983e03cf9316ab3527d2de5e12a0ecddb57ff6bd7f1295fdd136e5c9838857adb3d195d51ae292c12c6291edd0d454945cb5c230ed9d060e8b677c17e5dcf9ca7b4357dbf89dedf821a8a0724412584544ab9afe3de73e17d4aa3ab9c9cec6d94042b5af4302b3b1dcab43ed33c179b81d66e44a740b88c35908f845f2d5a3775752c26a77642abdd45d65724d30f3a884bc9812991beb612b1822511af652662da8ff3e4d5d812814e947194e7256367064e456011afd88cf0360e27e077ae62f450d5dd68eca3f4cc1cfd2b5e12b72da84d9eef4e758b0e981a3236d595948b13df5015ad71606d7929b4ffce90adf6fe4ee859d5a661a34976bdfe06998633863d3c0e7bef08e571a0794cbf25d1c2e17add99a769318e3b153c872c40b72a5d97388e992bc98922a645714f3e116b91a4d76d8f18403974c23d2dc3d014c01b51f2fe913582254473a6ff4340e47f9301c1f0383271888932a957c87b538ce7686ccf818757569eb2226a95ec8685a2334208c7aa2bf33c5f53d1be57129e8c068c48b913762b7dc6e9ca7d0a308e676ccd2de94554e6445da46e56903701a937629397dc555382a57ca990669efedd5b3e3dd963d0232866c97946397631a1cf80ba4f7544d5ce21940737c067d8dd39d0ca3896c89269d947fa49d67083e051d7d3ba585d67de28ad4152b67ddacec7ab1adc718d2a44ba7f16649abcbe551bcd5d001cb80c6aad68da1c3c4809657791565241e0bb46b6cf99236f68cd692feb0729461d32d93af6931a038da0448b779cfcc8a7fcb8faef6fb434fdb47ff1625151438444df827bdf8c789d8e1b0423b2fd85e62ceb7b27b0aed335db471d1f38cbee67b690eedd521501d5cbdca67cc34e487ebd389d61b371fc90a90327f3834e9836867822bfbc3935c8624345323b041f04240983c2f2b4eb7654d94b4f2d4459dd2de4bdb675833f69ea9466d24818fdaca62a736cbd12992a943c21c0a7d82cb23c1970861b9a854176c841dd67bc8e9b50f027e102bca79282fab0062d6ce9e2843ff11b4fab509254274a228707bda6951a427b5aaeb96f53b0a0b59bb1d23b5b905a23e95da8b9dd2c99e6fce2a6de1815820232b01fd1d59711df223397955274ede4300cef962bb3e0e6f6e259494f97cca1f4c5909275649362ed502480af584df8e6ddcf801831f872fe5e636e2eab3cd722764f26be88ca28dfc8fff5eb883d32892eec6b8c0b45aaa46c3521cdb04f88667f8bc589cac933619a1550d393adec2405cf59b2687a7914b8a93452e5346dca5da55a3395e2926a7a96c88d5aab5e0b1a95bf2bd8ea0b23fa425c968b7a9785b32565d7a52dba913bcae6054c9dd982e8362ce5a927624e21b87412060debffec9809e2581c75c663d76dc0e7d65a36f3a4df389bf126f03b05455ae33b60d692a74ac7be612af54ee8224046b2c4257a4db73313dd42097aaf47d184f5d4b3fe9088871287a85509ea3a1064bc8fe3b4353882b11c1d6ddfaaaac632a6bab448cbda9fec279bd30fe1a1db29ecf8b8e2deb8d4c6ccb54cbef28af526b6f1ba1073807378560e142c6b114a418206a3958756e8e27d3c03ba572da8ba3f2a1db42af7abe5621ce137b10f0e085410465e7d9756bd87b4cfe01919231bb15e33a23c1daaddcef314bcf2faa4500a6d27a5443166b701f96867cf136a907f74d36c8a2f7ce70dabdbd29ddaab09c83d16d394140f56feb95ecd7e07985fec42d1a908bc9d6c8e1ffa3f42e74d2d48bd1da2f32be7531c7f9e01abd528744c1c23723060d1d9835dea025b3adfdc47ba1141e307004b77ab0c061246cc19eea0104c46532091e997c16535e33fd5c6825ed542f12bc8e12afdcc0ddc76b2a461aac6c531333c12a8dd8e1fd84ec8c5f5b9cf837eb98bab20609c42e2c2710c43760cd3aba7dc41e030cca878ff35d311a82e5206642832672f7c5a797c97903201440ea48cf41fb0c615c6269e51ccdbcc02cf1e0d449b6c254321d3eb50a340f25f15da2592f7b0332d785ab51a5a8ee65c087b9a61fb15aa40e9758972ebcba6d8bf0d2dfa26ac8769ea2ec21a65f020c8d1608008f00893010167c5933ed89244b3ce4dde94527f4d63618e9cfc87099c6e00556f6adcea2605e2096c32cc0dd61d459f3d2bf6ef894a1e8565cfa3abc12777eadde49a8937cec150c5720ebefd7f910784657c5382a108054b2aed55b46548e7e85d1a333c49be43b5c61dc6b56edbf5890381dc8d749d0b9ec48b5db6533949dc643391b480d9d25ff66539d138115d1bb00e7ead7a951f8119b6dbe1131caad2b86acae92be83311e8d2ffbec319921e062345b8d50196ddf29ddb23589137426857087fa22f068940239c08bc7996f795a1254d5ad155fd03bf10f39e3d295b6b9b6154f3d7f3de30c6fe4bcc3f6079f5900997f02167f260be0a766e3881fd8d3257edc68ac11658440f49998aeb69a03431989ec6687d9e365a31ffeff273cb5fc33ff1b07ba8fd22e14f0137748e0e258227349e9f26232b2c9c56329d11a4871bb60eb93bbc4fbd15ddc88489af68754e9ad562339ca375633d9ec87980bb91241847372006e1dcb3743cb0e409f94d645e5b84f2b1501a21c0064555fdd825a0ae5c9713a545385a29f43dee040fd5d574a16320eb7cacb4e33edc368d2ed0ac02e86492a6ea788f0613f93dd0f173317710e638b591f9af106a1920c7e560f91220f731282c2fb98de42bb9e53e3369e191b34a17377709756ec8e740ff74f07f56e2acc096f977f133e1f9b387396131e4446c8c46035f10720f165d09326cf02741a3acf43b1fb77fd2b3d1f81bad197e2756231c3ad3c2781766313f3258a2e6f2503eb5d8bc4ec84d4d2e83eac98f763a1e7fea4fe4fd1ebce05864e653dc5e1a1dafd7e59bdd3d3cca948f3c005b104afb277f4597aa0935c1cf80e5654ad170d46cb4fe42abf13a987192b157854796336b53a5ae680299c1f5f355fc3ddd56b3ab4db01bc1fc68b845c8236a511c65e99ddd77fd03a8f91c01f7494daf0ffc7864b4712b3eb963f8952f3bd093a5d251e7a04a38e9d6c14268d3d79824ffe2ea93d34210cadcb4d4d0b121829124d6b71ed20f595b090915ff6a15e64749b5bb60b0a64e3ded7b49df1af16505e72bb28215c2db95ddabdc1d25f3087a5ec9b5486f86e480360be313738481d1b8d677bc94b66d99f0deee665a40802dcb6c430d226fbad69711d185a01e8fce9b32f2d355a5aeb9a85a1dba3919dc38968edc8c3169f4a96ff45fca012acd78550518aba5fb424d9594fd1a005a4ccac06eaea5fcffe6c5ef0d2e4ade1c023c09a134fbd63fd4c34514c6cf91ba3255789a5c15d3014dd3770ae25dd24e449ec8d4af3af085007407270cfce071d841b8417758d216db4c6e2036acbc983aa86a407d665e08462efa50a0c0ed5183ef1049cc1de43d85f92effb52bc031b4eb5c212ba38122a8a169d03f1b3e2575182e67dba5488e45b0c3ac829b558a6aca108b8f5c33afb31170adf9498c274334e2637b90b2fa7dd218687213a614cdda2c38ed9e59126a1e3026fbe3f78a3f0ad3a4b04cc7318c817ccfde386915269861dcadfa0778a8df2fdffed1af393994696e53e33d3bade47b789ecf88f6fa2d2bd3f79ae4978a95d2cfb56e6bedf966aea310ce4d02439c90e754fb5b953827a8d00fd09c13217e52bafd77459f10b11ebbe75658a0cf6f278a76ad8409f31b60019fcc413b9723c76d0471579e1c1423a8c204b72811e8dcddbf602566d92e4273e97199499d76ed4b5eafe034cffe62f143b2249fefc558cd09d1945750af10a959dfc9d3b490dba2d3e5ee3d91113f5f84d062ed7b98e95982deee96472b6a33e1f3aa5d5d625bd7b8481cf33859a482e36e3077f003e16d58247a2d70b9f0c4c5aa7acfe2641275aa97f8ceef8516c392a299f73b3ec3a4e4c5dc5b363cf600e7b15270d2a9da63b3ae1a1b16da674a74f945e130dec9751a473696bf3e060ee897a86d41287f9f8b54986cfe4a97fbe45f2e82e7b19d15d67b9d0ea23354d5460af6b1f816c1bbb8a59900800598ca14ac609565954c878196e859cbe8f2d6b938d46c3e2f15ff7325c65af586a6a2e9d9813e67a4e79928d929f67dea3ba9480dfe8310d2a070620e97d6977be3e142854f4b24879833f16c5141931b7dd59c64d444676d07f3f993a8b6d05218bac2d69076b45a638b0f1412473e86a75394e1f99de56519fd69233f93a8dde275d9dc206e36682b4f1573e6c31d48fa869accce7efaff26a980f032558418d004e19de5f5602bd4469ba6ecb7c2f763c925fedd68a670bd90ae31bb031b0bbca1da01bc579f9a4e8d05ead93825318dfdcfedca040f2bb869fce677b1d8455252dbe4a99594ec5c8f23a9ade5a1ac739b56ff26430225a1cc02d058e8760ba9bdd07c01f48dce5576c4d3aa40fdff8e8f8353e76dc9059e8e78a0a527596ac0ead5bc2adc3a72f97718be8a1a019354a8670f4fbd984d3a182f7e9ec1ea732cb04afe632599e84617171e3c5b2f2c87785799fbec3ed90856f924f5d9277fc8f181ed870884300d6b84191cca766946405a92aecd166fe6e4f6e4ce8b605ad8502320042f0fb61ae177348a1a8fb0b66025b1f59ea1d4485aa80d2cd039330d769697a588ff63a07926af7b698aa6d436b8fbe52df8d7b2e22667562c0e4f944da49e3f5839e98781eda36b5c8d658961e5b45451eb41f79161a08acdd9fac2bcb11732eb21006e1be66cec9dc043ec637e4fca7d7b93a561d69e2592475f0b5a116c1f7428fcb91e0c7270f1eb520d4394587dcadc6b4a390c69965938cfc86027de8b85a4c0cd4b562f5c7a9d133ebc8e4d072beec10d524240d5d16cdb0d6773a96274e2d87ed2c2e1039215c76616573f0e37c01ea36ff2933c83e4252bea5128e02d4a0d6ebe36cd934a7f57fc713669a045949181811561c88373a95f458e6c512a6df0e1c5cb06a7e392568ac9d499bb7d24bdc12cc61deaa4411efd11da4a064ae5cee9596daf3bd22fe62fff2ac615d249468b090fc4b53944f07401c0a1dab06dfe8a326ae2eb281d81b5e1056ac608d23def7b75e7f07004e28c6dc625c2b5fd6cc96a31f5d940fc867d4a16a1156508ec00f4f0f9c8f2f7b778242c7cf68be53b98989ffd2feb9c9ebd111eac1aadbcaf1dd68336190ae1e3d280c3c6d6567340514460e008898f93703820ad14c53a52b8d54c0f1fb79c31e0f0d76ab5494ae7ee45c0024a8142fd4af6627767ffd4e704419df91903610233f2e2063b8af594f0ab549f869660f40bedd2244b276189373d959278b306a92b0d029033f6418f811ececd00f4fe7295262fd9111abb93d78023e3c1a755ccd50a2be700e3064ed72afb8c52b49772dd5a970d9e638584ca6643292163c115d4302fc6aca7ad478c4f8c96b31b378413436914551896db153fe5e2fc01ea4fb34cfc3f9d00419b2e8160325f2f2581270df3743fa0fae0d1b3f78f4731c8ae8340c976912d82ee2cc321c18bd520ce584e02ae8311e38a699a8d51f2ddca17962eae710dcb2652fd8cce17fabef17255110107aadaf638d08ed9f2b009f301fcaec0f55e75638a081db07ba8fbbfb4658647cc6671d36e5f39071355bd68abc2616534530ff65acd5b025e55852e29477c9e2922406edbed9285759c1a792cc3440c2c18af73df049b9bcc15f99d478b28ce9f762656f5ee31b7932298901489c229bd033cdd77c0d16d7730ca70d7785a6bbf83d44557bab3ea449475c740eb15f78fd90d29f41f6ea3facd6ca9b17518e875a23c9275c854fc383d62ac0655620a2adf1f047f20eff89dd57bdda6209fffe5fe5cd672226e50f44d9fa41b2e83ea7f1fdd43e207bdc2e48e5004d4299bc8a5e374ef90f695c908b6c3c2177c0588f57c0f68a3c17cf6ee576fee3a8acc775c9bcc4062e0df26d50b01974fd4f090fba363d8ddd857487127743a3a6cc6f18dab2a0e357da42478e8118804d13c53513ff8249665eed3fdc3986a24153b7b3340b5bd80cf7adf6ea6bed5df858dbdc0711cdd2fa0aeaec105067ccf3dc007fcbed6a888e4185b385fcfea6dddbf5d17e2abc5e876a8acb7984460910220e28627e1e4a2a93d1cf647cde9362dadf6a52717449c63a203521d2ed52089bf7908fd728e4aeb6b93b9ba16d4e7ba7e4660010f6e2ca94c9d1b3c550a89efbd44438c053ed9f266b8c00fb7dd93ef1ac715f290f4c4b0b770577a120968e46d480399fbc5c702531b942768d0a486f3af5dbcc0cc22ad436a27457cd94b9d6a70ce0cff63afb90f1dee15370d6b51d836028af5e4e97a7a78bfba8bdcc41c687080e69d06951a02c949d0f2943702e4ce6c46fe9ecd8657d3e9012bf555a8b9c56ca8150b5d2a70cc415b34f60e6d1add1e4a48f35ee33c69669790cd83b0c61ad59f34cd78293de656acaaf6aac4c4e1235c63987e10f217ac2cf10f0550894fd463350cdf549eebe39e4d88dfc6ed79679c97d8d8adeaf66a61f400dd38b87ea48b6930749dba700cc25695281fff8e3a14af43211ccb98975fe2f9f30ee97451a9fd95e176f61c26941a76c608beedec658056093f3c9000686d8a808b7fa1bc627eb89574e741883615be17b7485ef0b0e75fa29a2567181af90bf0775372ba03463ad7412502cf50d15f743b56dc23857f4afaa0551933f98814040b6dc61654baddd2152433917c1a45ba71d6841b3e8ecdb924c371a33a5b3e6ead48d4edf8e91482b7046d8b553b6e8075f3fd391fd53edc64e66360f969b2552b4409d5706e76f3912fa817cfec92059a489ef29075d7714e6b84d07156c129c72b09f0cd91bcae364cce0f36a5e1c565efa85dca554ca2aff0e00001d2eac351b12da3974c779514324413d563eb5fb66178c458bcbb95c28877097ed69e5ec205ed6e62930c8c1bdc3706a2a42ac9cadb457865441a995b9c4b561b636fd3aa82f21ec78936d2ce0095c596d58c50a15be8d77b3e97871fc25aef540fa05add076fa396ad59f88823cd2ce0067f6c388ba4f64e7d57c313c6c3f5a18530283837d4e00389cd340c8f26420c2d566f6a25da081e7210c126743bceeff749981d459e8ab59ce55f9201d451f071b111cb07c4b4c8d7db4cd2727b02dd821571dcb6b97600362f6eece852908cc534c356a273242eb51abdadca34ab4cd2b9af17e52b20721a117f1c5a8aab7028a0029bfdbf33cddaf707b6b33856f448f97cb0b2476d4032c670356d7a9d378ee49bff7d32531b22d4d4679ffa3e6f2e7174d73cefe9312b0c6bc0037e3da7ac39d1b6122bb415aad35b357b14a416fa6ada9b997a2bb38a90e4fa43884a77d2c3ab864e5613e2e201aba006c990c5457ae6b48c10c197afe4400f39a3d54c12aa57efce3d59eaaecbe6fe906fa09182438b34639647581641a75d7280505d84a752b2645eb180b974d1a2c7dbc6e9b2eee10b86e006a5d4334403c34cc5b73f4fe0bd1fe5913d306778bcc2a0030a3d008fb967ca0349c29ba0f128ddb593935b7bc53994df1e479a1613a3e38e75c22901a98ae2b7954bc00ad257bbc13b1cb0fcb3b5a8deda34c0045eea17e332ea7d200d3ff4fc44f19b65f3b02d9952129efe6911f54ee0620c77fc0d1bd205115d5d2dd5122dbdeb06fe2615dc85f497939d0a477e6d1059f577cf7f091ce15b16faa55dcb1cb0d0b3ca6bb6c00a0ac2946503244b32056df65719da9a33ef8039007d98fe8f0cfac3d7efb7d4b6d17f9f38a155beac321fbe76a3ee9bac65a974fa2e94c6dbc9d32c4c7fd4b9998eb7128fea149059e53ff38bdd1f564b74e37c7b80572cfe4cc6c4ac4424c3348963dabe5a668b8d7bb8fb916da75f398f243ed50826d35b4d2b73740ed4aa38284e4305ea0688b9d740024cf195c284ee78ce43c468968f84b9eae6e8e2e29f672bc865d1babf99ee4064bf24a664b8e7055df2ea62002a9821998c46f4aa934ae0f02087f417606f39c3e57d6da19443c2b4fe03bb37edbcfa95eca01aac93f341c5aec0f5beca81a8a2c01221d1ed9bcae88fab2abcbb7ea8defac615292469f2146a3f84a4e25dd40028c6a2fcb97120e4f39f2225b277c48f5bb2fa101efcdd584abd3c0942574a8086d12d201e23ff142ac8d1d89265fcfbaa0445589cf5c810e94f8b1bca4fb8b295b01e9530772ab95c2ef000c5e4d7b1e882b7a992ef0e83a0f589c2fe04039b6bd4c2b4bdaacb20cb094f157711f7cca64e2bbadc133e4ebac8af81e980e0c590399c9d2629549f2ac22cfbaa05f7b22bfc8e96dafb1a3abc4446d9bbf1d1cdc2e00d67c492fc5eb6fbaff4a1ca1a65408ae4608cc81980e9567297023f865e66721ee034a5ace02c00ba53c65277235b0ae525d5d5e9a59c37f03280490ebb94dbfe069dc76733f99d80ca07049f6aba6ae1f89d1bad6b3ff1388a2892bc922fafb100e918c19994b5f6d60fe90870bb31caab0d379aff7322b0686ef6590a5872abde89368458288c168a8ec0178644010f145e0cc6581dcb9775b103bf1a4b77c144698c4fe0c9061d8f4cc3218cd249e6162fed073e4761d1cc5b7bc7c3bbdb78755bcde85859482c64394c5b91d368c7975892a568b49b4d70812c8c32d4f09fa49ad1de7e3df7e703e56467b702a88c6ee7d80ce1c0d69839b0b36d9066de7e51dce136b225d1cfe65ed7dc294ec3d1f9f5756913cb28c9b6437fee47af318dc3b0bfbbd1b40f0b5264960d96539ef489ff65541802f63c433d16da9f551fffa7b4a3f22610b4a2bc563876e86302219b511196281d0e879a08c7a18bca56b26e852eedb73b606c82c90d91a4e8bc45270565b3c0245f4ea2b9a30d0778fc79e87200bd0a3028ef36c54428822cb761f4313978f1f814c2b10f393cb415a471cebf7e5f497d1e76f1151b8d6d13a17e94bba78fadf04d331bd59d605df73f2594207f102a8054cfb6caeb895c1b6f7c3316d7758ea8ab0103f536ffe71942ab64a944d0e0fc2883b877f5446ef7fcdf49b06b7cae2dbd7d1857fd9502fa63c7f6a73d21defd770a9d88b061b15d421709c2b6967452d77c7660cdaeb24648d9a0f17c111641c90c76f93b2ab55b7946d3a140978f6637f3153603b8260336764a732899efe12a2f0a155919e343fcaebdb44d5c3635bba515c911e7de2ba5a9a239d02c6195483686da74516e68bababcd0bad90cb7db0fab6542d89f72b5cb54fd16996245e3ff70ff9afb847a6b2d96d5eabc236c78fba1c92cef06276af508e7eb1c18a54bfbc588cd9bc877bb7617afd7f614f3a211e7c11b5cbed7a8aa7fea2212f2289a89ae0283735aed3ea130294f6dbff59486bae1a36dc002de3eb7f71145e9e15a1b40a39cd8b6520945340d0a9780a98c93f489e42a3769242080f9fbc8fff6a5ebb46747305455ed7495ba22bc7d1142526ff7ddd6f1cc3c9035cd37f788e0b7d15455702ba5d1b68ac88cb8ef4693651f5f6bf29b636a8b3dcb506da608c837a132265be583e420900c7c2a7c57dd8716c8d2ead0e99d46a5ad86c19d4a8dabe4490d77183d872e5fb1e5b9096ecaaaba4c2a5160ff7ce2b09f516454a1ed29e12985d5fea409be1298e9ddf79e8bc317a3707a02aa90baaf390117975da72bb207288cf526cdd649513abcd2d06c39a5c534cafd896778f1570ceddd4c2ecdb46b1c0f1f5e53d851fdd3a230e5058273eed83e25d6a7e0c95d2ef40c10de9b5b68002adf703591a75737f21a22e6aec83225e79c09bccd06152925fb8211a086c453a2ca4199b9e0a702bbbe011a72c39d56f596ba058dac6b6582435fe48a9f3ba12239798df1998209b56164888618a364034c8f1b313fd392456cfc6b292afe3dceb55fe18dc7cb9b6847672730df2fc6ae881375959d8ad8889499a3d9a35f7ccdcab43d0dfac6dc4b80d21dd4f6e60285227a56c7a43f3c2741abf156894a0fc97b22ece52322d3d030cd464ebcb27de1fd42f6f5ecfd969c92cadf4cfc6ab75955250e1f5fcd4bed8c55f87d0afd1fa80b7f0b2d0247dd8813ccfc7e87280d123698a70816dd2d2cfc7711faf6bac87a213a6485b01c377f83164a2af80b6c88d6e82f9560cd053f1a803b67af40bddf568ffe9c34371257cf8a5548e61c7615472083f9e9d2426664a1e05dd8abdb7610e325e79378c592bc2b4ce8f2dc32e1c29fcab86b87fbcaa147c4de23e48c803bfdffd3498135ed64e0ae1e1daff9a5feac8e66f68ec37ada62c10dbc89b7ce014246133f452d25682502a9697e59b76cd7d704ae03af85f4cea46867ae5e0ca8ac2c238e56811a07f63d15c9b7da5c7e84db5e927f59a525f8b9da392383d5369c7f74cb5f2f39dfab03cd3026c23f4ab1930504d7472a6fb99e5d4da50fbd7568d6d0de5a26f2e51df490d37c6e67a8e39d98b755b79919aa8aad4527353154065e21020abd2381250ebc4390aac41e28d59b39cb0d2fa00032f3ae054ed0be861ef7158ea687e559abc4de7f5e1c1e3ef40f874701eee841872148752feee3d670130f3182377c5313340f87247eb0b324e1b0f405840975d741319149fb52645e54379e3b154e9770a1ba7e3ec7bf9111b6dc0e9e984c76a28e70dec921c26e4e3d3f6fed9844049d6b56678c288504e60f9a00a1fd0af7b99c5804b936f4d8e36902447db2c05c73a41404bf20b340891bfeb78bbdcf5953caecc3b7aa319c2db149153d5688ca17edf44cc9785c14237c2f2643dfd0a60d28972d579a1a0ce9855c7bd798a7e8c7e321d1ffa0437911c58933c77ac9788354b405141e2f888813dd8adc88acdb903e05f7f7d8cc430b0c6c3b914c47de3eefef1850b4ba343f520b125d3eb6b5e953c1ab1bb0e1998e8c7780d2ac4635df4064091db8439fef4b6863b336cda260faf1233552047fdfb46f41e5b274128825b4bd914f32fc0dcb82b4e3663935b3d45dbdedb2cade0356989d5ef0436b83fb028b66031fade6f204c7100af23a57c23f4238c7fcbd651abd631327ac922d0a3f95df28815acb1b4b8cb6f5c14122331a32ecab942759ca6f6feaa2fb9f85c1986e085e7ada2285025e1c7aa359e93313d37669b0077b5c074c0578be09cfb323aa9dd5ad316d1d1372928e3cd455b7ea4d5e2fa3a4402b6c546ab29699f92da450e9fc09341a8232cdf8b7f54ae5f3981c81cd2bd5d4957ffde151b9407200bcd874fe10a196ec3a3c735feb3fb05de2fa251341306c7eaaf24ce816f48b269d449671107043dd6dbe0ae06072f90c30217dbd3b5944c5092997a4d47c7d15abafdb18aa55928f98edc25d9377a77cc428123d9a67f506ac7cdeb293b8893b5f4720c25c6614478668494a609f1d227acfd0a4691fd4437cc170342597c2c9ba26f42f858453c4bfe823f472753aafeee39939c8028b49d43591d55324a198f3810abbcd1ace74e80a9cdd18ec0dff1fc2de640a1bea81725be697f6e6338b72f64679a4bbf02019a895bf8d5112ea60940a9cfd468bd68214b607e179d96e07e4450341c21359db8a36f49a0bab4be193c367d9089864c4d392a4e1798901f2916707ac5cbe0d99915d182ff2e6da406bca3dbca895ce7511194346e87b7b5d2f34a7963f6c5602a5364c9b5475600ac55f3911334385d92d0f9158c8029effea916d43cc82d0e04b666e89e9c3c8e26997661093d3d7cc2fe7d4d9e98182f8c23d251434f183c0b14692dce73353489cf8c7efd1ea5519bb9d4c058c64b48cb0fdb505061625b76e8a485c0693b0e4655e2ff5a3847d6635a485fedfb4f5d9de2180390cd3c71f3e9aadb781db788441a0f47d2027c8cd6dcd93ced6002367d470e4f21246935c83eeabba8c5ea7227ff358087ffa063364b60c15b405b7fa867b42c7999ce26541e9ec452afe6af0028e2454a78c767c90881b4af7fb7de0cf97b0e7bc5c4566c26144c29b64a3173d455dee20d42cdea981c826a3406498a89821a770656efaec8c4637d7240a91d909aaf4e89ee74123c3ef0a505ea85e7855edd1495f131e740b9956ac2321bc90cef7293aed41281b5d7460f0329ee10a992c5090564ddac565d8a33c52a2e15f20d5a26e8c4032c062cdd7c01093fc6f343c0181fe8de79c07a10ee0361e6f6154819b93ed0a3054d7538ddc77a5d5e1799498b614420ecf54738c32fd305ebbae758eea55ce07bc2d901a4be6d1e24c0592c16ebb877945bda6440a7be16593ffa1e24e5eafaef81bd6427cf99c31e2d25b5cced40c2489b21aa978be8e1489d0b9431e9b4a31b371af561e12a49b4408cde548954ebaad891221f4f0da6ecdeddc00e378fa675f3627f064518981975f3203dc22eb1ed3a4aee913068bdc9d24f366885c1ec9a78f65a5eb74b85bfd6cb727201e965f760ea085abeb40561679a0bfebea47ff463f3a637d1e771bfd463b5846c58b30e4b54decaab80e00aea07e0fc371806b78fe45f1a37dbad9741bc511b60df9c30dc0172ef1401e986b7c8149db9aeec10efa7750894f514979d4ca13e01997e4612b73959460e3f80a4f921b8de395a08faa14fc721241f337468d8db65639c6b5ca2e3041ecaa1a5847e5f4d54fb2587ed269d6403034b450805268e6a76a529fc70567e3005c08576ff972399699fa9ffa4778cc7b68455ccb14c95f1b9d30c53622df3e73140e7b63c797e8e1e6896eee1122b3a5552cf1891037c246208602cb8674af571e822c3fcd94274240227e80e87750480ae0258a739022ea651b8eaff7361364f9f090c98333c3af1ef7fe33fce8c0e450940d99b20da7adc3bc4272b2371a902d476e40d71cba18eaaac22769aa38820d1ec13b77d3e7735a8e45a320ae023879c2d60468c8a81fd05a967c4e1e0a15cee60720ba5ec9d7e92ea2fcb9e7ee3bdd3867bb67bbfca1532811e43c48086cd2d775676fabd8daffbac14d5ccda8fa9073f26e59ce8a8a97fd3866cc16e3d3de6e3bcbe30032cb8f0532ebf150232f7be1a79c96a361975da3505210042ac0ac6be616a261d61bc7405af0f027963117afc23eddcc98004ad43afc5dbd815c68ce00223fa59b2a358ddd549b0a9daafd68b7d9758fd1000d03447e3f928cee9b7152dd3fe74d9aab8261e8ffd167220225144d2bb91bb33bfb6eb9d0d7709dfac8ffc46c36ca9a6d23f8df16f8bdeca6137d0426b691972b30a4a30b1243a6f6173eecc6eee68d1317e5f227b2c20da388a1ba88fecd3573d707bd9d0857b3103b93e8ffaf66585251120e60aecfb14771fed8494b8b450c0dc8a3ed596b6d4b73d0a262cdd61d0817fe89310f01866a1366475a8b12ffedd4d41a463e8642451ceec3d33e9baa696c7450e73299769b24fc9e7c77a211ab0af2ff9e6afc1821c57f94762dcf0eef2f5d57c9c2c1202715af6e5c3c06d60d20d9a5aec44d75f0b1e74a6d708a0f842c3e3dff991597f8c1d342f834a2e3e2940487dc99f39e190f0550db5fb89046ac5305b928ee167d1a487de3f7163eb19cdfb784d9ac14a5fd9636bedf3ac689709290a1543ecaf2da9f4debbc995b1db515b4f228375a5f4de24d4944ce627b414a95ada11866b5f9bdbc9aec484db7f53439d46f87357a9331577918d317bbe8df25638c039997be66f689a8e12a1ef84417a91926deebac4a58d9faa4378ee07d4ad7a4885a5ee3b4f870b4f68738095fc171c22bc05d5313d317c03c096bd1201037dec31ab7b49ec3f0ce9f44e760eca0962f2f835b6e72c1e5613dc4eaf050e0fce692993103022cdc7bda7e2b537793139b47830868d8b2309e1d8088228343442255cef3aced434017ef001cd316c887b3fc911fe6aa96c8fbbbc91689aad50040470f52e95ea4ce31ed861056664d8f2413327008dd694d177f0843b237171bf4897b788b8d55e62488dd53f7752193f4c0a30cfe2e8c9ca0df1895c4a12b7f2319c9b02b81eba5c9bdeb442fe31b9a2cee4862c5a2eda54fad4d0e48dc869a504c4cd8dffaeb07d039786e2883ee3a38cc9a5ad02ddf1b2298cd300e9a15330925d7942151fcca733a51720fface1c84e5796d9610382706cc368c0def469d07a3fca624966449903bfff431750e45381efca5e094b0cf668d135d339689ac7d413768b43681949063931377f21eef92d891ff41ec8fef9faa304a9c0fbef7de2411690fd4acc32fc1b58e449a99237d396fadf43b957d50a3f8ed60fa1f082d2099331ade64444f8d0c9ba780c9e3af602364d87846b497770313157505d7c8cea168025b93f5a8c25775eb327b33c4d0db24f9902aaf36978f1fdabac7470e7abe13142dde5bdc89db6c47b2ee6349b64823cd7b70128ed3a24c935abb9b88a635a96193864f55fac1b5f2be75484fc0338ae62ce792168b98ea7e5bda361c63cffeb20ebd80b0bbc8d2bc88a6f1cdc98afe3f57efdf15e33bac002073dd05ffdfa6453fcd35e1ebd9e039caeeec0f02c07f10bc958dbe97c3dbc946190b8052f1b18dc68b7e6fa45d1af47d0e58a319ab49b11a7e86e2454c48efaaa497e925ee917bae1e7a6fbfaa4329c40316910cac9c9b85970f76aaf8ea1c40ef64124204e44585c141ce52b216381644726790789736260b9fc4738e568740cafdb5b030a12a792562f522a4cf61bd8359a89d93f734573190d68d61668a5d4762e01416fcd4c57bfcb18c6b912ddfe285e898fc82bebc0dd5687035da4110c1fecc49d0c257d0f4e0aad1a43cd823c59ddfa91f398cb90b4a7cf9b98107625704082b269542e4dace454df58cffdedd828a174cf5e4b2196a17f51becfcdb75b3b7b9f086ad7de0534bf2f2c99fbb8d35ee6952ba859b9534fcff5551df4d3cad9e4214def9698daaa03693a9ec641f34b5340db405157a2eec089e01f29543cf2178260b167203d67258b46cde04db8350965970ca2b96e0c29630dec562013b7203264f7d218c2db957b217391617cdc38d2ba2bbc3907e5c84764690464ca0d46a12ad82c208353b9ea7691b999bba19f2e70c0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
