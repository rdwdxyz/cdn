<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"842e10d069e86d6110cd1c128c568d0120218025f7d4f92eaa90150864806c221c9ce1b56e28f962850aab055e80491fbd93818c716e88e7098942fe83af66cf5fe43bb35066fb2336f3cf6c59fdcf2b5d2686342eb4b828c17f55ea9dff5159d884e5ab51843f820f7d66ff2336f100c389d7d80e2459ba55e298167bfe29465a471eb09af4e3cd7978dc98955931dff71e09391c62bea0ba720ce97eae6dbabf445a4dfc14aa7fd444ca6c972d70e3aee853de54b74886ae84c8776cf36b656aeddcc4cfac44e9f7588c11c6234ed657d0f4ca387dfddf2b03480b3fc06a9604487e96128dc961e88e34501e38ce5a01532dd6c474aefdf22c36054869589cc4b17cf20ed6f6a5689eec99b26bdf4d14743a18c36a71b55bae941d34bc1a2f2d8c77da10ae7eb5aac7e704d6166e7bad81a143254bab691fb033cf0ef34ef86ba00c023e5ba1b51907941bea05a8a92378de8370556b2066212edaa1ed4989d63be74cc6ae766a7aa034f30029a0810b79b062c4b90112a86a4ce4055c70ee4768c3111a2b37e619222ebe1f409f2f95c12b7f1c2269f10e9e7fafcc4ad8e2b49a0e1184f513e7530581a0503d84cf1e9d1c9b49ff71c3be885f6f7969d763a96ee53865010196657e7e962ec9000cfd1ac4913dbc47165578f19a451cd4c60c3c60da7de0415efc9f55c4b76fb3c1e4cdb1e3c9a30b41c8ce1f1088f9450ce547453e59ef3ec945527cc4197d06343390ba456ece2f3aad9199ae2bc31f751d8a75507e3b6595b34f8940b26dec20a05b40853c25bf2ec314389477564e9c213317282e3c97abbb36afa38ea55e58f3d797e3c23ade6fafa0d3f244207079ebfc0658f24618be4cc788c49c69f4ff51551cba001d6152e4460e4cd97c769e1c94ee5c3bc40741513f5739ec5e878f66642cb925646936764675b23158541319fc5b3a0551272535f5de7f96f1dba2c53aa6c1e7db4aedd51fe1b4aafd83e4db06ba48bd114cf3f0077ecb2c022291905b718ef27284021b10a7455a57867bbe1a2763c09b12a0f6e23522f46ad9673f54b141c746da311f825232310ccc86a825f07d5e18882b766068f2ce95ce7101c400acf7cedb4305be03c8537143c2ef58c3936bfdc7ffb8df26ca283ef8906f23a83728d14cca097adcec7e72d3723694edcbd6d8032eb960b2ef3ae9d8d007160fe7dacf29bd1c41cc38ebd15335cfcdfae926871830b59c82a1f9f12c9fab091426e8761830967d3077615d80ea257812bf7b8acb8e11121cf4922de1a5da16a5c8d839a3a9cf83b5b18c34bbd60615f26be65258ca3589d2f384eec672730e69e39194a5a900e92bd99e8fda5aaf67f9bd6d5b9da3fd6207afa1abf13c0a7a4d5225083f4aa0226ad4fae52d0b3e917a0dba309c750cac88cd619d0b5d128d5e602471f8d8739b4bf758b73902ece404264a9abd94334d750d140f30ead7c559976bf161173c79c14b5d835036ea58815bc58151c3eafbb929e94657dd831eba026d4168a53590d3b5e17198a390b95d5c6e90f2809884de6df0fc087d6f3d6d2d37776455936aa695ab9efe7168fc8900e1f13ebb8fef4c57681624940133fea2469029e2ed4709fa2fade6a94d874c21d745e922e42573c26759eb7274f1053fe139167794f2b562956c9679f36a757d6a329150e381d0b82f6efd35ad9c99b3144bf2c6f25c81c4b0faf5c4156604ef783f08d09e020e8ca9b71d51971c2c25b652b89d299c460fcdb5fd129e26e091a87274cd4adc646526411e288bb7f46d7971ae5b1e7cfdd8e8bb13656c9be9742be248c722a1c6c30a440e2c17743576106268e2d8fb9f808463f2da3b4a686fdfb6e0b17c1970786cc2775036db1e03984b4199904e94ce8cf8c275b88c98b7fb4b94af01cc04c6111c2bd8d78b0fb17d61d6e852ed75dfce6a41d04bb9946ff67a5d407fc942f4ce3ea43beac95be73169b52a468d61420f0ec46472c63679faf27d6b976800bea6e7cea9b429b2a67e3f589f9dea300784ad44a37af50a67a4c1384a1ea4c349ec2d9abce7a42c5259d13b51bdf1c69a9b1ad41046f4f16c1869a0cdf642d68986e665319b7f6d32651eecfd2db848e1246887877b5d99874de8182170fde221c0f1edfcc4ebd1ecd6450fac83a0df98a3aa0e0069d5a56bb9e6fd119702156ec77f4d2be9b6dd4600b8dbfe2f313602d6d28f903dcb0621c8268115d0399531df49d1b222dc10429743e58a3c2afd5b7e767784b83256ae19af12b7854fea49bf6596e54d851fd65e324d1379d686b845cf7650047f527693f2e9b99c512df937ef4e83d91c19f34ac8a6febfe5b3b2dfc05ac38df71f1b18953de0b929af2c0519c6822b393ed22ff69db13bf27bb7e36648ca0b16340daff827dc9732ba85a8589804ea86e01a42c18cce482a4f001679acc59556df16c82ec1987322938a9a35c09bdfbb2268db187ac35ea7a28442981c9e9e95caa6169a0577034493e625925dad958b9d658a5fcec0119a1ea46270650d7d94acc50b6bc509a0d88b7fae1affcf364cc926aeb5e0be27a13586daf84c942d762646e4aae9757bf5b169bcc7b496c277ce63d350369b1767ff53161a105a2f636a2067769b76726d5f16f3b188a8c68365cefe3c6267060ae0e7fe1b91d2c5b658d7705684b37efb33db006b95591eb1a6e1be675ffe9319735e60741acfc97e5c7ced05d1b732f3ac0cf20ba93dba21440b08b568ab9b1e9ea39c7521dd761518d84e0c30d8487b19dce03fd2b07e770caf4e355630c228377ba2f7882d21eac8c7ae64127775f245dc6b95547ed17e2092e6aeac6acd1962f8e8b34ca3b31b83f152c19d086ed378110bbb509ffa532cd2a9d028d55d230e2cb77fde38f659725c30ce9f1ea759489f1b6dee14d149e906ba99b630ae9d5bdae8a528c197f8dc55abb8e43b16f4c8aabd423849fa6f99dc60b8efa79150cb7fdc81e3443a14381e1febefb093e5db7e693fc44434d18e183f944a91af16323416c12c30f420fc1a995f388370f2bce4baa4011310801c820ddfe68e076113bafdcf58b014e4fc7c9f3bf497e2a1cdf2d35662b6d69850fbeb91c6ffc155bf1d5bb425af49d221505b20f5694620199c3c3160bdac2b04bee15b9a3b67d8b739b9659b551437be8fbb186624f208d31b83e6bcbb3ec4f3c38fc65f3bbcfa1df345c17a6b9c9dc85dee1ca01c485792652466c931c0542790f7d6e7e706885313d77c716757305be8be1b98b1c9153d70ad763dffaa949a548297dc82852795b17fe22c2216f71eb11f1577e89e387d71f3022540d4f0a9c9d17a883f8d5b3d90b84e09ffd5ee7851eee6f6264fb11e5e8f2e0e51c059e4052e2d4b0899e1fe4212462bc77fa81fa19990a8a39617eef9a81a92f555d388f2331ed789051ea1523787ea8025e988de65abdaca168837c09e11b3a542aa5b0f1e15495ad3389a8184f5edff622e2b2a627a769b3c672119012a57bfba697333aa01e8d550a4efc7bdc0bcc80e29449cf044b4f9851f5c2f543dbd9b4663b18b3d249feedca3b5f68fed13c673101dc7b0dd07d899b7e8f01150bb8376c8be7d7fd2c7cc3ffcade91a8fa7f5b73f7f7896bd5cbda92bf67b200b360bb73266d66bb95113305b785ec4ee882ef5887646c51a5d0f589296319b4a764a4bddcc67abec52b3c0a0d722fe6660fdeb0d72afbd8eca5baedbc3386f3228e1376871dd43d068f795e0178bdb5b78d54444c05d76bc3acc38bb5b1efd18091ac5b51fd59b4389b33ffc0b987cd805b3ffd792f5973bcee1e73de7933012982dd79ffadd2643452a3147778fed8f5f44ad9d8237657a201daac265bee25e0ea5efd348ceec22d163f2986668bf2057989b303db83374032b6e82306d65af67ab58bea4fafc4fbdf914103a94a4685363ddf8e928f0f41e6a37a078432d91b4942c5576cc67a89bd9dc0edb8a89caa8700c2b3dae199628c0656fde26e98662845d084ec69db79fca081c94cb8f5fc33383fbb1b67d1a70af63d466941955eed4729c3a699dc9fdb3359aed7899636c3c31a797031ef835dc1ee972aacca2ee422d90e11670487b5cd37925f587525b7ae500f74295693836cdd03449b0dae90d88055ed2b26e69b5be27738c802b117ed2c3e2fac4d053901a0f13ba84b7f1005c4db7029dad11ff927ef8af8dbcadcdfdc8ca70dbc3d642b839faaa445faf6a9b6065072431d8c876ec89f933a506ae01dd3a7c739ed7405dad6f8bf1b5f05ea3199565d873b485f739994c533a4aeb3056d7882c5c8c421276a541ed259a40489c861575afbd766f75cc6935896809379a7e99a6a341a2a4ce1ab6e49e7395f250b0c40818d904fd09b4c37e19e4faa692d55bf1eabd3f4259d2b1e41e0bdfddc59081db0f05fe7753308cafa8d782a45bfd26265e1e9c5525c55bd4dc6a4640d7e0e471430cea2163d8d5146d8619ba8553bb897bd2dbe5f5d54da43a7c451861179b8c7c2713986523daab8f1db56822f2087aa26e3a802da0e85a79dccc41f3ce5dc53d678364f1f343d7fca80a0949b6b9fae16dc03e7551191bb7ac60b256018ece5ffe6ec32c1ab9e4a2ec9d51678de99f650a4d4215b9c48647847edea466d5f75325ced8a2d9a19585efc3f0990d1913ab34a99011d577dc4b82e06818d5e84db8ae81b556cb1bc2db2891bb962fcad975f321a9d619e8aba69beb62c34d2d09dfe929d92d8679452f11ae76b9fa5be0454793d7edeb7c14fdbf7e6c191584d662db4e56025bb14dd02f2ef1fea26eb80b240df0db11531fc5187448e18056a29f153ebbd44564a911441daa521f77cdaa8b006b7a7f6ad319418417a1f03e420aac5f7e4cd3d76f696c134c7e433179edb865058e49646a7db3e70f188f4b20746f97d1019afb87eee98dc45ce231059eccd23706e85cc8c169f7e5255e6a96134c70aa3a63a0d1f316ba294792a9d396e0a6587cac2ab3f1d9b9f5907f028d31ce91a5c8b6ddd4f7304d524baad738bee03818f5ee2cfc39ec4d7fa9761bca801bf1710b5b8cb631c8830310bfe9c225de6fd4c26f086e4e743d10821d4a7904ef730c3be939c9159d0011b202a6eab7afb2ff2e6202a35f41af734d5b48ce5bd3e337b286d0300fbbd6e0daeadf5ea71c96c0855859860820edb02ee12d6c7af4e254549189a886591142197844e6237c3f26b5f89eec8a4d4b4915486073b4857dc3694dab73011376ef8f842bb624b85c27feadfd4e0c64282d54c1dfb15f4ab928d6b5088938157a6af9f859b97a873a73528420f5793a0b8a3f9150212cb4daef196d8444553c93fc9c5ae3d59be540a640e82ac1edaa6bc7bdbb1c1644dbed6f2e04efed543b1129579072fe1aaa2b997923aa5e4b966830051ca89a1ec33f0b9c549d6761c37804242b4b6a3e677885ee315bcc09a2cb038f0d5c4a7cd188639b465276cb3f45643e9dd8fc5d6a5025bac9d1f156e1838dbae4fa1f6e8eca70486debe3ce41274d721e8a80dedda80ef35c9e510da8e73969583d58cd2986cd871e388ba3b9b60dd89381edb4029761157dcb8b4c543f29f2da234a3433293c84df97f850621774775ecc521c1710da2cf290ece7d6e7afd1473b5b37aa8de923e7edeb0e641cbf3aaae915d223d0ce3cbf9749b9075966df76af21b1a1fbf810abbeb61169d3f38b083381ee5e15e91d6f83e7635a8f2cd84e815d1b5258fbc0dde9228ecaac7df4351d618a5592940b946b645a72c026e646b062974f9992be6b0d16fce74a2af708fd8cac4229add3bede1cf4bd38bfe6f2749fd29324173e638aeddf27cd886945c480b1c7026c2487d2b0bf8dfbef412b9e5b409080276824d3a34c8123fee16ec4892de7c630abf1a14bfdf9635e5fd766b241d95efcba8fe94badf3582bf1032c701930cf4a28a32280bc0e27360c4edfa12f152225aeeffb0d5b7e34973affb3fb81b42ca3c0a5da3a37cd936e12dd4b39f8ff6982c6ef10e6849c0458e0462d13adfc90e78c9add7d480f9b5fb77aace98c0eb90482249e52a45543a4261d8ddd5880c5f0e36a66847905bd81243d5b57c6fd8453f35009e19b0e9a48365c035be0364570deac9fcc49268eefa20359c5ec1fd4511a61947bb4d75a35df468dfa8b6d4eb5c28f89b61fe6be72899e3cd8b2f388584e8fa90100788bb7984d956de79301e1b682be7448fd6c8e2602450fcc8419014239a9c744d125848eb3b5a57bc25f9cc461b443bf94c0d02cca3f1da0a057df1e2011d5c89e96d21b016b5c7ea67f5aae05ebb0a7a201082308c417990a1bc8d56bda3d1977c590bbeb7f2238834baf380f0ea5da59ecad6a96fd1d767e25e85e6f5f3e3fed2d74033e6734deca26459178cee0e695d26ff4b50460ec64cc0b5d2a033cea6552316159fb4cd6417a738ed99798d8db94daf7ff265262e465855a0233b954a93f32d1c58491fc3641686d44ae59b2f8bc126d40bc1a6cdac47e18e633c07ea00669727747102fa3dd2f013953d42426ff7e744c458078d1baf2c7e3e0c608185cfe457d64d8ac4f194affc15e95cf22fa529771294ea4a3f148bab856153c87c924a339f5f35051868bcdf02c31e7a0da2db8a74d1cc14dc5544fb736784de7b61cd46b6a62d169e35a5eca61d8106eaee9ebbcbd8695283ccd9ec66768046ef5afca4fca1ab888bd8a254e14a96970e005a4dba5afbc7efbe03d77e0b6eba1d08c77f564dc51c48a7335284f4f54a53027fafebcff73981e6212f384d4d8911326c3e088b355233d6600074d56c484d7d02cf42af28e38ca1c959a2ca9a55739764bb10958d9e570f5281a9f5dc128c6389f8a5e139bf235f9bf02776f8854605fba73eeab1a3cafe5c4829d98111dfdda6af25c80136daec0c463766197914324dc92bbc6666ebd8a8016a50604fb076f14ee327ad87f66002a1212efcb77a20284d7de4bc8eb1bc12533bc842f8b28ccaa1673b962b562b971c458dd1397f2c6865e5407b1cc8b340be868421f22cabdb7c2a4026d9ec3a388d1ea867fa76ded0cf713f7f3ca75dd64661336611ea207d116b885fdf6d4e7595e2fe7f53c6584c0396e3d9b5b2d2f5797bd03ccc4b64d0a2a63ad634840a97affeb0ed7350f2e15e011301ddee103ee8e7bce4bd31f889ddebd306e37b893104fe2d7fa5327e57cd3b312c0efec5d75293a3c557ad497000feb285d0f911f354fb8e3a10f7be983cf93ebbef7e12c7653b0ead00ebeb419508db7af6607bd6b7d2dc63557d5cd0dbe5fa78d2c6d5a1001b6bbfffbc919c65cd6f57db9abb89e1eff274fce04ebad92d0f370fe49c09bb42fd272e5e2a5aade6ff6fe6556edfaed9b5a4a5339171527743d1db688faecfa6ae5f6cc4739b81a9ef9f928c72e44e441c124a812c8602510defe88bef70dd9297b568da32d1814cb624a660fb604a03b8f9807e049116322ff38249eeeb1ac73ffd8e018fe9a8462701f7b97a61652711622d27ae3f442b113dc48c34dc2a2b2298190b095e2e384325e6c23120b34f1abe6cfa72b17d4eec5c6c1e2723285986ffac6365e50aac0c2d4e1f52af5d847e9564a06faa192ec2e742ada37a50f114c6fcf858e799e5d0ded32c56becf9be4f8d31e4aafbf95f79ef18d2b5d9f2165e5a0b4590e1110cb193c100416d6c6290cba01218cf7c300ade70c6d02decb76cb08aebe6321ccbe0ca3e283686c0eae0934ff747ad3e69cba450cb975faa8a2a9d4b7ed59b233c6f6624d4bf3e46ffc94887e28888be53d068fcb9616284a4bcb22b96cc9644141e3ad1002cda686bdc08c04eea521b4fcf0739207d5bc0177aca8ca94c64c54f6cd77ec9d87cc98cc7c6b923e3acf4871fee95d0b479d06e1458d3e87d972aaf2af3577f6d222effbe142d47f4e143160b1e0cebd8c40947d5fed4c59c0fda6d0d45b89459f231643649f0b9c48c82f3e0924e1e08f477070ed1a1e1eba6fa4aaccf185b83b7717510ac8afe39fe91df404334d7a5a4d38a0281b64db617aa88b32467f6f772bfb74f3ae5b5b386b96b55c3858588c95327ce238af981fe1b158bd81bc5a80da791c5170864f73320ac376d05c7bac8103a1195d04bcc9dfc1d42cd0333281903d638899e6e3a0fa4bb5a34b2b05814d5008ffcf8991b0bf7335b2059703f2e932a8a2f130b64ba4ac08f38be2bb46a373dae6998ca7f7bd20d8f5d74bb4fd6fb51eed5c8f316c20884102c04b242a6ae8678fb45feeaead1404c50e8618359b67c1e62071062554f3e74ebc6ade79945cb55cc5c8a548a3e3e98817e3256e27e75adcbe8cc6bffc90b639aedb5508bf53ad70b0e2e4fabd1d3155ab726095510eaf8e796771e39100e749450f45ea4bafb94cd3ff124a2f56d8cb9272e82ce78bb8ef20205cf7f294bddf74d64ceab91667a0c453e4e8ad1b1d6c6f476ccb26db48cd875f762cbe0e4d3ed9f977c605d2b5738ba9b7a0a6b2a97f931d2b814c640235bb5407ad1728568675cf78347cb3fc2808858dec3055da8d1600744b59dbee8e73f9d198ac276ffb44f89c7f530dce9f1df827fe70a4c5c1570610d9265c5ef299f09001438b981dbba0140d954a7a8894d54635786dc9ef3472918591a59c21d7dba6cc5aa17de6b816f50934b54b6e307882d9f2c83299be0129b565dc1999c0278f4484b6f42ea7b8df22b45da278e0dc68d3cd7ae494f8c677225b96496632bef3299873e683ff31e5400e8bdad3ae3f794bc91095f4f08cf981c7a8a0f49a9741fe328ef5381d046f4b9dcda6320233e707999a7b839046f4469e3e70107ad7099d3d184b43e229e470d7b2c156ffa7327940b9a39e0e2530417cde52a740f3c780ee05142ae7436e4eb46b77419e08a7e87db09c0ad95846b38da39e240814953e61519a4b1413d7918577fd7625dd14d5c7ff5b6ecaf70c91eeee372e9eb6bb9e666aedefff0726297d0476012515a7e5610f17a2bff6a028aae9c49c038da4337e899cbb71ff4057712d3e985920e971dd97e354fa7ae3e33c947fab57d65943cd92341faa491396640c305af9e9d7f4bc788483bc5ebb232484ce55c0872c3ce0ea4e3ce73fe9ce12a93d2d45650eec9d1b85ae95b5b70e1d8f064c9d267d78baebfe913e7827a659ab7b49e2efdedde3c8d2bd480443b68e75660efebdba9d132e2287ba40f02cbe729fe073d23562810476c3e5a4469650f14afbb760033d0cd674aad5a5d8c9a11dfea23957c7c2c10c0363091ec766f21be35f499101a66f7855ea9244ed7b87d8ef20685e37f58cd6b5a577549d9fc849cfa00a5148a044b5c80cb6d60c1c03979c23518d86f2dcac3a4dbb271c4c5503ad146830f4f11f10353b17c143b4f04bda7f340a7004a98c18d6efb188fadbb4ca9a3d1295afaee638b435c9fb732c8d033a00747a70acf381a21fc94ac9a482b6293e21456e708714bd7bca68637bc63aefe7037bb5aca7b87a591dfe65e791ffbba5a22d2b18de944c45a2e5f20bde7a9d942d7a0a1c61b025575884f79ef7dc5d70b6ddfc43fcce88f67930459f94f1543b0cb844137504b86c1a08fd71f4c957bbe1d192525914e5a61ab07f72c1b984b234d5d7f4e74268d89f0b92b314cd1312cbe3b2659f5b9b506dd6660dcc507796321d334465d862b2439691d1ee23385b9533df6a013912738dc5d25525c86df528f368a20cf522a8c85ef71d8c2e8f08d2e4950b64c9ab16c9de380f9a42a774e5bfd52d784d62dc6255e494e7a6709fda35f7e375917826e71668f128d4f1368013f8cefdd6c12d456e2a9637de6a526908401c0b7c875aefd426ce85b6b930ee42532d3d8240d082dc85d104353dce8423ceb8a876502b55925e0c50dfe69c0ee62f474cf5339672e55aa96a31e7765c176f560d2be1948b8abceab07fd0c72497446a92858932397eb557d437f198c4df8e3724addc1772a5d03fff84513627be7944e843547867c2473c9712aa1d6e812048222248f9bf1c3f8f45bec22bfb9ff2fa28e60c1b3a9dff0523a82837f8aee3b5fdfeeaeed6b39c36a7bdb811e4296fdbcbf07693ab8ef5851d9ac2b0c5b57ba59e9ea4b216455b90af47fdb40e79ce9b24655f8da04bd24680355f515394ec5e813170c5b72a5d71e165a28e956d54b8948205c1da99be2e09511812cb5d9770c73bfb03ff4bd362312c71d32000d517114745adc1c7a087941487d917d632e61f8ea14edc96170084018d7096e36be1a1c8cc5fa6882b7471ecab9b3c57c71481f175e741b9a732e935adb932f3af9852de4779f9c80a0c856c1572402022beb9cce2db4b0d48b79a2a5e4c76d0bc69b0e7801481ccb50f7a73cb6924c553b4dc94c9b41ec141dec589bf0782164a103e728833edc82bd3f5d653a1ee5c109c947381b86cbdfb863e69e4631a24a1fd22f7bb8663f11432ba5464b919a3ebb6ac6e7085ec6a6f086797cb547d9fc7f91adbc872c27f6f00dce6491f803f1f7e64c3e0a28812ff637ac0954a11aed13d07418db4ca7a3b5ed8279294832bff4d17f9cdc801004caf138c9000450c921eeded761d03cb283b5066aa06fd4e9bff17263f8976025bd248bada40acabb164e34142ba2a700163e263ff2113ed7f45de9c7c265a3d27db15751c295a88fc3632b624e03c8a0e5fff5c1277f12fc4b403d289c4ea57fdd3e0487ba8793a4a0c6ab86cb75d95ab9ad063564575ddf9e9b56aa15ec9492fcbee1920b8481bd849fed79183d4384a4138f46019383c2108ed50bab24db948bd009b3ae027df461c12c62b7c17505db803ae51f43f6da344341ed6d9f468fe66d855162afcf8b3470a459e78d45787d1632c8858ffc47dfb0bd0bf778dc19608e1ca59a4c0a5954a490262ec76546fa1cff6a1f4a02166211dd7cb268928092f4f84ad9587d616d60f908f6a40bd701a17014b0a04638b29c705a57a8e45f5d760d968e0082f65c92611f143a1f2dcfc5bbd484106117c91168b92bea791b1d7d9c2387263a10f749b3e8c428bea2cedc8071ad0da9c9be27102854327e644be7b51c3433cac167ae3b6a493f29e0938cc9d21dcdc54fd0bed3d584928e66a8ba1ba059f42b1bc2f4b461834dd24ec48afa862f942a799e197617a7a07c79a713a5aada0cb81fbe9ccd8924e0b377bd364afb16fa07cdfe586be346072e8469afad10df4f0dcc4d9e0089c0a4bc0f7fc362c192b8d50b67cab7baac5c78d8396c21f8ced9d3e936a229325623489aea76e0aaab876758ff236c5594639036fd85f697a635f46e9ac62bf2e5dbbaf34290f0f048e83a0be005ac5a84c2e894ae7b556f33355b7f47a4e250382392a828f0703b35c1df52d814c7d5e44b39492d6a118579ee53d279ff49ab5fdfd0cb23ab0c42f905ab55c4edfdbb7d30f9b5439aa58247e6773a003be2df3abdc34f3952ec6e23fb93466753d993e369c8d3fdcbbc00510b4ec9fe9859c7d5d3b23e5aeb6b58b748805d6e3051b75faddaf063c984fb804cc7d94af40194217209fe22bbd880a317c1858837651c18f4cc33b554706e4201b6c579731402ae37fa342ddefd4e99defaaf165694b7d5bd95c4adb3fefa632c2496316a9318ee49308bdd7bf4577ba3f0964e756053e9eec6da171f9648853d77b6409f23e0bccd493b3c0bf5ae2dd813e915f52517703b94aaa224deed5cba668f2e75156235956904f743139e66f493cc25c18d20eaa81de04ace623eb2bef2ac9e7b39370cb7d96e26899e615a5953cf32bd7499b55c01e6a9ec6d6a0a1c1bd3577d595d029cf1ef3406cdd044b69281ee40749f40bdb3f1fbf9df91c59a56a3f6af1d500ac5fab8fc5cb10cbfba5e9ce406ca22e68f7fc269ddc654e6e161536822598098e40f2c12eefedcec07aabac56e7ea0e0f99e2b2d7e1224539c9d3fbcb83d04f3c0d6c34c9b6358accae2e668d32118cea49dd2f85ba4ee2ca911c718a65195e51ed3070170bbd75ffa277ac4d825589bffa1793ac460b3c99c4c90d70eb6f896d75fead4a03b642b420e1cee56bde9fa7dc8457002e5fdfa5c59f5d4089393c4eaecccaf7dbc9a123f3cce0220bf3f746692720be52d3ab3cef0edc0bdd5277f573b0228f81d581cf3289add35c71f6da560285c140fab1eed33f58bf1b0ef41a5ab1e83946576cd7926b9ef2b8c6b3846805c6ba2a3660e6f5e34be7ff309fd4afe6fa5830f29bf077a3e4020d6f184f6c1b67bc6050cb10af921979cbd73db71401d23b502d55697d718988abf6250facaa510dae940bc1f27cac927664b106b4c2f4a2d5330d41e25863676cac38e8ba457f800a696d8a0f8c9fb1134eb5697d85ccc3737795cf7e568e93e213674c3ef2b084987316a6a8004f4fcf0d1afc714d3db488cd7ac6d22e14e8b3604e883086052b915646142c37cd2a22400980e9be0e8753b3b8905102c4f5aeb280c0ebdb2f788eda6f6f2dea901d0edf904842603997e2fdc6e0ff95c3a31eb323efdadea3f1d4d0df676d564e88ce442e94c3d1a3dae334d0c3864a21b5b6fbcebf39435021050622420db2961fc565df3194592919f03612cf724312ebc9b568cd66923f2f6e4eef907639a0beaf86bf6ef6d22ad331155efa0c18543fa3d656c623a285d5b0268ad28603231e646bf5034d2eb3e577b1229ce5f8a4c7ae82d65710414437a1372c52bcae6b2c4a7c931de259027a5a47bd3b303309eb7793346f7df078242facf3508cc2da0cdf9169d206dfca9de5e52318e81a36974df59628fe849233f44b97e4ef4da19046e519b88468415a909135e9e5eb66e3c3578ec483479d3d4231893d432694dc8733a425a8a35e1e4169c039d18f4291399c665963627197989bafe78fde5e76e28c58a0f81bc6cab7838d5aa7b8e00a38e6520b98d5c2229f7e70e1d2c03daed8a6a6ba1980a5151656500451a6b2c3ad6835ba3c67268e9544d420835a81795cc69f6a2ba02f32b2e7d293e28d7fc8a6ff8c2d18b3411fcd331ef7ab2a4c422d2fe525aae5a4f809e53998146e23a55e579991c6b99615222917441455650dddb69312235be04c8d3952ef7152386530573728cd613c956727f88be40449b1eb94cd159a6e3b06362397490a04d407eebccd10317e2b539298445d82d6229d10ffe486412c090c0f141efd8b186d032389304f688b4d33dbf5b42110715c312a3dcfc593850aaefbab29d2cf1cdcca9994d81845572cc0efb0b2ee7c9a2cd1d8fea0bbccfe5ff8e0674fc9e6cccb29bf9418541c368a46ebc3bd9b4522a5521097c4fd553fa25e9bff781aba785069fce0579328db425557943e6497ec2bb3c93a8b71a70e55e34b12a707a2c3c5c783d9689612deb51089a6a52919512e8a0956f4477c97f38dd8107d650d306957a690db6f1fd4bfb43f3a4c122927b0aabeda0b9e5b9ef9f2b754b1d766d6314e6e0230a7104fbf58aa68fe32a9d993baa34ae971f2b15539987dd995ee1e3c8e127d6086c83f0f7dda6fbcf92d56e30ca725ef43d5f25a210b83400982bdace4b4a8b29896b928227abaddabf542f1929536e0838feab2e7ed2b4aed93c4bf1bd0a516d19009f0599dee2d591c99b9e324d9bb1c231c117ef2a8a8fc0751952e5faa478ad19898ba35f9291516bc185849e4a55c16757e3e0eaec4902f9ada353f3718434aeda0ba7dc6f2ba5f761ad4dcb6bc435c3160a65c66d94ddad55735430e08632d0c19b6bade998941d05e37e2df6746cdf408954a3b0a9fd14947ac2e3d4c9e296cd98e8794fb0744e28ac4375230ab2c7b0b7fb0c2ef759ccd064622c19d0898324dca35c3a8447a18c24e692c389f91101b5de1e6cd9838756828aa40240e4a92956257bee818fed05301377b48bdf9c116c690d1472193e7448664b732a9c19dd49ab40a32699b9a42e415a92ac166a2440dbe5c0d1ba2f75d6d96851789a87de6da4e9a3134a83af336a6376b10f3d0a4aba43f9ad7239e3dd93985375937a2bdab95b729391729829bfd4a27571582fe4cb00c74634db77080428878c9535d2e9805f51ed3f1f60d2f69c8e203659f7bacacda54c4b2a3f8060ce80dfc02460e7d2b4f87fe2dd532249442448ac3c3d2138cfb54ad984d7fc7715c0e90469119647452c3a01d2c25ad36a138a7f6ce7be3c6e7450a749c0f783f1d504c9a9303ac6c1e0356fc060f7a10587bc0ca52c91ff78d40c01a2f5f12954894bd12faf522134f9ab339298b50aea4701b9982bc87e0c58a783aba798aba23c179c90c707b0f16ed2487a1fc163bee278acf7a38c8203296b3faa3cd03c1bbdd6b833d0f7384daf04d8f35b131271445396d558deef2616340ea021903a4ace793c36a50b53431494449a89967256275b03dc567978155a509b63b24a77e6076a89ad4973c0120bee086e74bad1bb55f191ed124cb43978855bc724587433c121d63ebcb23288925949a2c35a0f9f90acb531eb57f22dd80ea9f6c994ac05e0bc9aad7096c5bbb15984bfe8e82b9797381cb98a13bda0c4c4069578d041d9749e1638df1e6bd7041c84afef3bfbe1d8d5810c4ce1ba9ec6b2545577e3e03960adf39ff8e7a09c3359002ed01562fb7c7d09e011d0089e432853fd8441151062db5a57ed77ce7ab7be884da2ad859d41c7149bd9a40be4883cdac889d984a7d93264e5b68675569f1d022e869daacca29042ae6f830afdd7c5c0943872590d11cda0d1948a792c6faaa1d9efb412f8b0176d0abe045ad02d516d20568469b74a77d05ac18d092b2cb34aec5d15d2e44bb9a7a2024afcec60dfa3bdfc0f61bd102e1ba2a7df39864c250cebee9b597d65e8874fcd5e2ed59512735deeda0cba78b19101771655338dfe0ea6f5c0c59b8a6565743738c9384a40837eb7addf2bb2ad4508a0d739e23afed86771e0384e17df2234e3f178f98fdf9a9086d261b2a1ba5f7c4d922654d7b8a6d91cdfefa95b8d689016f895d5dc29471f6c8539b537b23e03a399dc4c9a88fcacf38cc6b66b8586f7b15b80bfc9a9c259d31167b54449526a1fcacb27c2c78b91503c9de76d5e3dbca3109fa7107c78efbba3c94caba6f693591b29fbe9bacabf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
