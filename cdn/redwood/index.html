<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5523899f09d377c39a3139ce448d66105758c354b08a3444d9d1c7f9e1737c5cf9cb5b8fe47b7e16338add2a384d61844e94a2a2ae03de41e5830d7c7d9eb770d0766fd84d09e9ffde6ef8debeed1a765ad4cec8e20868c37f179a327135b7982ece640232380c95e247f0f6249ecd4b9444a21edf5d64094ca3359b8756e02e9208a428c5bf7ffb2ef3c8eebe1394e8e47ef04741d9e5437251365e1792e8c08aa0b7dd4ba949c4af8ba8c4cf05c400f43820016dc3c82c96aec04ff6a99c5c233d4e9269fa70646132762bf641f130d42ed617ce90550acb9a7599a82f8b9a7e960229272cf3dc99bc32ebfb6ed0b818eca1446903b889b8657a87081b6115b6931f907d519e89ad921e25d37c48705517dc43bd371eebd4157cdac890abc423f30d232573d24df63fe2efccce9e6480b58e1760f3f937b2270b570fe59363cbde3ff1be9d780858b5480e7a7b3d992f315453467cc654d7e812becff40758e81790e1c5f02eafc26728972f70ea7965877e6853d7ef3e20b0f6df72b95878269251dc0fd4837ccb607594362478d8b7088c4aee74cb984425e08134159dd3560f37a290e011b5b774e46b768874bd2ca41904a72df43a99f437082a68438725f09049d10c8f505ec04fbc510c1fb96ec58582fcc036f1ea6973c524342b4d44fc704641a4850ac86b71d82a2c04cbae62535cfb56c92c034c72283da3599b3451311a718ece1ff98e2076d0392cf74fe4b1a94ecd4efe02685c5b6f1b3a5b69d4d85a0a3ec6a5e1508b76327db2098c0724f5b2e8d65266616e6d9965846c3c44169197a0e37160af68659e9d061334a7c0fcd59e4ced5717b84664622cc91d5575f04c2163ce7f5dbe74a8d3a811bd6d5afc5b06048b2896b7e35b1d0eef1b67955491a332dc832607ace1228683f7a6bfe01ecd48db6ef7eec75db024165ffcb0681ce87b5048283f75368e5235e5fb6990f7ce380876f6c94b88bc376dc0290a601dd52cff34e33925a66ca0baf4a962970a8c1432737b61b164370bd2c1b846bf049110cf91ca73830faa3a8deca4ca4267572ac28a4728cd92945ac7498d2e59080a83d2da2b5a4d3382d5f053ad057ada75a50859140ab141e6d85cac2b1dae5f17b5a200b733760493985fc3f2d70160c57bdfe41a64ced224839ba30fba50f5d7be9722472ec46594e37fb0bf138e38e81f254226b0b77a4d9d0cacb1be68775df160f4d8db175b6d6d25b6eed9a87e411ba89485d248bff8cf43a06bd3eb3f78d7310f8ca9cc0303a813f4c3d77a330395dd8faea555a0a259c074c22b3ee403ac7ef57e42a379dcc286c03dfcd93da74e4c8f7426fda1ee1c09a8178dbc63d9a07b6eb753857f01e2f856c59f21375849dd3970509156d423a9d6e9a6015bb7877c76df64589c0c2e71b15a54f6f4eb337f9c8a9822dea343541bdf60c575fdf6d7eaff8256d112c79facfc43f2af5d719df2b8d8b834e4a64521059b56ca00f92cb08df04c2149445254f233fbb8687496998e50bc542a747eb7521d30d70a1d5740622544b2f9b868377340354e2fa2d7526083b465fe3082813ab5d5dc3047c25de3435b06c0c0fc73e78f1e6d5445c47724d6107ce08dec4bb81bc596e390eb2c172479d3f1037a5e7c323c74803383b5c4e7d8c55a77d4deeafaf16bfcb5ade4edd338fcf6ca9e52a9dedd3644ff5b0dc014f16eaa4cb94182644887bc67b61e6b008b98840c56316e9161e7985ce2a7279e82c2030d0362601b044556304b5b03ab15062821e7b2ccbd1bc6c9b958cacc0386f094189c9aee0f0dd7a333638a9fa75bd0142f6dcc7e6b5bf0d3a77d820aecc37986424d671d9290aa2df225fef5a8e6f02ebab6d25105ca24092eaef50aa20801745ff354a5d72e5429c0734566104b4c3779e0cf4f10027927c24e14cb9b4b6f0e3144acff5144903c6c79023eb62aecf7b09e6b3c6e86cf9e9c7d42366eb3dd2e44ca49ac3c9055fcae12f7cd72848883d89d0356ac9063a22aa70dbd43c249b187027836daacc32b8f5bff078f4ec2d4de1bea3e6f2c37dc2803e60ff7dbc97ac3f83f4c1143a9627822e1d11162e792602451c875dc1678b83d02eb38a90c68d0b58677505ce1c9533e66e4d82bc16edbab30e4d9697ba5ae6b7f8906cb9309b65a7e7e6a7291fb811c020e13c190aedfa21f67177795beda753bfe3aeb4f8fdebc0b7f32cf7f240d27ad52dc56309027e3cbc74b4b81672365f19a32aadd1ddacdc79db7fbf999e8f1f9c246d21dbd0b547e40406441af4628eba4ed1b2da48483e75baa4a0474226688247c76932d656adf89eeeadfaf069616d71f48009fc91601ed5945049b73a0f0e76be1f5235eec05e42de1d2178476684da8ddad7e6e07fb2f429b4d53ad2a76e39271df351e0d786db4e65f06e9f7be9c2598e098c567bdf11cc8098fe9acbd88e3b4eb126c0e07156ab97479c5d8f67b64990dbb07da79fe88747528a85a7c9f4a321d09427388912283555c9cbe7dcde913caa35d986f8eec517e5ade0674c4ae37d109239baa3716321caf2db59709e7acbbed6fa243763e8d02280e5154cc0d417b6121205beff146addd7bdc6b3ec2c0108cf98bfe5f8f63d3ec9eca21fd07f625c56cb1bce6eda1c84bc0d7fba5fc8971fdce33d745658bbecfcf6edbd5429b921250fe5aae0d12f0bc432f28e72af99fddf5181192327ace4ab2c22ec129c3badef99241d25715a51bb7e8130b0824a30fe9febe4043fcacd0756430f5d2ecbcd55a4073394081f0e5398e4956cca62c9f85e2209d489abf49bbf34501d88ff1b9657b44b1f1efa9d18c3eb47e16d502fde29fed7b837ddf6ebe39bf25b26f90b4487e9666f96fbe7bee4b323c39e08b588ccaf0c1e03b30dd29b785dc2ec11d445b35c0cd4a742b84f2b3dd36eb78189799ea1e0d9e8d79a3bafabc92d3ffa2f437bee4ee2f27402f3ccbf35c08589f49b856628bca24f99bcd96b01656ef40199b796e123d8362886b68938daa66a53345926a13deb4555745ac59c6d1ab4d584be7ab54e1b7db28decf84b05196754080a894107e42a386581ff057c3a75d73103af882ec4daf9e709de2fba88229d39866f538efddfd70767a2f2a2c52b56bd37930997d15821d6b1412eed47686323b7625e388768e611b0e821ef1b175edffd001f9a075315840d36f88cb9f0777925f9b033db781ec5eb123d45d6266bc9f927942d3397248e8967ecdf6e8e793cd0e823dde74c731563781254c7c7fb1cb444c0070d2ea4aa92b330804e32dfab5105d500194a3b0f1fc48988391d1a4b1eabc770f589eaa7a8472916a726ebe3898919ca9ac3bb3b113c2fbac0e885827bf705926aebb70dc1e2b148df8e04ec7958bf675cea25e44f2942d74bfde24bdad62be131e3f0295bd22c4901fa9999554a20dff29e85cb5e3adb2d7c3b46dce18256426cbc5360586fe21e60be9f4427de9f0c2e6dee5da1cdf30c143691538c6bc4f721d57e52cd5df4b09170672ddcea17aadbd2af425bafeac6da24bc55db4d870f91a6e812433fc85c416324b9a625941e5a223a993be756b7e4818a7285ca9e86f4c84d276549adfd544cfb5302a7c92dc9cd33abe6d09410fb710efe1da6f4d166a4675e7cf404ca347908675c5b8da9d230bd0c05d84895a8a8600a1b9980166dcc0bfaee46fb838b4f18bb9115d65d5106b30e7c6778f01f854561b1631f3b5dd47e763824f73ded8457860dffaf853dad1da541213df5809bffceaac0d5fd4a31d297ac455fb10658a0ac9df980c6e5490127d42d653957769ece104d9e19760b36fadad728c1a06918d867b37f6006524f9724892346e6b6a78638e835e96523e6b7ae6197b43f772b206bf6f087fe51e72c95a5c7b0a6c4c71b59ba9265265faeba04d3348ab36c740648bc589c9e988fdf6ce98a4069b692d6219947b1774bb87e2188789975e5762e28102028c9d521014c235ea0f20599524687b581b2a911645a19e6f9acf16e11e17d5874796b043b09536efd48e6207a11a124f9f8a6667cbb409cb01da0f82b74d15dbc0fed77c3f49a1badfe813d3b97aba925405253bd3fbb882795702fe6e5171ac09889e9a0e303590d08077b5f76d833b160f964d5ff6e1d2372fc3c4de78f40c2ef764f9cc52d8ea7102cf265ac1485fe1f3b7c8a57e529cf2fb7e573ddf7aee294e50cb5c49cf952f25846e4cea760cadc091784d554f92e1f1acef54757fded7af8dc51e17641575f8573037f50adb9318586f7cbbceabb8a87ba89c578b37937e10c5088538c33c2989d6a15330742423b481a815be742e1918d4e3e1d8b7987556fd23a047bf56346a3131b5a579bb2952ebb4ee0100dcc55b72c9b9ecd006dd20eefc4195a009ec8e5d75eb7ac1f09b1011495b91496c83e834b1bf7eeb465e10ba76d8af928d1fead184cd9e7b367ddffedd85c78242e465682a4a3c93e4236866189cc5e3af2c39aabf6cc81954aa0309c5af94fcfffb96cb161281757b9c11fdd564144b7186cb5bb8aee5de1dac5472f4c34476f35b768e82b0aa55eae0d737abe94c43a573271f742e5619cc2d44b9ca419f9ec380d9975c51ecf8ee97b1c1da6565a2f16a4248eac4472876ac27f9eee978699e03ec5948af61e3314445fade59a5812d96490f4a20f146ddaef3eab3aa5e5fe6bcd3fe0a8816547cce43982412a75cd8ac0753efcb5f943d705732222aabff256256cea208bd1daaf49d034df7de54bcc7d78422b494de0b85f86dce0743b2dd22850797b620ff7f688c385369b4bd731d75760f7ddaf480aacb0ce4dc01c519f8c2f2606f6069b7b39a5bd78da68f67f21a62d5e88ef17fd76c45a7fc4ce1c68072e96f5b7bd96a6d778feccd70ba4333fdaf56c95b2466c273740294e8603e25d44444ecaa87bfad658b0878895542aa2aad911904423bbd26e6caf96da206aa5df5e60777399bfa5c52269681d32c6cf0519ae798228e2389f7369acf72c6c0bebc03eef9b4b487a9d167875bfab481a4110b4b7dbe803f67db1a34b5c6ba0d4fd842e5ed9b3b8287d216f28ec3cfed233bdec41bcae7122943079993fb0e9e6b209faed5531890333f84587bdfd95004cb311531f9cdb3265a223889aa3631ddae7f081e5067be7ab54941cd5f1ab86d06bcec65909e01be47b39b837b327d6091e49ef3c0d41f54ff1d7d4e135abb58b9a937fe7804f9b7897289cccd4690020143cc6a69019bfdac4b6019fc342c57225d3ca97ac7a0a486079dc2344ebc3d419400fbb54e7390f16721807e4eb388dcb4c358121be81e6c90d7f10f4951dee9894226e68407d2a2e66b2145d47bb347415600ff10251ea35d25b8cb4f4546e7467424a3a53444899e85ed87fb559f6290d96e19d3281754b5d1948b7ddec9d7c03785405187e6fa479344d4336d9bb4805af51e119f123a2bb584e4542349a4163bd2faf9eee09e3209a67224b87fe59e1b02abc4ead660803cd587818d369c155486e69751ad8c5d5dc3cd63f04498332a8c047290e30b4cfe46ef6d82bbeb694b0afad57606a8912b852f18b2eefcfacb94463f6df378bd994619059c1389934d1baef8fff06a314bab351ef915c9ce78166f541c0dee8282e2a1d892b3650094ca38a96f033d0cd9f4bdb731335d72dc371e270dcedaa89e7598e7b66026e73e84a10de4c80edfc54403ca925d32868872961397ef463be3b75abc0d94cec266108a69c6400698afcb1b982bb1f4278da7c50569185fbf1f5dfb242056f0293e83edc6dbe5962bf082452d66e68be353e784d5fc8a5071d18145cf40f572bce358b8556cecd15839507b8d989751c274bab0b1d10c46b8215dcd86c1f3b9cc5a80b01063aa33da0f34568fc55c4602526900b11e5622d0bbaf9523190e1bad1a06728f558137c5be25d26644d1dda55def495ef15f809e8c4fbdd070706433a1e01c5f9a714e8b02a7cc12d99fe0dd88d28cb8470120a9c0c01eb802cfd6881101a3a17061d469709a7ca7fddcbf2f00fa3fffdd681d6ba99201d0da9f8634d87ed780ab389314b48296ea7e8c3552b5858f1031e866b7366279e200b53dccc124889b135dc422ce0480a07fe42601105725c2ba7b65b8271dd5bdf9018a5215f7cebf0af3751b8d4aaede6e45cc421efb17b46a80f67c4c2e92ff80e569b65d8ebed6ff3c6d412f2767a74a61d3a5ad953916ef478072acaa799246fd66e1430aa24cd3fa46f6535aad96c78668f61f868c55f4f4826c5f5846896c39f70fc45312203cfe468c92a9eda93b3472239266e5f9dd2188d3e20607e97ddf85ec609095917ed61617ce3851c6580df7c266dc48b9aceac1ac67e7d9ba9ac6a93cb0be0928db43c525e98306bd8886d2491eddfdabd3b676b1dce03ce7511c1cd35437b3593c711fe83b8ab1cbc0cbf573a080ff2c8d13a018e9f1a46a177dde833cf181a63e28e79f4a6e4a085c55d61f3d36959b747a3249bfc330dd49d325afc0997ccd504dd7e8566642a33bc47a51d4eb0c8b13e5d386aa6b557c154053dfdac7457a35ea9ea64382ba66dfd3928a14e1aadda329207e0d325c4226d145ee330a20c631ae6a09fa21a47c2c75bc006977decb7d46aaf1d6c927e8a1361a0c018cd148dcb833d15c714c59889f59ed9d358bf5e266eca5ee0fd06b7364905a5cb3d536180995e41dea191c009224ddf0c72950dfb6cd653f95028ccdee38db60da0748f3b22788b0d812d13b26582ebc25e5fb676c014e13e25e2a64a8c733d007b01ee6166a45e4d16f373d02409fab0a7a8a893ebca092bcb17b3122b23489554e0a883e36afa67a8781f3b2befe033721293b2c1a2baa179b45f02d8899a5ae3d72682a7264716f1fee71476e9ec798f2050d3b89943bba2bdfbc12d73f4354bb60e904a8d18fec2ce76a1a256f5463bce6c4b44da1920bcfb99767f224b118ce9dce977e55653ee6b19b643fd01e21b02631fa8f7a0af0b79583384273af0f2e45e0e85d4fcc008c9747d23af9dd9f43f0f6a1df54c74846c970a91e91b80bb109c7edc220706419cebef18dd17ad2d4e93c6fbfe738dd8ec0d9434a4b6e961088b93196b1952bf06c3d6100bbfbf13d6f5712eebe0a2cb79e51b1ebf686d0d487286c268e733aafdbde5fc7b720317e6b2d3181de9e08d9f1b61123aba86611fd94cd8c73fda6aab602dfcd053011b34965fab29e8cbfd24afed69590b49fb6f8559f465034acfe24eea10a4c5b08db1e93e1a4a8dc44aa8194b4f3bbadcdf31d7c2fe747719afaba28c877ded2a6eb21c2b85addce234e47030649484fef2c66a9d67027a1662849838674f21d395ddc970d5565294d264cff5fa414f2f8e20efe0b8a578ea25b4f30d38b399f5a232b012fbf43082df916ea411d1fdd44c86052e5a73183f179f6b5008723c085814f5404fb3043ba140ab7593cd4d263d406fbbff3600fa0005c16486342a1faf0210e5281687ee41e5980eaa1272b5092fef5fc59ffe796269a66f8535c273ff94341c721839855aca9fd064374621a0caa250725b27a6db1b152755e7ef33edc1d3b8dd8fb288407de20b6efc4db62e104b98c4474057a81c1e4cbbc8869c1aeb951a920f9b981f63e5c5f9562877b393825dafbef6eb053380b7d40e18ccbf80d981b8b2177ca7d4a30cfdff34cee1af8f11f88936855ec0a5d08e8d29dfecfd7e98617c2b96583446a76b0ff051de6080627d612e8ffd7e37127d103957b4efd09b80baa5face93a8900ccf6fb47e91a7ac67975d1902688613bccc102bb334009707ba36331f4fbf87d4d68b29f424346006067e495e74d1ab334e333fe2ca16eabb544d50d396d72744b8a9d77bccf8adbe52cf52ad939bbfa0e5ef51248c158362adfc258c37c903264bb0ca99a5e7ab0b2580504710e6d79629e9f3e7c4ab8d4825bc836a77279f9de930ce774e9d34f1b117b4c5d87f21f8a9b9c163c5dd6dca6eb99cb0dea99b559348adac5573d6b1b86bff4c88615575425be33571b2e9e3794a6808502ee2f3c7c141da662f4fe9fad27df6603e058412add4b1ceaffc997dc032e4e7d976f67fdf2d5afceb143e5c92a3a8fba073aa177610d8c5cbba9424e6ad1455f280e169222f5a765cd02839013d2219ab851da8086c749ec539e01b5239b9597e8d5754a17f3c2398a1276ca4d7431024455a3b48238e9fc73fa2779b29ed4ac5bc6e9b0019ed4f9376083330193d6c1bea5953f98075221269fc4ef780c24fbcf0d543edafae1e77467d5f645dbe7c4641a8eed0c9c452ec852439480c75909a2a053084964f353419a40f94aafbd27bdd80774d553fa9f78072bcd45f0800f08cd36cd8327c1367aef830ecf1900b3653ba6a8d00e3dfaff832cab708444403363efbea369d005eaa31a79ccd67a0b4b89e4d7ebf2048b6db08cbde6571074f97c7c740395a52a9202d9befd6b51f1c0b0bcc9c3217557f4073cc72c8df2c6124f62faade0700341802cd0c7577797acdaa08c62d18b95cc0ff2bf17255ebd5ecaedaf46ddb642e6b1984843d2932f4579806a7dcaaac8e6c58d191e0f768571c4d9c3de361f749d7a947b6d85b070cccce8e72749f4f0964a85ea5189a745d06ff4fe0e33282a20b2e1f3cb41807182470a3a35ffd66138d844e0107bd1ee856a22afa77960df7ec057a667cd3d32af549fb567ec6aba52504c77ce6cf9660f9a68afe71a6d8e69cf022a9dd60b63c51b789e7bf32617c5c2ef1d264988527e0cde8d56fdd592c558514e9f1cc6c21c264ad461d58984303ccf0c7bcc8f5a8f957b1119e2c8a84e96374eacfa589a8a2213c2188cf83849622c945176a1faaca09785a4ae31854a83b9fd9a8763e883fb93f107499b7860d68fe9a17601c7ff5dde1f11e936ceb0fc61efb94eff15e2caf1fc06e7e3b785201c057c554ac3c7d4b62fcf4efa9302652a15db4437f6a2a74847a81ee18e8986edecf19df8d378f50ae6a8034ce2ea9d3aa80331545a7ed1c32bf55d0b18f7c73bccc62d67a551b46b65b380154a7163927a587865be7b580129ada0bfe5a48948041abd92e2796b9f46623876b756313cc8ffef2835cc4d037a8f0463b3281ff931001ed3e8389642123a440ec861bd949c54363eab6667c20db119e7c367a1599155ab1d2e0a662e45aef5bc08428aa9690e79e972232fb8648c4a33972b4369bd10c13fd5bb05be3644ed11d97c05f38ac790d2b51b8196be3f29643767af338cefa30e92e4df678d5addc9e67b43f3bbf36a6aa2eaa7a966a8f5774a3f1f1a680acf85d741d2533cba5ed059e4db1f5ae5a7a6e09c2349c8876b93a54c230b228049cb42e5a7bfbc5e6e6c5d7a76ac1c1a4c93da4e9337ffe5eb71e2b7b0b9f26ff09c2a8d0e55c54f2aaf6b0aa08a63feddd095e5cbb51e3fb3062be4f38a3a47359fb72bedff6156763a2312141fbff60e17f12a4defa231a8ee913a21d9d7a1ecd0cddc013ecf0c637c65e6224d260cd96de34c13b8ced2c7403de03cb2c89bc5d4846ee173f096de5188f7cb664df8e0349b3196f66d3d56b82e207ff70cce277ffdfbe4e4f3e7a12181efec04f1e88f9cd540f8104aebca5ae82c76ae9269dc5e73468222fd16b9dcefbe7032ec8fc217ef7e12c2a90028de647a8109d71f3f097a2249d842a026d5c7ce19abfcb7ee6860f07db4cfb41b9aa925e09b122040bda03aca536b941dd4a784c32d93f850938068bdf42c979567e68baff283bc1b284c18b943d2781e22c087904830002927e0c27f8aead5369961c4056a5f082e2ea3163f6ba3bf9eb4e2b98eaac354964f2896d7bb452403618b562c2aa63ac4c13ac9b1ba9f5465298e9301624ebb8dcb6cedb8f1d79eed88321393d8cce4b089b9b82fe205e7bc1992b4a9b6aed7a6ac307a33f7a67f864e969a0d11a1f1ddb2027d1be224492a230ee5322536679b438693c39bf45d5d3f62355a7f55f8d768605494754ff775eb3591208597c3e17c73df3dd12529775445a9eeb27795527ccd68a524ec1b1dfe8c0831f0cc7da83e71a886867f531b0d48fa772e8e921fe324bcc5361846b61ebcabec677df554e44e790773b54a739e45d0576f3ece74cabbd95cfcbedf8f09f44dbbf03dca4e680d26242c8d8e42dbef93a28680bea188d28a4e0db35025838079459f291a8ca9cd49fd34515137bf2b519080cbfc02853ec35ccb56523262995eedfef9ec792c4f73e506c85c715af9ce8b98e8196329089425470ab0c583ea7977b179c30b4929cbbbb10fe146814b488c35141a0b347227bca31ad74f8e281e6a0b03f52c80bc737f2c008581df873dffb3ba304171e48bbb909c4c6b5fcab865d7094a76049cfaaf82e1dbc1c322679c3e629d75b1bdf30e019d315748dbb27348a4cbd36553cbbd3166057cb0905d92719d61e81dc91166fd436fdcc6504271548ed024185e474173c30d614d45a3b9e2a97bac4206e67eb879fb6d7731974e3704e19a267d53ee53f9323b4d1c29ee55a221f41cfff5038775a49c57cd7e298866a499f14d303f6fedea657fd893bf10c9e9c4722b03706069dae9600aa5059c259731d71382992d7f80757ecfba0b390515dd742e72abc43649419c23f167f8a0595825c954c1456dc15a22b060dc212cec6a535d1a528ffb7ee59b351c307959a5c3ff3c557c6bc0d15a16dc024ca8c4f070589be2086cb1aa55cde77b70feee1b83d5dd4293b3e1ca6f3295351871db83f006b3fcd2847b6afc73ad83610d15deead6d2bf18fb4837fecf80da5ce4e84b275ab0bd0ba8814196d4483587a24d5abec6515bbeb1188930283cecc5f6a4716bbda0bf7b18fb670ec2aa54b7103ccc241114cd215071bfcdad191e4cdad447d7ea55cb00e57c12431882c6fa4a7f5bd7ab19c7c4781fcbb125565cea2f30331428c57421a2687cafe0e3498645a1cdcb7b4077df98829a4fdb4ea02f05db43273ac0d906c73fc9c1ad959225c65d2b7f263535b6cb3fcd9d1ead6d73c145c20d542ee5810dfbfad82b949a3de6d8221c26462f0b7d935c5cbf89a1268fe104bb1206dc2b2c1be6f199b602fe5bd2872ab0eecdcf690118614cd50dd61483e7fadfb2523b6eb08eac1221181c0fcdb0b1c19a83dae539ea94e435b821055c8b1fae0981fbe8983a55755e12095cd81783998309e66ccd2105ba324d0bf22a436ca5257cfed041310e93a4a2c980b14852f034e8e9e531ad48771da40376cbc62f04fcecc36cbc8d58068181f6b9813969892f45058c7b9383aaff481dedefba1cd40f0e4ed2d8de2279406218930af4328c12585c776eff6c05210c9c0f381420e206d26c301771a0dcc67ea07f9d67e22f83e1efb33cba0337b24c3fc76494fdd4f3b5637869c1ef85c219e971079aacc3dfbdef0b41e8fd7b151813ce806bfb34e3ffd364cf11b503a9c77783bc0ad9686bd935ef8d63ced32c90f1d166e0a02e8342920f24c53ee8b5c6f0fcede044e8e806e2025a08a60eecccd8c7430c7abeaaf7dee2ac7aa8d9ee0117a30e2db70bbb18412ea663d80873ddd79b268c6fa7ae01da69f82241b26c5c8e2265b4d98b48a7cdbc46fbed46af23242cee4816bf3c9d8d8ea172bb5357f7ebf786a497cd26dd6675e42589022a1885f74c264c9612aafe03442c238ac90870734fbc940d71dd8c3b5697d67bb060f49fa52abad153222f4507fc0e288bf38bf1702313b86cf9f62c8a0d42fa29f5200f8606f9d142f2baf0b37a9916b837a0e6d1a66976ba733c7b9fe083a3df626b0204bb5c219b80b19ced097947c96f5f6377f4f420cad3ac5f0a73cb5c514f2c0fb3dad55b8b450b2231b0b712da5a6a7e0601b1aca90a5e93a9262ce30d041b4ecb14a5f1129f76677286d7100db2b34a8d856f710b0cedfef77dcb792fb1ef8da2b4836e448e90f0bd463de74cb01db9fd719799f8049a325d862207784f129abdbc70ea054392eca6ee0dbb07fc62687762f24bc1f78d0d5f9696679c47c50ea14d1b6c2582b2bffeb548eaaa3c5f13f920fb5448a1f2f71fd051791e6a4e0ca90467e27954da90bf91556e6f3a678b52c4b7581b8076fe408d4c12c8c74c46089cd6476dfbc8d0a059aff71c65f7e629e4201ee7313bdf69d4218b8fc8cf15fdd0731c786bf084237902ac51ca5665d51a7e025106c8eb2b3ab5dbb58c9d4abb5ef63c1be61ba2e59da8bcd7a20fba1fc955492ff259d7d70619a6f63e0b5bb52c8b1bc34f31029698b4a83c3782822b6b745d817f1918c81e9c1a47f2c3c00a43e6625919faca49e65f37a9d48e2905c20c86c96073e919266a1701350f540e31005c9752d07fb50f0107d5e8fc7ead0e5068b68d644edbd54eac7eb0b506ade0f062b3173e4a35eb0463e31b5d9fee797245cdbffd37f2d8c3314527ae89b424dab0303c89937029b5409155dad5f0e578a91d91e1d83bb8b73beaeaeb67976e389117c4b29fec6a49a4e43e40407fbc74cea888d661f3b12990644ee95c1d63e2299e5808e59defa48cf5d3a2db035808bbb507945ffdce47ba3f50d640ce2165e92e189af44ed792e5ab2050b04852d0a8f7f33908e0174c0c9992cc16a48707d31ede587cc3a78a5b73f26610788eec3a9b008ba5ffa2293574546384fbae314014e215439512b933bf6d375e960f1921dc65c123e6925625a56b35ae14465dea7ecd94998927c2154c2bf2690300f8c9a49fd4fab2056970575bb0837f565e791338322e95a3f004da21323a9468d820c2bb5b1bd64ec3ea966d942821e669d765cc9c1f5391f1a21d333dd15047e83e267a6d0ed13db146d231dde102e05f1fbc1717d026005fb70b4ebba2bdfe699301892ec4bd1553914691d2e51cf459a0c74d89b837e645ef9aee0bd2109eefa9cd4bb51156dbacbbcbc565b5f07ea101690fd6ef06bfa80e60033992fa237f65395f6801b9a5629b5c1d0808c1c3e9f8a8c58cc9266b3667e93a4e2e55947610d3d53e37ec5bdfb3fd63ec3c97a07e8fd678c4312289849648d0533ad7e2438f2efec38c4f865a9ececf2b907e55f01897377ea84141b884e84a479f2b9de583febaf53fa1c7f470d31baace552aedd477bf2e2a74f7bcf7e38c055f50fac99c651423beb8215cc3ca357baf3e47a0cad23da1784ee7312a5c2e92c0a963e986258eea7c6f3b42c8df2371bf7597923ad2b67fd8e1a4f2597f3b027c03c97c9029c4af58da50436003ff16119078385747290d5db862df2cd169c801ab2f8638497bcfc6eef507985180bde5fe1d2ace14bd2aab6ae96c3e9ef330c2c6d17653871a37fb88f2571907fd5d2a8f3e4bfcfb16314dcde6ef88896c02053449069bb02b34d1973037d3d58520bebffc7187b33ed7b45337c53fbee64712a8aae58948d8505b4da1f1009b670db84b21f03b82d346951adac0f8e63d003d06b119874a8b57f8cee586094c720c26c7330f1e9ade14b4045ac7dcecf7e56acc3539dd0085e44427bf57d8c1e3c33988844191e3b46fd352fdbdaf830eec8b63148d744bff7480fc4ddf0f0075f208207a978ed03484e1803dfaa46a03b76b71196ef0a95ac9c891e8900a79991692340c570d5a7842627105efe2033a71e247077ab8f4a30fa825c272f2cda9240731d82668605dfc07d6225d4428aeb78b2681790b2938cc819a72beb0399aaa26a0a11dfa0176363bbbbdd10e0d7687fc11e8ceaf379f418c636f4fd4cfa0a218cca8445fabd1c9f9ff7f7c3910fa99137dcfe44bad056f1222a8bcca33e5cb786450c7581c23556b641f612126fe75dd169095bbd9430553a93a86829d6768456b6de16a1e937f3c726aad0a70521ce6683d33b92493acb47c5a955f9486dd674f1336626a9c478f074b23c16527e98529519f9ce13cd9e657ad0a10c44a53610731282361e4f6d092f23fa1f2211f28bfc89a3e9afdffc649eee4ae9e73e24b2c750d09d52a30ba972d6396c0a7f4a77f247cab1504e07e93461caada80bec04c54d6f7dcdf12688eb07e92de6fc4d6173cc83c51d7df76d739e5ef14df78e3f83f26c09d2fda11c7036a70883492e655fb05dbffb687e3a760195c9a1bec1382784181620080ba417d06e244973bfccd81faad547995562666dfdec69e7122d7a15e98b453b1971de0f57ee62fc25cdf2163402de144e6d41a7a923ec40bd136ef3beacc8262ec8d5c7789d21a6eca6dd89e9c458b24b148b64a33a3edf409373a2597494cdb5bb04d865a0740032beb6e5ca1fec4a7e64ef785615fa3adad5bf4be07ef8c64b24f2f8566a0e982833e6d41dfaeea38e4d3e9a738c993ee5ceb1fbc51fe5ac85a1735018559907c9ae2dd9c030eda7d45ff72b327b5eb05ff2f40cbe8fc6d9db1a94368e2085a4042d0e3d95bb745d80051e63387ef87d5f1088b22dd5823e628122f7e9e0198d0832cc427042aa23e52a030f933c395a9d1d074b0aa8c153d2d1a4d4b6a7573f878646324e75dc6fb46fb91a2b7a5ccac8948f4770b98d04403167b5d4554943e638efdea6e13b8ffacb73aceaf1ec49593fcf849e398af15a59cbf1486a9e0328601087c05993fbf02b2f2736502b8ad00a6ddc3c3fb60919ab4a0831ea8567ae904c0ab7c6318a4feb23fdec6785dbbf48d5e599db1ee49ddcb583f65b58b2b481711019974acbc46f00af97941748764ed31a03183277f00062ad05189d7cad6252d8360e348abf46cc707d08646c68ed459732ebb26dcc0764119c961a1969c45cb1e6bfd686914c1c849cb18d270cee158aea5108784d0f646db78ea2916f785ea6be3e7391e1642e2a673557a836ebbaa79c0750604a9d289d23d9da48bec772d3fb64804ab5e916f2af1f12b9ff501ddb7d0b5a482aa6b00002e9488059247e92ab02cec118bba9412268d0287caaeb446fad258d6aa29358a1d88f09a949ef51e44de977b872b0c7a99c6e2c9d5f089d120bff8f051d76e3cbf503ed684ba6641adff82374639722ef040607cc28ded3744618ea2f7239ac5d2f2d975f416a9485c56789d70cd1b08f51083979bbbc6c3f3ab65630f6c04c518cf9255e516a6987e0383cd16e534fe95ded47bc5776bb35fc388416db90fea145662722555a12b49a7502bd8d77087f0b08ef85452d5afd33add719b5823d4ac234f0c1e1219307e89a9e7e2eaf473e5ae5ca2a40c0ab6df6d955037071452b23fb062726ba31a6d73af46ee6c461c83ccb39729622b6b06f344d8a03aa1c789f2c1b6b6ba9170b4333aae29cbdc3e7dbcd77fedd3f9e767df9afc0781e42afe3c8842730e1aa03ef46ce3fd680ab8b2b69f9f4d0a313a67d408fc56bf9f9f2a296923930493e49954f6e40d38d4bf015455e3e6912bf84e896cf0c31e046506323af4bd4aba904a7280cbde10678ae971238c4443e69edf61826321c027e6f7c826b43b271a4ff574ce953f2c2b9f979b745d9f58fb1b8cbfb3cc607ed6fc495d15a83ded41fe2c1bab373820e0f533de2855c12a9155cdfae3fa1949a9521408999dbebb170e0cb54610235a389eea4c199b6223033de6658a88307fa8048f52c9c71d0f5c81c4ece182ae5242e08d69c34fccf885e9a8618482ab96beb6409e864ffa07e9e312c0b1a78dada4dc041f63484e8259a687c7af4d7ae4d06518d48b99589521f5ca9b8d71c69e728cff2d22749e3137e96e78f5f1857a986eade176e8b8b9fcd461be46ff849afec95f044b8c3359eae02ff3c3b404ba439021c405a0766a8912dca77c8d8ce9bfb1f8a27f45a5d077113a7d40eb04fe504e46cb8a8b8febbced8688cccd851ae2c3fe50f7081188c5468b924b1019062ca3286acc46b8bf284f2770d92b4605444dce8c460b392eb9010ca5a9b7db03ae8a634726cb03babf4a6c9b956e445b176604357d8e177f4195db2ca101cbe5f1804e362d8edf6ec7f6c0399b53d500a62c0e0d2d94fe805b204ed7ac3ddac3c108f4b06e1902fedcff69aba24de29080f292abe0a07cc387aedb262812b7c3276e97248347e94fbae4c642527798de182a448def8cc7651fb8c3951482665d707995db8f11e381d44a9b63ce55767335ce7f0c387ccfdecc2db1b02fbe2f1781072733d883c2fbe6f9077876363bc73a3fe5381bd42af977c35fed7e8891f342a6ebf5ece1d13b8268285101666b87d4ff6f7bc916b76edb4ba28599ad802762e24038173911a15e8ba422d04fb8e12d4c47a4a9e2a0ce3ae093fc6555936bd47ac0dd17c1ed60f8a0f0914512fef0e811494a2aa8167573611f9448448100c9668e31524704414e7456b5aa1f0bfcfae6586cc2e40efcef7504c8b9ee25d73c91379bd7b968decac4b0f1ddef539285f5647218bf473a16db2e94a36e5c1c216e9065df1af9fb58bc9114d396512b82831540398e200d6c9c20dbbbe91f1d7af14e219f14456eed8ebd83be907696db0ef0b097c68336fa29ab7228f1d01be0ebbebd5a8d40821998d33496dbbef25d17d1f7cd92ff716fc37421f979ede16c28755655df2eeadcaa435b05dac678ca5e413114c8440cbec48eb1f5a07eab49ea556bad906cdb9184b08c1e4dab5c496be567d1dfc8e73d7c2826acb82a1933e85754a6ecf19d3a914c30bb3af48b8ded87efcbcd986a1253fba7c1a596670960d9c6c6016daa001fe4e60c500410d0cbc71887209b7c1aeac690b64368efa675888a2772d316859460e10a669baf94636acdd9fd8cdc1b8f4b279862b1ad1fc32afb21b1f24b70a4fabcb2c394cc5f38e23a8f6fa24639c1132295349801a018a998882c837295b15ac364ee8c86bfbc97cedcc5456030227eccca88108fde2fbb98ff3458efb0b109c3c857ef0dd964739c5dbb3443ebdb282ae6f0493d179e7262fc9296245466b8c439e9d2e98e875f3a4fe70d19c58d62d2bdf2b7f0cf7e05f74ade77610e9f51dc96b063eb250aca2db88c87aaeb283dd97202767d8627fe5ab0eb922ac49dbd128d7e6abc746f7d9317f768412a7434095fc2eb4d589b18e3a3ad2ea93bfb2e98415e7eb637c55ffb740ce0759c9c8e66771d140a3f60e742d6e37b10e2e4b1df1554a0cd966951b539f547d63a14cb04c54de5f1c1341d8abe7e2cf07d2a36e755a8313961c72fd018b9e1a91376ad22594ade7cb5ddcd999809da4a2275244d426a349ea945c58ea332872bfd5fbdcd2533ba42193a36c56c1fdcf7702750c1a4daeebd5ff3763731d6cced5300bd6ca97cba289985987279e4c3713c79cec9ddb9fe0387821542f539b8d8350bb49c34758ae06931e3a9306094c736e1c7dcd60dff646bcfac1f9ffd72f13c3700a40e49dd2ba9c11db486ff7965f917a6f3c6a58085e29d4ba16a1dd31532505f5e23bc95a76a21f7f91bb08dc5c8b591a48f86b9dfb2b93283b65f3fce12322dd0384f8ec1337ad678fc2b209640731904adee9d50e76e12093de0050e66d0ec9e0e164d5430a7558f6b9c18e4c3f7324e1a15545ed62c31ef19f8f0717940ed72609a605d15c7ad7a91053fad839e28b9bfb3c1d1bdc7b65a853fd60ed1d04e254c207f8de99b4abcd878f03b459f367e9700acba621b299b2bb9d0d46a992b2d9e714eed31b6c20497fa84c4bd2c7a55a3ebe4a4ddbd63f46de90d3446e7cb492bbc6fd29c5acac4eea0d0acf86f3f45c1e6dd5deb7376503a946c912c5e4a75c61a6cbf9782c4b9249f225db79cf94c932ee2c896b255108c280685ca29caf6e248af2377d7313ba70481280388a4b8db401a4fafb4a14060295a1890c634ed8ba255bd7c596abaad2c54b54e9725e1a7f09a464041bdd763e587a0b521e1ac4b494c7c36837f194b8e0e6edf80fae2c5e37a35a0efccfac5e8f169bc98ab5df24c0939e32a61379db167cc0e7fbdd3f8ed3af36cbc225855940377c6b429668741140fa300caa97fdf019679590934353c5eb7f29f8a6799f9073620f8f6634fbd3832b13b364484458d11360f4b1d125febb5898613cf57832f1ffbdbf86734e30d475","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
