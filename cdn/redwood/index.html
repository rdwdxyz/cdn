<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96263c014c6123976fbec0db6c665c39bdfe8cc6d4905c7de7a7dab7b34bacf94106e1ffaf73e076aa37898c0058273171892f55f9e954a7668eae476d48b80eb3f5404ad98a448b3c66d05b7d5b9e26c2ad823c0a7c017200fc75dc4b38c87ace2a5453e3acedc00a1f9f3c7694b72159905ef61cd9e20f83463d2303903e3b493887a3c244f99b109b0046ba5f1e1de32c47aef0b0edb702297f413bfc0652cab50d3735af8cb21408b90abdc380310a7dfce7e85f012afd454a7a35f1240c5befe3fab8078f38f00ca9bcb4a18879ad44c46a974eb49f5f43923c93ddf61e083ce00d6ff8b9009a1479bb1db2e978e150d9fb94559f117ad4c32cd8dc45659a4edd5ca4512173928b93bbfca136ca2873286c5057245c43fc92beef6c15761dcb6b666bc8b16519d0e6f5ef343e05d2dbb45dcaaa355f9f1056f968723333b454a6996d87a541e05898866f2e6669d83a6598dc0d1b08e51c82f9280130ea198908e1d96272b480912bf5444d8bd867ba00efa282f17998d152c57180aba643c4a44297ac1df02b0d5f821e513e0547a8934068dda2ede55daa496376ba591b7479d7e8fbe38908a61c295305847cd91273d6ff3a18a450249764947d7e0e063841cf1228bbbdd9103abdfec4a76b6d70db42d06414243f969c10cb8b6f1108e115da54057ba8343ab428c017f6c4d435d6d780f5ecd1d812396a6014d394ae2e09c3d0837e5d54f2b3d4462b94d5bf1021036f54e3a6be12e22257aec66bf06418a40e608dbe1a20e601170d8fabc9db3b489893c0879b936b22f3c12324fc8905b4b031ca205326e572cf291ea5eaed9ad915555833256e8ceede059ea44c5f16057444ce87c4a2dd06b07e457539a94b8a37dd4d646bb1e14aed2ae9319a12906d28f21de8eebce2581d8bd62769847fdc026eb73c0750888550e0a309a92c14c1bf6ea7c74def1274b775121395ff534e2929a13c982ed3761fbb42f806328a21827d056742846eaa76ee818f6bbb309aa09bd7041e247ba92252f08145342d6e5a3916b641044d93febcebb82db385c59c18f181acf3c3d749853a06c7725c08574b90f7868b7c647bba9ae09096e068f900526a845be9ccface8c517e989409de61ea9ac90dcdc7f5398ef090bf25a47bee87b81e98b77ceed9e4c2391d9f5893dd81a06a2b8ef114e1861764d78b7212991d6648aeabb4ca320883275949c01ceeebcb244e6924c48a55b35abe9fcfe8374b4518619c0388efe9e7e14d94d6e0edd3e6087366bbe13efbdcb778c27d0b7b35b5549ca1319522425d5322f57c816517b3825fd2125b9627806f25fa4a71d5c6a5aeb80e3feaf3c07290c08755af3d0bb8529dc94210391fd94c6f91a808e3b8c1eca37f6359bcc8126e6b9b0ddd28db14c86aece2dd487ac937c442175c5c8daca1811cc19a63e10b1e6cb727cd38c97eff821a8bbee45f3f0a43017836f348b91d17e5e2956b7823abf2606143539fbe5a15fc22e639725e43b218f8e9254d03356a2a6c72ddb9a5032021fd2e48dfc4cb10bd7452a078b3da571a456a51a42b65ba9ee7072fa44ce9057dd6270fb2b8eba115c4afd7c11d1e164faf345023b0bb69952f54c9345dd96b6165e46753dc958119be6ebd233861ecad9ff0e76d045b6bb0db55a13c982207d2cf4c695f40826a0955d2bbc2e7991e6269d259ebfd179e5e73306a4eccaafe76f2c2fad5955676c5e3e1f79d4050c9ba7583999dc3bf21a75bb5e47dbb86aea01ca4e0b49015c0d869936bf262aa9fca75e80e039f2c703173739dc40a013e41805012cbec1a85d9bb824b2c402662b71791f71e5ec6d4707de763dab84dc63c2e4a21e84f2e8931af10cde265ede61b9adb84c842e9f9c77b016087f4f429fde242631ece769249fcb0f6a9601b9973335a26535197441626b82d286d2dd66f0ec56332bb50a541fbbac99ecaddcff680de2f7985a72dde33e713504c5604ff85f012193c1041c99bb93c760f9278861e8ca9f6dcc7a6eb91510e716d0114e2ba41ba919260fe45cc9cbca080c433a40ef7e137c0cbb8386d18ab5da26579c8cd19c6a28856db7672608239e4be950593f26a6758da3faebb578d1a437933be2d3a8ae14cd0f6f3d15fea2ed8efa5b7bd95b41ce6251066f99abec7059cbc1bfbb2db8190fed65cef56d9b99c74c5a0ec7962bb26f1903cab31e71d6d6230909cbbc3b1fffdc2c3bd46c31ddd733639e373276b0be9d1dc08626f7b7bf1bbf5e731362261d5f455cae30cac54684c7a45f8d243ada08071dc6242c53a4f112443231fd9642e1224284c7a8a20caa730bd8bf51f9f8333cb96fa9d8d04f78f53e32ce297a9866c7c4204f164527b11301b1e69c97560ab3236bbefdf59b8ee57ff3ad2066c5c8aea5790ba0986e7f211dacb8fa7d5c4a50bb4d67d5a5480613a8c42d34746091742bb4fdd268b3c861227bdaaaa7f1bda7161cdd6e9457cbc98eebb267b9cd225aa4809e3fb303ba69aa1a1ce53e61f7bc73ceb265fda3c5b95d6a0d6568e86da25de69c5ede3d78daaaf2205e7f5d167ad84a5c5e4c49f9bbd7c261c8a2e3769d8fd1e948d1c268605e6e79c053da0c634ec1fcf60e4782d36b12f6f75e93f97959276866e6ce46691273045a0adf9f7aa65e8d72c5c576de709c79d537384c4841180379e91cd8cc11b3f5b062d840932ede1f222d1b47a2892cf45df34085d2859e41499dc0e170aac81b642ed5bd68787e9410e58cedfbf68d3efa1eb8c7953b7a01b183a36a14549e3039fb67788a435d44a947cc144691686c11b9fab9efaf3a3a925de6cac10124fd71c274fbd22a03d06c315730932fda085f25116e5fe4ec82e971b9d16cbb4dde86757eab475a43c8e8560232a39a11cbbf8da20f4c00a4f9ef72eb31272226ad9cf4a505a0543068bb7b0a601e9d0b7f57730a744d30c5dc4cb3bbf3ab6e5cc098ee8ff6a1991c2df48e13ea75331ddd8a53a184d6e2203df5e9d89cf3bc2d3a3793722f8e0d6c7343054a52221830cca3266e292d63155767567eb505c3137e4409b116a187a15f22a87aa21e7e0d0b8105f74f1267c715ff4c1fa93d9d2698c90dbd2d8903e09d80534d49345f11b317e933293ca70c12737d45faeaffd6994639a68c8dd7c09cf1c7972477c2e88b4f5610bfac650b3b4e83482cbfc984df627c2210bfade7dc288f66018f048b6096179f893c2a7fc5d95dd12448cf52b6f73faca9508c5401d844ba43528627a85532c8a23611029ac4af17d5dbf39ae01289f0e0a04920b6f3e48c05196a93d369f221819b17fc12aa230cba672c04a764023059cd6ff0290973313e1268c9ad5cf2eda3c22ffd2e6ba70aa488f12e4985dca1e7704d6df3ce615b9848d839e852d3a7e91bbe7ca6010b357bdf0f9721d2ff0888499f6b38d1ce8c7065a61a89944b719c3f1c713a0c426bcb37de0fca08e729349e97ddef5841d2f28e6a71ce067e258cdedc3f5a1216fa1680c95c4ad6e41611584ee49f28d8bf39bceb85ffe3639982fa27db0b1ce3d8840d2ed5cd794dc2747796fc5c1e693f38a0169658d5135be373a3f5e43d6a59c68094affddb689a5420748659e7786f022992b2b55630dcdeefb20c899baea7aab562522e09e679584add6bbdfc390fe31aee979927d0dae34f15471a1db6969fcfbb4813c5aabf1ea45daf8aead146c82e0e2f20131421009c5f34d2ea99eecd9d6112d13ab946584445131ac0403804af6c9389287cc310b0f3f308fb73e5d1812b2a3138854022e09451125674e9d5401ee0ae546eaa96ed73bbb2691877f33ca0c9aff1ebbff11ffc1f15610c9ea1bcc9a47a3b205d95934f949522c97434a48b3c6e148e46803ac64fcbdcba038ef08c993c24386382fb4c2a1abbb6741bced468acf896a0fb96f0479187df9ea8bc7fb2785914ae49e0093d50b862e9f6f081f3bed2e4361bcdb1c2f88b5d6c2ba213987d9fb2ed252f22e32eafbec549dab3f3b88cbda478c5109f7f08ca63cf3d2abbd35f705ee70e52e0d83f7023bb6efa540aefd56331bca4ad1833df0827070415c2c8059b663f36a173803606734da204fe929568ea2961d510c750e3ba00709c001dc6dc0b13f6f218d0d084b52ff1154555876647d8f55cbc13648db00f2c1129fc16884b4eb5ce90ea464d3fb9ffdea63d2b1238ddda035e1b995450552f9e09308982e3dcdde1bac4d6d2340219c90aede65c26dca4faa3e10117a87af6e3b8f0957c7e1b91a28772125d17a60066d56efe8294c879b472d9f4c6f3f27a417366c00ddb64536d00cb11e986c3411998c5fdc2e9c2c5e9bc60f3129a0ff1b66e93a9466ad30f87b88a5331044ceae3ee2b0d7044887b79cbff10b808620e967472efef729acb4390263e54c1a35de474ab186a4cf2841f56e649f46fc2871e3596a23c1ba811400432658a45bf93ccbe56063fe57ee2b66a9eef6681d8ba4a4ad828b78e79f90c4155d2575625cdf6b12dde7f43d84614bf5c86be7509892177b04684387922a70d1cd8b09d78a4cf442dc071b17edb5ecf268e5300210123e3df98a744a4cedf0ba998240696f49fdbcb4f0ed9311b345320c5ae880c3ffa08eb94f10068a3f9bf78c2ca4a399ffed61409b7d30cc0751b20da0c3fe21444924674b34066f17c199e5e07dff5ec0233fd0a41489d557f2f7ac45d2f9372c5f281c3c892bc9d5db0e6dda9dc736ce27407584e4974f2b87593daed393f7614cac85f41e92d585bb7fdf2e4081e5177a117926c02d6fe7c34d25325bde19e531578256c11d51ad58db61cfd09d078318c69302a3b36e8fc48c29431afb657afc0d3e7e41697496452c18ab01fb6b2f4afb645855b9c7d6bc515d0054f7ac4b69a66617b58b0959940aa9e35672ebce3c8efa1a51cdefb49c28ed1835d255eac827338984b547e7237eb9aa9694be8b657e6fba4ae14ff79f55c744b3fccff849824457b70d7fdcce79535519eaca486fe96dc0ae1b30bedefe8fc49d51ce65da90d1724b2e9a87073209c782cce147e43d2f7fb140d8ab9fdc6d997a6172dca13b87f9cb51b72cbaaf913a935005168076af2577b509a84d1baeea4117ab7f70fdba18f2ce02df8f054c64e9a72c63f9cc6f328c6821579910cfdff43e2a81b88ac4a85eca99cb9138d57bf1e2ff20172c0e5e3fd8bc5988739370986418ab93d0ac3f35a9151ca0be356bacc922a80d0da9f20316d523d155194b4787910571fc0b193e6554b33b3f5539d40ebaef35b83884a7e365b2a56792c437490dc47323fc0aa1bdf8fd6732895ca66de47af7b3d68bddbd321b3262ab3252a390c43eadb7a0f6bdee9d764ffc0658299656a09d80acae2b5ab8ccf9cda522637277fccaa222600da065d6e54106e34c17d7f68cc4bfe7f736619e6ec65616e8a114f8c1c5ad3247cf0a8c03fe8d38e77dc7047c0ffa8fef6ba0c683860868a22f0723582167f50486848fd360d61ffaa1f8c155cf014e4697089a32b839046229e9f4a68e85e70007cfff8de82da79bd3137d1d118b25b8ed8df3cb412d8baae00ac8788a6d629ba4d44cd5d1db8361d3e8806678c0e24638a879a45801d7ff4438599e1983e3e6bc97b82f1161d6a9cee4263918a4b65d6d7f3c8a1347983fa122b1d4cd32bfa13c7b8ec2fb5de6a66f16fdab83df726786e14c890f7563b041f6e543b1557c24791b77f75bcf737b021b356e773a5161640f231db284afbd2b4e019f42730aa190ca6fc2b291e4402c16349c0037eda9353f9217ed614d3167a1f2e46430df0971b11da826a3f86f54ef0a496db0f698e9dcaa16ced4e0ec06948b8815a6cabf618fed9687651097ce5d9a8d8ee9f7a43b41eb8161e0b9dd252e338670d1ff4593e2da27c5f93c28fd8c9a93cabfa46240e1f2de866e25b971a940591a95e61d517d5e56272957cc929d52bd7fbf6ac528c04f73f9671d690ae64d87fd1e260085915bed8845eca1135989e8602407a513acabc2bdd11fb72551e5b06b7597a923e11f0d548b7fd748c4ab45e44b45901ef8f8ef214b6f8c865489aa3d37ea1cae1d3b2d8a9d0d34276e16a5ecff3eb0c43b78facfdc84a29ea7667abfe05be36719dce3eaa450890382e7445b169dc8ff24783688a76a86007e474e4d69bbaede9d2ddd0c2d0adf247eeaf7fa2315d2beaf1eb2dfa15bf4f7aa5c2d1e8ed0ff5ebb25edb2ad40f467033088109d0a5a2f7e991040ff4b5f6a7a644431461cb3c25675fb079e50694da6dc9903a3182a7f2a482f44f5e4df9c89f7a90e42fc82d7a10b2768877bac8cc7073e7d450b4492aa3ffbab47e4d2286f5e65b0fb90c37913ab850218c20ab2ce65e9f73234be85a8708ec12f35c39cce212e8bc155d094a102444cf163358faaae7c0a4314621c3fa289bec6427805757388da23f74176dc27736409987639aca7e7c4f3298b95ef48c12da1a4e153c30030c6de83528a8272187618e2d62427a4dc7a02c04248d48356bc6aa2e5b44274072d1f4ab02b0d07e58c4ebeaa0c9c8d69c9b46f14102efce8330837ff2325d4363539eba9bb6b6d5934b2516db58371af417a793b45be2599c7ea6f7ef4d9dba4516b553187b8f76f3fd8cc6eebd0d474af9508c7e3eb79425a66218daf8c0d1a12a3ebfe4307c23de209e2229957b3f2f3dac8469fe42e21d56e2fd573e6e7020ef8a8d4bfaec18daa09fc3d633e960c415e5e57f571ac8c2151c326476e0354bac93503edd8f748b01c90d2f0e0caaf5e6b3f93c3152f7929789f8796df907a4bc245288872f47614bed13f84785b75fd9caf4db07888acf90ec98e2970c688ae132ce99002e3a79448b4a912da62d2ac2a0f2e27f73c6888d18294a217b1ad74ec20341e0ff9697b59625122265a3b93dba9e384c803b6ba4817df24cfd510d3acc612137a79765424369d63a6715f5d4e08ba2292c09fc7c0896e6eaf87db570cbd095a2a1ecfef162184cd3a478b5ec3896f4b45a717152869d9776c92431b66f84127b2551a0f0ba08ad7ae6bbe8074d8d35c006bcc12cc9ee8a05ade851a76c571b43454db47a387e60edceab7a2d17b733932e9fd66e419433af111f29f5a3d541e9931d222773de95ec41f715d4a1e4967f89d557909591b18f066b015fa75b038de2550f0063226464a0ab7f7eaf710f8aaf6f61528a52ee2d112855e6eb7819e191a7d468917a53a75a0a9cb5ea53894581688320daa5d2a2943d8acbae6d137617e6e35f6c3c3af1af9d670e48b82da24f6f36e3aa1efdaba1179cbca101249081484c5518ebcf8ac38a7304bf34668e744fe5c2c3dcd256c849a13a6773611cc8402cf37554271e2f516f711fe7f44dad556346090ca63473b057cdcde73d9e6e3d2829a1274eaf06afa840dfbcf4d2a66bb33f7767a1fe3062ead1366259c654d756fc2dd2b27975fb5b016e20cf26c64cb871375ca759b8407d3b8ca29cd6a44cd2960a6362bacb949fb508654461912315cc90a421765a40a31e6af9f5d905ade945e49f61406ee5d9c1f44ebde0cf0e202e02e4cc6e33a1d379a1347f7daf7deeea85db0ddb230b16d48cdcee1411e39f2b01f572a5430ee46f70e9dc656450616f63c6e6bad0bd5dd2ed53deaccef3ad05e243e244299ea673b5e023cc13dc4c5de32d555897240a476d0fc12fb4514cc14b79f78ecc1bc4c431edd9bd352573db75b5d837c6528b6ed4a20b694290f31510f202d538d30bcd96936bd221ea14a1f4f992126ef5b3c26c6aed9ab247d8ea29e946a9801ea9db9a7930600b8a4d13802dfc7792b5d5613c09a561eb7c754efeda9f903c1de5e8a2f3f93b59de547b647871c8a11e6ed32654fd6edd1bb3f84f64f431bbfc07ec1cb5fee92c5329505ab25821475b5ff3fffd34861c2722b7de9c1bc87e519b710260ae1c7139ce07eeb1846498e05c20115cdbd621bacfdcaef2969e7e3dbc398585828adf3d5a5b018f7fbde13ac80a430ce9add4ecead14466ba34b2c2a5bedd1a7df6053e2a1c446f04d016527473e4943b885a2ddc5fb230618288933299bdf449eecd6c1dd08ae1d21128f2f1f0784857f7ad2e7885bcfe5dea345fd522690db835c973e07586b11baadf64455808ad36abf374bb0b477dae308852d5eb4afc9da417b2bdc1fae45d92dda339a7c9af8a20b06fc74bef110d432321cd9eea53f7bd7f95161f81d67329029003a7f3266f9040a8e4b9151a14b822e9180361c6a5e961dd8d027e56ae55c55dd5c8669975d8d89ea485ef3e754a8021d82d5d53ca5d14280e9519805fe6cfa9a7a0ba4be32a44f969e3c0a63df12db90f7c96dc6f5bef798e9d6dbf8439a4a67b053880c0b919e2fb7ebbffd7cc2783d099ed5a1c8bf385a1415461a35c76aaa91da3bb145887391d9b339f81e338c3053a2a3109b91db3e54c7a6e54f82cf1f14fe00c20f9191a57b0d1d6f5281d88b03ac665c71ddd55d63e3152b65b508c1b3a78c08623f651cdcb7ee017b9476c17eaec1088feeb3282acecd19c57add1aa434027b1749e02ac807c3ca2d3514fce0f3cbd1a105e009dfb90c587dc08ee1b311bc5fea4c5ec668518e199132409b7b503060fa5a1c15e7c1c79d88386f12aa977531d2a0fbd3c732200317d968c9007a1de482a330780a4b7624c5fb6aec3fe98889cb8dbba87e885e848a762f427bbcf0e3b1b57732c3df6946f3b25d98f103e4e062a785dd8a721cb73a59501aa97567abb7f93157f7562c90a4fe4a11e650c7fffaa2198d7ba89096db7754210876c38f2e1098d080878250d4d56dfc490b69caab21e1c5aa01d7ac0c13149c4a79a97363fa8059db710951a2894ace86432efd2af4fd54a22e6114fa2026d9e91f650f852e75709c8551b81a7a13bc6bc76900f8415d477ffe68cb9a113079c792d18937d9b95880af4d2aabc6e39f9df137460892be2ddd44a1071352bca5b06dbd87d24706a8d2e48cb2eed4b04a14ed8031c115ed955e5fca2ae96b00752fef8ce2a667bdda8e95ec9b06d08bbc25a30d4748769f66fc7264d33c741c445272c9612dde10f3040709852a8aa960eb664f492aabcf495d6f443608b3a6d8e6e4af2846461a03680678a8d7a8f561d5f64fada609b3e547a312ed81ab75c5c56daf168370072003d04eb6df1e68920a90c06f2652a4cef12bd71098bda4a986d81e7cc703973575c315ef8269c160d0653d3117aa3ad3192b476f32cf29e090762f927e19ebc668a055708cfec3e0558616c83d3aae63f042fe0913cef0aaffbc7ab54c073e39b4171f777c11168504ed6c2caddf599e1402fb80f381b9a51f45a54625cc0a75c3f904157f3ea33c8a4ca053330fdee945059d2e7c5b1d963f0084c01f36f7ad9d8e3207412e062158a8d94f700214e6c1b00fb346dffadbbd02598450d5720711069fa734310c4b3b5c7b67c0646e1cca7d002d8df5960396927275df395e8e5059de9c97a36761137e80411d06cdc6889a581a37d9c1dd18d2443094217f0b677e6c42322bc9cfd4f8fdf9960f1afce4ce96763700c17c5b240a23bdb3e3f7931ec80495d3613eae047b1efd310b13a65960ae34acbfb8f28c5b05a7c817bc3d9ee8a97c2168f5d155988a2072e4ec38bd463408b6cb8d44c0b8e10632f829a98a3a48d30ff01e3de530db524008ea82317c6915b775e3fa48e13b92358454b73608ecab728c785aa04fb15c5e2820e7d4010eabdda8c1fe32765389f1840ee8cf69b6f78a79ef4b7a70328ec76cd5d6b6ea519a09226ef7e579852ff1d1419c1ceaacc7381aafbd895957312c618371d387605c50c7e0af4a6890f6da8be7d15a51f8994e183c9c914be605f0b4eb7bfe13368ac903015fb8629af0e2e34cd0be4c3999af53f3fcd38bdcc91b6bda1dc6ed39745260e14a2bf6f821d059ff4cd2fa5c55fb1d11a18a89b9e888bc03d9e8d8a75cd0d8c483f3df5762dc8e2f63563f6336e161294fc9833133f8da41263d279d336a7b4de24c1acc73df4f1283858512ef5f80599f3cc9716af390f3487e2e6911f0c1156f278b8fb1c97e1cf025de11b8880702072ccb51d3694e338efbd64f5462b3a0ef0fad47510e70dd5565592ea642790ffd638f638ebb776f3b4ad53cb67bc156bdce99ef325a1fc1f1e3608337070a07847780713fb0f04513eb577d33e55ad340cfd34769dc025d06045283e572f40a4e7c39139e824d817da63880a9ef324a6af89d00bc9d536c399ed3a4322df25892f67b0adb626cdb7216f9e84620e5b6c9a78ab2ebf3e794c47fe1a0021d0e2721c6da2825ae68bf588194cf644521e2b8eaf4baf3f750f69cddf1364354491453f8ce0e5ccca79aa8bb3ad8f759ac7cfba315d883f2bc31c4f9260f166f835a9c719628988d55df0711eb35b19d2df9d36f74359401da9bad3e562902375271f1bc5b944a60a6d264fc74ee3772c39c9fba3afd4f14368cf8f13cf9cb22b3e67ca98382e40da84799432c9d889b47c35814fa01cee01fb6d51537f530c9e5555e57d8bd60645cc1ec9dfb4e29052a7086dbc3af02327921041801ed4674f06133cda9bfd7329213474816ee62969d10c2b3acea226924e4e00bf4025a5bcfbfd7482cf58a23b90fcd2e11bbb65107b84e34e2950fa220a16d22a40392f8fcf00d44c4a6238a68674e7c4e4712c1575d120e90e5c058dfd7a8ce0fab52057c346876e0430247408ff51d366079e78a36112c4c182d10465ea3e260c75977e7563608867f97235c88289a148e66d4eccfb757c3fb73104bb6387a895e882c7817e548e34fb2f81be0e81aabdbc3e7ad3a5f45cefea9649c765f486488749ec97f23e5d472f18a55e9258477ff9c94f8c66d3ffa7bc9e32b510b8257617348b42306327f2d3304a9c74b9dd2c16ba6323e2cef3478d4d6ffc3b06606399d64d4f714aea25ef98cf3632af48c83a186fb02a36a4506739aea29d2301bba124a30c68316b97d8882d74a49098571cca010e051f96e1f4da2f704495fe7d2958ef35e40cff6c0b3b11fd3e019afb9860013b8f74c823f6cc80d3e6c0b436ca80e7d80f0f40a36431b2658711b5dd1438b8e17a833daef264c86ff96e1b1eec74d5f6b91a28a6d86748208a9874161b31ab60c1d56bbd159d16d3e1bc33d90607a974346c6eeb6d9ebc618ce076c0b163bce3f018eca45a9d4a7dfbb7c4777a19044b762d52912dc06a7cec7891aef82e06c2d225d4c3b358a1a27f777a3fe882e665825a3fb9780c1e522d379a934be4e95a9c5253de07c075f150512f434ce754489a38ae9468085c5131fe476a23d29e67c422204f9e6f93276260f0d86f1411e6f94a0a37d77c3821076f1899f772e88c43700a481478433fecd163fdb46fd718b93d24eb6eae58ad348f620193ef0a7b8e7fa2e856805174673102575b2b2c5d22a95e84d7047632a0dbf6363a77dfa5e888cac05c799783259924d8bd30b7cdd13e6bded266edad353af154a15f393f7d740fc726e3c3b33d1ab08dac6a74547a180ebc2728a5a8811c5e4ecdd4d85c67de3dcd3de788001c790feccbba326d56b0099f58690f7c3e56eaf0477fc6c49d0b158c3b36654d08e224c06ba77e6dcafa88629063d31b9dd96bc2b78ee582d2644945edc1a30b0370612266a9eb88c7b4c3aa537496e6231f93799c20c9649e2682da747ba0f70b396716082633dfce4b6884271546e9464584214862d54d3bcf1ee80fea457e57b35406cb8b904099f5842be1be838ebbc365a67828dea624b8ec78c51d68e10d58b57d2c84e8ca30cc34eb7cf78658f6fa46f930bee4774819e11dfbc43425b6561e890abea2a66899e869bc9ce0716febff822b7f2048f03a931390a6e982010c9002310658aa88d3af3ae94777fa0f1de81afbaf2c5cc1bf004b8f8a9d3b071928bfa1ef6eaff07941cfd7b13f3d283c66d7aa570bb84dafd904e1bb24fa8c06e41b8188829105e4254834e2170293ae5e30eeb3b514a9d49688512139d58ab37ca5f2a7301065c91f735be41e641bcbd7e27b991ba16a0c9d9d61c8a908845dd606efe4dde598d539bfd426b9d369ef95153f1907f2fb8177d9782cd4a30025ecfcc38dcf3b282701a4283a5e47caecc4408803fc3b30f130517c7e1a7e6e03b5ac9902d6535a27f20821986af46632d0bb8e7464b7de98acf9791393de0874d49ac63f43284d53a04eaf2ab09ffffc8591eb3f78935eb80a2403a4a338fd2807d3b7ccb0fb65944a5441af57d6360c32031e103fa0c7a8669420e33a452222b7d2aaa4991cd4ecd7b4479ac2cdcc9c58bc8a86e9b9cab278056f8eb241d20d33cec59585015d8d4043546b41d35801b5c72e55c5296ea6c649a3733f4c5c4a8fb84c11dbd0cad890a9aa919b6f0b205a29cb2b7eae8e89fa842798ccc181fdba51bfba7545f9510f310eafc495ad1b16508534e8a0ed7560f2840fd91e79c7fab31c8a81f417c9af7cb82a6356bd8fdd1123937c64b4f3a625cc18bafa9630dfbcdc78082d9f05f0e6da21c806d46558839957a3f3a429e18d519bf270b419666ddec72bbf3b6b7275239c55faf57d29e4971e2c86a76abcd8acb9d577e39381d5fc5a93ec6e38753bf781618a8fb8bd60c924dc1e175ab5539617ee20cb02b4f72949d3e80a421dfb790d562d0ec437abe4618a808ce9c9614f0310db33817d770a36505870cbaa1add597db7d4c0482e0b48a557d213028904e2823de7837847a4a817948e913fe09f8a8a5ec8234d6c6406c657c55080c4adbae0083d3808b72a785738bceabc1818ec6b7075cd3e51e0b85739672af5444383ae41a4c0e2359fada74186c9a69c1d934f34c7b62a47175838357c7dfc2f2f477a1a18d53fd90585e6592622ef2bb59a9005d707b990047d0ccf49926ab3286177f2349192e12256e96f891dba027470ee95804d4db2fbaeaf0ffcb7e2bad117ebc7fac3a28a1bd1d1280a28152e34fa049929a071741b47dce449ef773c0d30185dacd56fd23aef44c34262ed4162a4d5b122e77b85f239b12678588386466d83c726e2d3d692a07fe1633266eaeda52526d32817db76ecb36bd68c3bc5caabf289401e4f6ceb0c4d412856d3a2c2bc541aca16be2b4d5f55a95a4534327237c2cce78dd74faa0c17511ab2b2fb3c1d119e28892346cfbc34e84f12151de119b739b17b932c876c2b5e0f9784a5f0150caff5c9dfdfc290a01ec94c38abaa90ca436195ca787d19dec20eafa48f0d47c8b2091d50ff26298a2412f59db457d80ad7a3cc637506cf745b17e4979d156b197f64556fd42a865a15462aa69cac9ec33f9c73ce157db77291fc0bd9626af987f5a8c6a4677178e12e08b656999d21aa1a84c8da91b63b8d05329aeb13580ff63074d28ec453fa786f599ae1021a3a137864a43db22fa5b651d0bb8f4b06c50d6e49b4fb5a659277e1b31871fa3935021c6a2fd4bb320f6be4b939a8bba2068e5328f20e417d140ab96298e6e7501785e5268c10fbe3a3f18c7fb121fa94b7644e44071a081e22e3ba40c58dc8671cb85f99cced908003f4b7236d97f760bc34f44d680f307a9902653996738a22b944c7ab2f688b45f0fa3da550dcda2474c9715235ec59a3fd4c5786a1978bfcd8fe2bbe2e502bc2a522a7f38f53ef77a29cd27fb0bfc0f32907836ee5afffc7998b5125b09b72ce6759f305b6e9efa4fd6c75eca7ee4db43eaa81c8c7bb387751c2bad96d7b611398eb26df7c6c0bc7145a258d59229f23e8ad706e012bc4c7ba52025901b6e49f1899f157f4b309365754a0930d45b83a5e09f643048ea16d14e3b00e4191da276a44f90d49434b175029c4d96914f2203e9469ec7200edce0474ad05fe3566d043f68bcacaab46ab1106c2d8b7ad3a82a8fe0bf956b98da45d69f5ab39b2af03bac744f7416452198ceba3d402dad0ccd501555e3f5e03fd0d8d625e3742ba1a83cfdf9c7eed173399850b22736309b4e7212856439b5aed4d04cb93207b9c66793936f606359d6f73c269d7f85acf09dd0ef7ad4a933d1c07c39b425b543e8e2f0260ce1ef9c0ef24cb1d4de9e1bcb225292a77f40c078605e8e56775edcebb25d0c0536a3585bc15ad91aac2aef55750fc42c1c2f996da86c88758260620ad38f0712cc80e7be83b534c9e3e603938efdd2ebe5261242f66efbfeb77e9ab192c41b76762ffaf45761a4046f1992c63206ae91758ff61f4c1f90d9f0526358aa1b47154cd21a3ba3331fb53c0338bf6e914f8d186e20dad74b9d55ee157288f115e83f18a24e241df942ab226a520755a2a95cca7e79de963482ab9d4e1adfaccbc6ccb6e6d3043ed127b3df3a4f4cba64ee4ea2a7876d85ed3b1c05cd5e231415c57ba32cde55b6d9e4e35dc44fd428bc1fe9b116409b3e5ad937145967347da14c4667e2dd6fe24f81c21ee5ece8b5ad3279f4125bc240ef1a6a83f67f0c5aab792e84b81452dd92d747617d43b1902c36db61a3b5e45e9e99383ae79ddfcac61b22e29fad85b08cde59ff4715c25db80b3562b31359d9b9b65166315f5f1b84555c9771f0ab9e95fb5693963a1470e2f63c2c288c5a99d6333e6a37739f45c04905f67997d387439bb5821bacda7d806e9172a2e1c6cde8a1965ba897d91571f55ecea5acd20b6e669c38ed63dd5f7dc40721a470b800d9c82bb4cea8ce1205d02d98c0c02fbc96073f27e93fa232514a4ae14c96eeb2c8e5c94234574c3295decadc0d2a75627f3923f1a2834593147dc49e5c92d1f421e008fe354e7ceb94dd35900cb30fbb45d2d81fd0aac6fe89212bdd3182083460b6d308cda23bc3ceca6bd23066997862281631d4ab89e571bc663d4d3faa73e33ab3ab290048250f4152113717730b7c50d86c7dc9aa0f6470e3e7031a929531fc91c136144104ad68b0aec8ee740bac4c01a3a9f0c1e46721e2caff8c78d47a9ea6a20e48b14c9650bbab70b67eb6fd258d1ed6a863221f2875d122c31e31abf17b22a3d109f81208223b433338b5d3e965da227167acc166df3b0cc1043a57f083354de7972ee2049523eda60dd0acf10f038b2c114c637d97bb2f87edbae7680dc1eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
