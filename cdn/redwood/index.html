<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bbf4577026e84fb7ecdd986bcc1a5d19b8fe1523121f5c7cfd34a6a5e5e2180190ca3d7d7c72c8ef1b6738485ef64166823d82dd7af1266d97a85d3db70e1259126200faf307c14e3b395389cbcf4a3fa0ade72c6baa68cd44a837e3dd91ab58364836881afe6152dfb34717c4011f1348a092f976be1937d733f7d26cceb09ccb61b7a29f7f19fa2c25028a902bb6a174405839f797bedf9d73951442dfec04d5734f956e4bf92cd21e3525b45b3548f1b318ce9a1b9dea7b9aeb00bcd9f4d8e93294e7b69f88b43e23c918e0e8bf74df7b03bae8366a2ebd2436b83c36ea661558b57055edd62bb15c767899133d307758ff702fce34d3b027a1eed0c709de67f1a9d2b8720d4a09ad784e2bbb3579255c70f8e8f073c5717fc518fcf504cccd564e5b6b184b93ef3fbceab90e99a0b2d754cd4e0626e32a097aa262b161842c2fa35f4717460b74de6105dd8505c17be59a99d40f7d899ab8c8b36527227812bcc26bdfe77f0d9277913493ca1ca94efb0186739a16e0315f5969e1917ea894eebbde908ee93023f35490a4381ffdf1d649275e845a1369fb1706f359fcead384f2a36c34866003a6db27269be4dcecf7290545ca29556c608b34d8cebe609c98e079e784b762223c8fb41ac25d75a1fe436b1dd71e3d668059c131f359517321335caa145822a006f1d03ba963d3028fd2010f1ca2a482c7a068be53dbad77d969a8209fc29e417aaa47f8ea327bce6e522d1accf887147c677b395ef61758c1940f715ec62908074a60a2d86ce258b6fa45a1a89e173be84d6fe0042fc1ec3736347d77da3b78ec663e332bb413c37d8f3f38909c6ea4dc91e171ffa64235c95a55609da7225b0b7187da5956c1398e94564deb1d512b5963cae05faebb0a7044ae3f37efaccd9bb86e3b1c2418128f320eae9552fe5fd57ae93432d2afe18019384c3e18b1a62b05d99adfc2272b4f529820840b32c119b250ed7db3aa2b64fb99da1a3c10ae8415b2eae80683b5fa244fb40636da6f83bde91aacd235946ec2b02f0506f451dff88063636e810456632e0d412af9e9ff89545f93913593ea44398fe77189ff0fd3d3f89c69fa67f48de4b48e96d3f5007496c74f98ad370387e569beef9e38d62ce3c705e827c16c0fd462d37fc81138563a328bfaa4ad6164d23729938bd092080b37f2bb1bbcefa2925c11404173822850aea5dea210aeef6de12e4df681f0b29cb1c7d2b5b5513fc3d1fbca46e4a6b29ba793e973e3457eae91741bc4509b7766834a59a5d0ba43c040bc4f98542c1c7daf1294cf817618f4038b22d3113a70e904693924501be431ca59699d3a10b3ee15addb7d25ea08c2e84948d8c4978001236084849400cfdaf65ec314dd2101d89b88f5217e82b66ed9c99973b564dace8e574927ef3e5737f5fe08f00fff490b68d479e3c5467a5501e8e976d0a7cdb2c85c6af1c9d84cb8588f4c528af712400c669c15d43b485c481507b0344031c746e651dd88bf6953234bf9bb3c3dd21378eeef0d8722064c0b030d462cab2cd71e37239fe855a1548b81acd01afd0af54d0fcf60ec40d228da14ac41c805f18ff00c312396e0225d8716911004171a9997a1dd336c9610465fca305895a40e527fe59de783f4d3354e3386ca6cc71008ff37533da5bbdafc738e06a3de87f28875dfe52d72d08328c814099d9067e327b0b7a57c24db5b3789459ca5f295bc8e34b27258bbdd042ac23c2503563f6b24bc2458d484094d48e1112cdd75468604c9a1237ab6b3912d1c29c96ac537d7026f4943f1452a2742a0d025960a8f0045a5759c632d5624cdfdac01a33d486cc71f758c192fcb3f8c8bc9d4637734e73d37b268cb9b15f96e4bad4cfb537ad023bcd6cf5430cfe6c9a2b1d7f1ea178c9b798e5735bf0221e1604a1000a64c20c0077756d8a73e6a13884f16675ea0b9c5729d0a4da894dcc7301e344c1b3474db31ab289e0bdaeabf0376a87113f817f4cd73f6ccb897f2732b18861921e34fe8af3011f062ad07e3f44d80e324f3b701293de9286c11716551864dbc00169c70514a4b88f79ef285216d800ca8b8f940d83a7dc116d2610d9cb9f6982e643115473d110323b14591e786cc1dc08b243242440f69bb437077e0a86c2201d5ec8caea59a6119de3c47b9ccc59b728032bd5a73eb715f67b399dc979644cb552a418ee9c3029ffa89921d9c594c8a2f8e47ffb20de8f47dd88e9214942ee3d4c32e284ccb038c24bd7181e4ea6a7314e4ae42af5f1cf09942e86a9e89cdefd68cee099c719ca98bb99aefcb46041f0595b12b419c6f1a2e2326955c5684d32cf030e012ec53fcaaf0d5ac6377d54aa08d889ae5797f43f658da38475fa7e97156f44090011dbaba3821197009e0fb7fef7514aaa30ec6172940767f316e49747442d94fcf48e491906737154ae77d84cfb199e98f5e36f871a5062908cdd65f56442abd6db47b3bd7777dda5eabe7c1f62985f3a56c1960ab95c33e7d040e211c7242e0620f87f81ef63a1264e6e269409d812e769e19b2a19d1fceeee783517ff6fe37fac44ea1038c5675bc84501771400b6c4e13e4bedd926093a1e6d1a5400ce3cb366971096c82eadeff0acf1b09d7d1ec60df43f677fefc82d476e049cec56f6f05e3a46b6e29ddb3648fec4dad08e282e938074e9aae1007c2cdcf50764766416df176a367d6305ef5e572345aae50535f6b6815aed1ac0a5d2b46edce076f22387191829cdc356b78ab31bcc0eace7d9f3fc3ac46a43b0826f4d210c3b448c3d15dcc720cd309df52b68dfe2320d76412c0b05a46709097f309c4ab6262c15dde282168d0718133f1fa2ad3d813ffd64702cb77ddcec6645ff8afb1945145f9d5711f5a4ae69c2a1be6f6721420ee8b6fb49af831ddd1f2df35ea55dbc7d8c6e2cc58ed6675ae5d7d56ba9bc3a38ffb7017565e6e5c3ed9f59d248f4f1f1f919c6fa09eb4175f866d341c0aa78bdde9cd610b8123351367fafaec40a087c86f6459937f4909fcbfbf6c6a372d4b8db90950d0a12aa364826dda495c32a3e1fc55689496db4249eed23fb7938cd9a59de66e38e7f118ff90fe88e6d083de82bc268de7fb595ec703928d098d5ca53ad1251e0a0ac582919f977e86dd34482381cb53b7fa9205127d60708524ea03fca79dfcd0e4892200e6c6e495ea491cc185855eb0651e0d377fe95dcc7984067c9435555ef4d55fa043b27ec072f5038dd591753ee898949dc7e8839ce46d86edec828a75ce0e8359db296f40a3a40b50458a06085e3cdd005e6c699ddb4f6314d624edeb543cea45cb98707acf5ab2f7eae44f5c450df543dd8ef26ea7af118173ed5340cca6ddf1184ec27b22f02c334ba938d3e85b3e41b7b2e9bafdf7d3f83e7dde9f696e66990115ac7d669a9edde1e2bad5f488936288e7f0f9385e2bac7a56a2ca8c140baf64a2a2f4476d2d0dcf93fd2968defc80b733277f851ab96760110b69ff6fd6bcda0b1103455c75c8fd141883dbaa2cdc6f5541befe98def858638d589cbf227830d811058a2dec372f23c480cdb822ef6c174679a5ed578af050c0552b5fd02ab140a9715649d106d025e6f0f65f0f0c68193bdcf2d48ccc535936203151fb021e4554320a876ec79cc5a5388005a5a7047060e64e7a75e23f75525226df28d7ac01ee465d58f3d7f07dcf5a874fc047fbf085e644a308c0ca7eaea0638383b0b605606f44badcc5dc603da51f49eaad8726f2d96befc3ddc5f4033df533aaf31d156088e38949276122786b7be78aa4d877614c9407045129fb0298ca92551f2e99f91af2da887801d250305ef3c113f63bf363a32e9d545687fba538e7dca2515ebd791f54d546cb72a674d47d2829db66b5657ec06b4f9a093958bdc96342b5e887c534ff1cdc29db7808fbd783b54d492870669fd238cd03a5b2a51096b969c548f81b4e38c4245694b0cfc2edc9d343dfd5718f68399ccba815dc29ac848360ac8d3d07bd5a1b4909c7c0cc082dca68f1418685125a2acbde0b3faede399f24253375ebe31ee35367ed606933c30d564f609d93270e8aa5136f288956d102fcc5465b9d2081a409c10596cbfef52623ae98606828d2c90cc7dbc27cb9549da8963590d6464703b490d67fcc208b5eaee9d06f3fc05d009f9c1170e94b70c162dd7e858bd353ebc52d1c0eab8e4c20611442af4c32a97e1677e40999b7981928f9acf662bb5174e878c5e1d776d2975b3628b89a082dbc887c59e64558aef7f9fb38af5951ca0d0ec215ec73c4a032e470972f5d1cab6267fec6e4aab4d74f07968b08685ba3d3fd421ea70fd1c93526c967720d881aff29756da3873a72b83eac33fb7d9e28baf08cb064df790230bfe5c6166674efc694e45d4a40b4981922810c0bbefa7e1686659df2b71d5694137069a4291fe27dcf30d1a282638cf972865235d77f3788436e90b10da575920d357af4f430f1ff9831942f821ea4e0dc92356b5e5503d1bca4b8b4a19bb9f4ab9a8047cf0b08f58ef2fffb5e4c364c4a72b5af8cc64fa04353cf3ae9606ed25e1c223c1421ea5c32970e6b99bae20a44a88ccee86f786fd13e7bfc14ff0a0647d755ead05d3c40395b7f017063b2af5a0e8bf208e91f816fb2860042f4cb3824590ec000ad8bdbaab0e1f355133315adae52a741e52331826968bec83445af1a5513b44875a96e7a6589b4958ff93fc5e80db78aeb4f7edda1441d7807aefd69389071631358c9e02a68aa821887b8943562d0744634bfcce2caf400040167d21aa0c895310a1beba687abac00633b55d55f9c9298db1097afbf30272136aaa397595a88983bcd8033e79883923a4a071946c9a0186f77a23c74e6417eaef022a913358970f59837543910707f73e90bf98fe0cdd402449169c4b6fa60015e9b55ab4c759129246a5b097f4a4a394a7e6664d631f3961ac6a117832c1361a6d0b569c015126b00068eb8db02a5fb10362e2a1f1515f1c2c986cf87cc91ff78e6906d8f4e5e1b73b086a037e79acb62dde5f12ddcf1c9dcf4f53b6ae0f1581b920dfe4712a49372db336b88c61ab644d28e7b32fdb530e5c47d8560015486c53a593ee57bef7cc8345c1df41d67ca0c8a1b5389f7b4e5ef49d679bbbcc8fb936d853522539b26697eead386bea5efade1596ea64285df55ee095e89a6c36b6f19c833198255b05d877f6623d31889f9336dcf4a455648b0ebd17cd1447f9708a0ed645ac517d79a9f4bd498c42c46520cd8eda6dab0b424b436368e0d38719cf2f3cba58e63fd468e348ae24c7995f0ea276b2dbfa8429849e470c9fcfd4d5fa9f5fa81bd4e95d155941289c10471619ae4bed74bf5be3fce3c3043aae43d9235fc9c187624bf237b971bde3964086829b0f7c82f7a792f67553c605138ab6a5a00651cf291f0553a944b5004766bdf8aa469c62d8c0d82a2979e20e84a20439cf26bf4a54dd755aa39d8018c785f55fd1e30d12ad9a1ff90b6f911db4f2156e672f42c419a9f5ce4be560d8ad2d8918eba45c39d1553577d7c7671d764c2233b70a6faff1268b68667bf3f78ddf771c1588eca28728d6f5d918e7d17c0d05393ec50ee212c30583837ff62f258435f2773375dfaa607aa5d475e26025dbc8119c733ef0a552b4a4b1f973483e2f4556c55d24d627268276d641732367e62c86a62360518f984182d42c5a4168f39dbc4dfc181bcf9b3261bc28f3d0012d41aac6dbb984f5cb95faddaeb01f8956be96eb9e2d75cb9e4e302ce89c3a10d3680f24ddff2d92b744f70bfd871f4a32e2cbe698300d1b5ce8c86c6cd19da37e8b304f2d20cdad475db697319790b48cc193f5e3289adf8bead9950a930e1791649a17f9eb399811cb41f2e232880899bc085068b4b0599b12e86d8f51ab73a7bf728a1d178d6975cacaa8b4c0107df15dc4a8f10fb52d0d7b228ee006a8fbbbb8c5beaa55aa372d8891625a6e57adf337c0af6f824db5dedb18f65c9d705c2155b6ee211347906b1353065c1c5ae531d7371ab3ae0dc49fc567c3aa6da080514d63d9b0105c9f86f71738051d7321f05efcc35af3a92c2a702734e1a6bfe8eaaafa1c163bc8f8546cdbcc683ff63180d0aaf94dbc91a74a5ffe855492e60c80ab1a441abcfc869e4d4b120d9cc5ed335dc24efd615cf9d8f3fffbea7b8a248ae09dcec367ad287ed97c989fc94fdb09b4fc47160dbf4427ad4e652e14a0e56aeb457ef0ad3bc0cba6c5eb5dc02c81b99f60abffde7df366a7dd9a6d8565dce6a8133631ab71605600aa1275e5be0811b731d5e8d7580d342ef5fc8467f97af2d4112b24f3bcba199477fb185690e5076197dd1049b17e7bfd69e8a0b7bb6c4220aa64d0f6cb5529ce8e5f356881db6f0d81de29a5f1f28aad8f842ee1990dbb32b8ea41affd940c73bcc92821147adc682f85629d928c1a77f0a9bb85b5f9acf77ba7cdbc7cc7107bf5fcf0c17bfa4c7254019eabfb13986a8354b76d2fa9694feabc009d3c096baaeebd513fccbdb27973670862b8da19924f08839071d2e61ee4e10f362161b126e2fad1111d4086715b4163335423f065399dcefd0e97a12953f217c890b81e286e45ca76dac9a0b25b928ae0dda40a3cf14a9c5b64210aef25ba2c86b771e3f99a43b69f64a6a4ab7ecea45a58c9580bdf64bccf309fee1f3b2328cee6dc974c01b90f84f91775e871a3f798aafca2bc53337a0b15f2886d9115eab9629759942b275bb0d102e67d1fb987139e947ee09268811e705956a508ffdc435368cc7146d4c8253c276a7e93d1fd2423d6052beebce674156b1de328d9e83a26337408f15fd3fb8d5db1b13d0986934cf5f75c9b550fd998b16ca6c39a46e12ef6807370adc745fa11b832d79470fd130c9e658df504253bc4f4869e47eb9d0d541c2deeda191cf148aeabb44d0e8f8cdcab09a580579176606ac2f7c3a132e612d6841e87d4e9c1529f787105fe527596f2f97083018e68940de08accc3048306bc05e1c62f2f51fc31afb2ea40ee1ffceeb6a223950990f4918655e9eb0f7e039611533091a05be13ded2d2c9ec84228bfa875a238d7d154da158de5e88c28197a8dc01c05613e48ac208b205702de8d9e65080b0372f2b25ebbd299cf923515d8c3ea5aa841831f9846757f0084050e47fb639c2fbfd6fcb1fa1b1c515417cd0efcce03d681b843bf49022e165c282557a32101763e889f899562b2abe1bba32167198bd7ab0c098541033c0828ae474ccefc929bbe2d9d57b56f90237d801ef1fdf650d78c6943c35ac1d544cdd1e511d5739f1fe4e3f02628bfa1bac2572a9a026168d035e47d30d0d149334222f6fbca8696b3d813418a6eb565e620ca76f14216373e70ee19da85e09c4c61bfa9d776305d297acf05420212ae7f1357111f7b0d319027710d4f2cfe2f949a5beedd38f827f2fbbf975703e5701216813f431a83aeea963f8e7b1d9f47671827210469ebe14c78239bcaa5d36fc7dff5123225dc96e4a2908b6e7bdce003f356c9c3ad1ee8adbeb4f42bd2f5a444ef48e95c88910797c505bd7bcb262a0bd8b7b9627f22c54f1c7db7a478edef90dc6a7af470fc11e8c658feafd4b8c9c800a3cb6f35283a5b3ef4c3cf4b52abfd682f197045b348be0ac3789447088dbff5ce692e62574221aaca4b3a32a29661ab2767e791a1df8b90aa352406e609d99c81dbaa9591f619468c69e627d4c55c40f9cd91253e39e1cf8f6c40051bafe9379d3ea5c4e27b65c44a22bc5a410f7676534af83d08c2c96c7ec8e45acc7230e5307620a2245a04c2e516b1623c60121c19dba42bfaaf58dcb58a89e806340151522368fd381e191fd7cfff7555403b6293b9049fab583a7448c42afefc3ff1a87bd547c6103a4ba7fece826ff41de61a8fd7628d0278b772f6664e1211c8f88375d95180ca9c452399862f5e0583bd55461817feb4ec2ba63981542735e6e0b5a15d708168c08f669d3cd093cdb205eaedd7b6fe89f053b1ec973357856d0760c7648a5c6acd1bf716563f7098033e120a3db66a759f1063b685a834e5da8492129e798b2878459ddb117145c19597e5bd2ae6d018ad83d9386e113bdf7345f3d3ee6c66e6d1da6425d95150c9a11786ece9f32714a79a68035d0e0d776edfebc72dce6ff67849e87576004bfbf0e59903b1fab631d6ac0fb74aece4201b9cdc66ecbe80342d90f4f3968a81892bf25a992ca4119f068abebd99eaa9d39a812c0e6c954d425d5aa2a43d26751b2b05f9b94c93ea3c94d53117ff4d36af61a82ce6914c530cd2ac27670fdcfa93d1e13d61a4f9baae23faaf26b5c1735a40dbbaaf8c2cddc55f9020df3429f649a7673fd9aa57597f0b059071c946f3ecf2fb6830a1729e39acb712e1a889687da2d7fc5042fd25635c7813c4e386b717c00fa78cb27b9ceaf2add7d8604556b3e75ef42bc71aa037844b080aa0f842aaeae7b1e7dbf3ba4a7ecfcb4ab94c8cff26bec0fcb59467e61009154927cce3e5c5a36031e886e4bf31e9d178f2909966e61260ac6202b55afbb72fb68ee877e78e50ab05ae523ec14c2c0f63bbf8361ec5ec9bd5d711235bb3b9ef46ea35fddb47bf8776f82f30f8a88c10691658a11a6f65509565fbbd48055a4b8fa57c4482cf76e3171c0534b7667e67b33799c0ad09e94022a39505483a88b538986ad158b1ffa39fa39c636f587a6643a538172d76097a407d998fac7246deeb8995cf5dc9dd4067c188867841ecb416d81c27ea2312cff8bb04edf5bf01083fcf03d82d48ee9a6675d1b374bf4e8e23ac9de2c2e1186ebdf699c504aec184cb4c5d9adeef7aab67cf02bc5909b13cab5d5ed44c7a8e73cf3efe7ca3c445cc1eab46837ec170bc9d131c79c86fa4458e73615d58110b84fe613a0f8c7b9a7549d05eafe172aa6f9c42581582efcae7e06c0d76fea0b2f503f2477fb3baba3a517d8f964f7c5b59c4c78be292f7c597244afa2d471964d23868eb940f6c44924d166d7bc965ea830bf8cb9e3058a2b4fb2822009bd239165b734957efb4e9970fe71a92f5f057b1ba9b319bb9e24ec4f055ed02d6f257a9547439ea3ba6b39d25cbb97269303b3deb634bb00b879bac872e23f1d6207df90598bbf267be6f4040d97f69a69c7d3b2bca2b3367540cd330169c83b1f56babd9d1aa6eb3634bfe5cad2c66892dbf0f1756a0e9d7d5a9bf11e18809af59eb27af01b1ba342abb6335b1815e6c644f474b56a8e92ca5cb446e3c8759bfc806f581c6adffba1f1c9366b6e0470c4cc4d7ea6cb0c5639a91d13666cc33794dc5a2efe6595a6327deb2f32e72b9da27aa48f16d32571497e98b793810ccbfdd458492acec95c5d79ec6ae8377eb3ca0982886379ef52223f64b4553f0351b000dafda3a4d65cddd03494ea7185e9baa0269962d0daee149511c90d0b387962721bfc2006e8d6ebca4c32a47f91c2296ab85adbdb17cf33adde5cd6ccbd4d9ac20ab5093273856cc2809b91f2ec6486ac63a43c6c7427ed63f2f3bf6724ea31186d76b3f90cfcd6cb25ca232cf50ffa2e475ae52012910dd54524b8a6a226f6b4e912407dbe479b09cd7f0542c4d9ad372bf02a47120660f94f3ecfab29009b2813ff8bb1747e90a9641ce7503e8edb057f2b7948758005d6ffdd6fc6c4250b540d518c0599083362bc8c9d1d606d5f26a067419bbf250edd0f43074b9cadfae3e2aa3f0c5031c3e9d9fcdb91996d6ebd4fa560ee121d95369a80c496e29ec0caf111bda024682069134b90bc1cc8fcd6b809589f411232b4a48231eeecb600013fa2ecd906727cbf2df531d89683e378118ca50da78e8b349e283dfdb59ec77410f9595b4b5c7b37d1369299601a0da7620c624c0f1380d07f81ccfa5f806b7bb8eff834f1402540f990663c2e98d09d6f4a3e3a1bfd69f6565970b067503d0fbee8e2414522f2a87d00ca01180147196428ac3af26d77afc55ba15e267eb05a911a232c60082c435723484daf78d356b2f778e9379cdcd11e417b6ee5c2e3124db2d893093374478b7b780c27b3149f18ed57dd26d9df068e34d2834e5c351f1f00768d3e2392e133b38917ecb693087d6c17c0ea6b6c6ec84964b2cbf5709ab24630cbd0d13a04c4f15e06b320d5513232460c97e675ca8837542589aafd60438ca804b842db284f330d763c8f1417748e6c26a3c41bb43c908d48d86e111e03ed3bd4b315db5d82c935d30541c79acb8da8b027d9465af1a51f1dff7ca36837ac05e02e5c57e42b96ae93836bb331bb4e47c6920fdfbebc3a7081b4412a3867afed30348f5aa8c237718f46a7cda0372a84afa29fa404f011da9d3bfc6bb005216b9236a4234ea50b7ee5417530ef1bdff5836cbf70e58219e03655ed46f9b6203e287c8ccf4e65080efba99911778c26c8407d980b8a4b8b5854a3ce44f917f76cb3b8688286523f74d72473f27d48b691ac7fa2cf6757c05c2d234dbea8a2c7e6773f6145c9bde92ecdaf15f0777acb458e0de5006487bb83f1162f92766f97168738eaedd669d390a7f5c5e99516b07590055aa4938727258b971102c17bbaed53efedb587a9c6868014313796f890a83e3dfd9cf58bf121fc8c66da28f2ec46c574409b56759f9f93d7a8f531f5ae309453620fa38b1cd035453ee4c118c845df2e476b154b4fb4d719e901a81f8306c05748d3771d474adf6b6ea0a44b5b3da31992ff5250e78c76ef372ea600bbfc36baff6306cfa5281c565daab1f81a98ba4e4f2e3422764f24325606251ec66624253864e24f39cdf59373a9f042710a0baeea726dcbf291dd481b4c364b34c3c5b1306a237366c142b1a440b74a6c816259d74571582ed074be240b21eee01055a853af1cdaa579fe09190b17b1e2d9f1b1b5f8e0aae22f5d6ffa2b421226499ffbe2a75238aa0e40a67dfdb1ad887a6f2b978a09eefd2e692ec8528e004c3755ada17e4954476216247feb87bbd59d551b9299ec37b0249d0385043c4a03d03b3e9ff4b48bc384d0c0b254e5a78eaee022637276ee375360a655b8d78829c0996177e9479fd7cb85e725ca573f83a4a782af01078925ad2b55451c531636715c37ee319d5be51474d2d07da5a9c9ea0db8a3fb3b62d89bd39aa0b640dc1f101107b97732cb848dc723e5adb90785e3a73966f4f922ff23046f0014c2b91de031412b45985c8faae59aa6f712fb9ab3c7bd59ce844d3555d7ab8d32ee303f434acb8a292dfa0f6374f32ec40c2bc40a1c2d12739314b0e403e207e1ef66ff7abaf9b3ac38b1edfe445b6cc668f59c432d5adcd67c3d74febdde2dd57944c00324e146fc8ee5e6d3c7b0dea4b0f98b78effc6bdc734074d31e132b030990e0dc9482f6cf769bdbbadacb31c6e42a33bf40f86bf82729589d1bbd824f5eaf089b6e2c313f45e71429a86ebf28eaadb653b6a828a55a96e6b6fb42ef8c3f389aff40054089ec994541e8bb6437a67fcde286c6cc2612aea7ee13547afe7c3e17b793be4560b8a1a1f1bdb5f8ebabac4e7515ea5208b09607c95bb914628758911165bf8fdac30dde40b21ee0b931f5451ec5d7262ffa4ed9874bc67f09811c22dddf136aa3248abad7cfcf71a076be23bc52ec0a242f5e00cb32d4eeb012b52ee0e0586d3a7fdf23a52d095d8af7315351783da05eff569af6da65454027c9842c532ed9afe73a5fd7985aadc80a8ba4540648f895f81ba0f0851f9aadac09196444542e29081a6fc13833c7b915920507cf93e705083f377f0c6e6dbbe17476405d23b7e5f04a15d69409ce407182e3f3f5b0327c0746ac0c85df2cba4498e43b9af15fe0ab9003a079d73b1f4b9f88946f2b375684a0a437bdc556795eed95ef5c9b39b62c43378c6dba67c623883b15dfe0e98c498d7e35d66ef34beff6ccbc298e7e5abdde33f2aa2a254c7e837441f6ea97925add43a6a31e7a2d59b79c198c73ffec766458c32a1fb380bb87079e74dfe433e4efa3c10e64857bce40ae55f9ad48692d5ff30e1fe8b1f80767a731eba86a762d6e36126d6d3b19270cf748ce55ccd484d3e890c6c852e82ed3acc738d68269296f418e973c02fd9cc1d034b3a7a6659fdf81df9042ffc9fcbe739cac6ca2f890fe1497b9d2625272af9813b1bf809c375dd609343e9a9a285f6319a350267931b92cff4f2b35d8dadc5216658cf72271ae60c55092d7792fdef7eafce4a51cb6a1e2a168b53ae59add63e3ebbf49df7d8fc0ec9aec75005ac26cff7af7e5066afc5424721798f66f781e45fabffae7c43a41ed64a04464d9a0d691ca120739505fc7741082b8dbd88f2ed9b990bcc7b2071fd0c0f27e8e92509cc85569605e4ca1c2fbd8219b90cb5114f34c1697f578e2825ba59cb64eab26bbc700aedfd53b552cd23f3972e1da32245dc19a34495f1e37dbc114ca7d228945d53a79e2ec634b0fd767b5234104b0dcfe983c6f9276dcaa4a7387e8f988949989941fb38ec11d47b81233b0b78c3b9aa1e0b4e391add7821c59d7ccf0967fc10ef872e5ff6824ca5355f1ed6390a81fecedb5caedebb4435d0e5fcdd9aa910277c2f0a79fd9a33f2af0d4e93386af0e75fdc8b6fdba2bca25501752234a17f53352775ea3b5732672ef87a2df74cf40dac3602f4149c5a92724ca4ef5492adba5a1b5eb9733f90622a327bee4414ed82b4c43a836a51651486d4c225a7e1ea8b276bc3c7de01af7b7e5d566572db12304813e952b8e8fa4c642ad1e6a8939c5e624dbff85af39c61637af343934e9336f34c6bb0f17810561eb837c0f33a7024a8a077477b6a61b076eb62e26de7fccf35f2e1b716c65136ca196a23709db002ee6b72f4ba53f0b320bf2de76872c22e8c5b5a399c12c0c99ef9c1e789859fbd762ca4e9dba06deebeb29444a8981e857aecb88d3228189fdde87dbe6002cd6d50b3356e53c58ea83f3ed89f106fcf068299b7b569351261e24a8daddf1f06cfd765004202eb65d6e84f921e3b04aa98d65e3b80b7b6beca4d11076484b9bb5e92c3ee8312b3225f7890a2bfcee641d24fc058aaf260e500757a065c4ce62a729048d3e5d0c846d7eb6e8ac0bba6ee934c3aa9a0e68be781ed47e9dcf35f3e43ff916abb884c0f71f0ebba6e6191d0531b9a32617da8160c52ffc551d978092e2f38bea9f9f39b909c475817af595860b09329c6a2b271c947059c7bdb4511f1896604450b835beb43bf083a0d30c820f96862bfb8f1b84ff322706b64f3d910a81511177785e2d2f19f953e66316633bddb930f52f817c0df8297a02dd66a3f69ebd281210f83b0cac4a0926a1562334a9b75f49f42c2106c51891e5267ad05c76f0122d204c5b831bef906ee94bee0e9e8baddd40736896b8c2bfc01bbdc872ab1c71dd1266dbca9a24a82a71182f17800428a175a888ca795825d57bd1204a1525e3cacd35973abebabf0342948c70c6d9da36c4434cb5c3847b989e10504a993881714af3b0f82c15abe756c6b09b8cb5868fe872eac020cde7d6e5ecd9086f7c19899babe7ad0ad8956520cb68a8d6ceb16812a6622a415120840df3928d196a3d15b3b9993789584c4289c1246dc433f543690bffe668ca392adf677b003e389a57d7ad7238da5b0a9063facbb05870c875bcdec1f3b4b7cc9c060c578e9e12e7570264159ca9b11991778f91e3960db9d8fee1c9ce3c9946ee67a49a1f3bf6c965eff290cad72a22d98e8913ead7fb968c5d31ec2bf55a52433d5ad03b526cb69a917414e16c6506be21d63979c248b2f224ed34b25feca408aa877feadd662b43924d7b2f0597e7c327964cd6b26650ee491d74373d0390803e4b1c1ec5a71aceceabaa4af33baa07987d68c8f3d7c453f6e77607d2f47b038c9d3a1681f8d0e4fc9355cd66c8d33e4d7e178d3286b527cd8888a99235fb51efedffc824547bdf40e494e013c1d56960c55ca0c6f0163ec46783a111fc6506b9491b918ae7c2cbe39d06f9397f200511f2e31c7ba850e5e1b6b7ccd4751f0cad2c9bc9f655bb569bcb8a47014b6c33f2df7e1d172945b5f13078a681d2b4c4377c5d7d5ba0d1ce2cf18ed7a0add8c53347e5e48184e93e4abae51f46612557633a09ff684b7f4fd4ee744437720a517cd683418d3e9379891fc43f58118dd1dc9c108af62421dff5c20f547994838ad9a241a7127fa42ded1596854ba46937c4d7ff69eafe5ee6fff88c616d7c3c98f590ce1ccb0bea69aa4ebf57f940be6e51192f8f23407c2ad446e24c0845e5209ceb02d8e5e110f2d634815b42572763b5e83e6b977826bc2450ace80225df3408144f35b69ec5c47e036cd3d2678d6dcaa4e654307acb5c176c25836e82b3ada039965c449c3653326bd0bf4f5aa6ccd9853d045b1d8df4d64736efb47682742147369051fada4157738c114c00d952c180896fec806a8a6de101aacbee20ea1439067821b91220ce74d96049827e347cde8da81bc44ac0fd3773f07ed363cb16fee8fd3043bbaadeccad43145045cbcc8c2f88edc2163f5063c148c5e4b92b175e08f80b7d48232f909ff4e680ade84b8b47d6c4afff7eec6111a6195ef83d1b905a7c9993c644520a018af245e233a5d378b55558ac9dc03897eaee83018407d01195ec624bb3336feb42c84e539041025e8cce2cbba721667238eb3399d54e12a1e95cffb3158945ee108ba2162cccfc2b88876bc1e3de7777c829987c6eb923a9fd59bd5531c843776ed26dc0257163981be6dfc8d23c4bcf1156e60c3b104ce3e35c6f3c7c48b847ec9af073e80047b03ce3eab04c5f23816693a71669382e0f7fb5b87ad2d1eb52223c9bc9ba859bf0e26ec89646004c5920456e79331482a6d155a02e794e79277b597b61b29ecdd4afe387296cd6f52d77cb120afb6fc6ba3d7833811977d256e48ad275cf59a2f35930a89fbe11b738dcfca19542e1f2078f8b4384b8d15a2dfa87115d8116be3655012caddb235af45afd15a85dd7ab456e5c38f5d4b927b7b536b79bcc763524c7728a4968c048ed0242dc6a6dfbe606fe2f1fd01ffa079af93b2060cc178c457e7e7d1d1e9675f4b63301f7e11ae0949a1abff896f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
