<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dcb4368abee2db717ac01e7b4ba73370538d0c3671a8436ecb97ec507346be0286a972d2daeaebc9062c3e7fea338330fbbab4ba97299e2bbae8b72ad8d0f59cac0ae3a14e021d6beeda1c386f0989183204934fe5ef5d940ee100855b265ec2e6378b1018ec479448aceafa740d06827c670cdcb31e4b8331be5f97da8f7fb84ef88e6eed20c24ad032b1679e30ce3de6eb473c514c47afc8fca95e1eb1f4be1af891204451ace182ae1e5e01b9578bb9edeed81921d685778130cc9ff84c0b217712121e5a0441f4fb1bc135a9156a84945c14d23d4cb9617d455e668c2c99847fa118003858549a012cb8279780061657bff12c7ad909cdee8218eeb3ed867d91cfa7f0734dad403724d1eaae5093ca5eedf4a5826547e92564d627b950495207ddb9cc39d9762497541ba17ff162528fada1803bfaa37e4f04e905e6837b7afb3fe007c255f2a8702165df2b6b12ee6630b62d43cfd4ef9cc5b9a433cc75f9fd84bd90a175b594d782b709609622739c0a10803b7e3dc781a0088e12be2534a524451c4aeb2f0db4f02863120be9e727b27fd5e60e648e1a9fd3644b684b528388405126769bf9b804537b81acb6fffb1d0d089b531b0621691ef23e60ffd50859117e60b9eb16064a653f0343eb6b6225044dba0edd2b0db5d2bb155e63ddd64e421a80e778cc693cd7dccbefb9b2cbf2d8751a59c35deca4b301d2f208523f555e5f2fec1e35c49d26bd0a37dc5c180540ce877ac6083342889589674cd7bf3eef32fa856f4b648b11d732025dff3e68c7de63b8b6d47d4b197e9f6dc626e8b84bb1b573993383af8a85e0990f3c1878afb8f7cee56e78481a68e0d08561303ca7f56c8b3c0453bda6d3a4317dd91fea3f2246173e6d4d8173ea1b1aabe965e92ca8b4903afc0880b6eb0ebb90451869d37a28f5ee183dcf0b1a58b16214564d8408cd3cf8fa716285a03f328c0f80221d47513efbf27e6c3318b91f5b21dc6b3ec77a1babf23679d0fba3cc832ace7c37db6d16ca66458ed8ee43e15b0386d3b2d2f58bf156dffa6a4c8f77e3016e7ec1a17385ffce8e74c3eda441b20ae7122825b6dde12845fc41ddccadc79d4da050f9f690e2103a13df4329f17fd673dcef170e4908ced83cbe0621fb33869e3399dc82843438e35196f63288a44ad8e1db3f5d8d09389ff35c19efa53935289866b12b16070c91d773aedf9d5258748b8252be38f72425814eb7a473f47a447590692d5c9552f3b171bc32d6c2fe8dd9cfca352081b752b674b156a8e39b6baadaa579961d99a731a4bcc5642dac17ebac03c1b935415db252aeea0eb7a0c479b3e88a3639ca83f79b8cb5f07df8c9ff550dda36741085dc10e42d26d2932ae9c0c1fa26456f94a2168ec848f3d9480133e119d06b7f40cd4602bd811b86e7d53d24d57b1798bed75779c5dec453076da61046910530f4e787218095ddbdaa8cb4a0f66b82c1b59fdd3d95b82121290b1a5af271c64e26f5d50200a63d9c73af97cb393e40cd848a742e2c76a76cdb36c03028266f4082042e765a8bd9587bd70a8ee23113eda258f407501bbc84dbd3b8b55124295b7be0ac1c9b0b15df38a71e898ec0caf23a9ce338579e855393f8ebf5febba3fdedd5f4621f102121b9bef9b4811f2b65362b184672f386ddfbecb2efc37b20f2d730cc111c90da9f52d6110e94d08cf96bc68107cf569e911992fa42cc231e8bf7efb8844449ab11437940d4bf7481b88109516eac301955746478143edbd899636517d7aee4d09eb8e38d1c60dea92850476f7f65ef9a8f2408f0db4cf2b49dd13b165c1242e03a8743b50ae9edf5dfa681a505d387325a0fc977aa00620de8f06fec4eee05580004475c34ce2b09295c5f6dcbb787cf6db29931c751a9c816dd9804257442ab19fc51a1b307e932869b6a8df20b2959157f0a59445d62fe1af8297802dac46ed83c6791215712e889de719c13c7e5a5b40a068ed0ebc7f23036118dd1a598d84776fa790ad12b0c4739f02f3e6190393eeb6fd2ba2ace5aeaa7022fd28e5eb8b179db93f4729347aff317b565d603e9a5e7a570fd2e8944ecf28cca44fa26f64a9c8c0302f223dbe1b49386d436c1f0bf1322cc318d7ea7449cfc95678cb1d2c26cc122fe1ddd77102f8790d06df572c3fe107d2acab302dcae7c02da870e788876b4a333c819cbd6111be5b505032ccb328189db89847d26f927c12a9aa46a4a70092c3256ec2506afafa1f9397b07d18ef1111599a34136f198815ce94cf57689e3620a08a60c60edefd4bf02f82d5d9a7d8a1d1d6734075876369b51865c19dae043e86c17fb42db99d6e9f603f1024d4005a6a4571e7137b75b314ab40ced465cd6e0d7d5d3f96cd23b677c88c624400db4b5df97a6fef0cd9622576249b7c7b7b3ee7ca9a2b24ffe3c3703529d84a95b73abde6dc1a9cba4164f0f097723cb4f6ba02bb8bf3f496410241f08f8878ca10cb950f00ffbe2174ff0c34aa5c3e27ab91fab5b612cbacfdb59fa3e4d4348ba6a695ded8598fab9a513c4091c6669e33c51f09af9601916de3af8f843d2e1b48b7f4f3e1f157cb10c3d4703330f6e22a89edd29fb5fa75f97ef5a1e0f6243c04bf68bcfda99253706a92997fb935a786be9117a5b429d6acc096a172ebd7a2ae859a93738da075b187050ab050d24f56d22edf080151a73810bcc2f37e6f27e68cbbc7269fb50bd3e85935f13d99e21c06a9aaa2a6d607ffb85efff82f12fb0152c549e6ec66f3b6ae6c747239c3ce17053a6f0482dd8955f5cd65ca038a4d886f6509c365a5d186028f3b416b79b1a25512df0049f15d1a40652cd7a1053651952fef52fbb7748af9a24ce5168566ff63d6634708d8c371d100ae426f351902bce44b588f9273e5a617eb6e2634230e6099d5dc452b6ae3c870dd0c66167d138f026443e920497914a84a425793d00de7828fe3e620ef993a31c675e1b323ae21bbee15cb5ab93e8b9bd67e7515638971ee249ad3e8534bbd14fc07bcafd024321c97bacc1fbb3536f4cd494e0df0c042aeec432db5f8fd0c57320e6fd03d961a129aea9640cc4fd19628b2beee938771e97b057f4084756f50d8de02b340f2993faeed46b88a7eeb4e10d26cf778aaa7fbf82bdd04db958277137ad1d269445ef3b70647112fed565d5573b0e70f419a418295034f672684ac014e5e460c9945cc7a793348d1e655585a8d7a2207dae1400d3edb7ba991abf6468feeb9ac8a4f695d8459a6996634e4aa05ff33dff85767415b8d2f9fc78cb0929597cb786d9451ecd375b28f6a1602951f4a2ef18cb00ad3b0afd6c500db846bf5f62659cdb1e7cabeb7b76f88bd3b602e80a142dd155b571711366cb0c7781425deca5fd7733d85b76ae0c679e4f7ac1005c46b6b3f4223c1f21118695fd0c28962c781711b2dd3044da3df5ee9d0eecab82643641abb4780b32609661a0c4cb2d328ef8e777360e05181bb3b2743ef72005adf311abe250f983fc0a6c2131127af824180fa87c16ca5223c6c94a1e3dc6bef0adeb8021021f94ed7a239359693af7318823cc02b5f8c10a58e6a57e15e445c012ee4aefc0b7499acdb28b6e539018e0c924cfe16f270b8ac0fc83f3b48a2c898ecb396ba17320198fc4ccf2fa6bc256f264181ac37b2814e4693dd896b6961d3c400609b4303894226dac73be4742edd66fa4caf74ddb833223171ced82c9ec779a6b14e9d73edded2bdd346758d4bd67c4eaccae371ddfb4d96f6a52adc8453ca7d6c68817c0dbc955d796b2704dc2950720e0ed362c72a69bd4fcf52976c265592a0d1f7da9c3d790e3629379a9f171e0f6e7414fc7c71c1bf546c0d0e40ce018255ab5c6a09dd8254098fd5deb653181334d4b4d1f28267cbdbb38178d12ebac4a59ec68bcc98d923f053da7d3237eed9deef70cf65c76536e549db9d132b884602097f9331d669105e9507737870a942934acce7b3d25774b7261deb94c2b7f62fbbfec6d48889409e21795f4f9005aebda1dd6cd664320bdaa92e837c8fc9d809db9210b2f63aa92251611dff49d0dfa3b4376e4a8fa411af109378d3d392cc24bd03b69cde328d915cf7c267ec7f7340fe433a8deb6269dfa567b0ae03237ecbccbcd9c5a946a347827bbb6638ac65e5444705f254dfa4198389616245ec66bb308b3c749aa551ec991a8cf9f4a400d1874111457b0b475b414370af33d36906f039ad26652f63d2fc9f29f29050c8d59eb544b3d1b4b60378d5b097f9035d32a186b9b0e592226e5d97519e070e0ab139bd9e31c0b1cd35969aeba6fe590d026dc94d004cfe49772b92e31d3956009615bddbccf5eab2f8f22031e694456d9486288bda3bcd63dc31834cd66772d34f720d8711cc054cb97aa9366bd66d41ac062069398a3accbf7afc51bea2fd34ab488b2a9aae21db171c19c38db690997b4ebd4de8c669a8ef93efe246de9857a2b61d8cfb94db64ab2197c605f27c84a6db546a01b14df19a7f2ce3ced1e4f257b8d548117f2134e1d0c3f76fc9e3f76d931826ba910dc5e01d24c313a5c2028898c9d00303113cfcac2f9aaad27a7e26043a3ebee80e3b2a3b5fb7fef87700612052c3563ab2debf1d44501af5be1a8b8d8cb21589af548a3c86d988107df280865f099614adb7459d54b7d811036ae1705976ca786ce4f2ea19f91b74fa0e6c680d7b1b1ace5ab7d35fe39ee8226803a1f98088d661cdbdcc7c2c997c86a6ade9595b78c77b0d439e8c4eceacc53bef87cd714ac7a0ae270f6d470fded0c0db0b781238bc8a40086a5e4dbe35eb433acefb1b8ea1931620282f1f6e9e5de6327c12c141089f012b3b40eda4e8171c692f924b66cca9ebd7a360dce2ceae8c92346cc559f090d84bdf7e82b295979185c5dd525afaf3973609d24e4b3c8ec58e0b09568bff13f0b7ad37430b7a8cae40f64b4f0e516d1a542626a3a33188553fed4d644cb8aa8b93db9fcaad0f08af8401cb64d692979c1ee8cf1d1a69c00bbe2efef6a7cc0caec9b17566cd3ad4cd130a6158893d4d485d567a6ceedc9187f2572a733268db8190329e371ef45b53cedfc49bd9c3c0f4340ffe054eba62789107026cc844f675549f358c9fe59b9c427e217677c1c72cb5f6405d912a895e628b8a2fc988f28ab553071912086d78fdb30d17cad1a58a0d11b2985bad89af51a8ac752720b729b6da02fb53f408e9b0c274fe38c72fc268617f2f6095d8d9fbf92fe48196cb231d9a10e27827684e6143d8a8d3ec73a72067b7bafbf4672cccf23bf80c54165530366b8b5e811753a246f47bf67f8e002a06092ba1f42b27540bd4edd1ce69524d9e9f43287aabbdefc38065dd51dfc927785372cb4d87b05bda77f0dc53797dae1d00419281bdcb343d47e5518f2113c071910a69e822a830c6afb4181473205e5f28ede9efadba1faf1ad201120d61eabada1f6a63761f12c4b073a915d72ff86f23e21850a141539a39ccbae4d413d05b6fe843738b01d522543bd0081709947fbe448a91a6cafd4eb93a4b0336ef9678601d2f088c98d47f3e6ea5626e317e79965f94768e821f2d7d82adf7f58fc405114ea25a35ecea3d8031b206a15ade6bdaf6a90c1cdea825e019c037c7f47f10cb765d7db143ef101362d87210124eb4745f72ebf0b8a402e40c658ee612feefe8e5b51bb2095abe1ee1ecae9c06c4c958ceaf4a7073e2dff8dec97889d19ce70d780fc4236cfd29c5e3da91d660a2156f5c707a53e8d62c90a55f5f2ac77f748b5ef582590619598bb72dc3f9acb30879128228c71a4ebe2118a4aa9930ac24c58c928831a7906c517e37b138e7e783a21e37659cf9b62b81296d2f5f0bb27005c388ed6206dec8ccfba9f56577b50182a3048c750d34ff7f78a5f9609fcb90d259f2f03f05239b331b1a3ad638edf4469c97ae17000d28ec5248c3a63edc010c57422f591a25d64f79177a75d9778fc65cf1939559e11eeb6dfc58c31a4332276f6bdc1928f6bb03a3bab26988cf3af6f233e9089521aa96c0360bd2944296c8461eed949d32b8f8d07fe61734def49c8988032c8fd0bb3acd280e88785ff0b7d38d7ea395eb7492c554bc5a55a533a521d1bed0db07532d050bc0d9c0eac16284786fee94764cceddf409333cea03424b848f71d35add9c800fa462316f778660978f9322a559a6de9f3d7987b4898a57f79c68a176750978f127e38a6dc84db732258fc4dc8401b4ba8e19e6069a6caea0bc9d536b3bcb1c4c8c66306820e282a5507a4179c335b5345790b5606a6bc2b808c8b6bbbf617feae3d48a6d5a1a67b1d46e388946f10e085c0cdd27f2a52d030251521af1fe1cbe3aa4e355957a86cf03eebf6ec9d47ec7da9e0cd532bc584f6c2531bdf6fda10691668105cfe4b610aa8671df37da39a5ae8b3d4f97ce757154f75b9185c88047a260d3556085ba888bbc3135154bb91a068f746052415488d6564166e069ba41a7aaae19d5dc838b29c0d8443e8b6dfee215f49d1b338af09366e7c4971e26003dd5111781429010a3e9e9947dc1065306ac66d5848b194ae83fbcf7b13f9b4e68f4a3d5fe8c0381bbd398c59143249bcd896129fb404b33924e889c0810c493cf32ca1c1c8866032cde3de6e2d3d3ffeccb420caa2f19867f4f1a091dbe5fb1b6480cdf084581bbee50212dbdf1b3fa4862320dadfed5b8e2f401be6b8422b9eeda765ffb9f76b62c86617fdc04a21786159bebe75334ced26d1962448c58b94e5724726f17e672e298b5f4c65e8b8a2375711be64521d2ebb36a6a2f2fbfec5fdeedc4d1dd118d932b606166e728cc3e57a2e67c857cfd1f92adc05fa301f48b32b0f3583ce4706b64eae751c1d47d2497cfebbbac3528ca9c3992547f99a5818d21efe7d5b1e4543d9f8c8056fd379b3b26807d7b0e049097b0bc2f7b9e60faf7ccfab59ea6eda2843e5565557c4ed78a93171e043321f44f63732bd53b562503e9088d90ebb2391b882dcd4040fb926a6bb68cadee7343cbc2315446c25c4651e9b8a9a9b1cd017d2bfdc8117e09b0aeb760f6bb52f2b60ad7f453cbff45502050723cb4c9eee7db6f3a185055a2e5056134616a811a691e6bcc4968f00f03681db6610ed6c1b69aec4e88860fb217bc6e7d4f410fb728ebd8ab27bc3612470efdc348073bb1ad82744ff476caf926645cd670f8412dbb64d69a6fde13036d85934895d569de7a100cdfe1cd5c9dbe015375549cbfc2ba514e998d2f58fecd751cb4f4241cef2ca4778aa22dbf9d61b59fd2b00bbeb8e7ca23fe01adba4c8cba4d577e98fc0a5501f1913afd620d6c625597f154ea0ee0abfe27afb8a9bf300494f389c6bcf33b300d2e2e90d0197251a6d509839e2a47da4734eef4bd3f4593e0b31ed7d16074967ad2a4d3a002ab68103b5d5abe489104c257169bbbe80a652327a46d0c7a6006415af301afd576cf94d8b78c1078358af4bc65d0b2e17b92d972cf3fdfebdd22cfe7b568cd6f4dbf065b88e90b328f78e394caf43b37b803cc1c8694db556d78799b1762e264e2e7866b06e6666cce14a86eed66e4024f23cdd7ac8208a2fba5c36c54c5737a95d85ff032959513263c2e740a374ffd9081eb9106ca1cd5905971b6c9040f168cf877c78c52af14f289d0f710fed7cf7b9bfeb96adbf1eb956be497752188b40e298aa3abae41ce1a18893e8eb7385ba7fbbe2e42324324affef4adf4100f1e29bf96b1744616e3b03e64ac15ad18a324fc429dcdb57b5a886ad21be6fd9c124fc346b3480c66496255daf2475e8f129eb6a9af26a0fd73215ba52a5dc0241d996af63ee969da5cd432fb4901867fd613fe50dd2f5a137a7028af19a892f21eec2a3eabbb8d32fe81715c3ecdd76e521c46b55e85e4fd995e003f00ea699c468b78bf44baab811278ca995e7b26e40f5db6ba6f34d91ddf8818eb05918db40bcc2fd689f0706f4f6a897a5593e554b2fc9a131237685e25d8b8357c7f6103c7b1aa22d516164fc6be9f45516f5ac3fed5d6962d6775f5d544562358abb2cafe3173af3bcd36ebb22c6fe93fe537dce32c5cdbaa2f4cd5db79030731f8fb93f0ad998b2f4c6215dfb6fbc2e17cef9b4ea30724731c64e1896371627aa9aca326d6bd772c1129048ad71abf5af15a383b6b294abce4e09e0c9689805aa9952910ec25cb5f17febdd4345e0c20e3a7e75874f1b2c06514ae50c474f4acfcef0e343f8166feb4dd38580ea2c9ae84c06aace8c0ad02aa2edf4e978deb79948094edd4f386e67d97811152cc33a9949cc1ef95556b4f2a406a347bb8b4c3ea18cacbec33b07d79008a62d22cdf52d604b3b514633aaa5e1015432dfb9e02a329642ce71b767381d784900eb01ff63d789e6a5e63840304fa30bc7ac19256cd88366c7e13d2248e95a68325ed390693b2cae8480f3931d9171de856eb01a6ab142c8a35c9c386e6e2ac1560009b2e09210e2b6677367181567a31aa14067e679cccf386bbf20bb60d2a4b0b5d0186618bc2f54636e2c921b3c07c8cbe325b3dbe56818e283e3dc8bb41b3eff23e44f15b956f0a8af9d7c882a3c908c12ef5f565eb375ac47e0ccd8471279bd500e27c43b3b3ac9f76ca9ddeaa7d0be21b1f2acee20c05a0683b2efe838c273f35a28ecf48edac4af0e483dc9fc57327bd99481ed5fbd12198102b8eae50a768af1919dd2e3ee03256e1e8f982323577a8635da2299cf2decb8ca395387421c5f4f201275a1a4918727c79d0bf2740ca5fd13eaf2bc59691ea0c8ac5f175455fa90cf2346fefbd0ae1e58363698b3dcf3c32026bff9473bd06cd55556cebf15cdbb208f43341eeeda1fda90ce6eb68f69974d70877b8aba80495f1c1af04f23880096973cc3647db8bc16ab39e6a9013b9566f0ab8e76439ce5487ecb6f669bdd22ff1db2df880255fd0020b5e1b9b081bda8651893f46f62c202b4c07c22fbe2c2072dd56ed96ab33cd829896702c64e8f19070ac00bd5709472108c2b6124195da479a431cdae2ae9888c89b4ab907e05baeb412e98911ef31ad1963dcc296e441d283725a05361b24506c95464429db4518a62bead0f7908c11a6348e023a1f70150f30254e4c92f34a676146dc5237cd02c0264a58dd20c2dbb816055fd42d27e94ac2f24369b07bcac50584f37c365b10cdcbbb5ca0021bd7fdab1a75daec6bf7e49ebf81614adff9837a046b809db57bf4ab5daafd36bf9de28841fdc5d58c21f68b2ca99fcf670b929fcb3a0b6accfff76370c1bafde89d562164cb72ade92f8a2893ae6bc12c9ace4e8772f36ad5864bcdf1770f793741f41572d0d9ade548c5f2540228ebc1754b885ba1ee9317b1b2bd91ab5ae5a4aac1382a1d6558f63114c800c419b8f048c1c7e430e382866db86f9e24710f73536921124077c72d725bc39a02542f61058435a9a5b625d5cce98164e7e0340b0cafb65f436da57e9f2aea55ce0e9ef67942a97952def3c5b2012d11879817d721495b58924e5b6cd97504f76be36bc210de56636d7a86731658ce7d70b2890d284662274c0b26663a86e43ecfcd6c566780de17029056d5c6a9c04d079533653064191ce9c1b2a5c0bf3caf3cd3e9303d4ec7052b7ad77ff3bfeeea5d40135c963bf23f76126c8f82c68ef1f356ce2158524463dd81715d3bdc7dc641da79afb8453c12d795c85b12d7c036fcd9a10affe7637886b379b98fe5061eb0c17bc2d1f82176b78f98124b7d2196e1ad80ff3ba187a3ab4da57b273e8ebeee25d7ddc42f1898e52c7fb23c2bac6e94029fed1e033a8bad4c071becca3c95684f9afac5de81cd94b93888c22354e9ccbba42788824be38605f18add6a3a81eecd77468954817540c3d17fe9248e44d57f551e6acac0e297ac8591fe98210aa3a3adebee4cd8eed87eaa7242b30ee4be7a6722e0eb864923691d83abb0f174021843ff0eef23bd2c4886f5fe09b0537dcab2e499ea4d2c51f3bd94644a37d22df8cc850c92a523e8391a30313a243eb5abf1305f5c3adf6e3d25a3caa49f3b50d0178192809c30a26caea6ac8c6349bec002c43f62ca27b6a87b1d485bde810fced9ce74b166f6ea4906129b495ca92eaa292c2944ff5d685095f734c66c03926a32f4589fca02e5cb9dac82e57e05862d291a74d60fd4596c4b95aff3ff844e12ec0381c88114fe8381b7de56eb74cc7fc2f5bba56345c17776acd1b519d6c976c9e8f05695c5b3cb856c661e241e49a75463083073b06cc35a7b8007ad21958c986adfabbd2c119d1198bdba3802fb89dbfa1b4050036c73e78a535a1bcd5d12f91b1540924c428df2551e47a31e5a1a20aac361461f37a928987ba212f20b4ef4d28ed2e4f2a1cfadf432cb73f57d4f8ac42869417fe521460197242f55f042c8f696ddb63818d8fd60ebbcf62842ffb4d0faade9fce4f924dbf04102be3d381f9ebb6db3fbbe28d95e80fe3fb00386f091d9ec2a0508059f8da8a4c003d11a32e536f52628b80704b3c53931cc5a83c93b9444da5662a00b73dfb074dbc7b74c4d59942c1d338b11667e463b2953d197e162b604c2433953f47b045590593653034a9e9eea32a304c8f92d43c54422ab8cff94cd7db420689f046f2751587a28528947b23d49d520305c9e26a7502dcdefc39d723478b87e3dd0b382bac3e2d45be7eb3f7c3721412d34e00fef1c810a76a0ed35b90ea8ea88a8d035b4dc863e29731cbbf122e16515601b96e5ed674ce4e6295dc7d3381108d6050dfe263ed8f8f91ee0d38a8243c86390fac99eadd9148884d1b481e8419a8a31401a9b72d4dcc0905271a95affb582173d0c1e6587c2464dbbfe474a7305ad4fda08818b23c770ee62e8324f7a5665651bd0f779656c8af12ac1be6e59be0afcacadec8ce5392ca0d65e42ecbbdd20c37531466af0c1f82b6f15c65291299f1de0de27c67becf81016c8fc4add55589a20d5f1986ad146ee003d2531af6cf7e7223336d110229c66af31f9af829d7363ca82ed71739336e35afeb363584ed6c55e48d515c6a34cad33ccf5bcc7596f18b3473bf1679c9869101e6ba0127819a0454ea41a71b072cad6b774259a9759b5be0f5c4ee161afacdbc3a294fddb0ec574f3eee6c43d1f6450fad433e7dba6a90c3bfa656434ebd39eb06c08975a538e570629d2741017c3c0604ee0b86c447254fb064c21507984d3f19e92947824d594b4744709fc14f2a021b96dba8b4ff00091382fd2ad30073f28465021786f28cd3d0826b83132f557afb10dda47ebb876bfdf040c3c2893fdacde84546fa10fbb433336ad04b0c1ec1dbdeeaeef2eba4ee4a333703f13c5a2cf104bc0a5c4400d5415461bb019fdad469ee3aa4149603a6005ffb32b238179e567f958b8fe852540ebabedcedc4de6a25be0ec6ac75e4faf049b276c8e19414a6b3aac0597a227798a81d1b58a128cdf84c1d5fd6494fe968c1bf7b68f1b26ff9f141bb46af2cb90c998bd57e02747a240be0a6d08f8ea39c54f2f2dda2d19d0c1735246d9851188423033fb9dd94ac614b05737c87cb31c40fda8e909ec7dddb165a65982ee13c191f831e014454260865a23bfa0d2d7cedad0b5c0c9a09c6b50175abece01d2bd2dabce088be0694e42268b4adc84093c983ef97ba35adac10f7d36b627d48cc3efefceee2c7a3f07cec988c71d37f0df14583b7aba57954f0b244847c679891f63da7dd809f2447fcad59404990750e71ff6557d311594ed5eeb15f31f816a32ba959cad8d57b478ed53ec1ee3cfaef178580e1de335c8b18e262fae4eac5a1dc9c69335820acbaf3a4d9fe5b52b9c0d7536d57627367dd7c1b3e6777f3496354dde2990b921e977b3a770ff145ef48d266802e06912800360157435111320dca2ae4abc7583b394471697ebf151db1a1bb397a31f94390c09d208ca689aa52bd071a45e409703fb1de63b915f3c7e633460d533349ddd7db833a5357fb3998ae25cd882cfd2867ddba52b10ca08fad889452d8b1e3c2107bbd9cdcaeea35575bdc5678a50a0d3f0bc674f737adf97cf181785eee9553f53ebe87239e09aa31eaf5acab0cc76323f0c1931f80d4f90c8c190d997c8d78da78e912ab50c4d23ef294090b81e0effc50be746ba54e11d2af8d5d87d89ca7351f3cc2a12bb196f84319b5e47cc272b284ccc570248ee3cdd54503d9a1bd0eb63d4b64254360931889d1f136b1b5fdcbc9c1552578d970da1f31216c4b5ff999d9bb142ca4ffd3c294ebc4baf014388acedb7dade4aab4ced17752b4365c0c0d115bec495e47dff00e24c0163d7e6208ee73e12f98ee25a336e443d7f7693261da27519fd3ba1e6737f81d7b429e928d58dbf9b7afa6bacec90b05ed7976732a4fcbb85798519282400b323cfa9831df147afc76420023a96f6a64072b51f8266e4d8993a7c772678f084a7ce44d5b055def36930df15eff29a97befeb48d76335eb7de7830531edd5a6f9ffe7a5e10c78602785701ef12df169ca3733744cdb87669b111951aaa42bac58ed4f2ce064699a5d67a793cb92c12895375693b6103723e918752a932506bed9471dc92be7ab3d4a00683a4c6953de3037f878491c417c89ba99a43eb08417b2b76bfc286ba37dc59e5545da1e63739c4a825760cc8fce583dad963d4ff080c1617fecbc9dc80678dd65be14e269a6ed38d5e9c614763f26ce603fec047bb98178e481a3e5fb8be2a9aaca3e599fbbc80fdf368c5df6842123091ba914a6b409e2c7f1fc29e21532a082415c21ea129d97b4f076790c7c9fbb01eb599151c222431a04a0ffbbf46a76d65206e1fb8de48edacbf92e5e0d54256784b06ae448bf8e965e5ddb50e013a55417bcf87d4b709923ec8fe819d7b00f6394e9b82d6fbc4179eda17ef54a7e63341325e2d7bd683988361165c6f2a2e6e12d54034e278ff3d6ccdae7138b59120ea7b3ab633dccfb3c7cb128501699d94ef2c20a718b7c8563af79047d4042b678e4552eca5c0ce9457596afcebf70f922ce227bbed5d45c6f699fd0a40e6ffe1fd0647d2611979e280541946b5a8ca3984757a8730a94b7f546273dac7a67a2cfab12e05e8d5141ec91169f0c3b84e0b5492963fe0758d504cc1a3e8c19a8621e3f78b88a778b25e5ab80f63ae144e6989cfc1f7bcffadf219b6be658cc874aa5065fec6cd80c31cd2e3382835304c66b39e5a11de553bdad2d68962a6830c2478df79679be1588dee4619ac00540e3e17bf90ce8f547bbd3bb98480018a03674bb2309033ae8a6ecdba2e06daa4b495577643fad09f7b6555db0fdfa456da51a3454f56df3f9dfd43450695be8bb25269975e1169db2e5c87fe05f47831c5b58b0915b364b2a19d7f02c6f449c576451c42f901977ecfed8ddc414755a9283a84215d890b796e89e0f5410e178e7ae5bc6c21f3a3fbd71d73c79a51bb92e5e453227dbbdddf6a458e6fdb8ca0e10c5175a6a5b421ac5780bc4f66a6247c1edd775d9af7392e5319b99803e5de509427a042aa410b5aea0a9d737e6dc942783ed439f4eef145c32acf655ee55b21c93821add42b9f42a2f0294eadd07b0ba66fb9110b3fe6a801cf922a1e0c19830aea0ed4cf7c5854def5dc5ff736521b6b7fe50b76c69f1edc28a62fa9435e72c47d90506821aa1e8a1c9e9268b97b1bf54a056848e3448f78c5f57a20d40cb5f94c13a76486d174a4e3a0ae608005d5ab052d16b0b781f52bbf429b896d8092bbd1428d3fe21c403b07815dac3d37ce30a4b7659acbecde6290f941300f745a2b52dede12fce4fd82380db8415d84de9c54b4b0f592317e51fde3d09c53c53fe9bcbb4bdc524259b0cded1c39ebadaf88e9e3d79bf5fd13fbdf08b9fbe000f4c0bc26136c53dfe7fea9a8b88141308b449ed7079738d89e387c2c991d2771a243a1522eec83cbe6b0649aa754b713e7fcf64fb10e640bff253cc0ef57e4a22149b51709526698f7f1f04233cdbbe402b3d1c636954e68c7fa77f4ceb00a6a06ad9968770f3be3114ea6c0fb7af6488de1f0a81f43010d54b2c21d221df080155063011ca8a865d4e4a1fcfaa7c77c4be4c89f4aa2bb1f26db33faaffec219da35af3581039fd3ec4a32c64c3dd64662ae68d32795dcd68ff7b7931f7a2dad4898967638774791b1ca229c2d5d8aa1a7baf8cb281748faa056de2fa6bb251bc360130faaed048aa399723e217920602ea8452d40571b914161815be8ed2530a1d06b7250d0e55a1d916dde65ab378fee9b03cf195c194aa0438ea74600694f554ae6ff321455f9570929fa5133e47d0deca0ad628ded5da50899424073136f25d2ff542774f0614b6f6f5ea352c3019560c83f01c8efdecbba36e64bcad4759cd867520143def7e34ea82cc90f1f52baf434cdce9ceda557e90924a344508e1686c3950c2092f4d4fbb5ba8eb52bb5aba528c27ca4717fbe551088ad9524accbabdbcabf83f55bca30199671bd74960736029c7e2d1cb20d939dfe599551d1646d5c7bde16ed163170647304280e206d9749117404ead44851cbfe0cbb5dbc1ef54af98f026d7c1b316516baa3034315a1a7261592a7721a66f0acb8d650b7e2845d08e45dbc97b12caccdfb0cfdca3ac15ba6b439da6dc58307cfc19266239ba510abcdb0b1d198048c0115cc7f241296491decd593caa245b943fb7d43b74ae7cf4c7affcb28e9297d118e5e9a78f0db564351c9abc463b63310b917c27227d8f037a9fa24c7fce444ebdb182a870e35d90efb31bb9037288ed9dc36888b448069f3b0fda4c7ee82caa291ee5dabdbc5f91c88c355ebf221b5e559cb188ae24bd5e8f82ed80f520845cf062829d253be40eee2bb05d278ebad26c0ec418f1c3b5a698d63e3d3c3d6558f79755b8c4e9dcdbbfdba2f121a710c5d90660ae9f6781f39496d07fe8b8555fca9a88bad87ce86c4360c5a77cdf467b0e9a4e3a4e4cbcd688ff94725552dcd1b28f048e09f772cb1bdb76541720b141c5339aafb2c91ce3fb5d9c6333c01ed162ec61b2603bee9574bb47a242a8ccb218e55f4f1abe4c5570f0fa66c9cfef89a722c61dcf5f2e18054293601da71d0d0cb7fb2b390cfb10a1327716c5cab7c64b94e0cb49428937c9bdcffabdc2bb0ae144901f0730ec0783598c5e82a402b478be23af8577dad4b3803ee0fdba68ced32226262d12ebafec4e0cd958bad2b61da7b1bbc8a4ecc87978faa108c055d3b02ccf8d42bb0fa28f90bf87a231c516580f9cf566ee90bf1bc043d3bc889b8538099ff66d7655b7ecb91f8dde812a4920fb75524d14b0490ab17fa53aedafe4d0a2d1b8e20244b6347dce264f0b0f8d380274f3704a90ed60660e62ae041a6a8942a138cc5ce0ab4d1868dd74442ffc036a24cc63df5932522203463993bdf66329674433e2a01fbcb3143a859086824a531a9a91532135e753f517798d42e662cf58a73dc9c10929b2e13dd37e35cb30f87adfa88650f2bd4814a3c64d3dc4c3fa2a8bf42bb67950efcb17347e0bfe3bac703f55edff75e2d1450ea210cb88bdd9e98f8da9ec97ead9e0ca8fc302f31038a416c07e06292916d06917411bb318d105b818eeb30cbdf5abaf3d8bae1f154918a0d844e2d2ac8f05f0a106f76e3a1df16c8d212acbb57993c77686ca1d10536a73a1d921ebab997cb3b964b591447c5d6fa1e329734913c658e5e6572af2f9fcda913b9e321a58d17df5485be3901105a398d3a0cd1064285f3d560e32fe864c3d158b17f467d8fdf3197b7dee1840d50affc80452d438b0ef58a9e4ed2652052734ed8a325f3823df9b09fdbb2bf1cdfc4d2dad63165187c63844aeed731858c63ae5042b2909836419f389535762ca9d029e0029eea14ba04bcc93384fcbbaa2c82d57cfb4e1d3d185f027263bdf9ea500c88ef7c7801eed6ccbf47cb735791b38a43ea59f2fcb9ead3d5a8fd0dd6293e7c8907f37ffb8781ebd8f21d03b577c9d6492150c7a2075906f678b601f59c789c27593e389f3ae5a3349e6450c12e21088da66521dcd9814c195c6ecfe5ca1724aa0f75af4dde78fa456965362cb22186ffb1b46cd208f9e51c5bf740bdd4960328601584be2a90bd15859a0f6cb27f8cab2e46512f78881c271cf5a932b2df967ed465b4099c905f427490c22b27adbea06136952c049f229ae81e5b186e059ddf31e152fdc289d7c439a1ff5edef21d4ccae0c0dfbccd48f09ca7be94827084789a2ddf484442e2d636105fa5fec6367107046ceeab9651f96479528a3512748c64dde5ce2e4572645e04c627129076b35a06e599b7c2a7966017fb1d6479d3ad498d1b8a2ec63249abcd1f2f5833b6ee366a8906d6881fe685746cf27fd62a899645322b4c8b555eb54b4e8bbbae41c985c7f40e38e5a28e24f958d93f770df6cad244a831515033f0af6184f147f7a6115491deccb0931b1f69ba39554544bd203e9a2ccb2638e50df7bf4786aa5811ff0bf77f82845dd6f54cc32529e54b1a1dda2f2df9783f54859b2999372e4471e4fe22f2f6cf2b924a3fa7db9974f7513474ccdf017ef3ea24763a3c8c50ced0a7b44a201b7e1b2f1d1594843cda600e2e5e9506ced3ebb0ecc23a8c6c6fca2694581291e779c59d4347078c4dfa16eb8833a49cbfa2d17e880cb27a5b070ef5fff726a8897fb855c1e85318a9cd32850376f34840361b002c20ed399a177b1bccbeb1713e34bcd9c9fea459f704d83377768192099e3e04e9c91a63263899388b142229aac60b758d7ae1a2bac2723efa35f44d98ea6d4a8d7fa9c76cb2b9c1c860c6173a34213e67e99aa9ef941e55de16e151c20e57faf474a1c541fb30c529863ada53e35137f125e17077c0a9d9a4a46894e2fc339897fe839a060501c07b9935c253d3a44479819d104f8aa13092a78430dbd0e868d3fae5e412dc903a0627bc8e1186a39e95926639b2c9ec00703f5db3226db61885f1412c5231908e50ac4e8a0a7806207d4cb7d1854e4a5de796c47aee246ed8071a12e522a8a91a93b926d082b2beb18b1c353cedd83d8f7cc7ecb291c3f550b9cd056f4924ed80845fc1a160e4ff874b70c05c913926ee51919304c4f89ae5f06bb35b16435dc2ef23ad070a50506359771481221f6b54b9ce66b9322a84a83b981b3f77ef17093f0e064acfe88c9b75d0fab1da44a2e3beb7ed5ed1b53c3c5506ffb2f2e5ef72bdac113c3b0aee771d5d9e7a9b04cd8c1112ae842863c7d11b72c661b06014a0e5f167b6b94f05bb62ffe369d73049d221e28713f1b8dcd4adb045f2c77c1c7fc1cef956d34d81fa44976fd24d91d3aca1a23aee47a0501066a37798ad866ea0f3599c89619c77ef07b1ef5fead4c6054271aae3432ee81e81ebd867f0ad86d6437730dcde7bc00869612087858b205bc3a663dfb8cc2ec57278c14188323f37092c4694595c6b96bd100a7548aaf26fa1738bf89c81b4b29ee363b8dc1976fb5a50de6768385c4bb1aa1d50165bcb07c1f09fc06400f6e183179812c7eaccf8b1981b8755e47e43739571e5f212172fec437bd022f92a2feca1eb41d0a7745f1d91d537d51ecddf27183638109245c23478888065f057294716d4bf37a84af1f5df18ad70447a714aac5065b0afb24c2f52c3c9d8bf752305cde9e05ce696c481002d167cff349464e691a139f416926500bc7c885b6aede98f2d5228a62548eca5464aa648f171a9bb94ce3d79d4fe2373a590420c433e5d27674074c415f44a5d1f9f9000ad904eb057b1d11156626dce26de65c628d9a5e81f299284ffedfbfd638f87b53b1cea56108d9d418e942e2e8275307ab2d5b544b36b8940008414055d7638d17b15e9e7710f28b77e7c52da53ae4c6dce3e6db828f06731dceff7679276095d8ac6576f55121d6986e28e64064df1d681bbedfb6d064007445592d99e458ab6fd8206836107a9ac077412c21b9524afb1e19a748600ded97d8107bd5d89b01052c1ce5aa3e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
