<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a3ae1b97e9741a154f54a1a42b34491beb36c95ccc4aab509eefbcb60ec75af90803c4f3067872475417a1c37f9c322668468caeef2b2eb2addfef3b69cad4053ccc2aa975c8b7b956b5669c505ae3dd77cb715d0d54cbb19740df9ff097388da0b7a2504c31977449fc93161f705c0716938ecc58f54cc0772e1edec9e9d62378338b3266aaab16996cf8b76350c907003c58cc6aa1a1e260f2fb1b81da43f93857d56821fbe17ef416370609414a8d7fc68f5bc143ff9df6217f218b2cdbc5d9bd5a906be6f1d3dcc65183ee15844c5cf2ccaff4a96cba6c2fef3ce961e60ae1a80f1b40c46678b27e04943d41cb7598bc7f3468ee5df8f419db9d587e8977720e6279c97ad2d8ae64fcb18b9d5d55d0c3f3721a20add0490e5fb36636acd18d815defee694769fb91089c06ab5b23a250f6add3caf443d94eb539b57bc681c24a2cd9e1496f0a7b4eef52ba73f9c8e2734c4fdcbcc6f07b5dc1d9fe60d96339a85cf453855369c4d40b227f18e35a78ea4164a12aa5fdd58905bb1463d5879ebe34dbb7c1b841489ec4392dec08f55c4203124a8017da3f0e995a39abc3656f2c12a9d4299844910b148de34397b4edf0e40425c89acb39a8569233383be0b58ab72c619eab0db41c4d4085425c195b66a204bb94ae98ad95ae566cc3b2783b7e3d3d3d233967a47d850b3abb06029562147794895e56a6f869051d979be70a943319b6165bd791177331102078a4364181d32403faa2ed67b8ba0c571e610ee111e1cb5b7b6c4a44765f1c5c89bcb042d6040393bd5ad34a621d4068297c592282776a01ffbbecf3dc5ffe777da98f5521cc6d25ce95dc45a16e07787dab20c7023f59c755deed5aecc4d08e2e962c096ce2a9803430e4180dba173c8b838eba30587e5ad067770bf48bf2a949b31833b6ccb413218ffd6980c2cd953304d7e0ca1b4e664ba6cee3c0cedde9a3cd5ff07ea4f55af564b750c2a949eb6d488f05b6f145ec9fdf831847d653073bac85fd1afc71b2be7d19540aeec10c12ceb19a162d6c9e15703defd0a5b41df156d74d751f049b668cceb97ce44aca10de27dd7beb5ab8eb339c9c31725baace6610e2e2876a11fe13e67a006c078f361d6a4a93d67876af424f7e425ff9db0c460577c327306fca81b85d62744fc94f204caf1895d04333d1af76fd04b3fc11aab040b52a0459f0de2f97d44c67c6c3bf6c728c5d6823361f68030dddd800edbdae48c81b38838e7902ec8fcb0a30be1fa2a85559e3f73dc109b40387ee133094ea42725ab313030bbb7a35ed76722d8931adc3a37173f1ed24aa76f27fb91f82429d424344b11b8ce793c7868b5daae7afe510aed99e55b122c22e44736012344a07f69e970445f387b838ebbd1a23f89f8d9f285db88b9d9632a57f1ac714313476816a8b63204a9742f3724ad57fc3c8f1da6a86dbd991f9c9d454a05b74b0d4762f67a83f02d03d57ef93ca352ba6398f735d2c709f45722044e665bd7f1037d2094e3ca079f4f02ed27cf32d2bc6964818931c3d4de70515653c8484e4a634fb25a1ae849518e26943e216aeaa128b3b27a04a152be675d219c01048b818118db6fd1654043585c523fac14f35a0f90043c3eceb953c4bbe079a35a1ef758515e8a0d82860cf107ecebb9038192b02c77fc7a388a8727e72ce7535d8f81a54cc2877e3720c618503bc930125e7e81ab5bec90a57e29f4a643083dceed5c5070b73568752168c45567b7a40684939f75b8e049355d9921f50ee0166a7ca86c02b8584c8e89e92ba067e395d83d04fda26c6fd900620b7a5febb4951d2b402363973057a2be5b20d9551216b3cd80cd698bfc1cfa0301d5850f0065e840598ce857074d417e034127e0d5aef89ef34aa13b82c8648b974beac3c1ca5bc44e71431cad6a4da2ce0c93e41f2c1d0bb23c6ca9f0dc70589e4153b2d9e819d19fc78408bb6475e7898d1329c99fa51f6eae930a040c24fdc09b9aa700540ac441e6e7d98729edf21dabb095ad927c25c6e4f3d38a706030b14bba7e3776a5c5408e27bfc26d7016897c634b9a4264acfd1e6ca2eb19d2a8af8cece9af5a93df8544ce9b474c4398b24a69f992997ad9342fb673a0b3700e91412e02f13f0891c80ea3b64009743af19aeb80b0ff732bd8b26309f3715e26619d5cef13c9c490112a7f8d64e01d7add7d083e6cede4f370578e6f3e7ec97325ca5ded4766b4485f6af49708cbbab68e2cd5eff1cc1f52179610488ec37f040dd3bea448f2a472a220f9c6bb0077be1c1d13cddf61e98fa5ff5bcc0fecbbe745104ad9358310be4e1c64bc4335f2a983e2b9871de3d2a3d0d66d868414a48f19f661bed61d6bf3fcd92eba71d7639809ce6adf09b1957dbcc7276664a52a463d434b945815b10b5e4d284b659b7558b498b91cc01240a1da280471e78e8b5f04effa3dd910cb3c14a6bcb244d68f3e1b723ee96fde91ebfa3443df98886627b44dbcfbd0c514d44a7a11255b253be90187bd2804ea4af0c1ef5debd7de08307c3622133160c32acf642ca576b3f34a6dad33c110e09a31c4511f1522023589307200c45629793a591be148b22fcdf536a44912d12c55a35b656035117238d13f6908012788ae4b7389936f49b7613ec8a1eb19935caba14b9ef95c226a37b7bf93907a8482cd8d7a837e92086d22a75a31720798c3562f2a6e05fa28ae93c0d0cece57acb17640e0ec94b7cc0b2d159570f611b70c0c699937d97af0a8b1e1822f1a683c94edd6d57c6e258e1011313c0d0b22e7d8e692a81c78e88e19970f3b14c34c6071e058fa9331dff45089d62fca4f42724e4b45db5842c3dffaa43d6f54ec948db9da92d4e6ad58c400c3a01bcfd5a9f7d5b437b33142a4c357cda1f759f90f6d8184c1a0fd084551ce5c2980033e17b4c97eec2d1ced9adcf1f24766fcb3c59e04ee7cedac0c497f864659c89c8aad197fc978ef134e2340c433c6b0c5721f5deb94fd7b17373ec8ba8b0d7159e9640540bc867470c15ee3ae9ca993334ed69e110d86cd6b9789f48499accb33ebc5daeb8c3bfc89134b1e57cc7e0eb16516480777365e9ea9cb50e44152245c3c2126e71f684bd1cc22729b35b85d8375533a03d0ab351cae930b237e3a70cc37cb2c1e29ff1b84c274fcf02c748eeb57e33a1d059277df40326b640c41ae33d11218f31d4d42cb73ad77e77485d9396df7d22f3253f18839bf3bbe7b35425afbccf10126d87fdcdd2889d575455f69bdd7b0004948cb2e9076600d0838652ccad0b24b579169770920c8bea5844252ef0ce7b7ef8d394792911dbaaa0305d6fa8796988975e7fac4c185f87d501d78b5be4af7ca7d0339a4eaadf80e9f84ca5cfbfccfa9ac84499ff684f200dcee70c536d65fdd4b2020a419dc50b951a54f80fe40d62d2e2cd74a55e4de35247119357023a1be3491f5ffce526a30ba4ef563db926cc4e473b895de77371be3b1d129b637035f3baadb5dd2ddace42e982851cf232d01bf602e0e48c658fa5c32a5cffe70b8fd2a8c9d32b894edb58983eb58aa9d87d7b7598539064e8803bb0e3485b4fdc6756bdd465f361615878f043fa59bdcc8bb8b5f33e03d07b049a3171ce03f298e18abfcd815dc67312e47c88acb33807138e66f2f30d6c3106dde3b0f64c91fbbcf97a9835ab9f7a7a9463cf73cc324f6403351552c02f8533067c924baf68b3276742b3b318fd7c4fc7158ba37a1d9d65516eda2235c8533cc785edd6837e5b7f91d5be909c73fbf427b8778bfcb1fdbafc1b99a530120bf1ea5cbb27f3f7271e1a16a91ebd444fc07d22c98afab1be30c34249f1c22a7032c57720061e07e146c7b5ddf312f23eccfbccb1dadbc3274098a2d3e88636d7bebbab0bb73726fc82892af8a9fe0af00aceb840cf8b9054a8aadb6db9322cdb5220961588799d45c5b03916a20a8c0e7ca87437fb0eec81c5ff9d7a9dee58528231c5240636d4f9c71a70cbc4345e09e04d79f4cff82c730eaf5212ffbe733f414917c87b54d4e7ce7f204b0b64b64e1eb776a7497efe028ccbb1af5af092060f732ce5316cca9fe6d751d15c6b09e8b9423e0a4170aa02e73aa0645c431a8aed49b0380c0cd70033a28fe69b51715acc79a2565c73e93a599b7a11764a3cd76157a27932d507c1680a666378e282a6af85fcbda8677fc37c6c9c373400d19ac37753112b78d03b941177741784ce5140fa63872f6a2d1b6c0899231c554078fd5e48695284ed515b88e36fbfcee712762452120ad5ce23b0f225e7e1deee53d913ba079bbd766e68067dd121729529d95e86dd40a2e1dd1a8dcbb0bf6d0e423e46c285e5055b044d05752131f3ae6b617a3a7b106a43e2936efe89253c5eadfcbb6c72a5732596cd32a2d5272324a0ef5af4c06d70a2a85163694b0c27c4a617d9f00c6dea5b6acf4c162642164d3611ef5a176b03f328364f64d33f09cbbf110939b95b1bfcbc93a9bcf3ed0d56fb9bd8e028bb2a98e1dbce33cddaa86786997665799194793d610a7503139d0d984123c83a82dad61a842a451fc36027e20737fc18d68f816fd72517dceb30f2bc582ef5b1dad62ec449fa70aa046de2d91a3b247100593847a7bbe060442a039235b67d06037e2f3ba091072585f44cd88f5adbb6cba5fdcfbfc802d8668ecb34df9f276e18fb48667e2593a7996eb415035109a6417c5fca53bc055ff73982808e634cd5f6b6bf8f658831937a7e4a7ff8106c355ae5904e028388ccddc1f7a53986b6ac8b5dd183c67bd26a73829a75177533102fd67a54f436651a4e36db27fb420aa57aded56348fe659db07818c53e7f80cd807d84b92a3d0872a483f0a514ceedb6943230e6324b88671f5e34e55e1e422dff572d06a1ba2e3b7062b49330667cf2b09e79a4dd868db91a290ec4f6dbcf729211dbce3b63c8a41480b6f2d5e26ce4a127ed1bb86bd65b68d6a49d48d7a821e2bbbd0073b8ce8032096cc74e47cf839cc3a5f921df1c65a3eb09a7c6d9783cad8c03a4dd978ccb79a07a438836cc4c13aae34f665aa6100c8324ba7c32496b401717317aead9c7e6ed2411e9ebe15f6ce80f25b3e97ae166f911fda88a07f926af175a5e60da38ce8ac4f54b6ec7ffb26a41c811f419bf30cf6d12db85c81b6d951735186a420eb64852ff2bd42b1840f3d80d8905d4e468326ee0118c70fbd77b2d1f89849735c5f3cc2ca39ac41b9e8b6d822e5fabbb35804cb868b0224c70072458a3174b86bd1fd9e2587f278677fd57ab42f8b590d47c5cfcf7d8d3250d9ea23fa086625905f86c4c0d1ca94066b629e7426d0998358111a40ac98b3faf92b47ec37efa40b64b6e62d6da9b23169e56394ac81f1422730deda07597963aee6b2e6a33ae851e3d1526406a19076e26b57b1a0357739cfc0225dddc5ea560604a2a5b5c263afea9640074ae1db0ff8eae55544d425f1092e3f9b46fe031f1a7cdd7ce1b295eae76cbd66e92bd9fc18d195b828286975f4d92219efc18dbc502ee06fa5d8a73fd6639089241820f1fb5fd7a7f3d5588b742fd5e6f0a340db1f41baac189effb32123ed6ebc3febf8b5a77981ed088cb42f4b735531821b2f446c664da1acc31232cd048fa273d727729fdf4555cee6429e1b7759791e09a0106a1aa972016a0ea74e475e2a5a03162966ab1ba4ac69c8c6628deb50050612e8c6864d18a62d2753151d5b63d287435311c207a7eb87ff447d3d3649e9d948af71865de6cefce09e15f22706d1dffe31a824f759e29bd6b42b2f3890ac0c582ab00dae7ef80d9a72a2b9812271b4915bd46c5f7966256d42e5c24207aba6415f32564685ec6d69dee455057a0c725c9d7b77b8b61ba2d1828e1eba17397f7b5dc09657597f392907f09f821a6cc16e7e1b79c32a2d3c9e87a90df29738762d2aad1d63737ccce118859e82b55c7064cc3f1d78db771d0b349481bf69bdd34be3d1635b6c8df73e93b8f2055d24bc456521c3e54c80b1dd1341ef91939a4bcca120252959fe09adea8be90433fdf85d0a488d89348172a70e4c7fdaee98022d1f2d7755c6faab394f71529184089008a39864d10b23e0022fca5ada00bf5e34bf8776062793bb0eddeacfeeadf75583b4e4c8caa361393ffbacea113c61d0fc4f4202f815031117f4527e92f98d7b58d8c7ac36bb0abf2939b6b6e969b2e203bcbab7bcda57cef7dc3a53e9aace641d71891fcbe6a0a3abd24ff70d8f6c4604ece561a9c99cd6e846aff459349392bff2f92a2d9116edb662e24b21b23be807bc51c0f6457ed447ac0f7284c77d97faa8e9f8a9e66620c7d830f2c0179c8cbd89a141d467e64c6bc11287b5888148b29f4fe2e06c8af807742753a70078a891922a0b3e77fe130fc07cca3c9ae7aa5d18ddb4c234416b5b22408d6319105bb11e333282dc7976cd552311ce4ee5d7ef7bf7e5f8738105a8465139324b589f37de464d7d8a7e9089c8f648cfb0c62c6b085997617f67cb988c386b36fa92266840524cb03a25eda5753540bd2a67b85ff64443f385a92820ec3402c305f9f0d4091c59fa1e2fa1cdc092378497783c74f4f172a6424a701cb8a27a07b457b2f092b7499025d51363b9c063eb8d2d47d6051188de8c527932a752b40e62f7babfe07dc9a8067d47ba1f68be68b36e9283ce5e6b5f9f63b5395f3e5f2e87d1f9fd8fdcad7baf0322523086c8fe0797ea8acfc82370a7a03e50d32f4e3b2d06b8ac7d9e37bb9bfd49863a66849a55583c8e7a5bdd4efd8a9c9c5ea1038e61328b27b025e9bcb638a1b068d917f1a54bd04d0963593f81f402c1ade119594bdfd53ebc8857f35ead163394492240c8877b1b25b32bff12fa4b348e5ec64e114bd715b9c398027df929fdf3b8e08124ca37d94535477bd4bd8764b4a6bc4a13be0fd12d643adbea1534d890446c75dcdc06d581c96b1209bf3ba36062d4a58d4e59efa6f4449e3b17feffd512035e732512def245ddb8370bd98064ef79d185822fa95db5021edc82f12ee05e6459f1e59f8583a30392d36ec4ba3bd7122dbf54a08fb585c17ea4a2586d5a8e31a04e5e53ea667944d82f9642c0cd55b4e936c55191c3001bf2e36301871349388f729b4a6db3816e484c18dcd5b947402c088130ef00440cc2a11cb82c922b49df3d25990444f2224d405685e9f35766dc3bf7d52e22d7b5d84875c9165f3acba3a91815480b15efa0f10d1729564cdfa8a51ec9352a575be2f703c40489a87bb6acabf788e447c79dc0aa39df8b865760bf97472dc8bce66ec4bfa48e4005c94408a2862dd472600853cec367d8494c6327b16c08bcd512d41083f9edae7c7b0b0c2c20cee3380f26333c467fac4ba90ce416daa12e423166517bb520d1b115d78e46e05ce8ec9b4b49bf15dc0255b48fd6a93114dc3dd1b56fe88f0e5a4669043c9ac88bd884749429ce7ea790ae027e2eff974c5ee12d8fcabf82596653981ab29648c1d07f531717310054e531bb0a06fd181aad43a7a4055e49527ee8a1c6ad5161d5ac1230b52bdceeebe84488876235d29c471258447e14bf9d62c5f65246b527022678cdd8afc71079e5c32500f93b2114947bf9afd137e74ba7e3bbade08e97985d8d76d9b5b9a59d4914520e2018b2dfd5b5b3047e6671f1b5383a36354d70c40beebb851a30d7c30183aa707928de7115c126d040d5855ef4f862a6bb0487e7da758b503bb8b23ecf0cd2ee897b87fcaae6cbf49d63fa6a671abb05bc418dcb9cd366431573c5e53ba9454129c70e5322d75fed1b9d10e2f09c4d25e7ea0b04c39a96c8239f7f2e803e7d6ac72a50b7125d4f6212f8d1580d9593b7e73f6ab0357e4cb8165776778d8cc725d28aeb90e9e644247a63be2a686048023ac5f593630f4b49b9218f33b6b0b46eb3a74323917cf89d4602a9398042fcccf7afc694f153bb1be5e96771f82a6477fd273ad9107a5e78811f2b87c8ded3b30b28276f30a21966c6b21b1549ff90371a835a0f91e634e9a81cfdc9354d030303c83d836a0c22638c0563abf7283b4b7d331b69dc8533e7f185f8ec1e159d871d24f2cf635e207938cfea9628f0bf0529a613f13dc2e502f02aa141a9d207c15b6531124e26a4eef31e81120941c52a1b79599b59bafb8e0391f81a55341f2d36e52f6c917ce586e4e9fec8ad6038f8873c557d000e73271f608bafdc6a6b34405c8cbc00706e19efd87e33e9c21ec5962ed0b7fe363fdd281859977bc30caa492f77f32e21c68ccdfa631ff81952a590aa3cf1741cd2a4c7453346f7b59967f8fad27dd6b9c63683e5db68836ea7292edf484e836d24525ccf793a0b78f81471e689b69b3e8d37b469cccfcc57dd8976b6ca80d1b8710e561a7dee6ec22221b9257a04c7c6c4f44b6836d8ee3f7e9367d59aaa05282902938a17109bee6cfb5c251844b50d93617d17788dba473073714e5e66294a9c4422c1ca41f6f44558115f01508dbcfaffabd54b557e8680f1a8ac77966119790ac5c16ef394f220e3967d368bbc84639d0f890d2619c3aa0667ba9743537da990f9f04722d0f3da693323985d281c3d6c7b5e053006e521d8cc9ddf179e4dd4d1b263bc61053690fbd6239834af8bcad3cb3b8fb68dbb777ced3d8c0184c02050195044c0096fd9f4e750aabe39eb708c9187094068cd5ba7c7e110bafa4753d84c9db00da4de07ba56ed6f6531f719232932d1e486dc6b3b889c757dbc56748591fc1bf65d756be5f7bbdba365a3370869eb26eb5fc743194460f8ee6589e70db751dd31f48258554a272e2f1d0644396ecfc83be892a6049a17bb897639ce5a12c97dfa1976c5b4f8b45be13bfb53e207725de1148417ef64c89d80cb8e24c76db39a5a0223e05748ee37020e1b0cc7c6d06d6b3769b8d3f38bd7ba40a5288da5c5880c9a707e4c9778a67667a68091121bd067bd5cb08dd4680683825217f16e42f18fa1697e76e0ff7fe58f5d80b8b6af5299c0b12a88b0feb6c388bf89d7395cc9ee9044054dc24b98725175f47b4b0157b812227e7679fa237ba0242544b872aa475fe9edb79a55978e020137f515115733e871647c003856213735b1f3ed2e61bc38fd91ed4171b4e2c454b202c594f53c1711e78e54fc22ef3b27168a0747495a05911812e68349c860f67275c11b2801468ce079593e3e199f0fb9ffbf5db614fe0187a490a21b8cbd00bc5a35b028cbabf6d612d2a9b6c8ce6c8de3744bd5b2a2ff6a3d54e98ef1ddf2dbe0098dfccd430ae4e9338fb08c7699dcf9075f92469a6c65d535300f79cf87bbb585e5a2eef3e76a4105fa55292a0fe4b1de6812304da192f3fb238c447c47d8511d4b79b249ed9d9d27188777a63b7db9ea0e0741b01b5eb04f425021427d8b3e9bbdb15642011e2e5aeaa578ee4b847ba45dfb86fcac1f8ac55af46a70fe9dc3fd8d003ca0eb5605e901ad2ad8ca882b3428a5f2aee5f65fb628ef49b5f3f47557e0966d234d7b34f6fdf8c5aa9a260cf42f588976827f92b04058a28c7cfc751658bb733cc84e892d0a227ff394e844a06151c24d70fa8cc4a3c86da29611af9bc928e9e46d90910039c433738d2f6d21ef91c87098bb932539d3102b72b6677b2cfc111ff926812ab66f1c331816654632b8473fcb80f14134536339fe1a263eb88d1b5932126f8829aecb5d6292474b4c6f2f5663aa480c7f620bca957f778cb95fb87b386efc5ccdebc27e9b518e4f9e666959e2c257e468c705cef60b7c41361c0f7caf58cec8afdf1f9e6ee58ebcc17f2ab9e19b992a09391040d87e01545cda1ea562bcb2e2103cd1ee51efca542b686a5a16c6c96ac2d96e8de1165b7edb052981d14af5c698312c39df8b08e62e09188e86e77e815f16d6f41c1fc4907e60a0d5b784bba55dd196c2d5a6c5e9410a320dafff8fef614b33dd93623d12bce650acc1db987436cc04ee834d637bc0e0f6857740a2ceb526121e1f0305d21da142adea6be4ab85dea22bf0cac2b1aa62ae438c70c2a5a8e90f0dd83f87afe58167a1297a3bb4cb378a4c64c3bbec3ab7c08c16697096fb15f8a042a3c61e6ec33b403f691627dc10308880dec5aa51f72594ec41b3a90059b057b23d17a2f474e1cf5cf200de6b9f88d0ad1c34076e3a5e9b9a203946ceb4f26b9b426896284afbca0c564afab25d1bc043be27c8ce385fb1ca73daccab923cea1cfa40c1e96a5263c92a4e043c4e1babc32c9c941e2b706e1cb440723f7661564ea226323d8cf6d464a69525a3b7a5f1a12f9d023ab4366d93c55a65fd1ff85ec7a0a9a1b2aa6cbc18aa9d79d22d34efc823eca626d9d2ded1f9fa5671ad39d35ba146e7233e5958b4b74d6cb4a623bc2a70e00b99f86f856dfb8b99da5d6f8fc774d88105b0f096b0d750773adcb7e9058aed0f99da85f2e72223351c4f93005e49e8ab3ad4be6e8f950b0b43ba5e6f0bd1545377cd15979d8bd44e168aa1d53de70c175ac2dd1e96c429b2caa70f0515617bf04257eb36631e0db7e62bacf17aa9fdb207fa30221415f829309b6093f13519f1729f46a1fd7907e119c993d4d4ed8e4a306d9e35863fcfe82217a364142b81407e9e139e46f9eef214471f51477571d999be7d34f2aee095c02c8764766c0f7f1a4b9a8f39cf6560071fab692bd64a314cab05f04cdec65afea6b7498e26d8f9f2c1664440d65a2e71133f9cde48cfcd830686b0a100366aa0129bd92f1230101768f1358e1370e40e257c1cda5f03c7958d6334da498baf235abecac17c678d1537575c8fc9ae34bdd94770ad3d05348ec4253b38ee9fd2411cc498b1497ab96145797de81f4a242e52731e8b710712392f5184eacbde6eedc33f8b652973426ba6b167739d7b713bb5aa133f47d6c9d7200b97a8c4f7f657d9447928e53ebfb9d81eaa46b70863ae6a113389a7ff04e96409e9714b05babf62ec09ff61c570a7913413b9ab9ab05be71d801ecf5f968fddd646c7b494fbde9e42a24bd823466ce4a1fe5c701018409db860af6c51fddddc41e3f13f536009f03b3a7a7039d3fb4cb4a58783c33798fc3d3a651306ba236f373606c55f3b9ddeef52857ce2e1e3ad01c5ce2965d96b65e13290d401c3955022bda75e808fa200faa144846e3df43ae89ee12ed95f6c1c00bdf638fef01a97052e96c9de85c4eb73a1fce004bfc4b660339711e8cb9e096f3b3303befdcacfbec2c036c96a3695eb33b2535346f21d11e94f1e597534b46b5b2b41a340c9bcf1cb686deaf5bccef2b462b5da82a678383eab9805defde93aba22090ec62226c608601cc536046cedfd0c32824be0260c222c56998cd1821da22d3dc575a428ec9a32ad395d77ab32fa91a3a0797310a6c5198953916c40d9e09cdd6fe4b966847e1ca6bbd2568cc2ae11fe85ffcfeb4f83abb2df2f444a807c672b0eb0f66d1aa1ce4025ade6ee6861290edb059718342ae043950b551221fd09ac18b7470aa2fb6fa274955f9b3f7b861067be9ee9fd63a85991b743fcfcb352511de4f7804285bd496e95510b96bdebcfb5a31efecac1434860a64c57484e92419b30f842d7722bde41a5484db6d0dc725626ed9cdb89882a4da9e3ff7ad2c8eafd856b51dd4f22bd07d83c32d69d4f4aa83edd8f216e14753a895fccb734e258f89186841a5381b085adb934936238cc6172976419838c318e7b85279fadb936480e7ed3e5099f1b60ee0a7df7dc92b00d3e083ea80884d0e6dd88171f31fdffe680a72e2ec47ab6feb631cae37d35f2212be994ef27f063eca3fbf1c059399455998e7c48079e86f5f4716bdf674a12fae9e5ffac504b546a80deec4ed3a98fd15e6c9b5ea9ef8ec0caf80d8084befc16a955907d71c12e81cbcd1ec2cf3a9450afaa9c308415d5025e9fd646038ec5be04a48f7a188571297e2bc473bb1614bf379c8cf4eab7b5ac248712bfe1d52bc100a086870c570842f5410c15230ac3a71e20d5d2233602026b65537df55c8f508004405264d5706f4a0b42155667b64a699097acf1a1bffb60314d17055f7562a63e79e0dbe4c132e91c811aa23a68fd4a05822544358f9f5f9bb5f7fb18ae5a07ac6f97d30a0565f04bc01ad039d36fc75e423a176d43c15aae9b4eff4ade34a6bf34a7c324d4b5fb19bfb6fad538fa02aee28ff19b1fb18376ea306ba35b424ef398493961a7d03dbf78f75ba247854a1eebb4eb214818354715a59a0971e0b4562421162434823c3f97ea05bbb4d08a5f5341720e3ac70094839f6dad21ed37c174cd6e708252dd400a7becff05d25fae7c99826d66fac0d74aa13f2935fd1a64b4e04031f5b89bdaff936151e7c2e2c30d35e8b5b00b1fbe10c501a9e337d5971b5277f431dc42c419123ea4ef30ff3809c9cfac0021042803a3f22576e11bfaef3aa1cf8fe26dab11f5f018d179a4cf153508de0798df01c7171506f75e869d32cd5fd5e6fb86c529188ce4a291fafa1421b8b1eccc1d5b3a8f9270dec2d0b4f73c9aa736e60ae99d5da803c3903fa246ef47c3b3e351840559a9a379a3e74f3a3c3ce9b4482341db45c536c4470faecc15b6d6ee822b71d9c7569d336b24865b9d7e7abb7494d148c19504a5f80e7184dc01f1b17965aeb6713a9f9c6062a3d513c0b5b0594cba90e49c5ddae84f68c37e8e9272c8fcc8e3734d86a1d123c8f8b18f9987bb9fae86b65ed93a371cd466c07e30653217cd2f4994acf4d90129ecc217c7951db4d59eccdabde707d479fb6d2ccfeb9ab164aa5f824b62435027338ad645d00b749d64883ccc728fd4bf1593633403080dc5ef88c815af95bb11d58a168a98877b82a8146c68b41a0e772f06b9b8ce2711ba565ebae0361ede7b4f98f588a500073c52a160125be287de08fb4d8258ff83a0a15533528e53d72347f20e06eae86da3085785cbf1577f969a05b3a5f30f6a9db76f1c93a80801f8fabb1c1cd731abe9404cb56b05cd3d59704f4ac6c45b092026adb5829c1410259d09b06edd2989e636ef6f227d5f3a067a537ec00508598e210014b07d0f6d3b1a75a5828be1ba37a8ccb78b3543b77bcf38d3fbb64489da03da9d0001b2f636cf9737d06f7215c16091498c1bf5138ae48a7c4ed549967aef45fda215d0a1ade47ca65def1d0b5ff45a427f2a835d65f5ef5cd375beb69c9933f4bc32fae348e89243aa968cc22148f702a099ab322de6d03fcd923e97e9e06bec1604588a999dbab388b553881bf0e1f1cd6661c920804f38471141c23ed68988b67a63097d92efc79429eda7bc13f050a7fe135591b8645f8761c702cbc66bb507787b27db693f9269955ea1239cdf7a5fa102e01bc24178b9d16165ea6e7b1b547656ac6c7c987cf6bcb4075826e6c1ae2104a683aa6caf228c5ccfda8e57bf7dbde14f0709000f29cbb96369f5b22d50b45cc5e07bada53a95d0062ec61ae0926c9da4495d896f2df8fb15cfe6930a8855231612e548cf4b1d8a9dd4e15928ee82b215cc4cd525e26f54fc1a7b204c60bbc772a9857e9206e6507752222c140a14ec19a3ea24d04fd90d0f3565afd39fdca2567035b6f49948301037763ff5a6297d672832510de0a6a4d4805eaaa7778f2cfd6c10e876cca9db8aa966a9fe97b92a3866e39471b3bf9529fb889a1170ff5882f2f1cf11d958c281d09fa17e81be4857ad60c3cc6432946ca95d4822620cb36835fa0c014d89b08e7340a6be9677664f2feec07eb662ce2c9dde4d3180e32fcb5a9eff1ad05fcceb78dd075c677d91ae8208978ed5dd31d05a8054566c82c7dd092bd7cec0ee2ef2ab54e03bf39b627f94919245cdcf1667ec5ede8ea94a5009fac2c4b07bf8e89dc49c11cc8888410a7a26c03e9a3f2ff0a0503337449bc743e932c2eb8377a3d2b81613c1372f5bdbbf3708d6be8f8b7d9a1dc1274f49244b2e41d00f8e4fd0c0ad92213efbcedc83d350a513aaf933a60eb1070e4dea316fca8d314b9c49cf7810ecff297b569977ff7f988fe98392a21950a40388605f97fe1aa110028f25915483a31c7ba1a97e07e2dbbc8a28fa4f2b3b944e3d03cc24bdce31265cdfb50cbfdd89523ab29cc0a0dfd7336e040cbd27c54dfb0cca979ff56e499dba9ee83ce45063f33c95df9c8f7a19d89c0dc543dacca69d078f40a26cf8aaf3eb109efd4ef30f17e9534b354047f24278ca7d3daa5b6701af734154121898bc447bb26e1c394a564d2d60168b9d4476608c6a4e65b8f5663664359debb0bb37ca328dccf158c51dbf2bdf20e3c35f99f7604b13503f8bb7b2f4095a7c66c806030d3c8e4f788ce3129c9880ed7315ad2c377b90d8f1e92c3a6af88e02d7c1529a9af6b703b2070d461c6bc50b0a12092f549e5d3f1b1fe935aa6ceb28fb0929f3135acbdebc7052541ac650ce24bdf1f6d1e4686211a142b40b5aa218bf90e624db83967d8d0e39e917bd29f2cce60b66b34dda01b5083d80ea1407b35f96e4c0b19cb79703630ea69241705ccf9224d1e5222d08648e12dc48f96196f44143002836a2d503622422d87daaf2719ab0bb0d0e66e80dd545439e1393ad358abe33d909f30c249a9783706dac27922de4f67b8bc7ab98b596f8c6d5d6558dea608dc7813dc66b85e6c499f3f5e83aa6abed7e578e8df18cab10a03e547fb1e41b047130e4b2650e5cc7b6a06f8a6030cc843d24d630da6999f6c974d5f6486012d9b26a1f6bad0f141f3f18ca35d58151819c2779a80ec2d05f0f5157ed68571241f3b7e3399ce3ea43bd60e70e968bef8f5a92be33d20d09eed1378b8b50e3009117ea7e668edecdc525383250c186036f3431c9685830ed79c4c8e841e4b58fcd98dfc2a420c5c0906c3fc20e9a5226dc7c0d35bb50ecaa27aed05d185718d0e95e48f363566846445df289be73b140ff027be03c7beded862f71ade7962ae203ac00196b1acc2d4fe34020a2076c1a0f7e79ede17b0bbeab0d916bf874ea8ad1ec2fc4560ef9ee0b594c0c02e8a8dc856ae8b1cb91409aafc8834de65c5df92d488ffe25fc425eea54a41cb6c68cd7bdeeb2aa2ed1978b1c0f22ecf98ffc31317220668d87709e13b8ccd776de3f0b5d4dab68dcee479c8f41f6c7c4d1e9430a681b636055e5edb002602fb0ed35670367d0fb562cf8b7b77ff40c3f2c342cde85680207d514dead6d99278bf1f5e867155f61cd66899d3f4c4de2b251bfb5cc515c0646bb57d42fcddee0167bc5d8a999b3393427c63f3e2bd65eb9a758d90eb69da814284969e99229bf71a4352b32ec5e30ac391710d7dc36d5919aee8002ad044760a2ce464db5efa9be79967edb19b67d4ac0c5efbcd79a400edf9f6eae3a8b88ace07b1a865a39f226941b40570841cb87d846295632fbf4bc8fae410da546a08817b227de313d5503b47b7c3f63dafbe76a1b7d64706e7143514a879c6c023b14abe2d3202c8da4a7b12ccfebc423eac7c63e174edff971e6185227b139aa90eb12ac78639008b32523c33e6a9b60f13cb76a1cc915afe68704819645ccd980a0c338c6d4c7e05d70747fcf19c3773872024074464eff4dc5a2dda74591738af0949992d85c7c20ddae578af3c277e6fe2d8a651e8d7df307816bdde40b5fbd67d6eacde40ac7d7535890c766d8c39d2d1ec50238ea7bc11d379ecfb88b94813b72b8f3beef9cb7e53b338c9a29689851e28416ab2aae0933f4ce2682e981b64a445770579c057b18cd31e89e1374dfc8bcbad12710cbeeba2326cdd25bd9d3bcaa764a2b41e56c898b617e1ca39903d1cd9f9807805ba4852ff184b6dfd2fa08667b14504ea553d7fb517ae3b7cf6beee1cf62b40c40c6a54ca143ea29d1bf78eead1b5414b5d1ac2396438b18714a380ada4c27cd27f4cad0f8c159323d1ae9e986f80b8d7ba00c9292206647d2870996799fd43183752553ff83a0d7a86926ae6f2466c7202e3cc0272493ba9d2efed357718df031a8783360f6479a6c098300655903acbc51024e9ea644924aed3d3cdccb10c389cad9d404cb4bfc7434f1b418f7ce1730c0650d3e696f8d840b468a38f54974058a95064eef30080c0c25dc3df122a2803b01b4f3777e384571657640ba25e672329097a40bb926f6477695677b18956286fabd8152a37f4c30ec7134b62e375616ea265e7b5ebafda7867f763e5e1ff945cef3403faebe5aa5f79b8af651f1cbb29dafb4401c4748bc86c2482cfade99f1b8b0f96793a992e5904bd23d491355d5b46aa7a2c5e9492d391a67be36ac0fc7d12a844a324a3b5e9a7ad5e6dc6b9ed11f13f1db2696d143c1276baf7926e75d934d230c0e24e538933423b7e68c847e4d6a6d1891c182056c82effde47f263b897622a956c69424974aca24126addedaeeddd2e9a3423d42997489fda4704e87519ed82c14cad4b3bf477e8133f265634930dc833fd89219478798d9eaa1834b1743ed76f2a2a6c111584fe487d43808cc0d7d8d86d67b9316d2fa58ef409714b2176fb9f974b12dd334fb8d23b5949283a45fb64d543846a2b5e1d0e7f37609bdf25376a4a9061d0732d40a6707fa08933e94dee787c204b75d819da07987c0aba9b604acb3a6f7d28d05a15dd0d4631e550e9edbc99f7261644538a70befd93ef3bebe0420bbcb1a4b33e9bef6391fc15c0d8e658a28f5815b37c49f5295715b179d86ec2ee9aec57c1bd59c11a033a2bd9354aaacdd3d9d4d375666e39377f112375781167b4add3eb2cfa8188e42b310b2d3945ad69e47c162b98871de81a7daefc19d1d035d3d1e5b9ec793a00079bc5e72bd9e81b71ddc30b8fd51f1d55810c0dda636066ab501d9800f0b68ed0af0160468042f6727cbbbd545a52f7a9a65704d64f321866cfb98179a74bbc25629668df1b10aa3ef06c69f7a0ff7e74cf92b79e6433da9db0d06b3f2a0062d1e2e21480eb105fa0383c1ea070efbb39d6c49e54cdd8a1b72821cc569f4b1b57c7d224ecc85b61d1a43fe99f665db3a1b23433304af2ae439add33a9a5d1243b2ec374f2177663eb8551d3067445ca43322997945219a2c3acadee8aec5c695375a67511f66bc7336bc03a1f93d3ebc10207a54a79999ad8916bee8ccb8f12afa3151654ca5140c155f824f2f7ab11f3959d26fa65135489c13543d551e8288787d8f8dae388c3c590e1ff99eba26f4223c2679465615d77ee23e85a7148c361df26b2289f3170813f97aaafd345d27ff83241540245aad8f901a54182dda97e4121aa7b3ada1a42375615a0f8417ead3ce6cf580f82aea90417edbe60337f258b646338a3b92d4085faebd391a34d00064eaf8880153cfa65d451276e725d2e41a7af977900c0edb916e959e4c3d11cb847661543d90ba87059d9a2c554e778bb295ab3192c567dc835e5263eeb0a0a7768a9a459afb824f5c7459dc34daac4ff867b8d057e9546739962808cb1001f3e95698b409714189beef4f2d097e92858567332631a6f4e3cdf9ae6d44392b3a1cb73142ebdbff1f5065d11e42ed20b026af0b0309435815f9dbf7b56d81d5c69e06525022bfddaa77af8093532d09fe4c79ac5b3e12fbc73b53261e838b6fd36b507e4024c4a6f58506ef54ec91029a609aa8e0ee22304c0f6684716f0a8a2cdf3fe9e924fea3771b1fa458aa6a15df74b78ad060e9faa85da0ac81466d694fc3b3829115b9ad85addb1d9427225c007dbd0dd7f4bbfa5f307641712cbdc36214b2e98bb3941d5c483d8088a45e6d280e3efee4a8e84706c8e9ce7766249e951c664a9d3dbd093084da13b17d2f06affef17a126f6a548710b7ed786eb8291ece252fb0e004d1cbab045281073be7ccd993f7437cac1ecb80662aaf2662d65901d54455c2676872611897010dee6c536657ea6bcc1ddf43c13e6d739ccc4e4707750e3e585629151d39e178c6ad927316bc274fc7e10407c2b00f8c1be74ac4026be6badc95789c25c48ed2b20fd7cdcae7c496d7b0c95bd0ce270f830e85f49cc2ab3cabc3cec082db5b4836a25fef3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
