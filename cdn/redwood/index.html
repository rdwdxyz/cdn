<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f228d8c73d598520ca541a16ab1f9c5b09501510fbafe02422ef05fa2b89bf20530c0c19da35a06f32b540dbff1d4633adc234472d9ef0b67c987afe2d7b6f69eff2f3e81ab6b809e031d403053dd288c888d1ee8ced388669d3312924dd3a70bf20b5f09e20196d8c95f2f37812fccab45318795f37d5999afbc7ccb91871bca61c5eb13273c75e9b7cddff42751b96bd415f036c7d63ffc965e21f0418522393c865caaa0d0b2ca1fb1c43212cc78bbc48fa5378a5868655ff3ecb0a5b8d9043e4d56b4a0135767fe2631f636fc125d1734e7e696041b947f8ae646a42ac14cd8a07dda9c96f5d70902f3637870bd906b039002b2135006fbe2dbd5eb6c3c23910fda5fb0d18da47f422549711b527b91a9897cdbf3f8e8eb9c6433b97e3cea7f43d0ca93ea05be2de081fafe4450681a9fe856af80dffa433c8de442e9c14d8724527e04d006a818b8cca95af2bf3143f2b3e55dd6e4b060b6a22b1e8569747f1fbab7e36c72b2343d37b86d9bbafefaaaa950695f4badcc09af1ac04488688d1c59b66c8cd50ab985766a81c9e6b368fd5675e3bf637d5973eb1bae97f316921fb7c76a884d9a734e3559183eac69eb22af23e13cf6f29e3d4769c35358b6d877d7ff4a3ae8b1d08a5fa1364c41c2e29b3dfdffcc261c7f3dd11bdc1dcfbaa42e169fffd7e14f2d5adc97fa5d61082eb9f43e39a44af6399951275387c8b31f622939c7bff12b10f6ac823db00fe9faef6f1b6940438093f1d0194bcddaaba2a00de1751b73e056e999c26ac11881a2a1bd122e8cd807269d7805935fd3c120172ba116f74761561f331332f35610c90640b5ebe9712531210a2b4baff0082528b65019033ebf87f3a4bd0cb0e29c4173cca3e4b8a52fb2adfc64ee28b99d2881012902ebff5a6cedf23a34544c5f82fad511d05a0e3fb001e6f2eff41409e12e26c92f1b626a21f5ce0d8ee21d4524184af09364fcf96562b56899ed9ff1dc7af19fd7d082213fce7affff9c6b4707ea382ac9bcd8c10bc4cda8b4386438260bd97b2f9870f90e1a02fcb73c17da13e970f6684f3bf737fcac61a299757879ffa3dc541c988b9a6b2dd774f57686a81037cef656ba38aee31e87de36daf3e03c1db16a3515a572475fae7743c78207fdd91259d4d61d066b9e5c22980afe3dea1b3f41c49a96de60a8d26cdc3c6e72fd96ce31323a279689aa805db57ab69c49d0bf3f72b2289444d500f6b4631a500b3b2551137b0b9e3507ac6de9a1f21c521621d6398fc009744f3afde90d0bf045e32149d275c8fda5cf0332046b9e7f969c7fe7778c7861567f0cb735a74f669141e74dfd114e8af6a83ae4db4a4e1c5fb35b7c1e51531ed0c85b6f8f38c29642bb4442452ff7eedba8e8062b871190e1297df5d3d14b462a46aeaba4be95eb4ffa4765678ac62dde19a9fa6ce7bcaf2dbba90ebe0c26b90552444782b414a86f56ce037668e404358ea61ce55b4cd6a9cf77fc7f66b3e686672749febc28c80f5d986d61ea627ca0b7baa5ec195ddc10b65aa389baf7571a18ca4ac32e0af475bc7a3f9bcfa781b18aaf67fa0862d1e0a59ab84ebac9f479ab8ddcfdbe148ed8af7a48ef8006dd4d4d9c85c7d0a8a4836a3f8df06ae56b2b469c25ef2024a74010777b97f7f75f7fd6266e19defd4a425be930db54df7879035d2f54fd9e78ccc18036ade24645a933bf2bf6f931e95f579cbb70153003abe272cf593786e9d2dd893651426bbe3125bef5ea35f75994377f1e810ae8b7f39cb00547f32dff43ab17f95e26d6a2727e3f9361744e100117f434fb28c216d006af4bd8f5de687745e1920703e4c6e03f64cb612594d734da7077a071a1e3e6146eda97fb3a69161792a36ace50c51fe81e63b9fdb0076f586cb3bb7963832a158ddd96d9c75e2642436025d052a6bc0cab7de6f4a856feff3799bef8f3050b058d0db6b49200d9a9d6812bdd703387117d68b4643fc4fe8543d2c75165b90d51e3c514ab31bd27a2b4dbb286262427f041ed8ad030ee116bbaa33276af2343889edb54121e11bd85094c929ef1fa90e33b0c9dfbd71f58570c252a9c8c1f44f2bf535c41533a613c88e17b8736e179b10c8360acbcd75349e929c8200a486114d952a9b55d323cf5465fd6e35be7916bd4756f32e013daa9400ff7cb7a09ed048eceb5b7f1885bdca8f04e71298a47a2b31bd6d08d828c8dd2dce2810ed286e3978e36c44ff338080d124277d1b7ccf6f9266d50a9308f599d11cefa33827120d31539b54cbd2d468824ab96b071c14bbb4259b98600c75fdb8123335e85d19a782a2d8ba134108f08240b333fc9369021185036088629bb7ed1fac6f87591ed3520e2c92d1310097f9b279ebcd42f8a42cccf99ec23ae53d7b6fa7fca180005f8629a4acb1debd5ecfc5591ea90a156396ba3607ee774b4d1bc289fb99256e8bac0e074a2c6717c0cc1bce56d86efa964a6419a44c38f0908b9483a2a2c7196daa0ea9a83ef1302cde0bf86be7636b5633e351ec71a07e66df56f929d30dc5ea70251959bd4ba6bc9ba6b497f6f1b2a3c5ed5148d60a79f4cb26e17a89b0400d124251cb8f0450fddcb16d2a88a305b7e2f696a6d19d3d04d420fab8e61a61a6fdf302a0a7c92eceed2b529cd49f4000da01fc92f56a808deb95d17a1be1048622e69136b33600b71f291f3e710b11f04acf3526407bd9e27fa70fd6640b0319dfdd4addf923b755fb7e25193b73abfca14c0b6e3b44d2d87090038b49116bab6c5e38ca3db7799ee7f2703e71974fb7bf62c138f79f516266f629ab53df31635eeff79621fc4e88fcdef1d15fcc86aa87a10ae1ef8c44e2c0b4b73d437d7edb35ab507be57f3986dddd31773820770ce0f1a00920b028ea3bdf13a35b69c7d9b45a4a83bbdd724f930516bc2557ce400723f4bf9508aa3f4d98e7b9ac786402d4b15c581106fc8870d79fca79c4014b57b4f1df285b7d950cfde0bc920dff6e6b0f72b30c058984168ff283c5da19cbf5090fb3aa01608a827979ccb43e4109b5e67cf4ab8b6e7d18a151ccd8d1d80d42b5f07d7c74a779eccc4935c6a92b652db4ad5c3eb3de73b3fbb502a708ff515f567937cc9addb3724a3a62d417bb6af9008f2641de05090100d8171077e6a18618bc434c6bdcaa86b7aa4675b2b2f49b922cd77dce3f6ec89bbdecdf22a3b16906cc4da8abc9f91878c7741b3f5c8511407d2a032f1b12800f88011dd92873a1fed3265115049d14022cf101d4f437311ac1f448fa5c3971eca0376678661673059f07342487f32eb870e078e1f9498d494c7ffc6413ce98a88bf161649bb4be9640791af107057be52d0d71e85b90d8dd200fd5fca4a2436830c50768cf340d16108b62a577998ff2954d8a718536122ae5a6360d63961e02cfbaad6937c40c9351bc92dba7d06bcd65e2457ebdd90edbfbde60916942eba700a7e4403f58e4a48315f0810d8cfd4bdd99362657f0a89342cbf89019a2b800d8153818755e1a91c37448e5b89d91a977a1aa4701ca5e3aa5796d42823801db55e04e54d82b0c7d2b3f1a308834b5da126fdb50fcec4f9b7aad9634d0a9e05c2635bfd86db8c4a5c74add53d80e2c71cc7bc83e89fa35dd8f027c82e48069a11c568aad5ff164662d2f9db6b49d265d7776f5620be2dd443ca56e06412508840072edf796cb65d034ad691b24a18d460eaef36e0ab589026bc5c039b7447cfbaf2a95a8b32b47a92fe6dc283fe732e53d6f17c02c2c333fedea93034b16958ef05d8b69e9931a77e7e45511cec90610843fe4c1ccf1bce210a435a14649dd6f84fb86a33fa1d4b90069b896df7af60945c88066abdafdab53855ea79994c81d30cfff9646ffa04b3ad23e5e9acc11088ff1aeb57615aeed9b9e3eaea034221c88dd68f9af6ddaa6aa3ba9dbb9c0337d6e7810f4781bf306778fcc8900cc0ea30562d71edbe4b77775d3e51b64b5646bbeb06674375ec4197345e2f706d2d3a073514c59b6f90c6fe6a286ec1c045afe4a6b4aa4c363dec87b3e7b25fd7c2fafd7782fb999c4f5b2f665e167cc5ba9faaf25f3b02acdbd5e6c58271b19cdf9aae890443793acdbfbf7398d0579f45a11799868352f8a2d7603f7381ac7299b6b0c81a5849553d05a67365bb78d38cbb8e3a084383e507b62192ac40cd67e60857518f4f23c07faafcf2dbac829255a942c1bdb621a728e5433db620c9ed95e7095721ed1f5f93c4d19f1340d3fbce574352c7154e6650dc9eabcbcc931e9e65759943253230daf018dd78abbf563484051c38bf5bec03bd00ddc515f9f8ac3ce3b241a6cd08fdc5eca0db1ac1f5f287ba166c68c9487a08ce7dd8498279e76dbe1af84c5dd5dadcd5d9cee76e6952ddbdb2e01de12a92472ec056eeccc28d7acc9fddbf9b4bb75512a23594349b07bf19ecf87eb99e7caa33f50c2443d39aa50376fde8af1fbb022ae0687c6058b05f70cbd66c73256f1bdf6c439252b7a93a3912cb3a6a9a3d703d4b4cf649372eff2f7add89ad0b7508f784a14e588f89a4644c7ac0e4107698548e83c79d2072e22c910caa42edeb7c1a61721f44c81d53f74351544f6066ddf1fcaec1638174f03cc0d2039bf7971bc223e48a041c88afd6bf2228361c45cdfa2be9759781fd125e336b2e0b2e375983802b2383906424bdce3207efb7b26b9ecd3f89bc3eeeb21ce72d30bf54bc2f0fe7ad0a9f9702d10d7ae51769a2fe8c8f610c9b470c3075b46a5741953b4e7e48f009e70c5a6bb592c1c1bad55f85012878c0276ea7e3a50311932f792b32d88f88436bf29752289cee9486ea55d84b1f88ee8f9d936ad110ed733b882a470d853d4e7ade48f5b97e20baca21358a1a9eecb9f7e8f1ba711f63b23296a385bb65bce194ddcc99d30d7cc4bfd84d6087e9e479b462ff02d3b567c009140cfebeba8e5c41724e041a6e0a09a38014931aa8cfd13d1230db3a9dfca0a8e1d57bd157f1cb9c8f15386825b70020a2ea73aba71106025c16c44fcd8316e69c8a834ef0e8377b0b2990b82604d7cc7639f94ed64e301101ce70fcfd75ae18979cf210c2db320d73a16b547bb5fcb67f2094fb6907a1f2c95482df235a6ac10a0bbf2d1441f2af9f4c09eb667e6e65fea32eda9e55d7f5d3b6f68ebe3e5d8773e35e33cb81293ebcdd14df536aeb0bbe6dcdb5525b62081171dc2027fb72cb92b16748f4930394e1fd8ffcac004f3014ca15475652728a2f6e0e92ae8ef1a5f31d2f54399d1db0ad7acfa28b92c66e66d707cab6b1e60db43ecaf024419c6d3b38d206b5b7a904548e4a16a83feccda3ebe620a73f93dcf5f27d1bfc9370383bb00fcb9555fd0d3ed82b235594d0cc67f635429cbdd5524abccc2eef7b54331d6f98de90d94d9f4e9972291f8c74e7e0b0b154d9c39611b1f6613ff10789a4257e2c73aa52dbba9e4d1d99f889dc5de2ec568cd413bf752e9aa7aee56953c38cda7256aa72ce6e9479e4140f08581d0d7791bf51ea0e41c15fb24462a010ae1817ebc7df3a1e369164effd03fa85c4ff587795775261ab876e65f7424ae04292841f03981fe699a4dc0be24c3f011c731f4298936d0bb7f3fc8ba39458b06348287f91f278f7757ce0d1c5457059af74c38942d07dc67a917d9eef6e5ec504c7a9d0456ec3b3d4dd6cae53eb27164e49ea83ebc12cc23d11cfe21b430f31b5e57b039b33cb0418c5569e31b2502cf872d1078c27f1d201a36c258813f1b3f10fce20f641b08039736cb89c824bc3dc3e1afe7e6bcd6deceabc6cf9b80a217974c860e00a67cb5f1c506c18508162979484a62b7862033914b95824ce31cb0c521432fca808acba3c061a5450db1d22fb346d85a99c0fe6889b28ba870a706b05f4ad6d48585423a993ba4a2f65f9e4ac38f927a70f6768992fa7c13de1a22a0261fd1e702c54dff0f0d5179bdfc8a4e3f355a6188fc069160a3cbf99de8c7f0c2224f42f0083eca183cd78593c21b5f666be433e87b306d1e27dbec5b2eebc4f36ee848cee8519e65f87552de9b82a4344db198ca4278c6771a7576a042c2e070185da5de2eda86bcdb166444ee1e3a66b20eca4bc0b7cfec6deb95905af2c1e9048343d8f08f3ccd05bc1cddb0f6434db51635f48569d9fda629963f4786e51dfd3c1fd600f8e4eff5b2567e8dedeeb1e2c692ff2a971e431985a7a10328deef9013149e7c9167377f6b953eebe06f924566d11d6edfc380537013291b4b29b3e01f41086e114410c98a077025e7e6e549cc60314091f406396ade6f27ecd00f5cc2de3031deafc9759b280ab455c99ce1db0a445ee094b876f2755a2e7bf8f9df47aa98ee269a8f0e650afc9da10fd90b752616d543ed05b831058499d42baa2e5b44597e98a48d324f4f2c415d55e5daac8c2a504459aa991a6c3b700c2a3a9cc291a651cfb14a3eb2f0bd03cdcb8ffa9b25232ac59374b7c0f2784bcc6f951ebe2acd61945f18373cd907427e526028f7128dfdc67e24d9649fead71d1749f5275b937d0ba6d7c600d51eef90df7eb1819de7c2d0c585e7e3bdf6fd9d81bdb96f4517815399b84cf06961386521fe78db3199ccf94556aa95f5c44443aebec745418018447e1ece47b2a8bfab3eaef65d7aa7bbca25e274a86ef8d9deefaddd037c112dc06ad26f1fe8cf0217ef62036962b56514efd88f40c80ad6c8017fda60f54717bb83dfeff441c6ceeb22448c0e0b48b1c3bddd5dea68ae149b053c70efacc567d1b1500dad33f30e0d780fbc5aab54af46f69dd60ab00ca2736b3a68823989ccb07c678a9cba04122c1963e2462f48cda9c476d308ca3b04192097b0d29eec885db60645db6338f235889de98ee1e852e387dda6983ace2977b8e8070908294a853aa67b4942c3e2fd7b600498a683c6a626140da3eb3db9d53a21e9a3ae7660e4dc1d2635929579068c081f1fd757e802ac8adc84b17af79c51354dd2b22f9d7532f39f441df092253cd7dd42083b67f0fe6d672de8df77656eb9afa3b2744c7c1d7f288920ccb8291dc6331b6e79c87aaf5b1bb7e205318233f07e68621f6a3832f021d5045b49f374f94655a76278b2af63e2e57190e572ee619acc4f1f4c4d7dfc7047cef834e7f0d28ab36a6e21c8e1d3ea0fba961cc507e12fa72d341b590e9ca1e779a3ce51e6942c5f83af40e6bc44bfea7de2b9039579a1ab5f6f269acf78eedcca647c6661735def690dd997a3b5d57954636539458b0840b42b127c33e56db4d0fed5be6f06d0cc23bdbf0a6f27b6444fc92b6c565404e21c82e684eebd5ea943bf504c08eca712d414089a038794b1b7c0270f15c007d341d3d4edc7a76a1df631d76e46b6415e58861e42437770cf39c8e7ebfb4af5b005befc6d762fcb7dd2c5571232387f4cf29f2618ebccc310a5fbd61a71c19e4562090c6b79d34aba40a52b766775033a987c4c230c04269cc41761fabc0c2420e9b3a85bc383798bcebcfcd024d0df1e9043bd6614a76a8c0b04f7b1bde8d9d98ea3af56102545e1178eabfa2e45370471f572417f80949bc7927189a6de8abb98ffe2fcf56ae342f4cd449612b910525b5bc2d7ed9ece637e1b6fb169a345c270a0f4baf7b2933ca44bf85581d97c3cec6e80638711cb2097369b22b0e6179ab0e56effeb97f1790155087383824c37a546c798b183a00f2776a70f4f11d48c7bbad393c8f315c2126c9a642abbe7abde16435d6f1c816389683df02c7b31bc73d1da72526d23e590dd22b78707346067283425719a0d1ceed84c53d0c7a3799b3ce158902988d9e2d12f2f533558566d610a09e53ed1b5c1171cee25173515649686b9ab3a611c17def45df8e68f2151c6caa44f4432883075020f14e33e338f936355d9af84609e59e863e7b49e21c2d31c220016d3ecaf2c17cc1357deddf85929805b67a3ceb2e2bd9886184bf9cfe540da613ac415b143fefa301691966df0c6584c9b3afa8dd8513e6fe397e637adc1f94f2594d752d0c808801cb8439b2f9ed0d9655f61d33eab5234f0435db6fa26dcbab28d030e719494a0ef71261dc431a0bde6134d628ccf30384229cf4abf0f02791d59c291188beaf971cde975810bf22943d6ffef39ae8cb1f5be787789f89b9cb9fd5fffd29b44a6181e0e96218d66d959d5cb6ec6f48b6b2d944f4e70919b67548cf26b73667bffb83bfa26796552c4df8e0acdb7c26b08ce49f22167116298bf9d4c31036c05414115d9573f0a19e94695860d8ecb06d222b6bc2073047a15a26eb754214032b9880ffd9708ed81c5fbfc2651f6dfd0c6badfa5b6d3e26e01a440acdd2b6373b41a5be72bf07cd3e982661aedabaf1bf85be0a3a8b107fec676a9308ef095c5f928bb1ee2d53b22b7536e7a4e1447c80bb5ea67ad6bcf1390325f26222ee28906ae107d2b325ba0f7696776fb32be645a90f0355dbd2840456c1092c79d45a675ebfe489e6311ace1b31e50602c3794db15c8a34c49ae7beaf2e40ec476241ad75d60770197dc990be36d42f5463ddf40b1f123715d475bbf32f8d0949859a77f8665f0db99c101002a01c0aab6ec7bb634956f2f0249414aa1cacd80b3846f95fd0dea7c0d4dec54b39c7497312745a2f813d2aa08c3811f3f0e1bc4e064da20cc17046486908c29c9308f67dcfb767cb48fe1cd2559e785baa25f0061317752bb579aef5fde9b4c5556983c050ae00f1fd0c4c8c482b4048932d6c727b03a461dacf6672512a08f6c7a4754ab4eb5c03072c77ce1185a34a4c0203bcf2a09a87f5e9a5f48f2ae8ad35602ca0713fe9d542318ce5fef4f0f10651e7d8cf7fabbd4345119d75b7a8059f53ebb44e4487db7bc6507599e28b61f38ddfa2945f32d582e4dedcc6df6aafdc2fe547f1c9d44e95c0c8cc93943471132596d33866f0d1ffa4df92d638ebe9e95715f106af47ce7c4688bac5b5d0528486c55e9b5baa6647588b073158c7e4af1e1bb0f2aecdb64947e154387fe80f94ec93a276b1aa471685ccacdceeb181ff6a120c99b170213ae9fdab7b23548020d164d69261dc1471703a0d43d9ac2731a82b5ba1b2506f888bc9e0bb01800d7b309e7d22abf16697092f412dedf90a9808773c80719acd6f6f3cf0776616d466100d5dcd8b6a9168ec34f68496e67063585f66fc2522f5391f6c11e058d13d9d20012dcfbded5007790e597aa3e78e9248c3e6c8dde7bc7708559efdaeedaaa2d3f5dd9fc31bf20d569fba1d18500dcbb56e55c2cc89be98b0a02cba956f1008985c4a0bf90b226fa62932c746322cd2afb1d300e6f72639642033daa875edb6bcfccd48ff80d8fad09333862f2612219dc77b0e50e185869a1a2c0609fd72861675cb24a9c3678766912196f69bd24708278af238f792f174c132d3aa8d4cf1bf25eccbc46811fb8bb940e1114f99e630c03abcd10b38523837c0c58b9baa6cfc27ca17adeae01547a68c27294a12d943f8d7f069ff8242adb6ecdd49e5f4e3e127b4e6eec49e494936eb37a5883fece79e7d6dc7118a24043e550c108fea5272c4596ebab522bafef048ecef44a0ee54ba1c6ffb01afdc568211f4b9bb4cf0811646a19650af3e6f7bb7c4ece62e9f678aa17d710a1e12c92a8ca39f3ec1a6f921df1d901512a05c7728eed18dd27a858def0760ba10e93d99f5c5af4244137a2891c1f1f0c899fd5baa7f34907b24c23fb6f3a32f9f8de41fc15e59dde2647860232f93b16ff2282b232be45160d5f05822a4544ef7ccbe1f61818b1f9021f2a2e08d5f0cc0dc1fc2d9ee5852564ae9fbc16e8e889b2d6b9c6b37cbbc525ff38be1106c5cff5a200a8f0b1e8dd1f6704d66d1f33914c7c73954d768c9ca475633b1e476673b5a68953a6e89919bdfe5532a1911183bcff1d04851512b694837e3be76e66550a04e4bdbb8f31b899f2becbf015a6a0fa1584487d0f8c3154ee10d3c48bf25770c61ec333902d4277a47e9a9a36427511b17684101e32001e4e042de9ff0b7df8d6726fb2e6f87cf34e5119cb2275bab4737588f74375265f2175661d860c65ad761a2b760449af2f84b11db70b0feff91d6cb936fa0aa863fe78bbdb309643fa49b14c56b930e5b8d525be3960c583192e173154b253b2b5353802de75a10f9763d04d87932eb591fff41ad20ac956c68f4971bac192eb00fda9189a41c11c00dc64ca92e3a7e1a670ea81ef040a4a96eebedd004ed393d00be89c9fbeb5721b083c3c139cf33ce2c25038331a9eee05c01f93163ff2c8020cf6a8418870ab2b626caf44175b5eb00da67795b556e6ac659dce2db1ba90639135091031a0f8e993a67268e0f21817c36d6186770360a4961263609b245f101de152d74564184a52a59ac6e0d7db55c35647913cae16c3334d0323e61db44e97a137ee66aac2acedf15dc21361fd179cd96deff05a9881a50d43f7de8e2bc1cfae9f3faadbdd6880b4a60a1780df7e4261f9e13f02493a3ad09a86f9738753b78da509f4d6b97fd762116973a6ae5eced7fb703b98f6c90d40d199f0fb5fe384effcfa3a1a1c65125e3eb8c7778262197b802a310507531a0526056366d779e68d1b524f74d4b9ff59dd7d8b8c293b2142e22318b0045394d6bb838054e209257157b07892c42e68e752443cb043b41d629db7f674124591fc7cd4f5d2973dce52f1c1aac14c12eabc775b758a49e1d749f3b4ed2d4abdddb034e7533d0741b832f1e4b93d21b98a98eb5cf0feb6200a1cefa34e6da7a4d29f103e950e42b69037e2aee1f81955c311719a9fa2d24194dc3bbf182a2290eb16c5f31ad38fb7f9f709cdc2750d22985cdd768df93203b38de4d832995bea7a3b12d00d5af8a8d363e980dfc742d4273748f8795b434c4055880f2d44c5121243514d50f9653d65f1d96f002cc8ea32e0d372e5da7842cfcf08b748978e28070b046ff9cbd9598aedcc9bd8846da1c3bc41a4a06e607d38e86d11cdf7cd5ffc4dcc3b80f8ad621f69a641d913dd89823bc40ee2505b2aa6c12f053ca6c3d605b33588b5bd919a0b08dab290869c321cc47efba6a5dda75c096b8a05a351243830b178bb938a178393eedf6449ba822afecb2ef406015ed4b23803b7554b9bb5cf6ec7b6b4d541c195aa86a3dbe36308bd9ef6619d2d8a8e69fde639e88c08170cf9e4dac4385b70d6a2d45d5163b6a7a34cc639d4454e4b33be8f4f0d4ffccbcb650df59aa6efb2483eb0ad8492732966df6b63116aa529c759b2638d66c844352257e2a0c7d59398ffd5491913c64f773e99b5ef9ba07bfbf21e671dbf4ef054417d249b86fe39acfbef63e39a2a5bea4dec40fb981323800ffe37c172de1ee719aab89af492391c2298f6ab8658330e7b64470ecf1098cbba096e1d8e8d278a911200954f2190bd14e9cc956f568e066b84e8861422f3992e070d51540fbae73b9d572c083558a2799a4eab9a464053f81566053dd09081df567e7005c1da65f7df568f2eb1cc0ea937aac278d106ab5faea6dc2d78f39d618610b5d0b99425969dc909dec94e5500a8aa815539ecd105d473cafa122602bf450c9e00f538669cccaa1fd01dfdbdfb7684a5adbaf7030487f2c533576ec11383e5e9083b44cab018f6e4e4d9a093a51722705d2ed1a548e231d1f0cce528f7505bfba92077aa09244cece1aa3ec10ed72587481075f6a5f8c632e28f70bf3c5a56a8a69fc8be5fb298e24fd9003d0812e65d4c3de07b0a2906c244fe44456d5dc776670edb7e57169d7466b559433015fa10f72d795decc6d4082500e5d5c9be169dd62d9e95e73f89bd0d25b2a9de80429609c7b4d1f9e26719c85863aa96e97e39170d74c2522bd6ea03520df9d94dfd8444786778e02a59700c79aac59419022d674eec4b930c15e5f5c714b49b8620312444def9d39cd7feeb00c4866c350199f3a5ed6a63df1a385598edd914d8e26703896bef63b2446e33e9c328ccf9eb7344881e31d1d60f1602923a8ae6094bb4f0bb50235231e77122f04b3b0189b57390d618d3d8a871d498b1ab20d724a1b678171e4dc2afa9f8bf3ece41267ea6e556e01cdb2a519cc08d1aef0fe401403b3d390789b71b5da9f891684bfaa45920d96a033d8342976766d66737685b57de0556f9c94f45aeef54adb88371c06c72593ac0c10fdacbe00af150e3a6f40302d884dd9b8f5f917a25353cbcfd319003e7b5ed280bc074fdfe628109117c532a8e7f98f1204f567f40023eadf978cf0fb59654ada7d3be0dc41a2386cc01eb68f40989725c7765e0b36addca6f764246b1778eb6c6fe77586e5b191c98b9c4c1effcab9062e12278ba9127c7069c74eb7dfe8fd6287e66635f2096a7e77d00154b775aadd9a1589b5bb44b07c03a1e92b937c73b7033663d4f05d628582a9f57693664d59723a9121754d3f67597264e04c7a29a0cda592138217facb6e2d36341ee336646251d01daec149fbcd3051f6055ca091ca6c8dca923b23a1fcd600ade5fcc9b40bbd7772b181491e0b9ba06d286862b73e609636b4d132c82dabd34ef448743a180c17257a54d5f1d9c1bcf2bc05cee0a666c3afee5d31ca1d867f1bf6ae132bc9827db02bba23619caf5e8510d46223f92fe874d7d3aee3f3ed90bb375c556742992408598445b10f846365248f1421cb799d0bc282ecee6580ba0c96dde98050f38bac890a0084e869f4bbe22d44837a2d0371b07f3f32129fc93d8a6bb9aa715a83b87cbfa655ff820323294d0fe7a6a522459d5f1784f052bc5f8f93ada9730a0825a526226487cd7cb8b4ad453f345b6cefcb1b1cd8e800d57769420030be2031a684b65c9c5b31f92896b90e664a443555e860cadd082d776bd3f8f7b7d5eceb9a9f7bbea5a88a6460c1aa59e1a146d1ab84e8c8798ff29888fd82ef48ac3159bc9480cc24b5393806368b11ec4fa8d9c0034463d6a5bdc3ee6aa79d393f6898483427ee5d94a157c58c571ea80cb0f0b3790c012566949a7b3cc2e88d4a266ccfcc3b4eec150c2e34933f18f28980a12ac75724fee2e78cab01d1bb9c4444192f460818cc35982e05014dc079acb52cb74d90a8516e93bec8f9cb1346f536ed84adde91906dcaca0174ab03886a7fdf137af7e0596a0b01834f03143a8b8315a6976a65ec28f1c6ca75fa70a6b2d0e8eb80e7ac04cf7347effc68ec0529e514e3674b3afe61cf0045ac9f10db368af20f1517dcf7b7361b3e4fec25db5787321d5cfe7c044845f66ee672caa1039034c539bf102ccc119e6b5d26dc13d7eec600e4b7de53a23e58a5927342916a88c308bfff151d2dcc3ce5dafd95ab2b44e0cff393e3fc765c6c9a68366e6271aa9030830a3b0e86bf170a7a8f51512721fa580891f7e2b38c54b4c6077a901e64bf5db91c0add6fab4d4089a859aac06b5e8dd3c6cd966487dbb5ce3b5c79ba485320008cdedc842ad8049534372d9bd715c5729edec7096b7e95968a7375c7e106e645278a81ca76ddcbe6ec9f7cc58c0af5a24d2f38d145524b40b4ad93df5478b5950b2fe9d77f7dd1636dc65b96667c39cd0f64e5f7cc7655ae2b160a36ac3aa9eb307e496272a3bd96585ee2cce3c2a4f3284565e692a569eb9ab75ef5b5878774d4869f5a476255e2be3f2cdf51380b8de68345e30bd27207f82f2e8f8789a283777b57a2fe6df79bea327368f427de348cf30f8e2b77b456cdb3b30d0776e0e781656e5acddc7ab0e1e63ae2b8fbd53129d49b41d58f3942c47cc6f00eeb0c765ecb3d9071507ac11d7bab9ad74541980b61f83ba49267414335a9242813fd0d3f47e0caa405f29c24c64322ac3b7b4b7269a9b99c80e66611ca4a606eeb86a06b74e86513e7f7e8337ec7c09425d347bc5bed2859be44149c94bf8254ce429c4fcc378e18a3662394eb521d819aaf230443222bc4eb26800e01e2d13ded34e6ec395c801f7d44f1f03b1d509ed16b30800f0c15b23443ffd14dcd992b99fead7b7c852487fa93559ddcf52a7ec4025a1b6b537b2cf4a8d8150c1d87388a48621830cc013bfd70aa2b088798b29e913f00456d6f0c1b2714a6bb00d3f1051705304a51806ef14f1ea543443747d4617ff3c1fe86ab13f3fd78e6e133f48034110910058e4a4b76083627be03f06422f75c047844ab285128dbfce9262b4d69345fec743b158c2bd49beb293530b45345638774734b1c9a5b4f2b3329d12589ca8a2bc4cd32e14edc39ce619d1ca828b97e7d7c33650d652c6e83a33d8c61113eedc89e6d759237562a752ed7054b2cf7b723d18219cf751e36c104918f53eede4e0d500f3a11d337ffd8f8071f1663537d25b9f0e9bddb0eae9fc830ce6b086bba698f4d6833e2945928a7ba356cc8281d3263fc3ea83f307e1956e8887bc35614f543241b2d0558f01f52b654f98e2f0b9f85245632df7aefd0ba9b6103146104349b110792e242777f16397459cd8a6947e3ad67fcc1fe99974d60c046676e75069dbba9c12fb5466129215fe97d2cbdf8f1677ec93f2520a3c9e4a458a397ce0f117e55652c399a08348ec7d8e4b7f9df2087a80c8be4210ba8af2102c38ee2ddd3bffa2b7f2357e7abbb4e8c91e3f8a54fbd7cd4a55c25b32d7a4dfe8e001a02dffbdd143e41ccd6d617e8ae6638c0b79ceaa368aba8b755f3deb7d0242516f4c4fe8fd7af3561e146d6499811270a64ee8dff444b02496f4b331ba3414fdf5fd8ed6e005c830601da8e7da66a9f33e6d9b111efb775dbc2c1db1dec3f488b95dad1255123b523d3c09c2f6a5c534a9547b57e32bc7db6c1e625a94120e9e6655099dea58234437cde296565985d9a4af8aae1aff746fe5b54e5b7b066664e865ae2a8fd88df1cf9c22c8c264b7fe54913ae257cee268862e51125407e3c41e35f2f43df967d445cfc24f268fb49cc930ad359a24e191e668adc5ae85df731926877e99c2604c526fee36bdbd85ca0b2cc9d612a9aad021ac5cb2d10edf308ae0cbf97b5195d026f5e078bc19269f6120611e08c6e08c12d4511175d03ab11ca9d156142573f1e874c167d02af1548cae3159689620fcee2479163686ebd2e0e4d55523156b10ca42dd9213daa06bdf174b39a042a3ee51d3204c0288e758244f93d956e03d6b969309727f68dbefbc5793fca9de1e9b38d2e645dd1002791dd637c37b7da1fbc745c6c663fa70c63c27ca1cf921f71ee33c3735451468c05a733d2dd602f1408454e105856e1bd5a7f6883792c8cf0dcc59ce3981956db02a1900757f728caf45a5de34ecc09b529e022f0c13f3ad4a66ccb7c835f169b73d7dd0b9f6d91eb0aee9908ec32ec77ec53a28f9c1b6ca79a2e0f94a36f21e22e966c0f01a0b83a9ddca139cbb95a87cfdfb7d1e94387587701f0ec96179f6b0b78de3db93557e0471eebe0814ade56b293da326035f099461777fb1d13617206a3d9135e770f9739f432784f4ec59dea9117c6bfe8c1c9b3b7d07a4fb0021f4ec52df4d5bca1678ef00869a23b8346f9bbba43f5e954122dd1a53d019c6b391217977bc54d98dfbdaa972ff9313b2254b620f5ac2a463ddf02dcc7a2f3c00b152f4c59431b77da846ed40d19f4a2923f26f2cbf7228b0b2da67d22eeb458fdd17b7d7bdef3d95fe6b61500e516b9d0ccd7faa179e1043952025d68de37b1c5d4daa39706bdc8bacb3e25b49ec83191795fcb470db380eb3d72ddd8341f868ab103ebfc655d9a1f03318290ca9d1ba096d855bc7f997a0b6c1c89e529e82403ce9ef54e9e4b2f417d71d1dd3a488276b4a6313d121ef59007c5b72a4dc1456d9271dfd675ec9f636e1e08bdb0d9a1a4fb77945bdcd7be8d11856af5d55831d714117ade29f55183f9a8d0ab4090fb7cd3c0db5b37f43f1b08a4e7b0a82ab1493854379d18c4982c16a8b103e7a776f7df7f9da3c1f68bc2d7c19b58f61a95d44fa0366a108eefc095e74d7e28bdcbaadb17a0951dea8a44205b87ae005b562415d8245716e6384db3adf26bab3be09ef6d05e86685084e7e2c2b0690a0268e442019110804b5466c1b86eab61841b429912d19f01d17bf6f321af13f043d2974df84d7c1f871a8f300eb6071c51cf92d17677eb6ae54634585519b5437c9e75c57bb3ed17549a4df611b474955414acea3f7e9688b844f8b5a792a9c3853e77602b5be64ac2a5736d847ca104819ca545cd808204badc49da43fda4e8ee7a189307035d94cd595a739d8677c5ed43165a104a84f3e6eae237b8bb28b594c72691c16dac764d7fd627a318245d8644063df69b57fa46880f7f3932831d748bd8d5afe0542ce917d9fa522c92527936efa6b29f7e9697ca48980ccc1d11c9ded39fdd6ce8e8387280517b2449fbe9c62342abd982355d4c407278d15b6df41969e24ad9a41148b1b972d40cf9afbf47fe8894857c1ee1afc49eb7c86ccce798f57e11b90b7ba776b8b5d24d6ede547e8a46a48034fb87706b1a0551ff4567222789e2815ac18aea23112e3a7f9133d16ca166ee7a91121df1b4ca6604b2feef57d1ad04536646e615f9765aef0e9d08113fea7be12e540f011ae97695d874be3bf79b004bed449ac8004c3b8ad6db4ec6bd2c63f6d6cb77b088fbde0ee11ac1faae3eddd1d2ff537c40f351f726d09eb09d6f2b43a23e38559e2d3741445ec9df9c64c86320514312b93024f9cc48d6ae3458ca26259ba039003bfde3fff917e9e6861d7b12749315b331151cdc986ca16f95f823f92ca0b6aae75e9ea5103b2de423b893bc7436affaec2369d57fd1ab7aa8ea1e36cf9172651800c07ca42896922fff72f05ae3192fdc9c06513fa8ea0e720f952c003a84faf56d533cfa3b31dcf2102cf43276f7bbfeb3a1eb3bb7c1dc9b87c6576b234b1b7307ccbc70029a9f18498e8ed7f98722a0eb579ac3b960850f1c3074c11e982f1b450f971780808ad64d921f7c580fab8e0e50c05b5bedb3cb4abe5dc01e84cbe8cbcddcdb4fe3767a2853ee63841ac55b3c6d03fe1ff3e37d60d327706cdf11967e7b448ed17dea69ac4f4932051d83c12bfbde7633c00725658ba11f5305510a425361d278934a7bdcc93a0905aefd8adbbb9a5cf62eea14b7e922095a8b84385d2a5dbcf69baec11ef6090ae025ddfeef363bb43b7c560547cb0440df219c8935271e4adb5a41d36cfb72261dfcd14eb949bc187bcaeb979931eec400a8cfc73852f793509fc1711a31315db5fcfbcd313d52ab40839a24af7d1bd656c6f693c5cbc65bf0e2a535ff9f563328aad60081f9a02d2a0f8eccd333fcde11b5075d6638c98fc5b1d6985d6535c7e6ed661de1db7206072843fc29d49fe9b0bdcfd7d663ccc7f4524d607c855fe8dda5ca1494c6e5551d351d05a0dee726b50db3867ef61b8590e9b2e0a0a223cca44f064506a4133ce22a906eb802f5b3dda60a9099f7d70e6bedd4077132e29889e560edb06da0c232f548b0a49f52ac67db657bebc9e08fdd0dd353455250c03b08c1895f465885d141497f7bfcdd0e99013f4f2726339b65459f16f2ec3704fc4a1bd8d7bec476b25471d1e05012d8ace5054b783199835f2a930d7252ff5fb738a5116c16317476784e90dc48049e15a6e73620d818776f3aeac83dc54ad9d316314430be5a10351da504b4bc29237affae3461aa76b51b3b36768d2530a5e3a0ac2e90bd75e7670f573bdb2acd9adbe9b1aa2a530f2b5115068fb85ca58fd2f88d3088f83e55e0b4e27043888354a16991ede7bd84c160bc7c113701aeefcda91e7b3984b59b7252a300c6aebb4ffee9e4f0569c547cb23d9549bc39dcd99174fdc6eeae124daf89fa152977e46cd9ceb945ea6b93e9be99ebe6ccf7f28cd8ea8d5cd272ae1639ad5a3549c85c44031c8a5c1b1e22012692d130cdd918776914c513ae969b8679e61e8d9966d874499b83bffd5fb074c7beedfc68e28cd22f6630142c07befe16956e4c958e41ec49946af1cdae917af2aa7e1c37513e07a9d85f4b13b4c28451ce6d507cb691c48493aeebddda68","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
