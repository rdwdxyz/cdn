<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ce2a2ce59fc6455e7f05f8ce1f5b778199dd345e5fb44f44f8812a4fedf05fb7c5c7a369f62811540016d38df55993cd9bcb86190f02a5d5d5c13fa65a278409d891fd78ac08edab1248d9c3d18c046bc569c554487cd9986fb95cd7683122f70f078501b59051b55494f5a1c468b2e0533e14bdee2eb69d814131ba0ddc0564ec93582e789a32023de953af22e4dbf2ebd22647d4900484d09c4a2bd3cf151188fad8bde27b574afd7b608726bc2470884df24d743f5417cf30bd07e0179a7617c05613266d53e83d0b7f0580b8bfb9388351313cd8604e57d53f7185b309b33ad3d75ae2cf4b782258c08ab85b24b8a667e3310349d8d28596d2e8134a1f8a3961343f2c79fee64080cafe7470866cf65fc83b3a1ca052413dfd7dbdedc4169a0154e121069bf85137a4144477f2887fe3c1b49c94e23fdea9d581baa36030d66f1d1feb5fba48d39123b7bb9538a54a8970cf5eec3ad7f50f962a586cbd328159a416c188212589b7915b16c3e555055dc2e76d3b7c98b84b98813b3a81beb855125b67cac9b00dc7dbe374789437fa12f3e739b95be3925cf812e5fa7449d301e2ed2676aeba07d60f5f46173846b45c3f780b54f1b813612398b5a5dde162c657f54917ac92473292493618cad0ee2d258d926a46bb9d561b569a66247ee9f7f002d8e3521c1e6ffb6fa85ef88bf547ee0b1cefb94b498730787ffd2e30a5c94674734ef6a26f041b3e30cd8f1979d367c2684d337034b954e40a3b7b95488270a13698690342ceeb203b6fc5aa6cd93ed84a03e1313ac6f13480ec0069d3a05806e00ebf4eab745949dba4e50dada51fb9ac419fdfaa910b36c00986e012dc1e83574c2d055c3fb694c0399b6e906cf5e2081503b8f449511e8541544903a9d8194fd341a998b391000113ff25947d45ffd87657750bdd9aa04766ab9358c092e965c665942ec049184992e5a3395bc4ac84e942456e2901f751b69da5ad0b6e6f1af683c8da68fa926b51161de84325b0c5294338ea1dce9414d069e888355b1b86d2f0ae106abcc2a115365f91b1c859e4ca691b81f602ae2232924450a774e7af3edb0254ebd1187054977aff07a11cf5299faf09ea4011e7e51e8862e8ee51dd3a903919337d203d60fd519c27079d0c3699675bc722ed6ea7a1baeaf36ad55561af93b83c4b9da8b7fbfc46a26cdc2faa07c3e9ab5f626a6e9a473ce6a27e6c095a60a76f9d8b7db236283dc8c01665102bc5ba863ca73760492e75dde4554adb87a8c6208559f20e5efec5af1ef1abb4f45f988392ab1a5ec2869c82750c1a1ea016122d76553093c9ea850d7edbb44954db507eca6a0906f6f6fda3b768c00772dd213e75288dc7a2e0af76e403473361d1c95b85127d896764b5cae7ce0758bfea7a393a042bd26f5c9650a33974bba43e26b15587d83b70d5c053199d49501f073589e8350483dd9ec9de072e6cbf1326d595c00cf52dbe5b7dbe0b397bd7f0f7dcb4b718f65e4037919f9c0575901d7c9a021168e3ee9e7cccbf34e3c5f976e548c66279f19bd9f18cdc367bc1d7f3c76a3ab1ce035a67035e1c6b060538e5b80ec7258aa8f1367788b429e179ad366215e58d7ed81ca8dae00161f7edc010c03a2eb58e6b483cbe5919fdb91bae4f112e6c3068f6a3d5bfdf85ff9140c609349113627a391ca46adc79cccbadd6697bfc6d7c44c0ffb6c41f58f2b1dcc5447789ff9ade75ab902b09deb839b9c162382594ab663ea6e5009a7263928e469322192da0b5a47f0b7c4d91d37d230f923ab02dc78cbb51aa1ba71d6207ebe106e240a6a93cd4b8ca57f83255b88471334e7dc9fb18b3eb62c9feb2aa52165cc07cc848d54db63ddcae3c13d1a43b2c2ad82da70c21eb142a1004d70b1811448138def5c7bb018302080d5802742be6da0336262829d7ccc74106cb57c8fa63b7565a8c811036e2bdd7ea4e66a7c61b00ed3722c1ba7d19e4164ed6d93372cb44079b32cc2b522d3067215569109e52feba98a547695e2662eef95512c7063b20f573e2844c1d82ddd4b0ed239ec545a96b266398d4e41e3f8c02e15b862d60cefe56195722fa3614b84018dc7c6cea6233550d95a1ced6b803881cd2c3bfb8bd5e813b6d7203efeeba3128ca561ecef0c4e61dafcf25ffa2e7af9a7601f3ddcc675d3253ead9c29a43964327a9cff1fb1b7b3525a1c8713904ce74acfea1b40a90272d6c947cc9707c4e901c44dbd375e2d9ef1b9c20e76f0e91b93a8c5bea3a408439fa730487ecc4717f0f512dfbe8b646172dcd062b02dae0529cb58309241db50086475946cdcfb7f2d538c621f70abe343149fc38582e87af2f6f536af21bd3f12a9e3951f1b9d48fd23da96d8d91798104f80fbde80cdaa5a220dfdf374a7575562f3245e1c72cf04ee8d12126f39725c47ba1526cf59e17167b42a35743716e3f3df9c0b4b1951efdf3ed657213e3a01ee6f7726b0e2faee929cfa20ee21f104fd2c571ee1074218ae6b11c55ac35b8413b38642461b4c7c1e9bdf47ba348cf26b08b2bc515825503e571cfa1de26f57a008246432a1e5ec094c8f090365122dfee2ce6a6fc2880e326925a42774f42988aa4d952c6ab7bf3771e4e529972815712630015d6b32c32a4224db77a1bc7735eeaeb8162a2fcaf28280f47bd1b48e8321ee1a138e6d4a03c379a170bcca2c3b52c20eb80edf1f585d7fe50a0205ac50e7ea03e4a633a1aae5e01735838c3b86dfc894a1ab92326cc7ed60e4914f7814dd083b53ece67368e85d1d5930a8898c4fc333ca45544ebd495b1f1a6ec17bd0489bcf487d1aae1d330ad0a61c41cf25763ac9320005cb421b98ce41160019ab4e8928ddd5f1494508c3ccb06000160010f926bf9d8aca1144ab504e32f519f2573c4e605a3c74039126f1c052dd0e46ae4d05311d0405580b55f1c5d4f5d6ec387bf6fcd528e9265043ee3a4913b9f193d74ebda8ad0848a2dbeefdd3c2a46c3481ff49a1a09782ea2c4aa90f66cc1e265b72bea19dddbc6b524c40ccd29abf9dff0d30ee32a137ee8ea7383bf3a23912a8a23d6492f39d901960da98c0005848470c05aedcf97dbabea758e07e85a2b0b01abb38bff91dc6c204ce6a1e210ce9fddd1dde2eb0f2c8f52576b1c5902fdc1d92d0ca67f6ea8f2610d415f8f17913f196cc52d447093c364b1ef156b2934ec911adbbc0c36d2f75b68ef816b56d595c5811d2c536baa972e9ba43823bc897f58329a176dc2dc83fa9e78b0c84eb34024296e5c2cf8be7f23bb029ffdb5dc442ad6768fe42f5eed7dd2ef78ad0d50afbae8f4e8b71d1b33ecf76b15462dffb91fdc701e46f2ae91ed2b7f0a0eebf51663a9d01430c17282e61c203a03598eb47848a19538cd7d1e0d631f3296973a4bcccf194d79203604b6b682881ddab8fb7ac1c2bfa5f77654d37fb52f46567f69f34aa588ea667bd42c703b0adfc4f3115f9cd21ca42f91333bb463e40533e253e24431bede0fc95202597475ec7bd6971fd2825a8c9e498b7c20c8bfb4cd7fce5f2b329518c8b4bd342f8a063162700ebe8eaa8f965fe4e9d9025a4f85c24dd73da6ca204a4cd540721f3b205956eeb355f035740b2635eec0383b21d991fd51b977b453c47730b4a88f26ec60bfda4afe9cb30aa4a360d14275070fb54bfc13d9abe59de4510da662b21070b26ddf7ca89de0334988b9e6df17a681aa17a4a510f22669700a413fdb91925b8309d8949d04c9a6049c36867700e456d3a970b513636c9a152c6e264d717d4eec21148c92435183fae07a54de95390586f1b28ea202a97a6e6cb7ae04032c6fee0d68c3477d41d97b05ec08886fba128403584b42764c0869ec2d74a77259dd9577079883649bad78e8ef736dff08862b45169b94fe923dd61118fa95319de2cda1bf7484d3810af6da5520faaa8f470e29ca2b68e103da2b765d182df36381cce2e02ade672df10d51cccdbdc95c04ced27d880a09427f776d27717b49252764f65af1f6e53acfef2f583319a0ab10ef8049a50b553538979d8267be784cac6d720f39bf9932d267f115e23890e42a2d9dbaec4932549aef326794ef0f94f255941a2a09d391354e03648585daf474f1f311a4c5e9bc2934cf41347bdaf25919e7e51e532a1dbef9906347657d532657de6dbb30778f40b9e3976c578b0ae6880599462ba7a17c27fb15e40da65fdb6ce6b38788705297395e1c51e9edbd0d00de6d39d366f5f5865c03a9bfd609d17e8cb0d87a828825006d7b0d1eb04bbfb23c0d237daedb896200137bf5726100d4c6af2d24b52d2a2f5f3ab1d905ee4cbafffa49d690dd59f4c5a07a1601a973e8dc0ea961b6fa7d2af6889b49ed3fcdeeef0c02e4caf02deb1e0bc3230ef639d4d2fad8337f11a6a9f75689bd080f34927c224af70a40b50a1872974861b1c73b659543f51962bbe141d973415e1ad941caa1fbe47b6c579967d1184e00dc356c0ae0ad83bcc848e674948be717924d63b933dbadd86cb2fed02a6a1d30e7afa97dcbdf409094adbb281a2441a3912e9a95d60f78e9de78beec713f1832cd91675ca40b71c92fc6a1c49bb7eb4f23c9baa954c1dc211be4cdc5370d76ddf69e526dbf723a39421297726210823ca8ca29fd973637e39e64ce380405a5979687c1ae347403c88df70b1dc185a302dfedc753af068ab482befb1ac15ab37d367da664ee2aeaf526eb00b2be841b854387ea896a66f7c12c3a2dae67994b494a13f4854f306a25123d17a39673ad8b17ff091593db5f84e779b910279db725d91c3bffe2eeff7fd637329e38d3d06252265cc62e457b36fa6eeba6067b43e50bc64fc1bf9c1669e9e749bb797ee7b4eaa33eb49bbab72248f7b52a311261994aec92d90ea4570fe56b0974c13d7dfdb5bbebe2c4fc679c8703f885883f192029ca0f05e908fb854685e572d0175230a5b4198c983610628cb6d4c782eb8af753e5e02231358dda7c04447de6abc61a80510307470f7c2aa268beb67469e08ec483c679efc854f1c939003ef72ef6c62489289b8427d697ea3f112f774f00a5e8661bb24415dd8418699bbece028911015182597bae642f2b36b25b04255e4a5b4637009f9704c167ebb19b28f4aa588fb39122061cb7b75a566404e6174aef4fc5c6b4851f084220aac2e78993210fbb51784799c6dc663e0bceee6611d2cca35f737b2a9362cee9c6ac8e70be66b44707d4e0eab9903199d0934bad2001b85729f43afa1f5db8d2ef7bdff3b1ea0dbc0a801e5c53468cebd3f4fb571ad7797df28775e205d339545528f17af95bac65f7d1439358301b6c2ddd3bc3071e0f557523f80109536be30a0b5c371d2733da09813f900a80a4d487d5c2367cdb67c315d3418ae0c7770fa9e71582e91017e016d04a858071518bbff0b4344e323d15be1dba655c722191888fd354c70068d43643ec4869b0be0c98e4bc196eab0c95e18895b617bbae7f59f304de7b51f728e64a2b119f1818e23b0f4575a8515907d1bae0f9fa015502e3276653389f18f1f93b1c637cf31a3be39b818cb0b5340311fb8cfd03405e0834c8013ceff459a86b236041d18620df2178a9bbbfc377ae266a8f2787e72fc2970750daa29a8d711b4edffc5fba7c92da6d3975bbec05b6eb764fd072611433dea31a6f45abb8d9ec26a92f1093d6da4483262d63286c3a8f27f0f5eb3cf37afde0cf32efb05859e774b9f8913bad13d4d3976c6222d3a83cf799bc73afe1fcfe8203f31e5edeea17e4bd0ef48632a47ad772b76ca46d86b125a1308d50540ca475007502dc3ec8e19cc2530995df4d8e5d543c7133ad7bd21cc850c1c5ec3af927ea9338734c1eae110afd93eb9ef17bab65f6f8e9baff5e8e6460331ae468ed33383df1790d24b9f31b88cb6430637519e9f2a7857454dfa45c7a06b32aa00d740dde8773aa170f4cbee6c24c531fb35a5f23360fce4e9136a850c293fa82d556317acaffc9916446ea10db9797d7b6338cd3af9ced2dc536f0d689b197d7df999a0d663f651edb54833b6346c8d0f8f91079062553ec7f49f6791e0d2219f5ff1e71ef94b012e795ac778cf6a06e26313909340ea667ad74a6bc077740c5b164a4e76bd765bc59c124ed97f3aa77566d876cda6b72c0b80ed5e67b05ab7b3ae2204387044b35d934d091439ca41ed2ffd94d88f4881339519b22d70a1073b6d78e5e4a6bd5b577bb32f365c3be15749f5134e546a092c3280c05f5b3136fa730ce41c014210ac07c9f110cbd848be8ae5b842467390d9a320f48f6fb9449818233e8f85e671e5990fc1727853ce4daa46fe5d4ead24f2a2a8b8f70556b32298d49eec3ef4926609aeb7f0ecfb18fab92e02625a9eab59e0e1948e05c1527db47a27b77e1a4fea3f1c46eab91aef170ca775d82c86efaa5b3ed3cf4681eb1ab8bd86ffac0e19f575d97b2eac9b25607cfc2def8ecbcf3d89ee0f32ad43fc21023bcdb87e91e7cd17b25cb2aac24ba8b4cf08ca285fcaee7fd76eefa19b596a1015aa80e17e46d4219fe253c23c3a2b9fc9e7fd42866faa659b7be4313836b5ccf43df08597458c4ba609834815838fce9d781baa6ddd46af35853c9bc91f30389eb22874840c6a932f2c546a61d186ac3f20b5d3937be3ceb51dba087fe5c10e66cc03f7620e0dc08fd52c00ace6829dbcbd50fae9edac60cab008842ff88dc0252028478a3ffea671632aa391c88f329d48bd3ee3db9f4599cb1a4d515d68b3fc41b049d669bb39b3cd150e8d4157f981fbd7bcc329f40984da9f09e3766d574d7cb2201fbc2cac97facc2139d5779db9d6cb8f211516de3e50d25247b262a7eac31956b745ef796598a606b937b509fbb9fc05d44ee9540a394ce24917808df65ed7a07f123f440d068dd2ffb1b73b8d3930b75a34d303bda4b828555d9ddd6f3470480848b34a72ceb884c615c1d22e2f48e15ca42f9e079d173152240b5f42926648e33a2794a518cd377e4fd5ff5b633fd131869d4f856fe4557b145d6d1cd64a967c9d1e71a3d48ff42a07fa61eb3534380e4a612bd948b06a61717d95baef2de41bab78b40b73d8392ace4f35afb80262456c7b45a74268153998f4e82ae7b9878343be4b62b3c0f06812c2006c5f777ee6156a0eb7da619cd97aa4b549b05ae3db2fa858b5f4bd97ff421683c32c472e8c84d482fb48d8caac370131677645ccd571cea041d177b49920ceea7401b5eab7bda668ea34793d9d6672b6bfbabdd337e70d20ff91f074c5773eac4a04e390d5a5eece76e33cf7bc08d2d068ce57989dd17829774d858a2123550222e3e6069b632be433baab9e7cfc73ea42333c43826abac4ae98787ddef1e96b195e63740d2825d37af7bad85428b3082e0026afff9d01c49ef4beaced6dd45910f00a7074b2cb4257c1f3bf21830caa58fbe2ea8b09086b7d40723c63c0a10d27be04018fba0e51dd33dd93fa77b192c792feedca070db38bb3079a9aafbcc7a0a2bb1fdeed771bc9dfcceecb0fb8a2d991a55651307bca6c7b92dfd3a56b5085de713784dc68ada66a5c3bb0bebf6685893a1fd3152a0632d643b20d52f3e14934bb5b15b5df3a190afcd400dee560314f1fd44d65b5c3e616d0a33bdfd240d84c942306a37cd3e31d541379f2d7326836438f7241444f09fa61b9280dfa56eb330d49a51644ef12a65c7551349751e0d5149d6852edfc4b5e2731785c194badca5025aa96c3b5ca99fd3b29fabcb89dfc2c2c60cffa44a0e3c0776cf161af9ee00af47afd609fc79a1fd3f940222a23311afe4b72e3b7f9b9eb3f7debf972f455c308a1aaac49eb4475d56df50ece8a8515e600037f11068f0c9d3cc8e29b8d290a67097783285d4749a6479f671666287694d717bdff0f6fd7e38f55f6e658131522bfabd5c6587e4c6a1df4facff30cbe39eabe0c48fb648fee222ec397b42d1b788be5266a7b930fdd120c1585909408991435c31ad084d19e54808913a45f30328fa1c81145fa94aae260c99d7192fde562a188753499674a974962d36a6a5fdfdaf1a8cdd0c7275e044552d181d04ef8aba359d2c489474e24283f407dbb5689bd87db59d05851c8a6caed259746dbafc6f8c4af6ab0829fbd0985de98d6b1ae65d3289e7ca990e36ee5d599ee7b18c5d69c1adbf2b36ac6c65c6ba8a366b955d119fed9e43650907266cdf99c7ac646191610a637568e3f2704d754de7d90c4c1051c31631567be5bcf7134b268ff0cdd94421293b164915ad3a8e1a3c57d3befa4ee12922a5ab2e8a92e2aa067ff063d964caab4d3409c456a5f7f27d7dd746e22496a018721d8a668734a4a8c9d296c96e0272ed485aec676fc0dbec5f31c0c5242f2f336ee77aba7fb2ec6b1f2c5129aa42d91cd963f466ece5051b62421fff8c769181fc3bf6aae31f70b07592073f5677f514ee6ac99146fb8428923da52536b43bdb3cf31b874a3c1643a2b99770679ecf928cb2722c0eee6c6561967ca7041bed32d328510e220d9a97d855225bedd3af2e4cd5ebb8f3abc7d1e269ddd95a444e3dd3fdaf008095bd9a2a23634dcaf01eca6d8e49da774447a91006923d75343d417e207ba8958a06ecbfd75f786e47f176e5e50854ede9507d1cccf6ee020e3d2149bdd5907ce66330ca24b2f3b51be9b3a661433221dde316b2faa3527b480fbb40e7614c690551f45f0b75fe867c319afa3c9f99da6a3ee722053eb60f5b4b89d025f9938817e164bc79aa964517a63cd35b4343cfa1776fc5a69213e37542d4003800766a009c054c5f332bfa8bb0e101d46db8efb1acb00d072a100cfef299a82a605264e75080d8ac70e121ffa89dd2c40fd149bcdb4dd24f3e226647e843b88e07d6badd2ead737822e5b95cf94918c55f7b505fddcf785c28d89c9fdd6ad1eeb7b73eae2c66c4d30f8b71ab615c111acbbfc2e84b72131e400db10a064c8c86d24bb2d264ee56b63e1f3e8df19b99706aabc7603fed4edae1c4b19f7a2b8a4a3ead9fe69273ba8ca210284331ab7c465ab21cf5e4ef9c55b5e71d016b8ad978eb4b35978576bc81092a7dabdf5322744e70da94785b27c16913a66d18afe8b7f801bf6f287eab503b58553ef0a2e6c9c2c323d3662e69c8e648218f22ecf98dd694326ab1292671afb16db72c789aff95c0d9a30bcb4031a336a362aebe02ff7631682d430b0eb53ad8ad6359b18bdd72e220b5aafe82e945b1b8442138d37f76af135561fb145e01c41723093d28ee63fecac255525827f7cf262b751311d9affb5ac32aebf65f5ce60b2fc784271d8e5978aabf9ca2b7b0cf5f6a1633f9e4c31c0d73dc6b443d152ec9ac50ecdd8986cd61359253e547ed7e8ab352d76393308ca46bae60ba79c318b87d8324bcb9c52dc19a75bfffa5519dadc5d5033c1510f99ce3c4387c7c0284bae53489adabb4a284e0204887fa9c5a82a2144f6a0a0ddcbe2b1d5d957295cab4a83ca38fa081cbe5a1d31395b10d5d946fc0f10858e167756187b65037b55e0f40838fa6a00aef6641a3d1eb061e37ed73dfec266d80013ea283715d32d930f837d7a19e307868ff0830c5ec7df26dd6430fe4924ffa2e6476d0d3f77337bcded8f88760071abfda0a943dc9959a7a9c612b52ace0c8e79b559939938e0e54cce570cb735fac07a9e7304da7889de185f4d73b9c7ad978417b037e85b9137aa21cb98aca3e97da20790a9c1bc3d69bbd68f1dabcdb49a54a4b26bed4e53194f504532de06e55d3f85a77d33104c7eff8d29a449445a892b5a640d0a17c8b33fd406d35b55799e1034cf4402f882b799abb6d5f76718da4bf4aca75deea088bebeaa4758e87a2ce896b25991b08355f37a5e70831d52e946cbbd6b1cacbc6cf66d08c9e0cdfd41de2973e3262927272a3ae72dca54f31c0dc9e805102722a6611175d71df00db894a860ba0b277afb3077b908433a8f75d5fbde95fe972857b73e7113b27dc779df3c4b193ec60ebec66972cfc001c8d2c66ca6c92e7205602447f6aaa21b963a16d2d5e492762c7f6bc7b2b946fb6ccf470d78998787f73be6297d3942bc6af981857f64ab0c47010f2451980fbb0265944c854a376f5674d9ee36ee5e9339356cb8e14caca36d84eb303839261b62a6a5c448e666873a6e3bace7b08ad48adde97e22f13acdfaded1ddc15a4e749f9ffadab1f9f1196d2e685d493df046ae1dc112ee547f96c4986ba047f3b9040a238cbbf6628606675ee91412ddc2bca24a5f5dc8b9a26d31c6813148399a0740c4c44290c4feaa4d78ff34b1d264ce28ea7c6b5835c977c4843a9970874604dfb84169d9e5c9aaddbbfd210c211130684ab2d4bdf6688d14f8033011d73ed61261ebdd18ebeee3dabca4cdedc2903296e23e4cee3ed1e939dc28ebf1347f034650172465ae5a187d762f3105e880b6b8ed7e280f61b15f9b3411924490541d19236a1a24299f69f8e95d7684f97182680eef75001e843488e42f9a68d13c2bb375f900a03899b4c0ba93f29ea2c5c8fedf4f4eda42cd6ba7b91e03f4f56f71eed58537774ff80f19dd2bb001416c6013291d27d33b77796742a7a79d4d52ac9e1e16bed82572c75b2557b2649ed08b555e491f9f4711b84120c7cd3fe07ef8720703a616b39d6565741a880a3c24136c4f31dbea1ff7ac77fac62005acaef39f8ea5e25d3b3de7cae32b8670719ea86a4bf9436a76ddae4aed04f4a25c55ca16392735d2dfa74fffc5ad07e36abcb7da05ef580bbb78af325e13b661fb344bab183ed822451be380d5f54932e1a1f02e1ba88a7307bc732bdc14cd129087fc33523f18b54425ff46f3f9ddd7ddff35ab48f155a968f689c33625fdd8835e15cf869b93681d0d3ea649461867d084482ca56e574273b7815a2641157a0b9d722a9c1cb4cd3f3f2896e78c0d36ec02b6af963a28b2b010d57b4a9fd27ad8dd42c5bf7986771faa1f64224d23461e0368f0d7f263a998dccc97db5f4d719c0f067ca8f9d39691fce24c5686a47ca918f3d4c3cc8f2bbe6434e67a73fe136bec95d947d37816c3e752ae34f71ec0ea5c54265f1fad73c073816fa4f7956721a2f88610efa7611cb20b2cc5b92b47296de1075432d7ab536bb15b2563a6d86f9d970dfb5f2fa1e9efe3eb57bd9977efa8998a517acaca60da5841e96499d54c43b29c2c5ba83c9de9845cbc35ef8f30eb7c43c2766a8b5e88675ef761849f701e50d891f7a7a9615c4b810a9fd2e6315194c1860914a659391c288d14b946ba0def60ec03b5e8b6a4c6534589e9c81b99310395304772e4ffa7ec19fc35cae8d16356c742a1c65d4293904619a9310245f0e308728e00d1da39dd58dc934dde93cec4e83e814ed2eef72880ea39d93607a782dec85cca4050cb1b7aa92c614c3d29d2c5f87419ad130870cc67621a8e8d90a5563663adc4cfa9d90730d66a4f2cf62211ad2db23fbb2b8e6de5d41310ff75b03ead866e65c65c7ee2ac973a7cecb16ca37b8a5486835743200869cabe08d480f2b4bc36ef21e4a7163b9d1f4217ec910bc135645027abf56fbadee6ade3d2b72c7583291541ac8798096cb34cc78b3e7fadce20a5c552b3586170235de649d418645d1578d7c47e81b81ec0af8ff5de0407c6da1ef7f9c56893067a0ff102f903b2bf917d5003bde4a3a1e97568c33bf49d57b144d318e495507608eaac3de0c951109c81c241a482de0fedf30474fe6eb7c4c8a1bb69f67ded9e8bbc6eb3e0e6a9e351327b286710b0ffd4c5995ff382d65cf86d7d2d5204b3da0aa6ce6dda625dda09f5ea6a4b1b85b59afc65f35a70448c7f2da3836ae5e17db1e0488cd6c483494d342bb177df59e205607aa745170ae2cb0ee143d420f3d17f3be325c249f74280e65e5386a7e62f0f348ca8544771c17213ecdfc63ceba199be884cb8dde4fffb89b38987a26c11780e8edfacc61b0b13d74ef9714176633716fd6d43df7246a8efd44022368efadf2e68434c70b37b1e6b4adc20ab081466aca33d8447292598eb30c82a66946be29cd88f1b07113cb914cb9d9c311a645e94d965f0a2ce9c84845cb4a5605346717e1800a4dd931d638897d271bd7ee32728a60ede46cbca052def8a0c8013801089fb17ae70fdd67dba84578e642133d388d3bcf90f1b2ffe1fb510f2d7499a0445f5f2541cf585ad6c8c5b10b02c2060c6a5d5abef1fb141d5d71c59a9e68a1803888c70039d3c2fb990bd0367a41c3803024c5ff0a602d8fb63d0d31a9625ab5fa2683d408a77e5ac1af70a056712a4a96925948b275cf7db4413afa003d63d9fc9b9b45b96263c275e140871328096b8090f7501d5b4d402fe95646ae09170e274638aa6a2332c5056e34fa31ebfc898a945615476cd3cd5d861345b1e3a4df6475ab6ec8babd73c93e85da48851a9883530795ff3cd393b45f71acfee8256a2e51d6cbdf70fd1bbdaba4eef70d306f1dc71c2d73aee6979f3b8e6b04fff5e19760e6935521e22ba8aa5054a0dcf80c31b94d7a0b8e6680bd25eece246ea99efbc88d30f20dc898dea8cdad21ad8182008f704ddfb3c94d2540f3864581b235e055c88bb6b493877bdea71b8eb2d342cd16ad18649adb1aaac18dacdcb9f92b63a6ed237aed1d2b9f88504e3282fcc5202cc6264a23b2e883a25c8edb61510fdb3025d28146be9aea411a33d7186c9f4ae2e422a26d3277eb2a30aa4b4c553d38f1316d51ebc018197069e17c5dbf872cbc6163816ee96cecf1c9bef1b0947a0cd1b761540d0a82927f6eb01ca3c9b68bb820851442786a3393702513fb395453828bedd0aaa3a7658094143a6a0a497be8d4994095471ad216239991f5af5e83c0789d3a6c1c9d4bcd45e188185ac4771a4c54868c96744869b5f68a5d8e3e0ba04ba9a7bd0d5ca0e23fadf00672d18cde5b3b184657facc714f07a5a9d0855c79300b06e0dba599bff9954f92f7300e351ced63541017095b9dcf98a4a283c3386c9c7c6c37d4bce0b472395c1902cd95e4b87b03aa982bf28fdcc6e8eb5447ed86ab1021fb20ae0e87c12aa1bc62074cd3adb223d62da31c95cb794eba908b9823da9f08d5cdd1d775d12cd6774ced7b1f4762d228eb1b5b561dde9150f507edc38f96b227828ae682166854b49304ffcde7ee584ef9d5100487f771630b7f1e125517749cfcae37b6ff63c4a7dabf5133c73219ef65a0ac8d728809b6fd517407aad441e1b46a5705500f6b23838ca4c2c99927e5eb007ae855c166be867459d29d26402e6dedb3f7cea741fed908b20efdbcfc7aac147d96fbc2c1cb088dd961a6b895e53f90ae7f98e7b7f1ea956db251c7ec82676ec3ed5b94568cd064ade354f8c1e1782a79690ea480240d8856e4ed5896554712d8a2c6cc339597fcb7f03982de880ebd6f44f7cedc3199d95abd4c09de52cdd75ad4c7b5393f33a8572958159da8ee6129d4c1dcd1469c6494154c2c28ebbf3a10760d790afd0496029ab05b8b78e8ff1866a8d4290b15999f80b35d18b54be362e04d2f7a04ebf2667a3e66ae47cb31d18f5be141c83c7ba3054431bc5794447db31e8757d78d088551a771bb6ac63e4e01bb4e3f4fc5e27fbf5c49690f44546dfd4791957c395e25b10c60e9b20068cadbdfb4ce2efe474f070856f8f844b7370a549f631fb314ef5e895d5622469e93767275e9574e2891bbb8b764995676ab686246f50156e89ef6ea62e749ceda01c36f38fd1d3c336fed60343b8ef748a06460e88579494b5e3d54d8489c35b78b510d4577681e9b3c5477a888c74f0b8bddc1b7e85fd5de6f8810574bd7ba6e6384200aef66507ab9e6063ea7493bdc3698d31a26f19c5375a73cc781ed7d4f739b37bf08fabc727ca084699b13c06c211c556db211e1e67564e663bb7819ec391c98277f3e181ac304fd4af526b8a32b55193f2b608d9e377bb55e40e41d5703294546316d1ba024fb64431c5cf866fbf998c750748cd019ac63b3855501385e93088085ca7bb3162302780ef02cb99bb4aaca81914ca1d8b52833c715e0e42bd6133cd5f6efda4146d831e887651e21293e82b5f74210ae99ea713e803f4ed7aa280bb506e9bd68fe2504a7d258794f44f50fbaadeaf97b57f063b44607cf756c4b1c00f75098e38f312d5c6f0f8e91b58eaf6abe1c974b98761ca4b93956dd64ddb663ac826cc8ba483565c6f9e765e99a03ac4527796a6a8b7da144ff75db413fbfdd4edc77ff3832327665700748cd28445e92aedfbfdb7f50d380e8970dfc608fc3a90ec55105906feca55673f5724ec56999b0db06a0ccdd5d036b308e13df1304bda04f504f568602a6ba56969840ae93134150ad50533644fd941044f7a866c5b8c89638e85f6ffbf1a615570e448425e6d4713f197b569e1fa0329af07a439544ac09b2120ec0bdfaf787b28aa729a8b9c6fbf1797856e4a355aaf78a2376768045764629ac439ef654cc8543ae4f56f584b6f43802adb74e03a02f7fc7d07f8ff40acc2ea130bd31b23331b12f98a64c1b00f77c0aed29c8427b661510ee39acf1406ef6eb290414ba97682564fa0819ce2a5767ade0b248130deaeb71cdeac87929c6013a8cd898443b1ee1386d3ef6d94943d012f87becbd9ec7a1595e19c9bab70b8ab5df76c5bb42f66a4ae2e58250ee1fad6643b71f18f7cde928599e8c33c68604e8e65622da0245eb9728f2578ff9ba377e5742bcbc826d4a137eca314eea58a7c548f72d3e48155d9ec97595f7a6ee0f6551216618e87826e9b3483ae329459678f61c506f7d9a81bb9fa6d4c51e3a1af949f44b807ca38ad159c741b8a7ae440c66d0eeb6e5ffcbf49de3c7e1d90d5c7a3a7f354a71f58e0b5cfe8e10aedb5d6c8c2f72b375616d649c9bdf74b8bfa9cb0f4651748af8995fc7fbfa60dbbde1db74103db4eae229d096471a659b9a1bacc333b7a4456b8f864d347a31da191a5ec58c56843727cb142c1deaca0a5c058a03ac9e56c4ab064ed330b47ff54df79529690016d042c86af0fb3d7291bfd2712ff4a1a6a825d6e649bcee0a70db58bdddbd94c88f42b9f95b04b322262dd2416201","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
