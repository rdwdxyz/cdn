<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5509a395cee325d0984f43245f5454405b78f8a65c7de316a4425136a4a9f80c2c037d047faf55f045a5270af5796ad21a85f09af4c2a09f61cdb163382a42311b72c863396806ed121a71979677efb24594565bbb0c26e1f9bf4b84917eba491aba244f8a44f9edd6a83ca2a119a2d2533b067de341a632a7fddbbb91e8f3fcbd7721404f38fa918df5ebd80608bc2b77f0888321dd4c3dfcf6ca267b6aae1d4e433377e7528fdd4d67299da874e7d099fefd40a6ed47c74b3db5133286ba87ac3f5f267994816cae0808fe88c1eeb67403138057a4499f963809f51cbdb49e62eeeaa852170e559d852a2437bbbf64526597f21609b8b97660e72fdf642b1f7f63ee58eea6909671150d326c608764a694c09361f7f5cb41b89f38ed4117ff3a910966c947b0a84fe782a85450422451d72846057f9df014de4acfcb4587b89a467a38a490bc7002945fdcaacfd7f4311735656ef36d096659058d64dbd8a168dbc7b86419d66a0c1350cd0306f985d7e1dedd14f1d0e13a8126b8e4acd7b4ed605fad514ff7a9f99929ed585f08580fa7b03aa75b5ed6c6bbdb8f9058dc0ec8c5d7a5fa120bd408c3d1f6477cba8c9423ef9d4cd98d2ac02a9e18566095e37ddf9142ea96df76bae8ad608ad76389228372d8ae72e32686555bfdce5be1f61a4616833d9bc13bb54ea5d0ec01d7b49428d6180d72ce134f10de853e091729023f872b991b379e223c85f57a121da05c82001b0adfaab75932d41f68ef50bc7b94b89f685147a2c13c04118196698647f004d746767a0dfe5b684031a126aa32f5bfbb94a5d7c818cdd03682eb506917a5a1434c5d789747e08b8b5bae2159edf0eb1555a0157a58dbfc9563f140f4da02fb8f6c145ddbebba9310cfe4b8f619eb924c859a69b039a0559ebffc80884f0cde91555eec0217e6b18cad100b626a46d96672b5ea619dac010f6d3f0f781e8157335f1cf3ea8ca63d8a66055672835acd3af81ea9c11449ef7e492c55570c64247e421398ea69e7930e943651e99f3a4b679d7e5c29a668d162c5882d224cc1eda2600d2c1cfed3274d7ec5e28000e65b78fb5e9d99941845e34f15e821f5e06ee1e10e5730f8bd3f27e13415937299d39716d3cedfd2785cf2c7e17f06b82f41c081f0ea104814d38f5f9198a0bcbe9a4bc62f19bf73bc5eac18d6da0109a3157c6c10eb71b35f859cd6f9cab5c1499827a7acce74858c61fc171d67422069964f03016dde8a2962ee5c88e476b275a65c95b3c644bb86bad7dd814350d7cecf280e97e97d844d25ff86a3020673f43170e4d7debd21d8f1c31e751e7b6d332da381133300f101596156a8720dfb40b8438f8da7d5f3b87f05419060de69021cc4f5d769f95e21c3a306ea7a9bda603269ffbedaba8187d9506d8a80e1d6f8fc7e8928ba9263e5a9b1924a1e892e1158f7e6ea32d453e6b09a32d820e55f9a870984fd8b5a96aca50f3a6266a7d28e2e95b30d67a51453d2b32b551157ab017a2d654a177b00fb08c0b5fb5ac4a4f290a58340d3d731ae543ea2d8c1b53fe7028552928757d8ea89be97e997d31567d3e9f0eca15fcb941b4a563ac40e0ef6568af0b8ce00108e51d613cf93c1f3f3a5c9bd9a5069efc67adecc1b3551ba36fce3dc2b0e5e82ef1971ca65b6ffe8ab98ea1c4a6660fc3eadcf9a5a9124b8379364f24cb654038ef18f2d95238e02e8588363b9ceff5d8a2f40a7334617c479b4ee3ebd351a22e99a6c46e9017377ac60ee2be15976b352df4bfc4de4ffc4f40b385e324b2e6300e37d3840ea38e5ef9b0fc15dafcc8ed8093771fbdf27dfb6d8099343a9a9992e7fd181a9575bb42ef0dee1bc1486c24139993c32a0d745a2eb1dc81a2215713f504f4fa0baf5d595751b48b61409e4accf8071a6286262de3fbffa98dc452be8eba1550e39cf61f08298cc297e13d4306693dbe02b887f85cc2d05f49ece4ca59b0bf57440f8b422cecacf03deb5d0a6501a1e0075e84a5c12f58292329d3ad9dd4203cbf58ff91307b5425cf5e43a88caa352e55c889d067077b1e9a084462689e57b47a206075144fbdc4d8bbc28c1de112f5a332b361ab4fc7dc59df10b00ca4eb0fe03911f9a41058cad5818e68c341ee4c5519bd67592d7ad79be31c886607fa2aa416bfdd758330edc9e803cacfa9c1e6f8a6a0d8ba89a41568093ea0eda56b40906b1c7eb081350dbea1da8f152a073e877bd383ef9420138955b8ada1a7c0f1b210fcb455b73596e32c49628f0783c1f2f929999c0d57da0708f9d99d9465a8a562ab2a6b327ee4810e3180109bf4b66c37ac6347b4b59cbc1b22a83d33f31f2e7e1b50e7bc4be8eea3b216d8c4c022c6a85b2a58328563d7c502dc3f069e169fd4cc5504d7dcd21ff0c8a354a38b3b5e9dfab6fa2dfd99e798229902220e7b79bd813f556d3d8d5efa3ef301ba2958b14e3f38a739b81b45c1723a19dfe391c96df691004cd82efc8eaac92f95e7fe40027c0256de036cb6fda2ba387f2246123b9b9d9a3a5386f21fcd1a758ac46af92ba84a6596db536c296ef3ca747307eab2a60a0a03257c24864d0b458c20be44e594d9f3d352ee0f897f5a5b717ed3f61dcd731ef30d7f225eaaefcfe5f3c58e84c956c045e92c85a5df3aa660c7dec2994e346274586895bf51e550e0d418a5ddf6138671c491451c9a28d74ee76a0c39509ea81e53954a53096c4995f5ec37787e341db50e82bb8ddc4fb6c00d6b1bcd4fdecbe5b2bd64675c4222293f18bdf13456edf843ace3c614e6001ee198e24852160ecabdb409afa13f1503c6e618e123485db7e8bf97c23da694585c5407a97ca83c8ae7cdd70165dc0e6f633c8f4a8a5ed52e40590064ade7d47580833beea345d34efc20847900631d1f1c574a62d7f7c4af26af4260a7b4856f263fe4fa5b7c14768a6a836dadf3bda03246eeb7b9d8f04f0846cbe2aa6068c92ff930a2a30dd67e7bf66b33551df6ecf16f46e5b98620d8b594f50c2f356747843e5f042ac93162aa0ce0f80798831c57dfae284f0ab73a1a3b2df1e79df36bcaaff4495790c0038d43bcdf22681432f87d3560732703f464ef3aa17b6a4614a9bf4c17baec0a308d0a68c03a69e73e560164546113f6b64e2eefc40a0257c499f64c5cc1205ee6872f1f747e848c6f773f3ebc6279b246654b5b7575431f5f7813ed70e64a20d1c2e11357d072cb847647e7dbcff668d08d9bfa7e09d20bf9d17674ca4ed79dfea590c5bf51f9c39256ee2de64be6c875caeb4815952ee060544d3628d7ac6edf538fefdbb14a1570644f5398a447045a352bbb2d4f93f2e1036f711944f63e31b9fa4b9026b110e9b297f1134dad36d29fdc9a8ee5fad1ebe84539e676ee810b0ca0529057a7a2023f929730294c3a06950a7a00f8364ca8889a3db3119926a984954714f4e8f1c6edcc6a5593f5fbc43dabf0803330087d9e634b79a63cc367b384f93ae0fb0e3dd417b2cfd9b1e3c5fe4c61f8fb207121171e9e5d85aa96805796b64a98026485a643637bc63cef0e00650ab4725ab3878d4f7f899112dde2aaf2b30fbb1d665286db1a8d685d6d3e4fb8c9fae2bce7c1eba5d9e33798c2165b4e693b50e740334943d2ce2ace2cdc63b98938717af7e9565502bcad499fd49089d242e64b70e20d6540ac6a0e248f94593d309aa76c49b5caf1c1eea809625a1daf3247904b315a8cb7310c9b4892c9bcdf6ff445cb15c846cd793956fe7c932bd2e7e34d2c627d5893e26aedc7591a6164afd794874ebc10df3524d8e07a2ea8eacfb5f2f1c33f3319e45239b0775e0fd96f4aa16c3c5cd6475edc42a0f609f41fcada1833cfcc6aa20566445c3859d113844234e19e50e5c74f11ad4db9000ee9753fc9aacfbdf35fcb5ddd4e4c76c1c042c53ac9dd1ea1ad4176d4503a24ea71ddd89b1ee26e358f5a9a3e2a7f7d4337c178cd1cc2421eeaed44af30f7bc70f96f874c4f03ae61c589cb48f8819e4748f8dfe6486d7cc0d7554884e18c839307d5ca4677dd4542a39eba6d632f9956cb7f7fcc05350aa24f43e9330aa3a1dbad3db5af2c558e9aa6a42b33ec4d305c1af90cfb824fca4012183a1d45e66a7f4e41d5c7562061491a904a4128e6bede2e9a52c7e1ca9d5095e8a32742e692986a7b23ee73b5e23a9f71de0fade04272a2ed03859b838dde2eaaccf76fafb203a67848bf6f7dceaa3836176071ddd380337bc595ff40f78112041d9962ad0c914458a0fa0c8a34125ff8f9b43d513daf3daf7d99257da97dfe1d35f3dc5faab0e1eed615d34e47a76fa3f179b633b217147a1bee2e32a429a8d91bf42b14975f610cab8fb2da0198d889d37b8c3c0c89ec218551f912c09c0f6541a94f20e1aaaf3584d01a9ec1d9242176159a6f7d9d83682684384e03babc43e994ef3480994f8ecb691783364d4e1b46d2328f46c1252ce0085d6e3193d80a94b017a510f1a512ff22e170f7f8592229a538e586d8429ec80d88eb20321c3f463e0193a32c48c9ef306c2308c9b2847dee32e26f5750ecddb1bc994754112a3a813e9947b70e30c2a5d828d25557dca736f77506bf7b088e7dc8edd25c718368873de126120597d15effc6629472bcc757d5dae0954421bb8c4628597b57e2cbbe20c533cd445fc7ba67bbb93d60e6cccec7f2736592c8cff44479107a751d31e6a8b4601665a961676c314e713d85bce23571f21eb655d2a2aafdfe57de42294ae16bf343dd2352b10bc86319431a259afb5f72353950b992bb28e8afc86facad89100fd7e31ddbdd016053003b1619f6a8598171e15f3c4670e011767c606feef1dd6260853d18d0d55cc9244c572b55e5a083a467ba69be064ee2bb5b0773ec1332789c0d3461b81a4c89e3b3d0952e217ec98caeeb698663be0304468157e983792145795ce156f3895bc4d95f23e579c14191fb25a1f2f12f69ad487cf735cc2a512848963f8eaa46ccda485493f5933fd648baabfcb96a2e00092f8b01bdb32bc086f912a67e0fc13109fc18787676c0d27575189a25044ab54c85f3765670ef89b0b8a8476dce4f124330800ba3f1b39137950b36e0cd20a71f353602fd9549dfabcc3daa05ca6637e4f39df8df6bf04924c6a4befa2860ccbc382dfec26cb820cb014cea16244c7cdf180b07eaeb71db5919be2e124e4bc38974378128515b10785611d26f3afaeeb5117c3cdbc45f1313f8b74fdf4caa2381b1e8f9794aba59e626fcea8e1dbee1739c66b95bd2027ed735f2d1d522f9e581d86fd8d0041f2d1b3fc8e6ac3fdb7c25c28c0512d253381219f9dc573bd58a6a88a8656ccabc7335c773cd125ab217bcde2add1b6761a5c595a9d60e7917b07ca484cecf39121d400cac20bc5f78e1d03f4fa4d68341622a9efcf6f00956cd8bba4cdcd632d37e829111b90101dc43612d33b9f32cb90a955c2390ddc6ed83364d2d1c2b5d52bd8ac11c8db87ea53d818ea6610d3be3ea912af500b91bb8441014f1597f7e9bc5b6f09c438e72895fcb312579674f2b5240e99bb23a9b5cb2a1d3468fa04f6324422cb43cd30fcc801209b71049182f1f6077701ae5e3e6799bf410e71a2ff1c102eae8daca8580774156aa69b50cc657e58710ad386b7b48a37cf65b061377d68892fdaba6badb2bedd9561cd639851dbae148717cfeeb122b942e4af61aa5c7f3c6fe35b12fb11a375d1d725564a405150e5ba9c4bad12406983f37ac3d9d10759f7bd9695bafa82794a88d36fd2a09a406345f904e2a42cab8c7c0ed89887696960d4df4e160c9e801ffa3f383a495887d6b9a47c46142435d5b4bad1ad563bc79382096564ade959bc108269ed6e23c6bd367d5bca7c97022690bc188000056a7fcdbf89ebfddda45a0a1206c9141be870a99ef20c97d366d1e4abe68098530a1c6e39defb10444650d54e1f044ce6c8a3bc9846783951a728f4e40395c271bd27f1f623a8b9c72d065b7d0d1ed207cf06b85d09abd6c4dfa03bbdc61ff7f015c459e90114eaac095466edf25dad10758d3c7b23a49d2b9764b2e334f1349e4234dd16c4af561dff0c65510fecfdfc0df0109f5e7d8d0b8f8552418f6798e9cf2b3cf6240535d27b9f8501ecbad29d9a57ce58c369bc7080d0573d61702f051bb36752b96be2156283038d5ca74213ff66ec32b80a381ba03503ecb14b50cb7f59a4c4b9f649e84dfe0b5f43ec8fd3a210c71d6348c2a9ccb349887f8935ddd0ce2b5f75f636dab186e3ab307ec895bbc9f5e8a9acded553687c20ba384ba2fd067c37794b806731f003b47466e992674db0ba3ce20b6ff88fb74ce02cf7114d7274045ba44bf0c71563d3e0e252da0c5152855f0ff2fa16ede12321d655c62ae29227a20d1ec7464975014dedb958644f6526a1318146d43e26445def17c9be7d8908ec19bc6d8a048145804cb957117e26976d1887cdedcc5b9979aa226eaebebec1b936008ec9d62b8acd13edc0a283b505c239085bc727e35d12c68826371f9d246f2535f0d9d611438ee1bdcc22a6e2fb2c883af7ceb720183ddf8c2d00e35ed73314406970d62789465bc5a61cc65babed8a730556fcdf85348d5886867ddfdea2243d97e477c3a88c6568ddfebb37c17164be6e57fb416f924211d42bd429ac8a327e874a4e701ade9e583574052d528266d47e2e8673c8c86bf53b62fe67a4a1032efb558178ad0057357ffad8f3d5577a86e992df9444fcca235da26776c5ef419d18145f2057f0f7e6ad9fecd890a98491404a567359978274cf5c2aa07b2d43a5d59327fbebb9e0ff129d14a9e78509ef9755832bbf7d585f263d2b93ead182558cb9c3299adb014c59fd9fe598e08dcafa7d8dba79f9a6e4baa40736458af470ddfe82167be645299fedb1accb28a6064e08f551a454ba04ebc46e1d99c92d4c9ed419671f7774dc8349e2120c2449591ef2cd369a5ae2e257d557733e8034fc4f8fbf3f9ea77cdf8c27879bccebb6c653747dd7b57d78a7d25e46e629139f033772459898f7293c04df474e2bcb533b54afc4242bd755b2cf7bdf9f685eb2cf4ca5e8021ba5f415700136cc5f8d1b4ef86747b8db62a1f6df9fbdb49e7f164b99b1b3c835f49039a14f0be354edb7916266ab115351c1936991d0148c4fdc98b200a04ee24ba05a29293fd5fd90309c0149689ebff342e117609855ca803cae6ea9a5e8516c73902d2c61f10be35232d78ac0b099dff343f2a28a0df344f214821d457207e77048e9497424c62a92322932034d385fcdab3cbcfdea06c1962ab09d5374d1ef93c5b3d60d62a36142985559111791bd51ce2c7faa0826c217da944b052496ebaa2164327b97d7030d9f5724263d1f10d497325d9eaed9883e38d7dd06a1db57616dc397ccc71ae4d052af1a29e3347a3fec510267a5a5acafc9afd1177610f5ff38f9b65903a69957b2395bad14d5182f1191629bb949cef83ea08a2b8276bce771c2d19f62aedaa21ab5a97a420743eefa2382bd4e7874a703948eb80da0ff5a6d2dbb4ac5881077c53406a510d516e080663867708ec6ef28fe2a841a423e99848e7c88e4a3efe07efa2b087808222abb3d327f117d2ad0a9cf028a68f72be4131ef8fdc3c79755b8d720e480ff59986feeae60bf14e564089982742201dae8c0e3311ca0f4022be931b1742b8b6a37ae7628bcabf731863eb78599e36c06e40b0490c02c141ea772a9d9daa1311da0d3b365164a62922db96b7732a822ffed356a055348647338668cdae83f60b7386aeb9698fc66423298821f40e6c7cf7739e17bd83fe47057a8d6b79ae5c765e07927370e18d6856420ecc8ef60b01f3a63f0d59c380ebd30a78ad73b12cbf2b44809896dc1d0e6e40daf415f25bfd9886648fa03edc32808557fb9c1567988e90430bdb6f89329eeafc7a3e73fad6bd4c211bea7089ce8d18f46554c069c506e9df2938444d0ad98fd4150f63f80e5717bd557748c58d491f93909cd2455a0812427e50e69f12ef339f93aa3368c963de7c592e71cf13f7acfcf5da94c2b9d621def987d460b5849f065e097d84a2f60226110d94166cdd8023d2168f93fa577470c69e832782e05f7586416ab68dac12c5c47dd759e6a606a0676db1445d8db1952d8d1670eaf6b7a36ceaf56b98548cd4c8a75a21458da2a62082d8c18d703b2bba67c0ec3cbdf8d185adc421cafefda334a8d245d9cb2c9c3cdcc73656b5ee5f9fccd6d3b99f746d0985ba70af92c63f88e0aa5ce83ffbb4c859a16eb5afcb74607d8e464a69eb70c8e4e5ef369f28760042cb50abb5edb01333e0e69daf4a427a37d71063d896264d34d65d5fdd56042ee911ebd69b2aeac328ca852c51cefb29efd3c9d7705a2f2808c73f59fc24e3ba94b0609795287a269c6cac59b4573337f774a51182b585eb17b472764e7bf7b4e4c604bba735de0cc4b546a5f16a66ba3339bae036bd29d743e0b02eb265142bb1e86a816d7be7c9df4c1bccc0a074de2c2819515261e44f450c3ad2ea5c06a1d5a710214f7f83209455bcfedf8a2355c02b33863d454626104ecdde47b3fd44f86a738521c4a61881d8c5d6eabc184e260fc4a42c35713af6667ca9427b71ed79fa2ada7c3f941d8ed6994b79bcd0e3b76b4b0824ca30210cbb3a049cd1e467c2968a84434d5fa2b79e1ec2a7bcb5e39d5ac73c0bf7f7bfb6f7244c78029dfb28e1f6fe7c8ea47e00723c7c0657d795aeac35782ed8d7676bd09fdb466736817b7f00482fe23267003a89a2bc45d671eb81e6aaa2a90649f2ac37a09a9150491f9d2c8e01f7afb2e524216f8e26244a8049eaff8650fd07a9cd5ac743fa9987a8e9e97b28c42457666524b0b377fe0068f7bd1032cc13c5e99051146bcf025fdf9d6b9f92edb83af644fd5e6b345cde5fea0b6a5424c71be5a80c79f921d13a55187f9fc2340bd40d533d61bdf03ba9c1951483f89e98bd35fa2d57d039fcbce6e79bab5e30f83d3bdb77bb445a41722926bfe3608508f7753f7ef809417eb862fa146a5145b2a74df99e1567c22a5154950d5f10da9d4d5b980bfd0d60ee465b197d8e316b44b57c3d910093ff8fcbdf4cd4be4f289196a58cfaa884f652f261ff7366f4f3dfdcdf42e8d6eedbb13a9e5eb13787a13db4dc055f032129f5922dd96754c4f579da652c6809cea210bcde61c9aa0ed6b094d59a56ccd7a564b2bd7b8e9bbacc07b6668239f3abd7c051e957617fab12a2e40bb941e6631e8d228a14d52fd0043a820f27269ad01a38259c18993c51322266df84be93604595a6784be043948aeb88b212781911139e0d07c3b4b1c3fbc0bac8bf43058985a11993a1af2a08a2df38f655ddf707a6f0455a02c2a091bc3ab4cf6f1a916c935ac01e15d7419049e199003d42df67ec348ed64cc5bbb19d3b7f8f126aa6afc8830366ac50b243db2d71c48e01b753e83b5a1e7cb69aa6eac939c3a4597512138c0fbdda480cfeb6f60c4cfe779a515e60469048f212984ec530815297eb258bf2375835c6392d06f6398354165a434002318e953ad3882ad8968e981e0b47b5f2e1880d19aeb110196b917f6eeddbb07722f89de11f595188bfd6051344d84fdb4f9ff9dc7a4de899ce0507f0aa34b6999fbd9a14343aa4187eeef3b23e64db3daa684db297dcc63953dbeea42047f95be0d24867b8f55cb6872c5f64ff72f53154ee3df423a101af4e4284310c9af711629ead1e86bdd09111faba687ad0e13f109a6c84a3f6c50b09fd44cfc9c33d77c4f530847558a81053f66bcad49be1118fa5f87f1c62ab32ad52b3d63f5b9d118961df073fe4c5617bb2ce668635dc5b01753e9c2245518dc02959b19d38663b81cb0a8618ee648885dc6c0d17e57be70db15994de263daaf2f69e3161229264eba47c72b7530dd27966b30e21bdc1567c96b8f746b4322e08841b396e72296a21fba48cb132b995a4a523a23476d93d7d9c0a49a3312b1fe0ca4f3b5dc4ca8e5bc0d3585063f05ba6bf7985515fda179e6191a8b3437a6682c52c2c3e192d9f4c129b37aead0ced76d3813c9d4ed212ede173ca3b53ecde8a07098aaf229f0d77228b8ce93dd2f1e7f48299aa29eeb8e737cbc577e952447d0c3cb238a6dedcdc741a2f9dc7049d991689a84093218f4fd94aa442a5ed1d30bbd98f6d94b518024c6ed33ed427439d6d8fc1830f696023feab5c1a1741b670be7df969a529ba70cf5f332d4a686ba98bf16f85b663e7c2ef28284acac455ee64f2dc4b61d80ded62d83d75ca10f206e4f03ce441f05e7b763e07a5fe9e1441f39a253fef69656c4137c00272d4b3e29901bee32fd0199f4df12bb3837f8509e0f16e82186c3d7994a8d02fb32f115a031426535e58f5f72ad3bbac215ba789369e2b378d768463cba7a0fe3a61a57122f9f9e70c16861950449ec41068e30f33f764fb078fcf60948e2d6e2b5dcb6fc2d13a47eef5a3e73c5d093f8ccb7be2d0d57dd40e8bb2d527bf226140b2e830d4346c2a0201ff9639d0135665a71bea67377df041805910889e6b493d247117ef3b8c85712a0c2aaaf8e4d93176a75584dc051d5a969fd2394c3ec9b6c17c598d972549e3f7fc1def96ed2b2de3659903087146d7f8a76251d4f2bc5f67ee53d33372cc4db881fbfc7a5af9709034046824e277626cbcc6b8be1b5dbd926f8ebf8ab8eb6fc593fa6fe62d6b47bbb89d90a9706645c2984438c7269d7a7c20b8c76f3232acf90a2822cc1d9961dd739955d7ea41c9280188fb23811f58d604e280eaf96b6fc734b9f350a4bcf7b6411483c6e94bab1ce351e6a593c523b82f05eaed5505e0f008330fee549ecd395d35328eccfaeb3aa9b2214631c45fd02a586bf1e902a6dda41e5e45061db8997147cb863e25c1502ad989315a342b49a40ec11e6126f7a6d99be813b129dc00bacb9e2ddf66b294ad96d3ad34bfb74716bdb4144f30b8ca0e3e376e18df394c36b056da4c70ce1120a855183c53cb1775cddb66d750321bc3d759ea2cb96b3d5e6e7ab008c7225bd0298a218d6fbbf888f6b23a923abffc96b5ccf6c6e4b0e58514c61b02d115b18eefc3fbbd86bb69593f81bba24ebf3d3845ca1489fa142e34af65a89421eb0401720e968e8b4409506758d6657d8287a281b77ff3755e92ac012e9370248db1554bd4b49a03fd0990df18a523871a8ad01617f6568fd0a27e19106e8cfe3b0776e0da3e5ab9d44bf8d5bd34e314d01a9d5572a7bc35b70f3ecff42a8448af10658037d8113cda49a4ac6a8e2eaa6515a6393dba502535824f6a4cd40356f1984ead4c12a91d7330d9d6bba6ffe003b38c825d086bb8a9c8ef28e7bcdaa4f2673e247fc0ec79c173409c08875c367e0d952205432d5e248da7d24fa719ab66c70f5150d1a0186d09dcd19150c066f1e03bdc531eb93ac101bfd3ab3ed99467968ddfef0a89d071830ec3f2c38dabf3468ebbbecb3770d2847d90dd4971bca049c493bb1b2702c3d3468da29a859a5d11ee8391edf5c4b1fae5d4c07b58ffbc9af63057d6d6b53f584fec3b20b5727a20bea84d181c93c23b344217e170db75df176d91fa25a2770926245a650d4d36f51b6e09bd07a8cd05d5ef5ef0c7665cef77e28d57a0f9e4f50f070c6ff234df450ef973ce42f0fe43f96864d813818b93c4e5ead089b7310c5b9e94a10c6383b9f68c5bb279945a16eb0301a5378f09442d632205d35198338c8908a8fd8a86feb015d723dfe34f868ceea21209fc0b899bdc20474e5ad642553ed7e3a7c653d68a57e705d0cba136c260df09d80bfd2673b8cd32d8b2eee1baa83ad0f6b3d3e03269bcbb8d23805a903e13b2d201984d268e086a4ba46ec555e20c06e87246bbf4aa6587b2772cfc3d52ddf423df823d0d11103f2b5396ea12da207f6de52f7957aafc601ef7427f9024981b9121b45c96a1eb357f059c5f9c57723540d267fb4df654baba2de94eaca086a770aaa93b649b4f803bd3c0ac5a4611860ccaaed75bd1a807294f64b3d979347460696d67c0b337d27e9e1f5ab620ea6af4a62a80e89444c93df8409597c0054b35d7d35570279f6cdbb3d8aad713383cb6811f1fb2db93dd1c7c2ef10511f215191a74b852fd416ce7f1a2a0793ce3d2aeff524a62b49d909bd55fd03b5a3f3b8f59c59ba0bd3a511a040d68c4e087b6806fa0310dd289f062ee9a10d403cfce3feeb3fe7f75f1b0bb132289aaad6d840456a5157de330c89da3986e26f25df4c531995137af07556b1c0b14d8ef5909a33c65a823a1cb02c01c8b53827062c6d53d98637511bdd675ea654a445839da586c5072a50e47ba9c18f295ee8bf3bbf32faa793bd7bdae249979394f339f792d43422cf7e9b5f372f29aa454c5d5f14bacb91af4943fcf62462c8d298e4013b9048cc4bf7ed5b5136face3e86fb660eb241be4917f360a6bea010c3bfa9155243a9b25f512405e95449e5abb02fcc7fc4644daa030a8249ad6d68dbf4f1f91c4516889b4b1887cbad94da021023e19fa6d17873e820d377c15d94bda70c39e42b3cd6098ddacfbb3850cbec8ccacedf23684ed649efeaceb5eac82be66f6a74f713bde2e34cc2f95eeaf64b2897d6d16acdd685ce84955471ae3b72fddbe78ae5cfaf89c99867a3d0e893f39d2d5b85cc921bbcbfa05ce81f79c7bbcbc4336f38709b165d93e7ead7bcc4c67e1b2d612a09c1f4baa72a19b64b9e33db0c527d9b41dad56e52144429360cac8b8295a758f69f79e4924920b834402530c7626f346585db3c9c34258dfeb03f3ce0e836191f9dc17cb2dfead51d0151f7b710a09fee105aebde3cd9e2ff03127dacf9bf13ce079b247ed81cfa3924e02ebccfb4fbbb76428a7481edc41337a7c3e76a6d013b378f789829f5f39f6d8fced9e7fb0e1dc0ca97825f1f40d2d4341752bac020253b8e77159ba1799d94dea1771a7314a2230bc3de9ac29b0517aa1a266b5f5d6751d6b56ee39da7c7a9a5b4e4b6bd830002d03ff262a16476bd28c013751d789c0e28f553ff26c157ec639d3123eafa0fa9f4ea393931154ba9dff8887adc6ae3f1592c957ecbfa58c53e328c2f3781381ed6dcfddb5ab5f31603fd699da62ccf6bb144888550aa0349bfbacc896f0e98a53c486fa71ec01561ef999c8785d6ad8bdfced703e5f1975be4bb56682a105d36cad8f6bed899cc7cbc3e2a0e2d36418ce6b744fd945378e92a558725d7c430406f7c740808767033d3979d76940519d2ab06abac405ffb15620bf5e3347ab49d01c20b0f92501ec01e6be4fd31d4666b899ed926b7d310882495812e2fc765ea0b61e4a7a227632165684556fce3b189847071685ec80328214ab5103940fece4828c2193d6a356925f36095ffc11dbe2000569bce354263cc0de91f7bf1fcb3bce15f4a1a701d78f7dbe1474b93df679713727091f6145d2bd05c95834b12009049298847d9f24f6c64d5bd96ac6f9e108942103ad93e636bff26ff980a09c2213c22e8e072aed5d085681b4b1cb608480e38b067bd1e87642acb81eff7b2af9d1021c964c7cb35ec0d816310def5b891fbe809def58ad725c4858e81a04beec4f95ba5cd322b4c0e442f8b2101823d30a0a0ede46e2e1eb206a1d66e358169ee2c60cabe2f543b468a2fc3a9f9d96020a4ae02c560695d9704a2936ffb71b86151a8203d76619a6a4a8cc38fb1342b24f4f4d14ad0d663b2a804fc82d019618886fafaf6a0a4a9df2e1ca1960a1a625fd66f1dd894119653b623bca1fdb21843388cfa14195c0f568b1d8be3073a8658c96051d21d0311d7bd95ab6247965496f1bbe4511e80c2b1e01ffd9692b10b7584520e85f5a76d9dff40d4e9c08b3f1d7401f46d91b27dec2325eb2614e50b4b7ec9ee3175b31acb18873ef8f88acd8bfdd63a4619bcb26397fdc3b8854dc7dc5de3ef2ce5332978c65aca4979da4ac2191ba3e556507c5ce3bdccbd2ac022523c25f4aad99435ddf1230df1cf33b15a91ec2c422ccccdcb225bacc55cf5fe16ba32c0c3373ceedb2fc31bea99d675e489ee6e1960c2d1a4e7f3d7cb3043ab13bbb7f25ee5edd423c395f76e87d8e3786e33b8bdf98e648b6ff21493ae1fb0fc003ded3c9ecc7cf0acf9d8b4d88ce32255ede0a1cc993235889d570ee3b3c6f93c61b85cb56564218bedf9619ded0c7647df487d9476cc4de85d9c023d6734584781a0ff3bb7a424ed8a49afb351081cf416074300c8624fff684cbabe3bc33467436e703e5105939bb6e8ddeb735205fdc63c584d2b448b07fea5645a71d11a183b15a6c7170db76a3bec70782af35a0f1c8f7128c11de993865e5ecf1142216e9c762e7a5a8a4f3c4a4ed572b7a4ecfa0e7e3c9a6cbe53dabfd8d76fbd60ad87862413d5313ff237929ab6dd3839aef16be5f5d09e5fde4eb2aa07f9b25b2d1a9326211b0d5c1a358f5381533cdf95597d2d355704a7d02e626bb11d44801d3074a8307dbc87a54c06fb1243253cdb4c67d03b615073ade99f7f3158ca046c63c3f9aeed9231ce6d6dd9e68600979766e4826a71f3c61da8fb1990c19ab6728cf41fde236d80a07f5468b7ad64bab3386f320288b3865522f3718b03f15662c304fa2369edadee599835c97d46e16e3a274808014c3c0d1edd6e6138e5e9cc101705af18cf3c9904fa359b4fd96deb6db27878a431a957df390e9b1111993fdcb4c4dc1316506cfab0fb64d36fd2c9119a58b6f180614d2da7e6314bcce794d4725ee076eb274c473e0f1a2b73a448dd23c0cb7fd47bfb903605e4dfdf112e04cc95c3935e381fe0653dc937c3288ce57657a826025772abfc8944365c8ac9c80715f77ac25f55ccbcdf7a9732286d573d4097d9d2014c9decada9d430a5db6af2b7b3de7b42938a02efa7b2b32b11125dbe57577db679afaca0c7eecd910f7e26de595744a51e7c56991b2bc78d81d92bc0ece5d5f1f4639b22310593822345c3505d43308942956bf186a044bbd1932febe42a9fa15bf8e83e289863c8b19da9587128e236e2d6757b4f8a5e1563359a0d7047deb4defa5aaabb8d3a63c8ec833078108e498f24427b5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
