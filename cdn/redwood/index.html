<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60e639dac52bfdade37b59f09ffeeb9c0c183590a2c4b8dd6ea0adb471440620661b5f9078f631188c60f0a11a14bfc091c0bd5ba2eef19155f3077f94db28a16018089997dbb77738fc89863d71203bb6af1c977ca13b2c221605fb2333cbbc048ede404a771773ab9f16ba69b7c098fbcbf7932799ae15f29917d40ed5ded63bedd13f8ead009392464d50e419829931a38f259c460a26c1f11321e02201e5890e265970362c49570931f0fadc058a2adf751b8b977d0c7bd13235d43895a178fcd3f3ec284bd6f3d2f5b301e244aa7780b37788b37e11bd163f1cef7acf3c2ab41aa7eff2415150093a27ff85dbae1a72bfa37009b2ed944a00ac63ff7334a6fa92b7a662c2ef67a03b8d8e17672ebc63e4dc14b60a9d264553cb3d0d8d5e1a4a3f7fe1b317ad471882657055439711a27ba4ec58486afe7444942cced496e520fa3a0a17ee38227811f2c963789e18143860ce4b137675976317d558c9c3721cf2531ceb1d7c401b008834f6ebadc64c6413f3a36eb85b5defb51c0f490151462dacb66121b118df2581dd290426d7741dc32bd20215a0380d604b2062e6ea1b02d5ec73d2f483e1b208373f822030efc29fa34f69f98e710d76985ec689e949aa9c86f4d1cc02a4cdac3b1c2d6a3e88c4b78905e6d93b7bc731a23bfc2b2ee608a1ff1ed9dbe142bf2bbae814ef982aaeb84654808bf431acadab4c1e1ee45535df3861f03fcb9ec7e94ad7b6583e31d567b21fbcf064a6745b229cb553c90cd9b1157464c144a3f454bc1b39c3f9e3897cc3eb4371a1723d28c2d20f5f0d1d589b847a9bd1f0cda5244b258a299e1214b9108852202202fc6155f40a0b091cec43b4779c4f412fa90936d1acf47390388b07dbe8b99d5172478c035cbddd49f32785151cab42064e2730f6cb439beac2cc2832a3c728b5569a919676fd91260162ff5595ec9beb2ab4d96ac9a7eac6500a0ad4bc877d986bfb5a52c4086aea8ec6e8ff6567868181b2ccafbc0c4b123164f4ac943c6a16d6d6d551a48896547605b16f56c3ab8ae2ca62e451232017df7b356d4ea2ce4ff25a7058439bfe26301bc8ac0c672642de772e413b55d86370038175638a33e705e20b3b6ee506ca4f2caa0089466ddb90e48308c10e7fc619083819220c7d58883c170b90d95565c7ac744ed8eda65c2678dbb108ec3eb5a6c6b09c317e8ee808f9c655a7a2f191512f89e30f95f9154a378018e0457e1da9ef3304a857609ca6d4734f7b1a0ceae8e98ed11859da3c553943efb0b41977d926fada6e212f57e4ff9c8ac2d2664cf7e46eb9f4c39f7fe2bc315a7bc31a32930d9081f093e48d7d41e5c85a2c03f81f796abce4a7493372d0812e85596ca39acf04e9563d09a6f7680e2772a59aa682310c057b8332aed5f6cf01a8050849432408449113af80b3accdf64eead196ab1cc5086631b8d327d6cbee6088a308ececdbe0e06f48840e7cff161050a2ead9bf560790ec3e78d988a49f9b6a5dc5ad511d6b0e300bd58064656e9f0194e96be598202dfdb85985d1ce020f8e65bcb58dd4d1412831ae66981af10afc4732bcfd73b4095b421259fa61d8a72fc226e4fad73e223b2f359c86975855daaec978e6695845e28a6f5d95c25f7ac7e3b1b23b384df30c84e088e8b888f3a97e8ec83efcc0f25016a1e2375eadab3a9b2f54458bd00a4a712704003b20193e3573b98267b5c5807c0fa2c47dc56f69dea25bba6ccd15940382531279891b5ab0a138e89de92d62799f2c9fceec9e34c0f8154340dfbc79043cdf4bbe39583f5e480682464d81600602364be1e6eb9f69b0f35dea62560711ec6d7c576671150b88adf202c7a0b9204098fcfa011138a0ba22cfd750e877431994c834aae9ff4b5c3898528cba8a0aed9b8ccd104c0fcd7844a678d10282a8d3c44bdb7a01a44d0c9c53815530bd3f83c207aaf00f8e21dce530f3c22a0a1c366d34d72a7afc2ffaa92f76d13c0796f0a9835478b2c487e8eac18349f7abb5cb13aeca499ff260672f31607e38f3a67549e9a41cb707a4abb47fc53c682c8db80fbe452eeae4447713932cad1ea50e14146955d67dd8327e747322c257b81df9a5336c0eb5287d8142b5b98582fa9ffa0a8ca7fb5d6f7d4bc27503d80f4208c6227c4df697ef6fc636eda38b92d691dd921f431de3ed9b6f0cd378d510d024b74874b6c58cd52297cb6d70de88bc365bf35050f51ec61a0723437d155a60f753aa9134fb5ebcf0811af6f56ff2fa0296bcc67c2473019d949c0e4a64f0c2f21412a3b3ee4f2dad66a976537ecd18e455e60ae56afef2da4902fdec3fc2af8353e20b66c84ab8f01449161082537df066347907757f321ad4b7ef0adb9b7e55ce3984a11d2e506ebba1b8d85704dd466b984f24275b8239d6eedae4bec0112ecb5d68ccc0e3c3d34c0e59a5b18629d6b4ece2399c417a050641fa5ed68b46dcd402896b3db8b9f0bda7e570ad625a8ea980dc71facf6708056039a6711f9afb9ab106a63c8e28177c2c262e54386ba627cdc3312bf78984366ec77350c0ea9892d9feff26852ce0b60c042701cd0ed24819f32e27b372d0e31add865a1cf76036d14c80430ea65ec079b81f0d6fc496b372bf013109145424e0cb0f73006f1015c8da54e517ed05b9069841f130b81d4d49cc8049203924ee6e3ceb8efd34085df403da69c3fb85647a8f7166e40b920e631241e674ef7c77cc319aa189c2395ef8328142187ac976f8c6619e46dcd08922f460f885f75eea48e587342ff8d48fcb4b4ddb70ea3f50741fc94222f51c6fa013bb17e7f60b9d063e7da2b88064cfd3c3f96528cdc185b827cb8a78c224c39221e84910efed5f4d72a3ecb5ced29c236e7227a3ef7ac9a8a3347b2d64ba61af1d56a9ad5a7b64223da80a264f3e77a67675c7aab1c9c0148cf29cd53c9e61d82ab0f3007ae5991a3601dc9d9d1ca27e6b69b82bf0f8bed606b260e25c821a1da35c669c7b2170cc8f11d88384be781716a33234db175681542e228ed212a8fc14bc4d42d3dc2b6214974ce82cb90e1b130a382996c0745e4284aa4a36579cef0aba8115d9c4df86bec6bfc3bf4f04f19fb4f83257e0b1909655dda4762600c4da67a25c1a71a586d97377a0fa82d512e5239f2575affb33109149ed97b26b2f0a35fac27acfaf18c4633482c0c3237ec0c0ed956e370e456bf2c516c67a5513db2915ebd3cb387bc3778397dc4fc091164ce5183b5ea47cfa9762e2b113bc5f92654cc4bf6b528621c5763f2a38b17551710576dad910db81f8887e18d2d122f13a0c0731478776b5d033eeaf96daddda0867066592e2dca1fa04ea6adb1bddb90fa79373dee9276cd101d560c00496cce0b2d75733717eef8bd0e680badab6babe141e417b91b7aa0d66abad297fe1a446069fface11cd0a7dcb0ed46d2ca56caff79821c97cb6e6ab62987853d7bc9be721979970232509dbe84d392610c46d1e54b8340ad414ae254f35869be1b9e05e51be5c788b5067f8617f7746ad9eb4448808222ac27ab7bfc70adf8fe3553d6d5df3793379d2381f0f5829a0a15cc5b485ce2f976aa8bdbfd2601d5bddf1ebdbe0c7a09ce5f12d393f5d7fa77eca5cf0716a7b005f12f102ae2a7e515cdb841a7748b9932bea699116c75004d79517a087e348bec7b23c1846962aee439a250c3fda9427710d96267d276a4e0d9fdd0073b0abd305bb2afe7b25ed1f47f4994c6e22baac9d0080d3d65506ac2dabce263230a5457fd09a8fe590cd30db9e62f83ebe1fda4c6e9a83a75c976fd9b50d75c30f5c2960333b57adc8935ece55a5691505b9aa81a58c59c25350f712c7a2740b8749e8d31b47da42c0c1a9cca5c8fdf38a95599270e8802eff1d8a51c82b5a9bbd9b94cf2cdd371debd7e6f6fe5aab91609ce5fc7dc993203d83f66748da13864d0e7050dbd651ad1a2aae1c60cce52a01da64e22d27057009b8aa2714538f9b8372cc1a2add2ba0b69dfc00a4c504c55cedc14a534d345a530d15e5a6d150c9d1312ff56ece62e35c442a58c1874e883275ac95fc04fa76259e0aa4c963ad5c4e623e0f6b7c035120ad5e44095120fe5048279f0619fe735f95a9e82f91fc42db496869e4ab271cf641d655ee35cccea478b0e91c83176af43b89c4b3174a48b2540061627acd249dee92d327ca6e146ff04ac2b37ce1dd3c102f8fa0bcd023df1dab080c1d0398172f03afa9a14b0e720ee9cb9ced030d7fc2cb67c1e93edc6f73ceb49299c316d01719cb8dd10ff5ab842cbeef5b05b7aea4c202690f8c076c805a4e3b63c0747e6f0dbf5384c219aba64a261f11f9034e16517123069cde58aab95ab696b53e28eecf50a647fb4bd8d7a6ec8d581a6a6829d6a8427228e27b8660c5ef5b0ddafdfdb2793842b709091ba85839a0ed32d6497371358ae33abf5ff25f00ac1624f27bb1ceec3b9ef2aa9b97b06c508dab85cf3763e2b58d47211503e5a7ccee77b1d26dcd8d37d57adf5df708d032ebf3f5524fa9cf6c39c1e712d74e559641d9afade0258d6472a8aaf215812362576e992b66ade16b0d6f2e582131c4e84936dad0746349a44204b95e4536a1eefaa0421ee146453bc3e23e933ac99e746b4e8d9072e10aa5987c6d4a9847fc66f50562de05cec9adbe52efa9dd9cc3bc1f3236e43195b110d60eb12e1878e3c71c0394e6ab923cfa048c06d1236ef20c0e439ded91deb3e97fb6a2605a2dbb9afcaee2adf22cd84aae6ce0d09ac289038368174ea73db45d1e72260b9dd50be5c0e1a00d84f3a383f5a81befb2f1010f26aef26dc57835de8b8bf63bf13ff7f4f9d1eb3191e96c097af58a09c0b0b5c27c6c2fbb376b44d11dc4525dbaf5d40be0d97069579d09042e81f4c04bc78d7e99a676f891f57db7202fee448cc2e6832faabf5ad057442563225705130d4fecd55e16bbdcb9ff406369dcf486a2d3e945d1cf24d9d1946de7ebe182ae810e7d5376fc4ee66d60b4820127c36f6d12355de78f2779d013a90666a09a4787f7f372c8f614e2e9b0a6ff3edc25f20bb6462bc0b43f77ec1f964cd07e62b8e81e4ffceb575d093953bcc39c02a55135ea823cdb84cbe988cd3f65806c9edf16a21b2c1e75a1edd0e73eb3a39604195adb6d9fdbccd4e02a06c3417b988bef8a19ee18322c498053391c5cffc0d9816ba17c78fc30725e5f62ce185d579f87cb7508341ff69ed9028d291212cfde2c79f6f8f07b8b44b5f3366558e2de934606daa2af4bd90d07a228f339b3047115afa2e0a16fb6975ce59c252ee02be3c839ced9acc52502575b30aaca271e3289692a8324afd603bc601aef66472faa3feb6779bbd4158e612191a72bc8f1e9f4a16b88ecb34b3b14900b4e92f604d8d41857e75ef054bea4454538854e10deee36d38d159e073d01d5f96dd35b01814c47444e800d44b5209cfac987b86a8f1514a23ca3395e8096a80205270855a7a282cffb4a35f9b509aa163ef21896d6f0bc407ab454cc98e41d302d287473f2f8dddf5fc6c18f59b802ccc4f90c0050e941dad2c6bcfdffdafd1ebf8313e5dd14cf14a6c836712beeef967df649af52f756e40b6b0d2754a28dc52bd7dbc0b3dc7a28220449e819ab8e760231165284daceb6ae21cfa380622fe00165e1a795f59fd105f1eff22f142985ec7a24b4a47ca3e5dcc8e625c1e1d3db3dcf26e9a790c9bb52043d361b73a67698abd83888aac64243e8fabbb6a0ab7cedf4fdfbdee14fbe78465321751b54dfe5596eb52af991a217203214f15b8760fffdd6bb1acaf5f9078519f8b8ee5d487c9fb892210820128252fe6ee42d3155bc2f5dbe140d250fb9053a34264546c9dbedc2f3dc741e0821d42d39d97a608c453f1d4255ce7388b8185a88095ff37ec514a353e170a85f3bd1e93331d5939e1e4fef5ee10b56dba053980d689ce903ebd81b691216e945b51947a4fd27423a957bfde7833b623c4379b6bb44e33edf2e811fc2533a36ce211507ef2df6b83a5577e19dc38fb813bfa90380ff463b3513a9d077aab0bc23fd6ce85300b1f9c9927d499acdd9b5ec6b46b8d582a8c09e2f258210ef6adbf676d0661ecd313e7869d4ecab51f08d0ba9e81cda274bfcc64184c3960a0b75e9777418366a9c4617f910e8b97fe8f235814acb92f57150663b8c019a72485dd326d2e46759b4cf26f6083b05fdccf43ca867761e1900e6862c64e06a220108d65b5e808b44a12f1fb473f1717a023a1ad3121689373f828060a1c731c4bd579b30902019040e932840ed5873a36e41deadb18175545886cdcdd3815063c427893e7421d2aeda4898e690eb879d39a6d68359f2046e74f25ff529a517551a835c46cb88913067cc017de6050b462ccfcf2aaa543c6652d0b77961cc05137d5387dbca4f486618c3a4d9c4312f9be1a1cc6de211be5ea7d4807f96ad855dda02c504914ec6a58cea0951a29ebe69604c624fe0fa26e921bd1c1ee8c430fc50621915b3bc3590521886afa79a014075190fa33d7ca411f446f26d36e1526fa6406bec3fdaac0e90860d0a29c1f6a04615bfb48c76ebd62d14e07dcdb5fb17947294a4cf46378be9368259eca77180725d8c1a877c90fb03a86c41064b2c9b4caf4d9a8447a8a756c08ed6eee113f100c6fc6675fda4641ab7e42f57780a63cf2d9162bd301772dd4fec1f02d47956880d50a56d75ead55b46e8985dcb39169b30dafb343f7ad701462d7eb19347de966ac9776b575348ea5681526d912463c7b59ba15ede551d3fb26819e17458570526a095b99bb43b3eded1ff19bb19e5de36b8276e2acea3be91be6c9c77ee7bee480d7211053858c92e45bf997b35419ba24ec250dcb827903c57477813e0b045fafa9b8d49d4c5b8e6cbf6a45e057f4517f8a127401689bd86100687ba5ad3a2666af356148407877df19f7cfada287a4aec4e6d30003e3a2a511ee2c0c22471e9857c57c8f4c748675b0ac3ec4301582f11da252c767081e69c9293f6314278319a06b58df9581fd5cf93f8b76ffbc0bc4bb2bfdb5fbcf33c8b081ac4175ee4608cb1f7e7a802c3685b03b05092b439eaaa2435a4b427c7c9d32c891e3ba2509925ccbbc581ef0de8ee856d9ffe9521e9911b27b84f7643028b49b1c0222eec4622db553099ef6c482e23d139faa74cb34a840880da60a3e73e0f0764d913de48f3489246122af94e401fc1220c26b34915709e9758f821593cc9715048064412822cbd61d539a929db828a677922463ccbc943ab4340c6686d1580a0518c1cec354c275a200f0d7dc2810d87ff523dcf1880daa5272426b04686167470aa7a33088bbc2bfdaf5308ba2ab163927d585f4ee77a440655c0557619e86c2ed97efc31442e4135c4a4e73a42e852ed0266b67e88d9587e34198985e565832c70ecbad9db4ba1d63e82d783f2c7408119d18ecc20ef3688d453bf820d51ff48deb67a359f188298875c3ec5dd377929816e739a84a5499641a5bd9da71fffb385c2ea5a8ce9844b35edcd3be7ac009e00a51b66a58df1633e1e0ac2cc6dd07f6dc56d416e3ef76462a5e3a8c92555fbafc76c3955a4ebe5f2a15f7ddb38da7b6bff5a0c33fe93b7ee5cb1666b0493c2d32b6cdc0d7197ac0eb9b65844cba24f6929e3bc2ae7e5a307a03b7a6e815c2e8a7ecc6a0388de8fc6f875144ed238f33b772e220ea01baa10a3dedb9aea9805606454849b28a7a7deb7635c9a8b95cdba440d2bec0c078c6a6eba8351ecbdc16ea8bc56e7e6395f9f82bf2d3b6edb2f1f5556904192d442ec99e35cc6bc00b233c3f5923aa3a17fa75c25fe750234cfdd0d8e50ccd02de61d08a8d546177d5790138a35e91be5e384c5b4e3feeb7f51268cb52ec78b506a6224e8803349b527751a4deb5f0fd2c9100410a7890a595caed479a8d89728beb60f6427a6ef32a3dedf46f0a7db36c89540e3d22101e948b145011d8a0af4f2410d9562cffbb484e4009280ac27ed799a2fe1ebaead5cda40c026f3442b62e09f739a510704277b1758c3c74ce136ad5a41a31ab85115d1e85d8134b653b3a2e35655528b8676488f4df5c16b76fe3de8c6a191cef8ee3e7c831bd9d79146f4d833ff6bef6f4d0d22f34577b3915276c2c452fe66097763916036db6abd1c2e54059d8a036190d1a03e4cdc21cbc19d33b8362bd2e669ef75a91ce91e73aec9c7ce4383f4c4eec82b5e76db29095823de930c8969c3f536d818c6457c2c589b450020b5880c67c414c35f3dd08e8b8156d0c03752220901545ba986b5a0f10757b859966eac5f84eed26eeb5f361f2968e5050f7ed3bab2f7157fa396f0b72196ee1a8dc6201a20a0eebb14b84473b37e828d75aa02aef9f007e4e0aefcfbf27b62276bcc8d6b454b1ad06b618ec33c6931befecfa0cb2d12be933a09c380fab7b8bc1d4d945eedc6780c8f624774463a5fb93b07b86dc481f67baef22c344ad766685e6b2cf2416185e52ef47a084df678a06d253879985869043fc9576e84b4eb67e2c7277b9665a7cc255738e47f85710d53aa2a6e03d2613d210f0ac9c8ba43a9d8cdb4273345fd024f95db776254ab174ec1e5dbc829402b0b94b7a9a83e4e9ff35c5262ee58ed499b3ea9a9e278b64856679f27ba497f2bd3e73edcbb80eab716432472f17cc7e1cee2ca2db6192a8dff7a2a35357ada86d81362bf7fe8438fadb6464e6c8c1947ed6be0582b31b63f4384357c0b46417769ea2b1a2d6765132648bf137378d48794af88442088a4e06c5e83b9821f92a7e5ce8054bfb6fc0639dbebeaa01c2d8d9947b7b5361dddef7cbba59df69c34d62cec66fef850729cdb9e2b3cf814c1d7247b0b516d8e748491603aa309a415b868defdff13752cbc7c60782af3d5a25a4d26f5198b76483c4c6e0761840a1e09a91e3ced7f41446289a0cf21649b6732469a8cc8f405f7b81acbfb43598c074745e2c58bb5fd51cf103d94e556fee23235c59abeb483465ed9f43b443bea86424b0effeb864d542c09952b93952f16c1ffc0c4a81fe3f99e1c2d1d220a5fff2f9afa7f2429381a1e461f38b4568c86a42bc690433d81e296120bd7b79808e9bcad2cb3e29cdf8d0f631b80a9042f719cd25218ccabd677f8a8bc744fbed243e0b0a1f088675f706d8865592bc7832dcb4e470ca6b559f929004a1ed808a9653bc48a3c419b08be48c48e2f20f8a89abbde18715fc0685ade01b0c3fe4456513abd207282d68553b8c9362060990c7504956ce6f6236b85b01295c671a5f37141482aa35ace5d4fa4f4092db6bd0482ceb0bb2377fa41e0c8470c775f8476be1b37f8300c65ff7c6a9e539b5c46c40c8b2d974c7fba13d39dd74a21ae738ccb0e087b317d8c27fe1f7a13b53423eb83a323ecf3a33d76287a9bbd9187d31d93f795adf3a2d1e9091e137263dd226e4d5975ea437ee4d28c5f2ed06b722b89d97d83d1200a9c29f632a64a5140b692150a38a0a6b6e8bdd18e9c1636290afec01110bec9caa02794257ee69cd5738e6c89b5d084348278e977c5b8ce48f35617109b4d87fc2eeebc099c6cecb76a1bdfa4ad59894aca590d48db4411003eb071fe2e164386290c313a7054a522e2666145e55d52bef7ce291bb991fa16a98ae1755e876e32186d8c2f091ed0a182473bd2098439596622aab4ee476c12d5755c2be0292ed95530132ed6d8b9911d3f28fcaedaec924937f9cc626ee83015767d18e39e91470a8040b84112e8ff15b73e371884b0462c83519a9f7de527b420406bf0cdd66c8bba13af8fefb56b19eb88b966166ca26db98c1007e6ca0be282116ba9503cc7f5075f019d68177ebfeb8e47fa606bb976854f52212fc2a306b714a449e9081c0f33ca13e59a808a672d032a5b62e71277d5ed079894c0c1ae1876b5e6905163cc13c492586811192e2b997bb24d5ea021b1ddcfc5add95908d0b9b507373e48fe5ee7f76ffed58203963f2f05b2ea786e41682ef9ea647bec64193eb965637e74701eb45b5ccbe7fe2f05bb46a84944e25d7d571eb161ef1bd1f7f85c2b7816896b048b56350acbdb8a472dc24cfb56359b97bfac28ddaefab719719f975e5add97a346f22b760a6bc05726de117f8c6b72c1e63b8555bf48bd6c40dc944996c15eb2a6a16e5fa68625207b01236bb8e53843c232502dc35325e6680e29f1889945576412bd95b01343b95fbcb8bff9d5ccd9c6c47e5bdb9fddf1b2fdcf7e6791a6d26b7e4d5fab51aa5a6d76be0f70989a5964a1c87449840bdae3899597be8252196212e4486d0cc690d1d706570a37d7612015d62512e6eca26ffb03e2d44856ff2b32d97851a1a85f91d5244fe9eebbb055e6d7fda803e1e9afd54e7d2548c59425bd166c0898c7ff2a63b6aeac8929d2f95a8ed7fb40bd5c51d731f6195e98752c8acdf7e9941cb3c355c8274d347627d7243a89b7f35430a11cd799fe6f1dc111f06505204972415f41d5bea7298c14137d6e42c8b58c6117b9b6bc2569331d5cf4f66532eb572863cc4866dc915f651f8fea7f12aef6dc4f20371e0c5917f7dafb20206bdec1715176aafeb7d8e046edc47f5ddf3e3acde6f35c9e8359d4123d23e9bc5adb537d007c130480b340f7187fdb2b5ea46fc813e449436f36f93ad2e9bcfd09908e16dfec0f73bb1c6247f65ca4c8c20a854df7d6b57070cada9ed14e17840f4fe398853239bf4e3f902c3b2bbe88e552ab663055a0942d5ed990c01b76c7071d1511e2c3e3f3fa8fcac6a7fd15668deb35e98a8f3f399679ce08d8fd3a604bbb132340fcb6e1e65f474d978be8cdca0e2414ab1acb8c89cb73a1f341f8658ec380d8309158656d4fe98959e9d821c5fe8d21d56899beca1a40bbd5f4f1b5884ad5afa5229775247f3eb73161ce9287dbb07762ef1dade18533f83f6dfbdce376719f717f1625b3219daa58a718aadc2e8a20ed9f2bb3f12284b9a3fcec31573ebece0651e37d5a12c3eded0b9440b3ebe4e579ef8771848bfd144f26f7419c79782c204cd26265ba27af596bf181aae85e239da16190d4cde241be546fc4e46c02bce43e6710b2e7665256ea3b51cd18e9bf03866473d5bdc3dc434e532547e207ceba1e0beaf3f4f354e88d3f79d1299feb1f7d4203a1a00da4c5a6c5aca06be84d0970ea4df48bf49e88abdac594d1d54413bb9ea6bcd53fa095cb4ccb85bb339058901c866da5fe71ea882969f2117f631a5da2510329012769f2452f5ab025dc955e410c99b973c3634da7003104038762b9684027b461fed5ce818bf7f6f30d5e3b1d5594f9bff1892b14c3429b8554361068be4c2292c65161439a5fd07b9102fb234a33ef9d0f48cf598850aaa3ef922226af3480585aaa7d0c1ec7e627a2764121e27a0ca51ac0afcd8403efc1e35dc9ca31f610ef1e15824ca0bdefee219e7f50af2eb039b467555d8b6c406826ee834f6e51ee43eeb35607623c8ef877ae84a2049578d5b21697b8fe073d6575b9108b31c9c5acc72f44b6340346c6f543872cfba0c5383b27c22219e275d3779377487296cc9f4b7e787e8b1a30541ed92e61002ab6609d67f7365a518e599a4d918263b13ff477992771541cd8ca70379fa7a298ed12d0f60cd605a277c3bd896d7f29916fb1920ccf20652ac163951d8bd3bc09f0f731617f5dd3b10cb4927dcff411b8609a90dcf3163a468ef05d4e24b5bc694aef748a71a6d545cfe61b97ebd8ffba768eb43f488d800e657ab6e8403ccd4b32afd61b6d0bef40b83a2b18d6cc9a823b9b0fbd613dd6a04a5f291d7277bf8aa32d6df1158f92745d8b648d2bad2561bcc089e361492a6201ee6c6bdaa40630ec56b05abccc2243dd8918ddf85504450b25ecd49447ac4d3389a2e45348881bb0419751eec1551af09d0e85afa24bd603ab2073934dd133bf5cbe982e361b308817ed8db65f75b955b12f20f8b9bd88e226e09cfc50f473d3e8c34d9645d3840518d935d5b79f0b23c400409247ea7747ed15c6588b9e11fedb8305cd85165d724b6ae3ceaefef5d237b7695cb02759f7fcc867b6308ebb14076938bdeac348801ff49a87da83ef0edf98f820ec6023f438c6caa029ddc88217f1a5dd57dec0b232d76034806bf8af1680fa44a6eb0636666b9a526dd8e8d87cc2dfed77197801513ac42f359f5579df7ad02cdfeccf39b21d3d0035b436f462f7edbd83d094240f4fa5e1102d4178378aac4e8ad6c25b4527ab7a0bc9edc3ecc0f8e88e27c2c855ef730f88ea446ca5118fdd125e89a75dd7937415c330d8161684eb469710ef3c00fbad287a0819b09656db0b7d1ece866db8eadb97213bd3533647d27d972dc9d3c2ab210aee93cbfe0cde1551d48cb493e6b0862e697c96d8402b2adc3c43124515acf83b638e3be8da8b32d26ab5532aa555c6c87d723ebe1129d307ccd6e26d4ac30ed6be894f39130f9bc9ba45f12898e2ae55ef5277c355594380436720f313cb5da4d707cd624965bcc93fb5750ee5c5c8864939543ff111b739b100332fcaec36389a2d9c944a6c94353d160c4fcdfc2348721bbfd22fbbce8f0a04dae7d6ba87bd621a1f6b22c2e10d8000adac67fd1aa857755793573bc7c32bb76224da6a0f679eaf151a7ec06342b607c7c0218d721403557c61101b063580be3ecd4dd59923f6d5179b5ab6ebf405833f2a7e7ae0bb3a9fc158368a8239c68ad96b589f24ed4c01557727fb4d5cbf5bbd7a6383f1d4c9c42756fc50a1b6971e52cc7c9b18ff9f28257c0a14216b9cb09a560fd0c5c3bb7e9ff2d16e3abe08f5734c647a6dd32b0235ac901ef2ad6266cd4553b305742043fcaee957375e57a1f3bde3ea5ff8fc9ecea76daad6876daf279834b9476b0cce04cadfb08ce25ddd4dcadb4b9ccfa9cd64a762cbb207f0014c6c510f42805fad3e1dd2845fbfc3385d9a7a8a6f3e1e82ef3807528c56ce53d6321aac7289a362c7a7629a57c25a2170642bac035f2c944ed2de6b29cd9829c130e8e6bf4d9b4b13761589d540cf0965d2884d1995682b6f04dcb42b553b7d97c2930db7c6ffa8c6b91bb6c11f1fe3a65372ecb3adc1873d46ecbea94bebb29c2605221eb3cf845ca4519ffa58431258fe756e1a4983a1e60d3128bb0a880e84bc89af5edf1c108af8182fa051227e9c039657b79a34f98c25327317341c52988933fc555d25fbe34f6e904f53c2491a612cc32745f3f7fd70fbde5b5f2b174ab65304522e5ee25892eb837892e9889e9e3107e9f5cef8ad71c6652a5ebcb364973c9551692442e40a54e803e186e9270823861597e1188ed182a1fca8a4881cc6d8eb613809be240d7739b7b576438bed884e7e555890fef542fc9ce3040cf5ed35e3fad5251b5d4dcb23f0b5ef4bef0425c27022f53b25af53643747d7a24d6ce3a80d2a12efbc0d9aa87792814088bf722f38ae332b39f66d5ee90bc98b9287a10030349e58b968e305046c1cae9168f9afbe282e893aee5a5edb71b71874be2a271d187e6e87267d1620fb944c555e22f294fe90d03cbaf0d4609de5076832a186da17fbb0c7d08559ad3c8d0e19610d235a4e91553770d23f9a6427dd531d038b25ca25bc252710fdaa094953641651d9fc34783d87845fc87aee250050514eb235792e3e55665cbcffdb408df7c9e7391df23e77b5a561907162e6a007ca65f46d0ae116d040bbdf13c0c45a59fd286c073e6e2e9ed13f7d5a93b7e781062c86cf96bb89c8692afb61aad92c825d0fd50357dd001adeb3e5017fa391b924e25c948d5c4e8b6cfaf5a685a6ec1375aa65edb6a96bf9c270096c956e92bef3e6544f993a4402225846e7cc48f44a6a22bab3441d2806251fbd1644f5de7b3197e387babf82dfbf6ad816f8edf2b3c58bc560f1a526afd1c3ae1a0b7535be5beb660bbfccc058c4399b2ee675d46f6509223b94be5b6b9988925b30eedac29d1ff492518c46f8cf926bd8aeb03c222a3874a148589e6b64adabb9156fd46b7246a970133bbf9d2d3bc35f4b333e2a8bce117d98bba39e5b475222c214a157d371df01fe92a3239b0f57da1bd248cf7ad7e2bb5a30a6dd84595eda17a7bdb498aaa3fd2c9dfd7d98e20158d1ff0f4aca3bb3a1ba9d76977893b56289a72c66258812be8307cb271f508a1a1397e159662615d286ee382ac0a1354adcfef5f5b90ee4dc4ea43fa9bbf9eab94e19465a8141f231c38fd410186f91a05bcce577ec8ceb235e2b426f60fd4e16c043c92326fd1a4672e6bd3c3833cf1220bef9b69fffb66b4affeed50535fdbd94de80a09ed6f1647bd337a740f838da615137ebb84113f66f0341f61c7caad5e27aaa2620f80fba078a9e8215968be668368d31e9132c02d6c77a00be3dcabfd991c204a1c28cf1eae674b52c78383319c39d0b73999678b6fb61082deef497d51e02ec70f6a41133330da6913965693da0b3a48fcd157317435fcd48c006fde09359496100b469499f9e8fcfbca0c041fe1b0e1212263f2bf4651da5d8998e1f18a4ced8e0a6dc4188558f95fcf86f71b6e8f0fb975ddba79d67f61770ab3364a785d46a57300653c6baaebf3e1006cd9fc240186760698fbcc3d28cdcc6d6651127858ca377bcbb40caf0bd194ae570c7f1ae8db7aefa520e1f897c638c3195c4bf2d2d73ba6566ddb2abb2ca360c193293a0e4b64fa3538348e7a5295166772b69819c3a707bf13a4242fbd2f2d358059a43ffa961b4cf921837be76e19b892101b153e150884924f02b2763c300e36c44f5dae0484668cbd32d02e78328153caee64a64c3a1278a954276b00eae7cf7cebf3c83d4f5eab95748e0f91e32ee7c87017107259bbb6efc376ea34d84455dde9d865475251695af9df111ccbb44e9232e5311c84c82d01441924693822914d1e9a33f0f5b1d128ec31c9e097861282bb3f0f3e029ecc1050cc3390d7a2fb85d650b3c9ffd5b75bef280277d52f168ab400eae18938b1fc6a0868a82e9c0be000d902cf28592b1f50b25a6a8a4653467f116238650625ab7ea9bbff58c6a67a8b56c00bf2a4e233d54cf4dc1c291828a9ec430bf7cf4568cb5c4923ad858390c5c2cafc29f36aa483301111685855a76472dc7b844ca913908b1a1ea8866ff390df1bae1e8a4b86b494847c1018ca945d72a5db7d1fdd3bdf682f902cb9c5091b7daa0f1fa09febeb402b6f98da9c2009b41ea675a1832e090b050d86f9b8a6d9ffb302233c2b2774e91185503c8327cdc5549c5c063fa1d3ed8d3148aa34f16eb6d9d2c86bffe95e451829454f525c988f78def057e4f01bb7d500561e9d4bc39937ddf48eb79b94b7f6f059df78af713e45d8514a984505414ccf87f7d021de4c6a81be44fef1625f7473340e817bb4afa46d87580b1c68b48f8167b67ef6c8743a02c2c9bf89d2c3722c7bd95aeb89603004dae793af8792cbeb9407a5a7e871f764d885b621c34c8174a56ee85e086534e41e3e1e28c2bc18f9a52c4c016431d1c8cd9608bc5e82a37e8b8ff81b87b511fb0217c00ac4b568573b27544555ab5a7801b81bbcab06f818848a3f57e1313de5476882bb567e5a7d018bc7b126fae4dbed338333f599d621f2cdeff8139716861849c40047b0cde5d25fa63baf7f10d2882bf827003801e07f4b1f7d03ffa7cfde89ec61a43bdb1c3856070d454827346eb8ca2ea8b9d297bd6fb6aab03ce9e94a0ffae718d73d1c260417a82c26b8cd775ca6df707c11757deb066a56a6a4c76b957a36b7fed8bbea2d64a96ea01bce50157cdddf6cb234706e377ce94e557b0d9a869187a41290a3e25b28e6f7146e2281e57d34cf18495027a7477f7aaa84e384cc030f61f430e5ddcc5e99786c0dce8e9ccc1d9fe072f067a483b023e335b599148756eb79c3f1e55fae580c50f8d2ec526e6a8b74279a88651263cce0522ed8936fbea19fb77c22b60b0e0fa8ee8c3a164ec8693ddc1b558d9e20277c28847ced4dbe917a3916f517cf60bb8d57d977f5b11863b6ee59ff2c271799511e0cf0a0619f546f1abc433d98a09517df8f269b331e1c2879f71f6ff7cf914555d56d626ec94c4c95912a6bcb46d0a6a5dec4e35f3a32cb4587b6737950cc161ba98c2b811455d59fe7b9becdaa494f6cb58dd3d2cfa5265c2df556f42a47da7e2b8c5fbee045d26a2000a79dfccd6081b17450a4cda2b09bedaefaf04568f6dd89fa914cc5a18533b78a360820de334b205998324af44beb7186470fbdd13ec0b6fd04a8ad0ddb12bb57b514d86dfd06d207d5599ecfff8eabd0c62e7443334c0f48d76aeb0ee19b61512b703ac81a8e2a45326297f3adb6c088f551eb95d485da13f1bd5facb17ea69e82339550a33be8e77d2740a14ea1b40d26a1f9aa110798ff71cde088d83bbb3b800afbc3e402783f6c54d47b20e8327df86aad6148b9ee2604c658490a9b5bafef1145a610d35a154e9f948b6b96ef3f331ceb9fa02c9bb0c8eaa344d56a2f2b63bcbc26e960c3bb511c265a1cff4f7064805fbf605f2e9a3c1e56355f64ce5931f8812608173c5272904cd6edb427c6ce7de5b19b354d2cc15b819c2a72fb39f4c9ac1c3e8516eec3894d1ed725c6af7f4d971a7d215115a47fbe1e2337c606a077912bec42c9d81b3fea1311e5152171cdc6c70c9ce84074cc70fa37a493fcbbcdf621569584b7e34d06a5f0937b62aa04f57983d5661807c86d04f36db1ec3beb87fc278911dae81da4b9bbd6be6abcf7fe794893473685dc22238fc83c49bc976f296c4b24237e3ddf320c3e5933e2abe42c8d718b932fb25f990156ea71d459accfa57b1d47b7448104d4947604e5e98871ebe9949a48501e7e01aee94025fdd8e86b6a2376f309365d644cb0ba5e094a0c33488e7f1ece02af6ae4f1bdacef7aca1d91bf47f1dc1d62dd885e720aa998b371efd64e652c68a566cd4e7a2aaad2b723a73a7bb0b9828606da56cfb6ca40e21765e97f22150723f80cfee985f169220122a3214636837264909957b08da961722704778b2e76391573d5075a6cf38aa7859dc2be8b1fd887a9a913d37d96b3d81e9f4d17a9d284058af8286f414df50cf9f2c6b0992827f4ec88d2a076ed3d0eb822e3d4c4ffe3b967eca046080fbb7b24e5f19e157d15df419e5a98fc0a510e1330252bd6b812aa106ec5c0e1410db239a9d8733683ac83606c2c7b8611a35c362694f5234b79fd454e082e8ba2dc2a18aefac49b89f14a2ea111546b0a69d2c583b3d85fba2266e308e9c79d910b03c9e41675397a8ec27226b520019f2371929a920612f17eab3c077db10439ef527d4b5358378fe699fc64ca3e370aeb2159208ec01f64305f6f2f6de98aaf663c7118c268f550c5a497bdc4af9fe0965f04b951fd5b0ff4ec0f793c6bb20580257e86365bdf0e0c5ccc4908a0ec7dac75981c8280c3158623eb66cf38454621c649d8329017e57b13acd9cb9a66baf268f10e77a1c0339546e18cac408f93e31623e3259d03b3499efaf1cf3484f88ed2b7a7243ebc95701a03dbabb26b6c52f76926e4afd68fe57d3ce13940ca11803ac39dc70d55275015989816b45b825face1b2b4fb6c48e96d255c4344fb7fe802795257ec4fa65e14296cafcf8bfafc204bbb0d06061c1524c0f446c53563827662dcc49c5dd2a65570298158e16687b580cb78e8d55944f0a9d1d82fb1974f9306c561e556f85d6034cc3a13a885543445564f8f650add08b21c688eadfc04640742fe6cb73043806f18726535191796014718f746e78ebb3af71789707700da87005f9d66c5adce537567a25437afdbb280b0527810609c0269715bdcf9fd5abf598447d4eeae797141df13fbe64089f761a7dbe80dad0498818e0799b82f5a7cc64211851c5809ff39080b3bb58d0009a65635eab83136711e4a8ee0e97ef5e4b5551460dcdb4f1beebc418e44de24c6826cfdafb4f14ff540077932ef120d2e16adaa962b3c89bd26198857a29d1e46dc9fdbd5692","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
