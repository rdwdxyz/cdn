<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89ec2e7e73570d68ddd867d715a5db8f32eff8274bfad1b16da0566deeaff4729047a5012f3d7a7df4611fa82b44040a17f2dcedd49cfa368d0178ade4460284eea0a69e963ed07e8c7339757a6e57519f5f1ae4744ae3e2570d825c57ef74832da193faff09eff35a693c4dc2aa79163e5213b0a53080e892656a51afb0ad87877f212b7a031daa3581250f3ec50decced2e4e618367618b0576f6715d5fb3282d66d3d756a9212db0fbc0952dce62e17a34f1fe12611479af378b2b50a9fde22ade2ba50b1549ac7033bbc39274cefc3e4cbce7421fc92032a0a3a1ef594f61d20db6c0a111ff9d541d38e99dc48999e0d5b64dbd7ee77726d93e7bfaf28590de50d9385c2e3c1b0e91d911c619ca4318f821505d4b0b562ef9730816be3b24e90f8358a057072a035ea7cafb8ad6e072f841a386125b941a563cc974cb23cb61c29b5d9891cea9226cb231272d7a261f103e5b578fbc4ede1f5cec45dfc187db18e332c4d72cc026fe715671491677765e0e88c3d6f1c1072c6357de82844da681d22ce218e6d40f80c97186f4dcab671a69463328bc0dfbb5435aaa14390d40c4c2575ba630b6a3214eb76aeabec3f0c489a0107a33224cb8f355379118c1ac052bd189dea9ab1c627ee7d4de6d612ffd3b189d6b3a669bae3ded15fc284657bc084296ed3f49f9a8827153a1d12c7eae32acdd0856d363ea6ba53f69d177af968eac84d78a2356d33d022fdfeacccba082ded0774f7cc81c0db51b971b137cf1c0dc39fcb0782ec99bf9c7a096e6687c0571144fb0f47d83165fe523fed52476670f67eb6e06bc7aa1e7f010ba0a843a486b10f03847b00fe817f37a0b8e45df7ece645c98033bd2b4cbe9489d8046b5b35793794600ee82195d3734022572edc6e64a80b41712fd811c700ccfc71aab0db050abf6a25ef86a74d86453a01d990b05cc2a96c7d65a69e9c78c4cf18348704fe6b039713671e46fe278a3cccebed2b9343126379b8deb969046037c9f0fb87c4bfa094bcbac3174eb2cc90b7c3c352ed0921602feeba33fa448585c1edd7f46ee290618c96c795053f58952923dad204ec3513966ebebc6c336e072339ccff908013b45d79ad0b32dc1cfbb19eac6690da240a7b670e62468f42688a345bce56b1abee15cfc6ab050b915824b08f3cdb2d9eb585ff88294776c7e21e62b8b2b50f38c30ac500f416d097de7cbeb6638beec252005618b22f76d6009b48b9b6930b7c68b72d5fcfd7933272b629082e82f5b548280c26e5c7ebc37c1c50e036a530603a11ee5712862c8c1cf2c8d4dd1c923cce1341484740cacb0a74990e7dd158403d7770cd51dc4121b1f17a6d43d7a41dfa9bb00c785daae37b100d9ce92ec04872e7b6607e72a65a0630620a6d837b3f4184ed09e47f097e7309904db618af93bbddc2ec5c5580b2eb35cb45fa9940eb330512091b9523a1d4534ff16628960e8695d52b05c119bbd4ef1179ada634214e90da2d1c3042dbd1427a7fded3adf596b5e45aafc50964e76246eeaf28cdf3cc44e0ba71ef8d837394eb7cbfc6f618fc8ce4e4a1e9b9a8f9d68078bad8a7c4ad1a669598648ebf116b502e6a35b0a8b66a82bbae5e4517e99ad442637230bcd0531aa1373b108bf4d50290a608787199be61c2edbb09f50bba8ffbe04ef7d75cfaf7d0c744b92e3795c3a74b7473ac1f810c19822f59378e50c7413df31b962cb5582bc62c726d252fc023d196a0582e588fbc2f451da68bf50e08a2cb3f95e2665ea32945b4e026bcfbc6246b77500235cd0770edcaab24db7e8849a6772508598f86cd8adca36dfef827e259f6866ef569556b8ca38aa0b045438e3bf61830bce567f761c61569e328beadc2d85a3c84e50e4eaec5f16060421d1023fde71ef01a7233a6178026047b4f97c52685c4435cb5858e57c8eb7398696ad5a29f357b0b9e20607b967c8a832f431fe917e3a8458bb8ab192f60a28c36467b93e9e3b88b1ce356554580575c0b5693124410f141fc87333257758488b244af73316489f9004493a99054834f2571e9e611d8406d252c7056244761ac98e8e3ca58dc2115e089c4e7cff4d0fd595db8e5fd6773c4028b0acfda6aa2cfe29ead56560f8f74eaf8ae304c35ec15a4c23ec814b7cc69851b23e2bab7e6d284df5c7ae4aa0f1b261195fa1f33893a7363cf9022ef528cc17e7a38204622afdafe1f29997b906c650288b19ae31301894ad9dd4e79d3fc659ca0594933ae33e7aa15c7b8177c18c1195cd0c12ed88613cd66393d69a0ccdae3c1c2dba49688c7390e4052fbed55b59f8389bb1131daad4d86c02a823d648d70cace7980c6c593bd3979c73ab6d0e3b2e9496d14507e74fc75df8e1d169a946f4aae0b4ca2ae69b057aa7f5097ae0b32222c0e79d533f5489355c3d1136c7e4e1973ad9a05e5b6d33da34912add5b950c19dba267147c46aed2765a66db6e2341f4c77f3abdc26e351b616d1491b62193975f6cc82ad3fa7fff45594541609ad3d1051dfde201fb177f5a50d8899d7702d77f87d665d79de736d1c4a98117c9877be999cc0d60a43c92301deca750e6cadfa04a9cc54e0a70e17b519251e28816c45e06107063727503637670c32da6ba181c739a0dbda12c318026c791ea29499430b4f0fb17e25550dc77b9fda51be46451439537bdc38b5259a14b31442fbf88968fc274d0e67311229d21366138927e453e974c4e0ce9da77f9a722e2f96666498c72903c5f1fa603e84bd089822494ba27f15e6452e41dc1bbc717f9a78f87881446e9e8ddd6abff83130aed114c5e0fd80c6389ae7782acd7f846aad9c5a1bf8ab3c7b34d9f9549d615adbdd2f90099f4c142d2639c4be6af799a5eea1f0934627855fb2e14c8e9fcd4fd7a42fdc97abff3be0c8726617c13171798d6022f330599173270fd28d860555e3aaa24b0a91c3d5455977f965aebace2694687d19d0c010a0f758ee419a76cc9366175a31b1d921e0a12ddcf7f8c871eb77e623fc7bdd70fa0184bbdcba6cc6a0683afb0265317aa0f6cc1eff85b17fa34a04cb9f54d81ca73c1e615c8c7856829b6ab950185b41e1a627dd2a7618314512b802b0d8d908166c44689aae07bb4e3dc810fb5de3e70bbeb01f08f0dbe02794b49cc45508ca98896b41ede6dd0fe448a5972646224a49767cab786355c198b67f4aad78d19a9b22a062776f788f97a1eb5330be1731840ed71a2d4c9b8d6beeb9882da576dada24a8967802735d3afdaf88ef09bab11e0c380c44c3486a95ab8460386608697e8b38b03749b9557af712bf9ca3125abb7f606f358df6b5ebf92a6e05d4a0e83800dbbe5c7055d5ee73f7dd069413909b35bce6c8b546bfb4d11f70a0fb02c490ce5489320bebf95bff8df41d268340b295b8a467437e7932840181fa91c4b02c558221454640be4873bd4a40d6deab4b01fe55897b70d8643a6d2dd6c34a9ab2253988e0b8c427b9dec9571ad195825d4131de130cb350ac8a83c738c4df2b512c1f74c94f9597a23ffb60cf3248c5e27bece6cbdde4a9b302642686b12bd4ad979c08c49aeb98e0ff52ee86a7abb93dfc3e934905e10c5810a64abb0e07a8e48c5e291cfc0450d38e66b5bb114919bff36269f1799e6addac958830cb1e9bb1387861f05e140257a10e5fb6d059185e66ff57167023db1cbd76846a2402846e615afbac9d9b725dd88f94185bdb49526dd21bd95054738b923b2a5c01d984fdc8dfa71faa9cd68e415a6adfdfcc39ed56c23070d69917193c762c20475e3be800b39fe2bca334ccb519b53c8e78785fc33305fe107b133adb4e33d097cb0d89b7e9d451b3d9818e9542978dbccc8155193c6eece0f5e9013c8f268bc8596ac0b20c6e9f68378d48da5e6f34d643d409ae855bf38ca35beb4cc38c15a597c134275468d91245622c032196acb21fe0a4c92b3e9ce150ff32ae4bc507d5e79078945abea9780241dab26ed1f205ff9b03e8dcd54c1caef4261afb05eaf866671008aef4d20d5a83fb962ae598300dd1d563bfde5562778141680585e86e029e959052f35fc7a06b77bbabf170e5ceb81acab224a7515597f604e6ee9ef96cbc7402e560a6cf9d05319b9651d3c63858e11451d32dbb903c81e506ff2c5ad6972a8c41e62689fa67b474c59976c337ac3f3f9b20c9921aca97dfa6304f4617f0bc2c4e6b091124710cb19cc9bc6f66fe8b6f8ae348c14b8921b56312d7f90ed93e75aedf3d272059cb88f6f62a118abe54e51e2c068037b0e8540e40a8b9b204670e0ee8f99ea34ffc5b6dbfc1ed617d4e9310dacda46318b00954d6539e3e744a82b6ddb3ecaf7ea277a31f99712eab3f9062e7283a9dd298fc79697865076f5e0351c41177ecddedb01f2aeee95327bcf8ab203e99b51783755c21861564d71c6a9be3b36b9445001874f34d7534bc138b51c9afd67888efaeb87f3bdce788de0e8575ce42394119a47dd2ca42543ddbddffce6197fd90ac116729ebe3f72b54fac1677e454050620fc2e53f47d86e3243c9dfd57677fc835ccf2171a56dca37a312c10625cec6c6553ffc4eabe1f6724cd52fe7a24333c6059d9e677bf3e1fb5e9947719f9fae509ab81fd2a02a37ad74b30be6ae310079a2a580b5c27ec9d798bd6c3eb44fd03b998f22ea164d256fdb0a0bc838dc058983b47435074b8c4fe03846610cf03b3567d4eaf4362faba9d47d4a1b49cf5a9fe776ddbb83536151353faf59519f1a63ad83a4152191ae0aa86fa2d447eaecd921756aa71973c3fc49acff39a42ff3cc4a5d9192a8e4b2bfa53af3544fb1baaf26d75f1fc94d3b5bc218104f3d14cad211651781ca2d5823367ac05a3b6d6f68fb7c6e200af437c84176e7d8666ecd5f79b987dda4ce4fbe45833e0040b40b25e334c1be6c7946f64b7cac789aa625b93b5d4b53aff0f22b995ffb836847fb33a4f1a37c8f611d0d634b4def2a115cd5bcc937e1ea435d29151d99a2c3be4f75112d341c763a31f9e69912aa9aaff05de8fe578e46f443b4a3786494148d41c6914cc085600e336b7d82758d526277c5aca0b8d0158e7cea555351ddb986704c2b8a6fe20fe27b0c3684bdc2b342edc6561061bc18c943ac1bf6bd523cbc29f7d0b9104485860094335be3a7baa677349e735ff6735d1a85af58291017e22d6f815b7f77063b16fe9e18212c639fc288fd1e8aa8969ba22a185af040617ad2f784d4d4d3d1171b316fdd9fc67c39f8343daed0226a90eaf35ae500dc4181cb2a2ff987674210cc37d4ec1923005942b3ca387c9fd649b5c00300718a7032be2917fb210db1cacd8e93335d531d67eaf4f592bdf0b4a6beacef3153c96b1875394a5b3f53d0523ac94e70138c6121a723b0385d80396b015b4d44e087a04f345c2a0a74347d7fa18f04c50ca7abb071933cfbdc5028a80139e3494bbea8ed0ca10c45eff4233b085eb052b07efa6e3e0b0b1294858071ec2b1e45073cb95feff53252282822c86062117878d0e6fc2f519a24363197df4d58200da6fe145093d473c445335b9b2309cbe1f58b38c1c7a489d76ed7f840f94a9a112ba88dcb58ba02661791f9f9eed43d06ac97d06cd465cf574de9ab8ef3e59c765e64c6fd89679e7bf90d3aba29fd92117a15da7f52a5dff69e04b028ce3ae5aabb7003f58eb44b71e259a3a3d49731054c9dbff1ab08439fa051a390f24efb4e61bd9e525f7c2d186c971944363415a36cd3feb8adad7ff6762f5f7bb3c667bb50455c5a44de2af248e89b5bc255616837030b3db660cae8db477070f60b0c3638e6aede5d60f6037fc66ea5f9aad645bf14fbb82aa523e302a57ba607ddfdb30bdafbd0b2a8cc88e8e50777b3fafc9a58b108711bbe11a8a60cfa97ceb7a7d085fb1f7b07718e7da7c29bded9ee37e17511518d7bc55d794ebdb113d7dc15e8a70ae5282dba58b759f0a56886652c65b1768acd9075d57195f1ffe3a127e03b40195ce7c662f57e63cd71699c98c112f9ee84f34f64cf7d9cef3eaabb253fa1b63ada519fa3185172a374fdfa7a25b2abcaf1c37725ec863ebdf7127fc92980272be27fb9ab017893953058ad71f337aa93fb90eb30cb51abe8f5065827abb3172230f0f0d0b3764a19ac6c9200fb53a9b4a2c384d41ba586e95fcc5b9cc84b70a205466e1b49818b2b5a4256d65f3b15cd9c432604c8576c31276eee97bc6dd4734c6be55f83bcf06f20ca7e51b4731723c74f46668ed7a426693934842d019f549e06741e659b3c93ba8753fa177ae9a128e2b4a80cce0e117c0a7827f91e2e1cebb2ef91d5c7a9c5b70dba8000c7a8a109989f1543ec114e41abe99179a11a193dec781ae04156e86ce211016f3db03ce42d4309e0a6826759d29a07d1f19e4cc58034434fc7aecc26a05160b1c5322bb372c6747b14c3f6797b8b71d81240fad930f1d1ca41fc64929156ea85b482c696ededf3e0e9ee64d7398bc36dd90b3f4cd6c45b7c05d001ee2361bdbc009c08e9fca35756a4bd10be113cfb769dc5f462071f75d928ac4ae3a0361d53c7ff42252ae074fa0f71a83fcd3bbfb490152361493508f65fad6fdfe5d1faf8703df518504efe694421dd6a7a9a59ad9bd41280288a64f9de1c6d9cbd62cd15f5813bfcbae41ce26a7d61eb106866aab153cf8d1dd5165803cb3f6f83e607f59b023d20b2a9e8b9714618a1d2efe19b2b729d9e69f13634b7fd864afd247711f2fc614be3ba9cc2e2e2e6dc66b14e044c0eddd80b4d3cec47d88c7f786e46a784b3e361f4e6b3272a7f31da39667a898fc9134e6e64981fb390eccbe884494fd06e7587fd2c00584aa300f5ec789991dbb3502f2d0b075f6a306df00c4099d5ef5d85ef59977143dfa0040c2869539bcf3f12d3ba21a6a8fe0f90fbe9062bc4297eecb54ce05211b575206dc345a6fb2c23470bd388ef0e73565aff1c000d2cdc8e44322c4bae0230548452080d6cc63abedd17363ff664c64b3ef8977c9bf4d7cfaf8a887745c3fff01b0b1acdcdd314a2f83a4d3df288a5e2d1ce1e3e51f8622135c75623be0e429b65ca40932aceed1217f2ae4bb0593fac5901866a16e67b50767cd845815b813f87be9150c065e96b33dc7aad1950948a81f860099b6e1cc89bc553189cd48314c282f7f50c162fd364e39a144e1171cb1d134d0eac389a266e4f99d607e4232ba6ed0bd5b674cb36eb5a8b1cfa114198621e6404e3c80984bdbc3cdb2556b9113206c95fb09c93b05e5700b60b8f359647816158dc931a9b5a500e0bc84057cf520a178a7e7cb186e61199bfc0a2c91b1a0ed1af23d358cfede035efbaa635cc04f6e7b9761fb05ad92e10d56e58e4a0da587909a140d9e922305cb84ff86256b4c5515a52e1fda88bc09f505c66c8b5439bf7347bc4a25a9c1fbdd66fb35c7b785620e9386060ae852a67bff6907d0539681f79a6f2441ffd1aecd618beb84c4b7e9e1f8333780d74e897dca1f46e79fa683d1518dcfe73aed4305d04c9d6cd00fdf5bcda49d6c9567f8c2a964d9f1fd6e82c6c7ee777193d73e69324f6a2a8c4cc42cbd6b1d3e4ec3caccaa9bb457566f19b4697aaab01098f2770260459d277e002672f3e874387c8f5c03ade2cccbf1eb88c61a9b1287312852be72f9b3735c7feb28a440de7e64f0673b2c8d9f8100f10652f49862f6cfb142931b2c768d0ca47153bc99b1718aa3d9c4ee23987d8cdade263bd63c6361bcc2e11a1cf963aa867168a0153b72787aafdedc37499a68e8cc09c3240a8e2a07a85f458451217b326687772557147a8391b6e24e1385aa662b713b39d6f3a9a21afb7a25af2456cd7bd976da0632076a478b04db5159aa34ba4e0610037cd1107831c10db2a74d86043da3484994bd773b5db6bf54d28ef980baade997aa1c487ad2abcdbddc6cff490631bac1d7713c7ad0fe74e7517eda094b6ced1928ab2a1c69f98bc4ed23d8f9a1d977c542f6145393b4280031dd8a82c5aff898723b3879746aa9e3aef01699993f6f259465ba250126b2f6e5e86d2b594f8984b6e8165b2836745028f9d98b30fc3fef05ee10482472d086c8ae2b98780d36f53cd2cc3c380e2c9ed7fb1687c49278bc8c82a75c5b6377636a937f5acf7fc28df7ab36c5e52e7ce8c1500fc6a2e1f4dd6711486106dce0a0505ef9dc1bc6dfa3c2036dba17fbdea2877e80b53dfe429609ad5bb97214d48152fdd08386705531704c9ce2804ae651d8cb77ffeff2ef41d39e5321dc00b851ea326c3f5e92ec8029ce018d8c885985d0ffb3bfb42ee88562a0aff9c3b59b69b6b239687f44350a3cd5e26a7259f2f5b882a611955803238531896747c9a71cb9f477958947ebfd6bc9fa682f1740fc877b1933d005624da5ddc4669c3b3e7cd606be1443127e5bac255e1267b4b7ee846920eb12c532d09ffc4b102158c6838006b61fa29fd090d3306374a57d468ffac8d2e92459b96fe72ee7c735bb49f7944fa242b460e2cd99b2fea18a28bc5d88e351c6aba7c064e3b4d825babeeb2c35d4314e4da321a03ea1b73ac0cbd3a39ec89f76222a5b410e502dd19cd17d7f6258a68f8a6dd661e8ef5b6baf39155b0af41f85e835dcdad4cc5b4182dcea9b57444517ed138dcb43356e0513186ecdbe6983e1ab4b87673e8fbdacc81aa29070a0ebe60ca019efac0d817aed58a8740ffb4b767a29c15cdf836d3ff4931c47eeeb4127474d604f8fa9ef7fc98e4b851283414d5f4f65ff354a3ba91bb60ab3c3840e713f964a1e9e612e7072f2422bbdb6d9080ca089cfb3a4bd02b895f807548ed59a4cc9951e2523e8d5ba8c0b2fd83615593145c1067ee97aedc3641d8ebfbc241e49b329fea6b6c731ccfdb9a9d47c7810fca793a0bc2c9545d56ba23db40c3a98cf9b7757948a1e65c1af17466641156fd5b585cc508f3529b53a4b39fee3fd90354ec9f8b4dd1d6d72d82baecb908ff5d5f2dd3b1a822afaae8649b299667d19a10430e69bbf4950fa7aba921ff96511438daa88e6a416f457bcbfafb50ca30fe4eac8d077ed51cb4e354f030a290ecdba3b8f58553aec0aa7c991e539ae9efedb8040422f6c38671449e34c297440cde60dfab3bc6dc43236a355916b833fd8b539245c892509b6c6cac2de44d6d43312bc1ecc52879c8ad6bcd8c8ecf76550310814b0104e43d8885fee97a0fb9c4712936c5990d9063b0e681e787b862ef1ff691764a0973090a378bd223b4fc940241a5dc640ae12ff9b449add4e4663c7396c3c957e9751ad5234d55c112e06fb9ebd0191e05135c95c614de3bf581db0ce662d7e8bceecdd875a907a0a2db7090ec6ea80f7dc4975b398ffcf5efffea241aa0e25a804409223a510b08af1204d54e02c7f8a77f1868d87c29afacacdb94374ec525cb3c8ce493f2f3c925a0693c2c0d8ba5bf09f615cba393d1cf72d41a8f5515d91ab17b83d9e94020b7119eab474a90f04cf665441c9a453191b6768f2ad734a27634c81cc81d3a9dbf119624396de1c7e3fb430103132b355becdab3289873690c1810ac9c3fe37149fcc666abe2b463944231e3de2c57e94839f53448e318b1a6c9a08b1ab3e9c46befe5c1f24b1b9ce1cf64d7438bdde6f01a8f25a9caf778ae2161be31d7f5fc8356c8cc7916175268c6282353d0d259362b2d4946e09d3c57cb91adfda70710b7f5a36a9be3752aabc0e0243f6a71f3f127f86598f11444903895adbb8e8f0cc5af4d1474b76e2ba874c280f2e12415079799b90f0a19d6243c631117b2977930deb00aec4edb5f7bf14fcd31904f770d26e6a83891dcffed1f56a0f07c58245c56c9997cab0c9c2604fc0b54c9b27a4d759ce2e27b992a1ee6fc017788d576fe26c34505a72d3fb476f55c4cca9c87ef7a26e37659da26215bff8b0e539f6efff2f86937d83836e6a072b4997d59acd0b75c7ae589baed01b2f23b536a3f8023710c06d081d9044a27431a8e27db935fb500223a87522f7aa72a7b9aabd21dc79b1cbdf289408cad1089279c81d2d587c958d4a8c9431f391abff64ed1f4ee0a2f4046e7852b125d2176e0c442d2e86a504c9e5be36388c185f80033e50d82108f5de50ee1e3e63e45326574d66b4b20cbc2f2dc9bc48bb8e6b07c29b4c6c76ea04e6f4dcf9d7d6e3d67bbcd77b9f7652fbc2f2d1f4e9472df690b91348e90706a760909d872b4b6469e5a24ae9305cf6f9b96dff7cfefc8365f719ef762f67afde093e0f4a5626950b6c1ba987e29b65147b19d2a7123c18882ac2e62164c0f238aa09c45ff27a6c1fff35a10a03380a45799aab507846e2747b014b6c74b43b6fd8f6b4c87b1301ecffaeaa461f25b5f8f7f05bdd72ec07b65705eea0119aa0e27f3475e48973946e587f246c8f1489686d1b113d73bf981242a6c1174cadac659e6e4bfe524e612974149d520d3b8a15b5d8eb6b12655c0b9d0cba140a6414a7479abdc6994f81dbcb79412f28c757a2601cc704cb7a629eb87270d6709e323275d291556c4a15aae78c9ee5a58719ba4c02dc2cb3f59e2b7c586103698849891c9192994ad87221927a0e68a5076ac40722b37f3346b027bb943af1070153fc0b23b34965d0469252ca4a7b72154ee293a906f472e7503a0875b329f952d7ce411377dac24d6177fd54e830715df201c6722cc646efe889b7f872a8d4551522db731cbad4ea572d0114c042e91386a8560e1008b8217463fd3d7c54f10456c76f8c8dd4b83119922977cfe0a78cdfe91f1d90bfeb7eb5ec4342ba4bb07495c021b8833c36480ea6b8ed6113c4cf8dcede99dbcd11a73df48473c3d7b628b9f368c2c9fba69e7a21f167415c82609979cbb9c9c74a81ebd4de9fd804791e391b4e54b3b0c3177e117864581036793ec4e66f5c679094626dfb4bf26de6b4f541a5d32ff8326a4d21a731922f7e87272d0cc6afcae8c856541cbd771ae715a4b1d71585050fe11dcdc95f6579557c6224913b3bc0e9a52b7418af584ec0b43ec36c87dce10226b2fc52eb5823239c4ec2fa480c029b8ed358907e07f60047b0e0aa8b898bbff96bf27e11b0b67966d80c3fd56fb5f6a8a700b1c4cac6cccfb42892df87f81eb851c211645393e45dce4be9cf337fd671df53f2527b54fcb9f41d9ceaa7faba1c56ede4c601c59156920a2ed69298b98be88a74a42f469fc86280ae7efe5941bd7c52e06e89871bbd73c4e6e7d668b2133a6a53c412ca1e1f3f54af9406cb08b30419c9eacd641b76e24a79ece3a38ea99ba696b92313fa9c3bbdd1b8323fda6eef8847a9828bf9dae75a93f26f28eb23e9a88221760534f66ceb3b6171691581ad8a95e4e71500e8f5aa73c5f9ff732779a01efd8989952539bd9b5ecb9f4f4cc0d320ca8f536a81af418d7a4150cf547251f490698cc333c7ed68a9803769c3b390d7f45e42742a58a799b85343fff393b75c06baf7bf91a1cd294e83c7cf4719935061d3255ce21de43364d9ddef7815c1c274c09e5783d4bfbb1173f9ae4a726d5c2d4dbadf42c8558f384529b82a7846ef6d1fcb78d58af231fb5c0a8a28d65581e0d59352f53eadc83c7afba4005fe98a72868bb65c8924c7f31bfa17278467211e7a6e61e5db2f4f150e86c94a362516b45ff99bca4c564ff4ce24e81a64ec929b273dc797842de6d16aa6e950708790edfd0ed2eda5c97799b672d56b76de7d31185d14d714b45daa9a22992a4f8d23dc48faa79a4000d94fb3e5b30bc8c166004f54eb32959b84932c29d7f223eb36f8e9a8a766acf706e04e5fe10ad9c76fd43bbf7a373d8abe67282141452639714f906edc5c93e28b399f9b27ef5a3a23d0b2e5d483e8a246becf87df46e238cced36372e9651253751540302038bdcc4f7076e09a65b4cb7b6a0e72a68e7ae781d2545102cc1eedc578f2f64a07925353580b8bf336f81215857ac57a494d73ce34293723e0d51e8b0b3183632972f24d81872b9a297d2242a9b6c26d9714157f522f2f2b25ea3b79bc90452bcdfca8866f7f7c4de6a1b41f4bbf26566a8430c89de7c06cc4de3b379fd36ec0e1405a257efe528d020f7f6ce6ee403d6475c58a178d0669f84a6e7eb8d08891d2bb1b0efce6cfce34ca46f1f6737cdc30c9fba1dc1421b76acc6c7c8fb9662998d8ca23ba66a85510777aa52a81587be3dd63c3520f4885fc3a3a6c06b17c592bb6d614753dc141fedd4700bca85476305d38c63765c924cd7b45923827455e8436445924529896bb15888f8bb53407b93217cabe5a865d48913c8ddbfee4c9d6a6f948045315aea8dcedca466839688863b048bc7ee61f0f60d6be9bffe96bda5863aa24b97ad0115681f738e067bb4be5c8fb7b2378d2d915080cd247c8c2d23e9e743985ccc0f782521c53a24ae412f6584dce447de780b645745d18ab04b25cc733d95c04962ed5e018b00262d51e27bcf894e3fa8fa3317b79965d2bf98af4f2d9515a29d352ba9a55a5b51b80985ca6525fe73f833f2172282905e2bde3b390b7cffc0725a68ba54902465b16c1535fcc3600c268d1cf3bafb54a6355f832808baf9fee9cfab5fe15ae1a119eb2032ab0fbf7bce95e3bd8ab7681d6ce4a2b384b41937d4271d3bc7f1ce3d3538919107085b0faf6bbe1b639afde49113ceebb01ebc57d343cf31b234a73b866838e0220951c91efe5a09d5c81dd49947e32899c28cf9ab648f94ae17805788aab7c215c6afe4188732046d6aaea0d5a46355f2610b554cd26d10406bab50ba483e51e6cf276c56b5e0684b56fdb22473cbde084954f216d0a4177cc3ba13cc3ce110e7674673171c54e8047dbb071b4ed9273bfbd644b0699b4ba21c1c7d0aa80647a6e97d60d9b6921a71e52a43998e64b6c4434536b17daa132fa1edb7be2e827c35eb9ca9e149ca663922b2cfd3ac035b090b413953bf9496d58849c9c6a3442bb824545c324db8f1c03608f21c4ac97b6a77971b63f6fd63d1cb448d1e5ee746af7adb0930e3f7b244db5e8e4cc9f6a914b07cac6f27dd4f6de5786085da81fa74695d63a0df0d4acb89e2da60131c252e9196ba64eeb58bd6ead0f45e82673a2069c166263175b8c2a6450e5bf87cc307e2666ec271b45c715d6f6e66c0c7718c6e5a20bc2ad62a1eade00feebc795c3ac0ee781753e04163ca97bb5489d840682bc1fe5f8af38d6fca68fbe6d64a54204463c76e99aa41f6de27d0c6db21645e4ad301e599a4356d40b888ed5d597898ba63337a9becaefcd36a386ad1108a1040e8719e2b442731daba56329a8d688792810dcea1143c1916781abc7adeed071092c1a92485e5ad52b1d8c50693e33158210291b5d78f96360ff5134be008869ee36607842bbd40e6df154559309889d34027ed551e25cd6855bf6fdec7f37f875b41c7e8673b94726db2e4fbb5b8eb1e896dc7e8da53e5ac958a4cca4fdd1b88d2e6d532376a5df8e4ffe9fa4a879af3281f5dc744ebb9c70c80c32cb4610f513de6118e4f49aa43257ff6ca720502685a651c6b9ff23638fc35104dfd37251cb509432fb4e632987025dae64f62391a473202ef2373f3af0de414be2f5cc26568a1e505a4c7e21a3086c20ae74dc94cecdfea382f0fc908fc70b3a08a3a4f048b70d293aaf3588d3dc2fe13eff8316eeb177ef04c5c05895ca1d3448c37f94b6ac13bfc96a9c7a86e1018d644d96a2b8ba81c0207a9fbb24a2c2b9d784d7edfb58283bdf98e775ada75f78ec974f8243a2b0e1dfe448fcb10bdd54b37fda1c3c81ed322256bbd7885322406e656872bdee0cf6df2c10578b632b48267daaa16a4c968d21e7d685831affb9db537aed2807a5609a0fc2bf335fe887a1fc649fc8cc7541ea3ff166761b2fb24fa4e614d6ac433e1c81443a413d03e9e51719c7f9dd1e51c693ab0180f7e56ad282b681d6de17868a747aa16063ea80abe27d337b71396e31f6cff12a8f5cc5931ef2ff21aa8fdddf3de3738a9e9f78ac77d7c119fa5d9104d1f17764538de6602d93fe6f52fb2d6097eb68f2815121f08dacc3975f52c622fb8fd48b314d206278fd6987d10c88f274727cba693c91e538ffb4e136f3c4dddc01cc296bcfc96cc2f701b46a0a8447bf263e0ea178fd5c916aae986c8572283b80e8ee9e24b85e8729e23072cfda2c4241b05239dbe139fc14db4e68630529b0901816616719f0a808ac290c57a057d0653c678d6f6f280a2a907a3accab857bbb6a76f817ad175590990236e79c4977642578c7fd929cfc948123017dcef1f4384f8e031d0c75a57553f6c2e09c6b8842fab68e79ff39ee4cc0110f93e99940b6ee6e8b1db25e5f362fc5e134c693a45180c76dba64ddc1758d5f0e557d1bf0ee7bbf4d6d152c4668f037565fe8158c20696a5784efbba9777ca9c385015f3978c2e3275d64ea1490c8ae16022bfc119d0c2a6819457a104681a63ed62f29903ef29351e7e72ff8a4bf0ad3e69a39b07dcc75f187da76dc57f1045932cdf4a40b8b985c83eb059044870853a392a41bf38d421c3ae272e06410ac8477959623dcfdab34d1efef119958a226d94d175ae6796df4d20a533e3458f8715945b5f621fd2cc2e27e046da620b8236f81aacd35c9f64a71f6ecf2412eb71050e6aed6c718b13cb7c22b21ae192dc4144abee4502bea21e978b5530c9aef1ea441b8868513be36d31f7a3fbf6e8d29b354d5b8cc5447b141d9dcabced390ee65be5b5116ae630fc790bf48439edbe60a1da4033e3fc23041f446580dbbe9bd069b05c9300a0fa070be5d877ebada7bf047e708b1e4f6b774bd2f21870778dbb4d0bb61e0fa17a350d9e2d343bc2bbc5bb44a8be1ae80988d06a7afef0ab771aab17ddd377a9b50c4e50d72aaa18bcb18e7024d3a78ba4177203cfe8e21fef4eadc5c53bf5359f8c9f9041e4a20ec83db0480af28752a02b098e189962fbf1d77c22820c1bdff5ba9b86fab77497b992e6184730e18b41def19f143e08947913c8ec26d48bf4ce2582f85fb3d4882fa561b91dffd897abd5464749391a97589de119c05d3f168c796c4e1f33245958fa5ffb3ff59b1323c2e09a45dc4e956c92d61a513d777943e41ac70b42bfdfcf77089525ea2025544276a47b9bf4406fadcc32ca0483cae936217ea27b549dad4b0b62ed80950eb852387fddd4ac78d1ed00c17d75f6dc6a9c6a7e41a64ddb1e6f43a5e1f02844115c4a04341251662fefaaba0f296ef908ad044ecf8c949e2d02516a4f67bb68c44b5d4b618161b6ab80d9046c7cb0987afadc05f3d283db1150de9bb376b1cb34b8a4787ce6e043f74a81eaf0def64aa9f943e433f431c1ae725093686eee9810aff13b9feb4ffee654f430cfa42e2c8db8b9b047e2df7a327afa4d0076ab6d0d035b83a2bef3d6cd2e07e1db71ae4b1521822918623daa6c4446d03c2b50c72082046eba1ef7809507635fb28bbbda845d266032c60dc0d7e34312f8a044a6c9891ec3bd1264a469ba48d8735beaf3166f713c84dacf21ceae9d4184c6faa7e70dcf7b6a6690bd4d7260508eedc33ebe8d068cf9730c2cabef6e27d5034c6efbf870d141a3da0a4f37f0aeb5552c0c58f645e28d5699e58b29cea2ccf19ef076531d3d122283b96a472e6996b9ca853b1908e06441db9984f4e883b9e6c995d8cf94901e13b46a6c27cec2e2ab54857c88fd6c47fe974db1c6506daf7aedcc3ce39526282912a0a1d0cd51605e339c62b523e4ccae1b18a0c542daa4bb3139c1bc340ec58307b7b88c177fdaf3c4f3978cb4de28d0c7e01b3887d7e9bc72af414c2dd0092b655c0e788ea3cec8e214dd569f6b00e061c85b63ab8ac2071b0e0713377d04abb12e654069cf2fcb47936454c653672141341b5fb24d0a019e2d40f63a7a56c39021e2dcdf281d067fcc1a624bb8bb78a407cfa46d03c7f2d75dc49cbff2c0254ba046a179aca478e8a8cba11ab207042027691f689703e75285f951c96b73cf30e95f8adbc52e5773e5b07a893e3e6ff63b983f80583adea83d52e1edd076951c553eb80e3c0bacc46dc4544bd05da84364025c494b586223b2cd597873a9a10f0294885c6968014779a8b4b34a47bdfbe00db1feeee59bd3b9c99cba1ef10f7cd01f40d0922677f94a1a584cd76a6eff9e41e2e89270a29db18f838ec14947786d3106c3da12b29d3b6c3055523d2ee6209b6543834788e2f347d8aab267a67da3e0a71b3c3f024603a4ece5b6a4f426b9c665533f2a4834b20b37cbf8626a5d0663b37f4bb7a6fc51ef93455d5aaf7f911da452ac3ddbd288358204712145aa5f844953edba541bcee7b7e45a548fc79fd77307d6fbace85ad4948a9e2b9551cd6db1af13bceb898ab9968308c8d429abb203cf392dd5c2b101be77354330955afe0664673dd3f5416587a74262a7b4ce129c7cd63154839b9aa79694a53f21a10e3728602512af5157bc9bfeb5bcd2b189a6c2078e6e80b28db8b578b55226ea4e4a59f5d35364a7d985f4445b5412681b151beb6e5444532245d009892b8ae7fa638e873b8bce8afd8050b99172344048b0f53b7c89bfb3caf674e5c189db0e58b0a02501246a9cd049a8930b27bae0bc8fa3310388545ab0462cb5aef453ff8281878cb2c16dc594ef304e7360f43879d5624755a2268bd34bc99e5fb8cfd3128cfba730921a563c4461ae906bb1521012a0a7de96c7698f30148cebace62c6dd8ee62000d45b82923a1eb5068526357dfbf18a8cd4e4c2af42510e0dec5a93d2d3fc1f2b6b3a76014f1e6c3424b73d0e6ee06531ea619313580dcedf802f4510f0521e8978e58a75ebb9f7c1e993e573955fc1f56aa9e84a9ead5982093ce92aed18240fc1d8ca4bb718f1ad0c5d3a282dc85e5941b851957bbdda94c4b4a213303209bafa4edf1f19aea8fbf341540d6fd55d693c320e52dceede0ac524f5555929cd5f66db244808de56f3e899e1fe12a5f1d245a6b3dc91b8146ef2d544cdf4e8d573ba880787ab0c18a9a200797021f084e0fecc3c84c053aa9b1d7affca45ea2cf2e6cd58cfccb741ba376982bc810f504de6d22349b8f560ac0578c03163699ddd307b380a3ac847ada088b0b36effcb76db62dcafc0184e88022f42eb437bbcac90d69a8d0927bc767840324d8785ab73f6c7cc422173e4c4ad0c700dc1910a3c4c7790ea918d931a692479eb363c64969f5ba8ee6576e39f7e38628c4a5d5c5b19cf7a75953ec028665d62914dfd6c195fda06bf9d5c1afbcae8af2258a6d188c5376468f36675d8deada810844bcc08bbce694e6b7824b14c59df88c61ddc914a7c987b5e97ba3b5d1208bd3f884090c006f5be1cc3ca89f6221c16892400b4afc551587fe2ff1c4b2e1e17edb0e9d13236e3c622b74e19f8cbb415eae9188c11c8ae15eee4116ff5a03489887847ef1828087adb187b0234aa94e310bcf576a69b3a5593f467d83a05ea3d3c818f6f0c94d61f475e15d7773664cd18d9ee17ab9d6d3f9636e89f019209c52aa3a5a862d2ab56b3be6c6776be85ee86d9d2a6c7cbe95aeecdabef15b8532f0d2f3ca8e53d9392b872e5dc07697074c65f85ded4e22d766a16369da2b3609436b68449191800ec8c951f06121f916e19ab1ff626d072cd871dfb0c3b66eea855a4caba388a3d12eaa165eae1654f05fc70564e8a26e839118bf63ab9b93833de7b820aab04d5bd1f8381d3047cd1478cebcff786c41cdd68d3976627ee7194f466bf7199154d3d239bf1da871b1e9b3ede2e6fb1461a9981e147b96826b6d318282ce85771d6045666056ca9ce8efa918eb1f79721b34b3bd85361d472688ff95212a3ddc7a73a89ee18b3627142700ca89f92df20e03cd8b9891ac90d21db32abb1a983f224bc7f57bd3380cc0d832aa6111c5c7329db789f49c077fa3614c363aea396c77a2f8b35e7951cdfae240162d76f7d15da270a31cfd38c87e0088291386cb5d9bd5388237572177cf802d5d7bfd3e3431c39484ebca28ef040c2ee727365cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
