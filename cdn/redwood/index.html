<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dffd59b0a737da76ad04b19e112c44af49c27587573e44749ac5165eba4513617d99cf96e26f0005435ae56839902517e7550fabb5a1ee3176326ab233c54c1bd95edf456d0677a4325cbc0138dc8239ccc1f317f17a178e60c601edb93c71bc5902ed825c474e17741cca26dd03a0c63539e9efef014879ff971cccb5ee9b81e625de20b6c6feff3000d8b184030024c0bfa17579a9d18284c449a886b52018d6f77aed5a1d6b33f433d51c148cbc56986a4424eaff95cd2ed35d37e0d6e15484943be1b49f34fb96ec5d323168e719e0abcc425db8e3ee5c1ceb321c9af56b45331f40859d3775760832b1ef7ed90d2a667949d7704fdce56fbb9c0e424a672f63a03c496c1c3ea1b8fdd261c0b7679152eff0387f6d5178118c0f213b857fcb833ba1f89ff5e5784fc2013a79bb82775ea45cc25c765dc2e34ed5ce1bdafc2b1785ebca4838b468eae057e28408eb5d96dc525426069a2f9a4f1e29a07d5e3f59429e3557ae5adedb6fb231c9c58406b488fe6215a29f5de4562eb5c5c7efe71abec3b8183ec399887c2bc4bf7831ce3cc1d50f164da7f2293c323a922129521947b67b3ff784360d96ecf27e484fe7896b78634e26856cade0ea8a04f50a824c6d1aad57957f628ab0dd6ce22cb85ccaafdd740b3e83421bc4522ded3aa2ff69023c5ea0cc8c0acd530d4825b1242123d4ab3e614218b3df1c54847585f30d3cb13e8d74dbe968e61a24731ecc02be9077dd23b6be1c367881e800646384a1271fa5b015440bf3e89ad9935736f74d90768f71cadc34d453294c8b95a63ff75b5420c914ead51df741e9b7a886f9f839b11b7ad20670eb3c56317f7a9355381c27a984a08cdf70adc32683b89ce03654f313fef6113996ac7289e214ec3c61d0bfca44e0a7a6a8afe355e888e768323e0520e9420f2e2812a3f492d7cab94bde0880de2f6306e4ba66bfc196195806435672b053ffc84d148f2be0f1ad5c84638cf74f5e0ca61f6f8b6b04b50290e2eb4b959da1cb6152d95634d6d60d8cf38b7facb69948f1d01e606ce3abb69a3d1e4235f020036924d1b392b1eb7256e01de0ac73123da2873e459b7fd8ebb6b0683594c44a2eee77a9d3846c7cbbf9605531d1896636272ca4c9e24a4ac29e9506cd5f5ea3cab81744a10b143ee850fd74784b3569689a4bf46042f087eaffeb463a4122683728704d78de4b906b29757a789f285b2b2c1c547ae1287c5fee5e40b24a1b8fceed4f9b8247e6023e824aaf0c28c45aff345c792e863493132c5455cd86d026d8ee2c07e719d321c35f3c01b21b4c797f1aeeef9c7301444c16ce389dd7f40612a92ee08b6bd037966b08c8894e6815d066fd3e5f64494e3f75a3fc80ad31fe181d7d9849c83eaff6ccf9c6e77a78c3d585cadb3f0850ab420ba3ec6bd2b653d8388f7f58024466121cc03b191eaa8571739db2548d3667b882ca5fd0c4a2b0448d4b59297d052c0b0b56176efd8d6eb7b711a883a5c0db30e3c76e1bb94e2c5a93896635a85c27272981b07f4fc6b39296ff33b39c2926d6374c1a27b61ae8a5a6424bfd581b96acd4095b70f2b0fa63dc652871b865bb54a67882fc7a89a5bee976254666231ea2260e301c8a36528632b244895a9d29381086945cf56634f081b76425aaed43758375ad0a1bdd5ae51bc1c80f5df6b468ba80d277faa12bf29e68bf274a3ceadc22fe561f09dc081d84a39fd014da5a73344209b2e3e5bced9b0b91eb78f7153a8fc378e00d15f7a0a2a62b97dd8c5dda5cd58ffaeaf8b168f03ca972cc00b649accc6874b8d02a83a5944af8352bd16317d205d9d109e2266d626a96bf65a87e6c981a5644185f77f9a87b186a735e884204428bd2dbad7aa359531e80a4621f224d78f8ae057b5beaa60b15593516d7f9fd7813d01f72462e2fec005bebe289988d6f0ec02ddf2cf91bef2aed2f824015f82ce0e3f52cecdecdacc7471859b780286cc5d7b7f29f63ebd95675b799d2a530dc80e2a786e42e8d8d15974f05f7a3da1d553bd666cd51253d0cecc70b7f388fac18f2d13758249ee70cae14469103a1b5703d1ce0c6cc245f17cf7669ab0aac5764c08fc8718a1ba56fce98280c0c2205045c7c0a5a13a3489446e4e9a8a66b9168eaff444ebbcedd1e331ef37d1e0a82da72d98fa168d1f4cea3f6fb6d1ad901da39515a14a3696f06780b1ba7d61eaed92b467a22e51abb5f185cb175233f4b085367cef95d8b988a6f922464dfd1a7cff4a14fcc24a9e6ed235e77588fc5335f8b306ae15d37427820dd2d8f2a3ce4a3828bf7ca516ac31e056ad8d4521d71febc5c138c75ddde944523f7a37b23709a056ac8dab600494a017a893219b1c2bee4e33ec22a21ed694f9c25ad62e815d6a6cbde5c6df0c67cd366f068d1e69f17baa2802e5aa44055d3f9683601d71e56fe37c30ed3cd7f0757059f305522fabbf064db7140d78936ecb1c846b3f267ba1f7bfdd44b22e151326301b45ac6aed0e803e657a66f41dc2cb1f1aec794114bfc6ab1009d8d338b25f9bebf9f1889c5dc1e3eeabf596bd80a31499469b8fd46797da89903285e2852d8df09db04520f61506031b168be2e4f95ad7dbe3698dac1dd1204626d2537c45c88e89a3ddaeda91ae82616a878f50d627f2b2947e6a01fd9211af51b888b0e6b7fc12a86d1a731e934513185d2eaa2921efb19333725ca1cc79be71bd1f7ecb05a6222d1103d704d5029cea974d56000971a52c3f7b7bacb6ca83589cc79fd0577b590726f49540160a27bb65c49af180685487d4f79b598cf0ff70c27706d8d790a362a1020ec5c3714e1359eeaf46487f5dd7b4c8f46fc4b1b08f96b6aaa279f59112f31a7dd1dadbe724783d13c461cf31c995bad32b6e527d8d3d9925db986a9e74dbfb38d3f974d28a1241076f83d3abd77adb210786b86acb46ff49b3b6fe1fb2200ff5dd50044cb15fbe47a81c90a9db0a6fd40d02113e3b36e3222ce7b10f86f52f192d8dae077d5cb758b8acc42abb07f00436bc6147f376db3ff907e4a687dbeb70c94f0aa7ee5eaa49fc099810f2b650feefc33ca9d896d5dd2fc007a71e1976fb6d2dd88ef88ce9454b6303db7f232dfe295a2f7e5307b919999a4396b0820a7960be421513f784f034028f6c78bc00aea63252328a2312880a39196ef2d6381a1b7d97e735832578e7a1158e3f058e9c7e19d07eeec4972f2d7d71d1227863e37d43a62ca34e1603f5c9c77063c2bcf60a222692571c7061c0d2a61dcc2ea62d5e6974db5a1d7a0afbcd5d5bc4ed2ecda9122fde147ae95dfb69876d6218e6221f1af8304557f0c122640a0786f8baafe80f0accb2fed410f4b7b35849706d895cdcfeb08a17403a24cd08ddf854a1e51c7dbc61092d9cf49e73be4a94e17323781aab4799816c62f8ff791625c06f6a43c4776b4837a0483608f45492b54c7235c546f95fdd6c896fc25dae3529cb597ad29ebcc5b477f50487cc108669cc44dde9bbd5a4cd64014cdbe7feb2ee3931d2c52d30d5384f8ae8b05af91a7905407963c6398d8c02f8226ee53c342e2f839bc8a27d8ac71aa18d5d65d558a5a4a3372888bc48ef707fbee9d237b14b7cc29c6ac2d43da87a736a2a1fe4bb2c20935830e490916eee53800afe101f6a62fbfbb6562b9d6c8ebc8dfc18b2f02b7acbf736cf4ee638be26897abd18bd19148be648f834242d1f9ce68d05b0c084971b108bc4bfd39398bb6aad089868239640cfede841dede50abe9ee000c2df45162d2b4e253d48cf131639b619390ee155c29d04e7534a6739df5de76f0dfb7a7b946c13bc86250e24fe12d54d5efc43e1912cd5558c65dbafc3f7033823302e324d37b7849da2b8b6ae21047e3fca1cb0c421e2b54f93aed362c4ea762bbc9a2eb4b1abd5c03fd5ef05301f15c134d0fa8b9df3d4ccdbaa63cce0656b4491bb49e4589cf072b7d36d16caa88cdcc7aca1c2202c4dd9e483608076e5dc5bd9a40cb7a0b691a045ce703b75edf4342284779b005e15c278e67766fc6baa1b41ef4b8385817b99824b9ca0865ab56bb680496ced443bc4223e63ba4b4c4aaf7a3d0fc9e6cdf09eb5deae0584069fcf524caf99a6a2563ac2023e55f39734975a7b100a4167112c289a4e860cd6b5e383116b8fc32f4c9bd3040ef85972edf3f66b5ef8e56fab51d495acb49b7ca8ff10017278f1a7315a1573069810581d3457e18b3a7d78a252f0ea64148a0f326e106eaa9be45f56a684c50a18c44be3b50754f65ff66adaf3d6d6d91b77b9048edf0f6d1b7e36d8ddb203b6c0954ec7e25f2fe6a0e7f19eadfa368c909605291ee5eccc90094426cea7bc19885300b43d5f5571bce2bd7848022cc9a893fb732cf84f078304037c6b53980205b3b2af2dbf5abe9255524bfe92c30f9d291e473828146f8d40d9fd5e722025e55cbfafca5842131c36a6ffa7f6f08de669871d1f5776d952bbf3e4b5de06013a8c41b892b941b52b436eb438e5779e805591dd8472f093c8485a4e423cca8551df73a9024aa6573ab93043d13c3b295b7a9872944af26752ac9913b3c6590520834aa9e64d6a680b50ef1f7742c854de7dde3a65b308764130dbf272e5a98c2c26819e75c1ca468cb555a7b961915e64bac4afe5fb9f48d07f911c7fe5606b4ed521de0ed697ae3f658412c66dfd70334a5cc12246915e998adbd90babaa5ea05b1dd17b11ceb5b06faf14e335f7bfe2db0810062a5e0f2a59ad544cf11874bf8d5412ad5c39d34f300dfd24cd1ca09a129e89c85f8c72c3a8d598e2b4269d45e434c3dc1eecbec5a83db5d0ae80948baca8a56e915ba919867092163738b482ef803a472d1e3ccdd0b8380b678b1229e2abd48cfade59b4f4c97d7f46f0591f46bb0499ecba44836709cb52bd9eae4c8a470ea4a23f3a0a3ba374e913167ac1fe802f4782c96ce1341c62683f287cbd9d37c1f4079771669d0f5db5863adbf78eaa85c9adc82d0112618f2a275e2564ab0d53416978fe19598cd73965fc475cfb17aa9cdd4c69e603ebb6e10d4937beed1a591420aeb503826369ff8944e54902a5be9d7a25163cb41880183e90215e3ed083d05e22b1d780dab0eb47b5d065ca5869185493b2b9bf76113e8934f8b0f82ee528c6d757e10a59d787e72a8f15df6806363a4e80249564f223ac8f94d451035f4384dbfd8f862a4b40e0b95a9e635f76dfa734ec6547b73d697961cf961f9adbaad3a553a4342b391ce94b3f2735d4ea9f32ad9a1cacaa0b7d65dd92e72afc63bb7dc511c5465dbcb10386daeb5ab4ee81606f264135f82c82d6d540a47b284e3430dd7ebac2255c9240cd9cceb1a5194a976c6e0e4941830eba9f15d4423b609f3a0ee82f434c1f3ddfb69bf9d0da05e77c1b0c7c9e5d104c352409f8198a76029f50693d931991c1d2d62c78292a988fe1d8d693c7030280d763f20a32ac7e4fbfccf23a04019a0979b87ae6d7b4ebc922d6dc1ae3cfad8cc0103fa380d8be040953b041ec5b8a207e9ed75ee31dc1ca5286ec6bbfd7ec12afad592c579ecf9e2726f43edac6fc504e27a8286b250551ae798de32c1c11be4dfcf46cacf4d4a7ba153b26330190d32afbfefb420ddb0378353621ce912f9dd342bfd2835f9af15e6b0b1591a4280acb8d3aa0e394c504ed09dfad1624966b81e0bfec7899e5cd76f68d21461b9c814aa7636f088e1c397f9048c28fb97f8a90d279bd18cc27b41eca2491dcbb7788b7dc3387eb3071f070aaf11c7b5e4dea71a09b0abd9fc2db3422a992bbc02a1800dc5ba6532c662a28b06672ba494091c89c6b0b62fdb9a2c8a110b654dacabcff771446272fda8e2ec0830e56c712e53ccf23fef26f892ba06271a168d44a4ee78df83820a2983dc6e26e64f92c4846bbf784193bb6c3f5bec6c1442430a13a55aa8eb2eb77dbae8a27fa802eaf9d6076cf87ef3c8ddda99fa65c0c06297ec368b144e41665650e172eff482c6149e6d9adb507c4e2ce085cc5ffd84272e1360f558ccae49094281407e86b3d0b2c112bba05adf678e0dc274bdd293ae55939cc628b156215da48b60dd0dd8090e96b065ab19f0a92a2ea707d603d5e32058726f83548318e9538af64f347848d6ce9902daf1d77634391229bf30f03b5f84a6b5783636b4824647d1a97dba8d3f23c024eb4aeb046defd75ad139984553c451ec82124d4c6005f78a1ad0efa69a5ea1ea05ec9a5060ec924e816073ae265d00e66c7066866dd9cda28f2f4321f1c6b16f81e5d96acb927ab29863d36f778ed83440e219044224c7e60cf41c8d0475f518f784defe4924d20e49d24ae49d4e58dbc8da3429c538504e3729721c2e27155355a56a58c93c5f0a3a1dd1cd1627deb79985ee01fb7c9f1e274f2e677aa43eb7d6236c95ea588f2e1c066c2721b2a0e3657dff555a5a8e3c74dadd0d75099ab77a27829411c9bfcea868c655e1d4b60186ac6b1d9ed33f48b60dea00b737bede6ad91cb269e954ad66cc8f3dbfb7aa159de19a7c7581455a6770a9a66ea4e26f5e1c9587d1202cba9bf8fbea9dc93c48769f5e0f84253e41af95d47ad5f64cc5ff0e6a839319ac8fedc5d169d5faa9df9097c8fa7766eb9163469ab69ffeb3d3a784b62032e865aa7092ee6af308f4042139bf002f97db2f64d2552b240bb3e398e96ae633996a4153d9181b336f93d9d8622d353a9251dc5e14e8ce5c5776bd047654e93061ecf62b8efc85a046c9072e8d7ba8f6f93b858ce006b32bcdcc9b075131fd721e020fef504277332914aff43f01c05aa51b2dde938d98fa177ef0d00e18fb7e4804dced47db1520667de54a3c73a7cf76d13412305a88bc3e6073b3819af37e8c291db0aeda4d0bb7117d3a1a36819f2bf3391455a15bc2711aa41ce891fa3576b67b57fa1d731653baf829316422102b4f1f2a629a030730192ca21cdcfd595a516b6cd6fc70fb53df1d0b00ecb94dbdf36d715f5a4b7d7822ce9043652faeb0470b8ccb8babe0e24de57e6dc1c1244a7340b3d3c05ceadbd18ea6a7c38af8f509932842719c96c962b0383a97f16c4a07e3a02d088860c900d89cf6d5d8b22a3b39b004eeb1304ac49937ef53e35e32e3d3c0347a65ba2ce0a23467b961d8a0db877b19b1af5eb6f7d73776ab20de7f616d64a31d46132d23e04b1d9bfeb21590742a65669fa0efce3819fa482c066a55bbcc25ed4f5a80267896b10f14ba89abf4d4ae36403f23946fa73b7a1375a4de342e7160e650d2bf0646483d1faa349bfde2332938a86d7fa849642e36f2d4289a6e26002e1eb53a12511e25fb060abb203dcc6ec238e1ff58d9fc7e281e631437179db4df39355ca60e6a392c5c27c0c6d059d88cee31b736f5a0e13e20808ab9120cb8b861ae6afdfbf77e3525703eef8f3e13fbeda6c96f444667a852cd39a84f9e7602bf6c91d2142f463d119e141da89ced999d8c158f0e4fb78fce8b85495637d7e67b5ef2a5b867d636f6e75c7d4d287a7e94d47bc27b8ca87f588551f0b9110097a9466c5731e87fa1df84f502a3ef136b10a8dea8f386151420797770571b7e84b30e8f91184648f0c8ba5f90bc611160711da09dd0989e6caf94f3cb06d7d945c4527865eee542027f05a7706ef7b234149af9330b94f97d0917ee4a01e44d04e8b399f3d90380b404b708e171dfd36a6a3b04e966f7d9d9fdf8df811b088745ed46d69eb4700a913313aa21f731a7381fb4675ff73d0a610c9e772de0f2d7c475d69129e5f1798e640610f7d12a729a3591ee75f5b3da4be1aa1674eacc2b831bd4901075110ca0a3c067472e545fa190d1e5b1f11e1a7e9a3a7efd0436bf74702060527c8f30682b855a34a9c0550bb5f6637f4ad2a9263254d07861587dcffa43fcf538a36d4f081762aff8bccc8b1c9348c3f4ad80c923a6e8b5541b9660570c8b366e8801c012bdcf8aea2377f1d486bdd9628d00450b502a8b58651d881cb0cfc21339b94ad83cbf578140d967a1d11c0ec56b0ba51874381b35e2e42268c0bbfef2000532b5fb045cbf996ecab4b7abec5e32d0d41c1ad1d0fd6a4c2278ade1e0431d84d9371df76c237f2764bc170fd286fab026fd2ef97bd19c1c7736efc3863e84981a22d99d16b4ca5a4a9ee11a0270c76012efebaf0fa05a9c33249719c1ddb8d5afbffa3ccb7b210d4f4e820f080602a3b0c85b7739145f2d7a7024b78f189d012edebc3fa325e9eb7d3e27a6e1888bcb465ed9244d0a7c9f36390ade993bea8ecb555b208f2ca5ef43ab2c466e20acc6077b8c53cfadd44e3bcf830522b08a9a1471a49864fed923934e6ad72ca041125165ef379c504b02c944c6770dd7ec01a4edef6838dc254c23c483e12027c655f8fb6de14dd2ce6bb01ebd3e70f944e431ea46ae6a085ef688ce08fe8e6482bbb19405ec26cc994330c48d35f8367cfec35642dce5bf78c15623c2f19642a207c868674c2d86ddf5d85ce0bcd1d9b3d50d46f408584c76ca53caf28b08da7ea92bd2dcbcb79ac2c2af110db40fe12d11cbaef19f1cbb73490b762f176e66317d2a51d362c7e6365b91ad1671f08b9c4df798b515de20327a0f396a4b943b4402b6bcbc33b67085c00357b6d4c6e548b5ac669eed109661d9d2f45ddd9fa7b69ac98c39680ef399a5c5c0c77ec7d3c5fb7bf89dcb7f5f833dfcf096d09c3afcd274e12ccfb4d8903a07a80211dc417939fc3e1243a2981503b680328772c1274f0a00d6b29277eb2a0dda8d43dbe686f3baa72dadfb71e02f9f9366d0d47bd547cb19cf7ce0addd48b6989d0b39b8d88f979d6e6437a5d9943a6e8d7de19a1b02567332dd658df08ba81a30bf235770740fc8c3f0000f0bef0ffde96c6cd6929c0583cc64f1dc1a6c83a3ec6518d91ae3a3b39eefb01cb5834627576fc59a30a0640578d78b6700e1d43f941de572c761d2612d92b1b093847fb8c211e446ab6b7ec0d1be3ad64eebedf2528970aa7314262ad45dbf328098bfb2611876431e6b0a88cd316839eaf62837c9b420a12c9cf05dcb245a637b59949c25bc23424a2918400f85718981b5641bc9f228396b48df6664831d63b1d5cb8260e3e0fe5a6d38a013f17df72725a987acd3d79b70cf3df612abdf73b4468997f80c50c73fa00287e242135f84d88e8f820f38ea01bdaab20c6de36be8afc780a5f1763a1fddbedea29f829487105c46bc6564c447252accb3ff69f514b3ff02aa21f4e7eeebe8eeeafe16d469c3263b0a2eab32f75355c7d2d15fd7fa24c6ad49fc58ef8ac3fee4f603c042d11e70c7fe0f07347069a2c0538c09a409e1d056f1d78e4726f76b3736e5d14c322cf6a6c0c3f85a12db99bcaff8981136c16b8403592dfce1ced2cdf3d09184ca68058dacc027350e38053643f7434acdfd8bec662ef198c8fdf2b980a1271e30dcc37899cb885fbce35ba9e900652e10c51da80ed001f04c8308421cafa3b228a4b7ac859c1204af3f524a8285bbb2f3bece7e148deb65bf6cbc91280f3dc7a52422a9e1fa438b6cb913f3d50b6b0ab3dd83591ff79344bb36bca6e9d2e62452d136113256edc0ba6d352259bd238a5dabb7ba87b67ccf864aad65ef8084908ae196108f8dc0a80b5a0218d837b5b48a4901dd7009f8500893f68187e2ad517392a06f98d9ec665211852c68fd7693c948143e3888167fa91d05567a841c4f7881527cd5453c81bdd200f1d689e290feeda956175948ae174fadf8a0a417a25d5052b89d844506bdb33a6a06687146fa9b6d6da911837d9c15e7d2548341914d79d1004fbe8a5446368ec698b811a09561f77eaf588b9652a34c077fa475c85cde4e0dbb07e5c8623fc6fca5df9cfc54f50e3f25ea8a916929dedeec3e3caf05f9fa25bcafe9e1eb9de936c779d445aea0f125c3ed7365eba2cd5426972f38ce43f392f3ce71989ab92ed0d7e46cf072406acf96eef57527f7f3e907398a3632d9a03af0c985e8be12d7919f65126a212759f502418f28d2149831a6b8ea6b518137dc8678f665814948a89843be699c006696ac1c690a3b2fe2514f768a7df967af1130b1c0d484c6a8f7ea4737b92bb86a10e253577daa19f4b7fd3cd98523ba50212018c2fe0eb5991708cb5071d84a540e9fa7d1525b19ffaa9e515d235cae1a5ab32cf1d136c8e1dda6567b26720e498ddb101607937a68e35e4d5280df26e8a15c10b662ebcc7d0d411d721e86a15b6032bc1607ad644e9ff2e68c96f0eb8cf02785dee4c472ec22e3925a6a9abe8deee3b7342613edb3d243a55c4739e4596146eb5c385ce49762cb7e57c16f2f494b917b0af508796a7abaf2258be22f1f87952eb35502841fb21a31921b57eb96828ad3f14789d492469162bb1c186bcc183b8eab0b27afba5997637ee58eecc3ed3a70180acf7079332f12b422f5800a63f30a929fe649905793d4186127dbbba4f306068b0fae185a5909f1aebb663a88d5c31169cfdd9e84d7455b122d7b0bab3b349eec3bdef198c9233d4b3866b64cc6e7214259a69901a96bd80eb3d604215878733a75b6a8b3af3c0f954e3d4d008ce48949299541a0ad52e272c519fa9f232632a7e66c52f06ffb32f7d81a2278b35db147f0f1fd474357e212d4c9b5ef1e3c743e96ecb2355e26fa5aa16b77a0fc2db601cc87a1e4d5322a9da4bcfe676b7e2f76b7ff8c7354ef79a03f741aa38b914061b8dd5a63730aa31674426fd2a04e98a83aa7ee62fda0c2c72fe2f4dd6bdb06358ca71f214d9f3a5803ff6a4c797f271c7a829e634bdab98370ecb4b5f884100ec413d4849e9810e778ffd0136fd22fa22a821abf932512c8a397fd6d005fe2710704f8ad7b7584eb4349472fa2784b3c5144cd880e6c73c06e6ec819d8277dc4e1675179bb6ca496f50f49cc75428e49b0246115fa1f2f286965c67b3838a4de7d28490aa683e6db6e10f50ec81dc8d0aedb1df02395fd979fcbab5ffa73d72a37817ff989f2fd0b3ef8dfb0deea3d5429fd1c7a04755d602fe8974bfcbc39f47cc5e60ad5244afe0ff4901c0e754aa2d58f325458ab59541a26bebfa7b3cc92cb0a9286958ca07ac0092b2a703f8edde27957eaf6c124ba2b318955ac6d22c77083d981ddcfe1c0a2088bda331dc0317b07d580aa073213236a9254791466fbfd16c842bdd1cefa4993b607ac533bb26c67a7d9931a011fe1135e72d2ceed6b76c3b8b8814e4819e0e2a4e07281e1fd66bd834319c5d60fb0ee39b7c210f43ed79a9212f88264c984aaa150558f0b460c86c6b268a65f6c44529a1347c8e137efe8c5d1b4095651941374e31bd9ab85152af0f963d9bdfc718d189678574f68969c78fdf1648e0346c65bf989b587ed6c39a41f9b4bc3b28f8e7c3d889b737fed88c05ec16ac03ad13b62ce310a5ee505334d6e4d50340da0cfd31d3be8e9a7822781f76b79c310ff243263ac22d254b185dd13d42bfef5bdace5b0bcf849a4d4a607f0e0385c2a319bcf34fd6cb86482d0b8b3c58eb52d1e4e01ba5d2be5c16b94650a4defc1505dcf44f378988881c297c575f7bc6a81c72f2c24a38f701f7b56b102ffb272214cfc3b1c87458f9c40d64e56324b5cebc77857eecf7e1e282810f900d45f5790ff8ceea53cb71ea479383c7411af244612136e12e35c7df2e7b9ae159d9ce4e3701c400c977835b00df526fb38d5b1b78d2a03551c9e00c6b0a267867afeab8d753de323c650f9a7ec1e145f3ffe633bf145ef85d1737cec2d42dcecfd6be88fcd50c29601d15c87e57f293578a181c304d35f6a3826cb2f6c5ff04326bd3091e8dff9699b2eb98cfd41d8c0c5d246b38ffe67fc4843df7ac112dcaaf5c91875ec48b4bbdbb24d0ec6630a732b3af8104f7db0c6e6cbf1672882435d4fdf8a8b3c4063cbd5323a692573761429bf7eec00eebfdb49dd2f5530543d44cdc99dc24bee86a525657048159666e4c43abc9c7d3437cf6f7ca9ea8f6115d2b19ffd3e3715c5dc191cf8b70321f94aa835a8854ab4c9182dc9e2e751e2726a22db7c7176762f86f0b7443147dc4025f71cc9923ec1b50f5f2f6293566842986362a56e1dc9162d175423ed6b9df926f9eb8d12defb296efb75fc248cf5cf2d5ed105d99093acc88a51b9fe27a18adb68ab4be30538240aa418dc656c291ef343d6137e6b92f6c3e2ed61dd99bd23f536607b60a205f6488aeeea0954892e07c080b058b6f993c156c4ae82a11c7727e297a5ab9cda12178e00ed0c188c14ba984013023525a526ae2325033476d380782e9dbbf929a1efd08f27ddeacab56277c21aa9d1eac194f9d5fc05c34b52399c541b136351b48f4020e54b0d7b939c0542d0fbc1304402d795c88d29f060eeebef3fb5a52a1c4ce2cfd922f80272fce5aed23f5ffc34bc673020f42a6a3bf74b3df275f8cf01761959b77924929feb9cda44bd5c3e1c02a1b44f88d6d91355e3a06878b75302a2ab2c0238ce11516249fb890247c3a6dc4c9071af8dad900a23fd9762e6534d2cc59960543c98cc285ffb3935a8acfc9315892cc632bcd05853721a75cefbc9a0a8dcffb9c66b7eb2153fe78820ac490617cd00bdb56cd9300aa411e9d70226f61291f1f591873a4f67a9d77e53dfea236cd672233117b0afa4d5187b60675890ac5507c332b37a22a5a1d55be1f29b253fdd759307030ce14dc9cb634761e46b6f90b0aa3adb61a9eb90ff6e2d44cd8311f68373cd3eb3e6a0eedc2951f04a674e3449522271421eb706512346f40afbd1e3905619eb4f6da985ed7b1b968ca95c2d86de7fef9711abc3c42ad63c5a6832d8144d3222dc6712606733d47b836b491e4b141a52ea2ccc46004f115cb9d0a4a6af5f1ee5d1eb2b9e5b013ed82231c1b06a7f92d807300d52e30010d9da317adb0cc9d8c24afb4b412fecbe706f3cb67684d49c99a659b03a796cb0a148a6aaaedddb9e906d857c91a226f5bef8bb64c9383cb668b3d3c44e8544af8b2aa90d47981c4b4a3f8faa4fbf28c2b9a9ef6a4676ad238e6c5f4a565cbfa49420b32060ecc8972b46fbc80ea84ee463c35bf9d91b6fe95ef882666775db35d08563a9bf7238b462103057292c00a8551edbd3daa084489c9dcd6c8db994a9310f979d9e0107ed648c538d4522c86b3e4e053a0dad809b97e8c5234295c61a51514c7ed8dde7ad5e78b3457e097c7c57fee1b5ba77f3fd42a14e2bde0c2e21a3812e747f0db15fdd2d9f788fc157c2aa7722b8da7c8b0436f0b56fa5d90c1f5d5cc1c6fd637eba1ba0dc2bc1a91974b3c9f902d93bb9b496867cbd734025c1f19df002162ed9823275bb4d4c0fcbabb106bebfb4a26e4966520d84d1cc81ad26f6a6de365695a655beeebfc091ced529dc2bf9b64f923cbb99f874ddbb10cfe0c911387b569661421aa1bdf910c27e37793437da7bc92381962231000de7fd5f66c26e8718d34ade2efc6d82bc28350198be29aea8904b2be84bcad4191bff2173f192af8d901aa443575a08b562e4d4ac9e43206f8255b4ac46d60faa1acf1a506e8aa69b89b398faa590939729ae829f5305bbe24b41b3c29d9db3e78d7504bd99c47c5bd0b30aa7a0cb70f642b94d0013299ff754b38a6507ea77ee743eb18399646737c56d010bdffb659f302b33ed2d1a5c15aa1136090d668087984b60b38f3e87211898c885d07787ba6183e8367c7bd18a8b3e80fcf3b976a3e85d1d3ca7b9d1b09f885b22dc18837cf6d867fe8ca7a75b9d1dae00d42e8b045d02c7dc1bae8e09dcbe5e625f0ee12dab51197d2d9002375d2a239cf1b244ea616016c771b85bd0cc4c40fe7e6ac3fe16dba4c30b268a94d6a9f026d461274af934d9dcad62a3f69f3eda91085fafc473ee27036034ceb230e6dda1614f8288ee6e0b7b4942f470021c0598a120a4fc227f5ec15aca42091e96036c44de948af66f0cb47266e48ba797a7f2ad9b23c58cd02c5ecab1e579f6a57b530f2b35c0b6dbdbec061e7f0f40c4c3f073b3678c0b99de263b582bec4601edd8d53e04e24c65dc0b0017d4819280fbadd7ff3ac37e8de534fd925f0a5e9d192f9fe08313f8c74068faeb6141d204cdbb52171b3b80bc6806fb99afb6be82eb33a7572945fd832f450d7a0143da3461f92ee89aedd91c763012c8d56c1321521c3643884da1340316807a3d310ee3465192f6e50724fbbaf76e4a6a8a645d5fa8f14652082e2ac7e46fe1dd8834be17216a8afba975d6b1a75f20a92f80956821452de92c7db27ccfe0573e6002fcdafe19229387574a7bee17037548cb8a377a4bab7cce226d88cf64646ea3eca10df0418c21f09a1a65e2aebb07bbb254ce8bdb023aaee1c8a61832a679d6eccf2ae7958521335504a1fdd224e12580b1a16f25ac689ef06ccb4f6dc6594ca77203249074a1df515ee0c8dad321e5b6d0fb94fdf1f401ebcb92af04759ac267b1074531c05ec8bd302fb38680d4fd6093f54d18a9d704560f969ba179a152a858f06ef83d8c29d8664247153c784e23660b4ea7d2fae9a07100696cae15d47c684cab9683d8c55171992aa3c864fd77605593b5f9c22003590b60937579dafb45909fa44dc3efe3d1ebeaf4855dc91d9495d7077ff58747f39c9bffb7a5e1d4f9e87558cb73a2ddd4850a583c67d7ec3d9f8081de1a46329f731ee6f4f08840f87ed596097d1697ff0671d55cfe5f2f6f41b2b16bec7dd5eb7e2bc2cd111f76fc913fe33e34bb34dc293cac8dbd34c437240393d2315333069afea14e45e4a450e4f3c2248780749fd234c0d8a98e5b49c4a96632d830bc3c589230cf8a71f5fdca98b4247cd6dbd6f16ba0e3cda50505e400e23009e43fa466da7a0f6784929e90bed60759e72949c51a09d37a4897e917b5685a483e1e394e21800670253a0158d1fe024fc3d36bfd5e871a676af245306501c97b10635de5b6e7395343c7309a4a616f17e72560de76dcb3fd765c8d5da27861c6fe5b23c5d27bd6cdf709584b221b0ebdc65e4c72aba81654670e4ede6170b8ca5742fdcb5e3797873a6f07ddeecbe35a0a3e22e91f8c826315de568472b6d05e5255db6a2b75d99987c6bba554b1bafa51ccc93064a428596344fd7e9a1ae87633f418f7d49668eeeb2c2e43b3c2882df75de6752288d0d14972b1b60173db7081c536e75f887c45c3c6c2cd3cceced1e9fc174da49f955a499ba8d744fd49842f17cbe765237e0eb5fa45b7410988c293f82e069c417aaaabd695d7f371b0ab8456578be82e6901471f76196787a45e5d70da3456cee92e62c8d69a05668354435b0e787279b0e849e91a1df57fec47f4910b0e1572291916258255daaf153430e17219f123a04ac67e8fe99ce8ee97a739938a3881fe01b649b51f79e8fd6a2516c965ba75b7ca0a6dde4167ddf2c4c0d3b81c7b9fd63d3e4f6e3188e777fab4b7a87f26faa0fa5d54c76a0f042c7a13912f5f91e226cbed3e55d21f4ac5d94ffcc7e9f821b68224e5d35206e026c051e42a552a2ab3821d1cd6e7bfe35d007ea4fb6b5bf27b68b2310ec3be8622f884457200d218723666a1f3a1c997d213cb348f53ae7d7d6be1fb76e8c5491bd1f885762c66e7a42df9b3653183245df0de524beca22311d91fb8fdd2aa81b8c904c94f9011a47181a58f254fdf36724d1c54c680ce86753fa60ed74a664f5c63bb955458e0250a35c8aa83c873354b96a67b31123395a9ab53298234f14898da38442213584fe805516a5e30b19f535bdefe3e21a43c3c97696fcfc3504e5697b2d06b161da3a5c3d8665a5421d8336c83bbf2f5c7af6b123fdad0f176d8fb3319e93815fbf634d058797a80c7cd692f271f1da7c4b926025153ae61a54a681bfc7fde2a28efefa2b48ddd538822e900ca8d6ac777984af56c864f5985f25fdda9b5e84a20b8d6509a8ad7ac8c10792132040322d48d641fe3a2c4d1a6f7627af786c120abad7290a3e37b83bfe6f8df92ad72f80c9afd17adcf067007001a918fd86011ddecc61324a1b197969187ca1a3d53a5f59781d1afa10f986bcd279b347874059322774f495d91ba1018c7c9823fc34109d2cceb4cc0a4439ba1c6d812ba33706c8358b40a8d41e553dc7ac974192d6f0c96d42fdbcb289bd3cfa28e43262581adf49ff4c25bdcec6634f63e8bb51831c914e09e0378bbdea024ee303bcd999f49cef86b32d3f768bbc194598365a7145441ab18fcf91050f1f0a37765cec656f21288de066d8825254524f10ccca91b26a6ef9d3b5bad9273f2190718f4e4e9ef65328e1595205f644da33da988866eb09ccb5c8ddc31bacaadf49e8d5aa464ede4de56e16777cfbc0749747c4e14a4fe218df2814d785744015ed1e6bb47075cd452c083738274d502431471353abcd28aebcf025fbad3977c48bf56220aef1206e5d7d859e9f5312e02965b941c2b389a51254e7a110f9994a0c9ef9cabaa3b429bcc284af12b3b85c1af682d5a4f305fe53c7b1a5bb714708efdb4d54db617a31d8d356d88a75ff8877917d5654215cfe8cfdeecde6da674735dd4e1e7969a31e07410fbfe71c192188c48b50e233057b01d1652427e25aa825b0d6f7141b133ad6eeb220b87430e6465700779376f0046a4b8faea2acfe84a31822bd9742198c6a55514815a22ceb4266512b3f72c6209a749d365d23a4ac1dd1226ee05bfac920f0bb4b7fafd4b373cd5053ec46c589b90ec1bacc6d6ce3062f56b47492afcdeddb1c1dfcde6dda2e7bc501b58d11ade8540fcd9ff72e3f2557f75fa44eb90b4568c39e3093de6f211376920644873406487dff3581a9a934a9c535a456fac2658de4ed47e4612b244503dcf4d3f6617d222c06a80536f1eae7229ec5ae854d35eedd9d2c3bf9e66fed8f33c0a20839c63560888d641e4ce39e0bc92ce01127b6086b3a6b504ef63041dc6acaff6f737106264177c5d8a94ca2abf12aeff83bec3f86376e90cfe1fb59c9205b4926761722d7fde0f81e7ee461fbad81887fe75397a8f08ed1186ada41caada879f71d03c1d2ed9d2a0012997f0b9e0cda21de31c2930bba5bf86366f60f6b71cdd065de67a7126584b76f61fdf2747894a6e9a043844dbc278ae83f13e20ee1b2bd6ec2886d005b2d77954ebfa373639b11839a1762c1caeac9113b75e012ec282212b0b98d5ec98e69f9f74a02ca53ac5d68b3e5a92704ced0964763c8823ceca8eb120371fb128d13d832ea2770227311beac918e2388b818caa9595a0ba460f41bf431c57a9be3c8a52d07e2f43381ac5edb054616e65f50c1b045e1beb947a2c8d9a8602ff98ce691e6868c3fd8a892305bdbc9fff2efdc76964e9be4bed043d0933bc10aea35397bf264c73a89297bead41ad303663af948017f4958d454989c8c3bf1c046234112f7eb60ad8f39cd2650461cd147c8dee42191416cf50be91b2b45aaabaed89e504bf209bb1b17f2c30b98ba1a232d47708a87ae604caf0d01b8ad7306a47a48589f401953b99fdbf4cd3b8ea293994d1e5976fb6d2b9fea4386323de788471268e8ba1ac20c302e35686db72e109f5800499736e1e6dc02cd5f6bcfd6b14bd2a1fc9efdafc18247db8b3e667dc6f519e99baa2dc702a9c0a9dc4d51ee06032a9cabf7c80bb108b16e0c98215b25a7b60efb765cc22d9d1303aa48fee49185dc5c4f7f51a3de2af0087e9b3ca5d1355f1aac0052575956bf151feb4a609877d280f352246e1930931f871db540435789ed42473d9bf66c2615e37414d9dc213b9e4590ad3da7280cb59dea9fba7a8a4cc229bc4984b1a39993ca4eb3c780110ab4d8f0a1b8eff5602c799dabf845f52fd1ce6d1262478fb8f5af7dbe671bfae56dfe5d49811e8c76d6973003815084216cbedd206ddfc3b7731f4461dd3b4682f6844b27d2f38d8c3a6f80f056ef2d0c7e2955d747b745271c89344476311156ddf0bebc36bad9478c074e2b6767fde31eb1b0c6dd9e5069585a14bc7e4f50106f6ff62f147c968e0460d0c9b04bb0011211","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
