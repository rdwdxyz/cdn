<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e50f9aef9c078a4025ac97b8ba87cddfc03ff4a30d836a8afecf65b279485214779217a7d23c0b9554344b0b04ee140029293f894265d7f05f9dd3632783c1bd9184bee7de05f52e836e72f34e275f3a84c5b10cc295b1c6d8c86fec073c07da4fca9dab4730d1ad1ce4e474f49a623830cae634d400a456273e6729ce925c70a5779ef2abc5ff73767fec483c9cfc18f8c6ee905d37b509bc6aaaf2cdcfdcd9788bd7768c6be1b95223fd442076049c99d367aebcbda64a683675032146a4f6b1f9345b3e68743abaca570b31a471b6e22feef9e6a2db39056900fee58c139af471cc3e414ed3a5e514d465bad4b02ebb57fa28e16cc7e1718c1c469fc2b772c93af914f9bafc6a2f035d3b52884986f5f152a80e02918b7ad13cb146f6c136f435e22014de79a42bcc4ec4be3a3dd01a6f365fb6812ac61c9f02b16c50d37d3e5ff9c03d69d6ac64eff7c53669383768251bc7b17d275b0ade667740ff1349135abfecaf2aae771108b0c0762cbdbe6835b29b5ca30d3b0d9388b664c71683ca7ad67f53ce867f86d3d83615a91b1845e2850ab202c539cfc8691dfdd7d7c53ff02481d9b35a84397238dd38a6713656efa334694babc6e42f9867b5f13f8f8e72cbd82a4ccc8dfedc9bce3866f844d51cf38feda2136713486c60377169e5ae07b221f7cbce556ebfa829ba84039c530891e1cc7551be49d2c2ed34fde883533f27a07b68a9fdc584b5a4a047890b0eac7b86092c642094872f49241feadfa820171ebd3c00f4910fb47d3199410d30e996ced62b08114965ae379aebbe144e6f28f08a09bee536b39993f3ea76195c105fbb4b05603707109d92df6b67a6cf915ba0a3d078c6f3aa6a5c9598f6f6158f0c31fb5dc93b6ea73674d6ddfb10fe3b1db2af809f09358b31d40b1cd3fbb6ed8781405d434b7c0d83888023becd12459347d739a9261f460b435d8c3d085b07f4eb3dcb97d290fd047033e8d2ec315e04ba6113eed42ecf65deec54515f109a4d660cc72533270feee424ec4a5303f9f8de6d3ad7e049675b7ec16bfc7e1845c492d4c2ef1f0c6cacc057f3b832e24b04ae8e063cef7d64cef43c7d677818442df57ba4fda6dce9d6b760c6e99307c53b3ecc8816314080936f301fe991ff8582b9cd42b44127490e9cbbcb68eb2e68ed015b85b600e1a02fd2479ab5a3461b8e627da95da8229e33aa8c4464f19c3ce285c7dd7802337bc18211a043e14037a391c5a6d82597b2f52e2dd888de3a34acd4d635d6adbe0fc565261d86ca787b52f5d4fdeae24d0ebf9d80a54395e2821a669826a74cd5a96d090e6d72279a36bcd805bf19baa4654f1c4a7ea49307c259bce4f975368fcf0109490021b3f11995288e1470085066df9311915071c0ba4d12bdf9047e4e3b970f9f22e317963a6b34d434cea2f50bbfc40a32cda601ad91308fd00100506147f2d5e87d2d9adca09f79c11112d161353640452553d40161d22e2c6035207b058d5fbae6994eeb84791f50d7d7a410c80c834ebd2bb0b873743f3f2879a50ad78866c539a36e7421ea3bd398ec963e4e3fee29ddd5c80eee0f2a106282dac0f5c8408b06141438e09f9fd85dce2ef9e4e02dca781657b71abc97019c50907427f27ab3ef419e1d79bcce28915c1dc7c4357c7353a3c676ee2e93581ea7a711fe3597da620e8a82c280ae535a3073c0aa07d4544e6f3ddd3d98edb1f6d221709f62e27a3cd6b17188d0e4d75dcad8a357f5ad06666e9c3105b3ca38d25d6022ac7575d893dc79e64926a7f93496982f4453c6ecd07647916483429a23eb96f6bc64a0e8a219b8bf28b8cb73064484240528cf1875ebf9affc9d1d8f253c8953d5cc64fb0da3b2dbfb44b3f31560f7293df8f8579e78f804112033082b1fb4d2ef7782e3b7fac914aa916b3e21afde4be1d5f6835e6415f541a3ef4e03a82deb8392963bb750ec3fb6e3fa1c6b8aa4306f92f9b17e7bf4539fadde1c3d9aed806990ddc1cfc8e6f9342c82466a470a953b5e53fe8ed5ca703e7adca586ac37a482cd860d637b054eb94fb784914afb1f0e3ae0b617498d406312f6da4a2c5a01a73800f4e5d07bcd2acd6bb53e9633a5e97c4506b7781f5b6b9eae8d317f913161c78cd90a10ff23cb15e56e181cb66a79ba2ca9848dbb39543704be383b7c6d73043e8be74a8a65121889f03d0ade94f4b310e03461a818129f9680a49b2998e4e61c8b8a689964aac4186b0e8a90390a53524f233a0560ff41e7e7f2b15e00e7c3349b42db7dad590dc6c4bb0c037050674afe862ef03413ecd490f9d1522a29884433bf867b507280404c11e78e02f236e879530c4320aa68a4a66eaf91d699dd963f0ca51e514fb1c8f1e01cb4b096b7d8b43d3188791cf8f0449c9bf3f00cb63beb302549e4f7bc1ac6e26bcb371718245a80729fc9abb66e2b64fdcfda4c54673e137f372ce6a0b6f55341252bf4462eca5de96571e71b18f180411e1898d42fe28e71d05b1aa01799787c102725e31407c7f1c488abd6b43b1aa31e5515599561d0c85686bf7a5f6f569c96769fea384ee4441c6267dc86fb8ce3db582868d3cab9d5c13d204f54292f71c3323506c6f6ddee166ca48ca121fcddacb57f7217211a3fd36d97615370252dd2f8e57e0446a4221902aeeef0a57935b8c639c9f13bf5eb27f969e727b82a76ef5d34f2f06d479caa520fd2b27bd6de7a5cb96b394cd29af0b00999d43cfb35cf74f364724c0d4a2fea523e432c03ad621ceef0666ae263524c74c2069cf5762943c5012a2afb9f865dabbd205309d778cf364d06319ff94751e09c94901e01cadfb9a3d1f77fee32b51a3dab8ebbb40d0f66679bd0d1b26c38f4d72fa16a6f7d95bd440c494f84bb187e5fbc9316b2f448026bee15c67e292d8284835426b4751b8a5440d505c320386737fb6e5cb75d591d9a8c88e30983bec114b4a79202f4f7dc6184102a194082ca9d9b08feeb13c08942330e406cb956acd95461b8bf4aefdf56e7cd6dedd6fa718ee0b13d9549b7d02ac2fdc093dde90a6d641272a7248a99edba1fb3c99dfb1b5c84fa50a9abd5c828777838f887134885323469c172fb0c3d25b3e370f2b435bb0ac8597a84eb468684eceeed22f7d41683ca9c39d4e6770fcd4fba199f4e97a4106281db3cdae727c0b43f41b112baeaef31ee1964108dc434ac7d2ac5e80cd655de25d5fc929221c89a4e0b9c744a3e7fdf1600bd1139459a9c51c7262431955f7ee441207fe5111605e4ae477a40f70419b406dd0a8d09be4fe56ea0a1a6fc6927683faa85fbe3fb191b5a4795c32b26dba126b3709d5d541721f155dbc06ddf2d5bca5405059be0c1840b47cbfbe26f675df337609da7fd94f80b56bda9186da50f2674eb69f32b9b418f2afbd68fa37444c43c52a46c530108e0102734cf8d9a5d311f6a6679300ffd87844211c901f32fef8e3fc7ba807ea47282899586d79d4f778ba7c9fd950d599b15b7e05b58dc41fb8b7d151bd997dfbe4281ab04558c0d864a81f68d81c1de2796735a0a10b8db2e190867ea7e0ccc973df33c42800e08fe4269012e26fef0179eb249cf3f3a8db631fc2e1b251b34d27ec360d53c779ae9c03225fa2efa3d4b903269ed961ce04fd47a09d14155e12ae46779a4237838e3b4ebb1917b7a3fdef8d8646dabce11fe78300ad764a8b2506dbe8bf3f1bba5b44af7f611ac087d88bea25aadff168f3a6f49bc813431acdb4f9c7371c0eb78d58099a5b354d7fe93f587e7b67777f074859faedd005fc9b56ca04d2ad4093e7c72bbd45351b16d3c02ae17bda202f25a2d10bc9e1451fc34e381654bb7689231c08533699992ea770ef0d85c68e576fac1a53cc6c150668c00694c65cfda614832ddb8b444fa16775ff9065ac186e0f7d32b4b3956ff5f883d5e5de72fe23e18183f2ce63a1d7f1975004e2f4e1c684714050b1472457f2e80da7aa26aad79f6816b5ef53d4f3e270f607bec8370b238bdbfba315fc7b82e5acb0c81ed91307bf10024f38437cea78582cfd52947fbe0771cdd0fdcc60fa6d4b346a8bb6f16f797130b7d6c3546decd643795146e3dd7044b0b32cc99e9d9d10e7454700feea1c9665426c6b880f13fdb9db972467167b6b8ad2979f43ed1d9ecb0ff66da6040271d17273ea3c9f114c319f9004754beb38399d961a99ff096835d1411ba60c641e04c91544c83f043c5c95ade42e6d0573605755525e13cf0cafba6c951276a82dfbd53a01b25a48a222a5fb4d2a4c9036be8e5b5185314d4a43e91649ce9130b15e5cf8fff492134e917bface839ed75a3ae20f8cb0293b920cd57c3a6972f6db13b81afee426edc6f507268b114ea8e9dc9d4067e9f8a194c0e29c1bb5c1010875b0ea10e47c2e86e0cd6e93b21e08be5e5691c3b5451661212294633017c467b7003e980f365f979a32f97f461253d2ea2f71a24df9fb942551cec7bfc60497679241a032da343655cbeb8feed2c4ba1843f5063db632dbea2b0db007752037473402d966915cd3f4386d76bf06f79e0ad757ca8914145268d1978f1e19be4e1e3f9bb152198f968192fd2f463eca46b8d76e4e925a714882b4477e4f12eee3ba4a383fce05a357dd01f8717e09d077032ec16ece84d880b3151519dcc984b51c201e6fd57776c06cbba46af877cc639381bbf2a1dbbb1ff695d8635690f9fda40b00c268aac562c01e7637026029e523b8f232363163d8d2cc02d1c2be5398a1c4f05e7e8d8aba8cd3726e36a9562617fe67c77f8260ed8f64d16d0dba0ea4b044a1e0354d421ab7dabc19216c32ccd31ed7c0055b6978e4656eda188905480feaed6fa60e0227aa58ecb5ec22f09bd45631a188ae991768e2e8c5c111a1b14beeaa5fefaa18a6cde912bcfdf5287c39c20796cb2129a9f25d15c51e1e54db68e4af044e154cea4d62b56383a488a360ebe3bfe20aca3e67f4f9a402f15e528cfdea8e5726f56e5d123e28d8d989f8b29dddd374a2c1ef6d99855fea8d3b596bf7289f77ef335c323e8e678a3279c117c8d39bf301cdd5b5acfb19d8896d5a5d286416f7e986253c77ec2b7dd6ca92661c7085cbce0f4ac0218085fcf047b9d894293ceb062f97edfc736fae7f7a5d426d39bef37d8d6189dcac4cb4fbd138c44179a0c569a60f58cab7d9fe63ed63869e440a9b025494bf85313b73bcfa8e736cb810e1e825efdcb64c5aab4d26209e3c128ed121966acb2f833c4fd441cab888d91ae2711fe6f1ca3fbdc22c9050757ff90d3f020e2854da22ca3f278b4db56d7788f57bf1f78aa173aa5d9e701669c211f8d24b8ee85b74e1185e5ba89fa4009fba123bc02b8767e64218802f7882638b4d815f49f1319d65197f902d8e6cfeda9f3cd2e684b94713682cd44c658f01111ae92ec1008c2b2164f1b646f01846839110f04e44ad61c19d7824f7ea2c138786c6ae44e436d1498ca9d044217eb6c3cf442e68795269576cf8d470795212901b25222c4be77440505a2a88425ea2451e6c27a66bcccc8c7478bf27dd3803883cb962a5262729a9e9bf396568ce1e4c8d7efc6824c3a4c3e178f1bfd1dcfa93efddc94b25538477fc20958a38d648753e6da5bf5f20b65ecd121a8d7a665ea4ddf7673d07d57aab77a6e26e6671deef31c82ca51485ba7a969d66edc72a92c564f2a1eb41b087e276c6327e9079bd46ba385a0ae19be4183010540e504d3febe6ecd84f659f8a994b76d221ef5c83f35ca9fcbb9466648f5a132f0a76ca1e2e0198f4757d0e2a0d522c35d942d06b412de760e395ddddf1f1f542b66da6dbe4f29a3d19c093729fcc365e82040367be9e99c83973e54ebd106558d039057e4d0ee6a36ed9a257ff348517b059000bb1337cb730f16ff41ba579fd785f2afcbb63b9044008c4375e9fbbf9d9b478acd64c81441b18e7584389a6c904f38258c70582215185805b71bb39a19eae771860fe4464ccaaf997cc2959b497640f35da1babbf7b356e166f6e5501e34a033628ef9323b5f4eb3186d6f24221dc3365a22d825e6d540afd6fc8b7c6c75e4e35551bccb7c2f9760aa4360e3020f85ba509c4c5303a7d039eb0db9d693aab9ea826c879f5e145201a2981e3092bde0a7656256ba9c1eea14eeda22bbf1e5f5643d1ee1f0b944dec12a1cd111133379c2f721a28f9faccb3d71ebd6d44e63fd3ce24e6e9da166bdc779798e28ec9285e0e276aea03050336c071c2382a542ca7373300bc9027192a0b6a6c952d4fb6e1a1700fdbaa9785632b571be1bd783d3044ccef37021f3dd8eef7caf0360db5ee1a83f4d4be4e19734caf50e3fe30086bec5137565eca3e7b705cf42671ddf14583ccb3483b4897a6a2c57582743b4dabf7e6b062c489bbfa003ad8fe0a193ff1f1a9d81881bf01c372a60720bc68d612c7c4078e659a9f564ef0f6647eeee65882c2f4126b57bf912a2abb26f94f2ee51a4478d922c1fac5fa35db76c6447ce3c8d963f641981130bbb650125d788de28f5a38b470a144e5476a38863a72820df63af25ca6ca893877a9eb975618b79a03f596d9720dd949b92eaa72f0ae6b9b41119529598750b2029791133a7c739d603daf1ed2f3fc7fa79c79f97be08bcd422694a91ad0ed2eb479f62db0b7bcbb592ba2c4a51e83d86af275f31f8fabb815ef2fcb6692b2def1aedc5feca3f20f5e8f7ea2cc2d63079dfcb531aa5fbabe3d3f87c9e71203096bccf48738a34cdf68c4181e624685ba6dfafb598a7a7e0782dd32b3327569366271d495d60cfc07bea20331a37a28ccfc3a9c194841f7273cb53a73dc4492849067be0a97cc63f5941091b84b316ad565413fe62ecc10549937318d3a39c1117832a36eccf26188cb684d2e511560cca3bba5cc00a77da28bf2cb96c231af478a41918d14fa5ba583c9d78824f3507d691b75c6c8055b94174c9ff4bbfb458e3e6f223d1bc05ddddc0e794e7a3465c7e704661780e1cf753907452f678a509f5a9d0f8c0ef61a13bd389e4ae9b4122aa7a1a9d3067f9bb1b0cecb726f8ffe6e28c1c0f17d2b8763ac80663ea7efdcf185066631897f723494837b813ea01f504ac5517f5941e03f9073858988cf7f7b857165e1bf5aeb915b4cf86bbf2bdc41c7a169ea4993730aa7f2694d8bec547cc9ab6b466a7461fd6f56a909ad3ca7935534f00831935a1509d35c0b8786947aa5fa13a5435ba7f178bdf1cebd9448808e0365e8a8013e5b83e91d3977099489801ce5422e31fc5229d3533c16bd0c16cb8b50f8f6ef11d5dab2913ee33be990b426a32c8b8126ee524d6d1bc3aa0e9d92d1ebe74b9da05f2231f2b625211be5c5d73571273dd4e3be3679c7e3b1c211e0b9adfe5bfa7088eb36ffa151809806e1d0e2f735d32c27641b07f47be93a6bbeb3bc97236a466ed48ead6d2c5bb6c8792b5f8cbd17e10bdab0033e3363aa8407d351e9b6fecd54dfbc01481d565c7c76ccec0f59f5fd1521d2c4d5d3ae5f90397c0f8104c1424639a877dfc3f745bc4c3ec6620c00719a341708a47b25ec194b1118b584f003003f7533ab48ee1e1054ede187ac757d4494bb925005eec1315b1908258cef925bb0769d2bc82c43e78ea3e244f0a6651a6a76b6ba6cefd3dd35da0522e1d030e9198d76649d8575946975f71602b3900a1f69977176567308c042b78365acc9c44ee9d9a8ef1f036f63df1c84173ff8cfb326bd2ee1a6397a86a570b2d3b3cd137188f1fb467a3ae5e2530f797ec14f7a3bedc31335988a46921f934b9312ff68e629bad58e7e029db69d0b0862e664e98906a81d58ec1986413ef8e6aa1fa36112538d2138b8918bf6e2524d07ab63221466f0eb73402763f53d28b833af650fe3d4f8034d9ca34f256bc691bd2c31a557ed9161fb72b8d46fd24e856c46426d579e2fc35e799c05d851426e61da6ab9cf2fc32fd08f8e95883cffc241ef3be200ddc90bea04244dbb917e4c1c80206d427d3bacf77c29c74f20072f2c277531a0cc5df8caedafe571c2f691903a5e6ba692407c6290d52bbd798b2f02280caa929e9b28f672f2172afa53c693757687b23182255c2431289b1fce0c683cae50f5319cd9b5d0271ca3db044b5e54bb3aa91b01cc61a5bcf1bce38f36e6d5d67040ef18266272eb659945dc7a3e38445969c2d60fff0773fc97cb9c48613e6bb1874a39ec2c453f4cad9df650fa1084e715b9ef8c97e9419b53b31c2ea520731691e8eea1606215282586b0ff33753bbe03bec7f5b7aad59a36d1401b18e72257969653edb7794b7e27da503c940a6ea958a2960549101edc9c1505bd92c99edc58c0fea51346cee7a9aaea76debcad2a17b38bf0a893f3a93849c7e789b7dfc7a8a88c243726bdffbe167668c493ec57fe572025fe5fa743e21dab22c4aa2a1a94b0e9c2370f63227ccf333c1f58add346fe5ff3140080b6238790bc86d7bd23999d0435c6da88e5eee80b6f47fbe203f03318722b0faa6dfed87ba7eefeaed6653f201226eebe9ddb5135465f27e9b48b1b44f7f724efab7229cfb1d6a45160e579ff1a7765e852e9a7e8251309797995f15fb1f844d8d65ccf0db6275a7d1aff8da0ea0601713a37c2d8b34e85bc6a06c55e278e06c21193c6224f1ff04b4f03d728e3bc56bbd885d63f52748881373255f114d058820cfc2421b6414a03b3c35a82e7fc1d4873226bf02bc0a5801a98cfefcf0d5f5dab65a5e894428a5624b3c476da9d330edc3d688feee11272b8c471614aba6690197458296fc72b69a6f9f1fa609d37568ebdd14d9e71140f27e3de82f64a5f424e37809a6cfd4c43441dbb7f961541ead180af1b71b4c9ce5d828de30dd4b950f7eb517bee74d83d28b6dc03134256a30d14d91c52c580762f99ee6f4178ffd47cd4ccec0f6a4295d52e51bf236e7b22eac3e9f73af252b2761897a3d0f598f8f8ab28c284a7d1ef4794533f44171127c3e5d34224cce28d724c0577f88951737e8ff593d035256d188b336e2dcc9bff9d17523d249ee87b90e39d2a02d4ac1efed89e31b780500ec7b40ccbe16cf183352c44be73e8c3c3ce522f495b9a78d7f8abd3c687ea5a4cc23c046843cd8b6f443b5a8e22df56bdc1200866cfdb43b46bf1140d04fbc53c3072d8af00fce163f430c952a5cc1a4b6446cbde5899527b053d036d09ec164e72f0945607fe41de0d2e09b39956d0540d6b6b5ac2af9cd33e62fe2180b86b3c7bd88b353473f2d32fa324cebcda918b0b367975479a2d3bec21371669844b56026758305b4a376536fba2f84f63eb28942ab3f039288c15534f795b13efe33efab32de7d9d865e511f46e46d36bd905d406c2be04e02654e655023892236f16350e362cbc46d2df7dba63770103d63f5baaf469de6eb156fc06f8a23e95ee8e4b6eb0c32eb31ec37f084d60b57257429641fb6d501da4b178c8c6561c99c2980e23931101925b91960467bd3da5f79f3ad2f76c6e7c73f337dc9840256c14b62c9c666659e942e2d4002f8dc2590e8e10e99835f9b45218163e46c7152a61a5797dc2401e5f43d76d3e42535f08c3d1b2ec3b526ad2b53dc4cd530033488def6c9b87957d0f29fd96ffb782f97d4f70f201f4b307b8c72b6dc19cf01ce5c33b3af08d520f8f4cd0e8b3a624d1321754543b6c469ca68dbcfa9f943293d319d3c5cb8d0d286e979caa87b6fbc9c652cbdffb660d4fc17835d7c0cde450e9bcd013bc05999be7f0530ede085ed2837afc695a6dc3405f777f1bbc8766a06d9882b36d3c0e6e29e9915cdaf4796d32518424f9ccb9479db78ca84961385aadd6c0cccbbf572340680959a214eebe485217915228fc95001efe331547b8f86d860ea4a5adc192d5c880eae4e796a023b5a60982e49d6d93aa9559a7cc6f13972420669ce274725534ad02f2688d27af424b3225f2eeefc62d5297a35b5e837287390d61b2590b0de231fb032dddc3da6cd2bde7d290ad9c0892d0c98a745fa9a22a6419cac1e08bfebdd8084ae273a725c37fb96aac33478d72ed9fdedd5f6b2917ebc479948bd55fdf401d6a193d830dc70ff8238e9f5e26e8b6d8bbb71c65ddb628bec450d55a4f80378db4a17c6309a9299c6198a1cd46c43011f151be4acd7085209ff54874d2aece2cd17d4907350d690728bd6b549bfb261b7af77ca96c3a41e9269e9783c50998a23c61e1b7bf12da558bbc4b007e21ef4f7e4a3032a1fd8f463fe7b470504248e77d1bf1fe905bb7273e878c182162be53a767698d1a86388b0bd9e2dbc0ec9e1bf593efdf09fccea90dd6d56558b2d8b6b3ceaf0465a755d369b58fec5cb936150358fa7dcdda36be86937e3d6bcd3e704b682d2c148d17e0207cf84fdd832d42553d43be5efb3e542661126174aaeb93d46b62239e6ed813905a14e91ab0dbbf0ebb015d87b17bd40d454ea85d08cf4630f63e5084e1fcba72cdeddcbaae2e519091b9ca5e23c613e2e4665789335e02386b66fd925352d0b719b037540acd05211c25c542ba999cc2b903fbb72073a592b2090ab5a0321d13253d3afa0c3382393ae052859679631e2473365374463fc4e55c5e61e0f842b4110d99230f20cd4136e155ee59a24be7d646c5ad20396adbe154e80a6b6ff32b794926ca1d34d980418be973949c039e845d17199ebf3b8985f43b207da29e84c5b5998887a76ec15b7a23b28c421e05779bc669f85ed7f26a730e99b8a7d64c8536487f4566f74ba9f431f319373b3d37af92d676d2078ab61c09bdd8153232a233b817974ad682b04d3ef58fc162d734b9e78bc3458c5a83da585eeeddc9babcacea6bfadc95d111fe83fb7aab533a001c717b6956c87446d7de9d098c2c7e0a1f57062bbb84f6ed9fb46aa3af8d7f3675a179208acfb0c6d624baa21b8c1f25840d2522843e1f259ddc8a40845bef5b4bda465d0e6d9a229ea3d2af4b14bb826659f5ba1e3279297e7480e6ef0e224413b99ccf07277e100302b69183a331264cb5a936f9dada3dc5712beda7b7a4b4ed08d596f2634018bee551f5ce1c56fac943cf241d520fb91602f335be73e54688fce4d71eb4b526b50e263932074e1ef7b5eb2c678b22de0c44e35be978c62e74ba39a684e383fc7322c86004e7a10a71821cd0bb9bcc8d6a6fcbb10b1ad3b34ecc14181db17c0130e9b109034f55a6ff4d22312fb9e146fa2560ae47a3c467f54b37c936662f66a98dcd247dd99170b15e022c83c9db9b326c036ae158452f39d8b119fcee25a0f7d9f51621897ce014ce2f8daae55cd8a7c59ef4b8c3473230f22203ca8175f29cf6a724829383d1090193ebb449bd8689990bd5b2015580ed7e65f2ee221fc3615591cce3f7054cd9365a1c7fc55b45015139b095d2ebfc040cfae5a03ce0e51d1112a9b54b8b542de7107020c40627f9ef720c535e1a7b8c83ad6d06293a6ab9cc50455eb86ff9214aa8eb42cd3a68084b47b7471239b3f7fb571729a40dbb793c6ddb43c8db3e12cb1966d9de76f5c62b888451b1a10957e1b32bcec277500beb303ea5d60d156536343ddd4c2dd3c3817cbd4b2b2d834229c94822f828d52a0a0c97057cf8720071af812e85a73c69745c2ad0beab6da63d19212f72ca63545592da3eb42ce637353dc64d55862b90e6de84fb9a7b2f730b9d6437cbf6afb30d49d2a0e22ec77c15bd1642230385c9c52301bf778cea2351e91df4f791c1a90acb6eeaa8e9a72fc11c2e41ad9b4bd95e5b415d384cc7ad2341ed9e8f9b51f8129ebe9e43ba8fe5e84634be0e3f692e0bc52e7aad24e5551477d23573157bdbcec44da9bb83dd45e050085537e880744e421a6240ae5ee06609a3f5aca8f425dc6be9d18959f0c1b57a5b50db223d6f9e9e84c1db39a6fb06636dec7a7460476cfb498734ebaf975a8b107206f217b89731982494b6808a6159b1c5289189555f9ce1aa3821fde2e4dfb529eb432883552466f2ee5045f3aa5673bbb0957d07051dbbe23d5d2e387bec302c641d06b308eaa60ba4d65dc4e9a5fc537fdd4b9e1b9498fc63d2fde5b9fb05b61f13b0219ef5736b34d392364f9905d36d42e8143f1e4bfc88046376da89b08aa8d68285b18a840a3652285b13d5aebc98e0da66f222e85a067f252de270a13b66987484d4620a0614ea0e26ca8e8b6821a506e0be45a7d3d5077fad6d0870667a5b8bbd20261b19aa8b95d0cf3f53f82247b641143b0199dae028d625055a6d916e7e698df1685ca41a15f59cea270ebb371a3ccc736ff3aff503c517c572b2d9bc61935e504a0b94a520fbdda6a4b3c6ee14edae5e6baff9006980f30e090f3d5aa924245db639fbd1111dd30d8ac0dc3e7ff95429f2c8cdd0379eedc80db24150f0031feeda5868c39f7a26922d245649dcafee6d827a2e895b091ab99f6ae1dbff02ee26601c8868d1f794560921f68614ae1e5470492692cb9de19e55cf6f4b738e156f15f7587079552406d783b6063488505a31f8e4fc436d6031ee3d6e38db217b6ef55c13a2e32107980baa0e42d70b6ad8401368029abab725f35ebe52579c61f7eca26ce8ce07bbde01a06d52bfeacf525ddd4ff9434011303e9bbacfd0a98cc635f47069530e44f912b65cd2e1672bc06cae6d21bd81933c19e7cfd3be58fefe3f2e3bf9599ec2fc7ff5fc36b8f438f90793137aefbbe77e386e2f4629d120f24e522ca4919924de47f6ce0b7e616227b5fd2c4a374fcff2821d25068cb2125b83caa7ce87f76da59d724e60e0190ee157ec70dbccb1985315ade01a5c1eed672927f1b6b824bf42aee4c2fb84ef9cd41d9d252dac7c543db435f857956159c545133db68810ee4047fe76d7dfee9b524eaa715358f2d75b3d9b355dcaa8b1cee760fba4c9834e35c1007463436a1c4c6c4d0afde3ec0e49134b2b2af94049199acd674d638f8e669fc4ea7e9d58f04b3008de6ed37870690ab9bc8e0f3279a02a0c6a27046785bce37960506db65a27b4d6a63bc9185e091728edbd9c4c872340d2d6be9fc74e4d7bc2227d057250b2e33de6bb1dd9c6a56dd049f209e82f2fbb61d6fa9d0255430e7f4c95503bbbcd90b10749e1b4b269e09366cca59a161a1eb97d88c9dffb35a2602009b4d904582026124f0cc8c6453e565e533cb9eff8426c35daf17d0c5fa424b103c3ddf1ab0791b1bb23c3f5e122bc4263741a0d0eccc1d9f3e2862f8f74103de7523006c763cda21e0123240501c57e5c82700dfc382344b840abef215184de663a32e7a2b1443f2e9f3bf7038121e7907f3ef898c748cba491d6d7e0d821f487c8556efe9de485b7860c83628f6e1bbc36a3ddfdd5f4b0ef5356f8f21c6b497a8f2e3815feddc080b2b1861a893048245e5f80ecb5c3b07a7512eda717ae6b95169c09d349fb2e71f9783e807ff1b237453942aae1fab2adc0a9905ea3a4c02b169aacdde524053629d0fde72d096ffd6a707c88e2164d3081b1cdfdcf1062bcafaafff88eb8ca0f33f3079d60ffc28a068576b12a3dbc5968eb8ef63c6a37b207eb2c8509a91cbcd7a8825997add8279db066ad5dbcadbc35594991c0e674b2ba2d9f7f3e5036e6b0de715030016b972262a8177035fb826aa70cabe6c7fa381664451db394e2a51e908ec6c4c8e706148a909271029c0452a1474a02cb099877fe343815cd319956c5855337148723e804c69a4a1117b5c757f63cc44adf97b2163788f9c9c182c22431a01dd29ecc64458554412c6b981e89040b0ceabde909452c837f530abd9694cbf638cceb397434548f776e1344b3e6cda7a4b8ad93d23e4345215615476332bd80b1cadff80f9e0b4412e55761069f12cca6abb872946ce26483905da795a8c81d1c5c66ecff9dc62a90003f12fb63046f21a47498b2b0f1cd90e1f5b8257635e887f3c72680aaffa700665929ccf4e363b024f409b2a6a83a40ae068bf1f7083b65ccb0860fd7b946edab8190549bd201f497cd49b6e4b0251db3d0ce198727f9f4411d3e1615039ef7c864a0600b4548645fe7cca857800912e2cac71cd1cde1a931139969d6719c9d5397c942d7d05c4e71bc543ad7770a88bb7ea6c0c28ffa19399086f14b8132cabd4551c5c29406d2ab1c81d6d3b1d653c823beaeb32ba26b16f6aa00c19765db9122d466b1867e83e8fe28e6c43dbdc4f325d200abba7cd89b3a6db47cbb0398510f518e77052c6d3ac5966a1ed25dc4855a677e6293d0c3977655536e1670b4b19ffddef7ea0a1c1ff38a33c6ed7934d6e5290d2a2cfedb041c6c7346bd8216e806b0951e20328da950a988fdb45800f434fb5b5ef26bc3ccee443617b05cd1b538c14d5674378be0b26e730b9ebcdb86eba1b96c772c915a0a0106217e7bd1fa021567128950bd99233b9f1b2e788a9673a7c5e015c50523c7e29f331e21f7a318fea469f9aac66a0a55a5513938045f8b154c86c1147bb9195a27b58390ae43315010582bae1ae9c208901eb476bb21e590143691fb4f515f6ceaea3e1feff980d1a594d4a9d75dc87531a35a819db5dae22bac95686b676162676e8a04f7e5c6b6d23259d89c3f0c4572eeb446275c090649b47d6e9b1f63ef177697ec1981c5d9619fda0fe72773db66b3ae5c138446cef3ea6d80cec5a2505dde73f69472ea53643bfab633f0d49af4df63c4cee024db74d243f00c537d2945dc5be80b8027f67ab6ce2e0e51af8137e8e72c6b04123777ebd52b0eed8f3935300c059865e4f2330651968f2194e451303f1abad76fc8c13f930c37350361d3b7e7010e5cea91a0f855d3353f3d1a3e0039857ed0e770db28c34ab6ca000685051a530a71bc5f15e3df629eee0036f50ddc22c27bac3b7e2c971578ee731b1963a094e269ec9d4700c7eeb901d1bb641a145d169f9d229ee52818d8a2055ccbfdab8da7a1fadea5495f8348326af86b8b4126bfc4144c458421b35b8997556f92d88afdf44b2fe4a124d37a9e95af0fd6690755bc98eabe20a4a055b8177aeb9de68181d50d06ba9b5b564df961aaa127ccdd1416417d4af7ed1460783236d2e4ddd13835a3e54f2028fd620f142fd6a079ea4bbe4edaa48618346c5e7f761368591021ca97e760ac62c51d04c8bdb6d14b883f091be9512a29edaae1dd092995614951b2d946d0fee337419e31696cdb900b3864d57164f608b21d7bb42dd1598f9f078622ada64f5c0bab72d65703156f2e02c6e710e54a69119a182506a8dc9f017afffd6f6396791665253eb542ea9b8c575a210dd81e61089f5529fb20fdaa0ef4c886dcb7cdc1f4ffaaddf849c3560b68a1e6556357e5ef60fbd6a775abcbc646acdaafcd2678a79ddaabd10c79a8dcf75c5e00646ef031cd9db92f2c938eb0b9dd6d8bdb06e866c2574d01b5aa96ffbf170ef023ebb0d76f5539437eda892fdd6b7836354fd89d56766c1abf9db17efdbd5b882fe52c1c9d05f737c0757980853536904a7b3907e74e39d53f1badf7010b1a772ea7a46dd4d35b13b6aac2d4f1bd74867879fba816010a291d9114e0a6f15ed27d45a9a0273c4280c9b24999a23cf1eebceb45928eb6c001e454fb0b1f66e0ee3c0a9a0094ef02cc12af0f456051ab20e8cf916a6469d1a542af75ab82e551e84bd92986db06118b3d74c1d9362f6873e84b4821850cf4c7e7d028af8f44ff298c3ac88da8c70705075098466d9975afb03a9c9ae951f717fb01f5973477932657d73c99e6e05d85830d86ae47abf7645c4c582d7ee62cc028dd43615e7c9a951f0e42e2d8cd558fabc81e702b608c61c78a73a27c26bb10d626b1125c0ca3746259c069926c4c0884294d1b915a8ee4d9e9b985e23c51bfdbb2650a5107601c015e75baeb5af0e4a166587aeea1e915b0a036a27e8fcf9ab400c1c785c5b1d5eba8bc1e1563c3fc39058cecfea2c0aefa56e34037cbf5e93b7da7f8b1b071c71ca3b26044eb93e592dbfbdbb7c08630ace2617460ecb971bea16ef1ccff34361c5be17dcdb3ba1d1e2293f399decb03c0de84593eb40cdbafcc6a343993503d999660f4db7810b45b585cfbf46ecb80ccc7f76a9de447bd444bb1af957851adcb13ea28a1a5b10f27997e0059f0540b872e37da07e22fa847d4bd4afe479aaf6e9bf8fd301e081228db4fcc08bc9f506a9eb757ccaef4cdaa9ca7d3d1370a7d7cf735352e823779fbc1619c62646a75fa172469a18a27a97fe76059206d1057facae35ac61faeb219d1c50d0fba7e993d9ad0f75e83f14b3fc5a95225566bb53aa77ad69b05600f0d63990b2cb18a284409bafc789d05fc59db5acb34f62c825f2eda9e01afdc6c2d3b3561db0c35230d24cdb1ef58d319612092894d30cbdaf5d9d5a2fca99a4a8b5b5af9a5cf8b60b6dcb1ed0162f698b4d74601417e2b9d6923db4d4b1556947ba74ef39cf006a369d62a0d95ea9de287930d430620b1266907474391e8c9c554309c220c0ae69720306bde966d54f1c34416c50e25bc9e1571588195827cd7cdf8afa38ca1ff01c7e446f36f4e152c151d4a7a9d4f922c7eb3f64112a7843105f0a3d62244f98b7c05ffcc849704bd422831b4686852bc4463abb827c6645b129a3d09f78b40afc17273ab5075ab18317b497eb2f71dcf4129b2dca78a86341b12fa5afe43a8a1316e790cf32b8db6aae5f7b6c659d4e9858f921bb77d38cb3009acd1b76a12f2dd4e6375ce2404dc1f044c5fab06215720e0e295b44c55d505710df29861a521e561e5b5cda18eda277f2b33723d1efb8c76e27508cbf5beec9e8396cf423988e294decc3efd831404bb5074e7efd2f372544b9fccd17d10e2fa9b67a00538055251ee2cf89bc08d63b7ccc5d0a200aaafa717b772461d12ae664cbcf132226d9bfd8119b3d7eceb9be389fbdc89230dc201a0bfbe0d451f9e87a6ce78c42c7d571b91bc1d878023b3fc34c24e3758714c0630ee98578b376aac2c29b00f3edb7d7ac209b6955830f87ceb43b3969ce8ce6e0b88132e2b2d02b6a4a596d3dd43472f2fdb2bad8f461924c142f2df09eeeeb0e7d6c3d5e0e0eb4042d188872b753a01636a11438929e71559c7824c8a1f7af51d74af6712d449fab26b140dcef713aaae4bc37f01f01abafcd15a9198746bc6df9032db23e13df74b7df8aa87e41aa77c005586a149954a8de1069719f9f81f5b85c0ce68fdc352428e0e9ec42c057dacc9bd4141375142d521ef26c2d7ce789027ce15ca3ad0da6fb1187df3784ed8b190481742ac241840bf373da1f2b06127d21dfad522f13b8efd147c0212a2cc801a50156e94c7d00264938ebc8a597459c79cb9124f62835aa6e082cd6e6f56a0b250a096b25a014059f91ee5d123978880a5cfe663f4c878993e12b08a566aa378d1ebe9d8c2accfb12ab71b44cfa98c4c7c40722d357ab207593eef1294b1d78b4e4751e95ea030713617fa57fe53bfa615c2c8eaf3ea507a24d8add47f15bf744450844c0e2ef888853b8d6a4ed8fcc4a24440f1a7c8afa21901a245fd3031c3ea134c069527d4cc54e9e5fa8b3d12487bf85e6ffa7fffe0aaa7606f078d731020369c9a7255adb28c891710a711fb375cf85b218edb84c0c4341e86f7726a88982180eefcad02e33da8119fc29a735730e0544161c6bd96d44630c247abecb73144af2754dea34198fe9c56f8ab81b30f0fc0d15564d14b8e30ad92d090041d3d289a4770e2ddc9b13e516265b5b9760e333b14acfee50abddcbf349e24da0a34024e5c06adc5fac39c3ce5cef1e80be054243ce52ff87ecfebbcbb3f7189fce5169dffc1e6629e7507bc881f473a438cf3a33c77fc878fea5384091caf170be571c98a8ff37d63f92c7a728aaf36eb5ca9153bc0b50371eeff8c6fa4d9fb24d6c50c27c4eb437fa8642fd38adf24c7bb7ab340f8264dc5e1335429ccedfe00a03be35b7a8ba4b9136bb9b79e6bc2a209db946751ffcfaf92678cb1b59f1a36e834269cbcccee9857d3c310bf6a74bb209982c864eb4e3e7c4575858b25691","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
