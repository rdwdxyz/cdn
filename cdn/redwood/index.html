<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90483c8a93095e585ab7d0e1e208988b3e99532292f79fd4ef4a754ef8f355471d404bdfc2b7e06e409e52c95243dc6f7c5d8404dfa1d803a3f781c1d8a31eac8f4469343c6223ea4fb2a012ed47025b0fe1cba022247f655cc1266bd4893506918af1dd2be7b2dfc11982d9a3505659e43d7bc1003903859e29882384e818d0b308e2947837bd3ce18779218f7472f3402a23509570ad90de48ba4015f1c0e315c49e43091b6bce8777a7d7ed5f5edaeb14a6b0880de24bf477f68613fc1118c597dc936e9b0b3f977b42cedc6fa26bf2047269fdaa775cac9417d3dc23c55ac7b9c8354cd42aa6dfb7dc10dd0dfe1570b7f4a37c9c5c55c438d9ae2573199a95872c1d75b255c02e8fe07970f6c644ec4a895027758e6d9da23f9e5982709bb8b7366b8c05ef74c9c453f3211089f7153f2e4d8de2b898d4837899d6331950355e77cc09f9b44a35244319f590e284594b7df1b289e870dcc0b0fc1e440116c850a8dc76811c5d2bb3c3e66a51377268aa8d7489b963dcdbdbfdaf841cdc41bb61da4d722f998cb45a43449c50e1ecbd9678df6cd1cb3765d24313bc9037ea2f244a1d90203a6afd47195bbde9aa7e703a92c57b452c956ae546551d0742633891bf6adf5ddd5c4944a1e3bf0f912abe6e02d87bea31d27d0867cf3ebb6947218d3e257cb957a326be16f1826bcc496607c63a45a2d4d997a57a9acda4a4b8225b89026892972dc79253d1786730043a85eca63672202ffa1e0e8e050941d3d41f10c9b48b1b53a7f285ca1bec1f443f0815c93e078e238b5d3c107b6416001ff19cd16ad4cba45105a9225bc893ccb56cb7381769a5aa5ef2f0b41d1d0e37d9bb6ae3c72f912d69b4e908ed3395c7b89a7a6f797d2864ea731ab2f503255259660af223bf6d25e459098fdd03e6575df30167cb4ebc993d7c3ceacc67f6e98397188f69f0faf6a2cc7ef7ef1b7dad3e2f51b5bb3f5ee551f571af66c7b83cbf43814b441e2a9456f4b4f666fc0ad32c473ec2fd167c9a77e759e120fc2ed92fd1b6b6eb934afa84fc9496faac58152c67a9d0edc72d3d75a3a6602d05d5b1178e511bb1d13a8e6f4992e646ab6580009604d03b655e88417f5e64febf8b52eff25042d9fca300c57e7924a27faec957514092aed7c9bea355a69c1530630287b372dd68aca7031c12c66ab4d14c2d2a1397e801b400470a8087ce9985aa07509bddcdf9df14b235c52663642a0e15eb2c86354aca2e0140ee2657f003f85563cf67a7565904b666fbf0feecb2f1be209423db20d0a4ba0af9c3c7bd7c9bc17ac695c40cdfe545895a74a7898eb3287c9150f5370f96cd71bb84137d104e2e60e98d273360b405d9ce0d33336d92311ecaef5386e9651e47d77341dd7ecddd98c195a442a558784d9b3f675ab6eac52aede50cfdb0f44c4141cfeb109904b851061899e770f6e86b92986e8d2892d1357ee4ec8ac40d1ccbdd7b9f94aff4dc740b47650b296b52dd18903fc3bfe7eb619d99bb19d50e43cbedee9fd59cc17283626c24d78a06031bbd6fe083a3122066b22b7600d828e07d9c7912e1d7decbfc3a5ed199b5b7b518ee4a4d83d5226950d54c3552c634fa3da950d82db6490b2e78560369f545e6e5a0c58f91638c1acb7e5677458e7a28b36ef69c2d9cf0712d990b20583cc81b5c92b7f62cac996e3d7d8f244da46ae6e0b355fecd33bc2442254707bb931883fbc19c90894d70381115fd20e69e0a347191f03f7c6f21a0ff6727d75aab8a9ed5e5dbb0948cc6be99f2b0c994ecf6d697784e1d6fa0000b996df42900a61befe40c27209ad7cbf5bb8270924fab9427c680a8dffffb5a86e067d9479c61ca7343f3379403daf83ad798652502b288a65f00e27b466c9f08cf3763a0b31674be73ae0867e8876929aa5b3a842a00487c382f918960684b080226d942110f040dc07f9a1975e296dfdf49b6767db3ed78e62928acf0bf8a5af3380cfc22087cd08567cd7373518b07d189bb89ac38a9d54e6fe1784443ac5b477e409c5414a5a44deef5c9f6976550c2d51f21fc6969a32ea9c19b9064f8c03bb9561e193fd2e44cde10d8a3c0fd031736494eb04b86d3426d8414ae1418141ac04f2f9275cf0a64b4549e1816c49c818f8b3fc6739714b85982e012792f034c016deaccc94f8d0b835f58d1648ee4fcdcdbcad4643b72091358ffd8318f635b253f013aa5c2cb89664859f220045d6ace5a50ac26acc7b6119aaf00b3d6c586d79e414c1b336fc8ba88f4c38aa15f8738b600a04e6429d826c8f8a5e8ea7cdb1755dc7685e96aa295eb023d9b672975da047d3e19e3f072f7b1c1caabac7a731c5f984acd1e1517c2cbc1dae296d754bbc3d2189bcaa1d7529e9770d0d5080cd577759f6c092a43eaf5dbe6f23f6ade12bc1039ab79c7c3c297a20c70fc7c85d8a075b63874f3d852a21c5a282d5b3258840248998cb2e5057451ec6196978a322108963e09052d23654f3b9e390e765f22ee9bf8d13a7cd0ce794ecfaed8b6eb78359baa88dace85e54cb24d564dd62d57021f50f38573e3e0b1aa44697f86f52a4b4fa6c6c3ec947909418267603552ebfe53e57c7ffa60218f4e83558819da1f1b404e89e14d805c985754e1aa68050d83556b802f98f3f7ef1be488854aba713d99fd0dab4b0f3c435a25d9fb0ffd560ebf2928d76a1a4d03f32bec17887708ecc66a0b5ed1c8922433eb336d2ab548e5d163e50d5169b0ee9d554fec92634194aa4fcc5a4007a09b9d716d0cca295e337c9bb7d403907fe2fa22b5b8e56007f42477ca3bdde4e8aad11dcfccf5f94af7a4cbe87d21f7e27ac5533de721240365e340afee308506f8e3aca165cb73c2896a86e405e617b208b6fbc2b57a92b32d2a31a1480b8dd0ca1210a9c618737f1f7c4d3fa3825d45575baf980dc4034ac0a496f090ef14372d7ab1361f46f4edacd73c33808146c86c87decd879779076f60e6f725fda161af6fb55f5e27372989682280bb6847f5d718acf18a33659231e63f3c86b949c460646edf8b0fe38c75d39fa0bad83386cb1810a59f839c08d886ad5107d73c420b72f9c03c600606cc06a129c518b185e130e2625b46c77176edda67fc5c4a7d9998ae40c834e209ff22bbef660cdc6db50605a0e913c4f9eefdbd8fac951873ae080f2f5a6ee638811ab0cd39695a4bc23a6aaf104b016a842a6fb111350ecf1faaf7f02ca77724a4822fbc8fab58362fe0092042984485deac9dc809d5c30686342a9107eb1b0e69387e46937bc4123fd8eb6ee871e28458fd8b10bbaab841411cce9d549dab8203debc366a5aace331b51567d7b2a159e641486ef9b9c43c9971cc5c3154d978bc07a8f46d478193351cda29b34d1327c732afaaf98e971c0871e3aec1556d44d2e9bea214319eb5682c1150133f02a450b12fedcb4266e6171d34ede5b14cbb12bc3b94b4980b13dc9bee5e21a682a870c2c33d7779cce784bdfd6e903093d197a8c385bb79c79d2e83a85ce3c5d28e21ab43f23d036a3a5244f6e228c5fdfeff976ee2ceb7c76eb558eae8b85be150532dbb9a3468a40745a21c81c4de17df142d1bb063058257a8ac91c248c1c0cee7d9fef60909e7289ac4603d70d4657094c782a8fa23e732f9729770e42c910fd246a810b1dff5c71ab6a16aadd83055b453f85a61d757b9f9769d01fe5ff07aea4c3ff2092050e699c5844dbbf161bceac93aa29477f25758f766c2ee9e1bfaaf929828f4fa0fca295da2ea926db6de65a6cb75969d1dbaf34651c04356bad93b4196d98be7ad037b41f74e0ad9fe3f6fd5578f09235a8d23b0b5d2201b2a4e0693f3bd394f64e147e3932e8da8a91c8c74a0779f186d7aa7ea3724a92aca8337bebab532d31fd263038139d4258399d2192caf53570e22b1e4b82e7bee5037769b340f142f1aa542bf353a7a018909e537af7230d2ddd3e8a08ecaafbbd4c19fcf582fb87fa658c9cc6d0529b0e7d7258b6b5a54c7d0837c96deb016824c226ca6676d3917f1e3e4c09ff906424ca859780cdba8aaf81cbfcac2bff8aff73fc9bc6a33ea367652e3cf5a87907062f7967c128088314528ed77ca94ce6b591db77787e942a36c8b4f11a8d9caebcf3597774ce674d5292a03615ea3e5007fdec5934dd250659d70d989395354682e4f686e25625273fbb4194be4f8abffe905037037f5cbd2852f1f4803a965af9133eb06d10441ed35c0eb1512c7c7bc51d10ffb9ca8df298e62051603f3e1a0c5bd657144a715bb685106d69f49748dab1dec40229b1e05ce8462a431787b9e940179852760b60ae7dd4a88ba1cdaf99636936c928f807b0f7ed4d9fab801b2a798208ee3dcc4216981cfb69f8253e480f5a605490c5a74c73de4ceb60c6a87b2ac5bdf5a8cc605dfd21f13c869bac77edadf844656f3221084a5c55d5580995bbf5c43e63f6403fe2590b5fd87456030aec50919ac818cb04267dae38b45a4630c115aea81935699ca0888d88f846b50167e7aa206b301f2f6908283a58bd793b8ea0ea4475e81b5a1d970ab35a49fedcd068507f2c9f0905c8bb67bc5276676f865d3febbff1b5836b46739c8c2ebf9c8aba3084f5a2de67ec6ecf8c825477ffc3813e3dafb1a571aa65dcd9869dcc611f90f9952bb4fd21598db72c554b0956bfa08767ebea773a11912cbf2299154cc823910cf45f769ff10acfe1d0e90fcbba7a9b39e2ed65fa828dc0fba2b0228f6fc87630562d5a8c6a77f249b4ff072c38699c60f463d89cfbf46ab444b15d6c3a354ba5ada20d515d7836360579ab62d6f54ef0d73a5a8a040642daa85d2aecebde5db24b3f54f3334856a69c8845f93779e4a5e6592a63396b899d52e3eee6c438fa436addd8cfb923b8d5c4f877ef1dadf8738962cc6686ad96bbd3573a6f62088b524eac50feb95cac3943746ff19eeee9dfb2a9efc621e3a12c38c9ede2ad583d0f01b15fb1a31929947ccde70fe73dcf50c3310a8dd3e8dae7ea6e29c1f227b784694cb143eb152ff7f3b0ffa75783185a52808e020ac1be23ed1331384955dcb4dcd6712c4243d9e3548fa4c9704c8a09afc3ff20f9cd84471aa8c95d009ab5eabc7a8d970127d8adfb809bc4b235c5692a34b00cf3c2e25385da1f52b7b920de0e7d37a0e88924374afb2310eac46622b1f66a1b602ab173d114d156ee7a94e94481a0f9c71686c964935091edbb96a2ec0f7e80359f12af133b40d7931856b8b49c2136099de2676936e0de337ca2091db9b24bf71e4f0ae854810f94d8da5869b7ace8c5ea0f6f12c31f7c45f24e4cd3ec2e84229e44718c7dab0e2fc6253fd3eadc37806d6a2dcea6bc7be26231f4b1f8c19315f2d74df9a1c8758999312bbc56383788b3717ae0db809fd22a16fb9820ab9cbb5bb56060f3a0c5d5a6994bbc5163a5d08f545dfcbaf697a76ea699baa304b0a1d39aaa409e5ca5adbaa6238f5ecd235defafd2fe791fc97ff2b806a6e80c0793d71adbb10c6091d1d1e68f794b44cb83ad9a98ac8c43fde210a31e6d018d5e55ca42592df8f34ed01a9d15eb2f9d51b5e2a82d89359d9ef793091cb0f95273f0cf07b83d4765497ebf8d6f26e96c5c650602c686c0a04e7e375e2dc151297b9e92c45847ddfa6408f84303fd8cd1bfeef1ebc7b9ce41b69ceacdb37d5be02abaed13c7d5acca01f549f1091aec761e68597b4a11ccd13af061f32390c0cf54014bdf79dcc564e643c525638ad1c490520468bdf19f37c54ce3f6b0fb324ffc565b1b6e3d0d8b22a408b9f81752c0526e27955b93a8c1ddf98e0515631fa8f1ea9540a21fd6c9708c65ce87e72af5c3257b38835a3c39ff2bab29ae984673358e650da81938827136de5f64544ee062b5cb32fdee3a4c952b7872dc82757a7d5a2c18b7bc1aba397d0ff218c8cee24020d91b760649298ed769c6b1d2d9d8955f1d99286f58d9056340d1fb46dafae3253a970ebe69a628aab1b67894467311bf45730d0b8f97dc2463ae923a1a074b6da40d73d26e80b279cfa7db37ed3d5a4c58283e073ec1789cbefd260ace9fb7344a62afddb66b8c128537a5e03424d476077171d4a169ec453b4b2c7ed67a7f210cee99a036f3a403a79191e47480c97336d5bf6f59e0d8522ce186857195f511f2618cd750b5d1798c7513e73946ffa0cfda4432e8d5bc42c73b0f73ae566de9ba5e9e9975ea2f9cf6c1d8ee7339c419de4411cfcd8667b702f7c96abdb8d0e3397f4b1534ec32afabea14c6cee509d853974914e4732f3f8d7271214fdea0cd4769c5d77838edb017635fbf0c04dc67726a8dadba24c8bd0ddbc14c3dcd5dd0ae8ddcc60dab782eb0875295f494bb57af74478907bc2fd1bc0846e913d7cb9bc89535c1e076e9b4d429996df4bb4b82a19ad7928c4d4d63c20aef8fd5b73e1e2c3743e922a5429e09875bd4c9fcfe57b65cfdc5b9a41f2acda7057b01b52236490e920ea002cd952c58ab2c1d48555f0a25d46323ca00e0eadffd7c950f8203c83504ccdaae66d7f2d8a9fe3d7c8b89bcc392da800b8255687f2b775b4ac876d24b3151ebd12aebf2e981506d839e2109db5b20866403eca3e8a176881e26ae1a9b16815764443e37e1c7924c43a9a24f1b67b14ef2e003fcea48dd080db98afb2f03001424717cb6d54760fbb349e07aabeea3bd18162a05af1927332fe7a098ab984877832a71ba09011a634c040f58fed38f759e5495ec85ac93b37583410d5c0040e15f568d1230e90544dac1870c44a5b4bca1626112aad0389feed62fbefa4dd9019a945f3dce5d949ab892ccefad35e2aac05a04d9112bd42d24553b150b7713e6cbe7ed74f5b361cff364eb6acbccb49dbf9e5246f1ec85ba0b02121c9b065ae3f2b5238f396d7afcb4f1b33d148c404bb600e775b6f9d3b07b8236c62cc7ad61e479cca520da88bdc2dabb6439056ddc9ba91f4ecbf535bbe5131d98a0bb1bdc07e6c9a0bb2e8b59fefd5a96c19e64be4c3a135dffb94e2fa1858f3128abe6fb69b1b318cd9efbe3d76e7615079401df2af5236d7d2570fa9ab42cab451ec5cff02016c2a8ff2122d80c676f1a97814839ff7a24be5b444cd9484376a6f3225a67561ec23dbe72107945928b4c1e2da2527c5fc7dc9dde3b334da6ce6040b078e9a18e8669876647de476f81032708377f244325071cf41c3bcf7f7ec7cb6e0adcef29643cb096d01eea0f0f2e3545a89c899cc2cd23d0f411261749141e0c2583102a72cd30f2587b4abf3b7e9911a4d91d568f685e35aff32827cfe44a50ad551c13b4d0d648d63e7d7d1b10c24fc8e92acb659a04e60a3b28d8fd908c9ed40ea64195a998634ea7434931289701f09063dfc12df480d4bc28847104230d02c8c5acf3c45da84c5e9c06538f5d3cab57bd685a95d4904e365d53848121cad9d4b77c8b60af73e207e10258b9474901ec5db1562bbbb0bb375da430663a6e30ecde3886f914cb3cdf9d61c8abc4578922e1246f9ed59a0192117da984b33802722859641b2dc04907c0226f8238bbf5fd40d5ff5f628ad7e91ad939a78c67dcf83bfd763c4a8ef7ce2a0e5149ad2954ba1fcdc32bea49e7b6c3a9ac461b62af5238db595c22bbc86dd4c4249e3becc85940072dc1ff58cd40f9a4f12c06219c87eb54989467620032ca879879af1d93f00fb3ab365b2025de6e88e41d816b103af6764986042d6372b549d695a0cc4ee2f6e5c2a30ca3bd488fc95ceb5736e75598a995e7564b520a6e1fec1730dbd98daeeb8764d543d05a92ff45bab8cdfdce50e31fe3db03a302c7bd168e37b23a39957dc80533e7969ee9bde7774a722b5cc3ca6f240703425832600f5a86468d6326befe36fd2c077fd04325022398d65917f911458b329258f9928de31622db8590174f0c9dd30fec0aec2857f91510a02b29e24da9346dad6448c5f8430ccae33a817f71dea4d7151d6caa973a8640d05d59730afaa8d74049684c74bebc95f14acc3667fb4679d35a82b3986f682544cbd2d5657bfc5ee36dd4b578ac73d1769aa9b226f68c076839b794b19fc60d21b0055f9d7d37f140d3801a1f32207e35afb3eb7229e71c97f11e01d745b38310a5826cd29bbe0e22df87789926ee2c6e645c6457c5e3294eab1d8cbff97684492e58a3eac9d62081ebde742f58cf5e27a8c08361e9b9b710cccf61507ae7d215c961386329da0b3d74b5e66b6f7a6bd4b75334f76e18d324a3fba86ec9d5dddce19a9c1b565f0f5dfd72d2f1a78958df53885640dc06a93fc28fd6276ab031321899c77c954c0f7024e8c8dd0b952485ea45d2e8baaac7a4ac9f50fc028620a0140f0b5b6f66b664b4da3e238f5ddcb18ddb87528247e1af8671535d0b5e37c2f77faf88327d4be2a847b3b08df47653c33abc4c7212cf5856d270eef397da59302f136b7a1d246491ac27b9034f350e1cb3f2fabd86354fed84d092be2acbfbd1b1f2c9dff604e2c38d3678b342ea0b84da2019271b89da302a4288a0335a13561feed3b00f33b4ac16d0e5b01599df1102d146d5f13a6fdd94d3e19c36ba085e6f48c0119dd304d2754bb0b2bf76c6960c1fb31f5a8e7c3f98004af54e1a77e2c1f7b93c7e093bb65cdaf892e61b62ef1caa4524f6b65643c137b2f250e78ac97db448b9f7daf8fcec80477f15ec3589ce256fdb047cfa10451505bddadf53c0468b2df3636c268388de755d140a7f7698ec35cebea7f2c0c0fa6eedc19598e0289001b8226d77a87f0a2997fec53d471b39006242799fec1b735e029c16d2a380ffa4ce2f2109a36783234dc2c89e130afb4372035ad0edca00266bf2282e81432d4e23b35d909370346be9f08055b4ac850a2786aaf563340949bc3b313315c5b06be916c24e19f897b51ad1e14e2b7d6fe0064bbdf8f6e7ab22723f4f388a6e019420206f8013bf1efb2ffdb79241585941cf776e8da82b2a2c42f04754b61563937adc1ec8007fd6dc987f7799a465da0d3657cb50a73046cc28582a0deb99a6c51351ef6c97e5585304011d737493c9ec5ea27bf3399a12c41138e51c3fe97182f00a8687815a8ddd6c51f1a6720f0be12de85015d19ae9f9603f69e7612b9b501e0681ec0cd152515724d4f030ecea83f00261db5609e27732d546ee228ab2404498e01be9a185e6bd39c3285b135857e07eb6c049b6c04790cdecdf075b5564e92b5668a0428f2e660bae67def9827e7dd370f3c8b16b57712a0eeb482698c98c19e399cf14cc4db73973b07510f572794b54a6d219b79e73eeac3e1f947021881689a0c5fea268caf51fecad6c76561be8831f692512468d539c5152ac335f190279f1c08f76a19dfcb44186d6d36a715a71eebf1fd7c586e1eb456f1a4394930c1f779c1e89a7ad6579a49ad99ff144f75957e70fd339431c5eae7ac62eb60333dc3e4ba7793ee5dc93b35cfb27488f528091675713fd0629bc8c5188e1ba8bdd5ef1a84e5da70ae0d87fe2415ff7a252ec46b1b64fcccf31f1d6fd413c644be699ffaeafab964a7fabfa58c364172367b2e640a6685f05377b0a1094e14be23e5dedf4ee2af7e4972d83cc7e66efae507771fc5aa4dce80e6acdf6cda7a4978c41970c22de255001fdc9bf75388f18fde222e389ab6f81949d6a27dfab384bc8e641c3dac430a7b56dac0743da7a139f08b6d4cbf94551a99eddedceee8a74cc72fe8af59f4b50f42424ee9b48768545726a180183ac941a4f613c7684ac3e25d5e238168445601b663c5be249f216c18a956ac2ff57029006c9c55dc634d671118e75039e7284c68e99ca8527341e71756efa6539889e37ab824123e558dc85122684790a1b0d83378acacb2ed18743dd29e5813f70c84e2ec0d58210b01008a8ade729a8be48910409e5506879f93206b6173d303c02f73dd4f844c93c4d593574ad5f6903f0b4fa36157b47e7a5e5f302c8356f0e3a5aae0f163b7825ea897b82cd57b371d9da8778b379b74868a89e5506459733701b0572bcf138a22a3ffb4d431e6a294d1d2747bd30d4e24772b1ae4289e4baeacf5fa6d6f14d182192378c288b427e6d394637eae8acfe355067905c0196ca6c79296fea22f91f6edaa0a037f66602ba2400af5a82a9ca9eadabe0de76520c4348b94e57525601b62a4686529bd00855581b337c79c98aee86af31a6e06ada0ddb9c9b273a8b43790f9c89327da9880fffd21035afab26f3591d40cf278d603cef7bdaf77f09a118d7c4cd2d71fdbe4d96823b6d9241e340ff077b4907823bdc0ab9fbdfeb566a00fa1c8afd39cfc9119e8b8a6427a0856f028316e31241dabb60fb27570287eb480b0cec5fdc82f5453f240d569ef550d5dc1f1118b84b4ecfff047c0817e754eabb301482b108f4f20b1b7a68ca154a5c738f0eb88b45c35da47829bb2bec3f84fc21e9c9776d78f9c0624e20940230834eabedb2542eec0a5bc5e6ca24a104479372126df99108e8849a2d10e0547b1565689b7ffebb096fef86d184513f4847f716636c85dd5a0e3f75be7f10c97840e7dbb32d9c48de52b9424be297e860cd9fad724af8f62e5438e749913a15fe6e7524d69d36cc6c999b6b09d7a6ff5e303316b27ecb470b3c89229306648a6494b5c4d18f3ce08cc4bde6ae51af62a1aa9b046a947d7f8555ab6cdd766277556c182af77086110d8c9d54ebda9cecd0c64853d30ba967cca4f7feb8d81983e6bc3e1e5e5747b624689f25e7fe53ca1b6ac8d7993d0c4da2d62629cd23be1df2fd86d07d9241e9332dd054036b40954d8379afa21beada7e7f588bec5000fe10807d364265c9bbfc83d06c060426c3b079d062f411e851f480363dd9a3dc3709f2f72a3ff948783c0922aa1d901dfc1637be0c87554ae88b90fcdcea6e6f4592ad6d2b06445e45228600cb30a848165955d6b9e06cf919c6eca718c65cd61b8033d3fb72872a5d1950ed6c7eeff2e3aae6fbbfcc36a8661fbec8e6989871ed5705cee1d93647c74a60340b039e92dbe7752d466816c13bd783ebd22b136cb0f99a73e96586e89248f1f5e0286ec14da0b2a9aba7f30c79115e46f7aa78aef30d8d188ff0a4a235e280b82889304e19bdec026445da6ea7bf1df06633264e2beb5441f891b33b11e8e6d9c4698b9bc1576374141350d4396f812872c8524761134a5a653cbebe1ac549eea55f48d291e0d811ec7eae298a8f3ade3f2be60045fc1bf6e0a43d0e5a1788e8b686da81fac750ff075f906e5f33cab9a28999dfc88ad3a1ecc76b303ae2f66a95757a3047a16f54ab7d9e15364686db1697b375160844b5ec75677c3ba12a9d20a02e632d1de723541f3f25337a01e8756856dfab0ef6e2dfb9bca8bd0fc5a0d2636f487d03f27eaf73694b6da0a18b3f5845bbc7eaecc9cc64b68afecf395e1584946909dedafd115ecd137fe8898840f02d3d95188c483412edf661d7b279adb7171f1b2e4e34c1fc876ed18a53d511619c1616535d94abb5c36fb9e97f8aba08e586e90d08f40dc6fab3efe7531a82eb71022ab77521eeb981f164613d71fdfeb64ad67ebfbc70a0396d47e8b3eea7a5db233e71671f9e1b95135d17ae78c2db91bb800c68c5fd145ff242e93ef5f65495dcbe0dc6ff18d1f68d55125ee01eea777b8ffe35477859e38b839fa6ee754b120a872184971a68580bab514e67209c9901bbab0d222ab088a3eaf9cc33ba239216cb09ccd7a27c13840f76a41175c75a752f66da350b6082a36750daf0ba1fad862f0537bde55cb06764d48c4d81def049924070a17eb88f523e8b518503916026f3a65d3592f3829af8354f4e094bbf7be2c6ce5abb903e1b130c6bd5f23a5ce35a4bee2e2afc9c28e14401416fdf20b43c17f74f7005d0e3fe9644d42bd5570b215210eb7980b42c81d8bb92626f5399a9a8387e78587bf7ed909cc05afa9f2293c906766d2884f4c387d8d4fc97ed4b38588a7f8cc90b719ca921347efef3a8f82f69db1ac8b001e50ba3ffb63b1542303c36249bb047801c4d0c94ee7cf66b937c1803681b69b0d65efe66f219824a6dc3259240ffad2a3f1efb6ab40b12eeb7c7e7b6fca91537f26297903d10188f2b6cba1cb2e1c6ecbc6a2fa3331f857db8c16d78a6a90782997421e1e052796d88dd0b4e1f8b1bf314169d8666d6c05011c86a9701bf8efd96d42e4d4966485fc29ca4bf1944e9ea54b681e8c3aca47fcaac48e9e44c8013177c750090ee575f5ff54fb8c7fd6340c07e69fb3fbee116a023940a4353d00200bba0cbf045fc8e9f77caee83a57366e95450023f6343f92f9c75253334a8d7d8a3618ddfb8e4e4129661550eb531805ca5a638797d7839bcd167036ec0696bc51dddce2e661e1936e4d443800024e2d1ab526158817cbb9eebb1521869cf5a8566376dabd27287919bd3ab66d410be205e29100bb9af74e5e3323f56bb92b508ccb428f6ff59c24807a01e011c9565ad8f6b40d6f27aea209b79f3bfa20f8f502cdb243f1463cf79ea0fd4d6076e0c569d371b590c3234588c968ad52347ff0ad29ecad9b4dca6296aaeb532d195811476613cafb3849e57948631b712de934d34ca92cfb7fcfafd03a9cbc5da0e2c18e7eeae0b4dc407fbe9b1280f654ae2e118084c6bde1a890a26d8c45cf3df5bb2e40762d17b6557dd60229f4da34452e8dbedc50c527b9daf485b63115ae5e454a921a39e4b61dd7acbc302aa0efaca6b3cb2d92f53379528a642726ff739a6f07cb9e38187acb89e111ed950418cc00d4833ccb1bd529e9c66c145f8cbd8d9250499aec002ca25cb64fd207795a006f0906064195f25269120ad7259c775fb155fc652d550967960d921e81b1c96d67d409910cc152843d760868e2d2f1ce692163f8509637a0c0ca515cffede34f73c36e45861f56b9de4982ccf66f56c159bdf55436db129f8979e6fcd9820a2153ead716f94824ce9689a5c802a343a93ebc028be9a6f415be0cc310d06dcfb13b195bfdf08f7fbbc1c21759dd893701d4a739f677624e0937d440c6e5ea3f261b9e6abb0cfa0b0a0e3dad240a396ca2c7b97f83f43a176e85e0e43393b3598373bfdf9ac7f9f79b54a3eb43e18e26b0a91a959236c4d69054723841ac93f5bfa4b470f07a6352cec642b92815bd150e1e4444ad7e932c94ea1628b24059762359554a5238ac2e2cf7bbadc9822132f91e56a98b1f1dcee3203470965fe59606d44ded64cb38ec98580c1d295bdec61e12e69fced7a097d0464fbcea62df448edb722de3e5b9d20cc1b84440b03f2e46484253b703efc6e59873fe16206c67de80dd66e31c78dd526ff87ed2b9103b08dda3560e78a2b3d12167be58796a5dba4af9b4fc8425070e4ba5b57ceaff26436ef49cb886a258598d2858485a0e8a2b74ef145b989a11d37d4338b0ff57b7bb2ef102dd9aaa109feb321c611c5adc947082dc2cc9054e663468c1b241b4e2df275e913b0d57588871fd5805dd0c89a12e2ee3249c580899b33884865903507dc1deb957a927ba610bb0d96b77a5f5ecfb234f666e62c55d2d4ed9f9b99df6c5a45d717ef8cbc9a66a8508cd9c1c56dc197cad082122ccad20c1004c6947a3bc98f799f6df591019dffdf7f1bbd79057a02c793d924853bd7964c7e0ff268a8d1521aee04392d7ccdca1fb288ebe3439e679dbae1e4a5bdc1597ce58c67072584a461c27c4e9fa7d75adf83c826526bc799093b411500cb837d2f6194491deb799e72c5aaff41a2251f75f49c509124bc3df6d6edd516c3a5e2ed581dbd70bd5718322376ea010b58fd1ee99fdcd00bea0aad7f239338899ee68b762bbecbfe0ce241c3d0c354ee424d84734f004756ee21325356bfc1173e3c8a7ca8112bb3eefc5d9585e4aec07daf9333e17f026ae87a416b97da0e7fc5240c22a4351ccc72a24adcbb7b4e20931558329e10347bf6bd9035e1d497b00fbf1ffd451a943f6eb0b4c9cfa757859bbca272318fa88cbf47518a348f13a97af1a2bc5c22b37dbaf11239b8148eb41932ce0e7df37334ccd7d26630c8cafe6437b0378136100ddd59cf7934ca32dbcc3a990168c4980d5e6df67d685cf8c8fc2df4f2eb9be7e3280913a6109467554db0b8f48bebcdc7315d2aecda3b69a2e83fc25d64913cd001a7f6ee8f109f1e7595d6f7d46cc656a4b4d4be711b108125402f88fc1566b3bcb61c9f1659880229b7f3f6e08fbfb4e453819e89d8e8b8c771fc1902c16ea222ea273b60ca63001bef4004ee8cd2496c265eab25004eb4c65870b8962896d9fc42239b7372780de97c7d217a6c81c076c73986cb3237d6fca0da094b50e6e64b7275295b93140cbca6b691b6c1ecf5104fabe5bed18ac160941fea48e38423899e265902d0a9f7d1bbe842ec443cb0e4dfcf7c03bdd0fa477eaeda9de2c0690b01900556660a542470e3296d3d12ab6dc868c3cfcc00ced2fdd3ed28049a99c8d267d8be9e34e7c76e5a0b63273f1894cc6cc262a02410b1d1aa3c65609a0b8a7480c4a5a1972629636428c80258f7a8e629e979c90516d3c0f43e9f6eafc8a3d3f0d27873bdb7f1b9c13b0252eaebeae1e210fadc7db0e40f285d970366628388f1aa93ad3ec94f87189c72cf48963172b70fa08f2533c2be5b633225332d62bf205f6d91928af5de8773a6cc44889b1d009602b5b0cbca1216b74a2222293887df3a370c604e1d82296de8354a719c180eb44adae7016a296ed2b08a6b7577d37562222cae706d58cbe28fcc2a380770c805e59a751a65ccc3b825ac76e8640cc30c3829a26d65b2dbd9a95eedfbc3210352faf269f1ec7467d525171c6cb77d99f11a0c57b94a8b6a1e52b1e20fe6c222e1649b6d03b4ecdcd1dd005d0036a4e1d2fdf5124966775d512a9623454bf42f8a3532ae0f2c1422182d3c7d8a4cae94b0fc7de4001ce818492f6e311e833522585a5b430b33b5082b729042f0c78d73bc1295072c9642afaf9057144eb82fbe9c4ef28d5291fe108ee5f79a1d006c4878b586b90a6d07b1fa163f9b865bab379ca0cf178a79018f3cc5dcb5b8f49a1cbc729ceaf6f5e31d0a88ba39380e3cd74066d2bd39b10bd3bf368fd4a1e000bb20af566622364d03cf8a920bd83f92c4fdbc29a24dc1729908134b75d967e7d64d83a5b0c418b5989cbd78db0d0b58cbd66b3ab9e6b5cc168c847693b736e88ff21070f55e4aa4e0679856712dc3aaab9c84d56f2ff2ac247b25d4d9cf58598f23d883fce42a1b2640be6d4bdc4eda13751780104dd2c202f08ab78973f3d483ecdce92eafaaebe8395ef85b537976c25951bdab7cfff7d02dc119a0fab1f051a89d5b9c7db8d3a9a52246a462e6ba685176bc795aa7f2f6b16f55a0591ea93565584118e0be018c2087de1f59cfef5f105b1069000617ecc6dd1b548d1397e038908bca7de9be92f9262f9685145e47428080d2324dac8f06335200506409c6c79b34b8698f63fbaa75f64491758d9514fbfeda1632fe8bf323455206fed27da1d8d248d9bd3b6eb3c71da323815e4de96a76a6f633b078ddee80c0e753fca6113ff1dcea65d38e4868bd6dd0d3031bcae2406cd9ec87da6d6c6fffbc5cffbed7fdf2fd15869410e6f1b01ce33be3a5659900a3effb7997c0b6082c3495a5cb4574e602fab120b848da2a874432e27dcbe8a7e24d1ea5fc14f0f915aae0a105258a5cce4166629eae3b5513434801dcb14c11fdf4cf406a1d1c8b7f14b94c97db385b156480d13a6fb91168f3e8c6a772e0bed9f4774e2dcbefae3bdacbd2d993b6d1445da26fa076397ce22dc8a2f50f899dffeffacc21e69d68563da15db436c33f8d1819a9becfc47c6a06d7e7b93c16b446aeed33861a878fc8cc5a7e369ab2ac2e61250df5b11bc736d97fdef4e3a73d9fceda7cafe901d42e1bef79d51f18dfc56f9636db921713b513136773a5f602b06e41408800250886b271037ab8fa3bbe234f8a1d16accc55ebe6bd33b579d70718b2991dc4058f75fed3c00e71356c9699eb3b607b8dd27ea23fd366c23b1d3909015099cddd082953d4a8496b5b188b70fc7414a929d125774a607dc22a951a29df18862cc5372cc2d88430204effec77371f79e0454654b367aad543e8ac853bf6b89f005f5c7f1f85485e8ea4928d5dde438f7b6026ab17d688611dc0f3572fae8ddf90ca725b2eb45d5d36842fed1abeb7618277b9156bbd0cb0cb1bf5f1720980e5b57486e639fa5034f2cda8795fe1645d0c467fe659511d21662155e35f73066d8ec39c432162b22e396edc7143c48d498fa5173dadb326ed3d9af350b6791e247ec2ad75c4dd11c73051e232deeb1bc706ba23f29ecd2476a2c899efd1f7fa36aa62cadc99d0782fe774780681189c223317270c92f0c3d592d55fb0caac39c8b96b95d764ac7e4d71e18e2a3f00e36c56a866782996d2b30de1e69e12cc4edc029f6740521ad4a48212db43658e4b6de3e9f0281c234c8af37aa885a712fe72d125a01b763032ecf777bb575676ada72278e1ac05cd6c4e5418d835643b8bc50c53e1ec5ce0de6685abf6219a2a5d5587e2c14a187e03817efd60c445b152ccbdb8887a13f2392f07b47ba9e87513812a05e0afc7a45a71951df8b60bea471144d2ee52a4aa3a57f95a755fd656bbfe9f1f0628f9c6d1b572af9dbbaf8d249b60c830f2d6f0652e1dc825dc8634ce3702c6bbf55c1725334e27decd2778d15e25b6dec0d51e1d0a156a3b12b744993898dce79155c31850485362738af9824f584b587318053f3b534e0f187c7c56819af8012bcee84dae6437c43d56fa6e04776db4602e2926ac2088e577dc43e215b266a88c0f486dda524e2cb1f8d972f3b07576c113b0ff57ad9925d1e5a6d1c1017a51806a9ada3ecfadf0bf94c2f1b1e38e98ccb0325b6b0b2b8fd3ab6fe15e305e812b939e4b9d110cb642c405727d7b93f616a665168d17643d4c6542fb07fc5fec1a08bedafdba6cb37468220f89485bff2821d01f5b861b396186776d6a562ef83785be2ef7e077792b81ad1eceec1ce1a857dac9913380449ae2f748a10666bb47846ca0724944952d08a135dda834f7584db18004a61837ec9590c4cffbbe4bf4e1eec61bd8523a79eaee8769c8e7f8393fe29d0ce53111fb9d9d7366b8461a7fc3a949aee695338eb036ae4d79059fb936223662ceb1d310fffb63ff5ebc20a58788ab74717ae0e1769e2fef16bd2028d8d53b5776bdee148ad865491b4851261c71399e1c230875dad1e34c10558cea84c4f7afb11192ebc9f31e26b768f54b1de98df94b79ef5e3319a44a81d3ee7f272c3285e579d4b50dbe6722059292aca74401bbae5401941196f6a91243a6bbf8adf45ba2dd826f122843db1ff14d9f2b6cd8ff10f85cfd5d4e4001030d49b49c0145580e852acf1473e7a43a8e778ff6abae5b7128ce8237fc3305fa5c5579aea8d6abb573201d0b06e1762c2bd264c93b031f55d654ed5e9edb02513964410e99d28ab3ec14f9c716f3d6702a122315e92974a3e3d2047d001e3e868567f5eb6fb3c9e1355d103e8087576bf34605d124fddc6b6caaf8d55246cf2b4ea949afc989f766eb395c673ab22c708d2c8437943aca2a26eec3124f338d53faf074509e3dc4a771b364fa040d9073c970c19888e5853846a8eec5c86797f04fd2d7f809e6e14a58108f2ce967a4473d49ab8123e00ef6df252df2b490c95fee36e12746281ec449ea4690f14cf8620448e3722ad4ac8c50af5b8a0c1c0b407ee89f3e1244acb3d0fa20f4a451f40d0170b120eea28812892248c5849abe8a81efd926d43624e5686a0080a67259aeda2d0387b7e2542687ee1a806756721c2eecd61df8151da0576e74f1b2d1832e4f887e187a5cc2fc1bf253600d1ff0243fddc3d75f7b30027d81141e826f9c1a1cd56a447bd8e1447395fd31620154a1c29666145a3ab9d273dc6c980310e7afbd1c8665baa4fdde6cfec7ae628871c0efe5a3c7385c2c47a4d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
