<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f2c4ed923d26de2fc68ace83dd0571bcd722eab6876f5f6672c5b49c738fbf4f826d6267a92bc586a3e62127f4cf47fc2389d075cdc26063d399dcbfd35afd6c0e38660d514b48304b48229f59c49be5498cf6e4f6edcd6f8acc179cebf25293313aa68387f153fbc103e590cc95c953b637ead5ea226db06c9f982e9fd7e75d4f66e02697d52945572fdaba4f2de3a1ad504b298b2637f0a686000c421ee1da402e95ab5c897d9cd674003108614d2fa76f71a16a932a56c09fd2062060129c45126f4a726794f1acd804a210454716a4c79f6f3e7bde7d6d1f6d220f4897a7e0610300a27a5ac285141c9d5ac7817457ef3de5122e213a433005e13dd223a1c2772d03b125bcafe47e4cc02bd744a6843b3359ae4865894b2da64149b9c6d650c3945579aebb2ef2e90ad749a9246ee3aae21124261c315c6d8bc9a385595ca86d08f8ca47074870bfb479a2fcc34538801e4845cad7f63962e9551f0cb69928e4444605f72e50e3093ab5cc3b4f9f70b2728d456458741a5ce34366c5842a99e49b92b03920097c2cb878b375ad7aa68ef5148ee352d2fcd84a4d6abad414d4816c472f7ada4cd3f88014654dd8d9b99f97b84dc0c741840505c2395bfce4fad9fc1c0a5ce3ea205c70b558ef6691c14a03eada3b1dd20cdbd6def563bc260ad0beb4bdc407fe38521e9e600fa92952e904c66254cfa8b9acebbd4f6216814389713126ed83d7da2e209d7acb5b52269979c2bc212fd309c8f660173282160480e741feb7a9350409e81cf3979d112c9e4a3147a51e30ec534d7159bd582425f5e7728543b60e734e25f53d621633a088f10dffd93cee406430be16d25e958179e6169f2197b4e9f9c876d409ae867cccba0f10523487612e9f4f14e7217b0759406a54e605f36e099ae0fbe67670c5233efa2aec3d2ea00924dec9cb28f71958d5a3a448d0310a4a6c1f4c18d25ca278d278acf41030b3d8c0b2adc86251b660918930e683ce5908f1209d6ddf6c4747139ac0c0b03da6085d2255b77654e4892b1c7ea2b432cdc1eeaa18cb06ad2876b0360d247afc168cee04d79644e7de9b023b855e987b4dcd11b7c425c330a68f9a6847f4388b773b7d89eae9c8d325601f9e42c8372fdd77efcd84e014493d72c3ff980817fa18f699d45c1f1752c35add5e101273e94a936728272dbcd37f99040153273089bfe0310b8cc31b8acebb4e4469bd13bf470d91ea85c296f484c76be50920313097ea7e90163e6f42b885dd3845e1f1c5d26346549017d1a270d75843f42bcbbf18163b407717049d1cf2a217ace9134e6fca9df841b3ba860632ae8b1f3c7beb5e966ca8f08065dc7aa16b7b9f6d022f37f0cac998736cbd62eb10f1ad1ededcbcea020898dc9111b54fd92391d39ae04e9932d780b74c92f393c42843f025d0463cb32e5d36059491597d584c52640693c8043c9fee549b0c4adaf14b9d90acd022a535beb22fe23a0516173f273e25e57f56b5e8fc4f877096f1a12c48a87f9835d4a23a3535b1b47704c87335dd1234e0e74393bb74bbac1c03e510a10d790b5a1ce2749afa70ffba25729d954a4293572236cf273224124f8e40b2fbcc8bf705635a3c42abbc44426b50653fb886a100eaeb4a2101820a7fa440850330e9ca517a21794091bc11640b65cac58421d7f756e4ae7ba2ec05972b1969073d0b7afbc2c4ed6897ecbff969be18b5ef0625e2d505c587edd7dca504fdf300aa29af14b25d45c49b65f807c8c40f94f17248e9c7508c204bf7a0401f2ebd42177a98cba42ff9945d64c213123c6a885b429cb54bb76820b26d63cb91f928b7e1ac4ec049131cc63eadb008f2be32914229db88ce55711d0e9f4fd5a83fc332e870e870b8eb013fd4d2b88b89dbfc2ce49ea9e1cdd83d0370764d7a93b958492e810d09cc283568a7abaa64a4128a224361f76deacc421860099926ec613eb328fa15fffc3defa64b72f2f5ca3adf0326f1bb092b67eeff8cc0c92ea7220c1d3463b3133c05a0eff4f13da14a3e787c62345855a2f1e68cc2474195f477a1c9359d1555a25c6a700f20bf59b962c4f91e08e3613fd75ba940d0c593dcd5a19bd7bc56e1b2c8b628c6d422272821da2923b04dcd64cec1c1739d81e408cc92b942c78f89f8cca2dbe3e40af5de11f9bda089325696cd356e5bdb97be603793abef8055470f459ef8fd5e03f8528054e3027268e06b553bee5560ace6a819392716ad0a78e4acac9371488008032d6892ff27e06441b9f33963ad13db75f209b08c5cda9d9143b84f7b76cefe21d5bd8509c2fff5983fa481c36378549e8eea326eb842d9bba905993309bee9bb52781ce1be47323fface9ea7bb55499cbf1379e71c816c4ad73eeedf9724364c44d971c90588a61ee48fc852019cb5430984c565229c27b62157e6197e9569400e5f9b8baa56e124d43776bf9eba6c91c1f18ecac1679940d17e7c6c59d525b6fc9bb7877d6db230dcaf9c91f1a6936c0566f0875229b05f3211d385a8fd1375f10bd7706697766ae8d95f66dd2a624d70da026d7a8b7b7d7b0275be9fdeca6f75e4e2487f39756ac5fc304c7dc6e76e05ccd22c2ecf7d59c00201c4c0f7aeed60833c78fbfa9e8bd3586c2eb109d1a6cebe02704f50bcb3f558c15eccdb7c45f6b9cdd76a1d820149353576b1d5672104b44f71b368a230f095dac7928d39d35639615864ee4abffb8b78c6c88654d7eb692933d15315fd253d8c1c7684335f5440f329010ce66403c696e01f8ac9a9edaeda8a691f2b44d0ce7dbdd7cd70dfa7f7304a278657fc561078a89aae7ce0d4f46f241863dbdb6583e53d8da93e0b36344c6fded003274b261cb374b86af92ffc9b586aab3cebce8a9899c44143722472e3ce73d2c5a02915268594476ef06c7e6a08401237540d227e8f66ef48f1c384726afa146640ee34f94b509242aabcf66db27506a925ea99385bb7b06452a1dde946569ef45c8f3c025ea8c370800436a62d7e01b167d09bc297854cfb10a367b59739c75beec2e23eee16deb468020c1c085c5a1831df16c7a433268b4ca2479ae3586aa8fbe64523c529baca22e3762d6ef0da19380d00f4e50f3d44652c6f5e6e8544376542b879ed7cfacd26c1fad754bd14738f6dd506c200a5d47b6a805eba4c1651b06c57e636e1e8eb30e8da01eb6194841f822122f3a71c5eda4f9782e666ef9f64c6e86e8dfcc00f5aa70ecebbc39e1d8ab9ff54ef3362de56d6ed364a3f9bd9bd304e085951bd112bce162356b21f06256423489b29c78383b25818c3a9e4ae1eddc8ac688de003b87ca5200b997eac919fa3d99445164f78d995fa08c349c182acd7b387631bb9f94cc4b8ef76099c0fdbc14dd6ab9e930a45326ca54d6282f2be89f6af0653b4ae99754dd609812bcc709aac98d2b887472e0cc8b1dbb7f5a2e33038d1e7f61829eecb1a87cb4a9e7ceb0eb37684a51fd675049d67dddd377f97d965502add5e1d4697bd76f50da8f5e6847df5f03cf5d843fce7c0d150ac7cbd9b60adafe60cc777912390152581bdfae44f070a5f03cb9990e047d97328b22655666525c23ba6e34001525e57cf98827ffa2fb329741e81c8a42a1c3e95b13f8f651d2c0e58571d3c2a8dc751ca994901ebdb78ac14a24f569eaf62910819b955abf09b7880616c03a100baa2841b2cbff86095be3ca96408d90727f98961c255355ec36fb11ea21f719e8ccad8fcbcde9c03c4d47176e47ab9707768d9f8b87e906ff8f85b1f71d0dc0d122772238e2e8761039dfc1ef7383cef81a4616f599ec141ca71252c914786ccd85aa4992e16a39e74fa1681d030ea099e02100be2236fcb4812fbec7f0bde2ff05a1a7e9bf711fc3d406cf03850be7902188dbd813cc620c6fbb71aacd93418c87f98fdd62df8aa9b0f504b900dd0e2e30c919548e20711c0d047ba856c62aac52b1232f9c805de113aa5a162f81b56581212cddc9c5904149a0da9789d031ae6ce0020497f2c87d2f8207d777b6cc9127826bbbfdc214a63825c17d861003153ae7d50d91241ca0ad7cd691bf91294dc91199a14314bd34f25c19be739cccc502794d14f706fb6cf41097a4eb75ec0f14006e4764cd3c994d819e63748975256e7335988d307b26216b461b83ad2c5f01b745c0b94871f7ae57e65e5ceec12236b0a2209ed4ff2720e2b7dd89788cc3ce340e8d60e9396435e8caeeaadc1759d0729faf02c1ef1b597bfda6606c4f7af9cba717d16badab3855e1568d3974a0701e5cb2df0f31032e99d1631d258bdb218203edd26af8bd4783e4a90656ce79df2cd6285adbc1b414d6fbea4ad8b33bfa6b0b3ea370913f0c476861985f3924ef549870292e24750ab600bf2ef900dbf0b75cc3afce3d187ed186affbbc79b9115c31c32595a17a8e6f05d174965993b54a3d7d16439fb8e285018875b339d3824e5f6f5a39963c908547d6e74f2869c1848dc0ed41603f299116d842d6f1bba9830f2a1151dab8a3eacfe7ed7d7c76beada14a67c7f6341c88bba096660d992361cd2c9eb1ebca12c90653694a84c50548f27404fe2ad836d8cf4827e7a09043561ea359c02f75bb716f07faef020ce371bbe6258e8c30378512e47e7288e41aa1690afdf8d8dc4fc5a8c83a2b62976fdf217866981cad721d9360961d76f0f9c21aaeee622ed22beb46e8adf1d3fbad0e91d589b9e28230ca86170f4994af231223a3580c4c83f0b26fe1cd626130049c656cc07b8a05ec657e31ac53bd72b95cdce8e24dfc16730ecb1f861e1d767714dd4ff402f720580e33df8f4dee8279f361cd21a46eb1885ed80d7dd909d3edaef3174ab3db03bbcbc7e30d6587367e9910bc757159ff0ede49fc8485a87e4acf8fb15b5b00539841251ce8d98a5ee6ad1cf8bbfa55872e09622a606e3bf34b7cd6ca1c591ac4572aa7abbc2e4b0474d73995f904e24ea1b9e0d54faf04f37ae78a1fdffb94bbafd170f1a5fc7ceca8e9c9f9f9e8f0f8d4d5336116fd598a466de47cdd2110766d634ae83b999a2ea6a77f54c23ea0a4d2bd3edb637ed49d63f845d678d0035af561c810a85168cae8ded038bc029a72c983d0387929011335fb27c671f6c6c1f0d8e0fe01e87818ea20479d0b992fed4aa1955aeaf7539e2d342ec4eb62df895cab4b9fbac2c044bb22a70547e183c1f608502dc89acfb7a505c341873ba40a0eda212e8e438369bb0aff7dfc7099db6c3f60dd1bef551e65c038f748e1abea47cf5e89cb16b65b064880cdaf52f67a55d18a011f1a37eef9cf127d90912c8f85c6f788544c8c57f1967686710c519c548ecd0560520cd946d9932f1bff77d87ec7e76088ba943bdb7ea84b5cf1a8459cfda845b3b3c290b06e02116ebff9e94db35608394cb60d461370617249019533db1d1ffd70df874594b69d41807e6884bef0088fd8af502155001995a65ac13c5dc7a2528f55252675b4e8220bf25e2566837d8d54589f177d0fb6f3dc5093903683b243d2647a1043c1e5a14366e1a079200f50f78f0523be37e78293609f3fc3ba1a0496509dd6ab3ae7312f920c206522c5894b18bc135e89a34c9c8eab5aa5dbc11c8b9ac072e35440ec0e96b8853150d641d7322e99704699068b057c385653e325adc348f6c0f9eb28409efb5b5d0b3e36a65ab02928e93040a411b6dbc8eaec592af49d03d781c5cdedcabf5aca9083a7ce2566d83fb049b8846ad8def770da9ac3194a958c8787f7f9f54ff462697b6b6602239a640b3c405ae8020dffbe8b9c92444d0da78d16db056ec3be70955683e809c66b976ec054f51e8e8e393a7eaa150f7011d46de258281318ca3c8bd806f70e572df6f3b4b8118d4631bb06c939945d10f116828aadd28547d90f748562d8392e65196494d96392bc3f8a187e7d0c83fd005e61dc4c98586bbde7c8f42c6cfe7c1c2960b807acc09326077f105c2077d64849c16a6156a2154044bbb7c1a8adb1e2489c6a76d91695a71f72fccd340a17e420f0f5240ec31d6a683d922c1b0edd3322fab49c418eb3be66bac9c4b7d157dab3db6106f72bd619dc65837c4621bd65d27f6c2b7f5263062c3195d6123cb26890cc842a8d342203562877395bddf56aef08d66628875bd4a97fc5089ede6908d2b89817cca5a876aeca16db922094202959ced6ab13330b4c617e370789ea59fe3c1ac41b247e26d35a64975b23313886c5ad7395bb48827f153d0d5029453060f3e303bb711d6fe01a91318046ab456dedd1472f912916c1b4651bed774700ab319ba031b8c9eb639f622c2b560015607ef5e3a92aaa3e896cae224e09817eb08d0b7cc29c41724a7578c474458392a8569e952384b45dd997f4d848340186b27bd91893f0b2778c4fcc27373fb2919fdf00d4df7fd60fd9c80313afeec0a2b7bdf91b8296e0436674d5796e01ac35e277fa90928d5272a9fe4d14385dd7a5a41e9f5f2a395fd72d37899dc6bf49973b031c7f533d9d60894456c61783223c753b2fb382577aa1695efe011611d9894c5d71ac31def3f265f2aa35dc56f35f1658704885a5f4808f52d5d2eee752e28324b9448b5671ecdcbbb51ebcbe91cd98b0be6fd62682d5c1e2cf8f83e7d14a2e9a4f26b6c6e3ceb6d8c096c04388988b3e8e25f82319c68c01611d643906c37b206d26a8a7e8878af5646d4fbbfa44bd34f37d57aa71d0bdb5080922c87cfbc2e58324fd79f1a0d1f430e32ba22a447169c55c8a4595de409db2c41788bcecb6719d554df8c2b1c14da7aca3c450d979334b2683825bbdffd3231798a2b3f217f7a816f7be28bb561fe7ed1745c94633733ba1e76f3bb96fd6b193736f067dec1354dc2286bd6400a249e131e944734cf514d6c59090552c5cbd01f58ebe48edea29013331548019d02e8501d977e6737ab6933fcb257c2c80450661b5217c67aafecdafb695535d4aa1ce9e2339ab9f3a2dc0d080aa09acf06be5ceac3e921e06c5cbb51bd775dc004212f685121cc9c4be895282999d412266246a5f7cf9796a0518e77238e9039a98b23454a7b0b2c0b751379b176be547ca7e3a2e8b9399c590a7fcc14665e3f9b025ce3d20bdd1bdb9701e475707442ae980b757aff422e4f3dcaf426817619ee844cece17d676cc2224b59f2190c3255e34c40a7da17365af124d33a40b7ff9eb0c8d825db448160e5646c2912e7d87dd2eb83c83852981cd668f926d24301dd631b516b86751a739960bad80726e824f29f16c766b8c27f33f1b2e1e2fa62efbede10ffec5dfa7ef419f876dda91b11c3b93508b6ea184c2b017323f9880d65c1f2789c699cc61cd14c3a209e339e23ef2cd2c095528d0cbce3c7a1911e884331a74901aaafcdc5f4e2cf54ef6bd4bb8ed876909073877f2b1636910dc708bba6bca0c2eecb8f935323fa5a7b239ac293db82f677b89ef19babfa05ec75730ae848ccf4012605145206037d267cca13c198ecb0d162562a0567a51288b994b842d5ccb7a0a72c9468c2457222180d99326b54a8c5313ecfff629bee8563aafdbe4714d4fa61f5e2c4901312ea9306f3557125bcdc6dcdeac68226f61c49fd6f9268d6d2e5f6a987672f19b1a5940e6285609838dff389d043f9526819a2a1984c176809dd32f29b23b697f4173f4f53cb9119116ad39b4d612cfbb1d9d3b60578aa10b4eb7dfca79ba922ba25513c3d72f24338a1f1e747fe6bd6dcbffa3a55c22d3048f1bbf4115bef666f86a26c7762e0d6e8203f7b3f15fec4c1c3a5897cb394c66f00bfa3b83d4b3447add13740c49d95f25b2d251d46b34d8b0d537be4a1471a6e54d1cc7e6cb805526df5681a0d6358e6f57dbc17f21bc5a7a62e23096f879f025a25f99bf283bc7079419656b3a4b9975a934f67fe65aee536d4b0a37a7ec63d10ae4321da36e5dd9b802c20e579cdfe989e9cb4a2a0c3ba78879c5da7824d185826ba7724749360c76ee45df3d1d30a07e55607822f633cb05b56fceb52f3937135f46c48daa2433f80086bbcae1108dc289b2ee35a1758a9ae84128200e634dbc7c5d8c9b4e8d6512270d4f5733689ca9b14e21490588e730410ea2680d7ad10e6ef31e79398c62af0084520639d9bad908e74d64d688cb5e9d9415fad069bdf31aa4fd13756ea279143034f4d31c70efdc9d2eeddf74f62377f02e399bbca585d39178d625c38a5866f41721da1b74490fd0ca4717d9d609fcb8666072329f1a0be6004594050ba6b330e9d9b3ca33a869aa033d7ef48099db7d8565585dc5994a3d7d4cc25bf6776cf3c4258a7bb9a3ef2f1286e4d3543a676078db04301ad262262d068b6953e5a504aac592289b742b2cf3c9da6d7fcf7d4383904bbd3bc3df86ee93b1586a811cc60be03ec03a7dc96c94ec3ae98cae1f69cbcd3bf7696dd1d4f78b1aff11a86f037736195fc13c563564bfd2d6056324be1268636a77e0309e9fce9a0f01df16354fb06f77b2856a928029535f4627d21b073e8dfc8f2694145400c43e005bb255f8dcd5ca3d358f03bb1e3c23eb8a1686cb8fd997f4f8b3ca2dced9852eff3f864fdb9b9b60da0abcadf7b24d4d5a6ff2544757659f8da5ceabdf1b546e801586711d4417b93402caacae647c03350db0362507bf6e9ca006501f56e8a5d64b6195ca74d99c110f2ec90b28e25e35627b45626ba5ebed2d908769f40deec227e66ac065eef9dd7d5a7d7809ad128d38a01382013036cd6be8f7febae185cf6785ab42d175ed0e3e7eb343f1c08c785b3ee380af3aadecdfd6cf52181e99cfc65059448c657e2a5359bb8049023dbf473341122a0290726d887b8d7f0b30c5024edae85931f37655996feacfdbcaa359fc830005b4224928d5114f97e20ef798d2dd4fa9782391484abceae135888f859203025117fab6a995c95a779a98dc8445a5666e5db1f503538330e508b314327886b955d59760bf0767a0a60e713144a2787b0f3f65a607bf1ee41cda557683c76b39b72d963c918b94c101ff9f2ef0362425b1379ec03d05efb85381dc83e54e146f188bea39ab4f21e3411eae74d677b1c94c489a2b434b21faaf7e557cd96f0c490439965f4a6cd912093c0558728d9325988787e3ffa7241f84cf22cce44d48d93f2b98ae8ead2385a0b28eba6dbcd0df2f4a2295b9860ca06ae0adc5442cd18269e5aa024cc34d595aee535674baf1eb9ca27bba6c34bc09bcd0a2fcf43e2ad2e9135e6bc21431a168399262bfcda05236b5b620897833095de252ee1633a4ba32c0176abc3012dcffba4b4662830aba973f248c770374bae1fc102ce9ad37cfc3b7c590a2ad1c3e4862bcc482544af07fbf0c7689245656c9d3fd16cc1943f10b08fbc3092cc20ef5023e6aeb00a695efef077b19bc5e511f9e7ee2cab7b151539d3db46036bb10e0ad85a950878b1da868919bd7bffd46b78a8a12cae3addd34e34d4b5280f7b12e1cb23b5186eac6e01cf2c3c553ca9208dd9a92406e123c7da216ecf0195cc631c52c75b703f87d7e8d8dc3520068630e8da24e8be5fa93405edd00318fc8ec78e6c32a4413c36e508d31cd5b830b5f649631092bf61efe2ceb234367cd5f64a718b3de652d107b8c9bf15b3c2f9fc560ec40ba2f5b4a68bf41d65406a73ee3371b44895f04d513586c9399211f508182bc75241aaf5aa1d8d66634e90fbfab4ff9b96e9c37d8ed0a6d738bc2fc440969279d19aa96bde42f3f6d80c041cf29720e1dfd8dc77f73f409b224289740ae11b4b2409999350b0b62edd4be468839bec348cc70c3e2530997988c6c156031bd7d88e2ac4b70ed81d1c07c379a2678ff48cd07937cf5f35e76c459b73f0237f6e0dd61e0a5cbbf74edb785a703746297e741b5b21e813b50b7af927bb409a0f5b4cb5a46c267959dec4689efbe8aaad90b4c0853df45322610ec7a92322f95ca9b49d6fc01bbac48d8abe59cf5d2a721fafe503ac1fb5caba2262badb77ca71e2299f6b6d9e205a8433ea538c17bc58e7aa96d374230be7a4d75cb22220f3457b7400c75dfff673ad19eb728098f7ea9712dc487b0b9adb5f9a279a13b4e8a0e6a78f1e6ad518f8f05d52e0c50cf6e3d36425eafb4e21982265007996dd330a2e7582e9d1cf2f1270e7f52fe4202c25654873956c4cc1b46eabf2374058b3d6c7b1f22105c9d353088e5a6b43f59db934197a36bda5c56f6e236bf6aea4b609225290472364fe4fe9320260d269f71707b5a3049bccea10f4dfb24c0f2e55592414d0ddff1ec7c7e638d742c2a1ca3898632e5863d115b0ab338af15ac8cd29046277f528952b6553383741a0e69c468307a0c7b55acf9195864d0185e4f812b6a0e4e3c27059bacdf018c8adf87dcf33738e146d8eab29b501029a061e65a37547e3ca8db7700963bf97e200b00cc92d7e60eb8dd7d06b34e51ec04665c167dc41c4f72a35b32fe10dd1ead84aa4244c43082b06bdc2a16a0312ab20929c7954dda5f4b69ea36b10e5c4756db5ccd6d7d647ac16f5e74b0b5a0d9dfab8b4bd5abe86802106104988adb566b0b8c91412dd0b9ab2e52dcc35b53a8a167b7b355bdf67f4eed0552db22b9a004879237a273566b09c4fd59f4f34b2a1965832f5902ba4b4463807261e6aaba2eafdb41524bc3b4075df9c36ac4b15a0818924bdbff01f88c13167a2017aa733494098b669e3cc5689d63d23050092446f3a7d07f342a96b9b894120596a2be850680f35de4053f86dfeb3722da1c60e7428b307085b98d1dbda20306eac0824d5a433c9a995d826e67f59d237a127664cc60e47bf40e1d59b04322a38a7ceff28687e99783cd125095dfc29ceb4a7a0ad7a28f66f9b26ef3e764619a7d294dcc05b7b1f4775d6ab7430ca45be1fc9bcf89b1347bbc67548280eebb55b586941a3c89bb70c0d9bcd9022c2e54978576db5ab18c209fbac5f52cd74843a9a5e03d7f69c7f8348b907e6ba61e9c1a77523cf264726f4e2a3e51dac162be2a5f31b9d6e12c14d19c6a356dff58ae2e5d975461c4feda133021fcb60f534ccadeda632e5e74b3edc385b54159aca33f9070d79f4aabd5c68c41d4264b4310e2dd96c0cbcd8b506bef28c093eb3a0e8607959d73a4562ea77617552b3e8d8e1ce11c52f35e5773e55bcaa65ed2755a22e857a8879e348b7fd5ef2fd0cecd13e8d4fc9eeb0da491a7a8825a1bf046288933ceac9690b0c651c15dd9310b3ace0db90ca48c42cb3d825ff844064ed3a7df330553025b4fee6d0e75c1d1934c9751bcdae0687bbe81ab74162b9652bcead33c669f5de58ca8f63e7aea0724c35ec90eaa941a44c77a6af335f70875de2914ec217fbacdd72cd5aefa4b010a47b87ea1f48e7d82fa8d65253d8bfee5ef4b968e2458507ed97230f0806764702716ddb99047a26dc4c0caed3b715293f3c8a861741a00a96d96b03e4982bb8cdbdf6b3f7e962963853a156515338dba771d1ac3ecc0292ea6c7dfe993f675b9cbc05a253f1b9317e25f22bc5092a29565f7cfbb97bacea1ac943a1a6b8b464066a8e34691123fccd1c939eaabc330f86a82ce9b2ace3e4e819c26adf1a91c2771acebb60d6e38a8b4fda9c5067bcbc4a29da5132b7b5a3e606ce5452580c8e8d9721d7e7bf2c8bcd68865f66dc3b499dd42beabb3f0f2fb0d4009bfe265b905a06163008131cf24e54dca205e8d782bc00fc23639941b5edf29b85999534fbf7f8711cd42fd5976fdc5431725f4fe030e6e86f72751aaaa4088947d26fadd65e48afd737f5706ef1d799e075f1929d376b38976e9a7e9c8b4c4f71bdeb535628890309969d9e5ca17c81709d260495ed817efa7b1b55d22dcce135c96173c12f56689ceadc8b4cc9371e4728694d4aa9d8dae666090e99ed9dca009988df329992e55fa7ec09e39c161e13f034a584eaa5ab117e5575d90c38b5cf29b39a75aed9dbb851cef28ec3198ee83b905ac5c1adb758dec570349f33f8b96c2bd07d74d198ae272ff2612fe6cee75a62a64f78b56f7063fda54342ab3e52ffb4be3a38ec6bc3a6646e506ddc934924f2b89ff26e83231b7a26621c4c949a2c7ec34c879e769c05b590887cc6193faf1ecae803214e76b64d99512dcc0e515644793461fac1e563ecf26b7388962412010073bd212df18229b98a1c2645fbad942c69ade1c46bec3b6e2680990af6b7df7859e152f86bc66d5d217b0e619ba78624d16e176a132456cea477987706c77fb18631e435238605c81076356597c06f50e77c4484f8621ca20fa3c56a911eedbbc60e9b5d12e33367414155d454a4dcdd83e959c2d74f1024e62f047a501a9939517f301bce809ede7c583a0fedec233ce0e658194e5a7711a4e8f05c3d102b230ca28ecc566a58de74ea23edc09959877014fcef684c807e27b9a46fc7a7b2cb4fc2758fb4c35136e8f0e3ef962076a8ca54619ed084782416017f1fbd4d780a9e695d405bca2d340304ce1613802fbc342c254a62bd02cdbd1748c74d4a81c644f40d7557696c3917df682aebb6e89b6ff5225f0de78cffb293d8697a8361a96c914fa93b2dc9fbec2d7fe62d7f125f0c22ab56f3a225d98f4ab2ca649ec29712de5d191b251d6c8e1ed70e9f2d1706de93d3ae2f026429dea574eee6e022780da077ef59aacfc4c0c987ef827e05ad4b649144bac898f283647940d21011ea996a7bab256791f5a56de7a8013c5e3bfacf3bcc88dab7800aaf5c272e4b8f572397e7623822851992c3017e816ad385a363122fa50da376dee01f712a658baf17b44fae31aa0f66099fac722a5953cbe278a8122109bdc9ae1d412c1698629ee610798c32a400be85cfbe1e707c1d07b69ccd9f4b96d618278fdcdf84bcd8a12f5bd7179d3befcc512e96fe50700281ca8253fa1cddec877f3855999ea9838a3a5516279d626bdbf3b51fe2da56c030c39792f595967e28110feb7c5ecabfb9ceb6cfafebe3dbec77357e42b96a87c4a724b13a8935420aae2d8e9c5cf26605a3ff83d530b139ca959fd8832502b829f2f65d1560163c993cb5d814d66752fe39b859227b94b72c111d0289fc87fd749b3cae999e2208508610a5d05192484e5a7f935cccbd6fce59ed104037ea1496015da1ae150a3088357436c6302451a1ceca9af5aeee4839554145b3f291f289e78312b2291a5bd64fd241fa834cfbcba5e0e20fe9c32c1c884655982adff2047969ed9b7da9ff37588808f472d24f66c7a59ad7bedcd6f8d00d1d85a4873e6a19463a3dcf3a2f5b451113d3ba0311626b175099fcba338d8c0bdb4c4771ca880ad13983cffa5f200963bf8e8c12c1644b96e19d9fdcec5634d1c5a1a457723bdf5552a9feb851eb30853b5639eed36b24c504ff7034eaa32a74998d74b54c063d06e8c4cce680d58abf140b639457e107886624ee2e67ada98cabdeba689331ae78db521e7b51f2bc45a3e5a4e4401b99c5d63e12bfe9312a0192fd0315bb439731e6925b1343376839ea3cfbec061a0e2edc4d5f0bcf1211072ae774529248c8a45a244ccda407c9563fe2fe49faf45e09f2fee071b617065c6ddecdde0a40236c2a518383a026156e5b7a1632b12334928ed31e7a8170914f12569183a1648323c5c6a11d618b30eba5b0319695d81c03b04f452841766dba8a5ae54ece8f5f990d7e8430d257987756bf8325a38e756e02d66f40371235e89a3d34dd78c626118a93aa79627d7b838e5a31cb46acfccf250a81848dcb3b095c4d06974f68d1124331b161348184adb9a1f2744b6d72bf6db5b3f95fa890c185bacdf7730f2365578633fac72db82872abe87814c9803164e7c670a01829ff81e91b8fab37ac32ad02eeb14d0c0b8fc311947c4f49cfa084455e0dcc6fee0a60c2f31484ac644b9cb40f992c52e61c4aa9ce358abaf8566f11936e76e8e0bbe09a658042a1f82ad6add62fbfc287d76c92aa9cb7d496d687d62f7d20557dbab3b9cf90c801bef3031233715f40627235e2b93e8747e2c57aac223d5b36c08b38dde38051fa0ba944d0c6fd445a13f68889e657cfe8de65f5eb3dbbba7b98e8978a26392e2762c702bef2940ffbe0aecf6b0c658369e76b2846e01a79d29d22926aeec5730d4b5c2fc7cf7594e6f99c69512e247c8ecd0cf73fdf01e3e5df75876cbd1cdcf0d0f43701e618bc50b68e1f91dc03ccc304ffa965108905c35acf97a6ad1c6b64f404d38fb04fb69d46ccb8a7ac03420d3e5ccded933b50da8a61bab7640c67f7f09a2712f7842f523d22ff181def8ce5cae244fd94784dc5bba79324ef07b5b7af46c4e7e33f9bc7660b50790858f77d38d08c6947fcd924c44ec3ddec695f9ed761bd749bb1e5627021ae0cd5647d2a99c069e41f29e3b72b93f8ba4e545234f0daa9c53c3363452f9f37e114fc25a09873c59959b20ef603221b58b998ef25986e3523b4d49bc4747ea250cffa57989c3f2277452b754e9174bbe6df023a85f983eb1a0aa80ea833ca7a044e9c201f29e34b56a20544abc10c1f2d15dc9e6e201b7cd758093358007165854c41781da9810abfb604c362faf5180e331c6518dd5042b34f78053c64b2430d5095b9b935d28fd8b7cc28755624b8d02016d3bd4422ff49f80b75b06f7acb9ce21cf9e156e10da499ef071ff0db97536956d78ebffda2d16070b5c6f429a153b2e1ad6975dbedbb69b1a9f4b30222c160866c5eb90a5151fe154857d1e9d27593afdd56a1805b4106cbac343440b9f78cc6f942b218ebc95e84124818d087e1fa53231e82e37ee034b5b06990bcd9be146da65ce063e0802f11cce73d730954b9bad848306a9506839242a82e1e28a39ec766f72c01b3d6c4c180a3686b1759c7aaac0064426a45a84b3146b59b169317b23c16a67bd9d3811e4132d274ea31c4f21aa0436cd5049ec6540d740622351b4b2062b8f98967698b853dc6be6ca7ecb6a98113b06a628806770344036dc5a1522ddf4bf98b85dc7eb1252198c381f7e2ff24fa56f56ead28ceb73b2003588a560f404d81f4bbbae1f717fe6a2fee037bb188ef7efd7b70aed4f3554416c3a51f05c3a9ebba1242892dbc620dbef5a4b91455729b6920b4d7daeeaed78f03594057d381835179fdf857d1a3398e6863545abbffe71b873b64d8dc98480288060956d72abe69931f0dda2e106f0fcc81bab543773c2e70e9f48bc48029c2faee1f0cbc515c5ce49ee27b172f5bc7d07bd7c80a747700dd3245a9c46b41a3007deec109e43c83164e13cc2dd997f29e5df0487ef9675e2b8fada0dd10982dda7fb4d241fe1f704bce37b5357f384679c0fc0621f0181c27ce814e07f7015b342ca446ed17aea899907faaeb27bd57d506ee05204b1158517ad3f6a8a6d800afce59c4f126da915f4cb0b5c687b623a223eaeda31552f8776a310c352f00664f71b08cf47373dfefb8b252aa756e2b3d10e203e6c43c3dbc327b362be5ada35399ddcc9f03e27335deaaaeb88cb92f7e19565facd0a74b5b9fecab394a4fe0893aea7d8a528d72e26f7886e3cb1e83f539992f35f52b3365f139d04fc0aee6fea1f784b3c7fccb1574db0e456a3dcc6591c5a9588d9ec665d6891471bb81857d8a9c40ad71ea42e1b3bf9aac245df94f9d01c7b243a96c25b8992a7943b9006a7dfc7ec219dacbd2c5efc01fb889140969d969afb083a1d54a343e440600b638d28134b54d7341f6617774c7cfa16e24a91ae74bf6508c6d1cd276f3b754fc9e619f9e7be32cbb4e0ae61299577e78bc70535b8ecdc0deaf162ba98378e8fafadfd0f930ee63bca07d42884b190e9cfb9ce16e9e0b96adbe3cad5fedc642795e52bd83884593a0094707b2754d98f03bbbfbc8acb32f632a7cfd97b691b9466ebb954c324ca1e824ffb939c551d2528f1096a6825bd69e05efb2b3bdf6f88496f6b450bde87b1921483138545f58b019b4e3b64b598a79e46c678d3ffd582a7350a618fee90461ad81585f711bd66acaa9c78c5d5dbe148707a3e621430a19efbdc08a720c1bc07a5436b73ddc6b96ece3d5468c5153676a601565cb433f09a9596ad7af29f89364b151ffb18ffd35dbaf158066200042375f75d8d2052ea7d6e601563874cf7a4647e40eb3299a314400d8693d0ee49c4d2d17a412372b1e442702bbc40e56f1701c6c83400b3c5f2b1ab51060e019b49a04891ad41be8615349356baade9617bf87eea7c679fee3a4b6fe917fb82fb82a7a70bfbcfee00dd0d0a82d07f25a369e86b1dbabcfd72b883b64eb8367c79781dc20b7e9c9faffc0b0541ca336ff06c742594a56d70096feee1b9bdb90c0509c65a89261172c50a129e85d18219a34cd47e0f194f014033d0de8f6179ec50f7c83db84ef0497f097ed346c806d98366f6e26ddbb3d859d789aef377620195554d8e0e98bee1dd1ee55bce8afb70574124dcf26241088a05eb4d42e66c89ca9d6ebc1197e9fb062c344a23711618116470aae649d9178bc42e8472520577e23025fd58844dc73b93fd0aeaea568c47f6a14a2b6b1e0c685996b97e9625de3ce4466d0035eee53daf230562004ba77faf4d4329e8f9764a364c59b08db770e4c55afc388f14f1f4335f7d3add5448baecfd3910362dd96a628bf9e409598ba61b555d33b1da165c01a3bc453ec32db854e0c2963aa504a32d796e431f15d4a0e67aee7301975ca6b907e1f0dcf0eea39c22b72cc2eda2ab84f847099a2b02c177c66c93da5d548b3ada4286c1755808e24171274690ce7838d0adab725a48237065b5c1cc6c534982af44641df62fdc877dc00dfe751f8a1170fcc1f07bf892c720daf36c833b7e6ab1c978504b075cd9937263137692417b303a951c86cd0571b88ee33419b9fcf4388f9135bc5bff9bebb05c03abb1a2ea28874bda44a74f1ee51b188b13f6282c64142d53b24e357d5326243ff75821a5de51ac1d61ef50c0ab9717a8433442c02eb31afd6ec8baa1fee1cde97e4a97530322c20a055775271ed29730d59fb91ef597b8e1b424b239765e13ea0bc76257f685945ca835ba6c8cf879acc1de6656cc4c543253c613544256aeaff36c58f53f8fd5e8c952c3f5894f952218861da4882506c074ab9e839aea01619618d86b1d3a0e74299675154cfa0bdea7cfa2e88d72e7060aca108a16084478d263e418f8084d8552575fe7fc15260f506aaeff16113fc4ed8af99224448a167fa7d12e5779281c9693fb3825dd3e33aed7ef57f25e9a070e3f804f5bf87454fc418c16ee04bd7cb2a72b8082157bde22e608df8d5f5eae53a76cc599780887f326871dd2bdc8a59766308b6d0d016493f9f371c562001bc19d717468f482e18539da3ea0ac2c9c2d0c08112bd9799d977297dcaa486fcf5d5cc1c753f65406272221284eea8b798049fe406a6ffdc97398838df2342b95f919f69ab27fd618a9782b21652acb9bc38e0ca972303d18c5f98a9461f40cdc7f1361550b4b0accaa654305b9272ff0bca0f46a9ce0403855343bc21358bc2fbd9588e4197e5f0d02e67c850337b21df83af4d9a19177bf1506646e8eeeaec1ed0bd630b9477cad416870c4676bdc9c4b17efe45e7c3ad5c131b80ce9578ef127602b52b63ef6e0f05ff3d428fea424fe60acccc4fe387ab5ca338baa328069db1e1620d1be124d0503bb88e250ee968e00899ed9a9fc3197cd569a0c1520edef059867cdf3a7193f4c02700d1a12d072257c44c48052df493f2ce1f453ae2616d97ddbf51e7d60ed2eea49610ffa6a5ebeff31eb0c3febb716b821435bf344a2237043008d99ff76cea9d8429946b46cf09ad241c9beb26e051ec27a94c5f021c8805c78713bbf974555ebf65bda1762e3eb0f38f9691de298391fc0a64c5787c999569a856e3511e6a65229e6a46fc76a7a5f842b8b497f66d2fec6ee356032205cf092454f857bc4451754faa484e66f470c4ccea4d6cdb9f2c75f101de69228abaf5c82846b3c227b112b2db2379958eccf251e71113801035740429","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
