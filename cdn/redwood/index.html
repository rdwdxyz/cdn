<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8eb72ef8c3e154e0fe6e8fc826a0824bda8d5e37a320704a4d637258229735e985c90fc581595b8f646b7287aecd482b06bf35eaadbc180cc9b5df061faea1778d826b8b8291800dd93ffaccbbb0a98a8bb47d75dc31bfd2ff72f66e3442724611332aa789096bedbf1359f856d9a5e37d9dae1217160df03f2f14884e81883cf05eaa11d1d953304881c8c82bf8f619352d710b34e4f6ec37b177cd46155e6782d3fa43ccaf5a97167a6a7584d8a87284bf2855aa23416d394afd1f7340aa70edcb196d6033d8daaf6f3d747221c2d1a1b31c56271fdeda700a0ad3b0ad73147710a768f0767d34de2a10bbfe66d44c5ef6f29274bbbefe004d652cfb977d0f5a57a93d0bf30be8a536593d4883fce1660ea3205b9ed6d3111cded0a23980d4cef048d93be332dcb696970cf47cc191f88d987e66bd935eca5563e250d2eb4bc3bb512b8f2365c245aa162ee95d20102b1970598523a1f6b8879d55a0402750bff32d0781145db1b0d0999ea6f344651936cbd6ce9fb90778096eed8b59bd7a995974d69e534402cc4388424640abb1367ea306d06ecb0dafebab19b27c12fd6d5c8b9e1d81b85eb5ef62620c5c0f6d2eccccb7d85367764e8dbeccce5924a6a7275f00451d7b0275b8408e41e8324c7689d218a1681d8d63982af3a58d798be3c9c85b5018c7e01d309f96cbb73484be51ac783c55f0775b837d8ac1dfc5d8f0af70113e405679b4271d4cec5ab0cdf884862ecceac4a9d4f45f205799f968c9385cff1d72f27667a6ed9e96ab0ce0a688ee8dc689fcd42ccc0ee05867bd19e3d1b036a91665ee9af7d3c95ef643ad95bd0fd9fa3a30124422c41e460f924de818bd60e703467fa724bde2a65c66ac77585b6149cbd9ee835290cd36510d27d4011fcdacde0a50a025118f23aa2d608be22f4beb7969bc21fe9721b6aeeb45c4368d8832511902f3923c48442539172cb47b2add3d149f1958c46fbc0fa148daa3ecd36e6efc51faa9b550d0bca5ad7a4728388eb7a059323c6be00f72ae70c45a19ee91690f89ce2d0719d6fa7abec190e9f9e54bde244e9c50fec48897f94f9eea9c8f580ed724dc56fc62c4896f0a2b0478da17075810b500f06fccd9cca67393dc01c0b7dad3116afe73a7860d5c4b39a9ec8b5b549447f9752760ded23a06bb025a684f9180b9a64811a089a28009f884ec60511095496684957700c83734e0c25f53fd9a58bc980fe7dd48095d472597702d07770cf1871038a6c0a8d2da045505ef0c0c598d7545bd0a12b4652a34f4b899cff72f820a54be57452a3fbacaa9950883286592c191a72064f630e5c0202aea037d5683f6c954205cf61331c3e02bf9383fcdea4cf45583068a4d27158c0a873cb1e49b2e86b1523bf0a36bed4cb4b4c69246d8683e3b40612a779d95ea1908aaec85bb811dcf6d5aa80b891489d53c900c075b16cf2dad8df24c8f158a8680807767ab598c362fb202de6d9b25f8f3712ab8944b78a1b58c95be4c6fec521ae382079c4c638eb01d67e6c2b44130f0b46034d087945d4e69a3b101ca464e6fb10d7d6b3980b4905ff82860a0df1e163fd90f6523177974e7b45e440ff3962bd1dac2bba8d097af95ad123bfb64eb4630e92cb42491be39c717f1374e96277136f09c23210a13d7f035ccf1d729abdfe0f7d4bf3c6dced76412b8730c3b1a6d21bf86fafa540accd8fae488df996ad39ba8ab77641d814614b085e0db7f60bff9ea3d960b200a931c3e66db9dce90c8a355215da8437c7876b4c7584f3fcb63c722afac422c7adc1bd305b78f50aa5c130284837b707fe2db5b27fc5b9759e816a1c29ea5e763335833bfa86ba07c9e09673fe467ff0cde8a6061b6fb9b52bcfb0aada852bc82561182ae953ba649d7bce1b44484e4bf1bd37cfd0c0363ada63c4b61d311f27e43f8c59bd3c330c9c14c7e8c4a3a1efd6522fd6b8f6cf50ea92b47d29181f8d367841a9879a099896a67476b749c4f23779bccd0108310274d1b760d16062472a21b3e50b1da1d9ae8094c1ff5c8e854bc57bf5dc97cba72c7819470cb045637bd4d09813abf0334f0137501b45e387f7363c724ca21dc60d14c35ab4b98ddda2a3a6ab6655ca6b6c5f25b7b218770b5271b09ea512b6543533afff689d12b83c56e097d187f7aba70a2d8652fb997c7774a1e8a27eb1ef440ad7e96d0472303108169098413d01b54751f6d9216518efdb985ffe262c05c6b64b60b771ef18a61fe1e0864297df367345788553f6e5141c7cdc1bb049fb665e3bdce2d9885dfcb0b9aadfe85490c30a2e62c1cc95e8a1e6bf554ddde0371fd886bdcce264e276da1c41522a3f4f2c5d960bd80ad2fc580ef12798e29bba65b173f994ce78b1a688d4394d4fa13aea5df6a6082a62a0e82c9c28dbfda1977b51881545ea3af8b6c27507f8100127dc24c6d2cd4eb527c6f1a120f8620170a84ec8633157e983336a8be2d020c5d763cf7e642bdaa360dfe48b8ffc0255643f58c5aad59aa51832d90956085b538f55169f75aee7b9500a83d975c4e7cb3134491003e857496a1f500af2cf7e61d918529f229df17022e453dfdcb93a07d8dae4c38b1801182819f727e6ccdf3d1486663f59b1a65c71f30c44905a9fb31380bbea107a61a19957c6b2e56fff74a1cb5f8350a66bda9403918a9fece4443575f6f064b27b10b26ddb1a6926fc7f43afc6dcc86004104e4ac39de5e57c1c7c965c29ebc5a2759448af043a2b4bd9f5803e225b0603338809a8db6cd051475f1e994ede946423670562abead015a91a575ceb405f559e1148ca4ce82f8b60a8bdd275e4f0dd8ba61044cee162c0a41da0cb516b63b097081c856e06fbf37bee9c86d74a689db9b646a7cc599c18ed7a8405f995d8ad2077b701500c10531670efc7bfd917739cfdebf04f9a439cbd70e41f4f5c0a41ee651c8b639407a0841dee2ef5ea738cf403cc17535656e8a492387445838ec0557f96b023237a196050b8216cc63becfe59d7f880a3f4a26fd58a73fe29e0d8efaf67e7f841409b2c9a04174d3474ac7468ae4af23201a439caf8bc51b01e0e9eb0e35ad0e43c61d75af9b3e0ece41b969261a36aaf72a6d81de39504db3dda0f037249bcbd80375185d2b3be254e1e0508f94459bc659ac70ee537c3bec170ab323e992e18560a1ecfb35707dff24014b59294eea51886dc1e336b380ce7ac6db040341d91415fc141609e78b73b167f3f3c00675a241262f99b48471c8eb6e48ed843cc05fbfa3e395746768479361a914f8f1c9b4afee61deeccec1b942de1980c3a4b7259e4fa76c0009bb02e4a3ab31f9ac1c06346051dd821411ac9e64ce47aecd2610d72c78f01eb4d6112fc0af92ae156538c805523fe89312b986532e8abc7ff30560c442a984fde9bef81923176746c1afae2fcf47012cc19c87a3390aa47b622ecd8e17e1fea3e69eb47dc6c77da2032617ca962f57d1cf1838b5216daf95fd5dda0faf9319ad04ea20437845a20d943aed44eb220412f719972f7bee4b346b3446cdf6e67d4240c99a51f2971e5051d73c5c37ed5ca829383aece61a8780dc77f63e90384a2eec8660c5d3681d3d01f66fcf064438b010960371c7223da675371a4b4067e1f40d662f749cc713cd469e034b6e46e27f2aa50a534af3a225ca4ba738ebe443fe887ab472ea9619ccf1721deafc17906684113c575de161bd555aa75dca57acf25a98fc58225d7e766eb66d28fe872cf692aac62c0b896cf483f0e83a5761f3f6a2a371efcb5e407cf350d933047d5b5d244d67240d538e9ac0c073dfc9294ca97726120688fa5aefdc1c1c85ed9483d442cd0599f5e3ee3d24a47b676f9a1ab8ffe83ec3e5af053b9e8efdd511a04eb86edc11afdf600247251edf125e34ae3cd6fc50858e2b1272bf7a56fe27964f7c5bc4331ccca41a37432716df0c9e3b7ee5c7341420b28608e2433a5762a27361baceafe02d95f334d7adf7f7d6508054b1ee5bb99692735250bbb380c11d7b487e31502c0b18a26cad237d85b13833351de2f6df284fc87f29d54d0fc50ec633b99e356a9129a04587c5546c84537399d19c7dccc9a13a63d270d74ac6ffd605db70dd525913e684c1f591c551f71267f35d334e65aa82bab82725724cb363838a374df9cf3b96c0155c10c5bd4b186e0d2a1d4872e18825062e3e880bf50c7fa2383ea70db516764e006edaa1f15d220824ee8ecc71bf85d6e7111c5a7366731042c054c27cea00e792ceef8c712f4a2f71ede999b63f382d85d3751d17d3ee9a808164caee6063ebdfadd2038591cead9c8b44b724839a6f0bf7da1d28e62877b989571e9472988445826962372b8bc93a772520eee206705336457d748ad842659c0f44c25e4c64a1fb1dc1725c2b00181080ea5fb9cbab75dcc54dfac371853758f0c849f14111c4b5f2e35f0f3f405088d4a22067be6185b3786b098b2c8520a7c14d91ec67e1cefc567d5f7c41a34656d05272b0af9b7f5e62fc4f1e47b59c5477827ee225e055515f8993914771c7df3b88aaad5a729a09a2da384e2e047a7996cff8cee9c6b31bcfe54c3c614074033c2c66e322365c088326c913343c5f2cb31249be916e85d34e693844e9fd03ea1563acb8d3e2659ad7d2037b257117989392af6e75f67b6a9a7beef3dbcd2e3c779bd6aab955f83498cea124736982b1f9b8b282684fafe5fd2b000aa321ab2fa0dc19debea0cda4880a9f9c728c3a2b194ae9cb75ca45d682e86fc33b52be282b809e02e8a98e1c495a154df9d72fadcdc6b692c391d4625978a8cfa2045325e4a046db293d552b5ad53c4e6c54f219005af6ca7704961b790538371e4c053ed5a12e6050dc4ef2599b644c40087232372c6af1ef520bd66a639ae9084a7951621728ef315dd8b46d7817ba91c5d4a75385c29ba11ca755b55000d3a4edd07d9aad8292a8df3614816452bcabbb3241379f9093c1d456e13926ade2b0c0ba82170a505c3db5e9ddb5f4a7937c7f2e1a49e1d79e72b0b65455ef1e22ee148b7cadcf4e4ee3308afa7ecb6093bc2c497580b121d389fc46eb917e99a7567ba285f7708f2c7ff5cce93f21f2141f632e1ddc17cf2e6aa8725d6628eb9fca714a7d370ff89e610f4699ebe3efd759b02c99c26a3c0442fc4506eb55e0ef1a8f3fec24aa3da54010b1d6b1efeec305485ec5011b5cc133e8512013b86f2f21bdc1cc6b220bb09fe2d5fc5c3530ca5a220940bed221f9bffa46f26f413233cd27e311184faf9cf8301a269f58b1d24f95dcd5eab573ed1cd88c839dedfc63d40822b8148d595bb6ae6a533a1277dc892e2d565a5ecd145a57cc62e744d3fea1bdd472ddbed4709033d0f6a626ece052b03128c87161bd9831a9641bd74c046b94cd5e9b2ff8715415f125b89c657f06a07b9a9f093b68ff862da7be9e39a8555ec30dca2f4f6cd789e5930667203f14501930d756ea7d2403991e4333284aeadd55fbe354b9e43bb373fdbad4a555d861e90c4220aa25f439db70ec566b3afcaa5d522b538be735b6b605c0ae460c6286416e9245528dfb8fe3d5ca68491e0a3c3ac5b8af7cb21063b57b213ab28c9ee82ac9f418bca0328eb656c932485ab8f57ef6abdd6b77df6576e122a41424aadcd37aef78fac9993e684e9c21826c2a26500a823ff52d9526946b180b550ada3eb7b27502f765dd005894f620d5dd859fe2caf2be1eb411b5246a26d79582d6f8189325b1898133866558ae2aea8393cc5b42f0844de73c20926ec11faf3046e478d73a6f6fab59fa2744dfb26057a145e334c65d5eb88966134ecfbcca6cc4889f891497b5caed3cf4b29418b517d96777d18c6a4d95e020f60312acb073b2e8d72087b3c54814264d21eb55fbefbd65f05eef3fb243ea5751f297daadc3281fc86e2b8844b6f44dd4de427249608093b610e2d516e033f85c59a7a16e1eb91732dee1153936485cced0caf824e8a2c8db719edb2444f26c74494ec11f46b8fd7f9c2600d394e2bca24d7f74f1ff737d8f67e548fe197c7332d2587a8e9fc628dff33d29d559b36b36b4d3d301e6f9ce39eaf680f274ade1b07881e3ffa77c98c89a50b63561764c786ecd8b9b40ed694dd2ebd4e1a1854a0bea3cab41b1d7d099a71671eb518dcfbf01ec409fee01d39502d709b6825dccd16d8e0088ff26943d0e746451c6f3add4fd84b677db6caec5b50c223b5dced9a48ed5be20b0bfd194a97a77045a9c7dcb8caf1d4779243def96caa8443968f2e8ecb40cb671e323e080e665124b0c773c541addf58d63337827ed9003c245733e67655f9ebe1f9a6978001fd11feb21d28ec109bc42b5ff3fc32b43ce2f872b2c4ec6706414d20cd1cd0d91263b25d7074269050da163296a9b807dd71429a566f261b3ba8c48e2f11a234e3f6b2cc997999139857325fcb49296d7f0e35add16c32eef225c2403436ad6eba02dfc4b9c8f65ffeb14f775a20150ec6139077ddbb5d3391605f06594d53630dabed4672701bfe0b6326403085e2b5f94ed048f928df6525c03b332e508f8d421f7ee87ab88f00c315490bf25872e0ea2991e800d726bbc7b14b5f519132ec597d4296f08f14d657616aa4b0ce648631cb1ec76d2e6b0c10d1c551c60a5c87302857730a4fa0b429e7e9283d58de8b127733fda2d8245fb5b2db654774a98efad1b02b76c197a9a1f81c67d2ae71ea9458e38820dd28a3459346a05be08ba6ed521c47d40d434c95631a5af471edfa38fd792753bcb6b3b31c109cdb9d370ce1aef97483debc76bb72b355ffe94c01676e53eca8ed6d8ba97647eb141f81befc85957b4bd25a2799159a6fb36680877d8607bc97565b62a461bf6bd19297136c1c3b0905bd4ec7b06978220d79b0fbc36ac6590a7a91db0de959974420f58c43d25fbe64b9c47649c2b8acff733849a94fd317770e73adb1103dcb1165c3285f90d4d796036701bb1436670b9399ba19e9799c415440601f170e78c87fe4b91d3fd74c72ad7850e94189dd6c601d88bfab0e0aa6d4b31b66c81409aabaacf40029b1421112b43bc265fdd252ce9a113e621ed9b6a112ca7ca22a96da8c2bd7880bc16e24899927b8651d29cf24c656de700983ff4a5f2305e08af4598f4b080032785cfadd1ad2b20f7f58fd0d87c046543baf2e6d0339bd097713ded0065127d8f2c838aa195306ff3e8c8db6f9e28d726b0850a513f3804268aeda136ed0f369f8c6edcf59d566e0bf9873faadcf21612cd685d28d4c672f50218ed441662a4bac1604323b7b6dcc099a88445fbfb2d748cc5584c49eaeaafb16456a50245920f35fca8692c26e4017b599b358d157b694bf7839021c2c039c8c365486d17588cd6094f5d7dadc256b02d3f2dd04207732a91fcda09d7fddb4f59f90d5b0eda35a610cd2ce26948f44e3d2c22cae63e1135661ab9bc460545a8514aba11f36ab4e39e926d06deea7788740d562315b519b12086cd97c4b0c6a6180359bc531e2ae1619f323879a6ec82dec8873dd1ecdb4fda38fc04f0798986cbed5896a3c83584a6339adfd346fdc614ad3d1167b0e7729b032b910da3a43e54dc5c278a1e1624eabfb93fd7f890af63e28183f375d3a61731114c0de07f5f03e9cadb248202b5f0cb17aa4bb8fcde8d6b6cb390b18e0f58090b1a0386be964ee5ceb84de899a221cf4f875be4f7016a7053dbe2d15a6a582bc2c5d584ecb98dd44b63d993aceba186d0014f5568b0c2e2ce7fef26fe524bd7c796f9a61029f91965a86ba21e4fbafd004b2644e24b7fde6aa43ba7e0484d95e69d96dad64553d33d2b8176b763c6f10be530d70fb674cb5510a58af864dec5db35a5ac109a1fbbdda4ec939ab02b947e34f70aa717337629730d2109589e938504be7174bb3bdedd97aa67c53d7f0849b756b6d1dc1bc4c65141b923d0d42a52532e1f24471377bb4fa55b03bed9d653a6375eeaafc0fb5acedce4160b62470c2764bdcadf761cf264a22dd254dafa370c9e3dd15fbe88358975b8d24814a1332d5a858d20519c6d4d4791453a8ea4357af9f33f1cefb8628e45972b3b887e831ba924c5388273a0f2a5b583921ad5a5625a6605a4dae169c6fd29c631eda91c2f9ead82cdd531ba61342c489fcfe03055df08d3a6b4a0f66289e3b39feedc77b8cbd3df511594b5b47600b9a8acb6d59e7800627d52f780db8639fca32a22ae07ec7cfc352216a61c44c872c89cd167630d022abdee8d2e3f8d11fe754c5154fe62716deb368f5a7ca0dbb82a3c53172187a86237feaf614ccaa341c2a6f674f12091bdf7a29a1ad0fc619a61d29abdbfcdfe8e42f63726db55b81f2ec0bb4d13cc61487ea011a3b7ffd4e22da90d9383561e857c3e190e90a339f081192c670de76874a2fdaa7a895af562162762eee97619db6c36429093fd71d5f276c8f9ea648a851256123a443458a1d4b27404d2b7c398a5818d5677f66a4d71926428670d700436b18570958262c92ee022c4ae3d797f5f160dd7c076c81b38d636ef099f5ad2c02293ff35ff881b27dd951439fbd8c8ad464c33a2b872ffbbd53b75afc0f344fe3fa20447b4f9bc9e1ae52364f27475c4347f09d45d89ffbe8cae79656a99626490c570bd7ad5c74ba8cf23febfc5976edcfd69ebf1974f5c8660d4b2558c0d74c2e078293ad1845f5ac6e6e8ceb7a70100e4b9b7f8a9f63f7696c29dba82bf7dd3ee43a1d1a121d7bec4c1e66399a34fcf8132a01aa57dc6d882fd883f89e45fb9dc7a3b365c91ca3c29e825414e5e0bca51de347cd40ef3ce19cfc5733e3e25d1dfd59755d3096eda93423a9cf4e1039ad3faaca6749c303745b5d075924984ac48b8d9568c07c8aec3c2196a8f91cf93b31a0f9568528cadc067f7d2a0f97d03f73627146edafe2ebf50f15bc6d89001876695122f23dca2e223e64a4ec72a26de3a5d7047bc4964d606239d68bfceeb795557ff652d41692324bc50b0150d27888777c9188b41cfc036926cdc4ec1cee4b61805f8d0c154ece3cb50f06367dce4c28a516e624de29a888894721dd9a5f0616b583d1604b02c7d5ec2ef36756041389932a8d5f704e928cd1f6661f2795de0d2e18f09d288bcb7e0cd8f27d3fc0783849859e3754ef1b8189cd1cb17b421562eb8caf91c4b5228804ff5268d25186122f696dfcbbfbc48efc739a3827fc45d889055200b08296cd38af3d2c9cd533f958284f5d6a0f3fe8e358ad98553c0b5ad7681eb8bec93c0e59d28a48a372c36179090195237f6add63a135eddee9158df3958494f2538d95401b10d6a8bdbc711d1120b3d12259e0d92ec596d58ee2905477545873c97cbc14f9ecc41fbfbd059c7b890d9d9c5459ca90c45c027a77bcb3c33e2a7940a093141625d1539f8ad108ed598f1431d0d105e0caa9502567c75c56421c1321eb336ac650b1cf10e003478aeee2ba4c5ad2e15f3e0242c5621f7b601b26655326851cbbadfaa0149a5a445b366d154d36e1fb63953106f23661df704b2240a456bc09ebd16a950fed08596b67596d6c3289b510441ee85516e2ba4d3cc70237b856c75b7075c5aa9c3e414de026c7704c51fbc68a85586c8e6a48ff666c79e598f5efcd7789075c6b2cf213c13e6ebacdb574eda19f1ad9596d36f9234d1dfd3e1f1e556cbddc64d049136b51362c4742721d50788cd20d4551579e6776fd6d5f8e2e3cc5708b91ede48f7e0e99afe1d86724e05350336fa0da9acdc96c1b102ac137281458d5f4b22cc2c2b9d23df855867f6fca4e86ad73aab4184a29e520cd61ece685b6eb4ec93f94e1937688928152bc7841f6c57ad1e1f7fdf453a36dd9b0069cffa70de2276dbf778774e04acb71f24adcef26ab9527605b65f6298a39d7a90276e3ba1ac83b2f147e361aa716f79911a6e1a0b9631a6975892d40e8ea6415ba20ba55c92e08751980403912c80818ecf20dece944a2436f778f0b4729b405f7936068b5317cafa13cb672d9d521de1f90cdd8bd8cde220bc4ebb66dd3dc5fd4d843e7dfe1a72e1daab03db99893a4fee47086f2676155462700a9f7dafebea3c7018fece0ecf029136fbe26cedceefda157b4cc37d002a6bc34c9fb8265e6248a05a0790a6d2fc1c6565e7a4603646d4cabe58cc1a4aa4f962359393c7597757eaa29fa519332e8c721a5685a07198a2a21a9d2151873256ec6c4f9efe47f42f999e46a9c28212dafcea9630919353733e2770165b66e42285e1240af228930462a54bbc1f6d7165e39e92bd9cc77d57ee2ba30004583a217f980e95ac659b0c6735fef4828201c53bc41645ad47e7f34a625e27c46ba6620fa9c78330c74b49c0f93992c3c2e40855723cf2a17453d08c0411bb2421cb04a37e4cbfa23576ca7c173cc83846b06c940b171d396c5d94765fdcf5d7fc216c4cabc13e6320cf5bb51fa10f54b5da342a084b549e649afc77b79fe1853ab7682d2fabf2128d8f99b21814a438441ca3ece307c96adde678d7c6e17a757c6db11100d26a571079f28b528f17258f6f9be29678addaba5d976f1837cc72f226b4702590ecc38b479cc9637664abf151d1e7b87f7514540b26797bc54ef154ce19a240f99c333f4c9e3fb676bdccc454f5617211ef4f2657c2a58e00e6a51bc1571c05e4220af68cc3fd09cdd63d54bc65923d11effc709721d832338916014ce8a19db6ec04c496772bd793938af9c95add1134acdd3732434da7222369504f163d97c7c48ebe20b06e5a3adffd2f150836bbdf3407d2717c23c2c855f8a38739e585c4b8cd48e50e6fcac1c858eedb107da0022b798509a293f4e97d9f2211185636a69f9bf2590337a7248c8b26005e6d6982485ed358144dcc24527a0a1d6e506f89378c4eabb273b0b47248a0da825478d8a9f143176d1b9b9a37cab38f92d5b9bd37b0fcea04ee1d0f311cb6d5d52025b65c34e33ab310bf7c75bf826b3e5028912ee46345574f5d230c2d49e774f0374e22cdfc12d395e5096d97cc328fc797bfc46da2797aac54ac2934259bf7e2e2fa272cfe7cf35928332e6ebc08e480bb7776ad66b20d724bac63735b9e18426d4d4788f0b94e797cb624ed2df08549e3ed5a32c4b657ec537d2c920d18e0eeedd244bdb5a40048d3b65a68ba3711bc821d4cfce163b8958c5d25aa9028999c0528119e12157da0dadd06f07a21811213c19948ca28678d83e6e7b006eb896de9e867456b728925c8d82e1ceef1790e73dc94e33496f33d579d932b26a3ae1b888f6157a6a15ed2409a17e1a8c3550b90e58a1d159b455431f8a19e66ce82f3f2a01390aa0ad70fc1b7a835573ccd30677d627fac608aa684e67210fa14c1a58829467d23ae125773e762962759febe0b2da0407ca6d7e9af5e132337d96c8f54d956ef03db18cde435b1fe71b68534de24cc3cdca2788ca39f31c8e8365f47911b946a6181e6ebe45846489fdbba9344cea9990c658caca0550c3cf294a67234843de34381a56b8ddf5bb6d63e79a83eb9333f40e3150362c07e278454b240f43243006db6cff81524256710ef91127b3e68d91dcf8c36cef325be8e15fb9d4be5f61160b14ed14dc8146c0d1cf37b897c13ca3d50c58c9a00ef2ac224fa587ddde6a0f99961bece93dd5c63beff9dffbd76b3d33bd6fdd65b4a7ec0d7a029257d54aba9cf7c818e19a2bc22413d2cfc2e0344cda5de6de45140d7e778d1fb8c1ad41e2e05c9d283820d154208905d6e9a323a53b716be03e65032bdea6d45b07a94640f37d6aa90d9c407e428019f776e89f84809e225956575379bd6a492a4b45acf4db82e2550eca9055341eef3548a7fb3effadabdbe5ee247b1632116c8568d57ee652a53e516eac2f315ba0ba1792e92c0fccdc73b9a7881ade0456201c647ce5b94564961f617f9a39851702249d8fde1d3ec80a8477000cc267d8c1826602865b2be04dbb51b296e825a1fe0d3688ea0954275e6e781b3eed76f495b62da4583eb11fd9a474c1bedd9008872d09d6071280eb99aea3a3efd2c342f4923656d9cb80ee881ef7f7a1be6fd2e9978893e0704c2656cd083bf7c2d315ed9ad8abbbd3aa257e6f0d8d05acaae545719c28b156b1127e9409eb31ceec42dfb14f1a0de13861fb880d6d0ecc92acb0b614a08a64585df7f4dc0f51db319d900cc75ada0c1548f7e51eca74e98ceaf517b866df657e04d1575fdef8bb051ad583daac01a25abfd1fb1c77584ad251707fcf57fa8249aad6be6a8706518bb86dd7976a2d5d7d477e54a7df52b221cbf7a4f57e34c8dfcf964592686a872bc8f93455f3a84829eb99b67eebf1c25f53b3906605d92a3d8b83daa9a2642eff3984a727bab1d21c0eb171b7f89546192e474900710b5c4fe535beac9e608ea9184fc16a91e5b49cd4514228d6b69b9ddb901ac71b10bd15c58356c3cac72cff3910d3e8e2b739eecea4c3350ede37d7846664bd5704340ac9f4eca716a2376fd294b93a38ab19d31b3885e4db347b1cb085ea31d40f4ecb162aab0ed104161ba593077d0403ca53bca64b8601adc69886a4b3c3aceff2b1e884e9f8cfd6e8c1d23ab6f8133d2d8b3666d1ecc62a54ef629af4f4a95fa9175e90b1eeb0f7a76c87ad963a7491b744e6bfcbf63770321f07bfe5237f543082fb0ad6226714cb6bd481fa0ebf34c0cc97ba23d07b397cc91830bef00461184cc2f47d47d042fc935b6d3b90611462358029bb204b6452e4d2e806c149941a85368cdc360d5b0649480077b5fc2fb7927904ec01c0644966af2b899d90a099f7f5fb6ac16b8784c4b6ef5a6760d19b0faa72f607e792e308f5d5b5fd84178976186165b0ecc48ad20536066abf952d4164bd8a062ae4a2e8f7c84e69b3a82c284cd653d0f785aeb59c40643365dd97b8212a6a6d4f387b1f62e7f6c9e1cd1589accf392bd83892db0bf70784115998d8a907848e621b5fb095226c795266e9fac0f4315408f891e8fea00f939d6bced5ddf87dfc600580065ff2ceda60119b3572a9cac2d4a3e1b1e9e3377100b639637397e37058bfde5cfbe4923bdfaa4d59551a2c36ad968fc085fc035e464a3cca631241dfbdbf0d7963f68a4db9e3b8c5f970ef0ee4a98ba082602a3d7721dfa65dd373536d8227239e82bac420e18573ee68c0f4f043debb32cfbb6ed12d2e7fb8592f7bc60b1cfc9c90e12681031b5028038a69485f6135f8a55811297a8d04d5bf847fb65acef3680ddc87092beab530fd7d385232b3325c94f9357bdc0857bf16eeabc2cc777383980f0bfe412e3b0d74a29144b441badd3511823ddaee5beede37a76138b93cf4e101f43166eb837a4a135550265483d9e6e4c431797b18050c90ce705511af4086a6a8f83df6865af5be52670d574ac3a17fcf8bd4798742ea9500cc2ebf850e971f6adbd35f86bc911d474d60f1aeab786fdb223fed1c4969fd9d5f4666291745a9ac9aef1b42ef94b3cfcde35313a36e212b2d73203a9b6a8b61cc10e4f3aadead39efc24e849dda232cc661c5d804918d8490a492399826cfb765f9f038fbc0eae3d25c93d4e24dfe77386ae8c2f74170370cb551b1de2fa947fb2a970bb04dc6e2ac47b064615e43e7379b3fb00401bd4257b76d39b0ba0ba0b98641e08b6c4b05c90fa9ac9f07b3c7372ea1dae9d0817a6153eab31d1c88efcb76ddc4f544189dd5f18f42358e7bad9505acf01aa880125ca62794b04ba2a4fa3050238bd8437be7d6fdfa05c94a5e3ee3ade151b1569e5dd97469d29beb1441fd438a4176e6902dc24d36ca5585efa5409d9eb69ac0c32dd07a8aa36c21648d0b3f95f2a030d19e8a2d0d9a65a8f142efac4d9a96e193968fc849ad74d84c4442119abde91cf055daaacf1b3fd016b15157d2f96b0f9cd22a3a6cec9475737aa87656fc8a6c36fe4629141d56c7d67d40a9b2f660c0365436c44b2b0ab21304d24cd6fadd44084f249875b026516d422e5173e256708f83c37fe7474c1dbd2a3a4167d0b56fb06779b0e07dd1942a3417161a12cfb7818fffd00b4fd4eb94eb0075c312206ac407e86486825fc36acc822aa3bbc3198971af50e0183931b7f02329da6afa3822d28bc12aaf55086e7e9b4efe502eb85f335dc1f51440a2a712fd180c18c103390bf456c0a5ed9552c7a36a18de363e2bcbee6c2724facc172f79ae2b3758b4143948ef2c0d0c1cf3dd35fcf112ae68eb12aeb18ac69f26fb54b9f75899797a38ccd0f97aa79d55339199cd7ffec4df5a130f3a896764e96fdd9d0cfcc96bdb00ae33129113d16db39afdd788a25d78960c5d56e206d7dba885bc3e96a43697c57e7da26528d054ca00a635982a9d4963c03c54128b6298c56caba38621f3fa1faf0dc3ea57f6a56706fb54531820fbafe984b57ce3e829e027708f6b3f447432285cdd609969f428bed7c1fd03551cff9012bb7143cbef7bd14ab5ad8dbceec2008bd81d7f13d060107ad2c61a86da49cf93df648b2ee9b43354bf3382f226cd5bf1633eedb130e3b857cf4cf4081786b5ae5891290ce3924f5dd0a1eb2d937b79a622fb0a8ba722cce711a521ef96be67479532ac498d048ca6807aff287092c9ddbb669f5a9cadc484ccfd9411388fb775cbac9894a60c768f0fc9945bd206e415db5b4df9664b884364e3f6736312c406c3854d45ffa9d4b4e0e147126157ccc85789c73f18ec67ed9a9aed61250590ad8d08ce687a4e6042667447d76bd922ea9fdc0c54adb76ba6afd123634e866271774f8791c5311d580c43d7273cbf5a1d258614119c2d3bfae217d4616fffaaabd860ce68a6a7c99276389a0d993a197270113abb5d0626773ba4a492f269edff8a9bac13f109fc9f4386cef34217f733243f17c17b21e9945b13cc0aad5da7941fea8abdb23b2869d298841d1576ad8e6d6541ac6e4424ed410b13b86f781518c2b5be26fa242cbb27e044bf6eda0009f93db764a527ba4dd1f7ab195c477b638fffc1f0df29a8bb8cb8baf01f147fddf9a142033c08ef41ab2cafd954b1d4f569ad1e621dfe6a50af43e83f9832377e1a83675bcf1473aa203679d9cd4877b6b3da38dbf1f7d283d8e352283e71ae85d5913b3a70c0b8e5ec0e6337cae421bed77afadcc336a5d62770275e5531d8e6afda57f458dc72c9aeb1a0102013867b350d3fec31dc12f8a45f0102943cb5d38695f595510c723583f0e7dac24c255b92859c6b559e03789dd6b07ea2a33db7feaadb1245bec9ebe9a8148ef6dd4642fb87699a1214f3b0fa4c585fca39222a8a9e8a62d57545cf1a90a9d6d0cc18544dce5eb972d474cf6c751fb5a22cf08e7841d8e2b76bb38439aa8bb8345a2ec9ae38921263e0f0d9ac6d0270abed2e9ec08df5b37e2137b2f3568a0ad4bdea5c09cc18f0c761825ecd2424bc9562a21226dde9bbb6685a5428449dcde808b59c7afac300814dd75853e6aeb507dc7b81300368cec19ca7832241ecac4fa65ebdc90e5482790369ea6dcc991bcf1ffda1bb00e9c312c3e8921d5835cd7beef0923f1a36f4fce4f7e180608704d515f855e16df97e282732dbcedebc3bf395882ffbdf45f21b0a5738e43aa4d8f06d4c1a06b184431b8163aa5d0010a638a5905e3505e8613a3dd618398e83609d2ea4b17deb70b1517c905de381a0685d43912e335145096a9122cb02e4d81257be08bbd73121cea623c8784ef6baf74bf9789de11d05ecf2330d91ec5ef9af8eb8d36994e873ad0a22f3bdcdbf47e087f9c854e0e24b35e73b200e465f1861d789c818d0f64d5ebbaa7a179464180c2b652f2fa6ecce665b89bd5f2e5859aa3fdd1a6c7e599cb9aa3f34a7b50e4d1de1e7be154df4ce2b97b06b88c1005cb4e46f4a8dcf3e22b494c291a3a580cfe663d027c9528d6dbeb5210d2570cce5b2c65c133d6d861942bdc8c382e05c4c7db9283b799dca1d4b5632747613bbe286f2f28c6afac27c7a9626b53971772688820c35fe02cfe2bf9904e91ffb24458f4a339d6e0521284111d8fe15094f7f0180e4255f7ff4509976bd816172d23b9b5b9db3df5dd038ba2e8784bbe5f23e7bdcc0bb8df06a328e917f5a3dc9297900f4be9dda52b119841a0ca3f809e126b10ca1bdf09debd7ac99ca6da4c25d7d45d8a18d51b678ae73e5db4c05da7c64bdd4ba48c48653cfb4fbdc29de17222eb2c0a9c53be139c4b1e3be514346cf7898307e15279dcc33ebf7fbe079e02b29246792bd26e8951af28e8bb596e767be056164c79c93a2334ce1e13bd0086f59000f9e0789ce4bf9b6ef07981eb7829394b9002ae76041032b0ae41bc494e1f69a4832e467b873503a753b92b544217035e7e44de0adf951b627da7750105124d6f7ba65a607e2bc2c192a2aa1d5d67b5a0caa7e0593cf50e9abd5e2929d9e599d8691417bc96c94e3a09c1287683dc9bfeae2bf8c1860191633e4addc626d4cc31f3341aa84972b235c8681ffdaf83a48336f954054de6cf977e3723f846d485244476728efc2c2ac00a9529e2156295d6fc4d4e4bd9c47f7d69ca8c65cb27ff484f12d134846903943c47b4b79192a352f301f5eac47aee80b53d20ea4d9f888319a74f38b1f81a4d190a8d5cb180f0aba738bc6c8153d08020580385f46d188e53662bc4842f46ea8c223d11137cdeedd9d8135af5396a6bec8d7b933d9511d9d7885f7b6ea450569c12078f845d7713a4accfaf64aed9f597932b75ee785cb5c379c769229ea6c964a5a0351fd94c1d5080d1c0562cbec2d852d73637ed8015c450a5372d6f0cb7a71278c495d285027d0e0dde79e380eaec77d4320d578ebf631ad7faed5315172f4d58300bf2c961aede344e31264dade74ef7cee7a760444f5e7b488aac0fdd8cb012193dae61ba2f33bd34e797077ef3be9b4d97b011fca4b0be8098a59ca184b27ed688ed83a94c52c9fc4f5298ca63cb4acc58b76312e1aeb5df90c3c1d7560a8f8b4dd893ddad3c17e1589d998cd64922b75ce297fc9b11af81b0bdc54e0e11677e0499a041c5b0397f3568ed7616061b0557c858f0fd42065021cccdcfd21900356ddb3143f34c5a831d8d826528cc7694feab0e274e7fa24dd3fb09f06ae831295cb418f965f06a0feaa79276c6fc2d9c6f29d740a7ed827ac60bf11342f33d9471cdfc5a6ab8227d38a5edab2f8699778017d712feb562f1d43e7d118c79ff1df569608691716af38e2ad9cc19ff02c43d1fe1b35bf3b9c3c66dfdb6a059fa8717df9288d46a14effbb17d2c2d8474f815309ea2cf3d22d48b6fa16128a53b0f6f3a463ec44e55a961cd809904119bc54f987a9099da5ae114110df4254663b6fd825194ba7dc812786a73bea22eeb401787ca56ba91e65f8756629b5fdd95d3e93a1d49b516229c64534dd80655f0e8bc19ae9ab5793d35cd389b22e84a65be8465f9a1b5f8ea9d0c0ca8bb93474910bf0c32d5cf7a8d65fc3ac6d0b041587927cc34fe4d58eb5cd5931bff72d62e77fb2603cfabacba1c08d33877584784b7b08cf071b2c70ecdd8331cef3a067f72d35621f0664534f0aedf2e1f90c21adacbfaf5f45ce115c6b7e3a8b469696a89e94aac7f9ed992dce3ceff24f67dbb17bc1437aca2f2f4c802f671e91ec3afbf9c21fc322760765499d270376ce54e8e19825fc99a4283b0459c28ab0ba1f7128a647abea25e86cd700ea274b8e9926a81d74ecd42fc6255369e81470d4ae62d803b6d3a8db694edf5a913fccf5b2faca69ecc54734d40be2253cfaba5f3acd7e959fe49be6a4bb658c81aa2daa560becb951de9953ab78dee045a8c146d3d2e482ecfa44f248ab9645de68600951a29907c14e43480b5df5a4f4c3d5eaa5df28c15dbfb927fae92ba7138f64645a44faecb7c90a7000dff6af0857a9524b46af28489ca8b7f38d71ee62a65f7dccf8c27b0e4a2c31d08d77be6ef136dcd0cbe9b7c2ad9d4dde954c4aba6312558fd1139c798884889d23f50ca976f609be03ec04ebaafe5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
