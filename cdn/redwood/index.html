<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54192c8514aa1c7195e1ea19d207a6349e8577d4e286cc682eb01b59bd2789d87c21f35345377cd4805c8acbeeec47fce31192ce7eee1cd9c24596bacff55f35c4b135548436be7e56c064b7b6e70bc16f2c165f8ad5bfbe7ae834bc5648e32dbcf9da2ff495fdac8a4d2c433b3cc15d856003dcfc6125615d92c66b14e8df6d849232c06844568dc3bf2d363c1a7c7af3937d82d46ba2f0d7f39c04af1c850eb4b722ffe2d9e980585faac1a24d6dabde717600fdce84e3440719dda86c8d149e4798b69af07078422a80878331c1d6cfa6dac0d7faffebe4a44574c68aa2984c17b697db36b3c7e825880bf2427a7f6df10effe618d91d0762c44dbc59e15d7a33082e8c1b5d15aef98b625172db58ce7dd85e371f9f3be16da2f72b581a69a619a664360f67d7446ac0e092a2314d44ce8022ce6ecd1de463e4e97e9509ca65a61f49aef5f6dba21f99c37f58cf45d21d23d824fdc609e371262ded4533f06e8c371a6c1fb60a1cb52770e28ff284117c509eab3b7b732f40bb3fb866a08612935c7bec4eefbd3edc10d0925c77657c86270793f5ca4dfac94e256f86b95639135691336ecdcc7b4191402efa663e5e553297771dad51a46a25ee1a5cdb9e91dec5b8b57a3c4135d50e9047ceefd0e128c09ab3a8ef70283e940dd43a559ecc74d3dd8f9540d50d972bf8fd7572b088c8ab38d72d5b315c635518495b0bb424070cb00d05616cb8cbb7d0fab7b19dfece435807b90e1f9df69098de4ffe68a5da111976afc75fa4421d588973232dd9fb0b7d8fd6535891281d7f2211895c191a6ffdf796d49216fbf7085c413ffe1c8946e960b6f45dba28de483cabca963e4e76be7355198ecd27ff77afb612353c59f3c9ea0ed5c5a3c8298fbcd863cdc80c416ac31e2daa2c2f06fa59a55d254291b945f287b8cad5e0e239749fa00ca2ee4fc8cda26b4fd1aaf099944a57ca9279aa7d4d70b86beef1d67783ecd9065f143a7d244254713859627f17569b46b8a0797eb0cfe0e56937b74a90bf9f26ad2ca5dd9eac7f950e8464294ba133cb72f679856d10a72f84015a0cc5981b9ecbfbb9b6f8b2cedffee5153a5cb918913e15682ba0599498dab99f8a8133240dc52b18f67778dbcf98a3ca66e9b6b9130ba368917a9d00cf4b227a55a248d2c2f43cf34f92c09e05216b2f5bb1a0d9b69a312bc75e08405e43c1b64c20095ebc462681c431bafc0359e3c01673d9cd1a8de114f25f1ddf6451c3f4ac3aca3eee40e62a8af6b39f5ccfb7f88065ff54973cd69a50b93de65977c3fb614896e4f597299527ff18119322e5c12bcc417aed3c1493eb2b019f37de1c797cbfeb50feaa48a9ec7fd59b8028086caeff07e035123e3895803a1572936d5ea3b31d815e84b7d58bab5116d09bc0e9646bf7cb9b7762f9023c6475a25132225a5c3f15f1e98b9865123f02f597868fa7b42d259d675aa80ab556368d81a482e8cfac25fd7b4a31c07111498122c7a27d5e3e2ce9bc8bf3c6d715a93719df272980c25ae7e9a9564febd23630f2ad5e1fa34bb143f9a5b1e223e2e73bbb68ec59f153575fbd04815e6f1641931030e60412d4e8fe800af59f9a4c8e3f81ca00c7193e3242e94ccd926cfe7aba30daafbbfe1d05c7406715f1737d71210f3fe02347b53dbb16013e0fded0956b1261816106f50397fadce63e72c2ea5eea13d1f913b8fe31e459fd10ddad5f9aaf2db1bb2c09793201543a965949ba32e8efaf58a0bca15629c51a852208e938a2363f8131fb55744b3d644f9e0b25d9825bf124abf460b61b8494b6e8b49760615366ecc82355b1309bd95149cdddd2093612ff143aad546a6985887d942fc1501b89af6940dad6e0f43bd63890bb29b247706713ab1099d43555e1d0b2645a7d4a9762d819bd97536632d43f9bf259d3f71bad6a026ffa1775d74d6f78753e58c39730cb00be0d1659db8c30a3aa1f4270651af17148ee5fc068bb96892a1bd402654477ddcbe7758ec4276dbae662edd09c5bfae020e009a95ad7c545b432f9785de0a0a01d677568455d3f8ac0c603736963aa3e29034992eb856cb4104e34e039c773bc237338c2b67f94737f9339587bf43d2b9d9db32b02c3dd0aed73ace21d4e8ffc986806e42e00d091557cabe784ec3dad83cbefb209c58ad4523e6f4e2c2bffe155d020471007727f32b44a7bdbc4ec0f2178f22eef029a9fa4278550d65c09af7ab88b0da2a545eca12c427d2a58c6e4b9d3a2e04a337e4afb42b9ed0cba6f063777154576f53b6480ed60508bce92bc894423148b34513cb62dd64fa58578e7f5b53ce427865cf0c7d16f94bf16655789367c10d607899790c844c707d230aa510909fdcc47bcda80f1b4ec2e1837b4e1f56fc0a43a80240ed2049660cc582b261bc453cd6f3ec8354927b01dac94bc83477f34b0f80aa9c10042932cc5a2fda5c04ec775f04cf7b961193fcfeca8d885f26497ae095b014151b07599f28b57c70c7e6b0b13118231404d647171f26e34884cb4a62775da875662b224f1c7cd63126d64211634c7d959549d202d16f8571bb3ce5a6076255dfc40468d406e4865dc9e7b26210349f8d06e31cab1e1f408743fdc14fb981da26d747c9623d28b756e5687eee9a90de38baaf98c64a85e1948d4e416f53fa7104889fe0548831e2be7c37e3b406976b3bbba25ccd88cb713f3efa59de20d718c313ba31fb3b8c3310f1e472b07de536c54939fd30abf13ba2a3651844224c1a039e4f58dfb4cd400be68f840ba66fad0078b6126cd23e80dfd0c4015eca170655f77a2acae37c5bc78160ce535fc033f1317db149d6d8949cefda57dd6b59fdd87a116fd1ad059f9879c45080ef6060dea9cac0efe62a2156cf7a3302b5a70273f0a96765ac7a56456728f65be18535a03b676d98d0e065144864b954357931a757cb1ff29f2ff6b1a85d17a6a2db24e8972fc22c6361d883a15782faaa0d6029e9ef0459b579657de288810aa1eaac2909abdddba6acd2a7873d40c197e30812517c96633ad36c0fb857967d3f6d7a3bed295f51379f7cc464d8c97bf5a0f2ed07329c7e1f957cdf8937c0a3f3b859337550ff860f14f948a15f8b8cf1547489ace4ae6676d7f69429cefe5269640404c063f81c1735b906c1ff70b68a219f6c4b0c7751fa98584828597649ae0e373b05aaf927ede384029bf3769f789b8c51b793b70b387abdeacdddcb027fa1a2ab5c25d666f82ed25ae6a8cf939dc013add8aff4d9622bf22dae86fc387592cd05a6e83ad90c5076cc0dc9b7e19444776e3499e1d5180e720dfbe441c63f928ea6ebc26d228542fc89559873671be644e0cb07c6994622f18f44ea602f8a832187b621095b1554bc427f1912f039d0ca1e8e53291cb11f437b0d88349127c8b7a3c3f13daba55076bd76c60dd740929ef2a72ce1ffbb0c16a7f91e516891a862ac57701e4581d015ef8205d037338116aeeca79cae3d7a028420f16cdc971071a19d5815c13c0cd5bbce825a3302745563cdabf5ef313c70ffbfa2819307750fe69efaedc6ebf157ac0e5233fd88555da4e987251c767c5866184d4708f284ba346f3fecca89af63511efb8409ccd9306d4700a6b0548079b09f7f68b2a9f37010bf501ddfe4811ce329d19718d3f644bbc39d4b5d2c84331ca2c0117b62b2b1a5d0b200a9dbbe84c65f2375df2b5b3ff04bb6c32828ba84822021ed782c9e368edb522747868c6cb3ec4eefff6ef30a8cf67c14c83c190a04a1623546bd44f43500c5c7434faf2faf455f863fe0be7a26edca8a418d151e48e7f07a54b15b29a3416ed8cbffda28f3a7824a7b5058f703e04da8bdce445211cec4e0ae53052ca4794df95b9529bc795e83dc8c4a7445496fdeb86f3d79a18a70f19a63f5de38a6c5324bb2fe77041eb8e8b038cd46dc4cd4801e6c1d65ffa66e44ed07622a3a85c90edc6aca4d283dd94180c4f96d2bae79d11b706a8b692dbdb00bcc624b2a812997188a9406af538ebda385f8557fc38967ae8631923853933eda66b5a0ae0d230556b45995c403e68e84756749e922e3ea56c4fa699e63492e7201f79fd025e5bd69ba17d3ae8c5beb63af900ceed74d91cfe05233b2f8b0f56f5cc48591b5d90ca22143ea031fa972a6b0d4b166f568ae6104b123bb0d4709df6f11f42beb35952695eec4c31564f1ff86fb9aec10c906aa2c4fc267b854a2bef4c1a7c891850e35fc003f1f84ca6bbc16fa2e14736f6f2f93f3200842b2eba274812111b335fa177f17ee3205ce8ee87ce62dec4f45393e72a5be759012620009389a8c1fb3e8912f0323d1d9723bcc8f29c66232abef2b7904c8786ff93d601aba38320b6b31873e3c28e1027f22a7f2b2b657ae1dff9cdfe7ea77ce1fe0166bd10fd1a1c450fac3c8b54142d6dc994628324a280e05590cb93a243dcd677e008377674734b5fccc97ac2d9009ee3ae8b09ddd7966f94a98191f9b63e4a3f224d4d011d811f632fad5351594dbc796d1d98e45cede3db56375b0c0c009bc28020cdab1eed504d6d0b973f5909ae3ec98984e720bc80f0d2034e52a898b03568a4cb016e265cfe4939dbd6af7a0482eec7914f782343681262aab17f02202a8c490f640029e0c961d4a6138181b05ef4b612eeea4fdb29826659b5eefc295df293e61bd2400416499c9c7a4349f1534d6064141155ef2928f5834046b4ea9280c66d1c3545e2e51bef31d24b4902ce991c32d7f1c9bd399c4c38dfcb6088a16d6ab9587fc519e0325bf82e210fd4becc07414de09a8b26c36397f82209bc9cc2f496f045258a717647a232a0bd882a65d867ff6944625011975ff0ba2fc9c82d2be7a7ef6efdc07c2b5cf67ccece3f970ac38f0c18f21d2c6a835c32a5e3c856e9a1d4f5b9bee3abad810f240f90f535c192dcdac7439842fac24adc816f7ca790478ba6470e24dcad750dffd540e1e2dabe9def4f9e8f0c6ecbb43be7e72ff4394098f01d744b68b9bb8c2213bee5ce1de2cb93f96ec872497c8f5072e03a67237abc301c19f17b391284528ba0423e050d7e332d2b9d416fade6d6bf4a2495f5d5e281b57483949f48d8a28edeb3ae5c94805a84e5ccf84e2e16a2188925b33db21ccd90f0cf33aaebd73ebf8e4c412d6634b422d82fe990b049a0a704ab7d2e68ac23ce5fe587a87e6babef13cdec9c12fa93886962ffa78cb7ab84963b84bfa94d855f4759b56f8e0244d20d9827bf09f285095aa8ad2dd20e7817ea623d088cad696c5b029cf6158f68ed7ea844b047243380f87936c7539a48994412d53dc53a12cd8168599e79bd7e4dcd3f01e8c4c357b1301a903f9d1006bf299c7f18679403e9712b055e1ba5bb5073b153cbea1d8bb6bc9202dc39d14a87f448ac9ee66eaf51b5cdc92020bed332f4a9701ed1fe20079714b2b245d82220e40ad18e638546dced3ec87378c452557712f5c8e82c55c8e2a468acbf92a92f14d90418b083c6abaf1f19937e7f0b65f967df2c73af1dc78c89ee619112cd16480f57e4ddabff674bb8b8d3f1c65f4a232e4b3b8680cb56170477ccf74d9acb3321e8c10b9f986418357b2f2d17beb470c9581db60fc1a7c0f6f7a14c1d6fb429f406955344fbceedcf45d2210da69e1a6e2823d29b782a19e2c22081e0343155d03df1c714a14fc00c59f4fbdf639f3c6ea5fdcf69f75893c689c4b7da102e2a52b99bd0f2ee2ed562a682ea9be3086d02339d63c531ce6284e52e5263040558c592e4d57fe369cf74da86050a3ea9e8e2a918b6ba1fe7962d83f1f59be06e91a7cbd5e610b531a47fad1fcc0e96e8becc0f9f1d9b8d4514305a406277c734999d7b3237f0afe800e82dc7312732d68f8a79969d73f3a7af081369382653c1ae4485cceec2f34560cb01a5dfd8c90f4bff6a3ac009c2b66710a2f420bddd01e052cf960e9e56e32478aedd2d955f6150ff5df53ed6703753712444171195499d3e1b70f6774b4ccfef42770865e11e17f07a7e9c8fea596cf7218acd3bcd889e7964e4ea3a371a9552962bb20707ebce10451bf98060222240271c66a427a00b82f394a1f88a21d52779dd8175dca8b0e261457ef614fd4301c7965d7e257aba439ce0b14c35b4b71d9217827514a8499c1286a86bbb7766b35cfd9a84bd6cd032a1901bcc495d24ca2d2cf9999f192baae1c0cae9cdaa1d10eb7573ec8675bb831892113ccc6f82bfc0c142a5862e094d845fdc45c31660b816e0b89edbe015766049d2530c2c58cdc0c0ec88efeb7308071ee941673e8fa917f00b6526812e86ffde6f72d0cb4cc524f0bcbcd87fcea3649f461bf9f803dc2b092be3949058082e8e3b9dc9f491146d2c659782e045acd0526b3eec1dcf4f701180eb038d37b60ab60c2902d30353089bbd3a2e5ed0092676c8a2b7cbf8a54b78bbff7c7cd6ec1cdc3c09c641917a6b513082a0e0cdab3e12743a5a5411fa97bc114c10ce51aaf8a803d1010c842ebae29461b37ea2fddd8becf4d32c4f17e657809c9d95c41b7ede32259f4ca6ef8b52da32a737fa976e667402df2857cf27859efc8409db2f6f657e47b1e4e81e993974fe365a3c85adcf562f9046da79d78cdab3cc71bc95ee1d1a3257b9a5058bace8cd44212ca961c3c1a89ac762d7cf16385e6c451308fe280f1f6258f034d662f227c3ed9f13431509f6c4a2b30a96bb2f9893daf7a46fd81c93970248e6c9122e7f8264f216aae87188418ef51faf9846a3f171b693b98ff4ec18ab2e6fe0ba777abe7a7625d5f2d9813b57fb83ceab06bc5af83f829bb8a4e50f6ef87a348f38cfc8acf969f38c4fc26ca3b60439e73a3c74c6b1c6fd873045a84e053e790694565b2b4b218641da35dbebfe444e7d158d8430bf59df897d395066cd5681f186aa05725eaca833ef1c8b634a505068df84fe992f71bea2d6e67dc979becf7b003e4e21adb12e5e9fbe379d9d0ad20f21efa9e0e31dd88e422e5c1e9bc64975b86a5992c34aa432de8f90ee0ef483a7f15c8067f6770beeb5fb7084f791f0890c704ded4e1e966b41eab8d0514095191d6c9b912fab7c2cb800f5837ed01c0dad33a80e94f75d2a1585764fc3e90944b873b407654591438c48582d8a45d2085b5ceab8de8fbfffa0df7e3b0606a2f5d1fcddc90b06be6473ad8a72fae52aeb7c13a15129b6ab1a344f30b1f715fb27b5629238ad26ee18c6a23d0a6f5b4878b26f5d3f019f569330a38cbb1b31e04e5b43c4ea3d62d373fbd57bcb0fd6f862d870b4d7dad4bafedc538ec3b573c7d98e8311b59711c3689bc68c5b414e4221b419ae3962d01a4d817e690cabd4220fb9009bcf9f7366516b9d9efa12fe0c67f011b42ce39c290bd8c8da1898e462879e003c2c7b66caf03201cb9e1916b14a32b980bc8535a1f35aaf4425e637dd466262fa58ca7a842944a7fcdd21f4a781a78f1c7d80238222b9dd67e38bf957b6cc75606ec5d713729249fa42a7b792df2c5267a0752f98feb1d41b4852b38bdd2207f5adcff7df2a0a36f20cd21bf22b4c64d4cb1125e644703515754694bc9a281f7acc2ffed12a9b8a52485c77a3577cc6fe4997d281ef0a114208883765f3898d2a478d725a884067688ede4d6c8482fa54f05167cf559c6fd19855f79c948898a3991cfb27c0023eaa2410cda19a5c4f44fd8cd9a4f83e2ddbf58d403c336c54bb186db6bcabd935675ae6adfb1525467fc46db0d97d2633f760708622387864cf1e5c2d213a7d4004f0d6efb7ec924d7daa19045eb95115ab0e263465b5d7bb0649ec4454257a1ea571a3d66768e46cc2d883a2cfafff24dd290287d41ae605b80f4e38a4521cbef93949d616c721b60fccc8276a484d754ee57ffaa7bf2e718b9006558dfe92c7a6b7e9fe6914aea1b2df0c9407091e7d35ff870b4cef9db24b657cdad04fa4c083a4f4e69a6990d87880f1451a270dd388da3ca65aadb0cc9f8539ba277ac489b61e5fc2a60014e47d2a1e1255a6d2d6d819be2915ffd254384b2e30784f67a6f561046098791c046ad0e0ce499ef9d3d577fdb40a5db39bc4482c780790f36cd1436112fdf5e75c194336af273a9f5c5f9e4b95d593c24b829060b3eb980f0b5d3625763cb9e73ef429eff3c80f27f57d36ab2611799c123e42cf4c41ec6c78d5a2fcda054565c0281d4bb0d7fc7f0bfbc66d08fba2ae0b89d71efcf71c090b9d61341b04aee60e30e979478e91261b53b20afecd006dd7ecd237040e5c9ace682293a772eea75a6d7dcb9660399265c56499431d53ee4f51dde2c3a1e8120739aedaf16f8da6ab282bfbaba423d09c55304ebfb8c367a810e5f528e430195889ec1e67703c97fe8227834e9c474f4dabd9eef35753b0e52f687c59fc95f885a8a2206655ae2528ca60ba6fe3af54c19993b1fecc747f218e251874b9e0d502e5b1da2da5d510a18ee3ba2160066e8377b6a9a2920d0a58967406343eefccedb4d8427e01031c6a9b0812fa86f386674085fa6b83ab3bf6b0a67f97a73fd7486fd58c06d7a70df377cde01873cf84693225b6b8bfbf99e1c95ce6f98cf123ca2590c86618e271c34ca1882137537dd152017858efb9d2d3a2fd1e4d5edc9b6eb46137a4a68899539b57992312343a39853c0b472963a5e3f506d67d95b03037f8436347e433267f83af07b8f412977c5c57d5434b9a8dc0fbb769210a1cd93f8387fa744c114452f90c2065e37ec6e02fedd2939f2bb0a4f09f152860928626fbdaee34bf3fd6f55796d306bee6a4c9d30a2818ea302d83fb08f77b04f32bf0c931a95a8fc5a3b5c1f9eb91cb43b30394620545b4d3bcadac1abf0e49b5d73cbd6ec96910665d599a52333fcaa593b73834fea4365657022d889b0309d0c0b2dfa0ef6bf7a8ca3180fe795d0aab92cc2ab4e4ace71f03e753b2006baa618d75b4252fe8024216b0cbbe66e37f5e95f121e74359837935becf034270c99153542a93f0fcafbbd0f3f4ee8eca4f2a26c3983243bcf60c60c145b8f7a533c9672046021b51399573d8050cb1a93767f942ad4a7bad2540f7845e03fab33f3438813aea2ff00778ff233d5ec9ae063e4aebd4daa144066474562493449bc4e01c4f45052cc190a8b9096d0cbe7ed9db8f3d70014002de8fc00b1bbc4d058b20417cbae73da7bfb8bd9d0286527731faedb1f595303d9b0ab9949c7091919bf8b6208369b1fc0aaa1fa584368d4f8ecd7e50c0fa11143cbfb39311700fdb8718bfcf6274b77cba8cd536758f751bca4c2d5ddf142837c20dabf5860361486889c3a991ef284534f80d0f76e4b42a4dd94a6d13fa105df72bc880bc36d19d41e46452a475f89396e214d22195609ede8929bfa9d32727511ea9379d68fadca9d5787361cca5645d190a47c201342a949df11ace4ea7bf4b7daca3d721877eea6ef6b4f5a2708468eb49603ee4a3abd9cc3e12748df3bee43365f5f8ace73c905375de197b0f21af086524c80a53872ed07864aca2472980c09193698d5dd2a73d6cb6ea891075019edbee3f5e4946bf6cc3996247218dda871154074e326cf9fc1e2cb813bc628962d8d6e12d3c980c99ef7d1781b11a896be49491945b129a666b987bcb70b803d5b5a92922f712a37ed20eb157ca96aab914af08558ee2be2758b314a18bdebc6d3a895d298d644d6d7cd9432b3edba6323ac5d64ac0962d12e8b41b1deaf025950972f45621fe24e3c5e71241cbb6380c462a113392fb5053e0d746d61f0ef82404f8e2524e327cf01cbcc5f27d95b945f2bbbaac31dc57a9471aa82470a31d398a3ef92008c5847856a00c844632b106268da2ee5f797e29281c206d061356c2c0ab65efc789c332817e9f96e4d0415b742f850bbdf29188836518e51fa9b16043eae20a371e1500b6600bb5a0693088b826ebca6141167fde070c9f87392273c70fec724533ddea25cb1ab7b2d9695723778009282a96c2d2b2bf9acdf4753b7f3c46d8993e90e21c0685b81f6072ca7dd5bfcae602e6a89ea6acea879605224ef04041ca5103a5c5aeac32363e58f1a9aefe477bb66b820d1df0f7f5416e5a0d0a20b2e706b9bf17d442dd4c014030a5ced8397c38cc2327fe545958c6aa026ba10b0154a06f102ac1f9160d6aa8b9e81dd94c508f64b97051c7788acab9430d79f97e8697e4817750fd0197f62a5d65d4c0e9555e3f0578cf0d482ed74cf8c50c95e3621df1c64699ef0470319270912bdcbde73804e9dbb0ac9ef82c89920ec4eb82bbca0433d250f2762e00e9e82c589a4ddeec861345e54bda946ade6514979ba3a2bc5c782c396ea985b11f6422270a3008ff8a5591eb0a154f974d2fda91415e497a854a7b4d362500ccb9ef23035b5b04fb5d618140ae466d0b572c99730b0363de0d1c2f213a8935f7bcde72878354a654d10008a8055f07f775ec1c719d723922217c9074ae7dac05e16b7095cf6b62806645f3e30a116c93993328e6d65c505a42ce44ed53040b2f5861ed77d8894a68827ce89e8003139933d42584ed9d5fce112c1812b1aff5ef1511db0b7bbe3b5c7fa22ef3166be155fc0b2cd10eee64e1dd1dc45d0291ebe2788df32b54c8627b20abd7808e11157cd3f57c0d747817c92f050df32609fda5d60a27a89ae9ece1aebb5b2b843a5a549baa51185c1f5697317427211b064b878a844876c74503beeabd39fcfcf365b08b98e25462424e2bff25b4b74c7793d9546b6ddf9edf9815b486d9111de24cc024b5551c1148ed95cb7b26b4a87cfe09ffae81ceca295905ceeeb3c4b1a5470de0dd34260cdcbb73c8a830a9265452963d60c8089b7fde23b4f161209988d46fa84e5714b06631a948ff2b217c234a11c4823e261e5d3d8801240e4ddc9fa666d387dcc21a93c081ec526b9895ea2125a1ce1dc76654365f850977eee68dc4de23d24a737df37f22b2acbb37e159e2e5211eab013f3d12abb2b000a95b8cd410cc674489695cd6a928ae1606fdd6a2c0f75cc719493f0c6e69b9ce40fe3ac5284ba2fec338d3007d8da293165466307a43b4e0d3f44618753c56b2a99f30ecf03066548cce338a2eb4c891012bac50375f8a469c390d1387bd84fdc8e6db14767aaed162d187c850c6448ec1616301425236a04441b219a74247ede0823ad46a9815150b28b4b064b525ecfcd8dce646c0318189a457598c56ac0146013d0031af216d75bf5f54c40c30f442b9fbbcf661320dfdf0f8261aef1672fd41bdb6882044e99ef591bb2747bfde3ebda46747b8fb16affd620481015da65af9511c74a1b96f2ea4a721781fe1b2a643cf5ffcb91477044074a4d11bc1fd0a21b84b0e2c51dedd7254f7490425ad138182b961e8bdd000a3229e9f1c750bf7407ae2e3eeb728e0ac5dcdb5001583ba3de2f77a9066f3b66bb1201f1c90b4677f447e442545abc08920851baf94f6db99dc9477ed7e60a1c3dc850e3737cfe3261e0ca47d45da4b0c9e7fcaa4bf7e4cc45e6a96dff282d73fd4dc6d62da0a9ab34f5d909638aac236669f950754b8acef2293b99460fcb100a3d6976207d57e9aeb987f730104b31418b6c2cae94acddf7975b3266646094f0c4efd46fee6fb152206012fae6fefd016a3b0429a0a652141e66a3ddf90aea14692c7e6ba88cfa7587c09a1cc77d5fe60e55cc7f20db99e00c22338e049e92677c356e58e0e055369c7df0d080657e12261928c7ebe0e685d244a3c82f008fa4305a527a8ed6149a13483475c30217bf9a483e361b780ee7eb2ca4f1c9d16778501976c2eaea634d174c76b2f3f113795988836ed39792916298bd6561ba363589eecf8bbf55447d02d09a6ebfdc7d0c6c6f5d031da9354816fa954e6463f4c88b7f6fc8860ada2e5230928ccf6e5de7135246c327da4c739b9c977f0365da273ef974ed32977a96fd0da513780ce3ad78b7ef3e5d6422e856ed0182b29ca19a6af026ab841c061fbac4a7309f2c45da51382d0c656ed6501b9330d4e17eca5856b82243c4d379a712f365f26211615799cad95f3d45750cc547415cd1e085113477b41bcf675b201bd952944d4ef848eb8cc04abb8746f0e7d7592c3868ffe9b3751b1d42d329571ba99debb1775575198dbb2914729ec925260bcd6842a7afa6905fe3e0f33258fd3a054cb731aecc7f72d0dae372595fa8d67c4399ddd9bdf6626779c65d751ee36725cfbf9425013f9da551a623419e3c86556a577e89932ba6c25537dc16a985a0b8f9d273988ccf03dc675d9ee1840a4cfd289d173d925af0ae3b88082019b27c79e2f269d4daccd3ed8f2b69c94b8b8797b3e2cb7434490628402727c84e45667dc2cccd174306aa669366eea155d7d671fa237a9f371293aea9eb2d48fc68073cbf6c4f781eafa651fb766de5c4f4bdd704f993529d430e2c8cc3e810bd660ddd4a0b0c036da4bbf0673363f003089e85a1ea9c182d3f029b147c8b7690a2ac03cc09d127300e4b9cff5484b7419617739e73ef1ff674ed658a87fa6665a2af6b97f0245faaacef34e41751827211bf60a107dae02892bfb79d97068e8cd58df9d3790afed64868ed577b69b631c79799a00bd0855c3b5d3df4346d188fbc7e961fc43ae56429d28987939a90f18ef5e920e36bdf6bde97751717fa225e3f1b8cbb2b9e1291ed40ee40d4ba8368bdb5d1837f879731736309446a9a173cfa5130cb72143971f371e6ab2222ab11cee95143c49ed2467cde5802c140a380be94393ee826278a74de4935962e4575d8fb0e8521a99ed215ef31cfb66833c5fb2aa364c6ae01d28438f37cb3ecee79f632491435748237bcd61d5b27c0bbc95afe2d3b177445f5abb90b93ff9f545728cbae1b9dd68d9fe93b44840651894a7a334acf4ec726d7223ab6af9cd7b9b426ac2a2936b2e36b087e9854fd89bd2c8512d63596eb4e03e1c371b90a750df8a0b0f1cb7b0ceb92406f123909d72e0f178078edbea9e06490509da390dc4f4a162334efbaef2ba5463cc45a48efed56bb9d9b7be0c58a394b52ad3a48379bbcb1f37f2a9c971b74e07263a6e8d7d3d9ecadcfb2428af829f15fd918132b68eadc649bb2a669ab701ea65551f0f38d9aa5f6b9c1d4de89ba5f19b1002a958ec1d66fa9b20bed99ee720e74fcb51e8dfbbd9ddbe396b54842e487168d24e6607f4c9a8dd53dea5d85debd6a02d3e1b955dd975ac2a87a623f9d32dc78eb12abf3a411c3464a3367185aa6f66ae72c5365704063c1ce43883fbc8b0cf2cec1caf5a0d144b09e2c5a320233f5ce5ee54898de8ee89305b7438c21e7eeaf98c2e253ac88228d83acf250f704578b942c093cb894e076179592c307308cc7ca43b9f636e696194bbeab10920d3fe616011989745d3c67f003ae7a0e4fcfa86f3f69412c9ac76e6a48d0235dff0c80b0edb8e3512d74e88744526606ea7ecb0426423e6b3c5b76654b322fb67f2557b03c9802b91eb9da1b3f18879d5bfd8835b8157287300be221885276f32227e2c4a2ea393da9556ffb62c6256206560b824c884401cd67d46a16801affefa3e6514e31976881319269fe43088c5554e7746b59bfa52be8dc68881c5f6ce76a8d9491b09920be6e284007581e2e714b405017038ca7133a204c548c1f55dae9253a5d90cb6aac87616ee7443d29e9151f626631fe7815cde307c7d82fdfbc88c7fd2bd6a5e118864430cf14231aa4b5fd5986bedafee7943772ad8e4b8a2e740422585517019767755bedab907c359fe3ea7c78b49da49e08d380699017607dada7a4cd0da3b4cdbaa850f55ecd9ac37a7b1d45d55b56e4ad7c1efd525e7bb2a5f0d72405c87337ebfe66c3e0ce42308a5975c4ddda1b6ec35f58d51e260fd71d6e22205e166c5fd65419800e751bc7bf280c607c93d455c1f9be2aa9d4bed033a2b5060891c88a6c3b26a3cc68c3651ce2044956de7263d96cb423246cde3ae7d49658e08a2bc9ef226861c402c38a8cbdc6176819e3101eb21f87a5e7d14a1ab77b65d2a80e50c6f04dd9e610b9cca800dd980691f5de40660babc2535b78978abe4bbd8a3ab417cefe9f47a3fb58b54b8fb6865297875fbfea54eb51fa6b9080623ec9b524aa3c88437823ac8e14561b7e3c78ed9ba7c5c3b6d5211f336f7b79a41459c7183ae79ada8a66b62e7f9171fc5d3b1c560e102587c61ae21710d057c9bad95fa4526625a81e468a13dd0d00677952b94e38cb7f85ed52ea627273d5192700b1bf3be73de6c71df788ad05a87c5608e96ce5519ca59400e4f9d4ac02fd186038ed7af40af5ee0d30c92df69d3e997b4d3a3fc8883d451e9abe725ef417458c5225d8cd0c41fc81149105ba1fa80abd5cb5045b3c058615da27a7ad07c4840e896fb48528bd33195750b2d6c3e647424d61aeab2163734e894a3843848a51e57bbdc2c08685efbe087f13a68cd9bfe1ddb3ce732d58ae2ad9dff0298665245bad7ff3f4e2a3ce26f3ce4f0f662b501b5c6d8f94c1cde5c97a6412ac8ad6df521c99e287ac1f37467a6ce45b882511085c5ceeb8cc7028c090189e1538b5c6ebeacebf2f334a6df3749d0cf4615d3039a07d5d4548a516ba5aa8b1b57a473d7a7a0e0ad33f7bf8e8ac0df986f8514d68ba1bc4f58a758458f36022c724ed084d4a8765f2c790681652ac046095778ffd5578bd264ea27ea7b76078fb7199f8c2bfe1e9b1d563a30e4ab692eb9fdbd794640d877a18096f7b30a72421feccfa95e7f78db7ec6a30b38542c08a1ed9e872d43af81341032eccad5620ca9495c62bd4442de894638f3a168f6c2dcbc42c73c46fd11c0035acf07e795e8b25ebb4e287fbdb9a118c4d41d5fbe0cc909300a30a67a1793c6cf9b8fbc6a1f24f5661d61668341f12dc21fa2153e743afde715de23b6154c21117bb36c9d6ff02092089dd3a2aa1df38bb6da00045acf7810d370de97513d5a94eae25309c2d1452d99c171c01eae8486e454de8f7461539d1bf376bab2322f11dd6d6369517c48264b16384e1d1e1732823e237a14043ed960c3caa764e4bf02482de0ca76ad840faf776b2dd813883e3b0a52aa2269966cc1c38cd17d9369a75b069844e8283f1384f8b919a3d5edaabc2d973befb1318e17c2412da55e255af66952dc23dbad56ed16d3bc4c7f167c3157905c7999d5cacb5b6f87c6c3f698f9b7f1fd73086e23b04a242adca0c3b0faf9a07571fa41827c11b4a98484a3b00dd17278a7a92fadc01ef9766d0ed15e82477cb17bb0b28fe6d2d97ca53198ac3b7cd19632ddeba9e7cf55aa807ad9f69db1eefa4b522e7f6f81256d6fd27e488c5be0d52b4c8a978ad7c39d446b153dd23e84fab7ecb5164e9f42af6da755083b9ea843cbf17a728ad99c32e9a5f459425d825348d5750dc0706d7902b3abcce68950e9be4d22415f727d60e9bba6c97ba1c16c5529a4495b1180785275176dae89398ca2b1f3fe98c5a6b4e33b525ca1782446c0ca4a4413c3a6e37e01c4611e1dbcb4e6b423ddec0932aefb4af12eb8038864a2fa14e7f645b83c94bd98bce58d02ae3fb6969a9e731e8d8d760c2831ac6c265b0ef87d3c56cb7e83863971689b4e2a7ece66662d2c7b50592390e80f045155438bf1ac644ff5735593622953dd058e7de5d396f8ec9ec544fa085a1fa440b3a6654761402858e5f41e39a270fe430136744faf9e31d7fa5ab9fe2ce4918176a473f0397e3786fe4bfde845b98ebfeaf687c3b7f01d9baf014994e6d38273388c77f74fe5e8ec441107e00edba6bdea6c5d32ef212b74cd3ab6b493fab533a1550667ce9bb6b6564c2a9a69433e7d5f1911238ff03fc83067228acd6a9861eee71cd981fc1405fc0078abd2f0f2523c5ad9da0b6e01b99349eaec3953503c4dba08bd67275a311efdd7ffb1da4e2d244278e24e70b8563c7c67d7e7298e78ba47e7b74996c2025e5ebc48dc6a274d28210a380de709c6597316837a325b7e1d8dfffaa500dd835263e8415c56cfc488b24793265400a8db403731c8db63eabb85aa1c7b85190df4438bb1809fe059bde96835dd86de8b6ee61ce87202f1ab56bb29a25aa4338976bd9b718860c8da5f93a23b8218b97eaf16cb9f43e64d5ecaef75654d23cc0a314d1b114df34fe06b53fabf39776682fb52b694349c698a38048e82294a167f107c665bb42f43a676b4ffa9151415681b61cb34802a73ac945de9aca0ac3ce309474d8494e0f144d6f06047f82830f13284c9e2ac03a387e75e2729586f91cb340271cd8de353fa3fd5e52a150e317263b687ee8fbf4ff67a7da630e6fdaa617e797afee7550f5521ebceae72d1d4ab0a890176cc91061cdade1e3c039ed5cf18f8617d475c5d95c9e90793b7c29be5d6945317acb8edae3c731c936906018412b9c35a379efa9f28f5748814b872faef3b37a102c6a8a2aadef4003008af8000645d3c7bf66bce192274330ff3edd1fdad47f56730e7950613837e41812d583d15f6fd6a92e9706652602d50b99ae56d547d3e48aae7e01e9842adcb32cd855b25ebe9747bd789cffecd80fc81074dddf7d75eb0a30b801ffe3dd5553cd11dc6887712ebc04a44d4d508f5300d6e12784292d3c24b8afd48b376105e51f11577f9a8d4a5ad3f1e1c268954d8ddbc2aa19b3cf4c8ccf7f1ca1681c2f623ff3f4ac7a8944f688c34644a9202d34acfa2d19c98c18815a54768d70cab6dac02b56c6c315d5112fdb602a3faf6c95aed185780c62f7ef18020781c2dc9049008c69b1a7771a67b43dbea2314150b85b9b26be4fe1dfe53b352295b8b87a53e362f3354c73a575b4a9db3caf4977f2812ca9c25447cfee68a2b6bf79b89d042ca9eb04e9c8e1d54d5e0a2c29a779df8a56d89c2bba0f47ca7729215bf58208e91f17464611a44b0a586e7cfe76bac6fbc5fc455fa75fd1a988c983c68a5b9eb50b8b13bc75428670d1382c4ee69f9d42369d2a913ad7f3586f599d076cafdf34dbbaa7be6302ee10c0150c5e58564396536bf4f7229faeaa1ae1f81bde7af48c33d8d92e6073657488f0919662bdee8766a0cdd1cac1a9227b4ae77138631b02e2ca5e980ddbd82833bf89b5a65e8b7f9a69819b4f764d58b47ec42f35c0dbfc458c0d8a35cb6fb8720d3b7441e0ae685c59649f3f3a01006d8c2b93b6cd98aeeed4cf6bac8195706f777d8696d5acaac449b97d1bcacbcd22864ad0a7ae947070c8cb01603b1eca3bb0bfa2c987ece9f6523472b4ff8309860f953e7bff02855e1146de5ef1ee997cd9fdc17163cd763509f7807769719207dc59f52d9428a08f657224c86b9cc1d9ae122f06d996427b28883befee967395741bec3095b0632ce4ee75d311baf3725aae3f77b60f85aabc45bc7bb4554ac57e510e8bff9567b77ddd2a336eb8cb4cf0ce27096a5e54f6ec51bf36a186b545ced791ed8f8b7a583cfa707f415c1309b9de564663943c5d48f9bce95fe60255c5638df18dd0b497cb29fd43e9e9ef7c1241b3a2332dcbdbacf4d05d94794d232f4870bd6267b1b9cf172ed542008c9bb8a2bd95748225e18c0ae781cfcc89023186c271bf288ffb5cfb903b9cc3d7a6dae796fcb83d10d334ed53e7be7b04286627678cbe2a8c5bcd507e67a2d20dc0f488ad856ea529f22e32c68eb79a1ae459822e1f1a1848eed21bda45b5f306217686bfd46fb4a9b7c007ebabb2a778d17853ae673474298d5b3ba7401cc2c3567787e330f475abaa11387eaf5ea6250ddf5322241261d6ac9df21f7fb8abb6848c701ce0bc0271caad594d727d33affee95221f93748dfd08da65220a500efa4d8c641abc61e6e2370d5424c0773eee36513465a9fc319687793706c5dea95d06c88f572ae2fc75cecdf08c7a37f8b9941b81dacbeabae584babcba4834a8858a941ee7df7f09ade13d479f987353675b76f4580d1349c7e991bb6de2b91b7e6e2b61a5e1d2e273b6d58fcbff5c999b0ece40c4a70af55dcc97972edede660d48de076bd08bcfdab86ba2699a45fd69","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
