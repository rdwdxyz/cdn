<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"982b87685cb4b97bece4b0df0efd34c29378c49179cbd3cc355b7a2c8346d288682b55a290cb7451f962c4afae8027ec5718828be11014c12ece8df6f9dd83a67877e88600c8c152ff96792b742f8d32095cdf27cd319bb7bf56fbacf885836ea00a39dac0be81382a174c9bae1a4d48b3945fd865a78d2996c486f2bc36a7109bc371850db1de8eff17d1bb40f7b6ae97fc463e1adf0de76fe813e7d5c820415518ec0340533a885c8136e456837aeeff1c8fd1dfc8d7c7de17c577ffb55d471b5cf5b51165c4badcb708e886ec798677524aef649ee2a24aae5ef438c04c90503578da8a047c709808b5e6c269049c612a82d3e1e4a2ac20c3b6a5db58e481791893017e56fe708154d00e7d18b8c6b619846f46b29ba9b384a6f2e8ece36b703118fa87dde834d935c6094b450287c862860f2c365d9e263fccc6a30f91db0702c2d26dd8b60d0028f86d89f257e8cfb517cbb308bcbdcdbd8aa2a80dd62739cf676cf196f1927b02aade947a84b2c2b96a542eb7f09fbffc0d453ff151f421f1af025c7aa07b34a610af071daa482b3b3b03f3f9d7f35fac577befc35271700c3bfe5a7267d240aaac3fa47d5f3cba3d92d425e4404e36be6f033d74ee06293f1966c349ece8cd2403e57ec889dbd01ae47285c86f9f9f1feb7f1674349eedc319723607afb44bc7389fb1b3ebd9de470cd500f3664ecac58940302d53f6b8da52876ebf6e1263c2eec753b3dfb4724f8b4288d715d8de9acb2e64aeb4c11068099b1fa44a563d0e06b806a7c76256464970f7911ae0816ee8119ce28e2798e09a8f9a10ed40532dcbb67981ff156943f33732f2dc93279585276a60e5a4ba8d593c048bba7a55ce62dea2ac7099673db8877e2dd922d7896cd0a0ac131bd7720140d1d0c66640c5292408d43f52f68457c63b89e81c7fea63db5c29c4f3e2c66416160f48e61566a9709eb48d5293469a4949fc373ecccfbacb0498baa7896d066265df028a9d455507d4e97fabd0f4fccaed1f24832bcc3b1fd15966f143ade2496a9efc8b01249efd6eb13b014b904e09d807503ba411428369c1820ad6f6d9a631e579c4d0f73af1e82a55f671942e865a2e4d6e634d196601daae2969a4ccb98a084238a4194822541eb4e2c748f00c22b1d197dc4116cd0eba07e56d833eae7c8263b9bf6538e9831306f5fa0476dc04d5b826187e9f570017ad3af4e205bad7d324bd5cc4ecf035f2ed6b1108872f698f4c23486e026679ca4012c3bb348d0ff7ace5634ff90e835a763870a6f41e742ce83e31d2910ad3140fdf19926f73698da93ff3b43ef551f1d734c30063060764b112eb2821bb1bedf6c5c6feacdcfe5b27f3359b77a80d24c12ab927dc3f8f2199af48345e77d1c2f8a1c578f38a2032c17e50f41f953248ea024b0d0166ad02c6ac9eac4cf9a75694a176754a92d2fb1623ef896162a9e2c598b89cd702ec8b59382da2ddbcff82d79aa18a6881d18f51e8cbe58d0ec48e4f4f1bd58a18173902964cdbb5baee4dfdd35cb59106732fdf99ab9afb45b9c706b7ba752b777331931ca47294b379371469ff941dbedf4580bac0f7ef0c098fd0d3ff2791c912bd200f0c38c4a18bfd5541805c06f0fe80eae3e99d004a96426f1d7f871c5f71d4401f05a10166f3da9311f3aac48047ae822d222893038b6613f3d21ac0049e6c3ab11af522f8644fc117ff180f97e3fbd2e4b9d68b021920662a7d68476b0883afa024f474d7f573edda0cdab660e8cb87364a296424667fb0b5425961002fab6820941b3bafee2cf06b2edd0a7eca79ccbcf28aad40a2f49ff2e46afeab332a8eced7edb1646d662f911d97ee816fac2b20f9ed41e5031cd7bfff79db106f50cbb2f630b0468fd5ff1fa05823d863b444e766c26cf5b69828f5f1f8435ea96293166773f5cc1b8b148e912f8256a928786ed1ceea8d26e9fdfac760a042888750947a26d2994f7d5620d725488584733e3a37dd3c7dd7dbdf888274906ef7cda571ea24e896d4717ebe5fba3baa7f644bfe5bd5913b775309c929213900cacd413d6928f0cb26bc0c0b1ca205b48668c8dc50cbc2470c9816157fc0f99d6307201c99fca00a9a61746ec9bbc6b168de23bff0ca20fe3c2d11e0afb1f64ceec21601e895521cc996dc71a0d77abf1fc56785805a8b304b76cf88b4adc6887630f84a93c467743f9cb7b289131db4d2a253a5347605726019b27fa9d664c83cc4ab2780b40a510c0d4d5860a28931f834d4babbc54cfb6cacdda8c448e2b86d30a79f6c25223f157875f3da770b1404e88df03a3fb754b45358ccdf60453030672419ce50fc5b6d80332c5623e1400fb8a21b58f9ae556cb0a6d8988fde901ba20395583fcddf0626837f6d0b4985fe928951e717e40b1518948d1bb767bb8e2cfc4bca5968f70a039d4e95e41eca1b4fab8823ec93662616aa68f8b28cbd16875a8b4f7f5acb4c87e50b793bcc07bf3781064257a7795ec2f48ab7e186783fa0211d26715f0150450e8510082272af308576e16eaf439290826007a391a18c3bb743768ebf5a7f86c5dd4273c88059b3282fa8bcac1323801b9ab008830867a9cde8d68c99eaa93057bb27d41f4ad5f5b0fac739b0d79d846717cd8c5333a53538ee32ec1a510509133fe23538cf9de88d7ff04492acb4f7465bd462507ece595282498ee06839123fa98740ed81d161091305ff17bdc654614b8179b8f05329253ed0a624016cecf49e22ffff2b413eb5749eda7a4b90e7e6f121761dc74d7a40af16f4f9af6aef925efcbb6ba2b6a76bee81ae5bbf21bf31313249b5b9ad34def7ec16656cffa53089608d2b5bea96968030a94c63789a854120acb4f883bfe0cb61962504a08e421bcaf2ad086f2fd18dafdaf99eb8e5d49a8e5dcab6dd5149b2a6906c7ce35f54c4b9cc87e99682f83205997ce2ea8886e1d339d533ca9fee78356138def3501b8a14bcd3d1e761b9bb5d9de140f333e3ea150adfa1d8db83f57df7e01cd5569b0ed4491e69ae3d1470ba4ffe2bf0328caffa10ccc23e5baf40aaedc3935a25f9efe3991d99257cd9fa2dcfc9baddd1fbf0fe33e9d1d115bb41ab37329d807f15155ef183caac27365f3e8f56af433fe2053003dc91aa8c345121ba36704f223bd7d9f24282e2242c6df9c3c92ba028cd54216bc465c721118da9e6a38677843ba73c255ca8145662611a0f5fa04e9eb83352caf7909cb8c56d6c9a399e8caf09da77d336bfbddef575c90585dd5bb13f0cff2f83675c08028e8ffddd62a52af55108fcf7f25ba9fc3c21f11f6dac000842e8e968adb7cb4df905865b2c98efbcef524210479329d34fcfdc72b72c775ba2bafc97444f218c05309074064afa1f1f8363743e9452b6dd5653971b0251bfdbca98fbeb54d5402fcc27bc1c3e898f350387979db29442646e6341a7d50f783c501e5f814b12d58ed6e445d657a42f2612d1aef103726e207e869280ea22f777646c4a25be37767089dc6f4b1bdc6f41ce3f394e0344d91294f6f36ec93373b1d41b8a8b4039109ef7af84e80b07a4696e621c700813b51cff0662713c2c4aae040cf18af2ea19a28b964f81c1fc8be9133a42781fa627c8f2be03d988bf7009435d29ea07bf98d19edda5a4c2dd66527ba383c98a47479c9564e0830800d325027c401a61fd0be24282ab8c10c5fd6d2dd969d6539b17c24867750f0128aaad9ac6c5705715dee732e80a74e8f9f0cd8bce7e91fb43cb937a7eaf6d186634d97e88e6f75dc1991acb90c7a680a31980b796127d4708a75935f4762add7819c60219f657f83b24f6a29bcc49e515aa89c8f1513a7b4aae58dd2fa2d385232a6be87bc2d4c1cea4173569d6812ae48a0e5d2c6d6d2998cfbcbc03e3bd61acdb1607ab05259614731eb876d6e62698ccb3620de204bf3e9068d41ef792243f5129f6de76509f1d4d21e7ecf82e172d8799b5497f400ef767fb937873c9d3601cffdf8b884a4355b026167de90a43edfeda976522673adcb951cf0df845c87a27ac43f8fbcc889d544dde08a361ccdd30b9980b6f0f944d1a5da612a85a2ea285ca6841f4dac9b99d27d68d5f40646b8806472897913d2168f36cd26bb4a55f9f2a01c6e5baac462123e3e410780db8e34e46414904e0ee11815fffbab3cd354811cb615e4dfea3fc6592046c8e6f19c678a7c2a9ceaa4fe002037e492b856078f2bd7e4cf15f495e293664c5c61ac928016315064d5b8e896f964250437424690b0a22163c1c131a48954c40c2f6113a110b717c22da5c7ebbc153876b90f9d17dc126bcbde077cba8eedacaf35b5a317009db14fd0ea3287a62da0713c93ba770673aa45bbc805449a9339abad9210504835beaca1b01a6689cff80d8b51ffa85e1849ae7c4df8d1e8d383c9670998ecd25cd7a91fd43ae719eac142f874b9cab5aae6e4023d2df6820be2a5b4313d79dbee8643eac3394947a46128e3ddfa736ded52eaee12733baf82dbc70e9c2457f6f7c951953aac79eaf9cd98a03e144815ed42e14a8fcbaa66c93bd7f119e5fdd9efce1d1b1f136c78496b6d190d9361ab98b13cd209dc6010e1e1e65adf5601e238a31e4c258d6283766d6473654d94c69a035677cfe1d94e1a08921f5e375b4f024efd2add50d73482f76bb494b92606fb93d7ea129eccbf9031ac579d969541d1da225a4679b6d659a7bf5a6c195dc81dd145215f4d1986882958f6be8a11c8670bea44fc418c456ac34ea7c7a5279e829dc5bcd4b06d1204ec94ff23ff0fbade0b0aedde102c241c0115c723199c968381d3f201100ed5f2868bfb8aa2cc78fb46d34d864e585ef0b52f4ff275b25cedcb0b14d307b9b7bacddcd1de13c168319e8e0be6ee0417ebb82bcd73db7ca613e01ddda5abf3234f9c5f2f0afd728bba80ff708d57ac3b38894279dcffe484b2ce53ed701dae6cb659db621eacd8495f6ea4576a49c29afeb727ed17b250c2c0be064a2be3ad222fd9fb7cba51b92392f5de29bfc26012dfadda6fd91e4a1d169249b2bd82f2364698e4cb1af721903f731ff36ab98314f22272c932f4a9af41c1ced0623ea52ccef2531e91cf4f8061706f9f2738db7c65d3ced917f06b8f383e5066e4461e55afc8cbe5f08db0f13c700ba84bd30699b9d4fcfdcf6e139699a099a3f8eced0785cdb4ca7f2d32b0e6f6d64bdff94d42ae2d3f9db3d3005d12eb86992048f510aa3b8c6291ace1f91c6ba07fc0fa1260d88c2dbed9179952210ef0112d4932c0ea2d8b846f2b0191a8d023a95a684934a92f1d636383747dac783736bf1845cfd8b6aa0f825bfae133fd3c1a029a2ffd3855679582b8772f0af4dc4048fd579498eb802c1029313be30f2ec88e86056a441408aac0073220c5b94be71107bf40049bc3567e5f46ed87f31d21aa691bf0487e8823661ef1567a0529cd2ce38d9b6d0db8822a8683331fad115939e3ec8d2a68413a5567f976a1cea49cf79f6ad25b85c52bd24f3de3aee98ff167b7676e485cab2d281b3fba314c90ba75cfb30ed99b03af01ae9e2c36a328ce081fb94028c71d2e96b6e7caa741115dec38c1d908d80f9632624f72f3bbecb177f8336daf2d0752358e956533972fb37c67535fa632ee072bc488484244f8aa8fb139a299c6bf2ef1fbfaef4b049f0308d123ea3779a8df2c226037f29abda893484cabc7570c3e88d0e053306c7b74a9efb8af51ced5e6b99e71d4fd95bd3d08522c616fe02aa8dd69ee19bf064dcd22a8ffeb2201bea34a1e03032a606c851cfeb2b505c055b784f6b458929043ed249e463bc4732b3ba47769cb20b1fd7ef2d4e80793de2d0bc3af40ce9146ee4438fcceb82b751c32edf47e0581ac9bb57cd4b85177032699f4154bb16583dbb274202cc818c46bb317984b22e8fba5ac76526722ce1fbefe0b3d7e8a79571ecb2dd65643fa8dd422b07cafa7070cddb6ae02306a311bc585fa90390dd3391cc7984626ea7a31f8638333d8eae59732f8a028c1f8e3483a02d1ca1ccedf25ecb0ed845ae4daf70a3fd4316d82f02e1e508973a141d9ac73853d1432eddde259ee184e9190df51c233fe1eb52ae51167c0f55436dfd0e65667495c75a4784b18123cd37c6b00e0722055e19a7eceb8c4542ac8785fd08af4b96e16a115c761c26b72e7a21c3833e7a52c0b860ead0fc1d79dfc66080219d7bdc4bf77e7e32e6ae736f749c11d83a6667b497117c332b8761378da9b0e27f8ed0343bed366d50c9209ea945ec02917247988aed7fde2d6a728566f964d160a29141b8b7ec37342db847660bca0a0901c9f059b7875b082d594222f3244b3d289fd295b7964abc7a9a3a9d444ee16487e9d712c9110ddd0817abc25ee5da9a51e92ea203d8848ae5422669cbacfc7a5f7efc24ca16eb33c36cdd579991b288e89c771adc58a91627e09c3b2e8440590ceb59775820dc4c88e2ba83eac24e385483a4f4d1132fc7ab7aeebcea7e3e0185800f98768518397df66b15566c9eea8a225efd004fb4af707f78c047b5665e39d36d5ee60b4e608f3d64005db9e45e14b132b2b92ebf48cb31e9cd30e29204d43b920099043b933b83663fca4f24156fc48568ac32ff69dc2b5c9601b5792c64958958a03e11f3159d7982266a094ca58e25e66cc83a2ef1ff5c56db30962b1059c4bd2a3af717a6e0b813e3f904b67955edf54ce302f46f1e0102cd9ea3e6c9d9ecdd509c3c73b546311f84b653238bc36f80cab6420e0c8daf94e38101fb51fc6963c658a0cc3f8103e028456c16c53152ed3a4c530bd45b666780ea17c8a1d718d8ba99f5607eaba7ee70972f5f5571c9d3975ba0260b1088bcb4ca187cca651b3596b09c124a3587c115a5f6930a6e8a84bf397fe0e1ba92f499752a8492ace2747c490c8eaac6ab9fe02f9363b1be426c2b921fa992f8924dcec10dae5acedf97788f03a23451dbf69008d5b03394cf766fd1da2bbf5f15bb716c0c55b4e87a1952b06afe08a0ce9ebcbc26e4e4ff83be6dfd54ce5e153269ff638aa3018eaa84fd587f8c4dbe7b768eacd273c708bd33901f5ee0d89e29c7bcc06fac64b1e28864464281b7eb2121957817239130b30cee314daa1d3a3d1df78d3d7a77280cd15139410a28e24a4e305ae8602fecada6c1e5f378be47afc581f40f3b6ba77a371e881e078023b57f8dd1b063531b3be3d1a36a1b1357f360184ae359264a58b8f1d160e97b37df609826c19f84bb23983f8f6f44053e8dd7f031f7a70a596949d24d981a53de6b89e8685eb9a85e8239c1696ee7d78550253f9f385fc3b641409e51211eda5fb641316e42e1cfb110cb1ee6a128cfe871442eb6d7d18982b0530029ff7a721e05d4b59f0918bb23b13d89686ae5abdd850e225c793e3478336df38eaf85a54ad68474bff518dd54f037f524c801dea40567da575ec39378ede2fe401233c6e769de934a64841bbff5cf514918bb45f4d3fef58a079f4aaae704bde5ab263e45c997116ab6c0152f792070a5e54a0b72f64166fdfab8b70d58b08acd793670d677a51b524e7e58bed36e38cfbb622bfdef51bde097fea121827b18c659c005f25e1e48e950090644b391290411be68a7baa496a58c41504256694e9c1e31b6d2ea5e626f423bfcbdaf4066e3a64c30f8a850405b4ff66dd538ef2da507f6a53f4e3af288e5a7820ca729eb0b07879923a25dba8ea313a3a5bb1b4c36d991e8fc4ee509c3751b6c338343bcfeddac59b29c85c431caf5a51c63a2aeb43064be8d65d661a5e186ba3d0dfed0e760ffb19be9bee3290fbd37b9717273ab8a12d3b86135a9e406036e896644a2d30d4cf9878e84364d109b21f5095ec7e7970a2a16fcbd94f15904d0c35e740d47209f250a3823730862069c2e8140cac7a51553c405e1665aa043d99845efedaea6764be0a808a6f8cd98c39281dd8d01558db905925e6fc1f03a1bcaf4a1bfd3b4ce2d750d8aedd0e808cddbd4cbe2cc28b63aed20e29254a14900d396ba75802d75194d4bf4582b931b2be40671169888e655d845b4ab367d9cc571266d9e7ad6545eac918f269aa0e0fb71b42c1f5bf19e9f39c4d5ffec76e3463bc5a606e1df610e9d51b8ad748010de074d1d8e2e4dec1d993a843fac38f472037fec143bf8a986b56e66dbab354455bbc3e87954ca0ff1c60880d62e824b841fb76407b28fa14508c5532975afd28e2a33cf2e230d4656d9951e281d7b381e8ea164abdde0ad2c593a21299a4e227ca771049461eed0f6cf55492faa6b8996cb532b198ccf29c0240e9a056aa597c653078e7c5aae30ba7ba46e646e1a31ecc9fe9aafdbcf1f1cb9585912b6564808cdebdba4fa0daa4c7931c582db059553744005aa89a8f59962e8ebd31f771305fe7d4d3065dede9c2fd8a47146b5a016088393f3065415c1b431f7b72ab184f8db921329ea18f3db324764b14acf0561d893d56c50afa23aebe5f3d34d985fe07e939718e53ad32f63c0122f6c092f196ee089501bd2fdf39fa3e390585a7b6eda7c1fbe6972040e0cc8f3126a03bf646d2d3e237f8e98ca490a9b97dfa765ec4c9a88af369629d8e63f72d666da9925f1bc819635dba6d6bef9f325313b4b7956ff1707a4627c7f444b626c8b9c2de323bb2da487a36d09652c7ef4039289e32effa79aa34cf45d7ba6399d9295224935b119579c2b55084f40f1243d4103b7decef40fe9923e2c18b06bf8e34f52c7d7c3fde1bba4e18b320988d0b7fed8559cc3a83e0775df605b6b70ff997f88bf9a68c7e8ba366ea668a127290781021ca97c6676f9295b4d480faec718f986911725bbaaff155d24e953a52147279128749b2838b44370028ece8ffff99927b47b6a4860c254c8e893cc95235e8f5a2352fb66bf3c38f7d4ac96d34e1cf5b35965bfb78a4e73de58efb69637c5cfba3129eb2ac8e80885d2264f07e8f08cc20793a4410916888d83508ab0a362fc19a50814a5b05906860429508f7c36d70f54bbf017e9b1c183872632e19f610f957cbc32c455e6e56c0e32b8748f979fede9b9453d8a62734e331cd81f6ac825a14f6cc99d93082421027cf2c650146b42d9235ba123d8d3dc7d771b8768be6b327848f579b7a325f216b312d574a593d12f85f75b2332fbdd1d6f10a7c9c27f52ff1cb4882bb7326364e69423c3195b2c68548e83d6cc53556cfc3abc7d26b21c1a65db986d2d6689cac1bcce32290497326f8b2c4b3e30d244ab09220613a02e6764221c9eb360ecc14bef90755f3d23bc1dabfde4880379871f4a082c72ad68e8a4cfa08d5b7d3cc01286a54f6f9e56bc368e77972145e6f8bc478f701556cdf07272149d3c2d7382d0166b9ee5ef021875d5d9e96d6401efb1591e1008959a43ef850a65358aff0009b9ecd48f6924fd0e1ffba15d8929c0f0b9491b5ba8502ab0ca45b9a4ce4d7bc4432551818084fff2e98b5f6922a9800eb565ef600fc7a05e637bee6dda15035033159cb25893874d41fe10419ca31b2e8ef6ffc8dcfff2ece66bfbf04ab36f3d9edf5e6f68fcd2a212c90cafbbd53baf4c0ecfaf2b654d5688dce0db27efb56f2e2283aadb4fca19b8656b4a3084a514d2e7f1fc111a437e234834bb70905072784eef51e71cf2aa605982c24b55704ed8ebe8fd1c0ecc031392469f67accd72a67c11096cd5bb3660869f1d80c82e5f7b9fe130f4d8316a0e54d139122ed2bd0366cb8b80f4bad353d1f816f934ced8e3022d9234f5864e556c972bbb1d95565e6dd733cbce36862551700fc2471dd7930c9e31aaba85173f8651780afc69e12621ccaaff5e684b0fcd8e3d5f77b48edbe0876f8139372e09841493b234c3a07e5a54e40545166863b12c69b3d354f02a0f9e2ca54e319d142faaf53bf856633e2c7d8f174ec4e7687417e5a174a6dacd2ee7f99e9aad217985caa64128bde6c35921f72f64ff8b7a2dab25c1524a6d10ffc06fe4a68a64157144e221ab286e1c6759c3c82fb4df24c83d25b7582d817d2f45fca695292b6e08abee0c29611a0e4008de2f85e67feaa2b750989ddaba241bdc9613ba7af1150ef3f558fd1cc1a44be1dd5a5036e50c19f169dffb0090c70900b6135d917bd03290a6327fdade14134d088ae09381be16f581153eb3b4163496fd439fa535501797f234eb37bc1d663dad2cdfc1335664837407b317b5a2c98de1e253f8bc8e0a09ea47f9266dada6e1d6e9b33ed21160845bc08e2ec928473c7647d6a28b02564926147adb5e4c2aee5b908d21991e91bf4bdf29b06b143f097b83a804e52f99db943547face020954c45c4b4d8d1d6443bf9d39044dfe73b0e0259bb9d6a707075e165462c22f4a55b749dd62a47c419300eb5475c474f6098d29e41baca8ecb16bc2552b22d62474114cfb14fe9623693cabac468a9e1cacfaab1d04305d60d93a0d8253d9ecea99d7288eb96845aa0405b1b69fbd2eb45d6ba5d67fc94be9fb6f6b77c3ba806cffc104fe1786d1b29c0ad4517298c1cd68dc3b5870521ced0417aa2b756b41243544806507aa3824c2786a9ef215030f429847a01d781584e89a63c94354fb6795bd5fbf2d842d4621a8e13e06edd9f52f0169df054acfd9544f290465f1f091876ca93f571dac095f1ae470c6ef71b02cc095ac95655be81f3fa5adc6eb1cd1ea72f85a1a3884a7daf81566c2024ee7e3db419844e8b76bd501066e6a6dce07d66a1b0ac036dca68ffe1517bf8171b57ca5a12a5b0948b667713ba40fbd20761886322073123fa8259e15d23e2fb57c1d3e9133254a8eb3fb70d84ef10c05dc20c2ad6bf22f050d193b6ac257023193e52fd77565c6216a650c13bd0e89e8937d02d75ce611ca886660993f4b7ed4234ce19f84749bbb905122a52b798d4a708da50a54d8afef267a48e4567dc7c7c699b10117434cc7137820bf3193f07825d9c51b1a056a1c03ce370fc14cb4381a3517b7eef904c02c895f48627b17dbc82fc3844559da0a06a1b580a51f71648ec167ca30b3334ea8b83882ca8f4ba873e86b9f877df5b2debd3d27a2c08748ef58731f3948ff2aa82f054aac97cd43a6f9c4b93b0ce98948439910720b410ccf984f0880041c213458a3dca27aaae519ed5075a8d18d5033da633f7463e355e3c3f931e7637d34523bfcc02871099af389193976f405d55f65323db928c221385a73a02ac9dc645f4fde53334a8b1ac09f3d8cc4cc07651368027fbd06fc66a7ca8e7f0e15e73735ac3a0b04248dcb2e3f1051d458f1b83c3fbb21cc3c03f255b7581496b3c7d06fff47acfcd2c296bfdaaa5f02f31f48a654f30362b59ff10b7f30efbef1a7502649f7cd250f39b8808057287e79b0e1cf8c669fa1c7d58f9bad333fe006aadc8789ada5ab0a5dd807950dbe0dea9807c4367e2bbac2a8bbafdca5b040c8e1ea4a83603254d3758acaf058ee5764a9938a36b457f1382b5fed4c988bfb38495d04b53bd5dfaf4351afc1e31622faf4b8d2ca85075d51e5aef92feebb942c00274d5838813a611071515ef5626909dfae631239dd5d48b8ad75a9990bd68e49e335ddbb6d9b779e9f582a2cda7c632e1e0a1b40d3399b16ad448ce81522cf5df8c4ea81502c4db1b32c9dab97b860196b54b385dda6d55439fc554cec42a5d45616f003c3f1fa8b1d56498110ff9589e63b2de08ad51ec8f126f65a06575800c997a286feb8606fc501ac9051c0329fb2b344d55d5e0c176f3b332dfad8ca98cb36a77f320020fe21944164e0604d5b5d021c436b49d7b459b72a701448203d6a61881554dbd0d15eb310a1a857e1b5795a1cb4f19a322902acd8011ff25b62470cd30003b3cc49d764a8a0a92806b75f6dc11499950b2cfef22e908b3ee0702d183347fdec097d4b4a79fba0d7e14163b6092b264846b22384db015532b0697f8300cf6ff1d36bd7b51983c15df3c69c1398e9c3bd502c94cd9e89d0c0fe889604e29c8cedd5640fb55101f6051583ea2f6cdd1dedc5187b22290a5fde8cfdc561db55d2efd1e090cf2de273b4ac8fe959ab218600cf48fc7b12fe5959d295452a508bdbb7ca0f416d58ad955d7b1ee9588e6d92beab675ba034482798e74886920cc428bfb46589079474e47e23a4ff73d2a99d11a002366402499d7801e3ee3bab121b5ab8887e313003bb9f5ca32366e83c1de227cbac690146d99811164db19c0fd55ddc500bc0bb09dbd7c3b195fe71c030829e61cd824e9bbb08a76a662a16d0edb738ed914a22d1e7f2e9bad557c8c4fcef77cd60c08797c7bb12aa93c54e8d0b63f3c859ffee93a6bf4e7242b2d56c7f4b4a0698a986c06ceb402d3290df44f44155f3ec9913a1eb03afee8721bd323037e0ed99aaac401f7fcbe08ecdee8ae1a58436dc71f11fb798d066266a0c291a5f26486f78cec3d809987242c67f0322257165ac9e104867eb72fb9820c43ac2dff85bfcdd8be7c87054ce4c891515d5a58984496852d6f5b81a842d55d2a11e12f6522463a6bf38fdac6f2d03dd1824fb0c3274d2df71d62d4299d9a2554c07ff3d413c71fa1781ecc9a77aa3f432fcbaa486234788578bf7bee43f5d42fbd9ea5d740d8c8e5d0a901e2f359c3ff008d5ca8cabf2e1fc8978568803c526e6377ad4468ad4a42670472c9ab4d75bd43e14cbb777d6881f7eabe5ef46ef9a41d42f4aebb82f8b608147dab8e875c3075fa27b4b89c6f5805699f13581931bd41b7fc7918d3f6e5235fd5ca98debe750ba7bbd02b95dc4174ef21c12b691099ea9ccac8ae7579ad9272e606e7b6fb7771c0d7b1819039f993598bc908170d49ad720e43b7ab8ee6533e12f74c6ebec651684a49bc0ab0c4754105ebf9cee92c58458a2fbcdc6e74479c70ce23695d6cd0f299e675e745bf47b6ec8950fbec480cb7a5a0180130e60ef611424dd061a26b9a39a5de554983a890001b6ea8cead79cb06cd2ea6b70c579b3eb031973eccdd9d57d5fd2091ed16f03868e4699189c2a727de8d411ad166de281d38f61580bb95f309e1c722675dc52fc4d9fc4fc58c7f406aa4811ea3c63b5b33f09ca52fb4ea3dfdfd659ad571ec83abe1b2981ecb9eefabc03709419804d9b9c563a2ec02315635d1148d6df259cc18f59c6e6b509c0a4bf11d0ec2184fef5ccb6a29a01e5be52018a90468f4f8ef53bccb95f6d64fb027e4497fd4b3ccfb0537b49ebbb57ff3452074ae718853c2d56418ed7bb41d42aff6e462cf6dac2d8cfb3329f6357a46b3c7a446199b43624cb7e1cbbb4795bc0409106b9f53dfe0d096d3b4fa9d395610e697d0ad1630770c0b764ae6fba7b54b22ebdd971e1fcbdaeabb1b86d8d35da2edc4560d73ee1cf4003f7a5b7960882180f32ca7e350cc88e8a549e8fff7221a2b90acb3333c4097e94cd5251f973a350f560d6887ebbfd3a3deebb98a8223bd6a2d77d588ae21974938d7061e04564f65696f11dc120f8cbae11de92fdff190e67f58f0852f03a7c961e598ba8537f0fbccd34e63b26580a1298898d93ff1dc4aeca920aceae15a33044facc12cc329b9704823a82f842da95bb492ae946e523d05254e878e2733d4f6e6f100f1c276ebf0ff52c634277545d97b76829758c001911970e294c6382280d4d2f40ec4efe78c74ec30319a398412061bc9c78e035f021cd557b05d75e7496833658a78426c2f6188a9b64f12ec43b8aca06919a041d520d23550c5fbbbfb5bc37464036e01e1b42261a3d8105465232d20e6069a8d9e94584e9b05e89992fdab85aa13a10ffff6da1074272f9a36d009c1e5d845b1664324aeb1aa24f35e7486545de7780c33ada1e6ca122528aeda6efaa7b1ab95def5e1211087256ab9af73f90050b3feee6de097797e56deb71c72ad1dc24e98a13e1eb6ea58817ca1ace8e349d511503ed62152c94644db75c7ac0f54b9fe66397572ca7d134d111834430c04414b09bcc0d7964b294e501064c188c1add16b50fe1add413bc2919689448770fb86b33e8c033b40cda923d009542385adef68f33b9b281942c71400ace533efb6923fa0aa567d07c7d747ef7f78cdef6bfbdb610f2221eda515883fa7f5a5cf20125b5f794bdcd166363eb1f7f7d1e64c092344ecb9b873e70981d1c219a130f2417e947c768bbf65147979eeedb32f48b5982476744072b0f17872a6c996949c61519e1248988fac5b67f1284825c0d1cb40df072378ffe5fea46a5c88d16b7eff8e5b2b400cdd4072a4ade7a379de38ed013fb2a0125c05ea7631973eb55a4606e170e1de2baaf8b6df093266d8edeb97b3d22c5f0ed43a434571a3cf0f07e0ad50f6d6d5bbc7487163b25a9096ac59dc2568cac24c9a51d44094a73c867514cc177322c5cf2a5f53b7df6103ddddf765347c4102a341f184547e7c13682193794c645d7889e3b5d6592e63eb1b187bc0ebc406e786a656542cfee9f5e2ed73db1c70038a42963e6731ee39926b8293a9911b36a721104e2fa6105be446b59a2d8c544ad432737cd3ccd154fc8e842686014a5a926939e7cb10132bf50a8417575190f4dc15ff5a68a5591651e08468d9ed442d4d601a098d42ac6d325fdf1c440844ecfb8dc69d3778c7149d31c46b21f504d498408c4ce820f437583f6e914f0445d271305ce2f7f60534f566c71ab25157f2ea3946af20bf650de30c279d7dc03aa5b46566812f7ea50dea2dbbc63269a8b32479be7d8ef1d7f936b76c7bedd803200044ebb740c14ee285ceacbd303383548fb2a685bd1a3ca4499eb124fb71a2c0b43075861ecb553ff4efea041f1cedb11a52b082569bda223076a563ed5876a01cfef4bb46a1c06d1622c73906d4130bfbb16f3ee9c648cea4f6ef9bef7684333b98fc58a14c824709825d41e2130ddb13e82a09c50afa2105e96611de3c0d81d20eb8966f1b331f788103f44c116e83ab3397749db78fb33b17de803582fbf5d2a855d4b6bd75714894c6382892e6114381ff38150238a0048e53c78ce68dea1145df97dd9f681007499817798215fa5aa030d9494706f12f31cc6cebca13d51f0a168a808661db7337ed3cfc309a6b874f23c53cd3caaaeeeef12acb20dab7db484310038942d3d3ff50db2e37e802e37df58e17f9152e750751ffe99b3b38c09a3df94ec083aef712a2566a9f6f56b0d48afe41ccd487248203f5dde7b6cefba583439184d992e9e49230e4390e2e79328b42dfa47de9ebd6ec2689fbf2f73274f5eaef66c9155556ee1c4440051227b30dc587eedb60f0500c1d7ab77c6901642018fe99c6330c34d6c96d662f162afc9a986d1bf5e5972bfba807864e3be7e972407a4e80e68406025075a355dc47cfd71a77aeb461819573397fbb0354b5a820b0883f3ce530951f11eabad4f465bc5cca80a60168fecbb952ec6b826d52495626615cb9d43983670e93d5360b8767ea1cc167e1654b082e76830d6aae52cd1c13a185860f5b147822eeed316fc424999d505ff4420a501c4696eead9d2113aa909a4329adbf6262cf38675130bb20c7b827288ac5a66568f3a0aee4bd5c52ce1bad7299470094bba2ad6d21f96f06eec2dd1b21e0590cdeb89b031353bd9c2de06a1dae4338f176fd184ebcb70783369a7299938e4e62f24041592d3c4ba5c72fb393f73837878835eecdd2e056c09a0773b84dda4026119887ebc729020827905f34949b6414c6d4d1e0b81e7bc15ed9c1e3ae100c722db9553d8b0c491fe466e9c70d1e82ffc4ae93a668e17557b55d8a954235646190d3a9099ded72cf3857e90236740f5077048deeff3c59d8bcaff02225076351a043e235b0ca2e63f7b9ec381b429ed9f7b17ac1c5db743170b775f11a2a211e42d50a4ef657a9789d7ed2c3f95b0f8884f1c195e3c6fd2571624a19f97a720e42fdd038c8c1173adb97060594f02b9cb32456e4885e9eb98df6c00c0458a5bfbf66c403bbaf71da04e58b6362afaa30c45e33666fef5b8429d83e8c84252d5181b0c2b8742bb0e86d0d03728f740ea6cb62bb47afff0b3ba888b3f503b86fc2f4d27611a600caf6c46728c27b8e81a4a8881796efdcc42bc083334fcbeba071984e5398a5c4fdf0ddac295d23cd5649000156adc899870d0ee27abb796c1f9ff4608dad2f8f31b63edda15de45232f780151e7071c3c02aeec7a9cdbce958ce2879ed8cdc13100398b264fd8b2162b9620017fd54f64b7c0d74f5b6a06baf94a34292eb02c750dda44506a5e3696d688dfbb145197358480169010e8567df9eb0d6b9834d911844623de9a245f316088746bfa3d66be138810e437fba31751d9224776fc67ddb4f2129b9620bae771ce14bcdf400deaa9e8636b1f078a335952448bc59a1b1b573ccfd2f364e23b9b798e8b83e628078f54a3042cafa8580898fce91cf4fead95b383d738099e3a29242a0ee2109e5549015c93a4457ecb0dcbbcc9a9f608c9456240cdbd25d6eef916903f07249880d481aa7fff7b0627b0c083d9939825a607cf19380e41373026e195dbf134d4c916e1179e6faf95e367e093b1da95d1f8892214c4f6bf76b75e566fef753d18d8928643fd96061df1a0a2b4ce16b2844aac4b334265dcdb464f74c6abc7fc7ab6ad09ea242909ecf168042df1b10d7165b7c34c30a363e3e05a641f40784d7eea3d0d0a6c5e43f733d5367ce4c4d2bbf2e355fc7a1324a9adb4d3bc70379323bda76f989710bcf7b672ecda7b9581f0c6fbbf6d9120a46f65d5523827df974562d25a9d1fdb3b53305fddce89fde1a6b5db3132d26363f1c5b52ccac407826d791d426f79367a2b2360c07d1a83b32e794136771c48c18b877d37c5a8c159ef11bc0b1db6637952ea07933d92c7d1d730a9cff6909817c878c9e444816f91c37751d00f748f4e5feca4ef171562cf8777cff988c7c9bd3088478ce1f3d64be7cbbf8219f2e071ad4fa7f0256cebbd7fcc52221ab81cc34f7e31159df1e7f0ca2e8a2e15a27fc0dbde21fa247900e1b1411ad4fa278994c73c651fcdd7053926eb4a19db1a1f1f38548f4ae91dbd6e05c408864017f6c5966a1691dcc9928faabaebfe1c2c1fb85d7eb043e38c2d37db0895e0bbc3b2b0d60946f5992d35c434a10a6c0c57aef5ccf2a0d5207b4c0ddb96568d958b4ba4add08155c4cd674885f718fa5569e35ceba72d52c461f6674dc294d1ed634cf116b99ca0f8b3e4c7ac294dae38a7c03ae0a9f739568b6481a7ccc13e27dcd0c2daa7127b0961ae6d16874802e33303e9ef94a2902ce4b2e90e57dfe8c3e6403e95df01988f4b34772fdd2fc36f19e05640c1ff1b26f7cf8bfc44837b6d55ddb438617f6052704923f5cd956449e27c0003049a613b3643feb5736aab6007b9fb34b56fab869e193374f6c516b5b7be51e226f346e0f7bc5a2560f48268798a59c5ce4da4754c62d775abc5e776e5c7e5292b0e64dbebc6530d6ac010ac93d3b39f9e692c2ebeac28023320e44077bcf494d78d7f3809d30b20db9b3798f68e9708ecb1d90b13e5a23e9c5d48d4436dbd56e69e14e186787444296a5b914f6eb5eff84057ffdfd1b35911202f45c01a2816ca3262bc5122bb1db785876b7bb31eac8d53271881b600761e95073d09872a5ea7b86e1443ca013abf19ffa4a00d8242094ef401fc341aeb8407aea88d17f09f63d8fb9768e3b09f3d629055af380ef94f46a2c57b893d5df59024434b3d82352795fc0f1ede4b93d80b600bd8f7125657dc015a9b64b88a14fe9e04e2fab4a57be37ad7297d31927e0f8885feb2e2201a26965271849c3d959d996d079bccec498af3217164f8641b89eee67ada99212af813057ca0cacbcbc9096f47ed9978eca8fc1fbedcfc601d1099bb6cace6bda99480dc3220d6fb693a5b3300b410e0d6c2770f59db24270da52cc3cb522e6b31cd7d591abf9edfb4b02d1bcd52379c767ca68f8f8f0e85fcbd5fde46335a3cbb934a15c6b21df79832d2726cb7f721387d66d2ce966f1cfa7bb1efc1812f6401","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
