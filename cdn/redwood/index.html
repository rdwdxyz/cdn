<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f60e814e5d599910fb10f4357c80775534e84a60fac84fdf320606e980e0e8534713dc3f4db6297c38616e5480b446c092ca044965a6d85b7d606b7d1858bad7c4b7420a4d8e8f3b3054853be546a0faa5f41e5663f7e6929bba09526aa22928c8795a684c1013513f8fb73b71335f8a723c1b92e99d43762fe68736fc5bbc79744f8e2a967220167af9aca3df295f553f338f58a00564b9d9f5823b10c9689a79e8c3dc9025c7d083d33fb4965d365db9c3055f58817b3d996fb6326cbe8237697edec83e61fd8cf30d9feb02efa3e1dbc538e74520756ae55130447da69062276121eaabbac3253b4b697a9fb16a0b9b92c8f2fedea9461bb34b53d99072d95d654f56d39c68334c0409967055c5cc07ab623e0779b1a8c3edd391b36542dd3cb90ab41b436f58b2fec55be685fe03c0c8febad45d7876f698923d3229c6a52420eb4a523c8e5fe036771068e3a8d6a1657c2b20d3daa209880fd4598f83209ac1bf9e6cb1e0f1dae011a3204aa5cb85400da9e5dab3b54df4e23a25a7f011a7a8e0ebff4fe73b42e14b6bc429a1c6d03bb3ba8e8c9d2e5dd2ce3a72f6579894b7baae8440186b5859283dea402f914f2fd32b0ea54813fdc8a6ffdcb4262a029529ad51bebb862a95f19597c9dcf6d04fc77e5ac83af5dcf715218bf8f58441ded379b26e3e4e4ac3ca7340b82fb909b49f9b0709789d55df7b1a2c2f9ae6e608a1e427b8dd495839cb45e7f4f9521d9e1948e421d5b1797de5cc49e4c79e0955782eeca5c78c9df01bcd473e60129e0d98ddb9ecca8ab83c65fc831fd0541e693cfed00628ff5cc705c269da5baf9a420f5a466bb296413d9f4b60c530106fcb8d75bd3647453f5dd21cd385c2fa04670021f6e2fecfbc8a087808becf0771f5784daf4614d37642290221321108d83c350208e7b141504221fbef66dd4efeba5701bfbdeb68270c1235c2c55e47b3c85b4eb65da00c14d8bf8bcdd5e9f71f0116daa0d21941846227b786be3822731a0fee0c9ba910ce7aec9354047dc15a7ef0521ce6b1a8532d25ae7040d713c43ca451d2dfe85b73b3f0eb9de7c4e1c57c3f6850c51243eb6d1a16028c76259596369c8b88dab525195d0790a403047f9ed2220e4f0cb0742393d4436d42e0eb59565c8bff80da66abe2fa50d3a7c7a6fc3323214c9f618634e8038788d8084ef29c34786dc6c5f4a882535878179bac5de1203d492790f709b84517db79ddd49b8cdd3a29428e65a4cb1afab7775fe0b155eac1b5df023918ffdcd9eed5bf1ef80c0d9d27b35a93b12b7796d1ae71249e1d7b806eff2a49b0f304a305d7bebf5b3c174067761301fdf21c8a18d33428b90a8de7a111e3e1aacd4d6dbb9be2befaff8d701f9adbc48c546d2f093f28f2eeaf89e39d9853742f0a152dd0ea5ae1bf90c94bc2ca8840cdbf8b674be901233e1c0dc901b04d011e911ece06bfa7e0a10d72da98c78e0789785b26237b2f727eee5e6fe0a927cb25cd1d6e912671336b2170e6ba163e034af5c2440b0326786a61e375bbafc86cc0b51cf44a509d390381ba9f8b58ad1e67a6981cfd02e14398bd513bd3fbb10828253f563d54aadcea8fc84350851f83dd2c037b5e64a4a561e42122a35b6f9683209be9ff193d4dc082863d2e0eace1e057c0ae4d431664a8ac1cdf04aef7460bd364ff005d2c7e69b635cbcff0edd385fb8871060f81f8c72891d0deb179d57b0a0960fa31014105a9645f04c36a842e4a93c9442f1d1d3cf5ce785f0ad1fff9f72af2974ac431e8b6730bfcbad9102dfb0099a9e1b847b04f39f054afaa331a4b10767ff281084bbf54f6873c134f5f20bffe7fa2d3a3b98a2840a697ad1f770e4538612a175a9e4f5aad5ede2da5fd1e8733a404e101ebb67b817372132ecabadc403824d0163fc89f0cab8292e6459c5b0a6d97e34b32dfc3875ba45756ed679c395d02cf4178878a2baa1dfbd5839d5cede04186f16aacd681f165bbcb7e1c735ff3412599d1b59f97303be307e81577efcbd8cbad63d2afa3f8b2033007814b76de2864cdbec0911f8332a9c4ff170870df04a07771ef9d880e138472a47cf2edc9c89a61ca0fff904ea06d99cc6ef994f5f9d9e0daafa8f7b44fa5097f7ebf1b50c3613f4b92f97d15ccc563550fcdb5e4eeb75ad29cc8d9d48b20014f8f09d2d89b94b877663d4d410be26560adcc38215dda9d03320c195e48bdc504e35461dee30c907a1eff880d66f3f598015c3a921ce037cece8b8834fb2c1b45e5455c820c4d536a7484715a8906082d87e92bb704214a8fc509d4728734530c297ed13e8e4713b020e3705a7b1fd55bca93f1401e722b7d756720b4da304aa6ca65523b7b15c8d9ea2e6c8bf30771e37f5804e09b7a9bafc41040f857da460dff9d54eb48dd3820d0f148018e0199568e3cb52300eae5c4319e3dd8d70b6ddb249f2779d97f63da5430a1fd774592d4e681880f3f7267c0596071d0a80ac1eef312b0ae438e24199ff17c3f542391ba4a9238cca3ff25958a7d0feef6b3626be0e79579ec2d667c324f98459110a673f27b27ff148781656d9a45023a3b96fcf3fa5d52dedadfdb9bcae5e7934be3c0be4e462698037ecfbec8b49dd4a61821b7f8ea7cd0c0e4ca2e1146c411db62246045140d456a2e00f76b6d6864338e7cde6a2722c9c66094faa2aefa6557531054787bd4ff70f7570793c960693f9b24c9ecb7bdc841b65f2de85385ba4fc2fe6c2e693468324f903d4ea52d758cd7e75ee6bf3d283b500b936a68db85d5699316105a8dc32d0958d32ed88be8b6ed3978cdf3c173b781ad2f9732110e1f9caf3b3777ec45a160b1bf7c112c4b3780ed02d35dc652f08b4c53f4124a6a2090ddafebdac6aaaa68979f9e7ec560087870621512be0237c85e37f3ff1bd2a1ef487fe81109e47a0a5838b72582bc30a0ed3a6be2cd99834f56f7fa995d8b816eba5cf2c625f089ca2c44f50aeff063f1ff458bc2879c1726b0729247a5142c8e24d38e32614defdec0d9ecc62a4cbcdfc85b4b4e53ad8b3c16e46cd01f6499780e6a459bc8f1d74c8f6af3601e7fbf8a9c9b35e8ce9305c59265667cab25958a65c74a95efb6db6ba2bc99f3740656abc76ce86c21f6d3d45b545ef24fb1c24ba3bb2ea15643833d75223f0a7bb008279c8561813c47bab4539f25af0a13cdb697f9408a0a04e0a33ff1fa112d56b8ed283f8a31f6cb36c0c4e55ea51bd6731538b13c2e4daa72a697d917f064a3daa16feb5b7e287f086a9ce2923da3d5040c71ff9f90e42eb295e0e2858eab7456e3701e28c6f5d8e73713754d2bef7c56184f2e24270a09719c3e02fd650a43f03e4a6813130a2f10e91a1be6ea98ba55e60735900154a6adcc8356c317372f0d7fb5eeec26a5160e6c236b0f3e8e5db7401f06a7d1943823a447a3549a96b81e81db99f8f3b94471511692cac6b13410127e70b92199e88740da2248b39465bcac06d51c755202c7e69d6b9f3eeaf531dff8360557dd445c4b48eca060bfc5416301cf25221b154beeafa30f15501de713dd401a1c3b6be8c0c10960e1b2a8b238799773fb081127102ddd7eae7156b10b9515ca70f48d050ecf7527475eff02d9a5611fa5c8c279a135794fab7ef83ab550f38a4911a3c321937394cdb2b7ba0ff90d814b2b471bbbe5f5260f2846b4f0559a5e9e77cecce598c54303472298a38a656a837103bd9145dfafac42008e527e9c83c4137b239bc0dae96b6cfbe6e49d6da8178040fd73cc8771479f54f471525e5655d5ba162d4303cb0c04c1e89095d38380fc9c6ecd1d60bcc9d4cfd9c01d5685b5f1f2ce10dc73f2382f91f626bdbac870a6d2b033e0237fe133df25e575ba1f5722ff88a1d7afa4a51f702d670c4a7351a321ab7c19c246dc37c3058f442a0ff13b06b76d1da2c74b8baae280a56f78df259a4a94f707dc3f9766265b1ebd231df331d84f6888b22af6edfe0ccf54ed3bce20cb7b27458a33aa3c989dc8d3ba10c40546740e220701416db4edd336ea5762b357b50ac93d6f9ad0379f9618b29d7240a016ff7b2139fada4f1bbf267f86081d44f876956dfa0afc3704e2e2150a0a48e6fda18702a4ef165206a47b318aa22f87ba243e96bbb600d53f2ba75644c517933ab5b5236f3300873e8eeca99405f5273e82aa4f5bfb81642569970b1f2991f4c387a729a891a9da2959351bec1dc97682796a9712fea8878b0a336c5453207ab8a8acd9f225acc37e2013a2445efc8dfb1748d65b85cb643dccab7429ff851176b062b8fe8f201f914c1097a4338c5ed727764d5d0eef1e687b85f9a24f1d3550a88ad101a70156c06054b6f73ff5dbd8243e888d0945f4ef61af444f06765ce7aecf6695e1d76f415253cd48bee52deb02c4483b367535de268222849bbe8056b7f3d073ae6b9d9c3cfe86b5c7d16d56950f7ea9a182930bf227a2d3c67a0517ba01e2e70ba9785da1db47783a67841a05f0a718ef6310bf979568e303c3de08b84781c63d745fca1c630f603c1bf45592b08f7feb14dcfd52b8955410ca05af89dfd6249d2f63052ba127d76b1a39e44b4639f6d052c6bd04f56f2ef929753ce19d01f18ea43b756fa11a129ca3b2ffccb5780a0d842a9449a244d67f507db288270faa7995f5f4b29a7a3d7ca8b64ee42005a16c680023d37db902ad60e4e30ede20043318291d5a957591063b5f7ee252a927d3cc7cde5f301d6ef88dd2295c38ce148b87a6cb37608c50634f4011bb59d305136c22f0086382bd7d13403b2a3dc01969df96a0359d07983204c2d1840da93a21d900d7bfebece5c7bc96fc1ae60cfb5676e06ae91f959532613fd63814961da51af27c547cbd5a37e7b90315e0e9c4ac8c08b4bc435cd5dde09fb3fc1f04cd5a6d88a697cfdc9da1477ce00014017f167255b0b3f64aa39010cbdd07f567ad1e452ca94d32416a8750cc60708637aa1659714d11e838af600db3e2fcbd51a82867daf24b214aa6f92641939c2439f7291c3f81462b4015757b3f24337e69f34c1850582865c3fc7e05dc863eccc5d6f119d7569e470bbfc2956bd22ed9ff75cebc1cd79595b8d0bff1ef7b7315a5437d6f14e76ea0705d063f41ca41d3df93f26595003be2dee7fee04c2516cca80e3588a0d3a81eec64e8f50565e339b04bc5defb23faccb53162e01d16867bf594375db63c4142595ab6f7f18fedb5d7a1fb5b95fc3bf2aa4f0a1cd4733327ba884b1ef34f0c02eb5f28299cfe2f8e1d70004f20ee442e2d946436f3d7570585638c9721c4aa6d02aeadfe4357da9142b2abcd761fc5cfb388bc171f17b5831cf54925f6af9efe1db79899bf3c731dc78b77aa4467097e01aa17e3c3500b819622fcd2ab19e1fa99a6a51e8540a36356fd868558cdc6f8f8c674fbdc715812b88f15ef72b952f1051507217c5b43a627c664a1f996e4b8c747a17913ccb0807fe6186139f74cb36ff277dec814cebaa969b13499f0b8602c75a62f8f2689215e35422231b2b71a071761e39205716cce79b02cb0f516133b44e85b67b81f34aa26b1817c2aa53c7b0a18e3e1dee9e72624ed97f398944d8b5cab7b1ebce8b9574e4bab72783baec9324daef2bfddd8f2c4c010571d8a3dd60674c278431923654aaeadab4a50be6425dce9cac1c60f968c5121006ab1e2ccdf2fc673f79f39e0e9139cca9fd0f92df3ad6bbf2c07a2adedea0ae35dd929024f2ba2836aeb553d233410c0ff2573384ce1389a34e9997e80d6dff6019e704d8ef328072d6949ec20d8b2f85bdd397347c7361a85098b2291ec149efa906d084eeb57f1bafa0d37107c4b2468a8ed3e0667d39665c30078cdffe7181bf5b2f00c8483a92baa613e0e08c2a8d689499debf7ee52a6b6f011e3785d851f3cd5f72e3fb9c8c480acd3322401d2d809060b1dfb41e87724779bb80a16e4900e26bbf4f50fb01b44fa3e7616655a45942eb5256f8456668b641c7ce940b18800a974628983cd9b1f6736b00210fbd03d36caa2476b23d099689fc0affb1ae1095627e1588335d227d8460a6ca19f59701fa1e8ed39aa23a14dfa4f92b5e08d0590be3e95b91d05ff2b43356bb05f989484efcbf77b91dd15d7c833ee81e57d87acd769226044f405e441faccf6e8fa961f8cb24262be310f5cc047806e3b758cd238455c991fef7295440a56653d1910176a41ef94bdc7574ebf67c5c53a7ea341bebe5c02fc9bb7171003e02eb9b48889dfcea4df10638fdc7800a5b97be5715b51e4f8d3259b8cf0b8a7c748f3776d0f7d3375a669c57cbe312dedc64152d0124080cc79d9fba3e73aed53d8257acb2db4a8d26604b870bd89be76167b69f8e047015ca3b95ca4426bf42a43c916209079c62b9035760148226c5de638c809c0c57bc8fb1ab601c9db715940d7c385117125ce7446273245946184a397811e395762a03ac9e7cac5ace486bfad04a504c1a06fdf2bd0aa88ffd38fd5fda4a2324c819f1d0d6728a75a75a1e100bb16f8290b63f4c4b0e937cd496132a417d51d25c450af9b5b75da4fcb40e6c1a3c969aed056f3f257d9534946d157286f1ec6813e3840377561090c378fe44c5b16847bf51e1145eb915e03ec7f85a5dd26e4a3f34508a2b0e3ec576e4df5eb09538e1bdfa95eccc600a00c0b392de66ebba064f545773808a87bbeb9e432690a5131e0b5333197b378fef2aaf6f4b8c14a0fd4716a607bd079bc1408e37eac782e3d5f7ea4eba3b821ed021d660b77f48853ec79ec7916ac4fbb7fff849f4f53da7acfd417069224a1d3c8bd4c0f23b0ab794e91ca914e21e58406b26245ff3a2befe568f0f861f69e4c65aed0e49e017b0caddd33abb43be0355f4f188d20dfd1644ddffc1247d5f5486565d109d9455eb0415bf025b15f76e477d3d93e35a1ec321b0289958eade3d48d534eb63c6301d3efaa267ddb3eee8fc1c6d3d210f8d8a8c403f8013e800876d27db4f180523b33b6134c8ae5bfcd4b2ce61bcb94dd893d0f48631e06ebce39cdb82a01632f0bc4d762fec4d149b1ed14a3873c5549199f95593e65bb0b4eb5a5280620596197e8ea7696abfab96b2705c948543270dfca897830150885404d379afb4033f9dad4d4d9250fdfaeb591e15353612208eea97fa5e32e915437a6aba0916bcfa125c6c8c93b2ebf93155e91fa54778191720c1ef48b00fbdfc017db505dcd2626643e150e5a5de6831112bba97f6f07ce7c94791ce0bae62e37347acad757ab175dfb430abf6a40278734d511826ee66830b0b76b4e86971926afadff5c79c29f2f47f9b49332783b0c3ace244ee72a9c49fe580c85b778d504c47449ccd161539f819218aa6574934432c0da0508949f09b9a9cd7880965d21dd8e99d775da1e69224faf2551a445ece61bba1280cdcf7932b7b1073baaaf3bcc9e605185b4feb2e25a52ce821b487e2399ab23df50340bd94a8b661182cca98af6ecedd9f8102e64d82436fc9e2d1bfef1d433d2ebaabc871948f110a3df38bf718dfd42667f1f84fd4ea4f50fcec5943df85d63efc641d25c4e62f603698e5fb854c73636a629457acd389020d80ef9d0e85eef635caf245c7e0f8df5c04afce01369882be7809c0f7b6866fbd05ec3c4da97f38f404c7f368930e1898e7b8dfe5aa045e3d4fe63cfcfdf6587c106b9742a21e53932d7d6a1d6d37ec97697371b4592b59cf47df57d4ba354e99cd80a42223d8ee79ac45cc8dbc46ba501bee7e82db996d374745b2a578905419abe2fa2f5e570cbd99b2ab55c1348c1b4a4b207822aa4b7973a89eac4ae82e8e3652546838e1005d2970fe82c730786583a1d4f0c6af0f2c23f303bbe4e2b7f6b73d892ed3b82c9716b79062d9444f7ce503364cb46cd6b88e381e7794ca5589fc5246394b8e8c8e4663f3e6fd69394bd9109c3283dae1832f5f7011384cbb38b8cc196d7d03fed9256aeb3affb1a0964d24247d9d391a9843c99d1428bc23e45fdff28d53e60d2f22b8593d5e073553334d49fc93a975b6afa643de51589f5c42b1387fa2fe73ae141fd4e37113313aab8a8e089316366dbc6311f2b5e09c7a1cbac9a9e94763ce862a2919cb89234ea10f6539a6ce99f15747d34ebc5ae733622f95f8108f51994a41d794b43176d67322b97fecaee3763503ef8eebc1984da19e2ad6fde66b5567a37328cd9398d4ba08850cf95f18ed6cfc716955478eae867bc1b2b41ad97c55c62355a3505e011ddfd8d1dc57fbbd8c167479e5e4de739d6955b5c226ab9969e0bf914e5c289464c698b9d8c1fa21f4a74e3a623021cb958608bae804a9342403b035df3c8fa6561bcd7eb89a5a4e12a909735f12db81da5d5b6cd99309ca0665dbbc8c53a58313a38d1cada965e59e2f090c42b26b918e0abaa812e699530c141f70a1c092c0c3a944085fc352dbfa91e907e9833c1007ab8c514329c4fa2823d9779b2dfafe48273bb896ca30a3e310f64d6dbfc04e24edae103a37d194b748b8a6c537e8cf454848a2eaddc79bb14764dc27073a33543202bdf7e55181ad2003eb48df92ce8055e6d67913c9427fae61fc0154e77c84f723e03f85c4baf54764a9900125857c893eecf386710bb3dde85c949acb8c02da5032574b46ce3d501d66c76a8cf55d491d438fef1e5d08b4aa783e0f12b37417f49f6a37ad949f18d292c1c38f68495b059ce4a0fd8ed8fd285d13296fa629b0b8c59308803f3dd5ea94f98530ce4729c45c134c9fa676dd576fc679a12b25255046fde2edb7c2446751e429285e45c9365191343fa86302eb2c5886c445e4cc47256b136f0237ddb5f20760b8780e7cb3abb97b945b5b7263ec049ec20f38e9c1772f6ade5518c95de824ea3df2c0874ef603cc66ec4aca84d516c0dade92b91652b7d2c8f7b17e7252cee0a9d602f72a23949b1b6d01eb31ff0d1e7e0e7a5854feae6c11f11c9636728040d818a0150b7625ff29cb5d168402dceff350e36baec54dcd7c72403dbe300eb2402cf0ae39bd6d6758e5243927f09cdb6b77bc07bcb27bc2b7778fb8c8d5e7b7319db56b20d7e5645742de9f2dbb8b0d9b043a4e34173aadcfac73cbed253fe002e2c7d1dde1987f341cfa43cfb0603b44e10f15c0b9cfe552b69dd1fc3f69661d245216697af7a173afdb5496f255bbe01e222177227b88ea4e73ed0f2f03c7147875cfa8c4f431795cd5fc5a5f23b560b38741c3d65ac495a78e4bcdc65581c1a44b4a9141b313e17fb24e1a1fcba57bb84ab526ed5f7bd067d91f8f6fd8585d91efa73d571d4d9b84d6fcda668a9062e1f9379b48de2a8304d69c3775be6f4f8e5a5fbc4a583ceb58bc65164ee3f9166236d6db15001de833f5e8abb73a72f1aee843facfa5727e94e05a8da04ea227a4fd6e10ed81b5f3e82b030e82a9766352fd88df25226ae04d3a11c78a6a8891bae35d8139e553e1af2582f8c8dbf3b544aae559ee0b59ef7fca4ea3753da67a8b8899eeab78aa87d913a9e60d9a1ce3b63a9ea49847fe39f3577774b11d079a60643ac4cf84d5da4b73e8e078696df2622e3aa5067efcec9e080752213a24dcf901acdcd337c0dac584ed0bc54f3319e52a8c768f72be8d4504a35d53f8f69ca1b196eee9807ed41d3a0dcb4c1315b23e033c96b9837f7d4e59c50401c73420bb4d3ddc37c818ef4e727838e1781cff3757d0a9660e3adf5935512802457fd6706648e3f7b6cd09f83972719b9b7c60e249066ff42ac6e6450f8c72cefa7f0c15ffb39a512b87d78231ae9a112aafb59526d66b754d67c72e192b27d2cee925b96328b5b8e7a593acb3c06b5533d37243f635e84f9bc11862da79b9b5fa3a8307f8908be9725d87d5f6ce91876948c46b5ee38f08bbea75e2caff053b2f1d8a17f948d6d70a1d9574febe60a1744c627760707ee41237d4e0769428ff55019cb3c7a50a276b695ea1708c81ccf2d19fc64d61c323684f902950c28ead0ed7868fbedb2d97b47c6efea1112ee8058555a29a9ac588e95b012c0816464561b1189ccc3928fa12eb1e5667b517d74db0a758464efc4f55922515b7e410edc660982ab2646c660344b1071a6d55a64300ec933749136a5b70a8f843cd30931f45fc38e045831b8daace9b337e4eb9e9bd7002aa3d3e715bbdba1634bdd86352c70840a48868f8422b1190453ba54c0c831c825a013fc4682808de7ff435cbd21d19e4282cc593c869f85027db56b80f8bc28f7fe8deea369adc7477ea8c5f149b2d61a254067e859783d2f436bc2c8b49ad597ce339c0ff2ef14262ce668fd1a810f8c3588f390c87004399848425473f2f3951d3263178d670c67ba76e580a5cce01d4fe36747bb22725818e8765064c23accc1cabc8a5ae9ead7c8b693f183a0aefbaa0c2d6afa69437ce700d9090097e1bfc1a573bc1ffb53f6c359f99c644867012f3179bf2e92d5a2db8c0efabcbca27628c54084102ef0e05554de8240121bf45289e88e7f95e27905544ab2fafa57851a9b23b51cef5cf9d346a5aea299072e02d1a5255213fa60496047b0394454aaeddff9596b4e9d17e405f3b29aa9ce1cc5dd7b2b31099f144950e650720b0d3e423582a867dc41e2127f29f47b93f9eeec507aa2f1cca04860cbc19086ede1e854fe4fcc614e55dcb02369ff98eae5741fbd223b80447218a7497bb24dd5cf945c03560687b6cf841ad9cdcc82df2b488df824d062539ab1b5392603cb64c3ab31f095c610b11bde04cd5fe85b685d459a83bfbe0da3426f97b70ce456d40f433c6a5d85d490b58998428a98d7926d6984354866cb7d59a9f5fd2e4b92e375d10df4d68f73c3600ba289ac6d40c345e13b1dc294773c82088a6b44121c8effe422a906666a45090fbaa563a1c3291afb4d82f5f8f0ae3cc2ca8d0fa966978e9da9375ed8111bf579db64e087c9c3e65a35327ea0fbd8cab5a0d3089b3df67a42fd54964d872d8ecc790ba7851069d2b36083f25c25d9bd779d01591b8c25eb87b6f801aa0365c3d0ad5b022964668a8f7e86d90e85e6b49978d47c65c4db3cb9bbc8aa877205ebd3851b90e75e6c3e79148645e20c16ad0e4dec1ddbcf234478dc61eb3eb3dced19fa356e6833a48064c58aa86f402d47c4e87469f56b034a0313ca43a8ab97b05671d53feca324d2b6e590fbc26a2784b7bd54ec57508a710c5d20c621189c82669f01559b8169638e8f2cc3f20db6a9304e3bd124a73420fc37ffb38e0ffa5f77fb3a402a76b87ad8763f72919f8ace645645485fc60cddd886bcd44ef9faeccac03f96f467a4485e964c193c3107426b2c38363278d371bd7c8c3688c0a8268c89d9e00ab7ef8816d8ed0c17c6824511706c8c55d4cb25e2289cab560439aae0be57209685d9aa352ecb2bf3feeb6722dda85a53f92711954b2c9ba9a1f7f4287a416c68151448906ff0f0ffc31571c9f6215490aba60f614d650c7e6d9db24601cb676decd2f3d7b050738017809e2c9a1729841a09477103ac1b03dac20aee794a9dd479fdf2bd8b8b6074b70b8f7f366010cc3fda889dc50ea392c9e833af9bbe9b64f249ae1edd822ffd72b00201bef35f72ed729641f9f5bee92c55f80fb9f992a4e99964d8e3a0d9bb910180b5fe29e6669304647047b3344fccd34d8dcf50b4c0cdcffb8b7755eca04d4917487979bc9e538f707d0224a97fb14128e53e3337f663a85dec25f179574cf8dd03237105431bee13c3790798c3cb6d747a15a75e47f74814922300973af7642627d12ee432df2d65553981b99159dfa339a789595aaa8ca22346538f02e6159edfa0e07f0f901748da58478d1bd590712e2f44f656e03db41bc9601e2c5b3e271a786bb16590831fcbf5e497d82a44d9e827489ba77ae44a4ef916f573bce1412201cdc07cc9b2769e038ecb30facbef8b2688a6ce9bd219dd6f990cf1d0c05a42963dbe0507526da68e16c080f822d59a97c2844388575a15d69bf3fc45fe0b462fa5cf3bc1bb794175b42dee681c6b90ccbfb7a4e73c9ea0c8da8089b96af81e2b9f171558838c8969056afe9bce6617279d1324349f71b6406c9b8de832f68107dbe83dfcdb21372b1c410208c0510844a8b1b7cbbba81eac521d51738cc7e903506dc92db9e48d8f0d6aed05dd7818ac381f7ad46c5cdb89b1336d61d0204fabb6deddd29a71179cea7d8dd3f4994ff8780f4d33064c1a1d9666b09d7ad2490539b0af6e69594b4d27d29fb42d045dcb6af5d3fdd24f76edb8c6a9e29528c9d1dff870178c4bfee9ab59474125736ff8e4a438ff700a388ee904ef8796fd8a87961277c828844830c1a839b974157826c9a1aae65839dad032c98cd8a78679e193a779acb0df038e733c521f2df906f4a39bc562cfbfdb2f6b10970a454ac9d39abfac69df4040dacf81a7962793aa5cf39b74caf51c54dcf904a40f4bd9f194780bb03554957cfd8880793344a55e532bcf7f71b5d681658ffe416fd3f83b62d6e6f2f9f78f40ef876d5e1a12b1e0c263e2700e400a8c50e70da04f1c803c0c65f00b45bebc337adac6b3b2bc88b3f0d8dd26593825c62b5c46f89dd788f6740ac442e0b897ad9c677620132cc34f1e24daddcda2119d0dffbe8381930bcd91bbe5b53cd472c9922b498c99c5cbdd4979c16f9ed52305aca11f1eac4ea1df3659c44b6db45ab5b0c8fbaccb53bef5ff1d13a879044fab7a7ce4cefc6c44c8f69707841e0d4101f6e65684c794c9e8ec70e6f044a8282ef3353c285a0a71189715c20e76ec5157b430e14dda8676e8d76b012e9b882217727ad775353bb1e7b533d385cf0979bafe55adc88f893741988e97d3e32e3971917f1986cd72b0ff977009f01a5c6b52eb7f4ec616aef76c64e4325721a908617d6bedc91e5238cdb44ca343d0d0620412bc0abe296c4a0370bcde59f6e014e73082e134f358108fe85d54beff85b8f0857f50828f7043a36352b133692d3139b5f8054a56d3696c9a1c3945090fb781676c426d44797799897469f3ab76461aeac7fb69c347a14c40ff0b5bac93a4e68fd7e304a02e4b7bd935921ae57fb003fdc15be127349e6acf7a6463327fcf3a632b6e5a6ebc15c6872c6048a76d25871f5c43b7861246fd86e27b7544db49eef7291b20f356a7fd8524aa4cbdcdc9b38f22f07f445c644af1ea9682986d17c75b26853e8716ced75c45803efb46d17f8fcde7bfd14a57909b641388c378321f860cd8abe5bdaaf9bf1381711657d0fa8442cf699fc5d10bcfd137284fef0969babe23bf856be1c2670c7af1ca426e39fca80f7cc55b3406a17f9df770a40e6d14b4f01e77951077737ed32bc4e952e2bbc09290c9aff4172ebfa5e03f4d080aaa1a7590eb94f44eacf48520479c74eafb1c85bc007f3c6684c8fb1853fccf2d432e1d9ae5a6888e7c882641b1379a6e5b20dd02adc156cefee5c498def0cb39908c1ddb72ce392d0a4e0a4e7e37461be0669cb7f9637cfe79b49a82c8955b99c707e7020e4aa6301e8808d3bf98c828f3fedca3a13af64105a2d67052af9fc9bac3ec264909f778b15794617247d0ef834a9515811ac7c2136e0cb42ff1e6185db762d4102554c12460def414a7e01139e675d6f54be363044a7dc85d79dc07472589782002401e9af1c88b53a9268836a1b72503d885d5622ee900685f8ef780b33d43d5402c317a4845e5d8df814dda9f3e3a939f8ca1122afecde70512469cb4486a3789c4c1d662975858a5740107c8762d6dc3c8904ef50bf5959d09a54a68a189400585ea9053bfb5f38845a5ea0f0faa9a9519dfeea3a8cc001e31ba2fd22c531a74fb85ccd7819254baa5c5f128d6bec6ac3e23f3e19cce3a5c227610358c25d558f77b8cb71d43669e952861e6577fb0f31ceac2eb0bf8309e1954ff6c9addb801a01eb8e4e14ea47c9b442a9ea579c2c4e9806adaa48c730d9fefe6b0fba473e92f55dde326e11c4f71699946a0fcc4b52bdcafad180c29879198c806a5b2c391780b80c1efc3cfd5c12237e9153106de4ad867cce2a70ae3968e443f60f0517700c22ec5c90f43a5e9701750f4e65ab305d41eeeb1985c004e2706fb8b302a8c23e6c2a41b88167b0c2483ca98379384eb5af61aa7e2566e95f744c3963e5a4d3aa2ae13e98a08e307f7e36e1a898a3f290bc086a9b47d7602c847ca27d74626b7c68510b02ccbd4ddf340094a3085883f14502615e674cd96b8c663fc1a76d66a53d6d88667cd1bf8acf62469c4129f6b2edf7c955df22a8314c66ec9ffd1b3f9127a9cb5aa6dfc1df0587bd2b7be0d49935eeb63dac3a91d5d9d10d4b5090b2d003a6a149c619546d1701ea7aaa40ff48cf3487480b9237cb28c78756002b709138cf5113552f73c7de8671e439e7005de099cf607615a55f81a3bbe01ca47f5735464c1b2943c4cf2d594492d70528e9e0da25ef029c0823d7f4fbb8b4e7727b5d186cad6f209c8b59781d2bb5e1be949aeac38d30f522f0f580b40fdabb0abc86e81706778f60e78d388fa521f84504e38b1d3e1d4f7168b493c88a5e5ecc37ff49e050cb292c535b731c57a0833674a6d4af7b299695a90a7fc2d7e06707d00e7b7c8ae14227482be9c2a967bf88a3fb86fc9b03483e6183d7ed623793b3f8fe4499b3d91b68a1c135794cc88767d56e0363fe7ab38d5fb0892b1dba3c82013e99d6501bf8a73d764fda3d75d761e9212d4eacb0560849ea7045f028cac3f688b3da073ac0df6c8fbd3a4aafe6b7d86a1c16ea66643ef139f5527110ec34d4b0c5eb015a0bf0b00951844900d9baf75f24e0c8d581939adad8b5d56f747a9adeb311104c2d7d4e8efabd2773ee446f9848547fece5bb937a1f121df7654e451c9b5fedf2b93d2b731b9266b6088629185d40c100ea1e0c5e2927c905d2fa347ccc7fb34d29004270ff3c96f87f4fae36b9f1c6b04bd000721ae65f02f27d57b134fffc84753271c9603dc98800691d0390cff0bd5d4cc4293d4f103433fcb9e8bfecbbac1b13baf3bc3a35b4b493a5ebcb558a1cd3b8b86917c3bd9351d23744c7201be6c2168650b772d57401806a8512543eb136e39c7d0c1e3a432cf1f0d3036b9ff60c38afc12c6cc706d7f42b0971c4913e51fc1c2a09794e893522cf6b883a2fed9350d27d987656215447784463e92570fcacd35392c8fb8a03d5c9ad2ef9950aa471162c12480e36e9d44d2419b385e7633eba9955176e2187cc026185ff35977705c1be87bfa0e02f63a6a1b21cc3a8f65a78f17301d403ef0a79efcb6e84ab1aa51fb9eb79dff7e60ca3567720bc3bc071766d677969956ea8867d99c8a7845f3e1920877906f24ef1295ac492c4ac1e8d7be11fca615a552ee3f7d4e224bb7a53a9dba7dc0f4f51bd8ac36b2aaafdf38b350af7a163b7d11f0bc1729015fc8882c20a335d2ab62aeb25ebd1742b005f5a313461c622cdf2690c9e639e3d21c1b8627a563dbaf1ff1c860803010b893708f41d4dc70ed05dcb6c88f5bf50470450ee0111bcad17d406ff57393dd1bf74dc2035723aa83b2fc610c58be10b09b576336b1150090595540f7cdf1fb186d3792a9699ea366de6581892aa33f7a091e74d2672b0f11f43957a72eecf0d4841b2904c1b024ca2fe1f6d86a6b1291e76726686ef0d931e7a518b2a1f56a238998eda04c422cdb93435845ab3270df4fd6dedc91f6acf3ca24c7134a2b523ee2f45b7ea5a7aec1f79fdee2cc89ede5ae822ca686ae4434dd9b3d9ff2131f06a18895047a03672befb1456b5aaa2b463aa6bf1b05e0f1f58ba3e9cda8bae116bc926e496e4cb52181895c73accb709ab65f0ae91c71db144030cd19404b95cc8d36d4a1af6619d33ba5c48fc59baeb762be84aef1a2c7194fec5a5067f588ea65a2a4f0d0ac512927b3df38b17d8815ec2d1333f2844a36af995b6dbf42472d40d0025005e9f21351304d0dc2963421c48e95f35f1e989ac9a5e54a4cf9558ef92579d8637178ab7ae9ec45289b28860d8d005b42f291dd727dc07695427a42b23bba9a838af083b961f43ce8a590f240993f0df7e36f472295d71af7f1d5b126aa19135726d79ac847c2f136fee446393409a27f1f9fe34cc273dfb3bffdf14f6917e8b0463c04f33cc2a1898f215d8eb73a22e40ca2418634716575980440718db0caa7b56d34d4f6ebf5aa66423c633eed1ba989a73fc6147af5a694ac5efe86e0d6a5a954ddf33c0c06e16c269638d3231ace52c5d5cbda009dc1a802020161bb1e3a5d7bd796fad08ab512675273ba7ab5b6ce7c25a0e4b293c746fcd3966989582dfa985085f896242dab52320cd559a1f16e82b3c18f8120d612a005ce55dbc14a84d9907049dfa26c7f5af93a1b627d95bbaf0c1465bd045ef7ec70cd4d38f0a28f54d3a40e96450330b9dcee708ae92883bfefd7c2a25cd4e88f254b03f3bcc5923ccc0f1114c582f46438526805e5e88fed569227613a91421af067ff0f85937a4fa9b669bcbd9b2e0f935cf4e119b24446f5531d88fc4bc4db67c3c2f24a85e102f0117ffa578c02ef215ed7d26e46636ca1d5d53ff431552e7987ae88f9b6a49ab22d22ea44a720e160334ebc5d9020942faffd7be1a70bd3a99e1487c02ee6c78cf64e13cbebf8da68d57ee6bccdd550b4d2d198932c9cfc5297a1ffb690660d6186ec0e9bb00b5f9e6eb7df17cc10887d52a2d77727b7c6aab82b2c31cf1d502c9b7918e25229439a13a647250b0c605c3d2b513db5905e4378f47b1cdedeb1d67d291472d9a11439c124ca6ce2256fa1c5c5ca5272b85b635409a3a5888d40f8b6e7537f4d746916e6db49ffe3893aa3414089a6982259deac1b091971f1ed8522cfc86c9084700b62b26c3aa00a7128392fce87f27e2d7e782afea8958fe010ef0460ecc6d0cdfba7aa74cbb52b9bb4385e50b9e1cabbcf134571fd0a99a556050ba2a4090f5a7da4416ccc6edb6ee1fa154a4131561fac5f0f720d33002889220b76f2887dd11b6cfaca97f41ac5f3d45ed720ef52cb3c287d20a9054b829689ec9bc4fa9323d072837f8dc7050f86cabe221040ea60a617d4da1ba765ea2c37b587e2bc276c87b05883619fb84843326b47c7be0b665b4e56bf52d7185fef9c6a0b72cc5ed0051e22a63e05dbbdb4195db627b9a51da5e01f8580728b7bf3099b29dcfb9ab8167582930bb44d28eb167fb60f3bab12aaf1a0567c48bb9e2a55976f4cad77e14e9b5354d9e2857ee6b67cde653e2ab77657f0cacdc31a22eb4c8cd9b39dc3e3de424a3887005164bd5bf39c965e8da49353aeb4e2be1208a12c4cbe9836d9c5cc6fe0cafef2969ae413d6a7ef76ec2dbb2e80d291eb4171e3c6f27fcbd25c12354fe1f7718070ae183a9a6ab06988052396eb82f85d0c4c8d3063e3f824a693b8a58e51a31d8c8478fcc3184ae162d9b9901b935b3f807aadc1e4c6b01a6eee3de97a718e33749bc3a0003aeef1867a488dcc9a02bca9e238f9b8cb76b441da33e790c0f0bfc9011e8bae927980740162e6598cd549b449f90cbbb2e2455fd5335c8ff4fd0e44a4d581b01713d891f532502d419b3b2f7f5f2f14d0f921b8468848b7a4c5e9b7bc75c67ad4ce05bcb939e911c956ae719a0f2124a02b274e8eaededfbd29ff5bdcf3fcc5a5fa5a47d1f3281fe51466892ab541eccd86dff7da98056c02643ce7d07ace761e263324bd6e73d25be18889ce20ca2474af04024fa65852887a992595d3e86d4b9484ebf09f965a1219eb51f22d74ed4bfe4d82231e4ed613f1ba31a71b4eb15e4b901fbc04b99c80fa63f8f83ba17d7083b1752466c5fa60fa43718cc809082a4721b0b73ecaa252c8caeccccbaa5b2a2615c19dca8843485f55489c7fa5035f391b422d72417a0db8aff4a676710f9dc2e80b59a8b848c6ac7bbd7dd5f13342f24fbae32edf273426aab21df56e3d648a2aa5b39654ec597ea8cad817c6edb98b592da8069874935da85cb60678ca6419b717ace124fad7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
