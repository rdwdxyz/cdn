<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2de9d3dfba4c95dd0edd1bca7148ec7aad39d80a8424c0427e89e267d1609cf31550964b615ef160777620dde8a5e5db2a9974c807703ce05292e96592cbbe6b44c6d4e685ef13a2df22986d306f1d3adbba99691c22fc37057d69d2f252fae09047887a638105a31af8018833bf2399b74b8a0b2fd8bea1b6b57d66916f6e81caae74e6ae1507e87efded4f6babeda3a6cc8c15b0b8c0dae2153a17bf7bfd6d74e1c133687df56e9b7b447a052232f16f14fba40465a53cfbd1be9c9c765757d13ce1900500645589638389ff2b6989e75d2c1e7a0654bf2da699fb3410f63556707d6d325aabc7f107a23b9f9e9cd82692c9177613e47e989dd2b44643dfd40fde9854724488846fcccc27af80f2b0c649c2220c4ca6ffbb63e8d4241cba435bd5fef9c1bab384d410a981124edd5e45fb3fb540c77bd06edd31be8c4e899546f95a273c9e28ea7585d4312f8fdb79c6ac16743d2af05c2b8e4e6e70a5e4706dbab07c563c741322f16603f68be7a65ea3b423323b9f741e012566e58806a8e53c30712895cc0cec9924f63f42da6aecd700dca7c56603bd478acfe7503f70b719db72665f3ce2913f5e4d40da5e616688bb8fe585f2bcdd9dcc0380a003fa649824424694549b6ea65a7264092dc381e854175ebb414375b7ddad3add2be921f37e8d3e52f7ade0cce66bf7679494e9f24cb514e9f1c33788775df4a0aea95de8c8de59c05c4633676a0f2eefe8a18036ba339d7a1c5ff30af0346aca9f286c5abd190621b5337b0cf5d781ee4ed8d6a1d5819d2b3a7e9f5eb025171c459619f99770c7906b575f59ed2d81dcd1541477334b25940d4193e05141cfecc0a9b1ce9cc1530bfe931aec4a5376f132e13c9cef9c940d51be86ad0bc234ec96350b5fcdb9c577c4b6aacb59eb5da89081cb5e031c66af821db62e14e953374dd7ca82d95a263b425e232a6401b1f36335665636daeb11aafb7c099bc669b2bdf1ec27ce1cde288121d40f8d9d974d179b63f80b0dce41a15d3a50156512ea5dad4d43229e0284ff3bee9a8556ff38df5a07ce667ea456fa7e1124176a457d6307ac8964e18fcb09af312e42ed310af01854822d6b81b9548533a7bf7b0d0ab5b8d38934e88c765645c7cb899f91a0ca41525cd5d3d5c48ab959ac03db67e949e71def6f7dae85b0565e37b1dbf7b7e1eb89885195d012cb077f0771fef895b0cd176319ea9fb486992cdaff7e596c11d19f988e8ad4707cad8edc1d2fd27a625999feede08f54ce630aeb007192fca6e126f4d5a12f6a46203872c9059a7680503b83839df2a5a56cddbe19cf43ed87616524b5d3c7352e2bafc539396ef24d8ecce59b4b32ad9d018e8952be3d83eab8a09fc75ca1b3b7ac4049b4904480019a9d1b82a428aa5b39a80692830f0e3ae0ed8a05f967ab3dae72fc6e5bb11e30b416f07acad67db08f666ff7ef049475ee8d6a9ac1c3f1df030d2266a0a0ee12f50c167c8b4a6e7b5922ab77ea5442c345fd850afcd26bae558a632942eda5b84724571758d4c6693a634aac3629e9285f8f78d11096c6084c78eb33d05aebcd8090cf782ca42265eb2c373ea95076c2d884f5e34e1751b079c81d8c8a012ef7be53a9332460fb748d6a94e5ba22067743d0935ab4255837771198823e3b0827a4e7ff5512da31e52ea49e87920f255241c9de6fdd93b130515ba4cfac9f91e80e2263d34221f1a0b4d047890ade96025b6e2a1f1a896c879378ff7043e0cfbcab1937121d56283bbeca8ddf6345cbe0fea93ad59a7f1eb62333ded1c72d4f92e8e2200a34255c2b268e46c6785c88667ddc1445bab09ce053a209adc53ea78bbaea2a21dcc0b1a9161ea6abb7e398cdf02b23c7c6d280b8aa356b11895385174fef2e6ed37605991645a588b2443c31e03e484e220d0cb8638d269dccd608ebec1f5ee5253e3201e371572ccd222822887ef5d21316c97fbd48b7caa306c44542daf0b59e5ebc03aea38b2c1fc03e6db2a9fca89d9100d2d0e977c12112d6e84b61ba05e5cf4e0e7f942160072cd2d8297c41b1d88bde34cf587cf5ed1f81f9d465f0fc24431f27b6737d859af78bf399d286ec03939da0bf03626c86b884094ff16b89230a127228f7e0a0f002be0054f497b8f730efd7c930023870b0b28a875dceb6b32679e27f7ab5b8fb6a7b50d2e74288fbb5ad62b97c2c1f51f89f7a3182272eb2b12cf28a6897b70dc0886ea558955fdb2cf0cce9e44540beb669a6762042077af4e307408ba48d8730dc31cd8ee0444611c9e99efc26b30333a980652d386e633f4d91697ce31217201c670161e6796469942610a71950857f05876954d7b176ac4165c246bb263bcda04764f57ee51ce27e199adb7527fcdc33a8bdb610f02fc547303acbfc01cb372688942e157638e5a0fbbb6d14150ff99d0f76c7c21134aa5cb3d3d54f2a6bf34c6eedfec8b467be5125df4a320559d3a51c56f79bfe49efefa88029b5684417a6622a66ab205a216a2c20c8959f78f26cb883d245c1b8c4f13f580ac2b95de9bb7cec41953e0353a5a6aa37b226b33884cb8d332787bc1716c97a1f4a2a671d92756a94de3d6eb4515efedf012ab1b91fe8b5377066ec3394accf389a5f332ad136384b1b8deed2bb9383ee5fae9345ddba385d5f9041d48d4bd1e20d63b901a3e6192a7eda87c56ae60c91fdaf1b6f717e629785e14e4274d8e9c4f18c401588b67ec9bba7cb58d6a141a5f3f54cbb4cc8cb38a274bdf4c8ebec5eaeb0658908b8a1176b4d5a79bbb4a5480f11a7e6cc2bf25366e8cd95ca95a88172a78a389349acb7fb22c754f6761874cade2fb3d3e58bd052b7310a8059594e5562aa844b238fcf5623284da6ed8a5e6614d1a54e0dfe2bc1165457dbb4e7ab7d9a21b6b8d0301d2200fb73a365fe84f509fb98d58efa2c20092cf2ae2e0d1683d8e2c9111f464ade52ff69be9be2f985a0652d93560c05cd4782c74bc0681cd98d5f406ff3c3ab08e399558a9e892e62d3a14d03e241b55577b07c651ef8eb233d612982ca633550f84bd769f08b1760db6ba22539229bd73e36712e1d0ecf2a3c718051ea8e15a3b047b874774a6d36b1a4294e4246ad2ad25d671d2ca8df53dce41b06a08384f51ccf633966f64aab71da21e3b3b750720478b416925de820aa72c1ae6b585fa8cd3eb5aa7e92ceef849731b2362ec09bd2099435ff7596cc9b061b95ab2a0b87f02c6987c5728a86ca7a6fb45b156c9f8b2cca8d750e93575a45cbfb4a255e9c49a029b0ee807538e9cf9d79f351babdf8ad75ba554e780d1f5823cf303f27e316a5bbc4715d00312684080cebd6a02ac45bc078ba814a93d5ee77aa453cae652534555cc0df50303a54cd7a016af6af70a14d0fe9d0ac6b74a229ce2592d018dc57870edf889a857b1c3b7c716c4f708afdbdc4ab85a3a9494a9f17e15fe44bd56b2c948c70d2dbae304f4c0fcee87238fa7fb6fbdb486ca07d7f8b11ba6cff7b6dad0cd8cd6ed9446b12743046c97e6020aa7388c5044e220bd68695867b1cc08760c5089224a700af336d75881a530d31e47b1fb36acbb93cc2e53eede5f382253d1526cfa3544555aec7033f0164032fba6d023bf1f3cf394ad4854f7b1a88a9be39b3ec45165f9f43846fb9b025afd93ee4c559833f756d82c62d60d2c95f50759ad0a315a8e0e45a355e4367770fe61d7263d9a03fc841886f8e4c21f04e6ddf3167bb95991ebb28c0e52c9d448fd7d7359f15a88a46ce944a2796534c6e963fd7ac1c4ce8d729e3801f4159926f2a4c06704c617e826bd112a04f39d5a8b2ac532567b71766b90b6ee4afe2468730aac5771d009e6ce3ac2852cba7acf8457c48f797f5214adcb7074bfb6b1adc9dc7e6152490d82fa48da0d71b04f88df971b642438c5aa7369ce202f55268d2acf51678bc0f3a762ba1f5db0ce1bbbea9a1d12186a41119f1fad2cbd7fa0ad932945013615d4d664ae46d0cfa36964c8abed0bbc8fc491952a6d89d13ddcf8975d219ef18c1286c2cc2714ff7acc7b14ed0a938d9b9fa5fdb2e76486ae54e48a8eedc9a2a2cb0ecb76f728c82c76380d516758e6ac7007bc203c13df3d01a9b2775dbaf39578fb5e1e6b4936809f77820cb258766aba3b6a134445fd7dd2d90184b25c53515f483228a60c2d855b04b22fffa51bcdd85d65bd16d543313458e2b16c8e930d96908f9344c24f4ba617c66b9e2fa2c4a59feead2840ca86b65c6016603e3bdb753a48eaa645e9bbdd8808345c61c79919ee292c17d1643b6c8f244c0aa47ed8a9ed254ad47a22768c7275c5c901b5f7c47d184e1165b0cdd31e10cec28783f1f45df0059db2b31b58e61ebbe85888a99b5a5137f7b43d8376a1e56f6469125096d494bfa5c86248cbf27b849e320c011db0886d3e1231f63e27b4f946b2a91f20263a748b3e7491f1b902939d475782a30491af03ea4296c363b439ffd71f1362dbbab55ff81e1f4efc42d5ecc524e5153576881c98aae31c71f74f995d234124379792566f478afaa21e923291d697f86fab800455c65d32bf952967019cf80876cea9f1767783673a443064c5fb250ac06157487439ed4b1156d7671a6cab2f3c7abaf662c257897e42565029f0bdf76ad1546c9401f0d9ca7bc22c4b427442b9c2e4a434464682c75dec401d3106537571cc83b19fb4d24d52b8cb8ea681fa8ed5830abbcbf4c8e4d1f085880f9411402ac043b3c41cef4e48982c47bca9610a30a90c181885013e8c7ac2fca82e331e3cfa0df4637a1d03964c8d953c0c8b6a104d2eb339e893f2f6247881170c5ced0b4282a64aa957884e6863566e7e5751c1db78b7f06696cfac7329130f63a078f773c91ba16c82809f289f86639275b081cb3e88f900ca523fb16cc205671f6def5e1a3122a3f7442cfb9b34047e2f96e10193136ebe0e415279d918c35b9e00e9ebbc1d4b91c3c03353c6bdf66cccc4884f253ec31a8f1b1c946c336b6389db8b8fb1dfe57857873665b60cf40a6cc1c45c760d0739a28258cb5e12b6c18d964a6c2f1f7d7df754c39bc375fff68f2e55d4d15d5954e1c84a1e300729a44d767ef9aa3d0abd7ba9be0fdcf306e3d51024910a8abcec5f706b409ec193d77bbecdaf1b48590a9104a3e904d73f49d8c395bf864dbb5261a4dcba092a3831b0f73a0ec91b12f9fd9ad05d71c83548c42d1784fff465e5336690f8aa51c50cb29f767f050acd1ef02d1c99d6f87eef9511f25bf696d3810a4c18c4fa82a3157eb861f3c3469bfd5d5b2da741c7fb50b6d0ee7cc933fbddc1ad180833afd6d8c33fa15adda1fb62533c18b46afd926750c5df475368073ee9e04f009081e80a3693e23bf2e4a49c9b7ce985cf4736bfab85ec5807b7cd4b39caac0b97a263509d27dcdeeff25dc714adb5c4b591d09939b3b1e8a8c52ef9aa8034f7539e0ca87f78f73d0a41dd12412d0daa37b3cef89268f3dcee8338ddea3b48ed47270ce4d98296500bb03c9e0657e67613f041df3ca8d712f31bf29a67e10ba038c60cb08d9b865aa27c6a0fe7fd1daa6b2a30ceb894ea066028a0e56f2893a37c5331773bd453b27de313fb33e3c31bb692c9693021412b3e8e3246cc958057d578ac752888c4dfb185ba455a1d6811e3e2977d1ee48c0f2a21ab19d31b2f1be9568e7fd4d73c04753aa11039ed8b20c827266c34c546661002cb7d1ce8cdc58bb8c7888529b502df0733ff6e484a6147eb50f32482616444cb1b3131ac10f4551404bfa29d48687d4634c5e137eec3b6c8ea233896ad3a2bd83512a16c34c3f188e328a372cda7f81b7910a74a535f396c6b28a9ca550fab0e265f4144d60bf4bf07cca9a98c3ecf150aa8770a681957ec3e0610c6589d38bfa6bfc5b42bf9a5ed9a3a7183f21bee11d83de43da6d960ff7faf1c13059b03de747497c90714f83424c64f31cdecfaa66dafc11e4f9579176cd770cccdf2d21d828fe3e2d3917c26124e2710671349fbabee4bbee96605a9da1e604f207c4897238b629a032c543fc1d2c9cef7bbf7cf39b94d4d16a0a6b7efbd003710f61e286dff20565bae8b1a3591d5da6fda33bfcc38292f7b90f513d320f105a911d40c8256c051ba495f3fb629574f526b406e5b3a46f1677f66c2079f4e77fdfd7b0654e007465a5df0ff9cb8191b0fa9d60dd2f8a89ceddfa041e223f2bf6ba472599a78d29fc2a3abe45cc23ec077009bd0f5a47d7d0e19041a39d84d57a29947692d3e87cc332b747d253688bb09769448c8c5837b4284036cd210055cc058cb8ae232565e412daac9de252239384fd9a28fdde8f9120029639feb8d9ea36944292c1b1529945b620a5e5583fd677a8b51dc03bc9bb6eeeb19cf575701ad42dcf904a1995cc6680e5d4df98b71588c745494566e40c1186cf214a5d039251f1ce38f7dd88f0eb50ead5c5f37068fbbe96cac0b5791fb53c4a5c99c04c010c75e14d5dd18c5b1b9292727383eec392a314630eb1269bd02cbda52342f4d2e66d8aff8a5f6aa8d97b13c8d5ca5e188ab17f110222fa6878bab68749687c818060a62b2b49f63cbedb454b531546066c9889812776f573567cf7b7dd0e85d694d87b5ecf54d0cffcf49a94d1cb05d8a66cebe2271bd22dea18b3bf762a78cf7f68a0ae2dd273a4fc55de98dc69724dcfad8afb6561192a6735a5163b55f4126c258be948fd0cc6a108e645636ae77d40c19af12894390ac7a7ec3a0667b0f7b703af62ddb25fef2d0bb4ee99d4ae8837da316aaaf4b96f111f4e2e57fffc2f3c0ce89f9feb0cc08b6921a53f622cd4a99f2833ca8de2c45a1c68f5aec95997770f8eba47dab173d806dfe827634c9dcacf0af762de11ace652cae53ea01f10ba3d87c3911ccc3c2282e373c25d43842fdc534a3265e2f6f52250768067b0b6a368caa8e6f0679e24496b5eafbe369e0ce0374facca15ef12b3934d830ccdd30ced3a535f50e321d721543494cd03801c3857573765eb284fbb88e1ad9d6cab6e03a57a78bf29fc8a557139868666378410c7d2ad28a861884ef1e5e3b2073097e3dcf617adfd6367aedfe887967d4f610c811fbd433193cbc3619a4fdc64c77a38d4800fbbb82d5a6914068e348d4cec4b8799cba0fbfa9a41ee802f1748d580bc1d901ea7040cb0d15da8a752a0163130c10dc6b113d7e363b34913b7c6bab33deb1cd1f3256803b56ef23c786be71c54edd7917547d99efe4cb527349e6b41792eba57866bf0b43a221f263470a2de3dbf2d4739b90bfb4ac47f186e77b195c1a592dd1e045d9679bab81c1411b1e64b7b92a69afc829bf47d65390ef50a5f34238e3c09fd5d470697a828a15236dd7f5bd07023e5b2688810da03b54dc7fb4a5d2418a51dfff080b840d92c33772cc8724e8107590af9374a2e2b5a748e855c7d0d81bc077864c8a06540b30b1f04b1cc222750a1f989fc999e820cbd4e00c177ea9d4e3a0b87061952d9fc81e2bfb930507b89f925c9f81a47cce2c7696ba6a0527144f5d7afc49b87ae6cad6921f4a2af862de783de24e92cc7756a2e53b091eebf0b6db9dd744447d6ee69030c778293e98c5493904924422468cf07933302213a9e3b891e53d83f7c9c95eefdc40453418495d00b3dc1646c1c1f670d7f5c64f88c8623e0d3f718a834fd2ac32961682069ade7c06d92337a60647ce0964739829fdb9d1b7660bcafc00726700271600dcfef33198039a7f32caec503c192e92d816d492cec7854aa0623a4925dc41f2e8cc60f46059ae9eb19fc2e5a7730e999079f94423a456fb7214a6aee0d7165fd589657e97c2f71731f260ea9bbe335185b894079d77f30641cb3e7ada9140dfcff9045819cc7f9b81f612567d86f1fefedb6c9d626d84164d86f404d5430b20122060b2d00a10e3e449cad97f983f18c6b565d6446758b000fcb0aed772c2ef7e09ed675bb217eb57037754e392279132687435ecb0e3731cb9c7c6e302d54bbabac12b8961e156cc343bf0834111445d1eae85bd8402a5c6dce057b7432e7e2a233128d1a1e956cadc5c70bb0f40d149425702c216d882e5011219da4d10b12209fe321c957073f9c959b19edb88314abbfc6b409f0f647131247f5c4b47c4128fd8dd2fab061380a360980c1f9794599618a7755d93d21e907b357b6a34f2813361f59bd32d65db2a78ce7c369fe5cd0796c1d23d16180eb54050de153ab4866dc1dc3652661f46ae75464957b68df834db19be1def3e363f266cb53a397c671f68110aaa37f5a7508484176da0880adf140cb5aac2afe82b428d87bde7376c6eba98213e0e5295f895b209f67d0629a59c20b6147693c2f2d011a0266417984e48ba88a545fda523f3b33dc0f907d208d96b6ac17b3ee66395d268da4d79910bb71e636182d6fd18174560abdd13f313d1000fd79c4d554b9b6f8af371dfc8129c365936936e80197648834d7f93226b6aefe0b23786c87f748f1d2252847b8d5c9876c70bf5c0b3880454d92c74b9eab48bb397241c860139f90f43d2027140b43e7aa3d49b87cec79c2f6b77afd73c1ac153cfa23442a4b2afc6619ed45e89ad4fb4c3e6536bec8d03ac8823e14d5c9212521ba801e8207c36937036cb0ffffae8d5bb2b006d2a7be80f696b9969e82ce5df82381874d34fe2d0347804698dbb2c32bbedc2d62c4bf1a79f0f4f183f514ff39a42c99640c0df98e5913e205c5217438a68bddaec6b94356e73746face11e256294bd04bfbfcc79656be0af7b0d51ce0ba8ff558ea4aeaf988f0e815742ca4166229a7e56f247f44fb57bc5bff00fee1351a63ea258fbae849345bb2cc2de4537c5789322232dd4ea06f4ef5578c4407eeadb6a119076aef6350469a2b975f295f4b2b1eab4d6a45a03981f513ebc5669b2888c8e9a92768ddd63593a00c8dff9ed2f3abc3d87f91186e6f85a1f935cb31e5fef11b3a94b4d9f64d73dbf6b4915d22ab94aeb2cf2bdb61061d56645d5d9549a44b9c9d91f7bdbbe68ea1857f70609af9d5d1b9d4e10cb7b4718dfbb442e655429936e5f92989c4e828bbfe8cda48a38745322221a299af8a90c2687bc728bc92b975b7f822c074797cccaf976d12e9e0d6fd64dabfca0e652c8c4d0b7ce6728c9a889bef01d69faa532933460edebda2a47624cbdf9731744d13f56c8a7de548b9f38820f8bf6cd2cfb6d3540893cbf2f98a8c64112387d586c8cd17070954ca90101cc5e795444a3691766ef43878eca7a658d87e74c60e1f3d0254b5f5988fe02ae43ff95e47ccbfe574098158a7e7712a94aaf8da7339d3bef1cc533688721afdf2a48ed6123a3dd757aee8718820b98827f5240883ac637895acdbcdef3df27a4fc295e6c79497767322d13ac61ed0de9b6bda7b3d89f58b5f795fc6a8a14fbc79d27b066d914a551c74044d53baab6cc43af7556e4debd61aaf33de73421ffdfe104f3e7a1b4573c16ad37de2d296d4d2050da2f6aef537b84ae83bedf0cf3881aca7326ca651987c5850eaa0139cc05e51691daa7217927766ced2b5eb42001cb891912028138f1cf67cda0ff899eafda40a9db852f19c232fcd21d66a4100d517d6bbd89154d118a92532c004dbcbe2c98045669907eff85b63bbd7a9e39ac2224cf1baea3cb80a9e1891681358d1a4296ca0ba1e0cf5222ee6e139927ab2328ef4c199cf84a88891d64d0d1c196c209b0aa09c3cbc51260b1c7ed74352f83e501770285025d4a4c06179163e9493fbae4d0665df73c8a6efa91fba351121b2bb27cc20356fdd2d896d8a6e9d031a22414b857529af91a73dfd29c950470dd9924026d4cb4bce40691a5fedfd9554226be354fe75e1ba72124f91b618961a99b2c26a5eb854644de31207e80c96a39eaec60c59cf6371f8c6636ba9dd6fd1fb3869e06470e595ebed3b29fabc3d996b541dc653b4abd63b9f389c10ef1eba6a9be4d05583ac4d2206cdc1b2f2244cd77f9fafaef63f852b9b931536e01d27c8286e497e5e4f221d1f37ed799a2772e2f510393ebd7ca454f2de1b1022b63fd2bece5ae77e3c3577bc30e892ddb09a2f7110ceccce942dc1890ac20d416d9feac01e535713e56f85c9d004106405993d8f0ae84befd21b29484f2839a3bea32c7f83a3c0ec1cff6423eba36f02c8bb372434d4d06e11497a4d867e42397a9395dd1f2c376fed0bfa1d9528105226b2d1c373fd823633349330dce5a51cc888a163ac091038e6d7801626b9d08c74a0ee39ee3439f402ac7b1130d46ead8f68635bdc79560a1e50d085eb05030a4b49c8e6ce002bc83cd51a241aa388af5586d325cc3ebdb6491db859c07d5c02f2794417c07b2764215dbb22fc39369904bd7ef9023d8f865959c90f2e16e35d949a1c49f31b7a08a632740bbc116c27a5f2e4bc19d7710f3b33bfe21ebcd9065334971faaaedd4c3988f166c8a916b0c4b79cbe90a050ca6db3ba5192c57da0fd06d95777aa9271a1297f9b2c3213e8bbd02008685bee53a1587e490ec7664e4c8ad8b628339936bb512bc9735f5c3a15b59cef04e27d4d35eda3cc6a03b131d5d5b881c6c5f7e7c5312dfce5f4c44bb1658f76442474cdb7177e593cbeaafde2e27dba50d3a88fa35e12d52b1219fafecd88a37e371c4fada3175252a1f97e4e056f8680b6e0aff73279b57f1dfce995dfa646d6df0e6320567903114eb11fa1b3e6b4a67efe4ff51f1d9b44dddd48edd7b8c8af073a62e640948b3a57b83d2f28357ac4caf3058983b5e4e97083fa57cf7a5df97462d20384286c9491bd4816a7fa8a589637d62ad43dafdcc7ecf8adfe9b8fa8468f14527b16891e4a263248a4bb9b112e8fb6357a73c48b07e94fe632e5d21acc5e1ef5cae768f3ab4aa44caeae1174d05fe2dab93d77e2a509a165cdd3ae6b0363e9c1fc3d86f191f86d4e720c87794cd154d9fe8da92dc52f1c9e3fa06b8eef732990462e5b02f9b1b4bf7907a221438282a8b11938c2180b1d4ad8db47f44a5b483f7f714cc07f5959da4f180f29a08b3aed5bc5648a58dfab4197e2a6d26267ae3840afc46328c9398d8a35c8158de0c3538d15a8cc6ee1e1047d089526a0679ca3558b2badf61db8756a42dd424b45711ba6c9cc2d6589baf06f9d86399d4f0e3a52b570bd50a8c3ea79535cd05667b0885e3c6c087fe1620c1b90b7b658d70f966e946ce93a809cc2732ddc0f093d541459d5833bbc9387e078bcfba4f7d4b401a6241d2fa2911aa68a18227a2df4dcf176137767b22dd66b124ebb81b9891105a7e5ca26fe6410dfaf8b9ae76dc1710248717dfbd4b070b8f66bcc563f598c2f9cdeb3da74fda23f749d7b782f0a65ffb979d1c369c49b61d648740aaf048079d4e1ef0a088ee03bae5878e115b2f4185e0a7f097133c36f865ee74455fe179013687aa992440d6b6b67a819a9cf2d281ea705ba23581b59c019b745c0ceab6fbea013c4777170c26bdf8f9bc85d86925025da7d34c47132b8b8f7ce6ed6570534889369a606403439432939eb611e2c1a2a0f030912cb092bc080bbbdd973f7a495602aa2594229586cbca353c4c5ba4cc18b3a29655f5103408d890a208ed796a0d8eb655ce35d867112727eb663bd9482bc8aeeee2313a575d0e0f0edec7020a838558219c31a9e4f0599c21c6bab5a6c893ed6eed2478ca2edfafc4cbbd1c94a404eb312d434b3dc1e544fd8c82a9a3137fa3d6b12465afb96015829d5f2bbd6ab608b72960ff1005090e0ccc27da4bc0062438a92da040262af694a18fd8ecf3df5f551a74519ef6fb1585098bcc4e1b93b38d2e45f6be54ad39b397e2437ab4365af03b4e076be328af0e3086aa9c3dcfc6d190174c3a2c8e3e91a9c22d06240d6d4b9eab834d4188489ba7623987a7138906ab991a4a1519a2e0c0246f5f2c211bf3d995956c02f32a6469bd4edcebd7eb9f50db1f9817b9668c0f8586ce5d0470edcda5d70ae05761e6665b1de0a5bbfe4ff404e5a73ea2d221243ae98ca396aa85d531fa00c3721bfbe62f337283573e075f35e0b30dab54666aec4d1dfc84c224475bf2001407c59311d5ab17ab0cd9ba3599bad2fc9be1aef0808e43bff2e099c71f9b49a82fbc4f739e588d797b3e40b5571cab6698482d52d242e0838e22c3542f95b685523ccde8114e8f69b4c50dd2b8672652effe7c2fd57c7048a6bb2484570f07cf02b76b45324f0cde30d37986d4b5b040e7fec34daa621341642edbab8a48457d07f7b1fbe917c15867421ae2ab4f4ba62bc6632ed1e578a5785db223975b26edd5b7ce4e04e0126b3c11d639002c072278917c7875ab7a742549764abbb792efdd2a37a5fa6cf76b6fc6cf33f6aaa212b5cba0035c8766749addee5e6f59b88e8317ccf142301d24480c56fbf01180671b3d8f8bc7694439cd316b6604f63783ee3f95b10cabd41c9e635e39bc7f42eea9cd295a813a4a38c9086c9d7fa28815afce33a30bdaf1e662c570077e8735cfca8f8f924a30612edfe21b0f45e6a8d7b37fd1acaaad2b7f578f9f5c9dacc90e1088d2acdb991962cdab99c9b5b5604dd94e2ad75a6854521c1c4f2e918d2e5dadcc9151e15c6cd365ab61479f5f1e5e983e42872112c24734b2cbb313ced314105ed35769375a73f6ebaf184a826dc97902acc1374654dd68656a0dbc0a0eff384f9ecad7a251cc1c1c726fe5a7cbf9f859d89e0df7aee63c18052e0a020c65a0cde2737c70e8ef00649d22763159df0a0abfd3df711087a8f2b00dff02ffd46f1c1ed6d48f2c48c5200782e54d9fd3472b7e8533b4fc788061b1b0b4caeecfecf9e7a7ce35483377c6a8d01be8f38a6e03a3d7a8244a3ecba1887c22e75189953dc4ad2f2ec3d5737e0113f8cb96380656127fb335df21ff8b34e5b07f1f56c1bca14ef7388ca1600c027d0ccbfda22cea39cc8f5851cdb9144d4af386062cf2f36f4bb93c12dd2852b6d3d34eb998e1d1fcea4f5833b3f2201fd162d13c90ee6d940807abf1d4cd29ed910dc9afa044e9581facd250b47b11658a3bab9faa90a90f08075df59cdcf33ed9311335a74fb2b4eccec7d4475ad2f14f2f3e75c55825659fa935a12f8683087f4dc30b4f2bd6b7069da955eb196d3696ffa52e088f26950a84eeed41ac8c2b1baa252d8a892b6190a86bfba26b2ac8d5671ed716b0842d2612d1234e9e7c888b27212cc33866ecdad2013a74563ba9d8252aa5ee9aef7cf7823931413c46c3b7a8bc17ad0e8caf725d6d9e89200158bcd3c721fc73a045b9b8be228238a1be8f9a4dcbd2d1e44293663d2a2b09ec5a1afa01d9a1d06046e480401c7cbaed3b897f46e6bd6b73353b8a2e5d8c1233d3932ec19e683998ee59c3f0315102257b57f31ea70a78580f7a7505d9acb10078e8cb0762bcec4c8b7b9db72359f8c43c51ad3190da1da7e356dd9eeee671d049ba43638003fe93229fa0a6797909e1b22ebe0cd75f40c1f14dc70aebe1d0db357cff2171930a0a95e8de214346320ce18c107d4ec17148f3ff500e2ee79e1f42a312fc43c958333e531a76845e55c686585498bca779e080553257b1cf0db607d9ab8213853d3e7b0d86eed7f1396b724512f20d8f251a044956795da1b925b64bf60c0eb94d78549e63664a2100ae2ae45c894791d803a6ea8fd6b7879745e5a09682c4ba94b275680d282fd3ae6381bbe2bf181e9e9cb6a31d9d192819a9a7c3728b6bb045780c0c0438a38f8ff28e43369dae04f2ee1a0b68ac3b6ca4c7a6d6e955c11817203cc8a856d3f4fd1088ea5568835a7ddaea4afe70b748398f722263da8914180d493e6bf1b6f10720227e8c61045e6c77dfad6a55d2fc20b62356252075ba205cbda03fcd6ad7623b5e36eb8e7bbf35566629bba3eb280e8c31929d8d2d3cea75660c8bd127973a3d97793c322378589f838ff901c6ff6a2c76c2b9a37a3f427d3137e779a23b8cc56bd03895439f8fe7f8492476ee75f1a31e45e4ecb3447d0905c73acbdc2f04e4862bd4d4e5093bde4db810c72a1ba79685b205a576f77d7dd67851fc059c9b7dfb0d4adad9bfc7a5e514ab3b8e7c083162bd85f3395bc86eded88c55bce0f7a99838482f4238cc618bef28d4a7bc5f648b925e07f519b214f23dc10f801c98d635cc23ea80386ae32808699598c34747fc24451e0d19d11c09636c8c8c73af09af4ebf9b16658f0199fd966bba7656e863677a387a8aa31743cf769caef4255b7fd194d10efdbf3912f8b99ceabac1d54d3b9d5a78c33b1aa4fabe068049258d03bc14205236f9de96a39815d722c89e3f14f4de52ca97a6d1f2a16698372e64d186894316c947062397d465cacab655c1382a8a26f8fa632d4c983c3c30bbbb1963dedae87ad2eb830d1f6f621f669586eda317f56634153917da07eb22a8f4d5a7b52d3d17669b9fdaa2578d402d7283499fe2934ea8edc1d46cbd2b44a04e076f916252581963478f0f09234eeb99c5c32214736e4515fb6c141c59b0fefce8088bc638bae3d3e0baf72f1558978d9f16ec800121d4841eec6b9472630f11a491d028fbaa14e7299615ff6233d68d02d27219ea5c4065f6ec865dcee976f0c429719056f8d018f67e1d6639795ae5740c3229202b91aa438020c6b1397290b8b71e4c7ba43a4d20c7653ee44398d517da37b6b9166358516121132e61725b01bcfb7fbd768aee74c083ef1a4c386b06a72371a1b9710bc2c73b1aafcf48f61426243a9b0e16d2c78acf4727ff776be1c034ae13b0015b1c46176c99c93a3161680a859a39bdec0093065e43c405c396611ffd690f6bd90dc95c661c344f43c8432fa879d1584e75c0c9ce5b69887f6ed23c98643b9193933ca72865f34e8f098e3aeef065733a61b70088e80e2688ba8df5a543e5b59c61d2815825c667faa0d531f7e07a3c4fe67052d0a3fa545dbc361125386897b754719ff0bac4bb9d23f1d1ad828d51f46b598c05a179ce0ff3f5be3d826c41679c18fc964d465b178691b5a9e26abf28dcdf6f113e09ca0d6fa8e6901c897d3b12d7664ed30fc06b86b7f8ead5dd88c6309bc11a9c68ef72480d44b1cb24fca98c345dcc78cfe940d5aed14a91ae04ff3870dbb41275db474595dd3ef9f5615dda8e229ad77bad77eea57a0b00848e9d1dc5cb86363c2b0c4c638f669ea9ae41dcd7f01dd115adb8a3e17422c1277cbd37ec26d810b63a2eae769af8a6c79c50c0844b6f203be851f3fb1689849805382437967e26395b0331ac0c4f5f70cf44bc71c6d9717b55e598e93f834448e62cedf13a089b7eafaa13633cba0c553182c637cc8fa73068cdbd2c0e344d384682894b218f14953f9710132e59d129417f5628622c00faf9c0840bd6363983f229d30715299d6d5d97ed0a56f627378ae79640a6df7d0068af32941aa289f6a0e7fed8939b5e4b40fbe207426ccbc8e09637ba1b5e3c2275ee652145cc62c180cb3170d3bed9531cb8261e980c3e086acfe11b22643d96fc9fa576e424dd207862bd9699999558d58c59288ce15cb041d1af60553e21cfea0c00c7c6fabcf6354cc2eeaaebac83eeb23ca6fd33ba317f39537d38ddc0153b09db08044dbe83121374620891cc61c461ff2261b7b3798aabd5f0ae25da09f2be391786ca7d1013a82722095fa5dc6aba1bdedc33dc9351883f1edc3d150db1f2a4324fda35a18ca3b35543f39c8a0d76d2c74146fe0e1e13cad6be75de86ef39cdca996345e796f31380c4b86bd980fd132001617956d8d181e22789013e58f478409bd2b50084d1b46741de64e776465f5a99f96ef8d0f5f60f1bcaba27e07f3244eac9a0e21be7d70bd1efbf5c2a4666f926787b6480b54358cc69c2fb0f8c27c87923b50a805d12cd7915cfe144d7a2fc107f40cb72635061f701f86c0615c824475b0754f8cdcc02b7379c1eb44c8ab0e0c413f9af144d6136a813577b3757793e6543353deac281514e473e7073c2acefd0cba00dfcbead2a543bb4f81526a2d8764c7160b7d29fb911ee8fe4682e6e9a5b95004e179c58e5bee0f6459c859d4248804a2c441e8b164ef5b0edca5a7c20873342cd0ddee8277f99f9f35d857766a4b8a65116e72cf19476c1809ba1e287f2d7088dacbbed4d3c88d0275c41416a87eebf0143034e044edfd4bf1f14b767b7c6119bcfa1d982f85a286533a7261ec4ed1e399802038ad6e7dceb8f59084d06106858f83473539ceac5894cc833bcf1fd3520404a29f233d309fbc009426f85aeb5a5d7b09a1dc9389a20fac133911ef31f2b9b8a43140d2994a246df33402538b5a2e80107113c774231070f6dc9f029d195c02934d0b16282de1574da079d42e5ed3aa784ce8ad8c99e16e62d6ab95d7a71300088181791449fb49032e3f9f294c79da458c3db12b81ebf7306c59979a0e399150e3d5ac465ebd0e5e040ecdf4edde042fbdaf0810079d15cfe5096b955847932e3fd27c5b9b1e8afa0920a242d025243413987fef458f461e62843a5dc090c12dfa338ff99d57803189b5a762b3bb8bcd739c958233a68918365521834abb1db0846dfd71897961b7758289e10131bc630bce9a26267519c86729207a9a13394abc151e5d93c85a69bee8bee78a239e96e3039c70fa800927306e325bdb3ec29b24da02948036bdf2f68d2e5aa3083068814baddd6d98ba55a0f28a12896b1bacf713ba3be46f30c1c358cbb36a8cac5d129485866085a2e7a3e92acf1682b5042db2ab9bb1bb60165089943041b0b6a6750c587ea299e40bc95fb83e4cf85e7adfe0af4fa95a5415be172e4abe662b9c6aeccee2bcf2f8bbdc4822ee3bdf93cdea76c7b9954ebbd4f780c15b2d9d8c284e350c525d64d2fd1adef896ba5d0b3dd312d5ac6312f41035aa6bddaabac9f20fa5db9b0758bbcc15e66628332157ec03c66ca3ab8ebe10059dd873afe7e4e4e4d55835aa5bb7f9705b77182c41e752ecac60c31b6e5c8e79d257d9e73e08de24c8784a6ec8ecb67591dfddd94d864cad0c6f4c6db5833b4b8214012727086427eb517699caf077dadcf7ae1f993aed2993d2703b582ecc774e6012ff8a2ae1d3a758e337d8abf94d3c6684506f475af4c6f7eb99631ddd9e3cc82294bee91aeae2cc0c2104045c292f547567a0e1650493c45b10a12e00b5a26560015f816d29c23afdbc2cbdeb72218a0318d7dd8e0ec28625b25b23ba507cf946f45f10b8c2a05d47a16d244cc95a8c278544e401fdaba20d7c722b6b9aab04dae8b5d0723aeef51dfe1fe8810a4beb9343ba903317926e64d12756526b329adba5f89c80b5b04fb075fd5907fba6268bd3809c8c08e2739c50504c6bd60ab746872cca791c1f143aea928446aa53b9030fc16df197befb36366d9fb39ae130bf6628558495cb9cde345479d2f6d8755c3be1da7c1a7a762197383e7d55f065b6c9f82a42a4445b749b35db343091e8db67aa21e5ddc5d00478fcb94dd53a15719874403f6523d563aafcb506560d65ae91f5eec38301753a236e0aa4e11c92209d815c76cc1b0058281c76cd303aa51bf454373e57a0b1e8cf54b1b4ea7aeab29b9973b1a32408e3075f792753422a4cb4ffc5ca93614655aa61a1613adb1d5abcfa461c4be1d7519e7bb9e9bf6256d9d3e4e7f3202164b9991917127e76a2e159018670bfbb5ac456e446e20b7da39991db45ab46b04e5e972c86f05a9966e0f9e5b55b6e63adcf07acd5c0f1e21f5075896b6fdb00ad493167b427648b31b70c6f7154597b4f0b49887b895e1442c02615b4421f854ba658af2aa85ea397a24eec9ece5a579a22acdb4b5fa5fc0f11ca931609e325109402a7b35a8db50a90a364af8826fa0c5268b8cc7e4abe2cb9836be5a968453b8f93f0f4f53b5b159b9415942d48b79ca5bf01f2bef12692a5faeed3438fafe0546917b7315f254abe79197efe20d28c15b5998ccf576492f85e75dd495937f4de53bff11fb7a0b31373665e2c8333c7b309ffea7948cac3bbde4080178c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
