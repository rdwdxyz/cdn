<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7cf6008b2c5a0e20ea38e011561ea08ced1f74050b6853bd4df5034b9b341376e2603f3e157e76040475c5c99f050b7b2e817d03c3ba2ba16368eb80fe68c17f9fd222315bc210a96a288d431632e989d14e266e4064df2e787d05ccf5b52d654ca1f7782e8dae1fe6a9fd848db82d3987ca5ef2e2d1ea5691d451d20561ea3c0ddee26581db4dff8ccb768f69e58fa4ca4ba64f1d55ee08879cd38d1732617ed940d7d538d370a24e84f602cd35f8f492b2be443346c58da9c1ff70651f25e121af53c12b5cd0c6855c56f205fc1b0fc667265416ac6f2ff89216d83b2e5a59c0407022a0853779f327ed51073a350e45cb9d1317d63d278f496ac7c201ed80aca97872a427842a9baa5c220c64dc52a895d0b9228dc0edd359ed7f781ad789e3be9a1c24bac92138e35f0cf9c3d05fc16dbbf542cef35624771f7c4423e90a5974ae058ff129fa8aac6cfb406e6cb8e143f135ac0995fdcc1531770d6b7984fb8ba97b5c5b7d38c7f5ed6df2f7ef3bc4422a0849fae3b4effcda50a43f997109f1434e0256e7e452570c041162e0e0861b3b4cbfb66d77ea64410d5d36128122dc944a043085aa815e89b7dfc35d5fef52d6c491daa6754682fa264f03230cc1224e4fa9b7a877742a09db3c0578c36833b3b10afba7a50fd2c69f39848bf2e53fd5129862b5bfd939d970518e0f01ee121438b2c8616c5e420bae79d21a081f778a70846b22cd5a778337a916a94fa3ffc2a02a42ca51b2a93c76a7a5c706e36046409cdc8da23dce1ffcb7a51cf0facb5734f77b948eb6a1388d8e720815327837784008aa9366f3e4ae244927963043f7ebcba9b9fefd66cf9df0fb2198de9ad1703eba1da1dcf826fb08408b43cb9d3e47a195f5bd9dd4e83f86bcae7c9cafd5a742c86112736dab9bc753eb4945499f2bc99e1802024896070347470ab1d6eaec0e94ae6a9e9abe92d771ca5ed3fdbb8bf337a3a9a6b0e3cb14c1a9b508ccaf8f4a80b56ddd8efa11ae179459f1c92dbd78f71095cf6c1598730d7937d31ef98c2911f14a841a96c6c65fbb88a437b76204880b1d0fcc9b71af2262c4b2d0c1b4c8f738e29c8021be227cab23340be13275c79cde88b5a1f1e4018fdd5838e69de59ca63ab7a9132979cc8cb3bd611b090b7d6a4baf14e48e6e80dd9d7b826a2800c3ae7a567c4280b1c4c68bce3ddbc4d87a21369539cf2ec24dabd9cf41ef5696a4bd5b36966b536878d10505cb37df036fbea68fe8a0b58b0505b744b005e92d5bca3ede14155491621b4a386a29d21825a809ad69ec9187d508d202b14447b02c4342dd1818a8c8d194429cc674886ed9456e7a600c4fa2f81e8d7b96d0370ff388f5fe260b759fc33cbab97e91439222f883cd1f45cc57e745baa8884309eaacf4009dbc51ae32bac710972abc40f9190810a38c9997313445dc3d8003250b2c96221642282bdb915f401bd89491ce8be8816a51bbe720038cf157f322c95b8bc76b3b8237df274edacd2afd6c18244bb0174a6282f8bca677331eb1afae8274b599859c90af6bd8bac638dcb4d87c374b7e130777649be25d7ffbef34fde6e6868d35c64951fac6ed6330a23d74a151469b44eac5a80162fee21d0c92c21565383c1d8559eafbcc8d17c12f09f2befeed69a9f6d5544345dd59aeb655ae2228976eda3d92473c96127fe0be520f57d10d2b98932219aeb424a857db0bc100b68b2b41f7a75013e0487c9ba8dee58410cf085d3e228402935812602381e5cc19154b2ddc0491adba5462fb0276def32814d5753771be90915f930bdf171b761ae83b2d0860e58c808a6b1962156f353185901c280dc09318179f2ad2baa8e96a929da008444ec140d9efa9d48bfa5a3a4e0975394d1e452d21d97eaf833789832d51543cd79e1f11dacd66169bbd10e70a0fa7cd6bff00ed434cc052aa33aef67c05be9409fbd7be0c885d9788efdd96dac14c96fdf842825f7d85453b048032c128ff99c9d3b9f98153f81d8d7bdf9a7d71c4ba3af9ad27a2007fdf24bb52b1277bb22db3fb9eaa9f09e448606fd57d4bd7a2e533afbe8038a1ea162eb71cb572b43d2589d69849f32f61c29591d9417ea9b00ade6c58d154a7fad94edabc0c633e20e770f16a6e0d97ee2a12274e3f08a73e9562f7016c169d205febcc6162fe98d86fec331a92695f6cc2c93d6aec4c97327e8729bf15bf43457983a4f8a869ee2287775ad0e2cc4f5e71b18232cdd6273bbc499fb7866379fbd0567437678710a8ef2714dda7181be30497796f40f37708b36e5ec9c3605fb9126cb3f47d3d1ea1e19db4555ee806edf7388c7ad6cc52bf602eaecb3478243393203936ca030a2fca905fd44211372c2dccd6d6deb91d0cec2ed1c3acc8f7dd1287e3a104d8f89a9bf7bbddd7dcf742ab8e99b0fb52d0c1640686a8a3f2997760af4bd694cdc698972dc9ea63fbd941000b5765ae3f706a95aa2966abc8ed82d8d9b48cf2a7d7cb9962d52f38a72241099cf45983b7da997270103871cbd27b75e873a62608383fa21cc4315a0928704443c0a57a119f055369e29242c481fc932471943968ce074e1a1bf0a0039a8d35d30d03c12fb27b8feb177d224a0b6399ecd4c28b458cc86d3aaf29c6d17ebedb966b7bff79738c36c8d331c93b653e1d83346194dd726d8ed2476aa4508a02c0ad81a8ee8b90715e9d0775a385ed872ea45a4cd027fd7208f9358c98588f2395163cd659ace0defdf9f6f7ead25d63f58594b503e28e4d1a8bc72d3cc4a487f570c6fe4be7a3ab87fa5eea83dcf5921109cbd839b59b49c6aa408f382d8856731508f5691556f91e4ec40970b7e0d553f5effb5ed4e3946024a22791c8c2b5f0c0b54f1ef3c1fef8840d9d4d34218922860d026681d337715013abba87f79574ae1871805f6ccfd999af366832b330a72396576c3ba18bd0c24d67720ab70b079c85f6a2abb6f20f13051e4fea2ddc2003440825557bd2ea333e252020a61095082cdff26d41c8c245b880741c5d2d5fe9f7a45d89903301a9b80cfabd42776cb4eaf69fd73ce3e5df4b15be29863f463391df49590eda4e65efa680c4e7ce5cebc1c46383194e89d6c531facc9cc39c04635b81d21604a8a388a0830890f26170308304f3c61a0ae171f145bd570fa1d8c07a70db396686ba17757d202e372da38aa8d4c0ff8f6f68eb2233670077801f1ac04a657da7631421fd1e98d054fa3974ec7e417fec7aeb29efe25f35305703524c943e9067d27275ae8668dc6044df682e5d6d3d44b17f5fec0f44762f4bc9ebbe22d7a29dd1c0bccb33865dc7b07d34ac95b32782ee986713176b65a08e1e0462dbf4eab941ae29aa1c9c34ad8a43e48025b1ee005fde50c69b03eddfba994229a3773a3d1f67d2e5dc853203f3d08a856d4af759f0f011d01a893f8ce975363e8749c111c50009adfccb082a200b398e1b9419812c88052e181be3a037453923401f05f06aa6d31cbf40c5f30540b74fe891be6be98a25ebdb601f02c2b8abc8076b8b69b4db09b96127b17068937ad126fa9cac65daa3f0ea730ebc1a76816ec81fd303662cf9c5e8cd0048233e49d7779ad893798862431b467c8162cb366e11eaef2c3e1a184a5128f57da8ebc6a0c4dbbab899bacabf91cf712dea3e4875665871ab4d5bd87364cfbece93f69829a593cf4fb01ba3b0de06e4b6e93334bc47d0fc9696fc2339149d082bd14af90658cd27b8a5f62b061bf9f0c8401879774644265e38b3a0fe916e35e86ee5ae9f43f1501b07c15f90e1c2c5db4cdab0ce6eb39e8e64bc6cf229a95e5e3c235242d5fb968180f7b7c439fc2189bc033be69cc1627be486b28ff8a651e291910e2ec195ecb898e554ea444120136b2f66da7ba85b17f7acf4a16264313a5b19b363d51ae010be4220adcfbfe373dc459acd5efb822b2a2d1c4b5d7ddb2d67df16513bd8eebc4110e47943165e4c6a6c3551820f18443cfe1a15945e0f3fd974926910d95f7a4a3b5a8e087a5596c1667d676398023f09da0dd0e5ec91b45346a7b3e87eed056911d94d668e110fecdfd51353419593ca5100df330505023ca08c1c15ddd0a1e5fe57800a1949aa6163f7cdbe91a01bad2d1be04a1565e0a17a2650b97fcd969411a8b430c6dbf274f7c31fe9b37e3e09fb4f067c562d1fd7f31e58fca6deb9ff13c1865bfe25a7365ca1516aefee08fa186c27c1e660ce67ac7c3cbb9a14f1dc55ee9235696f5eff90a1d0177bac1330b960cf6900165646e05627feb85a7ebd435ddfe79713f58e949d5b1926c941eec072567ea35be21742f43c1adb55853cac8517604a5422223584b23acfa40617061639d48d9df9fc5749fbbdd8d4dcfa61531b387ff76cb68ee4e2fd83506c072817e60cd548c389c776be64eb5bf7f3f2058469c0418909dad2c86437a59f3a1d5584301eeec12797d0eaea3c17e0cdd559166fb430acbb8ce6263da8d813b20517d06bd6a24815d3ca31a8c5342b03a7f2f01df00d01cf51b3823874405a818cb5fd4931920b39a3c2f3db6a865342a3c0e834f552db7e02b07a4a60090113dfee85dff3f72f2ed84d49394d98f4a4931df7b3094b02be741484f0c136caff571bd458a89d72226fa8ae8ad3867b1b321d0ea3294bb9a98a8fcd3ab3356574d57f891022e70910a70fad3e26e22023cacd57ab2aa97275415f089e31225ba10190b7a5573225a5204497925c85c934d39372848edc23737d067a6ffae75448041fb4f11e1dda85d306091de80eb2d51388aa7e2e29f5155ecf21c177c200633bc60226df91d3193c00774ed95231b53889f703528fff86eb82945c94fdc57b914e79d9227e9f033c0e0685d4721be72c4cddecb106bb54fae41e89571a34762333e16b128faf9500d07e9856d6614c929509a97a4cd15e6aa2fad25e71985c27070103b7b24bf8d592f76fd8e94df5290f0033c0239e7a40fbf53681918eee5b11d6ddbdb1f7221a6716792dd09fbff643cc25c28d25a696f6dfddc840214a9b54cf551e150fa6037552d52de717cf362426145d1f2a431064b5bac8ede629f0b772db8dd57555db558796f26f863d558272e5e70ef3c61ed30be294b738fa084a939f9588914ff92eb958b46571a118d9eaf417c93e480a49dd57352293049a4773a077d8a1b8a4c24709bd8c3f36affe88b7ea0dd57a1a4d79186178be714742c486e45f91feaa47e28acc15a3968cf713e7853acc3c85dadba913332346394e268b5bf8adaa799c7298d4508401eeba158a24123114252c9232d94008653530c6f49c7f316a81070ea7a7124460c9cfcfc6ed080a6ebbfa0a98aea52b82111be1d489255a579debd216bce54427f310c4a2184ac8bbc91d643e6401e97bc20837bfe403abe41bfbd4673ee803fdb42cdabad93f0991b2118a827006ff4bf86a4961a7e92ccdfbe779d81371b8df77821088b27791eefa3d4d9d978cfe4463c2cdd48c5ae589f091d2cec56c4cfdd72b7c8e9965814c76af1411c72ef0ba8886a8358841d082f887062050b117fce22310b47b356d6432e5dd20c488433b7b5726b591600b764be7d06064d1cd5279b846a88b0fdaff1522d2c695ccbf71c1e0beb4532e86ce16fc9cb73e79a53d97ff98844103cfc9b6531060999a2999e837b06632b6188d3129ca33144ab4aeaf442b6801a41f964a979073c42e1ccd51fee7804aaa55ef02a7e24a59187682d69c57575a2f3571f63d2946b63594b2aa7c5d905423d5de9a90333801f574b9a4116fd771424b50f89de8eb2dad602a503f6bee24e599a844d4294ef7bc42c82e2b42c0e5c611df8dd627256b6958945d3298be87a9994e3fbaab179e3dc8aa69eed038843aafe631eb6907230116ac1cf7bf991af79413be3bb2f3935aa2377a800d65be04ede851f9ef90179139d54e89378d1fa4c1d440000b0476063a4f0449f56c4ac065b5310d92671bdcc2cc3773b7a309fe71b0ad0b12fb48629b981d71822a13289f8569ff5271ec233c0aeed8bf2a809320b494c1ae7f0623909dda579bae5a4c4dafbb689e86698c45c8645451045ce18e1756c175f75523b9018af4785a2afd782cc13df757d2e0f6160a8a7bddda8d6124705b6b5dce6fb99896492113b56b64a4e762f2c8fac6997cacc2db98b305b4eb4d7cfd129b1be7d3f3c0a0c92c9246b96ee98992ac250cb45721887360aca729c0d77c90ec7c8c3e62c2ee85e720c47120a3e51ee19ff48a12cb9ea1b77e65866d1c5dfe6b3684bc61a7984219aeda6a2df4fe992a926b02c51223072ffaab7eeeb3efd7cb5b4e0d9a9742abe550bb33716039661d53390d4fc98a6d21133f3283f41ecc55114be0c88dfd381fe0015457ee93f4349e6a3b27558994b3f83c1b78d917a331601d1f06db05d349fddb036758963bc73c84dc6bc03b8d9ca272d0b589b0aeacfb6928ebe26064e433db7a2b70d0026d6c0e82ce5e2636f2d306c0d074451581c415c05340059e386a70d8dae03d0d27733a804997a63e9cadc1c5b2eb394351279196dee187c86de855812c4e2d791502fbe407e61c38d9af70bf1387eb17961ab5780901490b831b87622c0a3a4da20079327b7cd1226c23ff8170ad3d226e931bd3e6716731615615830bb0ca61e5e4d9bc9f87da9976e7750527fe381b8f17ff05cedad1fbdbae7ad1d4d6244c3aa4f3b5cb2cbf90cea5fc12cc4bb386f0eb602c01a958fa2c5e5b8a3b7bb93077e3488493d17a974cc78676c52738154699b5c47ba7877bf5c9de08af5278b4b4f00b9e1b6d4911aa1e2feef021ac2241dd56f8b983befbb4643c27ef1977090af4acaccff5ac7615109d0f4836b42a4841397de3f17bd69a89d4987c9d5d6dc0b0d49af197936e60c076cacc30eadf8cf0dcc57f5f3a51e54c9d754746dbbd7fe465f8c1671da9adaf27147a52c08a758184514ff243673f00b11e2e51602b237e53864d3c867b7aa2af2bbbf36c86b58f12625817fd189172aeaa5fa0a1241ad8dd9a243737d321d995b2326ae003605a84ba7be825b5ce8a4b78f6b6143ee48d8ff957ea1649c55b1037380e2cbadf1b17f3833a8001b46f127cb3e29e501c8e50d7a1340a98628998708364ea4e59286d4dcce4b7acb3edeadb52e2d6619651def0d0690311bad0a100e576450768d06fb86a96f757ee1528c5e23b960628e663f99976556b36d7eaa5e58b403223d5d20e7e5489ed08e9961b99fba288def2fac446ebcf5389fe4348c0418e6adc57f1f230266c7861659382f812c2f46212fe1f7aef834b4a6f576eefb2ea64fcdaf4c7e000fe8805cf672fab3efac7befbced96a150c8d9e9a7a75db9896d787b55736dc71d909e8645356b96e8efc7506a057cb8ca25dea292bdae6ee4c4773cc576b436aaa0120c1320b648f352ad5570c512f70a6f6eced4cc5bfa8e9003d5099e299ccd96fd2cc096561314df6973e6b52c516f6f2646ec4d01a3b283dd6db91873b7c411ab3f6a7990660f4bcea9877928266fff57706ec616d23460e9c28a1c4e62b37d17007aba324fc4e6fda9b178676b13eccda6b7ec87e0119420dc7ea86fb9f1f9dd88b1f613fc9c4f0e9507ff78cce34ac1a07bbb4f48c003f9b674ad2abdc9a7cd2faacc6d6f86602d660c6b85a502e192b2af798af3319b82f9a0b632aa7022d248f2ae6c713b0ee8fb20b3923bccb70dd52f7d707d07aafb83626173c134b910848014d312f9d45fab6c1c3ab1d47c18ded18cc4f04ebfb9bf62128abd622ba1a75516c463702aec8add4afc601b4853a09aec690deca6d3c5c88a733758cc3c79097da2c78ae5cf00757bcc47a9e37fcdc0e6025ff5cdc4531a66c394c7e26c0aed8c1a3f2f0527aedeede9fc134ce63c6ef58fb4049786a9a29c44d2965c35fb75a9da2f3f5d14c220fbcd2cd365ca9ab658dd96a36fc785d356d1e961f4312b95688ae1dd95ab9ff75728a5604c055382e7203b4863b41fa2f15ce08c9fdb6d23b88c853cd27e0ee94913483f0722987ff35b978b6e64096d9ba3b60384f2e9c068b3721b28eb4298c61caaf8a0fc4857fba49589210cd790e5b245f12e98c143bbaebf79a4c0215ec97f0dec33d4cbe5e5543c5d61388a7d01e9ccb2c610efb28d83a3d38978cb5922731c638ef9770ef0baa682e16edc517ec391f18dace4c983e1f9a9178fa1a462365057e08312d52616126e5503413b39ef25366bc66d2400e266aa719cae4a3d7584410a19945bc4d0f268ee6df6f12dbe241e6ac41dcfc8bd7bcb3c55d169d7f6fca8a8f795eddbb7a100b0da356bc0aa8ab872168c51faa563a2395a40155edc706eda998700101137e95becc510aebd9535d762f7089f733c1da870bdbb6e03d7701f5e57bdedd140911b7c3a75497af1d5e1433d7c93145d6edd2ed7c68144ee00afdce7f1208a9e767c39e427e4312325e50a5a089165b36c7eb7f8578b2423152ea471bc051f1205b15b7b50c0ea32f00d5ad4c5eb41eec1c350c0877d27ca31934e4eb40819956ebf0135cde33b538bb46b88b851cee9b43c13f09477abc3dca479b243fc24dee7a3c9bfa14412b4b29048fd78ce62a013443262bf6f8c942d700c123a5d46ab7685b04acf341cb5c0e0c2ec5f70384cfbf9a1bb8834bc2aefcca5cb7a468e1b95a62727eb020a624ff2262340553ec23f9de043988c6b3b293d121b7489bd2839ec4a024af44246e1fdf9af19ab90370531d6c5599668f6c5cf03741d35c1c11695443337d6624e2ce61520c2eeec7a6535069ecfdb976090d45e40a452aeb8a805e5043414f025b472b338e68c56094382c6c8f9a343d57dcb0f87d2196fe9d94730c618b321ee542573d438084bfc090c4330a885a7d07339c02447ba5de4cd309c7cb362d7d1aab82ecef9a178cb762cc9a17e7cb66418272bc70f66af6bc51bf410e7dac58216c30e9703d77e75a36ae406825915e67805483c644880439669ac4199a03a693fd709d1c693715c25df4d6b497f537566fb961ea0dc8cb890093b31dfd4f913f0a81953ce4944d30b45cd46857c2ae699d7f93ebdea2cbf1d2069c89747fbbff14d3685d8b1cb4f540337d1d4d5abd72f265748e631eb13347ffa4addf2c85fd611e2fb9c5b966ec8dcd3926f47a1f2dca91132ba346108bf5a5a2c91271f04cc41bb738898ba26e1898f7ade7067144d3f1c6c74aff461b00f2ad99acf0f1c5abe026cdb4b867de906fdeb459568889819054cd9a634c4dcfeb15a7a0da19b56c197cc4aad5a7f486347a0294d656edafa89a15766822a31a352a9733529f94a08e19b78392fc0690865de4e21337bb0989d2e1c9eb50dbc5ac4055ae943a0902f8ee20558564e65158a1487fb076bf56890d960ffea4b18ef5cf66864199fa1a1e8804b6f86ac5c474c99db8455c21685cae643934f20e9b06566a7d24f12d4e7ed46feb64fd6b91ef4f355a23ef5db4ef81a28fa741c98a0b6aaeed598156b6514f08d3ab4b37d9c0a40dde63012f74e6c675608d71e1042d5497f82e4d2d5a2e0e2a833512be4cc176611c0fccf21a4aa9d104f96f70893b9a09a57c7f718a0efd70701340f4bf97644cbe1725eb4cf6cdd381685ce2aaa0111118bd1059d4369553e71786ee0c49e6910c768e716df810603a6e2263f418ac8defde1b44dc24eba86b9c493f2345cd1effadd8e1317dd74988134faf80011e08ac7372d58cd75b6ffb812f96c8205b6bcaa255381367a49fb346e2e2dad6cf4f675e6586b5823ad3d90a189745d4fec9b6f007a6bb0cf8be96e8f3c525f48bbf37e92938bcf0c54736de4cef930131bc785addbaef275a6849065555e44488519af6a3fb5a75e0eefd640be78b7c65ff6a9bc3be049632227e894a05b106cd209a0f060e45a2743f41399893f315fce2957f1cdbf25b9a66ed216e329b64165d0e307497d99615a6726be62320c27b55c629daebfe3ab9e7c5353605b526ba8703b31ad6d94f5f594037f1e6b3f755b946d4f000f64cfd39a6fe0a866c341c488e0ad876ce1224369904ae7d72e2969c32428d159ff80f018b3e049f65f0a84f28b6a79e447ef45abe16db023a3e569a81c81543b7e42d53da0f736f55ebd7a532ad7df51ade57d0e1037552fabc5e3160435e425e69e090d9eef976624f38f938d6e212130ccc33c7cb8d3e4ffa13b4b29e6b6938ade6f268057f674b5b8ae532e8d6d52a257db878812d63d6d99e6540d28993ddf5e25957cd4105c62013771cce8cf4a500cb970c27f08fce377f7a428c7630931f042e4509f3da410ed6781b1280b69134ed09fc054faffc34ed7cf6c86d9b81fce148f917dc08faf01c3f9d27a1fe63a4cc5eba896af63b8578c41911e6fbff9ed5b4d9edc6bcb782e75d8dbb14213cb0cae9e6cebedfe2fbdb57f8dfc76279f1505353d12b4a8b2cf532da1dc49340435d65bbc6fb22522661e9d3ff5ba5f3ffd9d05dd9a8878f88eafec35452e18a6f884bf6e6ab5a83c32ddf21a14f1e28aebf92db90d2f361b790a6d10aab30f4b6f66657cde9d644b58c007fc33aefa5087ae48c96f787f8f71452b072857460cc77d64eeb236dffb76a695640408a3bc0b1ad7c4a61c6d722a6707ea41356b1d024212dcd9e42f642050c47f64c97eb8d7163d818f8438d5873806935bd0ac9c2ebb97303c024d8c2f26b75a64e81c352865ee2b64d8730e314e4fd65d63f1fae04e67de6d82b3fc7c7195c736946de1ba3165564ed3b4997472c237573fe8eaa9c61dd955e68dce22a3cdeeca980e3ad8ffd152ffcc1e9d51b0b1021a99ef77aa192a612f1346633a020863af46eac438f212867af753919fcdb3d827620688c68ec3f6090a449131eed3cd2574e758fd9d0bb8886e68e44778bc40ba32f1eb56f19c331d331b683705f9d16c95e6ed34c25393d976b2a95e42e7fe98656f8a8f8054e27202a5d6aaa4741d0a3d2994e3f1660fd07ab2f6f5475bc0c4d019f38e0404b6f3ab3e0bf6bea5dbda0b5cbbffaba39eb6ec1d25faf89ae181b4aaba14bb588cc5d76da5e4c900bf485312910ad884b7c9e1c44a065b3616e6e1fc0d8eeb3794847884dbd9d5d729543525b5f7c83a8efe635c371a87d366572d0a9f3fc0207fdb2cd674e56849e90728cfda39fcf9e15a031f118d30e863ad3f5b7fce97f9530cc80a3814578349ed8d43e0becc33177bd0ca6c830673cfe5e6788536c30dbb0b07f47ee33b98b554c8350465ab0ec5315e9666bb7465dde3b2b6df80399bb28f5ba8de7ba18bf7ab4238465fd96fb4b631ab800830d09a7bfdd51544df794e645518058cc2838879d922a67e1d3d9b40d841168884e835c7ab481ef08459b631a83f54cf467bfe135ad8634eb722c1bc7871381ee231cda10917560f41c279b8f04b180675b237bf3685f8a4008f69ba1d3f05f981ee157bab86b819f50ac09a846099741103a2eeb1889fd981205fe14259ca5cd2084e3ff502385fb9ff55985fae129cc7c676b0f5134a193a6b640d6b961b789db85ed25f61564765f44ecf28ff4d7ed0b764c8e7aa9fb4e835ea45157b309bb5e4877bc249bc860181ade60e1118c91d00eb8c89536063ea9284e64734b65ebf5fbd47cef89d8e414275e0cfdb87e803b56537085ac213846f629a09cbc81173d83380023988e23c8c37e63f1fd89db30e64b788c6860e28002b7a92eacc830e88b982872d14dbdd0f713d8f706a4988ed4d133abfbdc4b7d727adaf5f7f39c5d22a2a0afe43269a2d1848c5acb6cfb3688fdb55357f7c25eb61c7f9e0f49426e9f81982612f8ec73bbdbf79941b468335fe8bf99175a85f044b68e8fd2e08a140d7c9f51e60cb88bd9a5b4f5ef6ce26067654800a50ed2a41e1a55f0d12c6d33117104647849cf9fd59f94156f3c2aa5afeaf122fb596a8e8326956771481becb4c24e18a2a2b9c90fea46c19b488c4447e2cf25061a3314acfa8e6ae48c3dc0b26ee6c20e373f4002b4cf379e2b8287df01e57927aab30fdb16238430642021565b88d7d09f9e342da0e63d165595783cd87b3ed84e5d0c171e72cc48646bac440fb61501ff8f38cc67e968301ee596e02a3a0a57c941439433000837e60e3d9e09de1e3fe05565dab59e0e21551953988ddaaa13644ef466211b1d94a95f712ab502c7eb1dcd0bf94e65781cb233ffd2269adbe6259b9807bccc9e03529b9ba1aebc4cd560f47a5771654576b781d18ff2acb3f3b1ac68da9b5865990448963d8bb6b48aded9f64f95e26be98afa7adb76df939978a4125442d2b74cacc576d94d997abe6d68f3f7c30f705028599f97f6e5a6fb331c283be636e604627b4d345bbff9440f8ecc9f928cc6268fe9eb97e95cae8f2886b4d5de3847154d72510cb54248ed6a417cc197a2b6b26d522917fe1aa2698e0d1a5da08880ebbadfbae0ae14119adfa9d7d7527462afa8c3c2aa505e62804f6052086f6415ff36b6dc73d690687783e225839e546cb670785717e6fe5695f9d92ca84bee37dbde56df1bf75b64851bf6fcdaddf4b38530284e5b5b1fa6955ea3dddf64858208852da825a6b8037fbf09cbb60d45d3e2db47d46418aab30642db494aee32b4348f6b8b15be57fcc8859a8d1afba2089515c72d2e151e868e59d373a0cdcb4af8d101673e606702a5ae1abc2c17886e7a8fe496e13a4146334e142bcee185d61d240ef5fae0f16b37ffb4acaf118b9890fa90e1a2ab0e9eb6b304158e65e7fe72c803cabd9aafedde0c122bea4c19221be1b0ad3e74b44cea46a77d1a4d8e3980aa99b4957ee61d5ac8a1944e863c6dbc8c88bf3fa4c19408dfab91bee527e98b52721c0deb7beacc43fb206a40b54e82286adbeb39acbfc73d2ab0e351e0c2602d8a176a74fa1e8dac38b22478f3a218ef9c602ff87b4bfc7520df64604152d00f7afc76287f12af4590c803a9513c9e59830402c91ad41622b616a939b68ba6720aeb0adbf33625dc5a9391122efcdba18ff6447fc0be4daaae1522aafe18968e934c3d48cea6ae100f75672be04bb07a643d416b0e4c7d086b17c1de85ad4cd9d81e6e25a4eb38db8b70c4f698cf789f7fc0c566ed26d0d23d94625138128cc3620bfb9151397439a1b672d05178800e98396a271762398bc7a6aae3d532e2a51abdcdce49dc7af8d7f1e72d6eb61f9dded1f8c2089ef259f6617fae6612892c259bddf238058bab9416ec815e1f744ba25f369a19370274a8c16ff38857cff09d1892ec819cd59ba1a07f1453634a5605838a7998ae65ff694a72769f7df6475f2d395c958e1b555a0523084ea1c584b02bb5285304f1a5680c8c8819d0e3839c4bb481ada43267c7102cbc0678b2d6687bccd4298dbdb5a23306e745fea407c83b99206e283cb346bd0e5de94c46c6a01fc566ec473ae8ae41132ebb7c13933c36363f0531fc759bc35c4f58af4d4240102b5f03a229fb3b60a27da611b53f4a88677f5404cef9c8560d42ea8185c8912c55a17965e45603e2708b679bc36691218354128871ea18902f4fa53954d14339490b633a8fffa8d25d203f94de73347b2c985e334e5524f98771df88cc8bd94a76d0521569b749382f90293ce3578f8fa68999b41a3c01f0546cf964dc470d396ceac96c97eed4e168dfa4dc0d4f9bbc3b985443c4a28f477c9131d1bf0cd77953f8c5555efac0c9f49d7a570c7c039b649e3261279f849a4f7f7c2d2ad88d2693cd24d3c437749c3822d35e45396d225a56e208cc5d9465a5544365f14cc7307c83384672281345a2a4e9304617c6cdebca04dc649aa4bd4f1be36093fe645485bdb6d88cfac4e0e9a8a09eca1251b9d9837321eb95e933c9f465f74f1b97920666de7df3a3780dae29feee7057ec8be318024b9f42c136cbabcf41ad4c8e1e1cbea119f42fa9836a05f7000ade10bfb61a843b8c0ed48f9d31b8b7b1b3ce9c05e77f8909c8f5a5b0afe4d65e087602dc215eb017646baebd5127d3787542161941a7912064245ab914bd0ce4f6a4bd032a5414662a63f7519d546d0bbcee8198add05ce918e04ca6e1c7aeaaf8a7e9037873f1bf09d3cd82ad890f13b57b198edbc5f08eec095022683147a48ce2e33ccd63b4b4d264b73201617753c517f2c6130103aa95a3010a2429d102d758bfcfb9df9a2eee50ef3f93b11b908f254cfcee8568e7993101e904f5e96e1dfe533b02827fcfabaa3ae6d2f8c17ed31f2646ef62c78d72a691f2850be07f21058666ced4598f2e13b064340e6416c077fb4218be27f05c895048b78b421a47b7863c77c73dbc1f26cbe78c06cade84fcfc150ac8ca3d679509c3e7b68c3f7fbd85b6815907a809ab6b03836900bad1883f21b8a1229ef3fd639e7314b4e418582e4adc81040c6a4e8ec793055ee68532db4d2c55431ea38a545944ac5376385269d8b4fe4a66ea49d14cc2cb035546c1206ac06f4dd979ec7fc4ef9c8e9526769a6fb02789699554d3d1685977c21e367b9fc528c5a773d6d500fb4843df83e231ccd7ffe34716932068dacc26802ae45a0af16a44e532b71dd63bcc89fdda2c619a2dec13f5febcb23ff81ce6411009cb9e680cedf6a17625a997058d980fd70cc18a3c228285934b3a27fee71881fd889e1a9d6ed2cd19422868e9d5abdbc8477378c07b2dfb1d4a8f96d22ae53d69c87274a0fd2fb7a4738e1c4a5b4eed573b2e8734dfb51190635f71f8056805ea54b004587cd17348c22a64d3ece0607f0de058a9be2569b91bf8863499facd2c8c48d0931b0cd3db28727c9d55267022e00087ff055b0c30a33cb23e0b1291474a3cbf5d59e63f56fb2b67842012725facda42faf6dbf8737e810267da8f04f8dbf18ffb603109cbf78a89250e9e9981acbf91c230cfd3895d7ebe4986cabcfd6434d0a437b91009562041fe0676b07ee0b30b27a852170c1a76b4c267add881ed9cd447b9f6a759f353d18cbf3a074e8bf48cba15cb17ff14f0cbc26602e542c408bf40b3a619c28195a6b85796e5b319f35702010e2faef16459322a3bac6876ce2615031e3ada0f4f037e12a7d4b7439f23460152dc1f29177951c2fd387fa446d37ca1838e4f475fa117e63c55f4cbaa251ed6ba62f1718010b1ee03f56ed19fa036b7f5d857e40b222d391f399d7e720c2d45035768e5e41fa7bd0e8654572a004ccd900929fb90093d3c37efc3879bb6e00b04fd9fa42131f1cfe11ef1f3be0f07e6ad947b8c81e77c0f3b5929f7db1864773af4c0812bf7d580de1d0d9cb69a62af03a25a57ee16a2a714e3725e63d672f1c7296888849fa6b5d127ca5d54420e0760b22383678a70489068f1238aab7833ef907ce003685bd47cfc9cfcd7fcd06fc05960268798f1a2e7052e5af533976284a282f9b42b92f1d9c43baf86809fa6649cef86a35d4ea7df294642ebe083e25014f51601bf5d4bbc34412763f4de7c59b4ab1892ebd2647638dd9f6f6a4e87fb4a5dc2bdf4b0b9faaa41eadbfe615f96616029571891c38dc448496cbb2f3d21cabd560fa35615576b2bd620f42fc6faf8bdcddb1f3bb8b01fc25719c15908f3d5331a323e9b2d87feb7f6fd548073bdbc793e9d2db9e013e9760a0c12ae6375c4cc964953a7afd41674715307059cd193d5708e7ebffaeaa0b5b0b6be8b3e6c594f1ca6dd13a86ffd619b7cacbafefa8f3629689a7d2cfd0592c2aada5041ec6c36c8eeaecb241a8c627de5934a2edf386334244b9472f7d20a894130ccd1a4d63946efa08a284f3488d68512ea7323cbe21c98506724b1a879b50f030b419b5b2ce7001d33bb6bc79a390cc376104983c1773d8cfcce5e929a758e5a270309f99a543f0773d5e8e6d03039382ff3337151b34b608fb061955f270e072ff3da5895734152fca0843d836bf6ac72922ec5148bf91b6c664f4fed2c349d0c5cd4a8a1c580e19dcc870518fc521a202ff0661e67de9450d851fd1c3f90aa04c1f30d49cc1629c23084da2b958c862d56658a4d9a5a14b54a539f27b161ee2f6ad8ca02c3f91d5d0b224af1e71843f63b0ea01ac9f27ba5a5bbb18380a03412c3dc4103ec8872c65fe64cca01c584a1dc7fb9b6f1ddbb96735306a35e0df52f80827b7f7967f1edd08cc98d7d324b78e860d61f9682f524fe1601b98325d80956f3855a491c7df6099831515c504063b6764b4a00143be63d46eeaa5a3adb19382023d7a55d32b2bc87dd180d3fefe83d801ddcd2e3130a6b2202e610e49b0094e56102d66fdc59de33ebf3d2ca81629ccebbce44978eef5fe29a6b4f6a00db0995df1354702f06ed5bcc435ae73b58e0aacbc053ea7daf97a9221ad3a10f74b85b10f107cf5e978289f10a34c434366b572442303fa3e84ccadaffa221f9b6e27280937eae00310659ad1f611ce0609730a70bc6dfd729e8ec0018a5e359f0a99b4a347c92ba3b4bac459920b6735ae4b9c28a46052f351afef3cf54d5e89b1752455d859956285f7fdf20e94c28ef4f7b9d9a47d53923232e3c8921c357b30c84343214aa8fb783d2500f1551c540559a92ee2ace06d9944736465406cdbc23445abe0fa0463bf5cb2de4d11eb3c37f7ee1cd8c4fab97c218848c167e7b2ca4a6a491cdb57de0ea1640c092f4774618d1c551aeed26ecb5732a02043a2fb7fe6a49ea61813750d1f12597dad93d582af30e41aedead2084129b1cb548c7f6bb3335212ffd8153a997c9c67d657e7097a95ad34b99153dbaa505855b82ce3c402996b78b3c248bbc15545dc5b2b07e14c00a3ba970e5e239afd23e3d6b3b0a2653e935639943e8e3fd0e9ddffd8305d92404efd3c659ed7bc6e033e3d0adf63fe54c56d1e7ada0b885143865442485cfc660cdbe43c29248df108788af90970ff268ac7301b9fe52e222b7705381a84f6085222b771b0f9da48eca36d500f20bc3cfb9b2d9b869ef4e7fb804c62c37a91f5ec7383d2438126a605d4bde866153ebb7481c8fcb6a718c38f56082c203de445e81a1fb773620532a5286cc03195649d83ace1e844051f9a52c1607cbefb057d1d894d37c96d130342d4a440138d151d56dbf078f2a3e00ecd9b2f820281a27790c53b4546aa00d397edff21b2233375c217c1cc1717e36275c4e2f7c1f81feee77b7276617d1dfea99f7fe5791817e6bdb62dd440e80a8a0de7cafba39cb9b9de86fe58083bf5557a025165e098405a347eac759ab1cab8adb12dda2c822e84b0f4f85b5fb23f0b646ad8591a596c563e2ee00aca055c68bdda90b71957cb3242b1b483223820ad3578e4f5aa4c99d1492bb3edd2c13b29df8ca7b9a3209eb64c89c5dc4d4529e2692fe2f8deb24496cad16d3ea8ac6d75dc350e9e233ee725fbd6daf19f8d3d379bbc3cd29dc01445f48f70b25f66bd31686f464134b7e293c822a317da3e2ddf6fc1499291e58fa9ac9b127ffcc3924ed030c2317f3c326f4d2cfb29c59c4baf4c5d9a7067c2b97ff9d432c1d6443cab6ecbb22025ce2e6214278df73baddf7d6551cdb052f1f9e18b260d224e150ee0e2df0e50d009ad84e8d138cf54f2d13e646e228ea1e98f1898dc6f276a6360d46fd8c786341df8a476d001f483dab735b98533b703627e049dfd9a3f8adfbc0d1d7763074d55016174b7e1e8d0ed0bcf7fbb90c4eaf67b3999ae3d2a8e1761878cff4bcc456e9eda126900bffe0e7cf394c38dffa18baf727199d5f8c19dde6fb5cf4036504bad176b8a98311d96d0eadd598d633af981c11f9449320553aa596ca09929a95870e562ce8116e6b165aec0fdcdcdd117fea38710afbae5051c1bdee5411e4ad568be4b08345417569d00caa209ebc6085ea342af3fea4fd0fcfbcf75bf772605bcb08611583b52aad185c078dcc531538df1f785c2abf04c37ac8c6dd3326d30ebd713214f9d081866c88ef3e96c646ff092a24dbd61051ce7061ad04b2c684e2cce4dba4844b9328d1cfcbd8ac47df1239637829b5da7cab0a01bca0cbfef4cf48bb10ea132e8573c78fa64b1ca052238929249e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
