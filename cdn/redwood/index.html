<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d762c2c95cec702dc4cee8db21a0cc4297a3f7f7b82ac01531c45df65a47770a45f1c30791bee958942363ba4bd00be0b3890d8178fa86cc713ef79abe5a5f00b3c5e545df87d2e74498abe1a0e2cfd93fe11c8283940ad837bae3c005fe220fb0fb232d1e5efa40d1d6bb7e96a388a0f6171e50cf0d0d0b7170da5fa229aee13f8f97448be7376bbdf71a1823437a37575c8a1a03d303000a6d38545eded75fb01a7d8d478d595dfada9a4c1e24bf68ee3f3a9a34d42cddde5bf61a02ab6d29980e42f2cd3744e910b15b3842f55c5aa197ae53d948731d03a9f5bcb151bd8fb9589c317b0d3774851e8adf0ad2bca8893fd514ea83fb9fe08d9fbe6e709b4c14479e7ce021833409be51e51774b8c166d585600cd9e9c80f8648f26f675c00298062f5bfeebeb1522ce3ad2e5d6d849184079eb0445303baf815bca5f8a6b642471371789bc3febd67e6890b89fc72dd122d9154386a3770b00696221df37d69c88a5cb8a49c5b07d1b102f94616486c1caca33908934267c04ea8632fd323d0e0510f2eef29608fc4534607ebef0d4d5f2075dc8d35eca24f3d589348398a49611dc6e453611319667b3d1e683f3a2e0a61e03a56b6c40048d62fbabc6fb6dc5d0c9bea77102c3e2a1a8860aa6441edb77234f6d908b85240cabc24287b54344315297adeaed797a712f97129c5c50717dd825da49c463bb703614386bb4a7691c6ac32b19555b7a0b090bd38c7dfad03cb6574437b59b175f8e88dbb4c3fef6966507abc891cc100bcc333c9c196a7ab0ec943cefa24b9e58a7d4ba3dc4fb5008623ad3d0e921e34f07de1d21ccd5c2770b21b632060c3ef51b1e7bc4beeaa3d519b47cf55db5e10ce046040ab8fa55c06101af5ab5e6b76cb97581764c83a25333aa6617405ac8c819b3c578a913e45e877977660f7276927086c8e4a27303da294817be643426c54cb2a61871a494ba8b33e5a4ba8cb0c58221db26563702753cb1cb0290b33f41cf84469e937910673c46f96015b53835edd6929658b1f05a897a17e9cf9138cd535f56f9fb48a78513d230946d902669e91d0d8f4b04330e45717008d9fe9ae7d9528348e5adc74e556eea5cd6381838e0dced753fe75010aee6d3ba3c559d701a4b288b9b38d74c7f2bfb3d511d92026788d5301aac41d3619e6aec88812f028c3e265907298a8391fc85f8e94f6c7a3237e4f1178cd154417e678b266ca2cd8bde25cef7d9a05269e97eeed7a4ecb0300216b0ce66cfb71b9e3c4ece3df4628385afae515aa20fd62dc4786f92eb7a9bbe7effcefeda25066edc987170d574fd91fb8f0c4ecac0e31cafa50645a5374909bc9aa18193fffebb19b58b17c5b6ccd589adbf2648fd8448625aa57838767550004b1390fbf3ecd6d78b054201422f24c8e0bd9d0ccb6a647635f1eb585cee67ed9556742c12bce4b5b5163ada61a07ae0e7b6acc0eef93e1016061d9e328f904a186b942c0be5a809e64a260512453a89bf34a1b3fbdac9725f58ae008d1eb05182c1951adf7a3a893946328ff49e02d87fecfaadd05270ecfd179cf2193044fc4083e528271f616a1d41440de3c30b871c96a66d5149f23fdb31c5aa06e045bc0b5c040b11a8bc41553b0935afecd33d1a7a012fdb510955ca8be387ba6ef146b6113b3d7b66daf182a7ea0c5abc016182209e9d86429be4dde07f888f1287a40c1619ff5571a01186671791d055fbc96faf502dc286cca68752c0aacaa0b3cbbdd92b15277bd819a2b50f9abd71e01c5472b604b73b1421fd57ce48eebfe1a5ce2923ed62753f074d2aac2f564456ebf9c3ade878224ab6f3b0c5890cfbfd853b1503201836591595a48e70262bc86ceeb8714213fe1efdf7559755f8021e4d7fc3648c93f4eb4eb8da70301547c890fe16af30c5c26df6e2efc9be9b382e337edc8fb91f48422b990901b53324d62df63b44d459c4778aa6088e53cedad83abeb698f8ac38d64f95f3e7c90b9c99704701cf8290f7889b30f3f08140d0e0b1d03a70c3ca4f53b49442ec68f624e02f638e5a9824d8e63f38794fe532fc6f458d836785d2045c26b280f0eed40294f6476b0a2910135908d38e977939db54ea0c521cc3f965efa4ad17f0d20f0cf3fec933b940cbfa5a40d81fc68240bef6ebc56ad86c5fc9798912de09931beff16423d774ae917c9c045b30c1b6ce13dc413bf2261d048b3deab3f5685418c11e64a23ec9c165b1c0dc95d08ae4adecadd30ec314e680ccdab64b1389f31185226a6367e557b977bb508943b1793022ff4d83c1f6bdd6b10e793886f9743e7cb0aba668b8e7565347c8db4185aaecc1386999549b89dd32aa17e16c93edb72d009ff23feedccd31a370d7b230336b79b54c7b368128aead644b59fc9d043b798f38aa3c8b4e757be42a8da63e31694693f95b05a22d249d8062468394aff2c279665fb983b59fe3e54fb317c5e2c35ee9fe73fadf36251bb512bbd5835a03480120a02ab80217b4df5f03bcd9c215b34b5bb09a82815b65ce2860703dc9438b47cf89a36717fc4674c640181b0da5823d4ad19dc61c0ff2d5666c7fc961c87c9b6535d19fefa734fe4ee1a330dfd922ebb8ae15550a223b31ccfb601fecc6a5867bdbdcc0e4e0fec76213b9e0d2ad311476e81a7181b4ad890ddc135eab3a49685b053c342d92ebf930b609c11706f82dfa2e4cdb41b48526c6f6f471807a4d2b9d8e6a500cb3155c25953b42146ee5d8b2eb1b50184ac01be191377008b9feb7eeb5d308d7c14d1971097284b894badcd8169484c5b7b28e7cf9967936650b0d79e053204f3bf5d2a1efbb43459bca45d23a783bc4bf49afd5d8c20f9f7ad6c7bf93e1ee5608c130a735527204f09bca939ce86e52823255c47b3f1ebe9f8c64051de891e096424b3ac6b88083f54b29d1370f57c92f764053590d01c8f918dd29871b6e12a7f735110d9fa9719879be16d713fb11561a4a626522f60fd4a3008b8c21004cfc5a7ca95668627c9d678e35f95e50ff536abe9c03e86b82eeb7158669da0dadf39d50b57f621abd61e5757b0d31e6be329b15f7bc17082b33158250b784eddfcfa60b561195df0e3828ae5f2cd2198be13d7865e408605502e875cc975e3c4f7ff689a293e0264551737ea3fecd81b44ae8c18154d7fce194b0b4f947dea621ae7c5da27255860ed97510aa770dfae398e7aaf8aa4b4dc0519d1866fe2da020a135deeb9b89b8d51748c909ad8f71b7956bbef1da7369843a03c9cf50bd666c0f2c205a0500fba853b494d825b92e0c5c19528fcab9b7675c451fdf01e21bea2fcf84ff9a42abf84963ef2a7d691c504836330e603590514db6800a7f30c479dbcb6f451b70b24c935fa52420b0e191a893b5ad7586b46b640d3ae87da9bac476761890a36eaec7592a2db81ef2b5c99580db2164a0c91e28d3e1b8b7275921d3ec6ac5fdf1a4616d5e22cbfc7265e6daff8222fd359abd06b82e90efbd8ffe222d884bdca9f9a60271c358ebb62cbf503a62787f12e6b6ef923278e05e2b48f6e4a9e79988cc8fb2370dff3d6924f7f108c9e7ddd830b6edefd98b7032e3479864f89baf7e4efb25043cdd01f1ea1bf44067f5d81dc0fe9414ddb1f4afdc8a26fe4a8bb3ed3bd172fe74897880f7be5341d9caa3c828e2fd5a0c3951bb987945448d90a486c7729097eb53e7b519cdb7d2f48499c8a3135dedc8684523fec8aa74c18ed835588174da4be154b2abf42d6bfe8412d4265351d0975888b68185a30386bd5d2a9d9f5112e91d73d15fcbb3575fa2c71bfb8d25f86c978e4cf20d55af18d2baf6384632c86c10badf4c748e83aec541461d830239c2f65657ff603a46598c049aeb0db6894274883d0c9f7d3d69480ea31f53750cbcee5cd782db0c2cf66e665e47b8a672bcb3583cb0c88e7b49b2a8c6ba1a936e04bc8ecadfc471884b101a7258c9f2329a6d2c2f706b1687cf84df2af4072cf6d497ad3dca0431ec54574c225bae87e70cdef405b178acac3da4ae80d47172c6801f4c1bd043e330bac5c4277646f540bb480c08c52fc36badf7e0492f2185817f41733181bf2a63489ef66d21a43a077b970dbb345df11b9dad505b75e38ee227461b82bb9c25fc8561096a33ae8c00f6a961b64ca98df737ce0dbe4bcee755199dcf9618d3c0b69d9f61c048af375ba9fb339b361f9961aaea09b3a575dd5946c4dccb7f4d31152f40c739d7ed9150e2d598e38a40a2345503c4cb6418ffcafead6b48b9bd4e5c207b44dcfabd3e4a1e6ae5f214b24cb1c34b6004676ecd34defccece442de3fd9115bd5b62f57a24c3e083d27afcc252a3daf49ddab487ccddb8715f37f5e6320d257506f1f1f96338e7e87ef24795050bdf63fe68872621766dc1c53e51f4b00b430d30dfb7febfc33649a85ff801d67065e04ee5ad2ff45c6aeee46bc717272b811ac7200092144a123fbc2719567642971631404f01af0e66183b732e2a8774f1fd3c2424701d84fc167c2b5a50cf3a5c6af3a9822183dc8274a8d50cee7123b0ec1ec8b4714adc66bd075651857287a374121a5ad5ab12b71ca2dcaca613160ce91872cdf4264bb525d38cecb31f45b56359529a29ad1e206eff26c07a75fa4b2e7f54b9d79bc0ef9c714aa5768b67b3bf55eeea49b700a6bf06768a00678cef58351ad6d834eefcc9049832e3c65725a03f4f1a2172785124704db7cfdfbf804f9f6e7ceefe2831991f783624fdba447f3b0c6e4c496cb8292405a115d6b2b2996bce6d57d8ea3c0a1f0b71e7a8a8cf96c3dda63527fca8150a99e11a67c06661b6cfab409532722df84cc94fcbc720a15f7ca88547aa1e7a1e0edf948237b712a64002b1c4dc38e7d65803c2d8e892d41df48fc3a659b3a8eee303154cfaae75817e935c4df0b863aa134406929209f6773abd341fae055e09e1242e5adc35ebf807f19668332ec7aa7b944cc23189a8e41655922d6e89cbf2e15b34664456903c7daf15c5352f7dcb3bfe8400a6c228b02147c74c69f22987f91b5a1f9e6a9a45fca1ec3dadcefc40966be27a6d1afae228d4902cf375cc60be4fc8d1004d508150ed17862a3c96049c5612e074314bd028d49e0a44fa6c4987643fd57afbf4483e7f4d5d837364d3429f01e01228274d71052a5310159cb3626736672194e4579de3273e48dabc1fb9e83951591bd50bce5bf082be32b3513341ebf3f379074d79137462ac3a694e4a840275857fdf4d4ff126b94285b0e8a63d24f3eb68f0cd3285cdc8a0f5a4cdaf50489376d1908bf24bb6f4bdb502e7a434a93d5111d736f8880aa1ec39b63ed3ff34a06121fc0602b730a4d4a6059433dfa6c1ccb47ce079e83fcfcc34fa1a02494fe2d93952e68056c336e21d096e08d2857929064be9ef582a9a74731c560036a7cd1785c2308fa500b7a2c581123ccf3b73dffbc28061411dcc1fd8ca1cdfcb801cc3041145ba4dd7e5603211eaa5230cf0f4763a7178f014186633a63a682bb8e9f70e71ef10da76aaecbbfdd7abe9538d94f395d951c400dc81a661381f1b9faaea66fc697a2ade1b190bcd3f8b27af952fb2483e3fcede33b15b2e6e604f6fbf8ece7a7bede46844e3e805b0c15925a78ad55be6cf6bf1569ae9bd1fb6d5474eab946331758b25dd943be9af5889809d948e82d7cb944c1f68e722ed559bc40bdb9de5c00f2fab51904ff263c04c5e379ab4cd7e8bf724ae25729b9bf3c68cda48a5b799455b0081eb170e9c10c5548a2bb1399a9b16f9878d895cf99641e22b71b2e665b3f696afc1b798ff282cca06123db0c592552403d039d529f53f842423aab433cb3595798d9c8b362f619dd75789819aaac109ee81bef98a238928acde4b37c46d5088624cffde4dc0a4a54196eac6dd6a1885aca089a9b1ce9a005a56be7fb632d8294e54c570c805cd90ee0e5dbbfb51572e65415193409f4a869653e0fa47ebfce375c2702680bb486eb34a947cba75899d629dbfd43c9188340173420bb0a43e9900ac56d4c80f8e23abda8536dab60959adc54278518401188cb631b50f644f321591b6b92133fe0dd9d68a1271f8ef4eaba88da55f07a1c4a56964ce3c4af6b52fed0023c9e41e0acc7aa5bca5d95ca42180c92d9019745ca6babf635a5a2997b36e820e8aaf3c3dca93d4122ef294589c36ee8ecd84c23276d40b78d79c0290dfbaa2fe7b81c50e2ed02ee6d7996ddf0e671725b46228ee8464d6d915e07b42c6bae6ba18f974251ded2ac95b6ae471ff527daf5a36ba110295ff76976eda0dcae60cbb80a0100e92639a9154de6cb189f980cabdc7509a0ef10a8265508888741008222fcbf760f9caae14b0daa2b0ad4951406e5b9a90bba17fe04c2b1ff477aba6336a129fee91ca94eca89d3ad2141326ef656f4e1bac02cb2320f74ab4f30e0005a96136643c32b6499024c01c4461e1d94afcf3376a1e5f9aa1af3bd8788f8a3bcaf01ed75d458669b1c56cb28076fdc0401945378c91eacf266918183f2b0645c0b40a5d8e28dfcd77a800365d09ddc47f37838d4792dc7a1678aa4cf09ee3d2638aca85a0a08f23182633f810aafbf67d85b30911a044761b4cdcce629aeba05d3ed5142c9631eb3df36ba5cc7fe150a6cea96cae24e35a3eed33203ead2c1e7a960120476c5cd70e4e33f08ca493db122b62f24fafa2c35890c1a4337061c44c8afe1ed8b25bf3d3477631cdffe39c62e114df5cee4b98e8c4711eb592fd8599a3e30804718ae99c21d9da09d9fc97ce731a1683a20835ba8db6ee2e31bf598aabb895679fe2f7d307784c469e49015e73096fbccd58b230260d78fcc8533402e1bf04c82197005b64bdd0e513b340683f262d7507269259ce44911aa9b4de032ce48cd51987249da9ffa8e6e9aaf8c1872f8092999c5224da30d9d7269eebf8858cc57efa6225406c66f4546eae540c47dcbe433cd54ec134957241db194bb15483236c2e88862f1aff1dcfc49cce5085325f19136992827feab2d21756afdb790b469cbcf0bdc2062bc8cfabd6a67c0507d39ea7b003d71e712dc9aa9644b002cf14eea4e060aa687fd6dd4518164da3f850ff81a7552e2ffa7f6dd7d6b14b67aa8046de49967c85bd2356961c5c097a043d777016f7886d5cdeaad75f554116c76957bfbd47f19f04390dfe609d3690314b69ccb96bca62c936d580e26e0369a26147a711119d888f5eeb2300d23202ffc3741b3b6f421d5414794e141bfa62eac54e47a89774bae64e592a5d4bd79d973928e981d645274daf988ed30af73c7ead183c7db3907d2f6f50b882e6f3a304af30f63610d5764b571b93b452a37b89d7a298f41f15fc93e8ca34a08696def936e3dfe150938e474a91667444617f8af38da36ef9b05cb8148c50ba2d3bac86915b48c67fa2cddf8dcdbc7f5341114aaab2a3ec0826a1c3ac00c87d934b60e1234cedf8a3c44beb53403919aec36240cfc4a5f09200e80d5e2b3ee127601834a72ab34756201d10c342f5c8dd7cca5e32f3722318df282b114c47603edeae201e608eadd7ba9e41204131a66b7f96d3b17752f964be2f9339bf8d6592e495c418adda808025188eb159d3ac7f918231150228c3596070f1b2e33a4d25870bb2340dff2390585f16ff339d3e28b50b30c302a8c3860483cabc9057095f12bc14e2454133375c8c2068f5d220d284f9cb9037a54e092ddd76c0b7f0a7e9a2680a6a3c41b752a92cb09ce0ae8834237d70e8b2e8a28224ea358a35e17ff7f6e27423a91fb1c3fe77327b2593816a403cf61589e1bafdf4e5eba1ebd860571358935e8b832eee18bab6f853558b8efd237756a1ff439272f245100f2c0ab993c9ba031cb31a8a5afff42e76aa2ac2ba8cd02173ae8afee2e31015d8912ef5c20b9a61902458201218ab85125fb5da9693f5b59a4914332fb6a646744e848708c1df118cd54ba7c6fe2ec0e5b9976bc5542a7b9967e36508d5e291ceb3c8ab36cc872153de9d265ffe1e7981e07579f36f9aa0086936b75ffd839705f3290224351b425a67663b8e868f537c14b308bec06831159addf4587ca6ffcd34adca1564b448b0108fcc39621a3d7e767a951aa157c4995a1e0a78fb11478720dbc1da50c12b8ab603b12ad5bd934c7d14a230e1a228d0338efc9202983f02f3d5640180db93d12834a13af5b62b9b541b55662f9b1d154634ced4018cc950754492eecc3986f1284e95ed0e3ff24a7f625871df6903c6818841a11659a0c04c5dfb71e1892693f2e6726bf03c4928a6c865de4e96ec58321016c576711d14d88e2973319db98a472a60de4decd6fd8ee6e02f018d4146bf42f6c10d47c5b71f07d54a4c2ca5ba9f2585a2d0857a9e59f83b70bc2c67f7186074bba87908863e6bbdfde4a3315085dc143c7f97cf85a6a358da494413a0b67ed167c0dd50c59dfd0ebc27c42b34b68379753d72379823934f08750388e9a0c1ecb5af72c665adc857aed35cf749ca5e3c0a4c8e7faaa59acb49ba07dcf6f1547bcbc8c537cf4e6d8f2b25903f6d9d7554b5d8dab795c68d00a74508257d87e11d66e067c9e6eeda3c02cd13316102dcdaa318b7d11e46e9023ed3137912f5232930c36adf13e773b6c23ea68c70831c5d2041b8f32763952ef881aff7659b74f5c7ad621e75d0c4d2cb265bf460aad212cc8d3c7a3d8339e9bb6d38980a7be7bfb0a3ce73137a64fcf7b79e66acfb420150448676199db5048ff15c37775e0558d5238a6009035e65f3b65397405838c640f868802a565306ea0edeba9ea072a13dd2f8612fe844e3dd822ad01a617a0853571a2869606591f2b0856000c95a831a6ad77bd14fd3fb5f18801874124d242b2f6447c2decf8b41057c756508e41e3295bf81b5b4645aa353f4fa2b85fa865fca34fa36d53506172103c8c6c8cbc928f7e567237ef29a7fbf6633fd9947dfdb62e5ad327a9fdf812fa3ab8eea7f63e62c6dccc9011adb90e17cc1d544c1294c6ed769163b0e279dc7bf945a4d6f66fc745d211766bf800b300f94f7ff358215c3bd516c6e339ccbdfcefffebc9f55d90e43a14ca7c79791f1db70f3781f99f030046ebb3cd8cdfd2cd14380372f103efdbb6fb643448b37ad21d1f1f18e6a43ec4f817441295060a36f45b3ed2ca8ca4a67a6253cb9d35672082212ab250d9b4e562cd961660211a11527e4ff9d88b21c39686041384c0702dd5498780e3fe8884cba0f4e27226e757324248cc303ae8686cd36df52e4447099b2df7947bc5136c9f52c81e430562a6699040ba2f9ca85a2f2494f17d2754a5220fce3184054a05c41282257caccffbfcb47143d055be4eac6c518ccd7ca2c99b3e68bd3499ff419c067eb001a7c4b15c12d5c0585fa277a9e6f061bb16cb2f58deeda41e5722eb865389e18923317b8715a5df4a675155fa2ff5b184ba8f1472a9589b0d3b1e01e214d29e1a11a56cd0dc8bc61d9cfd5ed40b76f3b33555105314d61730147697fcf2fb961ae50b17a17c1beebdae2b9c4463e6de4502f1b17aa1861134da4688b773d3da4692c015575ab391e954e6fa8fd26f064b8e8e29a8154bc3ca8624eee938b85c6fa8ab8d375f2f648938d499cd38bd3b522cc8a7ff9e10f7a880e0628ec931b92859f12d7e8080dc475f5ec1ae8cdd109988900dc132e61c5232cf0c2342191099f0ac0717e33c595c25511fe0c0984090c7d7cdd91bb9e67d1d834ada52f4a55db0a64b28d49d84d3ea12a7758297b22a89743273c06e58ef0f308abf9163d1ebb87ea9f63458597d764f8e7d3bad01c89975ceeaa5bc86173d3d65cd4c8dbaacd205539277b73642a3db0c4daf22daf219de6306238657e7d878319aadc7be558b26d6b5a8cd1138e8bc5142219e08ad445cb3ac011aab7190bad6c989d9606bc007972c30cf1a53258d3cb3bf529535d207a4d01be701e5f23f62c4a3ce6bd59fda6b0fd54ba0d3e6ab02c2859c7d01c8ee6d6e013ef391dded4c3fa6de533023e62cb5f4d34c1464e57d45a137a6185266fd8c4e3041e1e1b0fdeaec9701a94631bfc605b95584dab24890cacf16308ffe0cda7b03e27046efaefae896a0da8b7eb4a66032703131b040e243463bff9639879df9f8d3718725e5eba2b45bd5d15d42c088d63d4291792260ac80cc48b2a8bd7269169b4d20753ee5cb2ce6d75213f8abcc08dacdbef2dc57d7d22dfb0fc2f73a90053beb582b4b0cba4c661661f546f2d9f97671d6ace6f1804fef26fbd78f793a7544e196c3641e52e27f3e1d625d447ddd9ed4e304895db0b12bf1b5f891fd08a586f2a365e69ff9aa5caf6eca326c02c3cb72f4b595b73637ecc80357","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
