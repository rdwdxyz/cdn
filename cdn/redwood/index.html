<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b2bbfb86d31bce07f17a25e20e2f8bd3400c251d305d8df3caaa6c0c621fbde2b4d950236f8542334265c2c9f54f1f6861fca22e177eb81f111eddb0160ee560b27fd255d25b5a5bffcc0ee60a5ee31038a6f18e51c4233d3e1f21424ed53f8413ed01467531056f2650a973fddfa0f7c6181366b1e625c2c7d302b437a21ab5574c461620588042b745e5379b91062e691476f92124f084334a25dc1506cef0aa3e352f4483dfc7785ae23aa212926724566e6a70f8a60ebb719f9c73f7a6c0561167550a93d86532f34b6601607c9fc4222be6cace547600650a560cae26bb43ca124c5030dc47e0d0cce0497f32728b3bafb3fd2cd19259e4b2af3f478afd46daa06afc36ea14f76cfc251c9d4a2de7bcac150143d0cd5b99f740d556f48f7bafa7cf2e1ce76b0ccddcc5fafa0af006f3186814cc0d9f489cff6da318ec17567e9558c6b1828ff155205a67c87f16daf05ee9ee3c97afa4e242a2d6f633290afefbe90569e95a0cb96bd6ee38a262d57b4ca99a5f98c2557261b6f0b1d695e968b576a09572684058a23376d757b7de80b7b30ad59ae96cde67aced8fd4b87b42c09b3d34f0d226615d3d42e624b019462a97ffb2143ad656daab0fb43e42eecc80e392ac28943d75c73226c490d1ca790b57459b29502bd842f12e812d39ea7b3946900d7d96e3b4a65d0cf4b1c2a73eab34f0588a55799f3c0e522af752a70af9765e221efe20289353bcac2314b244b89a6c8fbb1d207c509c9642e80ec5c2f23d95f2d74366509ed5bed8f319a865907f538577ff72496a84f79ebe0fe8e6da46639f0e8027a96e79454759b67c47b39ec8b6a9d9495075fbb8ed6ff417d21e1fbf99fe34287e5e56d4c2e851959eff70f7e723db3270d8689a001d5050ededa57751982bbc73f6621d190f70ab1f0233bdc8089b62b37d8c9023ef98ef3854b118b4faa8df25e2346e97ae1cac33b39073528e18fc14b3bf6926554a1146782f005fb6a1d360a1554ac0c9eda6eb08ae2097c39e30cfdac2e67abac8f911756c648f800f3d1b156cd78f80918bd6c7c1a5677173b7929b06f39012df2a11d7f53d395525aa25b26a23ab5dbb24a4949dddfb1f0c953c3c778a1c18b5ebf56b969e04305c38e3ebd63eb62a2c76239289dcf86dff3edc81212d737c0087c018765410d8480f8e794b81cefa10a71ae176c11c6260da8fa9dc8506dc1283409e063fb88824d682ae9feedfb1399c1930844d609faf7d0628112370c6be4a9478c7aec6df0059655034afdd8b20c6c8aed875394000d6545d8a9619426ce9ffb122640f7f9f2b855d3dbd25d0ebf32271df0693e48f8dc51e33c99ed8c9ccf68f67d6bbba36f41d0b3b404cc3f58c1079aceaec131cc92bdf348483fc6b0b39f5ec28b8a31246dbf64f16a3f8c3ab4f2346ab058e861f947bb47af2d834700568d3277cb7ba1dc3f8f0f71820b7adb80f82e7572c64ca7e9066b89ac3ba817d846b44cae7c28d5aeaf663bf199bb1bd2c593f6a43feef6c507dde8007f0b3b1af43e5a1e42e893c5b66ff3081dd456fa3209c4c17ac2d2d250318b1c30887078f18d00f6f8f477b7766384ea35ecfcf424e4abab41fa8859dec6bec299ad37cedab7b1639d5f415815930a03afd853a1285020f14b153735d5d2f385967b6b547986afa4e0685a4062071cf023ce0099b9759b23ed65f3901f32469acad866cd0324d996d431c4b02dd9885d198207667b071b8316086af58d0b1a7bd4f953e2f17a87028c93fc47343fd87fdd8e02a5efc77ab2911208951d2827c579de99f8f1a12780559e63f539192be1a17ad43e47b97b5608ecd594e34213b63e837e1c1ef9901a68cfc7ff4db726b26fb27b37f436af2bcbb3e1f1d7db413f62b7bfccd6456bb4ddda993de4fce356d230ec214ed87058c91007241432ccdceb709376b6f5397f7860127724cdfe5b2d599665b06c76328763c34bf4e8626830cba4cdc04fb1d36d1b4f5c667af23e81a427f6629d85247602f852b3bd3907a6bba4eddea4ae01f787f9f1a028442076d0858fc71cda4ad1a24075402805092e2a95d3a8977e3fbf64860a7ddd0616d4f9c9c614f5ed0e2c9e8be0c3c342589638d6300fbc808ba8eeb45e278f2c38edf492657bf7444bbdf18a003b602112f1e1284226c0689e645d63bf580d8096601365c3c7b86c06ba95bb18aa6e475098377fb407bef9ed5d117c037c52cd057e0da90dfdfe7610bc2dd511571cd3c73943de8981f5cfc50a2db3e3f0c0fa4f23882d576664653e25b00fb6441fbe75ac82ee3c937d4ffaa533416f8db4b5516a6c9e8c6912f480c41694e7b29219566137fbae9eb3c620c1d11b2a980c6a841c5874bc8f7392cfee52ba19857a8d9411745b514a8e858da7f90fa14e7f97294ce762a885481cc4eeed1abab71f1b19a8b8252aee2db50488c3ca08528da7c5f2ee48ffca6c6ebbc2c13f027c180959192841bda13cfc62f84be12a207314b43c121ee4499b55c9c9d69ac352293352baf546dac17d4ae5d91417e893f803a6140e30a2107c3d4d0988b895bfb580224cf4bd72c0ade43de30d2ecb219672bfb924b7e69f47d39e5faa61fd6319434b30668e63b7cad6c2d71049677e8bed4ffb4d4d50e5931f8a2a437fca57d016f1d13edba189608a81773a6cf408a1eaf4ea72b6c6628ddb437f4aeeb793ced1d920e7dd65458b15d8f103eca927ba2a06bc5a537731e1e2340e1f2300ac0b06766ae04e2c926167f8cd3c92b09a592f14afb48f1f349477747fc27c81b0e8d76581db0e9ab79cf4369b5fb386bccd436fcee8b253f2d7a01bf33e3b1a10c0f41271bfeeb21f51573c6a8df1dccda6f1cacfa8a7bf8195ab83c6d93cf9b95d4c02eeb639297835f34b4377493cdfe7563680f763ae3bc7e86ed9dcc6cc45014112ac628a7138fe6651a337a21e39816e620499f465d7681085b6da321cad9eebc26418175eba1f017ece66829fa386e0ca4b5a80dfe28d80192e322c119ce541dae5a78ac5a5c29a05ec096ca9815cbdda8e7323a9cff8d2bdab8f72dc5eea71ccaf6e8ba6c3943811d2206fc81635364781adab23ea0a40a2e6bbe1af60e2712c2824b752d6afef3e92f174c2a91cc3028f3b78449854fe481cfc443c746f4b63b881bf82f1f22f9bf9d57f368943227eec0761cc48a2b4f26e2c842e6a4b17f5cb5e3400dab75058ad1cd46036dc235b82e83c9bed423a1114dd649f048eb8c77c6ebe60670a6d5148b0d36155f42a696e5312f553a7fa0b806c67cc4f33d144bf07bd5fc65f060653daf748b4e8c875e8bb94d65184baccc4d414d470cec2768ce4da959bd9fc786c2ed21c5dfbd16f3d6a93617b7d2b7e6eb719541da5c257b0f70c1bc298efcec5eb0e3791046540995afe40771dfa7011438a434979b72849062113708305e430945ac7caa26da2289a635a018b9180bcde8603e08e5ff60655183dbd1cab666f3cc1c483bfd794be8b28579a9ec1c181fd359afe19d63f363be9df2bba87909fb99bd07057286f749f576006c88e30b6bbcce8fa2158aab5d9dbd558bb45c9d8213f737b395c5520f70a9d3e3e25860449f3a2fd60ff71677ebf3ffa4938f983e8a5e7b214c30cce0f73b747cf1f61e37b90d9bb1d8f5e93e95ac91046959cc95abf86b06b279be78fe8ca55147404caffaef04c0a37eda91860b4cf95ba2a6e059ebafe7737f9b85459aed32380a1f2944d1d1ab8f693bdb3670a6fe24c25b2aea48e3e494cbb20a2e063c007ef9ba09e453337b2d7081c2d806245ef270ca1daf77722334b111492798bc9b661a32b910f43c0b77561a8ff8affb839b81487f1afd2ca70961a22fe3f5099a11fb3fd63c59d95e69e74489e29ff432ef7a6e9e9a979b25298c8ed5db1cc2cc54a60bd43fd9f4c1c51ebe41e744662bc6031fa521e94f4b8ac9fcca1dd80d1c13a37c86a0804d78b99eea951e45e847d6df9627d540f6a70e7e6e71af4e75ee47094802b798590eb11081a5ec6886abb115bb70fb2a36219d25aadee5ec35d26ac4bbe95f8a6d18b4b64cd7f96d2d7d5858cf5114d373de98f799e191aa839c9cde2d48a2c7ddccc920bc7564a8dca26edcff459f2f72cb3b475e4bcd33b0ba99a0a1587aad09f8e473ba11a5792a4ea59277753ca047d67bf381cfac6f66dc92e3fe0cc12a43b448757c20ffcd7ec9dbee29077e12a83d8b93cbc9cb267e8f455ee2b6471fa5b17fcadb11b2cdc366138debd4ef8cd810eff6392342fe8f4b2c712abd7c2253e22bbf40a69ae20eda73175024eb6602176c05e32364b7f0d93d39114854936d908a3823a4a4bf9d492bd791f0b9ac742356b0bebd6eb9dcc3a69453ebdc0324bc6b9f13485fcac908f0d1e735598534393c875c7aef580c66cc330e1d4a6c4179a72dceba54f69300216399f128a44fbedb89b956baca2d94952bc66de3526b96dc97663cf96421d3619a8edc4935e0b5defe8faf9e48556ea5681264966626f7ce88efcbb263c1464f80dec2e585597a406f71678ef6ae2c856e850117bd5e44ebcc75e8652434a533076f1123a64a8aa2dc2bb1978df726edbdeb9a093768e528d276fb4a1dfea9974664a1acc01c96e9ad5ebc51f76ae8545b8ad88f47ff713f4bd0badbdba0285eff8cdbc079d806d4d2de2286a024dc27889365c7bb53fc426a113d8d583034ee49e0c41b8d58c6437a67815b1d6b9ca082140551622b8c9c56f71a9df4dc4d81eab01fc7242c3749ecc0274a3d5dd0b8df923489204b3d0a2456fd6cd466d0420a37df7d823a0054b6bc59df523bbab916bba822ea2b9fb599c3668a78abe08b42dfda60200543044b0dabbbdbe49e55a7dafcbe2af6cd78fdeafb39c5e8af542bc857751230f8d748f8623b62e8f2d93a08c4f52190835b5e2f4db611230fefdf1f927a79daa48770f290b4c475b948411579ef87745c14fb20ba9b20fd6a3bd14ef50713c352b4fd5a8bbc5c62817dc3d0f34bdd3e948b1ee34650a70a7ea8489ef254dc94c456c1f9c4699f3a0fc2cb2b2d9fa57cbe8b2c6285d2a7c5fec0df1d8a251bdcec88b46fc2556d277baeb1e0508029d07c155f452fbaf8089650cd70bd952484667477b791e60905e53b6d3a7f11bd29765bfa3b4dc32083946e601c6eeb5a684414f68c1b2787523bd5b91590acdec9c6c5b0b2c32f00ce52a9992b5907bdb222fb371cc18f8a959a244f8c6f693037eff46e6c8ca724fe79530d2a62f2e9da2bf9d12648d6e4494438479f57bd39f1225daa5e07bea66ab0f683105bd02b723ee2ffb62bf5f4f1fc9fe316f00dcc6f2b300bf22ae9b324763059c66fab6c231eae0a7382ac9c087cde54fc34cbe781dcfeeed15aa07ec0d96d26d0a33039d41d74a97d74f52f9c6cea157fc616e6b5f874e3279f1ecba0f17e8107faaeb165223ec7badff9674650f4b5a12f833253280e9e5e74ce11e5e64b8622a9169b3445e5650bbddb30f84b843fcfe11505e67e2fabdace7bc9032df8f79e1203243ef6586e8b7bf8f1ca7a9c44c1d225e942390d5e5ac2a4432b47b927113e075210193c865fef31c1b230c313c0bcf8cf639e0df5e271e3b401eb35cbe841d983e43f9e2e02389ce9912180d3ef54be17d547ec7aa425e1bd8c6c495da71958846a791abae4840f6252ee8ec0a59e81b5363401806bfb476959181ba03e59f9b4f985166f378b0fbd37e04b0b1e960cf25b515c91c68481c669d02eeffcc785907aed0da7d8d6fd4fb7f95b5a0a156e4de78b90005369cf1f91e697b29dfe65f134622a6ecacf7b06e6e210be53b44facfbb23d49bca31773c3aff5adc4556da0c94cb59bced0c17817e394a30832ac480a403d1f0b9c8b6153d271d64968bb699e370c92e2200e3dcd2b673cdbe7c738af3fa810263dc8ae590b3487a5c16867548de55326974378f7c7cd42cf10547e575e8bec935f6845448c2ff8d3ffc60039cd4736e41f00a1babd341512be081b2facac3fe796e747ba5060428386bdbe91c91da1e8d06655729bad8bdfc7ff3823e6d3dae601294ba6636ce8411321b8cc370975e5bac7894f8d0cb640d7a2fd46f4c4ef2167eddf2692825848d82ed67d709b6edd7c4817f4ea6b44c83df2a78b18ca58141a126b154d8544d1d8ab651fdd0b8013fa0e8bc7661c7df1119ab831444cf1e4d89622cf5b940a84df06f8876182c06d7ab1888f7dc921ff38bf938bc9e957f2249230f31723d80f957de2f30954f9139d9178c5b17fac519accbf6a8ed71d6e18a223d433d3d31911f52a65dd1e073ddff7feca3aa556633a86a25ceb43bc2b7a63d3bc8ad14dbd180f08cb1e263adf34b3b71386f182e919ab06775cf3e26bdd0f73170daf5f86a5d033daba6a1d9f911209d40826688d9aae7d671cdac4426852c03fbed01211e6bcd99dd5d92cc0e7f8b6929d7a1ee7b27e9938179f0d885171427a30aa144ab8df5d5cfeb7c2546eeb4c9837cfc64eefdf4b49469b86519dc61bda6aabd90188bff60b68442b9de7be2ab48b184c90df3dc21dca1c537bfa0ae33be4a5b40c1ac49cfa57a726924baad56cc1c273be9342db29213ce38e824570a54d96743dee860bd14fff0d0efffaeaf9df7810585827f281916e46d58b3aaf282b4b292d3089aa28e78293d3eda59c76a8df9e7c3b38b020b82dc08febc664a710ab04b11fc3e3f2a5aa410348171f42ff7cd6f355c023aac2ac8d1f37dca150526b66f73ceb3564bd432d83a4024cc4d10f694830bf331524ba065b5fdedd4c74aa8ac7f30de1a8a741494b1ef053e405d268632efbfe8001294a8b09abf72e13094a79ffc5a05fef2cb255232b08a5c4033970048ffc9db4fd805354a74a15e2acbf5e2627c6566c5b48d5e250da6fd079f681964313cfa6ae0aa08e7d4419a880fae7bc7ce5bb00b3b8f11681ce52fdb9e1b440cacd6a47a3cbff1404268c2992211438e24162301e4b4c405192941f3bbbdd27aff9675a71559957b5d83286b8d6cc87e06ecc687754f6a83a13bb507b64d3533ac03947bc9ad19361f09951241dcbce3528af5841ed0c9c00e86a4495228bbb3db7dc90596832abd42839ea3236b8dd82108e9671d06859f4768dd42fd0bcfe2bacc9b075f62869f24bd60963f84379a018211e2dd7730dbc7f09b13c3d9b9f07eac23c0cc3ef70debb4a8c9d0fe6692b8832202f58e8bf02990a2f315db9566cb1fb8fc691727fc6e5091a3a2ce07509c120068eff6b3aef869572ef2ae8caae7ad411b776a65f063b1ac29ca28cbff1ccf8cdb1072a19059272bf941addf611a2721b8810cde884165f944341269a975871a66954d6fde7368f74a42dcaa9d95987e9879398546f10b469de6340d7fd70da585a485c7bff7b85a87beac614361b82eefced61e0f102143668c2bf9e87d45e4b27f41ebc7eb4ea0ac1b547a0d7bf2b6f16b632bd3628b9f0ee34c7e2e744da9ad0bc2ddd4b0c1c8ceda5dc22dd408748c7dc1d4067a7332aa5fa776e556e13b8571336b21dd295260b32bb7cb15a6fd6296e669ecc0be168b74ecc086146cb5220684746c834a37958b007f44a737404792e593f3d6726cd6b98c37b48a04381f0df0ada3b95170b04979067dbb1bb1c3619a0b5f5bd1442ea81ca310511fa3a1027fcb6fa5dff61edfbaaa51b803d62e0bcad76428961ac753313b98fdc75e6b6cae046ec053ea3a0c3acd79221fdc8a69cfec8c1c3c55a09192a84bc3a36a8201a2d0272ca021bf32ecdae88d7c18bb1f1e586b521e8c110c3122e4a99c36cc827882ec388c1ae42b5b4d6556100ed7c013afad53baf582b205372fd69ab35c8d175de2c77a59aefc53ee40965a050fab6ec0bc80cd70c28ce24ca4ba49afa161e65592deb782ca5d69f677aab7365214ce9be2d8b06b7b39f290ffa4659e92d2a71258dda52d8a20c01f6a0eb88019e75da60aeb781dbf5d82d22db5ec3f7174ed159a0b70d66cd3e1e51961590b585d6b36348e6a8911dc74771f95f6c745500a8c649515667d64bb2bb4390285be54a9403bf13cbbd1b1cd8715e23d2ccb9966e452fce2b22411324a88b2c3d75f722b79d99c68cd215136521b80cb72f21f85cdc77f804bb49dbe4dccc65d25e62147ea8bd6b8c6305a08853690ea9391badda4e51fd3e26f3d44832afb91bc9b83e35b6509046f25d7c092522a6b1a106644d26ea350fb9c4d04f3fba1de36b6fe4a8ab70fca373897aa58b0fedd59beda6c403497d81e78b4ac6ff933faef2dda085e7b0cc9db8770060ba9c7f7e1112d216c75646f09e9c95b64cc95b5f4e5f8d4970b416c5778a98027ba5b65f2feb08e1dac069af7f656fece895e894e353e8768a50804b51446d5a321eed5ffa96449983b03753086f60dd341c23646954598bf313ad729fb2154673cf00b0fba1ff8c455d8bbb85efe1bf7fcb3d2a1dedf1dbd364a102338eb287c8d619036df63b12b6ebbcffc4a1abc6bf4af7d0096a2011c53f0294ea3e690d4896ba4e841d0e5a4789a095e429a2928dad6c79c1eb9e0254c307aac853906ac1eec63239866bff25020dbacaefaa8903c5f34e50d5041814642d2c20a660af56e04e0240f932b65a13fafb58c1b73c84f849ca76304306482e1df021cc6c70022649e060a60ce9f704e5ff9f8f5271300bd7b2b5d30cd2e292f72c4935e7be4c4f658062363a7571333d7d6b6e437e4d8b52e57a2d83c0e6f778faacdad3f5bdcaf4198a8c82c210866592fa38cd2365ef6082768828bf9f69ddc8381279591ce22ae2887b11db8bf57db10659b7aac03aed739bf8593cdda0042793110094cce6558e92f27327882b793a4728102f14e4e63c8a0dc23a0fb1a57855523f62ca87afad04ba7ba04e84d20c44c5f4a9e728344ffc1da1805e2b97fc8de4aeec1e7f68f96e20f11dc071405b670c69c705767f6fc440d31c0a98268eb65b3aa78c2dd3b90b9b36ed9daef04890337c773582e3da5c756c726211a87dce3ca900ac84577df9c94df34d21376245a57b7722a3b15ee6c10222770c8227e0b8eed5177ab44f1ec315d8f008dad8fbe8a52181dd55a634ca73ce0afc917f1d9a18c0db79d94e1c46e0504015d7acf8d92bb264aacf09687f55d082b8419b294703965d9dfb2a4518b87da175fe7fcd6cc76487218ec37d6c15e0ce9cb470af4a1ffdd46cb06bbf79efa7f15c389c521e715338f39140895c6dc16e22f2945c322140c602ca8058174c2d7bea4db1d5b1984e61ae404566268ca7a64ebc84b14bccb7483954ace6b475c8ad11268666d540a5c75645b919ee428d25daeeafb567dd6213e0c65f128acaaa4a942b3ca7d55a87d025d7657db63a23c91e625c5f5753faccd4f4143d7d97a4d6a1ee1d4be435e357bff84261899fae47af10bb71faea69672b939a3ceba80cd504c019d6b209616868bbb6109e7e9d0f24e1f77d2d97aa9b4fa6bb52249bc7c6788e504d444508ec26eb716d1e87b0c89506e42a2d48af7bfec876976558b5d4d2255390d9bb556b12fe05ec1f48e17c6d27121407fd9494a092ba15473f53aa08d83fe64d5949fbdde7a3b49e098973b2668a2a7080cbd23da6c6a965db6f769fec297d8f69f29ecda452117fee2c52e0f919b4cdd940110fe73b99a98211272b0ddf6de919a007a5936e9125c6d95ffccfed891dace957859ed62b93d387bcf1c67843a91eee0bfe62c319f3cefa6a44d27c66c8d4e58103f050161f6b5a11f289c019a19a3cb1754feb9254f8c9b1b391005a61b655bd8b378749eaa8648d95ac5e9502e5c9685ca5967f036b74955a01f39bf44427417c739b577c48e2f0e027cc5994959f11603617c69a307d2b9506082026c0be2ca2701cb3f9708a48d8345c17434975c1141958e0fac6a5d7093871b9abbd9580e165d48b6beda96c063a83c6a9d1bf4fb31b3f7ebc9399a5a9dab3dcdcdd966d4a1701c23a20c7d65fb6139267f535eb4094ef226d5380e95ae77f15361d93d35e2691defc1f29cf9031941f044db53ce06819f65aa70b177453307e2c81ba3961bab8a9513d414f0e65d73d029d3ee010f3c3810d10a16ac67d987448d4f6251efa1096bde28dcb4987473d2390fa42ce09145709fc0af48b9204642645f357c362f0fd0f06e87cc79165eb5e4a92534d1b5e50cd0ab798754f960165a8f2a862bba256eeb8a490a5d7be72bc8da3369b6469f874a1dc235758fc98dfc89833852da01c990baaf200250933c117909d900e5ad7b173f0e55aee4d37db490fd3b68e8760b836cab54af1c5ba172d242df980730681a2a7c94d4780efc9d541343f5fc6ef4029c6b6c7e2050c171310eea106b2821033eee0d25e0dd3436c183bc733bd17e6c52e560b588d2d9c51281e084e2e86c3a3b0598095f9f5fc4673fab1436272b77165e76e4b49a4e20b5c4a1e6e802a75e0deb57de8086b8b571b0b1f5dc0ce2c1183423aabea9fc5cff3bb4c44843f42ea979254f25072713b11d2c84ecc01184fc552ca2c804bb7a45c63cc3a2317817ca8737a486a9668e5aeed9b05d067239301fcd333f23a5f812e3c703803f8b9f41524a28e5d98177224e31db1c9f8ca75935b67d09cb5941f898a8a83b409b255a7d874fad16bb9f25ff2a3223bc0a21ca8d9b6a038e5f91cdab75fa6d8dd418ded76000de20bfd652ffbbae6b50f422b8a243736af547fb3afadd756ff6e69aa4cad3327edc7a818dd8508315b4bb5223e4740f80ae23b00e341e85fef6baad8a3dd1cf126399a70cbd1da9d9b360ba773cb80a68221f1378390c448688eb0dfbbb25aa4cc5d8f9e402a6d19bbe4f0b73a6c9af29d11aa4b6dafba88f619341c41701db4b58375b3d944c523382ac09336468d51b4c7b29e55b0bcfe91af26404837f815825721e5c507389ee2ce0feddcca1e914ac49b4fb8587b91085cbab974ec8d1e41e983ef192daf965470177a121b8b3a7c7c98471606a2cfa2feeaf36f92870fc16afa3731e13c2975ff72a2aebf538c27b2c1a0db20f66e49b537c7ebf89dc8626853cc5541e2c11e34202db6e2c50c16dd35d8ad10cd1343eff13130c27c0378f1de3ffe55300622e1d0585572ebfbadcca367822deb8602f9295bbcd6589876d67787ad15276fbf0986f31a95f8ea2b1b5b85e66cf9bd7358aa935182bbfb319b293116c94525e8b9d6579354fecd5b4bb3bd58f81253b992aca8b206e498b750eef20818a73b78396a09eea9ee0adf221758235f7a30d89881f1dc127d31133717dce4308cd985c058e19da1ee825b728730d72aed0232f008f8d0c96b0c46cb63db9552f7cefebec9481bed57368a35903bf250868f2aaffb1c90a78a98764a455bfef107aa90b6159c9ba63f88cc2279057b4c862e51263c0933e30dba94cbbd13afbb1f37b46a54dd43f0c23e950ce7cb83583951885183254c650caafe08c82c62c1a159fdcdc1ac1bf885eb42ba5284650e87260c44f7c0dd034c076f1cf23f431f1d9464708fd182a7993045f401c0554aa889b7ad29626da5e786edcf6812fd2c99f8b842fb793259421b96f6bc4438687cf54413f2ef3ded774da25de0f9324b64fa87d4a387d44bf5bdac7ab89bd87d9e601be961093faf6e0d946d74947476e69b12963da4bb056b8969a64e4c0bd5871b66a93b4aefb287e72ea25c4627e87f8cd5ed3d93336c8c2eb7a8100a0726bd51266437170880773e4f0821756b2e75ed00242f80d7b7ed5c32474f15c35e52425126570c41f36c8a5f7beccb1ac6cae3b90b02077d205ec3af8422c90c18cfd5029823323d41597b35c24cd831c227770267436042fff2ef6b81caf41dcf02ca1d77f4d5d579eb0120b561c57de40009d423c21ac6ec19482d4a6b9ff2200369f2c5d983d96d72814e8767778ba703b4ee8e3bf54b02a63cd893c5ff4e7129da668496d374dbffa2bad25b1f744c2002a92f289a34b95ea0b932cb65f9d12e4017f471b341adf5989ded80b88af6e541a0468d9f9c740e4c1dec24ac229c2ac01368610037845d90d93b62c4c016a145292786c0c48335207f905ea82da1c40aeaa28d4a8bf7be71bfbab0b939a5970644bbc717902d6bf4f1697ad55196196e70938e093435471d2d422adb5ad8e044978b63abc60df62500085849826f4c57e4e5451c3b9dae52a18bd5bdeaf716ff118321a9b63fe8c6deca09cbef473de1c49c4df4ea2ef4a14b771ab62d9b3ec9717447adc30dceed67491de0283f501b9eb1ac7703297a3c0c6feaa7b5839ae95554a6080ce9fd313b7ddf5184f7f29d80444b10fdf50a05d0cc161d2a6b5ddd2b58461de09146af5310a775088d5b7058ff26b5b9b55897e4fe9e7e78974df132e7e5b936c572068fc4b741a4437088dfee0a76837b8efa8d134b70f14530bee54a72af4297b848e61b9d25cd81db3795fd17a59ad337dfc13c7418a65fdd0a12fa4ffd481213aaf72587cf0aae9e302a3c0b78cb8e384974cf0e6da140a01701f9736741135f55a6a653376d954dbc27864e7473fa81d1cd3dd9050b1f0e3619955b11a84b6793f32db094dbce4554469b44cd80a36b6b744fd70f1d46516af93fe550b53e211c2d9536f072989ca6a58af1a1391fae0461a6095c9be7c900c9bbc9316009960b7dfaa7150cca74ef2801a151418c6f47a13694cd7891eb3de295b81809dd134a70a89141d0c62df8004e3e526de3aeae6d0b78547aadf206630fa2ff69d1ca41bff4c0fe3ed6ac3ce76b6f5dc9915a5f36abf9975c084e1792b44ebc504790938fb20e9bd1791c662a91df5899b8ee1d1624255ea80ee32905c939c4f01a131a466346463e50e972961e1fe25d2b4fa3ec6e8cd0d4d6f2b6a3feeb34d6a48a4ee8eb6e48f85496053db105f1f3477f335f5d320220fec212210d0b799e5f555778318a41636b1d3efcd1c3770dc845506f28a2c16fd7bc0552f33a463c9b553d8fe782036b63487b75dd3b38c6643e36a42156fb2af6bd187f441668059d69d9249547cc489aeff4d1b2aeb6be467cc493d4ada34cb98e76988e6161889b093b6e8b9832d746bff53a30de5668e89e37bbe0d03186868c1c13781c90615a0d4f8c3c25c1204ef458a2cf224693d500a38996bc93d298292a8ad5a04a5f2ca2617f17cea7460ba85a135f0be558dd9d7a519a2a9d264b0d5dc6551b2ba5d3e4f0df90980c43ab50b59d17d3f96f3ee82e1fb68eaa800f324f396933c6e8fd062d1953af105ad85c237b9f3db1e94e9465784657c42cd5a2fb33c0028527e7a6e098d2fab42fe5d211c8da46b2b5d23a8053db2a8760b3b98b1f462925b78fa9126fe8fac080a83bc1184510570bef9769fdbc5e2214a07b8cbda39c6ae29480a840f644aa1f3c0b0b5fe1955af337ca109c95737ad36f47b4bc13618e3d550f7fccfacca682f7f63800fe2b4745476d5ed8062ac85301677e3b4b27c4184741ffe90c3140af129bbb8d88977928a264aaa4ac0ea7df58202576a1293d723b0018e64b510a6dbd166782502ac18b904fa145df4338262aa3a4f1086d9f10ee929aff7be4894b02bd23304e1b1f51d9f11f60870ce32dcb587d876dc5f900c655b2c8280ba69d4ccea4e00007c0ee451df3dd0f66f08f9166ccd931fcc444f87ada9c23388879ce1c1baa0ff48725759a377ad16c1de538edfbe0e1e15e9844112fc11bffe8a90a04543bee13a0def80c72499a7f5062f1a572518313e1763b892302e237da3b8d4568f4635fdb5494e10404a9376e98494bf684d27482763b2d816ef8891d89a80b55a4902a84c7aa243c9cdca6327f1a9ab3eee449bb7224f2733301788d5eb50ddbc6595bb729071c63e975b5693b72796d79f9c0fd21efd20ce2f76ef4af99d286f6af3bb636fc417e18cd33e917df8f13c7798b21658e61bd11ed04c3e9c5048eef8502f9121ad9b2c9503c3d33a1baa449e553bbf1de7c0f99bedad2fc8e8022ab6f27669feec360e643a1814e30f00ff482acced62546eed621b01bf170ab0a854187645f7af5d2323d31c555335010ab3be94ac93364263de8d0e07b9cb64b0e91c18eb50c0381fac0557c156b5c662c8657d9cb5ba14012dc071e5a56bad0de9c740d19fd92251417c05db7f59a56f89a59b1b6c21c975679c6d96c8f32c5f1d5270df99d833510580f105482a583a30e648b7f8e74170b7ee0e3946684f347e4bbb00deafc5d264bf6acc95dd07b62bc02d1d156573927aeac14a7a2de53ccc9da8e051485bba1c543842899a8f7fbff3f6a8459eec20ffefed19b2efbbabf4412654117f519033f907991ba0be28d111ad77df0d92dde9c82944a07650709963a7aa029e3ec9f354bc8574da40b61a89f2de7c35d93a49cc52616b83d2ba3199068eef4669b56d201b42a621768bc3b62971140f572a30d374934699277933f023b2854c9b61bde1afc8256c3961669c770920239135f97574dc2663370c4bc4dc9a3a77468051b020f1c11313d4d91b5ad47bacba10da7a8447b910c2ad37c1ee55cd21c2752e2cca665aa7dedc4c8a3fe140b81eba03bd436fccaf85eaec8e1e6fd358232ceac93e321f4ae8d81a4741d61b6ffd48006f3a3fcb27c95ba4dde9275bb019235a31ef4a4f9007aa98935cf2d3a5aca1cf3fcf504816a24b7be0033b317a8e3a56099f65da36e57146743a02ac28c21dc972528abda2a21bda31dbb36208498582011457a26d7e9292cdaf3193de19ae58c1187b4c6cccaa334abc177ab44b7aefff75c2d4ae1a3bfd8ef630fbf084cde64b40ff1b2fd79a3ae336b01fac4d57c9edf16cd1a2ce3a894365461751c48716df7f83391815a9ef4f1fba6b0a0edc8146d1fc7966455ad3abf0cb63eccd9cea66e9904816b4cdccda768bf261ebc96329c814445064dd626dcf656a5dfe00c440203c4830b1c7041e272b3ba845ec2fe85496f65ddf5e90cfc97621f98adbc9a18c477beae94a6c85d654c4fe18e87fee1c4424f5adb8f39232364422047b64956f8d336195e5a85465c40029642f5179bb63717898d095fe03420f2c7c1ebd4467b84d801caf7671ae68b89623b9e021306079f7c045c034c6cf12997ef1c15651b8b12a7c70cd25df483e0ce3545d332975b8e24433c0accc75e2e4f24944838ade43b1f00c2c90c095bb4ad7bb503c67f697d44e7efb5e6cf0719721cf579a89eb1a6b7c9f4d5b0ca14058f23d50e2df03b1703926d984e938ea298b757151531d31a7433755af22618b1b8d49d9a29787bbd08c7f95f86fbb07c3fcbe665534e9f3c17d9d5b6104ed87e6b24c7ac097478d135c52d0a759049ca2a71f30abf9a277f33073e49d0ac74d6337fd120e7ccc451d7fd1f14c86ec82cd4352a87ce4bdcd0b4c34bb973a512b52af0b8067e89884477b680b197f1075d9465bc2e92271642cc105624c987d055dcee25bab6bfcf8a642e2eb2ad2dead43ac07d66ee4934438f42cb385b951f22e0e00907e15813d17ea6f5f513751b619d33ef4229a5cb88ab3b4ffd2b06a0c6cfe96d17c9214b36c3586d77ff1f09603d00b4b36644df4b15e70a14991d8f6e50272c4b03de173250e2e6500dfa9ec0abd08b43c96d9082cdd3807ea3ebbf81b8521b8ac9b26e2e56698819ae4ff73bffc152fb642f7926b630e48e5c0cb32002a4eb2e34b7d7250d90c4c89b35c8835cf47450a943c6714a737c6908cd8693c080e638a824df92cc662b8b3b285998952c90436dcb695b78fea0e06cd7fc0aeba485a5244c0e2d10fb0d9aaa2f400372d37a16b1d99b2329a346b0e6d036398ffaf3650641316b625a1462b92d4a87d1984890fba0b9ecff2319ff77467fc3bf12f6a7ffa2af8c8ff553c1989fdb38a19730574bf9423520de7efed15470f2f3ef630fc9b0f4795acd1c167bad06bb7380d2569bc678a44211f5363fcc99d527b18ff8e7269641f0a82d8e931fe045c8d78be5aa3224fe6e0ffd05acc2c433529a74e17158555cfa85d438338870e771cf6f8b9712bd1681876f50f27b85b7258226353fc285a2913db4cf21bb049f2d6cda5bb46eaab09a0ca849973dcaa0909ff561e2ec63df286bb28860b033708e80dba726eabd7fafbd40544153bd5fb21c81cba3f71bbdeef437022e60354f46081189a5cb901555a1b3ff8541c041725aff3cb371b65556bf4a78bd5f87f8a3bc5866c5f6fe26290251acc93bfa16d961c3ddcdfbf77e9235367d47e3fbf0cbae9a1fa8d8f4cc442256dfc2fd83235debb7068417138a95ead3d6435f2273e2fded8b0ec3483f98f299773813fad0365c9433c2070b9e5b801be5210c9a718da1d75e8e5c1ac403ba1035fd8914f6fb4741939bb649277241785bcc1c879248a734e7ac7ee505f0e8e6eb48b29dbc8d9138a148bc2239c3532d687487a91bf6d2109afc1f9a9067d74c1cb8edbd484e1cc0ccfd9d957a2165bceb3830a7617db3b492aac92aec57bc665beea8496155f0cf9a200770798cd5e6c5f9637119d8cd74d9d1318b2972fffcff611a872eec41ed1aeef34e5f25ec4b631fc97b6273cd40fdbf2ff13027014b5c38e3d38ae5232564ab6d46ed7d37d024c837ac303ad3e7364230bdae170e97e6db7400cec3cca68009d043d93efb418f8506dfbee363f79cd57312967bbf4bd0a043ed733f34ad09c6aab8a73989e2d48768445a2dbc67720df2c8a6c393b94ce1aa0e71b504100fd6234e9eca479df5958bc4ba63520e681d86d9a7b7e0e9e5c55b19e2171d1dc6e2de64a5c67fb9dc59be34f31f3b22b649a1c3f9b007bc53a829b9e3d57520500ecf8d454a6c49dbfeeae497f1a4f49f5039402adbf0f9b68f0d2e918f0bda2253bc8ee0fdae4f04f33b3eab02224c0777b1879737501b42089409b279670dbc064b2265cc2cb2391910d21c7a09e69670a46e0abe50a93275e5477b1c92987077e08d6a1b066df695cb55b34f95bbad818a46ee99f697e841e56252f993032d64a97cafb3159965495118d941f370dc7bc48b01bb15281e8a9df0d772927ae8ae3ef5f1fe7e2f37d517dc32cdf56135f4ff1d9e5bd00a9d9503b3b547569d59cb0beb66669b543b259198f55be0da9d1e40cffe362ee6f0fd1f152f4ef21ed20dff5be51d00697e3eb45766c47f5c05d4ec5e0072a8540f2c4205ceff67e42a5665d2bda00ef237fd7a36c1deb86d4c81e65f233656a29347cd2f68d7ec07329c6095052ac1c769fb28203db16fe071ea80898f6527420cc80d9f994a3a71a7a9d022a22bdeff54d14ed7137866b95f52615d1a04afb56c85d0cb9b62522796a9a0f68830b92c532e7e8b04a186986f7f862040680939a054799b648395f31d782060f3c1d942608a0253fa68188365cfa22a258cfd766cfa2f093e3ec7be3a905d6637f2abe18fe185dd0b39db0b57bf9769b2a706f5d1f1cd2b04524e4132fc3da7bb388a45bb84221a0d384e3ee0eae57a691810f02c33fc76faa131ddbd9c5dcd59301b010e72772f4f8899410a014b2ceb38f63c9eb160548cd79b4c47914a728d03ba7591ead044160e711ae0e489b891601bbe170be36ade153204ad5244a51894ac2f95d6f00b379951664b933ad89b5f7e5d208cccdc272e59882df6ee6a00ef1e1adc561e3264c8984e16c32400f106f3eb6728811941cf78206c2f9ace1e046c64618cfd6bfef308196a2a9ce6222bd581e9706dab36b8f2da6bb4a0678b7ecb833c29439bef12e05e19e7c79f1bc5ce1c7f44e8eacadcd7be4c5a5db79ee8221e10a4419b2f28fd94e0272cb292a86a2045101df5683d46166eb546efc261e7ce3310e6140ef236a8536a87afd7b67ce7002d0aacfa32cfbdf65a89b258182b5830e72b282e22441275c8944e04fb603e2416e7f4614e5860b9ccb048ceb48a8c2dc28aad84fc7ac0d3b67a9bcb2d9dc3b63bb4dd704e0388aef31befd8de1b1b32fcd94b99bc054d67cb15585e09a61dd1bed293129f0b8ebd1eef25d6435ff8ef496d167768fc53bad20a3896c8707ec12a14f15","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
