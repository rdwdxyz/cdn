<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7a17ed9e2262811e9a0ed9be189fc394bfcbf8c5e385b4128199ef0cff29052d1d5d4d36db86448916be9b25b2df658bdd42e944578b28b53608239cf876b46c1793f9a273c78ce7841ce85b752dac27611ddaffa21d505bd865c8d6a4afc1373a6bc7ccfab2e97696d7788f71fd99ebb2c722fcb8594a1b1ee93d9c9cbe62a294217afb404d91fca39437311ad9b8a79e4f7a08e3ec91ea1ceed38cd54282a1f07498922059b86fbd8f4cc74866ab08025d6d30e68db44af7c992999f61b5cefb607b7f44e1ad81d0b5502b7268f7418f91e9ee61fcbb928242b943e7d582703835601ca49203fd098b9155184946b4d9d602cd1f466ac0933eb1609ce8090f839efc8507ba80a36710ad6c97bdf55be8faa727a368150992950bbc88a0a350e2933a97c99a5dac708535bab0e8a38ca807702794990b76b25998457a6fd886a20eee6cbef88d54e876438adff7b528e48cc1efef6f8ba03ca06724c8ace975eb9f4aa9b330a8bec76bccd5a4e0c8e80bd5fe8ea4369985ff36701b6c782cc070ef9d55ddc0172ad193e953d3e9abca6a8b803fb2c693d3c8cf9f6606cada9c7904d40c1996053bed6c644fc0188d43e8d62cd5d6594cba24916b223950f9a6e85c251cb5995654c146b52965f1f2bd1102e55c5c059d11e4a6a08094e139077bd5a2de2ca92dd594c81431ddb8223103f35f36ef5d240e36101e11b1e0b0b49a352005f0d8706e3ffc331876c0374243d497b6455c38398177d83e6c54d4a06c29a6216de0805faa05dd471683b622b81b807a77c3cf7475498d3ff8bb65e9c55e3ca75093e9964b781fb1d73905097a12aadd8fdb79d73659431ef32aca10365eb080744d73314aa56507e82dea5d5c6c6db23603cbc3e385fa582aed8fbb747e527f61dfde2722e6d63633a3bd1c643fc284fad03d0965bf60c5d6f2f42c069f582f1c4ac67be4dc985e5bb88ae498edfbd29451458763bd23206fe185ad609b7e0d6eb3b25c70f4e69b4a615e7d8c18e9949f463662e8374a25325d299f060915d384ce13870ef4cdca01e39b40716030cc4742879054e38ba8430a869cfde49e03f918c93262b467b41a53c98de52ac842e6ebd2598b358c2526817392737b5b501230b433896350a4b2bf4d842fc39765e37d2c1468b5447966b5d15009153e802f21906610cf146ed14c92cf89cbdd91327423b68db112594540654e9dce8fa70fa279283e40e519c7d10d71e05f398e0ec7ca86ca648b46d1d9cc9b73015a02cd445393b63c2d09125fe9cb8d95439d9b89905ade8145bcdf601b70b41d1da93c047c7b5942203890536d225045e11022b836dfdf2679178fc7e35c0b9a2b8076afcc1decb6fad6ded869e3e9c38a7500cab77cca0f2399d2db8fc21eff4d59bd8e7e4d63233d05b3686adf0b0345878d72e52772f8c3d4dfa51a684eab1c3f376a5918faf628071e791104889df897e314fb5ca3019a22b47351fce33d227e3783a559c243028ad11eebc45368699949f8890d283af6ea3df9896b90b110bce74ea3c0303babd0d875d7a4656e51d46210f778b8d778be0294ff349e3f6adf759065a39fec4aebcf7d192f7520a8a887a1f75c6450e117492391538e184cc68557418169a1d407174b9458613bdc8496c00243829f672ca03661c1d333292f37df0b3d1ab763d8d4b4c9a4ee235cb49a998fc9106d03a4ed11175b902732e8e87d05b0fbd040dccbc45b9cfd9a5aa2d18451ef52fcf3c24ffda5ad0a80160c6734f295e551332b80c25580727226407e07730404a892240cfe7feb53998696d0c8d77c99be8bfd0fc8de281bb19f586a7e778e6168204ab627d745631a24ca86efff4e27410baceb9cf14c7a4edb511d2ce6eacc6703b65b0e39d3935aaf74e8adc70329ef2a2d588b64fbe1d7dbfa4e186deb7f2c9cbf8dbc6a81dd00e3e0f1099988ddf922bd5d6de68bdbb0565d2dd2a56bcb048397dc831f53920c834f00c025b807a7c8f2f7a0d1786bd072a4b1dcc3e5c968a8c8fd220ec75fa6b610bf203e776c674c2385957e12a599137c31e0e53f005b3edf8e7c19730912eee217d61e9f5c665f6657062f0fd0357a7540b01e85ce4972bc45537316f8523c2d1bac6df75e4c729167e1f2cbbeba4fff57cbca8e5bdf23bf28d3b991f7ec317d951f470fa746bcb2c1bbae0ed509c5ee36d783ecc4d331ae9f5941213788912c2293a16730d3e0b492f4592f18accefa237e47f79701c47c2383e81a1b460508b1018bd9b5f7aa5db478da062b17df28574580e3ea6b97ff43a60b26ab71295d1af382e6b26516e5a09cdd8c39fa5ab870318c4bea115a38a30fcae853ad0cb7f1375a8d0ae885637e0c0b60e999903ea32a2455aee15f7a37c2f9008218f04cb6ee06395690971b4b0084a3cf95444b37814bf4692ab760e2ba7a0acd8036a1be4818a51e3facc567169ccd498b59e24b104ef20ecfbb15ee3259f81b65ea53dcc6dfa49044000ba29f56673de14b4cbcf2a737ff5fd48f97bc54be3a1b45e9d76abac6de6fb36bc600fe0178da1f7e52c7afc011fff3f196a804ac4d473df7a84709c749f1086fb3e6817b745b490cb05e120a7cce2e14824f7eb1c4757d993af7d02261e4acbc1d11c8fc0acfaa58a8021aa69936c4550bc2bd58b935d56997766810822c2c079c540fd8591860e315c1c8798e76f3ba4aea5154eaa2684b413a45fd2a9503f006c68fadd98d12bba506df907c2d67f05858c8ce3c8c53537c5c12a045549547bfdbb5467e4598fa44e22610f6f2f8eadc6120e03775c9bc32a41ed4c0a6abf67a905d6e7b8f8854f69e689b140c68acb80b0f46ffd5b8386a1befe6bd713cd82d37c812b1ec210540e31265dcbbba7a84024b1dfb5d9f38eb5a0425cec7de838fcd864a1d07ade07d4a7534cf4643f8cb05913fede69d3f62833467026f61b2858d22606e11565dce9c1131ff1e5c957f38ecd62457fee2014b24f2611f05e5b937c7874869722d2cbbac1f7707c9626705be9dea7aeed3738a1c8b2532be23f63a75c07630057de869c827ec60e5d09daf3153ed9305ba7eaec0922e517c644e7e9a8b3b1995964ac210c4bb1cc8f6f47d967fb9c9d3e57d4e24679046207c61ec6798c05a6da06abf545acc85656fe4b2ca9ad7c194b81719eabb5f1e5559564739479b1482d5aa2d9c69302da1b3e8cdeccc42aa1214a74dc829e62c38e5f0e5d379cf4af8610741579c13387762bf27de8cc898298c333015a2a2ff8240d9eb9af428fca7757c9c44dcbb81bf19b524701e5fb1f8183afed439ce2f7a0e78c1d882de0a393a53b075588b1b9fba9eb3e1e684c334c662c76c2c2919466301614a61369d2fee1bae403dc6146770ead66cae1646baa17176f107ffff0f6b625e4490299410199eb7823530d9bdea78d2e60d54b0b9f75a69809774970bacf9a39bb73232d388f9c4a345a1ac7f1faa675d61e7b5ceb7e7be262e678130f2f0741ed319402131352ce8bf3971ed1e8f401591c12606175269ce3154c5a6f627f9fc594accee6729962289bd50fa064da7f262fed33cbcd0a667d0bf60ed21cd92aeee6a8179a24b7d12a0282812ec587b633c0a802e398974287f8b8f03a751fd54efa11b24d3a833a7b37cb6beb6287aed109442e017411720952f0f9181bffe2284269b90d98f4c936fcac15a89df7ccd1e13aec739edd8d1dfee61b25fa94d3847e76a02336a25bc1dc7e8f1db3facf3b6ceba18131deacd88e2a30f6c248bda72121af073a596bcdbf0f8a2693089968e67a3ff726b1c71334f8d5e0cd80dfcd51be0ae59ef2366a6ceb5ca6888a22194edf771e1849d9821243c1c7fa425a996eca80b2e795e89fe1f8f2d90bbcec24ed1808ee4a595ff30aded53618104f1325802dec50d0c73e131138b66af598cd103082e65633b450a009db8b306168213a79cc1d6a76e3f73e53273e8c8e0eb289a3c490bd1699f618d63e03f099f0e17e32f62b298735debcbec38ced7ce8ca1bdb8140d999394b7b38619b6a71591fa79df503e5d9497308ce48d48c9b7cf766c419feb3aafbf0c4e24f85ceac5e0e5bbdc435b23133b9e14bf942095d849e31099c11a2711598137cb6325a44e42bdd7f31f43e70a644ccf6f914835317343f22b970b8ee2c4a188e57b8c7c90633929f16953ea7e25a31f999712aa86806acb0d3d42e70b5ed89afbd5f5a9d444755f9e4cfc61478200e1b42fe95a5c74d5b683683ed73988ea38a74f7a024c5f1aa081c4391fa467801fb4111fbc20580561efda5f72c5cadd5291b0894caae69f4a87ba69f1e1b2bc1c13cc14a9ac5321c347a7afbec5a2e458518d16142eac5e9616eb724eec264614bd399df79fade6fad4d4d0d244a4d4e2de187143168110ee8799d1009ef519ac551ce14a86a72ff95d62f29f2ff287ce71b798498749959e17bdb7785891e672468fba3b494eef2b6bf0551afaf1bc94dc99404ed7f5ebc641d22a62ec2fc30f9f1086a9802ba2033c30dfed28ef31613f040bb831d453816b7c8d1a7defc65206d63643e8a33a085baba07c5566cd69121681959bc4673b050710a8cd33ed0a3a281c9df0300a6273bb6924da71ea45b0f84f775a8349822ab823dbafbaae4c141fcb23f110e2c416a7d6ea4c612974cd8469f2d706701ced14810bcfa769de7b8c58232012b524991bf1fc6a530a808dfcf2bc937c4a900265d00f6716bb96b36cec887e3fe4728221ff1580d7ed82ded213f2952b549ee8cce855c5e84da1495f2baa058119ddc18181717c1586eb5295046e7c62c847576528d58782c0bc119a34dc7915fa05378ee006ec8e81d1ebdd002322b081bce0424bdc7f49cf2b9b4e08ddd70b922ab71e61faf6845a32aa3eeb1f03ebc2d0919bd5427da6d55dfa253da407d5843ee2b2d69b4dd244a7b3d1e0c8a7dbfb11a02d81532352d7e404e1e6ceabf2ce40e6a677af57505b3c457b0a4bb417904b59163e23039bbe0434afbd264bab6e65c74c0f7fb3eb32732ce33106dfa271246141dee9f9e30b5ad90c3390992b74a04059955a0a8e043b9f595d4b22504cdc6a9feff2382f20dcbc318a66557622b0fd068a75b589c20759c4e25503c78583672d78ec00be81fae5d028159f700d082d2a2972208b8cb44cd7234e1b0d6c1a1e4e15d32acf1de02e3a1ffa3f0fda1210badd6ce97199b3d1dfccf2e3a760cccb183ec14b2972e92b33cd7fde049e696a8bb51e82d71e35c1d9fcff3997e4ef3bd76da92be3e11ef54e986363118d890a1a913b2ec28c9e375c5d7713ce06920d22f300f3398be2aadbfbc134db50196d5d7b241e176c8cb406e8a4a3bc8f42b9f6d5c20f84329c05fdfd369a46e9c7c16bb9f0a7e759840e95c685d7e83412c87c53d9de19d40cfe450c4d41f8098b1df166d3fafa7410e1f3d00f1b86019a4b032f65dbe27d3062710968a3e2d82c2ac7e1957d9aabf62fb5ba08502b96111ee454ccea97f3b09b492aa5b33e4a5ac00eae6bc96b84242f07de0f19e07a959f2dd69111159b6699d572e4d5cdda3c39dafd93cf68d1ae1c5ac10f333dd5ad806cf34e7e9a97dd4a5350a4d8a3e5cafc2fa76f1d95858925c71be36aee42fa2a0cf38a230e6dbe399c09ec698bef02989a9fd5c423f650e0987ad7acbe47d9762d843472eb7d76e97e648a3d90b05cdb049d29c7a52f76c83f26131b85696560c4c4f4f4a9ebb458bd141785e740eb855f958dab9c0fea4019fbdee9e24d696f6104fad3bfae5e598f2edca814c02c4609cb33c7e75cdb040aabc1e381e028bdb9a7887ade93bc3f36f1e166b75e7b27e48a40ce12891170599f9df881987d0f1635b85c44caf69f5073e3a61a568d3ae7316416fe2060516f3d600e8548ca15c6c56d3a2dad25b9d43a99404b981c3c4f129319c67ec9ba9e25bb28d7fb3464c1e243603ff21578e99d884073bbb2bbdb76ede31ea204669522a3e044e4851417dd18e7d0f36b0a462ef82ae2b4f4c7d7b277b5b58ae296dc74423446028cb4b4bb13053315756d4fcbb2f6e9a284a5e3500f7e31f06705fc6afeadc740f6d600549905103dbc93f59417528703758ccf0d24917391652c31f2332b19920da8e871f64d21b5d0a09580c0ddced11affe54a6326950482d37121f269bce9f7078b14321e0776d1d4703cee438c6c0ae67ed763660a53675e00c0fbdfe9be1c55fa9003c63750b93065e9d6081ba983a68ab3bc884cfb4ab5bb74c0f90a9e890b9d6ec3addd20301f1aba6c1a9e1487853451d1cd1bd3ef4477c5baa43f875d4fe2a2e867613710183df96a8646859d584cfac5feb1d89c4b31ff41e7b28cd22f0e4aeb2ed956d811c6b966717067cf815c0eb04461f6ca2ade64cf4c852453e5a0b840110a224586156226c332d038b51a4d724b61af9f388833e65699d151fedafa89a55239adc66f3a2dba3b7d30bd0346ec2c7a6a7da2b5c90b804924368e93b2794008c121d985276d971890b281d74274152d792108409336aa3495cdf42bce4cc8d13077a03896dfdcb96655cdfe5662a3de671cd0b9fdf80cca5b5ef721b47893cd44863a2cb24825420cf90362f277ddbbe1e4909ad40fde8f4b92eb8460865bdb5c390b03fbdc081b35541485dc0df8c6fa3f9c5fd68fe89e10a3c09bb57beb7232697555ee42fef84766aea4ba8e70c3c1131ee405392825ec3267e45ea93f8cf6fd163ae516a8b86d14c39138ce904008df4fe31534bb77ccba36b812033db8c532235863f88e1e22d49470b6c300cb360ff54e56beaca4f102d09185fd86193ce7fbccce969fb490a3abda7bed3e554d08d20cfd0b2ee53a4b8e200ed2570a12ba4f219a5855413df258856881bcf2a4b25d9a5c361c5820600ad220a1f661286d5bfeb1a05f8f774b056bc183e4edb5f226be5d9b539862752e087604fe0dfba21664cb77c09e6b6f977a46a1b4afbcbf5f1b0e78b09d627d3c0f1f76f5d5ad6248ee90757237f316805c072d840483a0056efebb8b7bff1b9e0a482d434bd47fc41a42b898596d04417cd94a5f70046e156d915e10bab00da346b16bda613a57f31ffc866650307b771c1362e1886391fd55b269d35c2b9dc9d6e0a09c0fe4f5b24381f6e3942f5b9aebd14437ac943086d1dc13f91bc0bd08d353c905a6f4767eda9871e52afa3be2ffe7fd821e26a8dcfbf25830a99c03670af459d3b15995946ef3598b2d5c4d41d34ef6c082b4aa2a835cec480ad78dfde7d29861aecde850404c5d97b321af21e1f6455b90ae024abd5e10f23e46dfa52b53d18921ddb5f2686e3f9d4216a36830fe7f69395d153a71440a390596a0417e3d68f779d2641c76f365d8308223073b0703f6ddbf266674c2508958ca244f0ea9e211fedf24c81ae61b068eb4d1a5cc402092ed296a2957a1cb0cd509aa5bc7faacd474674f011804ba00e8f978d9a40120154980ab3cf2e28f47321c02de0bacc4edb6c4537147a23583d0ff03b966391d7cdeb45617eae247a48c1a72b524451ab2b10b7c74fde579335edae5dcb4c62ff035e457520e31d2eba5a9d38528856cd12ddeed088abbe50610389cb1beb95696857ea49201f3879cb428525fb107e5a75f31c9ec42254ae0beecc4fbab73881646c77580898141b469136e597e988834ded6c433ec18b767cf187aba3f4d9666c3a579f6a3dd90839d53c72c3334d77764d252d567e995f3c7d998e0514996b627be4d1fe1f08febe03b9419da5ebf91fac22823dee8da0b9803740270b196e007110dcf4957c92e7429ace9b8b55663e2f363d92ed0f13b16defe5a260a9bd49fd20696e54704b0fd90160a1cedac47f52fb5abb2bbf16321a37c096ce1935329913d184c75cd5096103c5738926eb212eddacec6ffe78a627bd43f7d96a59276192eb2438a36fb7d63c58fca6c699e53483119adf007c8756e1abf7349cdfd34801969ec9a8922795fe3cf3e64204ab1aa576c93f40f1d34d2c5911b7b59574201fabda67fa283a150b9628548ea310f39e3a81caac348b83d0010f89ee75da12427b99caff5c722cd60ad71fe1c61e8fad4bb5c9e5d74a623bc09b786107d0f49fd97e1cc563c91289f0d03ed4a865535e2ac7fe31a4665ee06a4aea314fd7f02b2f3b2a83076fc752dc2cdab0fe75f3137a50c22d165eb486a50d73b103c318ac8001a12d81212b6e29d769c5eb4447e5f854374cb94c762d11ea95f8d76815c6206df9b07f3b4df1b7213f6366462ad7d483211eb83f4713b6d0897331285a6e19d154357dd9a3928aadd1967dcbfbff04522ac9e496c9fd9fbcabc4e74ec62acea3de3d65b482f355f915207614a563fda72e624a4acfe403d9eac2d606786b004e79ab3132c5265d717f4f1be0427f1686f91c307a8b192128344582ca86766b56119bcbe755227452b1f00c53e468d651bcf8b41e8f489f34b2cc1de57cc1306f93eb00c0da132cd26e1cc553bab2c1993be8c697726db32497aeb9acd9ee4a3db16538c69e67fba4e51dfcdc90994bdf75cb2c4d92748a8b9b85b20dc10b365f6aaab25d4095c3d0df9fcb58797eb4bb9b4b0e638c712579750fb9aba227997f3283c90ddfe1a999c52727ca001ac2eeffc60b0a75b9edd2f47f2ded7624c7c3e2b8100c1a10ee6f50f501ee55f04bbed4bde9a8f3ec40e79a3f332f2d2136a631941ac25310dbf8bcfd41a7123e153758070db8ea182990e536034d2eb9341e63982d2e37bf654c53f012ed905fd9aa55ecfd3017c81c472fe1b36f8ea04d9e869e363f0d6d0b545683e1778699383857194a81f0ef7c2d426c281f19dda9979348fd01a872aa5cde62aab443076c86c3ba353879b7af6d1e4887584f536ce94c62da2bfeb50631afa511101c88a0c0dcbb00791bb2e7c59a69d44f8da7f042b0675a90c908dbd2083915bf9ac9fa907a969c9a2259c46f904b484c5351880ff3193c5984090692dd10960545b1538e9d7688a51546f9a906aedbe5ba1c4e66dba48fcf4f148e4573d19cdae2f5479af2237fe184a50a72e9d316f6cdfcd1a17821c3ac4f6a5e595af148928d54461955dca18ba58153973b3f5268e983f8f76099623662ac25e768303095801dd13fa49ce64f085e40417e8a3e924c2349280dde43619e462dd3b04a6bfd7eb648f5775d9f0a3caecf1aebe77234fd3a548e98ffd03843dd4e39e2a3ac29a2f112aa31535d4353a7634b577a7d0aef84a264e8e47dbb01da177e1b812962f9dc92043edca161e36bfa85a864167f188221493d9933418c9252817d5f7cabc6e93a1cd39afcc5a22c5829e7eea6c565821b48099b2f54c5e300ea4e6b903e6a3e313b9ae6e126cd31498f67c05119199dbf2e6972aa510a33e64b4523a2a26330dd98acc91a3c35c969a4c765efec12a2f5c1103004e03c34c6bceaf2fd99a1fd3bde872f784c4c4c401e317f75192ad42f43c93f22b953afc06dbd4c81cccb135c1b7608fe41a5327bdd78b4dbcb86b171c813f6478586ea283d271a822f37abe742339d1de7eb8f4f44d70161f8ee379ead61c5f3731b28527cce2f8a298509a129a1e5ffb82b5cdbbe97d48d900e59022d219b5a73d41fde723690fb5eb9e9b330326d9eff0c714aa9c042a007f33b536ad3b419a029beb8e9e36cd9f8c1a2150a44673db2ff3df733c629432bb90e17d3caf6430c6a9a2d5a5263bb63b7f97bc3c6dbc9d2c212fddfd8c1e2e02ae7fe85de418636099250564c81bb3a5c2d2acbd5f44806adfb0b3cb35bb3ac66c423c997f2b93bc3f12ec3edb43817fc3163aa003d28e275c33bf92c954d89c85adb57728f3f9803ce193697eae76367cdfe188d5136d38f1140dc55b6be9b72cae1f914d3884c857aefdd4237bbfca3632ba74cc346e8a891203b72b610b753f21035c24e3c80ed1c5c4240a57c7f87461633b23e0191cefc0df17306820e674f4645dc4117178c1f7108ee0b05f865e9e95852f62415def850e8a47b3a600cc9519d6552b0f66d67b168c0c5c3383b20418b5cfa8bc3d8ab22a8e406e7a5bed0762d3dc434a4fd7b2232d17f12bcd14bf36ceee057158c55127c42e1a7a7dfd42e3640b234ba352505f09234ef3009b453829176d04275379f2a1f3b8bba1074baed750da083433fce7e8137b21d8483e8d4f4a8184004d8f4d3bab996971070966b7624e0d615b68e3ef8d44b905f2e651e15208ca5a54f8958854d4afd4090c0068861fb7b159cdb466b6a5edcafaa5e2c572d76dcaf26df82f697a1951133d71de158f2e4321d77ea2438edcaecb541662f9887f39435d2d750678ce8d3f0619a08f8c150a4fc28c0ddd5d0f1b5608bf62e5c37b986750b101dcdd5194c71e6584dbd26358804815d0d3744a049e4819f7bf273ba776d3be6fe799abe95f15fb0f2c066f7fbacf74a4e49da97e28810b018ef25bf6e3b688eb8e43a17c66f458906629560b4ab492e75ea16b1e063c734c2fcc6f5cffd698207eaf2fbc8de43231ef26fcdafb7f4b1b272933b373f5c4f8bb1db32bf1852b021f5643917d5dcae20806c4594af5e9538cc89fdf6966ff16d4a97309e50ceece070bfcbca770c362be59d1379852af9c7c45a20e9a3e7cd0841f14cc5e05df4a721d32d605bd956486e81fc056e17ea895fde9adff642275f1a9201fd61e84c543d74291340cee5b5ddc207daacb7b70e00584f67d4bd4cbdace9f1445153b905ff882f558321d3ae0be56925a06e2c9a522da624d379ada768791775257ab107532b40cd75ed0337bda67aba545f0a0856c2569984e56777e9dcc4cf356465ae054e2670e25ee399b0462e951a529b22d9ef345a5bda1acf15fb7f513ae95116caace7821833921ff3b99c33ea072872c5b3dd5f57131d3c74ab5290ab194e1b10c65777fff2bccb2ac84e9984d1b8b71d24153324b3969b31d2de4f277075dc9b6a224ef5ede1f2348680fbfb5327da6c3b5c825d44dbc568504dfb983c04cd0a98362dd6f385d3b5cdcbd879bd78014a4a3a58d6a4456234ccfa9c8e21fee0ee5bd63199082b963f1f51344d7e34c8df01c31c3afda7521a40c80bb2c10622202e4a1d36b7c788b3b421a6fd7c869d50c19156e3a5485013a06d7ec66ca1c623ce55591c9b9b6cdce2b19277a6c56bc8ee760415369fb113cfeef071d46e7cd6616a7df12e7279769aae5e925224f719e0abf5066f4d145f7b7dd90ae8dfc8918fe9759c2b044eebb483cf039a15720ef17bcfc136e675c2d1be3742bb035ea190a6c98e9471d11d9f002affde17c2df9fd8a983a90b0978f6079c80c69c778e2096ffc2737c4713515b98284c267ff18184fa22f2856c2244743af728aa091def95bc22eeef51e14bbe8688dd4a5a2dcefb2f7e14d1de1875e6cf8163365abac6a82ebd6cb3d39e37676fea1597e80644b04290c45f6e46724c2fbf0b1bfed15b2f8baab657c1033b676ff0701b0fc1923f0bf87311593d6c750470b1def5113384ad273de28506b745c8133c267b6f646558e39cb17974b5202cc0d918601428cdde8dec2d2e51e353df935a8f1dc9b68bae944800ca36830cc500acc4331d093123906ca98639eed4e856a3d2774d00f52fe4d0e1c9df61e078679d1152c96358dbbea1c4b547f756b1ad36e778d9631819f5506e8f13964ff7686828e89bc20f1f3d96634281de87281822e49fa94df6bd1900f9b23b87a8ae82dbf7084cd18da0a100592353a8c14df633b7979ffc0f7d4b528fbd32c95c2cbe5f62fbd1be981d54f55198a97bcbb918157e1d961cc9f50a81e2daad1c8e486060699c4eaf38629acf52c4e057c6a81c7cd271b1fd6a281dc790b5baff74fa3eb36068265b55d8c144b93844a0f8d1263238635db4e2fb9e3014e9948a37165ffb3388f8eb6ab06fad5444c333deba73c65252f65764185c7112e52f7894e53ec5658bcfb214c501ac542cd59185635e978545ad509b2aa81288ff1c6cf024fefeb0dc690b3882ece570996f3220399b0414a913a0a5f33de9ad9ff24c46aa96401ed2920da50251996ba36d4fa9dc9edd7c149ad9ea5855ecff18b1431b32146e8ce852eea03061f6be831e3502f170d24026ec3b2e02dd033aff63f4de3b17c42e00c27d0aa14de89f6d412bb478e58ca608649e25097ac1587bd8aa598750bc6e9091cfab894354180690cb6d35888189da47a3a69501f7ca5200d4049ba241919f50d4236b635b9b96d0826a110477019e0330a8793a70a3d0f8dfb72a0076c9ff1d1c1f980943dba929ced2c8ed2b6e76fb1036ac5d424320a9d7691f6ab38bb611e6930b097f9cddccd59fc7684c8c0b2c14b5eea3b8984b77db1f1047d8abff9ddf918acc9529e1c0ece035e534c1ab5a98cb9189dc3bb05fb89e50b7d6291f9d5ba853180d8200c71f974fb08d4c5bfb17647367704651609659d8502eb4ff71ef34eecf91aaeb89296173c7741bb96feb6744352056e3585fa5c499f8dc19d68b00ae09a6f32b5168ac9ff1f158542c75e860708628ba84910df40e98e4c2cade748bf15d5d3b1c811e395c41cf3ada7197cc36439c0b1d62ae56f7c030fc36d424ad5f4c8bb05a0dc9c36138b381086078b1da202f8f05440ddb6538d2a7fd03cccd6f28f78412f18bc6edf135bbc277d9412f7b0fa627262a84b58d709288c5ef3676069a25cc69c9f89cc9a36b69f834fbe669907b87638b8caf7f8f901ba5bcd6710a2e63a2876d8252de51c6993955a26ab52e2ba530e0efe9c8b44d0c525972b5f766d388c0c6899e0ea2fb43e023040b4feb442c12bf3217354ab14c1a7560ed6621b1d9d864fb3e7d8a5a037145cd4a990322bf6490a981002cb2365ff14a5fcc00b1edbd5ff38b808d0d77c00a1bfc5e6a8f17662f96b2a1cf803dfb0bfb9601489bb6c316fba8681c7d4adc212b975adc51f27d920a324a0c7dfb0f9d6cc623eaa4aa812710dc0e254865b9725768d741fcffc54630508623ebd56461454690331374058795d6a29008f382279f0c155036f1ec2dca92eddc493e48d49dd45c6fb29d545508b130757f78f438adea5f2915108db117fd421657ef6a471a80ec3c71cee30f2f652042b1760d1e6407bbc81b0b05f1ec7b9533b3f2ef05ac8841a28f7e61624f6e7eb05e89e4fcab92384d5e1f0ab9ee42e0bb8e3183884e7e594dc32ba66c8a118b81a5b4ffd2256945b42dfc817a6da6ffd07e392b9ddecbfceba3dc869b05ba5dd9b1c0b685b6df1564ba5d109d5dae4af500bb7f2437246689906ca765de7b6d04480d5b53476a51b971d618f93c716d0745160c0fe87f2c3b687cf8108218e2c692710b22fc97c8cc3451154a613db1ae2646169f0604f65bc70eb63f0d09fd94ca1911b1386550c7dd25a2e12d8ffc81385fb6f437a69bc8ad630a29a71744bae0ea290f69690c2709aa65991e21b7fb378c5abd8146e0ca21a12f88111b06f9f4538faf1a8ef868769578f1d6b872f2a352957eab1c780012929bd2c0bafce4ce1d2d79d4edfd68f9019edfe13d64c93a9c7a90e8d2339e143bfe3ca03c771a8382af0c6356e3b9dba769b5a0bcd412dbb574839931217393c1752f9e018dda70b560f2de91cd1f0dec3d4ab1bbdafb480fb5951320191202e2fa04411c418d82d571c57cd510893efd078266a58bf9cc243b56833ba51f91fbd499513c3f915a6c1460b7db8931e6fd5fca9169ef3831caae8b342af4257f403cfb70bff9f715a3ffa7ee96724e5513aa4da2c994b9184699746c80d64cc2e212a9f89190dcfd1e3d339ddccd3c9d3ccfa857e283c6321e35ab7921b54e1a73ba4ca04c42ee91649c56d50e0ee3abcee9c3460211a39eaa34a2aa5a07dc0a197ae99c42f2a5870a81e2dc5c207809110a42e2911c7efb7b8100e66844f42cd4f97e32da36f03f2493a107b85b83fd65e2fcadc16cfbdd86f7709cbdba8ee65fa7a5e46d3275c7a99b4ddaf89ca7c205de4ec9da9e420ed5775be211023761d6a1f953d8c6141a5b7eec3f67e194a66152803649cd673c35a9d5b0c83c9f8a75c4ca7d5c9b2cdc61504ffb1b4cecddf4e41b891fe8b71fc668fdd78f7adae8062baabf4045911efc813e3a0f056dcdee23b16fd4a8a409e646d6177107fc448b94ead0dd49ca28a090c0612b63b5b237b0e9cd45dde557d5f260122d7e349712a1c2a06a2be574551c12b27c5e5043486ed126401d53e656f039a95bf6b20d8b156b3fb1e39dafc981e9376577a6da55cf94351e3c050ff508478f1d784168bf4c0d4c5619f58157084b9ef4ad6f75a4c74d62af7b5c619a38fc12c27f3ce82ec30788eddfb7acf1b40faaf7a72f4417ee4b1f9db6e243e1d92c61156f06db3d1b0acab6a1f10b4fc0aea8ef21cd1862c0745ed39b1088d264e54e21eefb8d046761078b2f4c8a7f544cf795862d37a4081603722d1cc8c3f00f5298b57f144f95b21baed1668669bb84cc42394d6ea323a696ae3fd83af3b5dc818bc4f3058ebc9c6b0d38508c0760b8aef88c858053012ad2aa7c3294a3c3bb21ac362aac5f4b122ab2d0815da574695cdbdd55e54cd1e786897452fd0c5dce9f5d95d14aed78afafc134bd83e8f37449200907f327365c7699c2a8e50cd25f59fb4beef834c03506e2aea6849b8317a6e28a30954ee9a808cb01ea8801c92ac5a5e1570bc5b0aa69a4b8c875de79a745672dfcb1701e53424e98b974caa5b7755afe201c03270e30fe3490a8f7e940113b02bfca4d237657b145132518fdfa3041b6ca0758ee353985f3d7a7cbf6fb4c1de65177a9c4591af8497e67459185fc0067c409cf46225be4a5da1ef89bca0c58ba4fdce2aecacdef2fbf1822abc90084471245bccd40e5a96c98927134dc22892b9ccc07429e3a07258d32c0dfbe4869aba1b6c10de616426c72bcebc4792e247265adbf35a8186f42b591ae6793f5078aaa2660fd362a75b89e40853387c2a3fdba4c59a1a843b1fb198d954ac1b5c9f09b6115165ade6c3bde90a1eb3760f2036f02d30b8048d75819dd12fc3a09211957facfc7627765ef3487fa62b1576787a49f5eb5fac95df8e36ed08cfaa8b86db376b5e37d04220a0cbdf3b0a046f21fb331d533be4bf6e290d39df1a915118ed45fde63d62fe69f8aa76676bc927ff6dfeed4ccf65603caf6b8cc1b336c9a6b2c1338c1fff4869d84e49da97d79f76a63eb8069f83af3636f3e60fee3d860c3d30b40dd9ad61d9c2e531b9eecc3f5efe1ca7647d2bd8aa7648e4ca045f8f40e5b9b69d2b4a002852c3d69214263edb48b91bcdfe9c2c92ed37122379e3dd6cca9b0681c49de21da60e261374cdd24b365c3272f94e2311ed8d2c7e74ae6156e391049e8fd9824f87494bccec6bf880e1277f5fca655da8dfd10d6c16c9aa51d8cabf6243166609f87a416abba432a28fac9210f0a5b0ecd3f1ef07b2c5eb389ec0d70dcd9e233ea372739938c35be34b3fa8323dbd30ce9bb9a858443c94b7336dac1f74398cbc9641f757f18c047f0ed2044dcdaa204f85887f6213e9afa3d571fdf549710021871ff571fc670d047d3d1a414b1a0651c1c3ef5c1e1b3c486205a18afd46e7a5c6a96cb340ff80cf334d365d4cb01921a6870ca74532ba874a156401cdb5543d4d3961b226ef7a9b890260223c4ed6a0ff4180f37e5ee87fea86362573f371272b2c73441a76b3bcfeb803265d97e07cce3f1306c0c2475b39cf98a32fa939c043ffd0b18805dfe421a43edaea4c111b23e0586a6343b83983d36f294e6b1e46bf459e29d73a43d6fb22366316d4d97fdf77dd6392e377dcbe143ab38a755a18aedb126afb2ee6f863ad0ff3782dbf00a7ceeda879612358288e0d88d50969fcfa23f960717f57aae0891dc7c197807a3692276cba0d0f5d910b84722a96b3a71289f89461bcc419824f306b167ce23fe36362aa98181ec2cb51ca235997e5676c55aabece016c7ef3c2b96f5877562234dd6c2b27eb3f7c9650782d73c0b97dec5a6f0afd038885fcf8931afb18de327f321ab787fec283a497928ceb4cd42632ca943f30309eec25276638c8b1ebc6ff60a29a48105e4bd3c717b2d281c9685effcfb02e74382d58c2d542ee485b7445008677f3e153a698ea9ddcd117002ac8abe6cba6fb994ffce36a2e8c22c53a99fff2d5a3634ada5e9c53833a965276c4e10bd541688230f0f2099572b9a9af52bf75c94c91d0d4e874e28b7fb592354e6ac603820fb8faf93d01a4078655c4533cbd79ee5d7d032d2a3c99a6a0ecda17fc5c6a573fb73b8608b620c35ffeb3c241f4783248ac6bc7b67fd0d152e53a532e9689db147af1b3760ab3239ff186e4269346c8b4b2fa146ec477eb057ecd66521647b735dfc7bd4e998df30fcca1e6230837528a5bd88193668040231dfd3a3c85df83361dd3d8ade21fbe94cf76e48c20e29eaa63e486722adeab0c01ffce59dfdc47877274fd918a453ad65e97fd83b3484afcb06f948dd09c5773849ebc7b5d36f404f676c2239e03af1b643cf3de3de30da7ceb8cbac0ad8471d64855d361cd6bddc5bd48b08422ff1a2e1d0a7cc013f2f27a9f0f5b3801bba39ca15ed06cb74347033c34758b5fb845e6940d1e533adc888167db17d0cedb8f5a0f255f46caae4751a76a72ff073b900884a4367ea14d15ccda2f3b296984c00f3bb8827cd1a0f220c5741010f066ed3922807e802f2a74e2c937d0422bf2f55ca38494fe1854515487d4a0b3547cc0e91cebf8cabff5d7db284693809b50f99ccb2b933058990e788a876bcb8641daa4c3470621b195b76718170b73878d4db0a44b4e5cf5873894ba6e41af9c6ce3551b5a11b89e6581dd926a6802a4157fd6c6239ffcdbc91144d9371dd5228793dc8a894804df2b4aca87590ab03507acb5cb9f139212da7139e87e50d264c5d90121ecf660368a56575d5be3bc0a80ccfcbc0d25ec7dd24cf565da4db573ac81814ebf8c47c1890cf2454c44c165c53d102baf251b74ff2899f9f96003aa94d88bb85b2c631803bacd9d2186909eed46f20c2cfef23a3d76beb57145bd647d548feaa52cd6943eb4494cef56df01729067a80c929fc0a1f3fccdaabc73be1eb68a295a506b3b82f9f99634be949c827b8a066ce839a545e4c6030ef7e7d9b0af277145e457a9a2aa82bf744439d658a8b19c9493bbb3bd4e781e641188d7d9f07e6f45fa2e66bc23bfef78d8737090fc715065bfebb4871781eb31361887f11740c6c3f1987420c7e3cb2332954541eabb88ec57444e9626ff16a4041aa934b831ea6a14dea279f5eb060624a034989a94a5a99c2085bd292797728ce088fccfcedf3ac7b7c7539eb58a1f9d4916c52b8bb715ca375bb0019af382df5946341179c82ae8a5607976240697dada8635b949bf8529c84fa8a512e4dfa819dc1ec9c2179802875e58528253e40d2edee9e822545a53243a200385f1e3bccc20ff39ed9742ee92f30456f9535071f170b347abb61a461452fab4e298f896c2836ab04960cf83ac5f187f011b885877aca7db6e209b67bcc7ba7954fcbfd9880a72dcb37f7f296afafbc34bf711bb2d4ae3bdf4a19cdfd26f4f4b4021f5b85051ca4958004f3c367e3b9da2baf3addc742836359e1020b59fa22046cb821668871efd65d7aa5a1261d03dd0653e8a8666a0df5d3869738ece898e02fb7f950fc7159e6d6cfb7f0cd30b9d9c62386d4dde91657f4731e688bdfba214ae74176da608edc104bc41d878db6d295d5a66a556bb4e988523d2eb49357a807ff0d6dd33b753cb09221e1e2032e652d17e113999bfee52518e5f396844ca0b3919e87a418f62464b2bf2ece27ffc5f27fa9b769c293bb4af8cfa2deb052a6ccfdd284e61347f274d3ffe46d8286d9b98b278fa5a6f154cb3cbe3ec1f26852817e53d8ffbd51a3378afb1a00946ece81cdcc4460b26c9b70c2a981c569502d635bf8815abd5e16ba34d8d1428c11060fe1fd3462d8aa8ed122621c5bf8780ada1488d88b381f479","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
