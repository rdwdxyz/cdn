<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"459acd02dd1a61d2690a175306cb0e51c903f6db4709ff7cb401e1d16d52bea10d1499e1aeeac94559195ed5c4235efc00417f0a954220f10f1a0c0b48c8215b950531cf875574c865f02e18fee7f81270817e57f4bd60b8d2fcdaf2e8ba9bd0d90c1b5975c8ab6cd6c1a9ad648b324dc92fcaa5d896ecd1d107b713ab72d5c93003e3960e6686ae2288733cf8aaba905aead648ae885519e8d06b107e013fabd98a269502f94f7145a680971d2e57530f278d8dc5fdc0590d4556b1f561d7cfd80cc0471d667beedc8d86b1b00e6d49406fd4ad4182a75b5814bdb8039860b3e79d64a0dd49b6170bff37691887d83e9842c493e4565e4d63fc64cf99b18e4958e1ae420057b38033b7dd5e04f6739bc08fe6094722ac628957b6ed39ddaca0b118fa0cb43abd9cf8a5620932079bebef90d1cf38af209cd96ca58b6fa9af7259812c75c91f4b97c5dd3326ca739081a0da4362b8ef8e05ba70a8e38c0515d2e00090722c81de4e4583d486ae920e0d084e3a7d5dd4df89434956a11c3cabe134e1f5dc6d51d66958f5188be4a8db22029e4626fe8f52691f89799ce44988541de1641d4a2be8fd4ad075d8d3fa9a9b6ea43e4d4fa76b16890720483aa3510d7e059b5e3c5aea04828849e29fc36de1b8361bd4a73b700858fe4f82b0c32459348ed7bb8f1b2abd7911bf43df5b272eca47cae930b80191e1c04fff263d34105c8aa2e341cabe08d21031d33bf0f5038ee01348b79f279a793e1c62087afb005e57799d1b3585943fe23fbcb34100a16a2b0e77e573939bde4e6366d7f076bc76a14129b1d4361b9cad698fc2fd4c46b8ef537c3eeaf0999d49ef776cff9b642d40c09379b09df2024a9deb61dfe31ea5264ec379a42fc13937d2522220c130f5695ea227285014dc67b6541743df7d0a15c334e487eeaed621652aa3be428aefc5bc6e470a0b4ade9fdb3a3b8eea6dc5bd7ef6adfa4f9803ecce62d940afb9a39c308a282492e951914dac262a5b58328aa41db29327e50f572e4c127d95d7bc90bde693f5f10a361db792278c74e641ae9ab1f830b9288189ace227c54d8f5300e09eb3d3af1f998373ef90d75a787b1b75b79151763f718cee99065d36f09600bf0eeff0cedb9dec5ac4b9b92b93230faa17ebbb9dc8fe19cb19ce12e6ba20d1b0ec5c30bcb53d8b6ac4e06add29bd5ff01c8d06e9d97cf228e17dfb8c030ad77d485ff74629067d3ab7b5ad107cb00ff8fe8366964be67179c5c6dd2b34b3ce5a486781b584d45a38ffd266e6c0e09b788a10d90f7b7168e4249e3d302172767aeac81e32b67c0414ad47e66fcde519712b134abc69d85642339c6c558a9cf5d6834b4f5ccd548725307efb46035ffe98bc70cdf015220cef851218c4728bb3103efe6ebe00be94ef49184c44b557e27ca54d5ace0708c8889489aea33a63f9c486d973457b06e2e7ac4b275fa8458eeba5c800ca74f984ecf628f84b2f1fd1e1f1ca66a1bd26476659f0b8b403c462a1eacc6359ded75e4e1027e59f9246efe41e170a65f696c336ae15c47d2ae9994400a7449ad37ab0983014ac77910e9384549947e054033a03f425668fdec23ab1929b9cc661b2bc041ae64cd6df611a8ffbb8b12d996ae8092278fa174016906f382f196aab3de8bb6efbd9d4fd5749b4a6c4d67bc834cc2bfbb2b0fc2c15b551792cfcc6261f583b41ceb3aafd7d4ff9647f00a5543450df7d30f056c2af8efbff468d08185533443dda3d9302c18b12804ef27b1e0b1297fa5737bae1bc3e65d8c07fee6ee192e323395be1289ad8235f4040ccb75d936119b3b3acd3cf8903d42916082110289c6a03275d02aad7268aa50d4e47130c24d59cc8efc2c137612634df623d493bdac5b757ed470bdd474323a4cbf0f2c1a171aeb6ba832a05e59f2a5a6f884c60f3856d28730cb12cf20ab3177ee8724e5bd45172bb7e2c4605be5a5270153fbef5c657a94257ee73b4a41de091316b35520c753fde6336d69f317edef9a89c56d03f4536785c87af1a85a6a75d1dd37af92b3528a5112d36c183d3c0a1b7de5be5d2594097ab01f06af81aa0b8bed70caa3a5c01e2e5bc4657bb4e0c031506963fafbd7ff7fba82ac8bf2ac7f0e8e453347cb0b13a6cec6d8ad602915a01274ba44d83163038a5f09cb54a01a965c2809c16b765bf1396f312466f7a00daf40e39bd526c14089a78b7f9852bc571eee7e06a8f12f1743902a60bbf03d014dfbe46ac1df879e55c1ca4f32504211fae5a8bc8d81ee613bd0ce737f1dd330489250d3c2583e74363129a643cde04ebd9898ce5be540731a699a703db77f897c0e4c66d0c8889c6568305af6eb266ef74f52cd942790cd8b2a3dc60ef8822443cfbc83f9284f83e099432836913c1cafb9c6a70e86f50ccc55b79f9b4414a4f0426b998007aba035dd2faf7b3b1fa5f0b2fd3fc3252c7048ccdcf6146335e9b0c34a1067e513b93730f74a232f58d385b1dde5abae289898a190bc1f204aa53a5dfa1b6f3dd29d568fababcbfba5b455af916d7c4a435674414490eb8bb6f983fc3a21c989cd1e7dc60fcc3892f88bfba71fc6f1104de65abf629829372901bb97fa8469356e2a0c8c6ca227a9167b13deb0bbbde7ca22a5cca4e4ffbb0272ec797249a52cefc7e1f9bcbd141f9585d47893045ab6074c56cf046019b4769884dae7d957f7fc06a304259fabb1a48d199e17b089655d36dc9c33bef8a6f8261514e89884dd566048ae98eb107fa7356bbf95bb25ed50e687a9720d7e9cc476da835858cead9c053729346c17c88909c0508702eaeaa9636cdc9072d5bf8a2a7639ca574816ca9448f076f4812a338c3007f4a1ce2b3c0a3957ecc5fd17812fdafc47a45cdff91f418191b005926adfef641de3ea842a92156f4ef3ac356318d2b24a9de3329080760a95f75f64193891e76741731440ff57999cdf69dca8433a3bf42d376ac95c3d44d4415c0e9cfef364c3a7ea21057b5aefd1d57ee85b55fb790c25f31fac2c7f107e151346ee170fc9e7987a31d0500e82d3747be8931bc8bc9e2b27b11f85d80fc2e564bbcefe5159a5075a3996d4a2385278ca0e5f1c6002f3898ddfbb6ebbe5c24780584384b8e2fc2fb77bcbdfbe8ac1a163169cf97337492734fab70ca8408b23daf4bbaec402403590e179f6dca504761571c94f388509f1d7c269dce055746e9b1cc22531d90dea9cbbeb8459dad43a1d983540babd85cbc7887cee87f2eb6a3cb9991ac53ece43a541861ee60b9efaa2bc591d382bbb3d95f9ba8be3e70e43293bfc6a674376356d76adaea70babc052ed5683b09c1e77464da8d0c8a0359772ad85e1a13415f9e2d26a2fd44b6f51b52c5fbd2582eaf395d7bc3dc15eebcad3921e2d08f60939c01e26e6c5bca67f5743226ab2465e490904fe81db683271002d6a5bedcf3c37daff91f4851e710ddd2ab28a8fe24d746e4c0ffffe296f85f72b43dbc9b2c3e086345263c3c8e2ed7cce4c7f56d0f73f28a4a8c886366d80b482d8043fc6363c74d2b4cbd1806cac2ce0b64ac643c2a54857480cb19ffe5c590b462f66bbf8fcb32357d2a93c25dca5cca08337b4d38d76ff2709e23f6f8de0724bf0805b307c6098b633b2d4187afe40220aa84e7e8ffce29ef025fff876822b266aafa3f7f16632485ce3bd3fb1be8eecdc193bb5ce3e5f23915cc78d669f3ae238678936a8a50dc1d25709d2d992d459e5ff463521352c9fd3d78b6e052143855fa5d00ee3d3171aa3b1632bfffd3c05c779b054efdad46668cabecbb67ee11f87bdafa059dff9be439468fe135cb6148b9a4284dd613f9f5186f7829f68b85f9b8c36661bd252fab96ffd47c012785ae1dbc94fa49edcd7ec0f944593f5673761a2f4f87e6948e2380eb58e9944e720c17f9429d3313ae4c062a369299d06398bf8b20dac48f408ee8f6cc1d12d5d8be376d3e57ba367f1183bda83d7f0c5263142c75f29f703fc0fc19f9e2d1d2cb0ee69870d99d5309450c7bf3e326ff3f6b05b9f053204fcef532e0cf9385d4cf496e160174aab6f2938395a5b388c4af434d8699cdc6e7c688fc458bab1d21a8f0a25d10568d484fd2dfa85a04c6f167107ff7616d3b53e650ecc45fd523e388959ebd48d3acbf99bb324517732687329bcfb3e0d349276af7e6995628f4280f51fdbf66bc1c2105e33777d90851fb1cb056af2d1568fcbb2109883a30e009b91b9893868a1a4b84ea109a17db0aafacfa41e1adc80b502d8f897ecda30071911b5d632953a9bb99b318a618dde82c8fbb0fc834cbe83d80792971fd074bddffa20376ee0148b7e5dff9c278fba494662868987962f832d6f9fc6fbf76c6a99a9d250c09848f3732927a3c25c0ee4661c66cb43c051903845031d4bdc8149d7020fcf75b8031806fad34516387a2d33df7e92cbaa746ae8604abfadf17e346abbba694b21dcf1d8df3308a71e7442d1e9b1fa4986e7f0990910f34899a688df5c923ce0de28b1f96208158634fba08deed42d03a7c2adf2a268e8dfc302c8930dff1604a4b65d92f051ca1d2accba1f24b524d472d6113fc4550f0b35b836f2ce59012935572c869a8b82b63ff0537fbdcfbe5636da51735156120e7999bb10fdc09f9080e695c31a8fe40c3ed78e9c6b198722dd990471ef33e73a7f466ce0f6b6e020dcaa4aa5c7e19dfccef8249bfd6f08f283e0ea741f8bb2aa67acfdbe682450d916cefe53e692493f3b412cc09f1d94e6a4984c95de22f6fa273303ff3a99f3422cdbe180948b03520ee05a9dd9aeacb00ed7bfd4ae11f25dbc3317d1f6e25f87bf3bfe6b796003eb19b2b1394cdc12d0e826047aaf6a79c51c3104c97e172f959b312ebc7838a6443f3a24cea9c5e3d5405ca7501729d59f596095b6c61e21a4e362ce697e0aa693ebbb1a45f7dd4956b95cd26929362ea2334f31cd82217e750de2f4b21271151a43dd1b3fd92a471ed435ca3cbf25b09ceb14902a20c2bb77a40bed9309f24914dea88c42d38e9f531594acd98ec62ee4374c3629665b7d333973511eae2d1fe4fa1fd1d7d16de6f32675003c9e49f7efd2fd8f1f8ea7ad0eb7d686adb60b2ac8cca1d1e469ddc16663eb6ec375acfe7a273f7eabb91ecaf5a0ebe838ef7d91009725fac58999ce486b68a207f542d01835cbf3794e1e431ff11cab7c95613f27704061f8ae69212d7b0190bdd42df1725bf45b3b99b72b4633516600524ec822e95b157c84246b85b2403bc14dd6f071ea08e187cfefd34130d970c2f5c19df31d03047fade173b9e4dbf5ce8301db47ac5696b8c13656aa545bfbd30fba64cac0f858b8eb616f06aea50e771bda20a4227490b971d0b28580d0f8ec0d346e0191cd347cd271b7c93258cf98969c63d342184334cbfac0adc829d48cdcae3112af741b7f39e83fba99e57f3807bf9f7a8dc7540e8842c446709676b37c730af8e8c2eb3273bc83ddedee7d661c435877f0abd1a95b0ed35493fa3b4e0d7d3f1e293fdcf808ab27710f17fc52fdabcb023aa234a98593b8e5f6ab5a9f14b6016d4eaf91995a176675e85d845afa1b49156a30bfc55fed7168cb2983dc9bf1ee8e8788765caae6eea1b02a6a4e85e1a08c449c63978918432a1ae2f7617dd5a23095fbecffe4bc11dae3f311552c06c211fa85516603f2d4588fccc58dad75467ff8cfae9b934c9d6f304342988bbd157c824fc5d5960cc9d3dd6c5ce594714fe3413abded8a232dd24f428e0fce9fb7f2e53a0fd9d74a95389a888ce26540e2d910fa18991621c08c6b6df4405abe86e274eba7b48c51a1f7fa7a9ce2b7619edd4ecf991bf953b4dd9e67106524d4b765f06300f3e694ca70e47b53c3157ef57d83a3fdc518c0d1c57a22b3e91756a7ed963180f7f6ce9f0fd6e154e4a6e86a23e926d18947c39aa195a084cc6b005c5562378dc8f08941b27b50253f0afba11d0995e158bf60321836896d45141a3616d2d9d8815dd0dfd62a3505bd7a33b23d2fe66f949171581f2cb6fc313220d47e8ac1a2e07aa5f4a27406e2e9a017b6529a5baff8f65a6702615e57801b65ff4c52c790b7d64f2a8dcf405b21de2ae59a8b9ee7d6443a414c552b34ef6d124f9c03683cfb449811e14a463b5e1e40516115568763ffca01561339fcb505df2b1f2d3d02ce71a6760815167dcdde0e51a2e338d8c15be685cb00e6fc6adc72bcf79710841e975424d6080b2651af6b3ee4cd746ac533fd7b1e812329a14ac45cf1ecac1fadf75905f6b749e323b9eaf62346d7ffc143abdf05faac42656828a487ecda8517099e2125bf43a0e72cd4989c32717c1f0399d5bece9c12a51d77d96dc19c34b2d7576c7480de5262475d6c689b720abb21579b9ef216bf9a116f213864a12c99f4fb932b723c3177fb3471d16a58f3e3a9cec5736b1e8200a13939e9d3d67afd13dc06f49136c2f50709d0cb5eb7ef3ba327d5e02c047f3691561c199b124029e14ce57c659484be4ca3a2c6c99ea5fda653ebdfa8f9d92d9d1664d3b2c0df3586a509f4245458f6537067249bd81f613a8fe27eb50a9ea5c719aa65a23a0900a19b0593ed06c6a78aa804cf01de71100fa7eaede862a733242f0ce652c6195e6a112ca57eebb78690fa8a351a4131dd0e6aa9cbf5949fdaf683e37f0e7094ac4d157de777f4e9b7a38ad1250637343395d1e5e41dda8a7f409c6ff98d7e171474e03552605f851535cfc393f5d7e3ecab9be679a56efe437871e80818db890a8e864d2ef0ada6a7c49e5eada8831db094c9a3d05d4821462a79da567b61ec514d7f4b1aa227139ed54f691b1dada1c7fdc2dd3d46ac0daceef725f4958bbc22cdf0ce640d633c5f84d7c31f207e8cef5c79ae5f1546ee7cd4923ea1bdbd26c4d7c6f8ffd729d59049c09376de81bf4736eb206051d5878834ce752391425a48abd590a00f31cb3b83a9332bf253f44064c904240e92a15c2120ffaefac42de7a9867455f2de86e4133f71caed31948e88f237d0e3686b1e6c3a101013679a5c092fca325a0988bd6d8395936877dbd2397f98ba6963af290783e01156bc5107e06e8198ee765967933f154d7a9017ad31161216713295c035b8419471fdd18cb0a2c2e08fb98f0ac94544adf778e287e9a91698246cb7d6b2670234df4d3b9472cf6ed378d06740160455c47e0448e82c7205c0cf50df8292de0d66f1a1b43ab5958603e100313ab26a7ea35d257f3d76f40b9446e9209e3a0f05a3c52e58dc8f370e7f8fbdda165962af1c06f53211ce05a8c4010ed157c8fcfec6688d62e612bd4f1bffe9be4b31f9553c491d0062b58faee769a6e77fc57bbf9775a5b27291d95a0a1d2d952b25f888ed83f82a442e75666aaa69ed3bd6ce50c5ef24971c799b8d39b7e8f7340807bbeb44fe53aaaaf996a12f5ed8dd89129960873dc2bcb2ac9e95eb04457e5e7d6ed7ffb93e1c5c294ed4b721a74fefeb3f9bcdd4fbae0038a2ebf2b40f5cfe7583a950ed39f6feb42df08d50cb09a2ce995964fdc1f6fd9efec5fb22c7cb6eb7fc5704cb48a483742d78c497b80d768d1768b11fc977066f40164ebb639d0b490389bc502efe3eb5b25e5a5ba22ca50cbb95a5d6da3076380e2d15287325e5dca6a323b26b73a6f29ad1b8ac43eb1b044730e26c03689108d57cda59df1a01a2c0d16a55ec86d58d90e45dee78beeea9d16fcaf782ffb832e67653481c9ad9d876a9b446d995ca70c450f9c1be1890def9ff91c4dd7ef85379a5b409f0494ad4fe734e0a8fc0fbaec41a93e03dc809333fb4dc5efbce238e140645304d39e5be0422f96dbc9afc30736103c4c774052e61dc6da4ed7a01ff05db1905563e7b6ca3a177ced7ae3b0afb50ed168c7bc0da38fb83c549dafa56ab902d979321f026af96d2132e54d4b4aacfd7648a66039de589c675c70085c5f0080e73dd9f567ad549eef82a5f0864421bb778bb652c2f31a6a354058c3125ff1ef1d874e05ab4dd13825a16bb3cd06b9dcfa525d03adf36a57d67a99227cdc29b66ce8000bc4e54a7f296fa908ad7f63a670419cc996557ab03436f8add542750e08be0217609af6b60dbfd7c9eea7df65f50a64f5b0f2a26fcc0c8e7bb0196bfc06170f54593763152bd9017bf8bea2648c45c93800fb6fa59d1730707ad1a74c27d2820ed37e2931ecea37ad159e435e364e603fd8b7f68a2b065c6380ad047bc33529f955337ab4c99f6b751905a7e491c9c63c4c9d43b83bae28607b65cb685070e6bf11fe5fc50f902904438f9da98abe59a7bf1b57145224b6dae647b0fc43184dfd28a9a19f16af9121f67857bb40f0e67a4ad832026c95ea9dea21a803461aaf1a886d44292a588e06a6bc4fc4ff27f263991ff45091d5e6043e60308680e9d950043df365deff5fae5f133bf6c6af7c23134b9f8cb1054603a3b3d7d9236e293dbb00210e399b5a99a77249ecbbcde63270713162838642e38213edd94d04b974ce6dcb82dbe740aa32dc35b060df9a8d7bac6b759e6b536fb573027fe120ffd328419ead7d7ab24c402245e62136e872bee555c7ced5953604cc6a7a95f1c780f17452d69749f2faa4b3ca96ca906b410051c30a5b2202b8935f8719652b161b08097b5fea4043062ec1d0f813a06da580390c402b0d5f5503b4a3d0eedd1bc563609594154c9e7fcb3eb541e1398b98f7ef9f766310b115462f5d1f056eed96c107356c7e9e61c59e98b7f4c77983c8011499c8fb4b6f65e20857321b42b1c95ee567165c2687137a8699aaed00987ca8b335ae1ab1306c9ffc1f267e2c238edddc5fc1f5c4e8750fd1bc920dc9703ff68087d8a8d4d1d58fbe254484989dbf34491f19bba44dc750d512dcae473ab394a06b3e4e1a24ec7b96ed0bebd80e376877d9c4f488477b2837a676fd7d7dee5c3f43e960c224696d2aa2284f184d6fbaa63cee24a6dc35e3ad55cb979252c75fc09e6d6916d687475f632364bd1bdcf7eb9da5c578f2a00d2a844b5464e4475ba89d2da542a76b8b270a6c7da2e5f1ae4d632fc28ebdaac43c4d45b9bf2f7f5a2a7482d04383c3a1175a0eac5555ae091db98dfbd515918fd725bd33adb16857bf5df5d2d6923f7a7ccf677f249876921f3d57601d20628d33856ebba8c6325ec70972c45f89710a1e55d9939a18a08710b2f7d8fc20eed4adb476197fe79e3da033a36d74ecb2a0a211750fd7ace9742c415d13ca2e8fa5d14a08d7c98feaf0a54ba6d72814f4be0ed678d3e8057d46544e5ad4287f41daee877baba61843aabbe5997d731db02bc68dc4ec995aff3bb98f7fa7be1a1316f1ebae0bf98ea4952b2808011ab4fa49037218cdf3513098acd3b81ced8fad33460b44f5ee01d2f879d5304db0fec7c26fc200c508b156d1988ccd1228f3d59b1270b5af27748bf446040c0d654d2a2b4e87f35c33e868f8971e0633024e0534a03e2a14218a067f2dd917058a7193289909ff6a24ffc25984f48777d2a0c84544f73c9a6018e150f5bf22cefaa5d7d36291393adb7a3d499e920fd6d915f2ae560de9f5f9ca16960a9078deebfe4ae285800af32be1a92637b3921b577a7438e3b2f176cc22d2a0ee30fe688653c0e72018079eb5379cd0591dfa1888f0b2bc640f6b3282b780bbe4d4e785207e031ea12bc90ac928b33f485e0d79352acef2df8222a55d5bd8c879b5d0a70f2bd836a3b0fe46be474b7b11eebdab310cb0905a1faad105377e7200bb4b4262d41c9a757e74bf4283bec3a96105e80cd76fad944569b39159ad4681e987db7c579a44ca0dff9135fa1a1170d39e5b104eb00523eb9a400a07639cde5095503658cc4af470d69f8825eabbdf79590b0338fd35755636b5450539ed26c43b2e2efbcf11406e373e8f73ffa9ad39160a0bfe26fd5c1f7610153dbb23b9a569a33815be83ec31ece03b01911936d87dbbf54241625e1c9af4a5c311f8480ca1015926374d03890a6254ebac70d48202811498be95e091e86ae7371d7585d966d6e09a35f90d99748bab335a5d99dd14cdab2fdb64d6ee0b3bb73058f37d84a66bac192411279133584480c106c5c8422501bd58109555dc54ce982bf012a66170a7b984e3777699e850366bf7f0e4692e3484180113ef95989fd9b182a80ecf3301fd4f73de74ab351d5856369f64d36d08b88b738ea1e5427362f4078be680aa9cccc6a2e1325cef5ad7dc136311eeab8ebc6c3cbdc14de97ad3941d1921fb6f71922f3bb655f95b9edda2d74e67dc56c95d0345681b57a4c9bcb78e92ff57f726e253c91a5e14ddfb6bb6baf9501ce08725624546c0c6b5be2ba6ba9507b95d0e00dd0de3f9d10a4fb4322ff91c44d9ee5a92f71813001eaa3f0cdc98730d5b082dc9e114113858531443e4b3fa89073bf45c62085d26cc0d60662c1e6bb8658f967019bdf97ee670f0012b5c32ef8d9ab5fcda9e37ed1da9092c05aefd0a1fb7bf40c2f8c4242e0427157e89e23bcf59356df933d7b685bac7ba1c525b3ca19e305277c10782a9d38d7450ce6db71f6b066927e8895599878b8b7efd744375f6c87676112ca70d8dffb2cbe499282c893b5a9bfc9894c17ea614098d4556a400c5ebe4ff550241bf6a7c9f3e5ee8e68f2429252ac436ecdb41a7130568ad708b16bca069c31bdc512320c3a6ba6e32a4d6c7cb6f1520fe3bf4a8655c439a1a61063d9363aba091952b814d28951d38b46b345ce21b3cbe37afb17dedff3062d8d162cfdd8b0b6b5c6ebc7d2ee84e32030722e88c15b43dd1dd1c5bb1685e1e4ff198c954f851b9c7a1adde3211841cfee3da3c63f226105f77861e2b742558b2a64112f9d07d2af4f62ea864e63562e6b9e0b4c4b2a7361faf39f6f9c92d596e1d0b3ecce0abd34031a0d4f60916c0afeb5677fb1bf185d9be892e3f90f3149b2009892aa1a19429f95605e53d40dbf8d1b3d0b680128196761ccb3673443978d4bc408fe9aad9f5c8b48bd59ab5f22fda54c5c3a394c60f1c899fbd1749244df8dd2e220ea9913337a27da96ae073e0d5e171ddeb02fb411426c666f1ad1cc6f2bd47ef18e0078da25c19ca5b793d389f2cd6816420af307702bafd4b6cda235207fad9186ccfb0176ee742bf3a5842fbe4ab48ada92367b9aab3dc3029d340aba259ad756e71c4a2407e3381bc2d587c3671498902eca8a2cc29bf539214b7334acc6644264930eda7d8b0b5b76a7b725ecc7829dcccc69858f9c159c40095e6044b6039579b69692de965c162860d564e0199b7b4300a975df1dfca1c8b7f6bd71b21958037f54c404fee5e3c041d60452845c03ee848921a3abdb174dfee3f1acc75c3fd9e4dc0e538521e3a0786c16bf190758f8b2f0eed3879b4534d71f4ba72aac72fe6494607f55ef1588b9b75afc02fa5411e01177f0c0c459a6183953db3021d12bbbd5de064cf308ba2416f142bf6303ba0b83c042a4da1f3d0e4a2f4a0702abd42bf4f634291c2b90d0c33655888afe0c96c0603dd10f47a6fb70b01c4d36aabedc9950c4c7cd71de9de885577c506607e98d8312be6282ac8426afcab8cd65050a776ae01ec890e4cc9d3f502a8838116532a36f4aad233e1ad93c785f6d264e6c7b2b7b9f8b1d8a35e8402313ed3fd618d7be050d1eeefceaf92ae93668eb5d2d4275319b5a33ca7271607965c12a36c70569df43c3dea214ed78949959c392c6f55838e7c22d4dfd9cb85d3558d4cdc2b1a1e16cc86a5cc760ead50e24f23d4742d43f4e3c10b5206d5aba9e09b82e62b4e22382745f008ec7625338a47ce9b5d62f24dca33ebea3e1888d8b561b3389dd5567d3eb7af04dfa75e9d4e4db4efe66591c5db3cf1a2e21765312f7dff6d2e63f4b199a5235678a951ee46f7718cbac5fa80273775678947eabd76316f583f822e441df7081f7fa630d2a651fadbb6c1bd91ae00ea2585faddca21a586b0e00e174399041e83c413228aea98d3ff4242ab2490858727339282d123c01bd38a64a1cf7ad2895ba60d59ffeeee81028d200cb8d68963badd15f402c58d7304123b679117fe55a3ae3012553a97c800f6be1c85ebebecad0025670c3ad1f6b2abe925f23ae4d00a184ed6569c292fa0b5fd9853605b2e9a2ceda3129a430ed661575b4b33bb9676c924a0b4542fb28a8768886dd56c3c972e2c3c7f679dea1752084332cc643cc458b3b92cb3963ec68beafa0d3278d16406ff2edd0bc9a438aed0b8562a7369ac0ce7c501b360ca8e67b8cf237e23f91bdecd1a143a5fca071e18c14618d0a88a66e944fcc0f177fcd1f6011130de545c50106c8512377e2870791f7da85d6b45593fbc95b7f794e95ab34711f6cb497b970732ad63a02430c924dca258ce5ee951cc7f652bf4ebb2659114cf38f4141865d9253be22a31cf48185b914633650a3cca478e0dd399890d459e2bd73b42989cf5188d53177c7364deaf526b247e51e434331a903f5777b08a10fada9586ebd224bd288063c380ff816edd08b6f0cc21e030882ad4f4420a96182488af7e09bf3571f655e91fba3d93342f09cd0ae2e2dcfe8dba1a4fc6263652dd2fe74916167952217c4107dc27cefdc59a8f74e606b3c4e93c52627f9d1d544255d21731af73f48cef97873aecf06d9701d3c95617a61bfec1ae59465c3fa6333bb30e1b08e2151180e00ee8e9564b282b3986feea750be31db2be07cfa81f6de4e5b8f0eec53336f2b1ae942f7137011a459251189f44438ee0d9bc7cd2d60bd8c934a3016d8bd6491c3d34f2ca71bba21684bcc3771d80d521d430315119065de945bf9689bf699673bf5cea30f088766e582f5b60823953a66c5c834558174dd27d0d96e9761ab98f61f53369a27718f78a02bfef6003cff1fc9cf6f409987f71a4d8c8ab2e118d1d1dc3c33c781665731a1c5b2be1e2fc4ce6f50045d2c5f9694849653c1701089fd21ac53c744e3edceef2c0f0b254fe96866db683416f6669c49fa82184e93ecc29b42c0394e95b0b097f4a13594e76a2c596eff1c55e3fe27bcd86d6469180d66185c6af24fe8dd13d96ff5da7cedfc63ff337efeb8588b6373b0b53b78bf5cea9cad7e0b57c22a5bcad4dc3ca7fb3cb8336e60beea7eeba9bf436b8f948ab811db33a6e94569d957028ed19a32c7e6d7bd05cd364dfbc3c3a67b6a242925134f212b549b8f00781e1999982357f4f7b1aaef19d5409ee54a6c39508fb61b17bbe59d15f18944d30d87375c832dc64879d2c4b5358959ffdc722da1205539d900659aa866446af27c35888378ccb7742d67a214977e8ebabbaf792de8f2eb9617bb28f2910d16b7d204019af8fdc865b61b1a2b1a83929290799bcf08a430c976f27587bdcbba7027e2ac4268ab4643222bdcce791377ef0805967afe6fd892f4fdfa3ac858f5a17791e7a06598b9b4433fb265483c0b2da220be7fdd332cd46e714ab5f8fae92181dfafa6abc01327cad97359671181613851fdd176d8b27a44908ef6a4d3fc228cce2b90557eb61171d7b8343aaf9fc150441eed5395b9334147a9a954f7e2dc08c9d98b1616da35b011ccfb9574890e2f1952e94b6c23a3658e32bf91b4f4d15710a7b8c91296cba613ae5e99bf8dce7e87e0c2b282fc15041071210adb125e026500242d47ed4d9d4b951dc880d8ce86b845f5df4c5fb6fd9493881001faac9410bc36d67438b70586ce3fdcb201fe208580ed4e08146ac32a702d272ebf6dc4363b37fa1c4e5836c4cfb8d38f17ff69fa2021635a948ae89f73fafd3be66ecea2ecaffc8440666b4706c499b9c3b4457bed800e51e0379ed25b2b19b19cda97e452135de6ca7af90a6594c6b4837c86e0dd848fc85650faa2989991025d76d6ebcc82dfad414a6f37333916fa09705c1608db6a6aa9bd1e2cee043d3770f549568cb78d7726a3fce4354b78a72aae544226f4df807f1ef54f91457db26bce82ac6fa3c1532149270d15c9e5262931c33bff0a44115a758d106e734097ced9d610597f4e4e23d23a20f66aff04eae7ec3b4cad6198c2122f10e2693633399eb04444a2caf1b1a713d257e5a196d8de76cf59f55a19f81ea4d20ebe3f0ea8eb123f9eec86393582b8eaf581b652377e1d475b89430adb0b1f932737d9a16fdaa54b965c20a9cc0558df7abd84d275574da30977f514b1527c76ff46c691ccc8740e41423c52cf685351fa44b82e3746bc0984521da65fc311cc599305fff947f54a59db7dffea3f8a5eed4adac8be57a912b4c3d96dfa5634dac5c434aa8354b6f663b4eb1e07e26da4d0844a27197c677a7ccb13ef6130bf1623e4b01a9b22c650de3edc75da36572ad59767d155dd64983b71043b5b79674c155f2a4f5e394dfd47a2e2a1d1c22d461867641ac740df3836ccc3058fec648164c9a17f5c2b2316fcd572bc446336e9c86e0db15821719671a37bc9ecddae36a8aaae01cf6cc12908709f5dc377de9c556cd846aa044a7f96a48a575b90c55e2a4ef090220234f7f7e45a61942cb40ac2b865c759aa483cfb49eba63a30624707885a71a00fff3003041ba3fae350d86fd197e3045e1a4689791ac853c8162580a4070d97c62859bf26adc4b65f1fd12c542e740e835f2167433aae19c0963a4b11788f05b943c0fb3074b04f49efac4eee4bc45de2963874dbf9ed27c1c182e10d5002c4163a3f978581ba918e9c23f6d2187e3c5825963ed921cd4516a5359ecba616520d93e483b2326719c9ac5e10e849abd2afb372a12d3a711739931ef3f472dac4d3f386afe03ec490278ab5e02a37ae0ac17bc98c90355b0de2377d7409669ba55a2f6e22d5e4e8676d93dec2f06ab03e41dcb1ecc275b85f0609534625794dcd9eb4602c091637a6767186db1e4ede58fc6a28ba33c222a39951b98e0f495502ad2bcf0c2204af17cdeb6e62b83972c18a3a26f443d2849321546f6dd2ff953c7c6ab31f146f9c557f929018d2548cc94ec62e10ca0590cd48cbd86e1589882d537a4030e5ff90b272b1379a4e1cf7aed7fc38970af74f1ca59c7b2f5f0796bca0d43d7654691016060cad102cc4a940716caa011ae1dc14047d23d47d458608652e0003b4c13661ef6cb97b5ceb5b2aed0af783b838df2ae175e0b731ad14b6cfc4d503804821bd79eac106636a8d73f10aa0a7b0b495fe683fcc090a34d4d902fa66d1e56628eb2731f76dc213583f21400a0b032d47b3b0359c48dfd36a489731a12401d82caa5137b5d84b841d5a6439d620565411ca4166cd86efb41632ea515a788d15fd398fe8d1f3f9d7c53215c02ea856661a11e606a81ab0baec3082eea086e0140a46b0c7a184f63d76747c333129960bec1a7ee180b2cc42d5ea9a13f7e54da0600e76176fec3c653a37cf7421be9d4655f0285b5a52b01cb85416278db0f4ba2ed570a8e020c74e67b708f65c962812bbe65f482674cdf65d1191a3f072c5c1476ab3b11ca351a651f0dad74a20618b77f3e18f974bbd3aee4e8484f3b64b1e3230cf594b262f03a1e2ea6b42c9f335f703b6accf78a2b05ec484afe4c3e2c60f455f6e3c05c377672cd71c98e7eb4c781b7f593fdf6274084968693c746a1346059fa9ccf66737d944eb38d8387ee87c0f0ad864f49034c1ba8e9bbaba2bd0fd7e72c04363e924c7da1144efe3b49f9c0323451c8fefac43ac48f2086a5f63991e672221aab6d9ed4ea8a716ce9ac450096be4423b04db03c11a874f1b4e31229d13bed30f0f01555f74bce78a5169cfdbb5bfa771099f82aad811912e436a1d6608924bc09f2b379d4fafc8106434a233bb1d4afd439c5cfb77c92540fc79c6a09c804b0ab7159e7fd727ea65bf56ab43b7a6fc7f9fc2ce22abdd71f9da887a127e3be95ffc73bffc24a685a48edad45df6235cec458e16c0f8a1f390cce68912edbe562bf135535c644c1831fdbce67fa9c5d4f8a652e6e2e771880079581c5a446ccb8bfb3c6e89f0955711efaafbc316a4f1f76fb0fc56a1cd99015d38ddad8754f84b5afa281b0b3d074841352ce9c7f7369c0ae1f7ea196723a628b7302b079d373652236f95f699878021f791486e4d36ad3a6d975546f05ab5bf49bb609685c8d4afa93a2192d78b53e9da24d2e6d93f71ec19297686690152f03363ab6edcea7cb5b85c3982f2d6479247e1169243577ee6d6f565c92be8f8b8bbaa3635a2c93b17e9116716ec6ef78f3fe3427b094705fa13dc6d212e4bf1acb93c1c4688429902e852462ce39ceaed31df6f12fea5b8b4af7bc04d5525c9022d91f1cf900a69d5ba40da0a41f503e67469afb72e19303894835195a38df743996d97e17bd99efb811031a2f10cc32a0d82fd89152c77defaf672287e27c644e6808308c4e75f4d3a474a243abca82dba33a83b0f8de38d65ed62505c5c82a9d0076aa26161f944971c7318870567d22294561883f3fd1a7f9288389beae99dd53de4bf878ee8eb7c661873b58ab58c7d9455deb86983836121c5e1d647a969e6c9e16a7f4683e066a1c58c00b24279e688179dd93a3bf03b06028af358bdff242906e6419f6a9313dfc3957d7678dd4d309c4c2556aa7de3c6a2e0b6d5417c92b4c0c6aabb423364d30dd058afd394394d919e3bb4aa4686140d18c65210c425abb4b50082c176fe3ae1e285bdb21633b8d145604d27b92ed406a073b92807db947f63319826e3da43082098024885b3d7244d0aebafe142bebb25361110cf5c5b42c4c9131c9110073801e5bbaad765ea49b87fe8bb54554231bf00699c04a295c3b9cdfcc3e2ff93d4c01b222358b13d86f7d2618f0a8d78e3aa7aa4a22cd6d4a0e3e2af4b2201efa9a96b917941c1d5dfb637e049a2ea722606b51bb7c2f61151df9b4f32b30d888adf4cc85aeb63832dabc69c369cd4293f48f038eb1ea06e6a0261c8ca0c9d489cd112e048c2a2cb9923a359a421510dda3db4ed7488cd923dea673e1e336661724827942261496119363343989c95925e87b29437cb634628cff1c31d3595323c2f82e6b532645421c2a2a7e70c973203745a2af3aaeab3a9af2f1f159a293ef3f2923e40d805248d99a2c3708ce3ec921ec2ee2d0a3b6c5896356ef26303b71583c8ec8693900dc3a9d54189c166be99b3c79bf64b9e6c1b49aa3e83fa3072b833b266425198c3ead63e575712450871726e0c471c9ae57c2e74ffba9bf44db2ee7374880e2e35b50e33659aa8936f37ee3763522b7d0f6ae9ecb03632fc77c0e4c96b37cc20d2364d76fb7c2ff2f1dcc0f1b7e3904e325b54426550070a6da6c8e0a25c026fc2a231ddb38dc16339f3c7af77cb9a414d775087623c4e87c701628b778ee153ce867ac2a8257561bd725dffd44ed48f4717655bec5de6621c20d066f6d1d9016a6a6068d8a70384c77b2c7733d993ca3601f33da933d891cf23575b17e723a71386bc65c7311d730d0b5d0e5a900590e1644b84ef6e8faff19d9500bf5f66eda7f760017554839d34a30d0015741928dc75bebd565c0c876d12bca6af16b629929c200af9362af951de94aa70b6a8fc441f53ef78225cbc96dd38227677ca7a98c48af70bf9fb14b21a27d0e5119ff7638186236dfdf1374856752f52927ba27e3bb92368ad922ea10666b17ab5f8c7b72d68d84e8594f62009b81477b19f7fd93455e5a2d4be0c0ccf2f63bfcca22c633fbcce5d7e611c3d15e3abe89aa6178e289de0d3722ef8c3255335c27fa0f2b16cb0a2890a75d0ad9edd1c976d90e596e07cd8ff8231ce37318e4d604d841329fbd66f627e8596bf1fe313995c89a89c524e5147a6ce8874b63c93c7795eb5c7d29cb09ca3318fba3ca0ec0d50190d0fb161fa710c6536c12c772088b4de10a3a9b2e081b86d8c438adc2c8ac521b8c4e6e332d1c09f573ec6b29b3520d38d06bbd5c7a3058fb49b4ff9b6615bf90a4457d359927f3ab94e950c2e6e74a3f37e762578cc79378bf3dcdb8866d6f992fb560dfadd6f9d6138f3b3cf894a2f529438cbaf77809057ebaf2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
