<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f0be987590e926d77090aba7f2fdf166af4f38497d38d5bbe6587be8ea97f9e790abf3abd7d1380c5b86592308bf2245db3a147bf326cd742227220ea5b4828f4ad58ce57a98b0f58504be2b112b1afd0f0605fa3aaed7c340ef73d39bd324ef2924f1df795c5d5ed4a32fdd75f113fc6ee46d8b2c2c1b90c4f797b0e70d48b7ebebe976e22934bf493b415686807e919d080c9a5b5187c4323ead3f73be2df79315d7627cbd7b58b4b50ea74dea359aabcfcea61ac4e792c984549ad91afc1fa7efd15324c6f61586b126af193c31d9a88599e9a4d63b853d277e6441d75be0b066519e275e646920ff181e8077e8ec584cb4e7efbce1f685b5de0696434d332290d4d774943e31d8385bb793732722d745bf15cebb584deba374e4a8f0601ab451c0d0eabeb2f151c9e244e1db4c687dd6c9cdcfe14d255ca449d637d7a11b4f19da47d6573a534df87544b20324e617c54c6c7f2973d5a40e409f16e67819ff62166d74bba3c1b521e6785def5fddfc43f982fd4151036b7f98ea17246ac524bc43c6d3888fd67dbce45fd44576247038df4af9828d45677ab2e9871ab20c67876e6c522ca43c0bd21e99a3f1a14195520654d46c8f0b1b5151a6bd60f32859ab44e4ba8d89f7e1deabebbd0a057e72d0831b315995b1276c57d602906e659872cd45a8d39df0ab481679176d3abe1a803a6e095601220c8bff2d94d8725979bce806b094aff18605ed7dd1cc0a1721f0851633ca972d6153cee003167760da80bd34b4dccbc73d50708840523b5fd5bd8b64afb282eca0ce2c2e6bf83d80dc84257b82563c84989ddfe33e6d507bc8ee9d5c642b79af78ad4a5ea118aa057cbba5bdcd153dfef4786fbd674b3e1f58c5a5fab196cfdd3e6ef68f88501e7a88a8289670b82b8522216049caa29b5241b34df13c0aa2fef3577c643f219d0cc392c190c72524f28556ecf35f3c4ab94324f0ea10073ab02ac8c25fda3f9d5575fad409f74aa117dbfc8e3f5727832f62d9f06e33e9cc82e74f47c296fd32192bbc78b04884c803b8a94dec41d3ca128fee654c80db0f7ffe9dc0724383c0aa467a89adcc8af6c77444e7d49e7210f24c4d9c41bcf64e16837af0f959ac95a6f74a4206f83b36cd16b019649acc02e8137978c6c9dec557bf339bc39bc4ae1722a4c429fb8f3cc659c3b699ead894161dfd590ce31a09dc865ea2947fd478a5f64861c541aa1c6c42b150e35fbf3c2e3dcef3cf4d9162af30a3a0e814702d450f761fb93b8f11ee5eb05c7771e3b94448850549acb81e8569f2d047ea6701186cb09c8bf6d0865d99def3ab6ec2b5ec2f53ea6114dcd11462405198470d7cce319302e54bb72f04cf71309888a166f4102efdc62ccdf238f936cb9a4e433324fd6976649810ab7e72b8099d3219686d83442d9955e0a200290f4ca4c2b545662f239c9e316b27526ec671eff39abc801a17b48dbf7973a7f9fdb943f78202f426818cf14d22b77ec36185398f83fce167272a56108bfc09b8c86de7584be633e684f097fd9ac0e1a19c8716a53a67fe9a1f2dcd026127d0efb76808ddc1d19cd9c49cd8c330f4eef4716d667546e2e0ac961e6c33121e1e9dbcf03e79653b0ac75d63873a18d5bb9562b99a7750d41a08cfc4cad0deb56133368f589b24f3fac490b38297a034fbc2bcbaf40dc9d9e948a51604fd15e406d805744d3551a0129d0a21594f53df53cf9b6dcf1c75a0e2d0d193674b69d65ec7869014f112dba7ec81b60a4bcc2cefac429746f026cf85c1a777308037a24c6b24594d3373e03715dd57f37c9e60527683944e0c277d260721772f9c9f6c5b4cffb203c6ea410c1b85fffe04a0d67a04ffaf7b2a63188983909058afcc01834f93ae1da7a7d8b2bc067c0c0dfe74e023d19f619dbcf42d112a5447925f8217105302895c153ab180adfd166713e2b95604a9485e51b14aaca7b19d60d4824331a4c00121afe5f718103969c811e693fad27edc4b50e5e69055249f29c603ac6d8ceaee15b4e5db1800807cf3984f681efb83d2cba0e4958b0b2eac138f7fb95cd5631fe69eaa997fc04424cd36b2af6846ceaab589d39da406f4b505a2da62ba54232331399410592356c2cd41ae575807a65db4c747047fda44e31ea10879140b979a69a30ea4b47ec5853a91f37a84f0eb465396f306614dd47f65db18a38af7cfec3a8f6ec06c7132b6ecd411d8a8dc17ff15339ef7dc21cf9f3b78d1e7283ab40fa3c9280026343339823a8d42237d3b98a11595405e127c1fdfb274f35194894bb3c19fc52fbb1b129368438e4490ef685c19f64aff4b1edf1dea8fd030108537d43ae6c58914baff696fabe9f5302493d45dce80d229f115debe0d308b9af2ac50016e3b247321ca3c83907647717c36a26eabe58a363867d247f55a8f22c1c48e122ab344243e5b0795181fe0531089fb225fc020fb709d1e07c1236708fe211d93349d5e7cb35e8bf9e4c6d788cebffab8cd729ac4f1c6a9f79d591b2e0e3b3c15703c86eea97581c366a980786589711de903e97be6583f7312ce2c0c2b379101cde9e7d59d1485b37902a2807585f65df9144e03b6ab6c85b056766f11e0cdd13f40a34541b545da72fc6946e63d74f336fdec07c508a14801701409576607de2b889bc0f41230becae2d23d36d498b373fd1924e17c43fd1b489f913225cecbeb77a9a6574cf1ff8aee718966fabc1450cdbdb50d02c39c7882299640f1185525f4532491a8e1af3d7274618462a9c522846c474fc60abc84d5e1b7c62906b99c467f20877efced92fac2355d8566c41c5e067d9c82cc7a7e16f1d97860a530a983116b3f1ec0717ff065f0e2de4a9a40b4a770baf06935fc7244faca943417ad2159d9d4f62836fffd73b2f99c91bf8a7ba7cf39d1955dd632fc2aafd7fdc4c24b605e656b7321b555b7a26b26820031433b18503906c89fd28d371c8bb3e31990f6e04bb2f0a0669ad113967e6790d03dde0158e9ef131bfcc86b17109b5a8f0621461ede3b656ecc266c6ef80f9a79211490e862eea82447e5fab7bea26e6e8f3359de1210d91af2134106e7a436e4b393fb0f6f2e24ec960bbe923b10d22ab83e185d0707b8b65c27d4392c077ada16cafbbf6141096d16fe6c703955845dba36e92b63ab5315a62233318036ef7e5a9f8d906bcf53fb9607a0a913347d2aad1e672eaaa9f46bd2d6568813d16d598d715117d1fc3c57bdc787e43d5aa063c24fc9735a61fc6c58cde00f79ae57dd0d5c5db782d34dde05bd07d72502a16a0e08ca2fb54ee7105f2292003f065ba28a244299a8453ba9bbcc047d593eae425669f97f10997e1eaa4ce11f3d747aa0295a792f30168cfd641e64692511c310f76c93a851a652acd0c6554986a8f166714a0044242f16ab073134d6d1e50bcadfa5b5acf2021ac052680da5d58256a754a9c1e74e393edda303d3307cc83840db3fc50247eb85039b768e9d82a96c132774056e6f78035d1bab9a8b177985f6ee1bbf39d24a402841174f841629de180c90bd1aecd1b19de5f7e64a273d314be60800a5989af40c97c8a2e8992d82c1e2decb16ac9ba6fe2a4649a997cd8b599bb68d2f540c991c9311635b8621dd1e4d1660ac6f649bb87a8880cd2ef1300e5b20dfc57fa0b9f87413896b56f55e979b72bdca7db75b73029381380ca2b7004162ee271049a83bbadf02476ae97aef26b4ec9cebeb9f36fa23d022e965b1c87fa7d2df586a2888b8f45415d97004001f5ce1d79d73c242ddd0ebb5233a3c546ecb8aabe5e60ad8c5818e2f32db5170b77e0b9101da84c1c33638690aae5c87c2df2d1665b63177bdd79f9bd1adfdbb14b23f18959e3244ecc7779e00b766f86eebaa3993ab9864921a5f7685f2b325cc1b37d0091c4e9e0e1ce001d6acf45b38e87ca7e8da6c286e5bb2fc5407ae13a659e7178b3c280e65da56a3a654d7f24c5561b9dd1f1a4d6183a54fb44c6e6460858f5762f996d1268f72e26f4cbba98e298d183807f7182d10aa29e541d104a772c5c97f537da9aab39a9bfd7cb95bb762549f5de4b5264b76a9dff821e7db305c464ff5025f8ff17f82703abea675aa1abbc57a75fe60e6f5f4e4a48a40f5fe08b3785915ba4a4f3794f311d986183ffd4771f5854bb0c378764ef3ab72adc7e8bf4555e635314c33226c559bb2dfd8c34f2380680ee4c69cb0171f0f219fac431a2862b8174d25da18698a4523417e6dd20d4601546b1d8c26f7b980f6345159e63e80ea2136badaf63aa3103625a8e25208b56578cb154c5aca4f6d6404233cf4afb87a3c9c4cc15141e6ee511fa6f625566d1579bc5ab6a944fdcea87d694b7c57fd122142540b4a9eb8ad2911459455d40d4e96734f04af27e7fc792c24ef4f02c7b73cd72b74f378dcf9fd328563080fef6bb15ee320d0ed0b037502a47269ac950f9057043b385af794149d19bec59fd5f07e0a3685c07692a57ee1d44369efae90fb607db3816d77f7c6d19d634aaa6363923329c452f888a0747d00edc544a1e9938bffd935f86c8eafd8b2c6ae76440eceae4f67c9f34f8ffe8f04a8632eedcd2e9acb64d0925bdb0bda28cd27d5d78e864949c81a3d34e235338d1943502e9eaeb8b708746306c44061dd5b4eff61ce9a16dcb9f961d4b2fca35ed639d02205da8d424f8f4adafd94dad2d348309e5e49eeeefee85636f2a68fbe521bbb69134e593b4899f4d0ad8595e0ede475b3c26bfb1a53db455b741b4c8614be514a082a5f3b64c39fdfb6588d3fd6287e7f0c87bbb28820e7a45c98f4f11e293dd65f904a89ad46388d39a6776f8cad8a97257e641eef5ba59e4374c10726ef8aea6f7891c0283df32d9e76a6b0e46837cd2a54c2f7885bf4f8a09c4397b1d304edf07f161fabdcf06ce5149a029c83994c265a6e3b9611db5712c6da7e15f9ed1392e80cb2a4308ef03900f4098518f184c7b862ae324538d0ea7a6048f309b747da8dc298380877ec75978c74d85da041e3e4de6ce1b08dde7493814c329025b7c02b57cf88d167c3e887da3a53b92ca4e481bc1c59e064d694e5fc1078c037f9326a68a51de87935279bfa91410b63c36278dfce0d9717b3ed06b0a18dfbe3303a5258ae9672f40ed1dce855e36fa46363a9efa4356709fa0b471235e58a0289ad0de81d5731cecddf7a08e4bb13c96c92c6f1c465b6d1e349efd3d273a57b1eb819044adcd008380f43f21a635522536596b794f2c788125371bded7274c5e9fce776f0ab0eee7cd407dca0c93d964d2a35b884b4478bfa3912c978dc86a792b8093d3b8b072c9db67a82c5303c043fb70ed2162919d43d83f45bd9dd91249e62042dd4234112fd2251eddb5449081742bab8dc1c8a041097ebd6b62af726f8257ad7f1ed95a2f3e1386194a896629b9b8c05615c374f4f6568e3d90e7276a71ffe4b3ad2e84265278043116c3c833630b1abe2f1088c9d8ec662532e9fe8954563aa0863aeb98e10a74baae7926495354709b40a46009f90ec3379d20d3c443cf4a65f9c60d1f768cd54f4c30880bda8d36badf5f0af275158e2c348455bff5071fcfb767bada7b37586345c46271755dab088d1a3962b6bbf4f30b46f0c0153495f426ebd60517039baa2fce795dca53ad9bc577d2e73374f154babb4cb962f9d9453f997f3b78930517b3140cc8f05f84014fcedff87a5f47298f8d0a5990ad78118437a0f3b104359e19f4612d0c94e30a4d1d201564469457ef594784532272b214db439d5a30f934f3b78159d58b6adb84ac2dac0d7f96494712e5053954215bfb401bc4d39dc5959ebe7257464ab7b4b002461c4dd9f3765e8057c6eecdbccb25ec93dd55cfd4d1dd60d8a3d8dc16510965c8eb5eab5edcde7fea6214f42705308da197db5e0a09546a60d811242112f6d6c9bb05b8672d49184e51fede01cc09089ea7b2c59c71e521143918a8c78d89c439b25e7da1363365a4060ac555a2c3abeeac124ba612b8bf7b4d7cb51695f044948fd26e0d96e7848affbf000a087e40b54db38d2ec38c6e6148228eaac03d5ca9856d4040fea8d84a64ef0746e42c8806b9cf33727afca94fbced3f7bda719d7d022379ba1db444631007dd8d0d7f28d30153021287e98a9b61a43a3ba5cd15b91c9ebcbb49a08b0942e5d7ebe0641ce444e6121d10310425be2a5b0000a1d516b6efabca6c529e21b1e0202f7fb45054194175c70e244d184f821d8594c3b2ab6b6c511f14e0e44025c36f9a7e1bd04f6ef76ed5cf369840c2a84c9ed8b40fc2bb862923aaca70491077207a8693d7da330034c5249f5ef9e5f52f0c04c6f58610c049a6e63ff6bf4cdff9dad775ae65503125a6f41ff5bda1af32f128ab1fb2ab748ca285d13b22f210dfe8ddbb72b81fc822645ee8c4d1032f6a83b0b09eb21b37f9d892cde02d36588b615a2ae93c6eb4507d712992c83ea7c23d9abefe834a6f084d8c90aec1dd45bbb81089a69f9172ff5bb7fc0c9658855e9ddaa1148b13b6adfa26a5db81b908e43652b39ff1de9a4992ceebf810fb18319e97a0eaa81025c9107b4efef890100fc6fafba5683b4f3b7fd2bb09cbc85cbe6c9fbdf184173d95730b2101a4f85fd69eb18402b2b6171d745a6ba4107a572648946bd577f89df188d57acb2e2b22b28e631f63c542c6fdc8be6454702322ee47a4572880f9b14a6bad9a663ceca4809723ea31967ea52517850b10c86be63cf7cdc75b8b52c1346ad8810abc304e70b699298471c89e07dcaa8a8c8da7116e2752893f4c85138dc8e8d32049ddc490ce22d287d5e2d77c8c1849204249cabe29e9a0a0287ebc420bacf80f6b6d9a28d728aa1e944295f515924027fe357f0a4efb26381d0b92aba6cf0de18c5b5b04bf8ec15a59bc51da6e8f7a92c6b4376cb59606c814377c178cd5069e7794e0091a1bb1f383a8023f84ea5d9b5a3b325195f4493af1427f955251fa5393e032f0559f39b77699b1a08937f7789774811d0347dcfa38a96d1d7130d6177de13db460a296ded40db26e5493d79fed5942ecdac255b268a430132567853830cfc4f60a66e3b2eda8ae7d66da806dad6652d2e08d05aeebe1a1df9d5d40299551ded2d98da6079a2d619cbf1ec152504baf2f4340d38101841973dafc1f4602f2d0bcae17a92f6037165d7ab888e14d1d3f3ecd48faf2a69cb2623530784f8b594634a31a0ea8af3dd000def9f5299c4d24ecc1148246fc0c1de0b170f150fa24036e1e11ca2d7189b45a706cfd3a4be7fb07f8e322cbf61dbca8bb04bdc1e15766e42d3f96824e71a52e622c9d70e7836518c5a0c2b2d96d03f69a120d205007f8f636a33972dff1541a40dc7a45d0b831b9cf7a35efaabad5b21462b3a8e188933e5a958cae0174e3d93c85503304d646ee27159ec6e97ed7379c624313025d24d212f9a6f6ad001c2fc5620adb53993f2b85c74ffb20e6c8d0a231a3526799aaf3da28989cc8b76480c7bb91daa68b46b953a76edb061fd22ea32f3eca21de66d3d8d28d1ff05fa6a7ad2dcd8e53901a07ccf7b3c89dff6d5ef9486f3e80d2691e5d53ed625d4ff76678ac8ce5f40cd978e7e2a9756f17717d45e9c1c9a05a6e292c1c5ccf4a270157b1a152dca359e59c2b015f0a7e17e66142f68e0c302d5ad5d1f8f97c07aa25d4b5f06887b87575c26d0cb460298e20b803ccf62922c4b62fc84a202a93b0962ab3f75926a2b74abd0ecd4013ad035890572f4da68a719c6798f3b724d7b8181e02de575706ae9ef7d1c714b5527ee382d2c5b1a49adf9cfd43116ad7521aacf388f42fd62ef850bc68b624b42adb60a0f52df67ec3fc350615fb1c8d48bbf12615cd20df4de3b174d5b5ea8c6d3f081d58515de1e98217c1f64fab3dd7cacf4a5aebb7f80d9101ad98a42805d957b521416e6d10feff9e7c24ff2735680d9eb137ec1ee1a6668a14e5a1c34936aa2e53a6d8513114c31716390148ff878f9b0f065cf8ec4b63cefd265665278beab705004330b1d2b6c607387678be3fe2cc590115baf414c9d0196f7a9d0387b5d041948649b5e802a04b13954bc2759c5d2b43c3fb8db0e0872a2831fda70f363488f140242a1fcc6a8180e8ff7c212e99c006e7456941673f4d713dd6186b583ee5f12b734b7886f84f6681eadbfbaa300568bd2b6ce1e946e07e71203bfe9feae278a40ad243028a2175e6b4aa4f01b54e8a02a097e461d16a09080ef648132a351d95c1929bd451a73a5dc7ec71aeb66e727bb60b68a78ade617928a56f249356ae658605b6e1526e20f8464cddd724ac3bceb43ce7c39c5e2a6b4c596a1f39686e7c6be15cfeb93c543a90bc2bd81992511e3f3c97214987c7b15449da247e4838c3b487d582b24b65fc3719620d8b20704e8147301987943c921776b0f42a75c3476c1499b445eabc9ba91eb6910dc4bda3fc7258bddcb0d55563a5c4f7c0e256a33e0face40483448e0aff5ad199dc0fc3680179037db645fdf42ccd11adc2f1dfbf2675c3bb83b1f04f5863f545a5aa38a6be692aa4d329de9d6a87eb91bc71107fb67ea37d33bd511a9222a7ff67a2662632e687eb8f23828e2bed5efa8183de6e21a8244cf7bf4aea0618f7ad8862fd0b90485a8d09e27e827e4ba0beee7efad76f95cff2380e4d83874561075a5ec486463f10ab95bde00c1c9724f172bf003519fb982fe15b02a176130f5783903af72be09486e83ddf455ac3c9dff4563d81fd0fdb9efd4ce8967ac5ca7f84eb9e66606611947ef2c673f7192557b56bb12c3251b477e3c12a5d2d5217bf728cf2e9632172d6f58dd44e791cb0d08caf477d74c03940e591f2a61d13ec1bd743738aaf0616b9dba1250438caeaa77de4018e7250156022e56309d4f8d5a83abf8c87fd45f42608788b577bd79457ec962e442e862630efaeb3da6584a013ff2506e62f7bbdfa59bbafd85ea543d36c047b14def46fe07ff88229febc66931c70c85ca5f36f101bef7a1672fd4b6b2fb00a84bb45f755f42b8c814843cee0cf3e0616f1d4c5bdf81e2fece34c45b0697c1ef50d39ec6ca480c1ecf4e49fb3fdbb9e37c2f770e75c91fc8d7523de71383228dc23298cb958d3f39964d37fa7c298a46983229ce79ed16749b30a25a106f0b51d8ad04c0ff5319f9dcbe032cd16b9d612f639ad8741c2b4f21c800b4d032c4b2e8a22d864edc91c99b42690cb2035b4b8a4e804304d40622743fe76d8a378ff4035964ee428f62f23aa35d2e4ff879ffce3d2eb86b44d68a3eff4dbb72b8d29c50920cc65045ca7baaca3ad297b3b66c365de1463873ecc32893f86f5c05b3696808d997dbec4c73e8b9bd0436f9b8653c6666ee0ef993993819792c612292c5edf5c4254e44fcfa6172d6e32b9042d6ee35d4d6cc83b858f678c02a65eb3ba714be8d5aa8526d1cf600c67687013c74ed02a60da11feb4620e49dc3eaf170a8c9e37a89d86223b88fe55190ffc7660b80a9a8c90204433f84679a8862cbf3311930035002ef71a7302d29ce05baf8e5d5608c8b4678b0a1889d9cc11347cc4e18d56b47708fa837829c6097aadb6e881c94fef2648acd7168efa7c8fd04cc548fecaeb7d91f7a312d92ab0b76d1b4f6031c0be3929f7bc911af6c4cc2137267da8ec6ef0f93cfb3283e1087d4c6024fc019eaf8bc969f911a4d10e30e95c25e1968b6ee7c3a98123a5079f0dd195f96278bfc3f1cf931ed640378592919d8b5ef0840a2b1d58928bf44fa084fe3f853fe0741c92176192c7260cb10f49f5b85c6392b168ce6cee9f575ecef159282debab732ce874c032822efb29b6e035b20ecac8ab4f23f097d01ebd17adc69cee7da72e785bfb697d45c15e3e2dd28d1a9f8be8dfdeea40184f9eab9cea3d029a116283c468000242825f42a1efd176d724c54b9dde7c9421752672aa020b063383076c2ee06d0bd2487d61609515ac04adadfbbebad4dd14c4570860955378c179d8a38a032024a9ded90b2e91a580fb58f02ab85573eb4632bf832e4ea19f7468aa374ffaa87d27707ad93ed9324a198963c3fa821a768c375e935b98b950173269e940ccfadec64202c3b4f398302afc6d6d29a86cc6b46a28d4f4ae03d72f63bc41e203dfc4888b9014cd60458f62eccf12c00ce98d6dea69619d6dca4314b8e44729ebf453d1637876510bb58f50437d45abf7fbf18f42265b19333f6a964a3193b11829d5f3bb807095a702e6c0464cc14876b3cd8d4e598342c7893b668936cff13688688610e3a1310031d11bdf4fd1b66beeb57184df2b6fc695550d71ec5ef1a293130c7b0306d890424f6cb512fcc5a23f8a78524afe5f5ca93fa7976faf2bb153b0c3fdfc60b23da2ab72a38854b7433b2aaa92b2ce60e0c6db18941cf589f60574107526e3418e03e524690d4ca4bb48d92f8210b4a75234964ef361979e75e4f4a87674801cd7486b4466a314d53bb2c03ed42d2634e6cf2a4fe86fe2cc312817d95a0ba34a8222113932bce8bf48d0a6895b138d39cc4e58de27fe4a127ffaecf776878696f246bb8c317c3bbf17f8b5ce164d4b58173c83fcecde2901a085a14ea233958b4e11aa1da2883d479a98d0fe53b0fea1eedfadeb807041137443668b3719f8ca0187070affd564ddadf21f8d8f21d3fc06a2d265bc1434156139b39bb87e6f7ff158f15a2987fe996698a7ad6632365bbf7ba1002853c63c591a98ff7081a5b76405d36cfd609362042b4de06709eb9e873e92eff3601986ab24675edfcc3f554bcbc6e93a61b68110df8bcdfef41b4f4681b25c2a4d8041825d07b51c298525159bd11160d743398daa5614f7d81f42a5206e470ae6248b97c8a07b013362982468012f11c11226c13a6cd31ed78bf2d66478c4da649271053469b789e48757628ee62b853356c14d7eec0538db03adb620903ff2ad2eed3854bb4a648224072910de2d2ec4ac8bed71c1b77d903930025b71c40a7676b9151e49907e0d3cf153de1b6fe78f47b2b0c1e32deac1c46086fd95dd6acfee6a51a1b8dacdda38b30f0855c6b7a9939a012380ab20f8c0d4e3f13744272ed96c84d6fe96a87450bcda9ec03f9c7e08fa6c99d044d5188d177654a28a0669befdec1918115c4633541454d46e25f3fbaf0db3cdb3c9f35568515e48baab2bacb94d3086dba2ae228fbd63a68f9da60e423fb2cbcb8eaa07a69cd0d79763c69988d48ab034ed14c47726a4f0cd299ec40cd4f332bc33c8a9f8ba5056c722e369b690c1fa254cc9886a167a54f9853ef141761ce734ff5684de5df3d8cfaa2ce99d4204129973dcf4f6f76501f135b941b7aa1004ff911e6a677429d5006535a27f651a2b5c7d7e3605b5c22a752be696d5d528ce128737a0feab75baa75a8b56beab626300dbd14939f03d8f8624edb0850d3fc328cbf650e42bc1b43aea1904e6799c8f4b603839a466284760e22be3e7a5bded3872994351b8403ab527e3b87eedb7ee125d7652412ffce11fadf502e3650f1acab5c35d492c08d62f673e20bdfb7eba7f55079ac04187248053ea776015c711d6708a102348c54058b5db343dd5a0b891967f51fcf4a148b51dec485fef1e72c1f25e1e552cdcd1bbd46af216e3652f0193f08da087cbdb69d05672fa2b4bf227d830db1b6c2595dd58a75ca49a2a7fb09a440f65adec126ae5952227d9414dfcb71b31ef98b52ff6bdcc0ffc1a777f2d25e159c827660cbd49506fef2b93cc66342676c7a2d6dc1bda63bbd6de3f114fbe6fb3f5e5ae7a7c3c7fa759c18185920090d692e920d5a281a3e6d089312563382a47ae4ccc89a09b5471e9fd51a56cb96c76028c589cb6bc3f7f16c03354b1096a878e5249f2bb775e5dd6c8786dac83bb65d1aa51f75e826f4979a42f5892a0f9f9a7fe8055de45c064ffc0577df0d4f23290d7f87a3cf2e31885e0862564b2f1ddfae5eda07c0f71d0f5fcf5316fb7ce3b0c99a78732b96ebb161da233240af9db77f8812a5e6e83eb2139c8342db351feeb08cb4845e58e0a0058a7c926eeb3585d424c3f3c95608b4d14d2088123efe328f71394fa1a286cfc2707e0ec251c7b13394d897ace1c7adc93a7367b64a052d322fcabce0815cd746742b92f89085b0560583984c4cf51198a37e3444027216e9346f0f2c5726eea08e4f54d9b2e670df29c09c1959802e4e3be88e17bf047533b1bfec64fa7428247a7f5294422ac2bdd6e05ee24c57786e02b04f974e068586ed5c4f69ef0e8c044b203a8f8acc626a6084aefdb037feaeb9b273c13bd7ca9c9ca8da6f83b74025972f6dc0c28799a98f9d0bf94ace9139dcc0bb6b9e8fd0b1ae67f5cea21b2a7431d1f549317c38e4220c0f0a41fd4c5e6866e5bef108568fa457954a2d73decf13ba61e7ca5d1b97307b7b1d84511e0e78fab3ea9ee0d6bbcc64075713bcf2e530cd12b4d62e3fb86f06645928e8442252cb8052952da59b828ac96ab929440a803782bb08c6c9085dbe5b5d943eaec90044fc57b0a2f2bfc1e55d25513c84e88c209192b1bc4daa085b0cda8c0f4181d981cb062a73f79fbc0ea4dd0d98633682fb94134376efd8f003a5384fddf3d4ae44bc96f7095fa4740f0294379adc67e2d0ee5c331d04dcc176ffd8acfedb64643dce063a3e0b1b26fbb087f4898f0de7e190d00d1decbfb3ccfbf9b15bd4ba126489a41650680af85505ce8032aa97f6807c7ce824ae0da40dc1844b771f09e5c5696ae58d2900a06ad1a7467ed6ec639f8b6f698e96a3aa37534d8a7adc88b547fb1d7f3c9ab64448fb093cfcf89f04bcac44990df7bb7b5e13943257b2e1c25a205bcdd98dd95ec65f7711b81ce7ba87801f2ecfcdb1833f339316f3c0f807bc5f3ef1821482ee1ab5627a389f5d4d65134c37a765855fa619835d1b31117eea47fb8282823dcc4a8946d5f87598eb3d815d637f5f050441a0df38901f03d9aa7ad10093f7ebfa751ffc8545b2af00a49a5c7c4330c6d29de8c9b2b3f2a69b49faff35b94204c4cbad27024ff53760a7c3009aa9403a30c7a7f36f9ac604974f870da266a5bde8d7624830f781d36af1da68041546a4ec93d111f667e292fcb5aedb3fd0b3ec93dfb5a509d19b1746c08b737c1545ce5777d9be71825df14f0f1820bc6a3c052e73ea3917774a46c936e5d112def9dd9e91b6315e0981c014bfb4f4490da9b6873803b1d13ebd1d118c65b1b7b0c61051899ea3666c812ac5f831228f06492e7a7579e0e47181ce5ea81db906382915b9a6902bdd9a85bfcf1a10742ef047272df7f4001d6de5aa156fd09adbbb7a3ab9070f69bad590e2115040e6ee493b246697e3fe29cd95c570c42438797c2f159421917447e2f2d9c8507e7ada19cf1f4ae9de9c371e106d261445230c4fdbf0d0adb8c63dcf2ccee3f365200919a178f1423ded8f9e35f05cc20eca3f96afeb200409250ebd102db20de3df5cd9e82234200265cfe4d4f214ce1776240b73aa8193c5c004d22a6c942b0a1cadd96cf5afbf1d6448ba771fa3abfcb01dce54a5d5686f49b3a2ae2c6aee5fa3705a667686c38dc77f496e3d149cd7be343f97a39ee92df342932ed0d98cc3db55ea88bf8e54084096d7ca91cdece884a597d0cc9ecfac6a99a875e695f87f0cfd2963615df86de85eda2f6e0c1f4e2bb4eefae562082c079a56fd1a798b7c9a5d77b904a7017c9601ed274d85bc31b227cceb39b693c5311bba9ba3f1d408b4bfa7dbeb63e4dfcdde97c0aeb76b249882d0c39143eb39bd925e72367e4ef64a5c6da4347b36822c215558d7f2a44e10225685507d8b16975dea30c3afbe01c2d31db771e0dd5942ed23295d183dd935f841de9fb1209d6e5b5c7aaf792cb4f4e3b1fc7066e0be3585106ca128ae883ec039a48439f85b48245e4438299974061226eccdcabc2ae93d1d9f7af0ab430ce1c5d67a5af291551e1fc405e71ca98e7f74c09c52bbd13b5e0958682bc787ed21dd6e45eb00fb0b0c15828b7d996620fae8d66d8840705506cf0e1faae1fc714e8d69c8b5b542e9a00fb9fa8da5c7969f62e6e21184222eef6de3395f7724d0afd0c7935a989a19e62bdd216188eaee4bc7e87b7a106960bfb17403e8fa9e15141d981c222dd496eb533f9e8f239311c8bf184b7d4e41b1005a787b70259b8098ba90a3b9a29e09fed8342843e202b84a352f91ca566427b0a2786c3b03e6f020e16d9a402137ee845e84e660030e5685109267b44334f65f45c478662ea4f36d2b0d7bf6fdde4a90f15172b8e4dfd2b6d1bc0be158c1062bd05f2e01212e7ed538e934ede6dc299bc6f0c6c13d152afe8857e7698a9a58bbaa8906a4b3705d71eceb05e626184b5d1d1722453b10b4f32f9e307886f7215cf6cb943c5bed5e0718caad562291477ad669d9615506e50757fc24b1ead6b635375bdf3c0402fa24f3af240341e5bdba35a69123eae1697ea1488f9830ebb73cad4d8ab9a4164c797891fed4f5bff21fd9ea2062750ba06079fbdd3df572f58eda4cff374d1778a6523ef868b0c5c56ca8a385d1657e0b32bccc7e1fe416a8abb98a14b899b22171acbdaf62c63bd75deee4f86797c1125bd718dc1f810eb8bcb25c71e12b2e4e8d30468a9b662d4cf0cedb3c2a7329269f949930f69a3e280c9afc5aa6b1ad597893502efa2716cd002a84c5e4d56113bbfb7c1588918a69cdf15ab4c0f0688305dceba5781bad1102cd3823512f976afd4c3c1a7373275532e620f8da5e381e7d63ac0fb9186dd2a7d2b7d8c1d3ac57355331d2be000db6dac1048b4a1e1e3aed92b2ebce4bec664abae846eed5fcc0a39317e9da55ee949df0358384fd6bdf1a92bc32bab95045a020c4997c4b055139e2e20e383f02534c9090f26c57e6bdc4e896131805be7a5c4ab830d7945fa3eed5924a8c595b3a64141650f5b55dc6f668854f1b8cb2f3ecf5740a2010c64e98e381c7a2fbb9d03e536921b84cb6692b7b0774213abbeb66c2582ddadf8e02186a3198960b66deb07d0542926bfbb179bf79e5c0a1e436a9197bb4f3cbd059c460859c10ebb0f35473dc2b6b971499d7b994a0670b74fcacb6d78b92baeb1455662b452ff1d337e43969afffe86f02dca3c49860f0c53f8bc2044f387a34127819ec321d44fe2dba00095c22fe9a42c47e2bd4f849f736d87b27b3929213dba53f61e5f642283de2a540d56d9a2c1ed9fbc189ea99974f52504448c17ef3c2b3ff09b4f73b3ad8c4bd3a709c0d3e965d06d97bd54d112a0783ddbad49ec5c101f46303d78418c456692dc2e21412c7df8afd5094ebb14aa7e8984f3b43e569c463baee4706850fa762d223f1f944d4d24ea265173d6d9698740e09f80bd14fea37b680e4babca4b3b214f1053d7a1cc6b1906656e9aac6a55852a40a41826e485b2356062052a7af8d1a9c141f90221b331bedc8c1bf365bec04d44018915ad219d60fd559a9cb9e736726c6450aabec428e059de8c4df5e19a79af3fabd950dc5a4bb98bc3126f5d2ac4452ebc8bddbcc927306e7116d569998ecc0c5153dc7cc30aea78bdb902911de57bf560c4c5fe94a2dd4c2484bf81a56a53985976d2738ab2d060bc054af2d7a47c13e6eb02d064540efdde791d8ef5e015f4e78bbead6e791ab5298a7a5c72c3d7f6b102959125e521716f643c747b6691afe0d3ebd7f08edf1b45ecd60044dc4ea68210f0ae6734fe0d08276cd912b6067aea73c633c220ec739f53e9f87d977d6478c26751ecc67c82699912a675b50e47446b7bea4922acbc1c596b1dab108f3de858f5bc12fb38d00c135051da42fe47943d162bc3cc89925f6fc892ede20b07b59bb14daa9afe245979aaef660091cd552f5a569c7d9717006a8ec7150232d7f62b517deced6830d612d341e098a10a4d3aad9f4d75bae52dfa7eab47369e9f3bd116778375bd3cc67683ebdcc561127ccb70dbc46e14b0b49df5e96f02f216da37ea56a2912a3d8c49ffb0e09a48cade81b702fb8987cd11c36c2f579d3b5f6b2c339ae42d6b1f86e4ccfe0e0904babd11209d4c073ce2ba64efc6782284368a785852576fb19107484072c9237de535360a66178c4c12aad722a4128c5d3a5fbb04336c4d6fd44300bcce99ef6ddade5f1c39f99f0cf5022850ad15475574f3a1fa66b0914c0329d0910aa7638a5bfadacb5e0897547b1160bf0827954c9e851c8b88371710306717a6509c36c706e87e97383a935e0ab003f51ec9e31de9d6eafbb257c24140ddf9ebee9366ed5737627641bc769aeba22a3bfbb77c237265eed0c61c9ef947593d32fc7904db34bc47c47a059a42d52773c0b25fe0d73a07a442338a3b266414d474e5cfea0eb5b24cec7de7d272631a101c6695af61d62861dc01f31b80d6117e807b49ae15d0cfdd750b54b1bcf371d383cf3ce3693e23c365cbde23871b58e2c4bee045162643b95e1d8cb4ec769a187a49af76a202813e6f2a0a616764bc9fdb668c7376cfced7a2e5b7f15637f31984d18c8ce8b5cc8a4d13218786adaafca16a76bf57c1fe967ecc68430036fe4a8fce86ecb62328bf727dd375a142899764b40ddc04c11f3e1e02ed2a2e75e852da8a6dfb504ee01aa05303170230af0da660dc02591a42883518919fbe9a5b8f33549674231de76ee3d9514753cb18c1666259780639c3b0596c4b526ba4b2e0c7ec531dddb0173fbf45db7c7eab0c24f04ec13536669ca1b7a56c339fbb77717f732348bfa6af1577df8c61b7609eeafddc40484579f9912b840543972ffe51b1b178f1d17b753721874380807c2e44e6480d0c6c27fc595cfef57b9f6c7fb8640aee84bf6cf4c08d34f420d1766e64af096a930357272a988a3430dba67ca42bde235340bd4cf340c11c168ef9f72c5fb63056734e2e4ef78a81c05a934ccdfd8c6ff39dad37fea91e53d0f59f420480b7ae43a2f53ff78344ff54599bc5537e9306548f8be297b347321e59da4acc87cdf9203f23ede6e238afbbe802d19e7814ada3eb165d90453dba0f9f8aefcfdf42dc7f6d47d2ceeab8a7b1df588dc2e28311e18131bc8d1fb6219d715f768172af7dd3d82fdcec42265b8c7b0af53453a5bfde3db26fb92f90ccf1ac36a9965c403e665343a84ef22232a7e2e4a7a2ab34da3ed7883f7e83baf01496b01dc2e81ac7c616cf0b13d818885ed1cf11160f0c3b44c41baebafba636ddc59510ac3dc6238703a2ace89cc20b4c16e99526dd1d7c771549019025a755909b6db951403490c5ad4c756c9d7020f6f2cb91d02367cf687fd0e7f6a920c59010e3ad8c6360b33068817fccdbb9b10029a9d7ddc12256b23242686e02e6bbe1f7d5d88d958cf53ec378972ffced675db239c8782ea9305ba1492f0681191e5afed03bc195b27cc11fe8d4649de5ea877d548ce6d7360112222e4ba0fe79eba8116401ad30ef3e9f53f462b996cf581240ecf86598af10093cd60c320bddd57a4f3681666eda56a76a3f8288581e8000ea00ccd029948073c300c9f3259f6a507361e56be5f5846a1bc46277b927b99c8aac4ba9d6e1f83d2c359eea2219af0fb2997fa37164d172be4a18a9f8690bc85a774495f10a3bd1cecaccff0ac811e7d3e6d9bbc6f5df12a659453094b54233164d5c1446e0e58377679db71d1549756c194869ae104e0cfe5fdff79abf20fb632329dec867c3d2c8b339cf12c237514a0cfa4b3ec83d3f0176ebc3aacf23ded1622c350c56f82b653aa0a5008acb9ac249205beedcae4ea48ad683e5e71abbd56eea57df78ec2dc3eab24b5da78772d080f4a5100ec947de6776a5b6b595f1ed133b5b0a09388c8017038fbb0cf5bb3e61dde669667d22ab640257432b1e91b7f6e7dd2cc32880a1d5dfaffa6c98d93a7d267505644cf93415693edeb1e17459b11d661fe8cd020a067fb057432931097918ae8958cd6abc63aafa22a4156becf71776395839f9739149fae0b6008858d4554ed27f2cc985fa0262265f8622beca539a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
