<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6851c3186fe67fb09f48a99573494e775ee14bcaa4dfedb82a619362add78ad91176e79dcfbf92674c46b0ec7629ccd51f74b3f8656afe0c3c1ceeaf8cbf42422c2e872e0c9463af2a93072711bcaee735ba26654059fc8e805f92ff50ffb0e9f647227dca1558a306137452879c701349aed44be168220543af368704cac2f139c1e84bfd2e021671e5bad1d86122d94f34fc77bdff74093defcf590036320679d3b48f9e0770316e50f1725e19e0db18a1e1614b2259b8c6f7ea7414ec594f51287e03028d4fb97338eda9dbb74634ced4fc981816e0bd751216a26cd2dfe64cb3c510820e587021f789d2991cdfef80f7da91ba4a13fcf78c665ace6da57667c55dce38a3cd08f86cb0dd33d953ad64958cdb59648673c4905d29ea192b5b53068ae568bf4d59b4fe1a35cb820136f5f1937b43f74ca84deea037027ab783a8cc4e41308b4d4d29f7b09dab4b552d08a0cdd4e6b18213fdd911333e3744d22ea7b03d4bd7e55ad8a2d887cd24ac2c7612ab7c9e8021f6f98427e035124740c820194e8761488d6d0098742ecff4d68156f7b105926a122484d6cb6b263bf91c123de6fb062969b55d81d42aa2b5f24cee1bf926485ebf83cc4de56c17433f2922219883eaa917305032d51e23d569318fe2d4b46131d94e15424f68e3582a31ebcaadd71063e692bf82fc8711972a08c6cfb47d2e9415cb9b80ecc66c63e836c41fe1310a53eabcfce6f9c692488029837fce9acb3764555aab7a2d053036e7fdb4c68f8a98c9fcbd51b118211df95f0fa82f8d6dfb83f6b6687691e6ce07fe68247082de1021c7251cf5e60675d43674611adead5d735321e878958e304ef4ec551c7aa14e5e3084f17ae3ec091d7a300ec0ac488c0b7ee5d08e06db94339c7744143de9ccffca7bc883e762fc10d343158ba76f3c11a0ef69a168ae553fd3fe5a1e127907e39024f67eb9cf4c85d60100883a9f810cbc845988fb5b46171c9c22af1b703d53e964252b1a11c93455765d545a4e166d6e8c95fc5f95c75c5793af18f9e4545c8039425f2a976b73473d842a629c74056a5a9d62c73b91ebb0945bc3862e13bbeb24b5ed51a4ec747927291a8f16744d7c752400a091d7980fb34a7bb371cfa7e096bb9691e3ee584d42dbddd8c9c9d7404ec1b3c20f09d832c6cabc17465b4d564c74fc7411cbb3f02b075852d4e298676c82596293019af14839c22e0009c0ffdbce684098d88554b64fb421a917669b569f87854e3b06caa97be6d24b70837d56fadf972de841c03017adbf07735fb350dda71158e822324cdcc5f98b21e526235e8af419c58c22e8e4fb0f18f2893173b689ed96e6beda08a6e65d1ff3de7b378a68a02b0ab4fb7c381ec6d48bb48616fdb4641057b6d77109e4c5d74566dd8e7640a0a2e75616a59a36da5891735b56d05b1ebdafbf8fd3dd514fee0803123e07f3e9d3d5950bcbb30fdf9db2707020e2e7ca99db2734c6e407e870842cacff2c13260dcc0ceaee679c98f4de7e076ade2800ca2d9cd97d0e0ea702f7ae3f3ac19633ec42350c1e2843286c68f5b42c266f921eb99ed22cf3522fc758f6de69136f9de9630f30f565585fb1c39b880e73ac9395dcf0e2305e67bd8589d43caef3a03e210f5190262cd02ad92f0ec7aed704f9f4aa5c5119eebed6e37aac64bb5a22b6722ef42db2175ddb1f921bfde6047d58df982d412895ca10bc1b7085cda270f5ae0819832801ea7ad49ca40038b7aa9b21cb486444b7c7fa4cee6f41f2c49e78f1e92a09afcedcdc981ad7e1b0e7cc170b786f814152fdcdab76363caa2c301a93e9e45e892c540621cab5d837b6d9efd0730b42fbecc47751c321e5ba03d88f0eb6933276e628241d3ed4226ff8cfefb29adfdf19558d498e6fa0a95fb343fa187e447c2c41b20e295d780ddb0549cab67a0c3ec26b8ced837189215945929bf9ca3bf4a88fc020240b626c17d3a275c24b0b6e2be894e744653b052b4a05d9b8bcf6cc7bc7badcf1b74c1b2091cde4b65c1dee2104de05cff66a881f64f77740b3a3f34df94a3dea731096ea4e70d255c9b9d837404f44ad63020d690eea956bd19f153cbc1c9092653f950085f58d5f90c37bf26eb63acd944a777c51b2e2da8410f3ec4616924c6e68eb8c8ef4f0ef2d70ac679e581b64d81ad286ce84ebe0e436f878ddfbc8c4ce1ea683d7a0d7e9431cca0942a7a78b4a45d9af350b72a4af93653a5bd70083a426e46ec3bf590932f034f88589964f19cd07ff497ec307cd1e67193fcaae43e3a25116e254d1869c652affc4affb74b8dec621a59d804bbba6f2e68febed06703b13367e4c8399df5810f51c4f02a9e1b707f02b027ee05f03dc491b6cfcacba8eecb297863eaaded7707aed4572464b2bbe44c197c04092e97015d46355797c011e6ed52055c268ea499d9c97d4e01920d8e0805b9a58978ecd4fd3693d8648a4d91622ef6bd9269d934147094f6af637a0cb2617e2f7fc570b8b15a174eabdf2ba58284dfac736bdea6b8d2ce7b53c7d18e13a519540ee49a9beb5e1c5eeb6aa3dd4edcd0cbaed3fa15293878c358cfff167f2afca96fce60d9cd24686a45c396283bbcf0c41a73b14e75a7890f8aa6560e32230555bb30e1e1c2a351959761236f06ffb2acdea4710014c489dc6b9796e6a093e1d2c55bfe51944a6d219edcae504cfe81a61c4c13e0fbc43ff8dfe09adff5c7b395b5d8636dd8c67963982409d38e0e1d52eef02ca000eed092debba55fb469b3b6ce089ee7354ac7f3588e05b545bd3d653e3697f76cb5719d7dce1da2c892b412a8353b46a3861643ff9d603e63ca147ce2576a0f06f3447ed2241eecfe0c24720f12ae41f79355d3984adc7178092f9a141adcc8114391a0fbf8e9eb298f940524ae1356653b4219e7a51ba4c3ed83ffb2b09c7a7b82d7c9cc3b8c4ff60514a36d1bcdd7e4bc5e02d0755b9e93305fa15affaaeee277bd2d8e19857e7b90342dc83d2af96a2bacb5e97844b8e8f60ede55d9b9e41ae3fe73b1e141391af18073bf1d63fe9b39f4513d5dbaf122cfc41002ebc5bb2abdd2a73e184e5a082b728706a91f8c484cb6c2dce1783891ffe731bec39c35d9e22cc7972d861ca0373adee5e5ec51b3464824cd97e8fbf2d3355f162102edc01448e045e7545f17050d43cab0a27164ad3acfbfff9b92239503f5b388f532b1843a122e50f0b7f137d826456e3653d6f532f694922a90fd1a898430f26501acb1738ac1b90ca634e0c58c1bdf855375b089171518f2de212a8e93f0ca76c774282a0fdfd1db415198767696b922e2e86ba038f69ebb274b4b337c4305ee3bc3bea616110cf5c87e6a1128f2d0a6061a9aaeedbbfe7bf3b36e4afc1ec1de9b0749171b9324b632ce65580c0021132d7d9ec4904248a7c20ffef2bd26b747f0d7f49d4d522b91b849cd25de7590af08fd6a6b2a1a207095faa0dd5062219126feebbb3805b399e9c720b1162a6dffe6e6d8cdd0ddf1abe95b2b311f80e7003cbaa82ed10492a90894d540b1a197a6bda134b5771fcf63f9183e0e0da7a343ce0db31302552427d5c220c9c67cf02ae3c5e7b24d458565f721c38f75979b8a755022390a924da923db097dbfcfc79f351c510a0e8c70c54edaf22d05c74ae21e6f73ef8137b00e0a5ac2531edb2cf808da817a785d0474254f8b56a49fc8eaf3136e9b21ca49b5ab1c217a644051a6ad246b73ff186795cf86d43d000d743f4335958dad5d77923dcc472d1a703d768e9df1d949481fae2fa3f5c1788e29c92c28c4aa3bb03e68ed3acd5bed4a3fd694da585b458eba6f1716c6a3796b7309259b0bae82ece0cb9d4eddb451c3c4d54f9297378247d327aeade748255310e664c858a9331100f80636010007f7c0d38bcf4321f5260d83cf0bf2dcfd2356a003c86ac07706af425a0c47830a2c8d459fd59bc94b70ead916f5fa7fc3183c45388392312b244979ef72b9ed1dfed7d7f881f72a8d20271d7b4eed88b4df98df668aa3d9c34bf192f5d1fdad6d42bd90778c8a6c846f0121bf26f87345397bb1ec70a22c83d1ec35d6846c9b5887e0793ef4e0e28454ca9fcf35dd3ac413a8b415a69a88a90f09a0e4bba4690c0116488616e7fae257d8dc594b7c4540ff1e651a0f9d311553e298f5d62d41004070bfe18af9ca2f654897b38c84b6fe87721b3c439f410c305dbb55f4f2532f64ca0b0109ee259d95be51cf10f8517a1317c8710f83c9ffc74db5b0be19f693a306af3e18768d467bf1c5c0f3d1fdc7197653b95139ab7c3871b0333cd1dc3b5057d0a523b3ee9d87cc3470e1cb65cc6c7cae1a41d8e4e193d039935a11c9c45535ddcf17409b1b08d31bd2e52a4b59c1ffca5931c5883e1c8bc7fc60e7599295a7c2cdd338876655a68a08962360bd5b3ddefb0612d5b5fe1584fbcc2c4f9e5b868166425d9bb9eaa394c33befe71326216688acd02e503c9a85c07f0cd39fa01c0254bdb75d4f4094bba104b3d006d9f77fda1f7e0078a06f1c204ec2486a65f0c75eead1524e1e2543c29806a629d3f0ed153ac0965ebee369f6ddf2cb406beeb8cad68ce0db33dc0b8dbcc5f0b3bb153c0f5cf5c4a1776e55a477163f49e0bcfacd442320cbb06be057f3d2bec8e76c9e87adb65b36d747fd0b034209fecd57d4d9d7bb7c164309db6e2891d2ece934c6188a987651b81c807a326895799a28efab6273994dc910ec8266ff232e9f1ea3a687c7bcb9bf0e66eae75855275d77e524f320612e96ad06c929295bee4fd74e9df36b319a7599cdaf1a19200bde24a6c39d030b07ac871bbde01334901828a71c1ee4450dda86461c9b3ff4898a62a099a1c70e28b6a52b6f2d1a48ef22031aa4de849deedd89cd4bd92b28263ad8bf84d17b81bd2992aa8b4308fefacdfabc1f6ab09b23cf2f54332923cf8fbff51669bca6d48f7e388d4c995f95b62d7fe2cd517127608d3815b9e592168fc2b35195925262bdf976a1ba9c73fe302bb2fcfbfc27ca54b170133ae0cb6d50704ee96be1381874ffd21998d0d5305710c181b74fc56b31e2164bde2caa294e7b3bc753e5357aa06279bd273ce09c4c18e28f4f9bd88e66a138f47ae4e51a6d8a9feaff303e95f9cb1260f05962e528b4d0f60be8b2ac08f51d5340fcf199a8f9ba545ffb7e2d53559b99f9739c5b836e4b11be2b676907c6c9a4d656a8fcc078e3cfe33bc9917f1f798742b1b1e8fa7178b5e1d324aeec2fadf2a1ef4a908e2553e654d5d73d9603dbcf7fff2629f8e54f9ed445dd677752cdc228c22189f2a507dbe86edbfbb0e1ba6801fe41e2ea0af0b6fac5e822336f323fc9321f1f16ca31eba65ac996e35403d9a14419b46d0b215824171fef7dbfaf01b4f277c0cac02330717544727143884bb9356fb771969e117ef4571302ef42c3675f3207d79e8f91ceadaa193c24bf01fa812fe113c6dcc80b978da6362a6815eb76ba4a0ee5d7b76874aed4db41c56e26476e4025871c1d0718fe3ab901e525ac3de49422f2fbaddb2fb70c22bf86bea78e41e2a148ce8059f0b09f320649ebcf8c0f734916f1e1b9fea0ed84c71ede12a4cc48af7a6ab3150c228cdd809db153d8e6c0b8493a1330c7d56d504346f8e3e1b4ed781eab6606e892b17aa3344d411751d673e1cb9ffca692c415cb6d28a4bbe92cc6af330887f69f7da8192ab408debc57576dcb3ebbda4defdee1fbff63ee28326b3efa65dc397df13cea2780790b8e53d6af3d9b52b29fde236f36c01c5769c388bda8b9cefb132dcb203c5b153ccc5049079f409b4ad697692bed6cb677d7051bfb107ec1d414dbd11417960ceac3bedbe996845bdae1c97f3bf28983dbde4ee421f033c36aea502c7769fcdb18911d979fee70257f90915bc900ca50b893a81d1e51c393fe4612cb3989c85f0b01bafaa4410b32dc7d6a70ba5bae6be53b890c1267c71a4c708fe085caa656b291985e6898d84194014876d4e9fcf19fb1b860a55694d9410966db4137ad32823e4a92c098715d9a126239e7dfd3626c44f5039cbcc8f89f312d8699b570e3a79698bc4010ac5d6d9113956cc30b48e3c79f1b4296b08a803e4013ce62c011f331eed09cdfe8afa8ea358d02ae0130e22daf308bbf306e0ac9d256757659333c4126384af68fcbc29928950f06357fa0ecefed68a64194419453ed0654332632bbc0a44d97e4433b2969dfbd38b49632804f38a11866cee34cb4072b0c40a1c470060f2f7106d608e5fbae38c80f4d69ba1b837ed282074149dcf1fc09c163b84d03b552f6128ebafbe589f44a68e528349d0271172b0de98228df99273a9a2257bb15236539437f7fd5da8cde07aebbc029686cfea9dfd5db7142c92deebf2f61b17984898ff00ccc0884472ded80d10b3e653d53c85b07935605a6599bc97cddf51bf7f0932867ce0ef0536ea1fc37a624320c68d3415829753e9d2ce5b7c1c99af0b756c4658f64fe68d28e42e5f5c330679b6bbf4a59c50ee0f934eefd8b55c267f7cb8e44e5827a6df857b74f681b18ddfde60f464acd7de9459a8e16dbd9aa073b38f0b6c44292ec2300a56d41fdddabfbe2df783a2a1bb33dad9667cc9f921e47eb665c5cb4873b29e45e4abc303bec85514b332b4af5841a43d9245a45841d9448e27ac3581056d9779c913969693883c54c9fe27e58d6544f192f03f94f5fcaa3225c1c2b1d7b8405d63c1b308357afc1df4ccbab6a6762155106ae1b325494815e5dce4c6d71b5deeea0682f9e0ded96e7904f0210a53b2bc48ac7f5574a32339f76ab0add320d7c2d8d47c5752a458db06198f158404e49482aa97205aeaa1bb203fafd858735a056e395bd8d7fd98ee48d4c76aa8d579becd5bbcdf0d1e5ad9de1985c20f34d8b5c4d4751a3c6893d38ae8a64a0c95232aaada0673f1865fb24a60305978826330c88b7f41b74c2dacac399620032331e1d45d9cc253e471ae8c491e40f427398fc2e4966ddd1072570ed3e1bd4cd56219374dc896b365869f2a19455f96b43e3d55832f98f0c1c6cf308ebeb5e6a5d7a28dc121e744265fd9b7cb5b506f5e2ad210b84994a63e1b01e909302de9cc1841060c3e18552817bfd118265615e7f2487b75937941aaddc924759843b368035f41d8f7966cd19983cda1d93df36df751b3c19e7d17b4d3e9a780db5dad7ea6272ff1c1d4767dd538361fd4d421fc680a695b42e55dc647361a3c6b430648dc75386f71ca134902e0c42f51c5da9f75fa39be3fa1dc0321673e94cab4894d78a0155a5017bceaf8796c7508b4db72a62dc6e7874e695156347d24285e47dbf18d6aa972b93670dd27c28cfafbe7c4c6a8034d7c57050ca6ab17bfabd01b9262082e4b924a07d956e2c33a50145449cf5c4c03d7a5f40cd79ef80de84b7e02976415d7b54407014c9b44bf3f6be4a448f585b6a7e762756f12b90daf9cdc0d917cdb53572c93bfe4dc4f235d10f68a437fd52508e13d3e1266ee87abd54475a539fa0b87d7173f5e2af3b2d58889e80422df05f65fac255a2693e9a845e942fa54084a1f86a8c69d291421e6865ed9cda19e46c3f8c10c8d1134761f5193ebf8b77948fc74f582111f5ac60c7329d5bac5765725c3082dac25661970d4290e8fe90dfdd9669259a1bd2cc266cdc15ee6995dd19fbf6e5f3a38f43dba16920764db35c9e607db93e2b3b339beba174277f69af6993b99cc1a835ae2b93e0f40296875cd1de2d7c66a2dfe73c05f475d08517874db3bed6f9e6f78bd1d2ec835baee585a7e3bcdc65dfdef0dd989ca4c1e5a1f0d363ddb364675abe8ae32aadcbb6ab927452deae8460462114b1abb1a18ceeeed38caf319d5e44325be20a22106fa7273a5a98a19a9ab4a6411921b43ed6de33452e0688c40da7a5a63d03f1a028a04049c8d13ced72b6b2dc31647e321bb3874bb00fd84cd82c8ccbc6237e245868c3cf323ae3cb19140ae3c4c858d07d745958e3c5249721b9b94a33be2575b9cd9521fb21525978e18a324c28e0407859b781bc383cf4e8264f1fc3e3356793810c2a791d6deb8b93b9b423122058e796f3831c7de25c4f065bfaf68e91aed53e2c5c9ce7c130ef460f0b318ff6aa080cc4a69c4a302c75c03b82a6fff52ce63a3d1a0e868e0639c096ae4ceef369c9563c95b2a76ba8e604d45faea735160205a170db414a6729486e8db19b2edd6a8480700e491917863a10ec9beb7973fb464916b0585719545590455893f0c9b5de715c1f52ba9c1e7dca88039e390c09d42707da23d7cc7aeb941c6123a85f82c82afab998d3dac7352c291cc06f1bd29a7ecc0c9ed02c35fce63290bd5732a98854f2fb5c656f63ab3012223eeaf34d068ce3425f73e309955f94533051ea35b8fb8f91ced42dc6671de6eb29158ecb30da4cc7f290f57c15f624c4eba82eee34298f2b81c720161999c9eb0ea250744c6c94abb043ad98d77e1bf8b1b1158b1dd7d9d83e88184b02b46e5d40791d2d94b0b4fbdba74d425773183949f7eace87a53d5a0b9a6e06f176bad0b20c935d2f3e2d94ad480bc5c4b3f1d8e316d6625005a0706b64b00b556472042f1dce3f5c0de575c1aae13d94f46c3953c0f7833ebac22c4ff0a25614323afb6aa3bc3c110a1d8680781b63a6233158939ae187f9eddcb3a881d2904aa8959d18115b89c9000c2b12e318344c18f76a71d2ab170fd6c950a80e28efa9524c2e09e512a7e4037b54d7efd44629dd4390c42692e0ca5b355dcf1d229f3c762cd0dfb09082d85358d4936c5f2f72a83afb83680ab3bd07e2afd2d48e9109055f0047fdaddf6531a83ea2331ed0fc8c907cf4d35d84b8f38502f2ce8560eff31d3721202be614622c1710941372df0befb7d90a1d3a35b4793f06439e2b3910834cf07fbdf4da1ca5af0e34b63b4e498c2dfe9bc5417b3f7c74af7819e599ed77c03208e533655faaf38894cc9bf336d5280e5cf6b9c0607e6551223ee452c71ebb1014f2c2b581aba4e44a7c6b44041dcce9064a155e74aef1497fcc65413277b613f54ca3b8dd10a61f034ba530fa550699a78765e06669e51d102625f2fc7f5f70f4b28a51cc0eaf3f8c669340fd3bd604db6835bcfd15406e2d605807d908fbaf5641b7e68384befb02329d3a2f3304b86d298831f7b85c9ecc1f52d2ddfa26ea94b6dfeddc170d9eef9979af7861557c22fef4d18076365dd4a74e4f7f926c69dba14b0a6400459c11363f8305ba809cfe30632bc4c690f241c9964d4503154632b0925925cab9cbfb68448b92642a91be791073a8c90b71c6dd444a0407843a5a8422400ee5200cf486c95e0fb76b5ca9913fd788c7703b45bbd1462eece1a9d9fc4375a42a6ef2721ecb033ff46740a2f03a8af3d87d5e668bdebdcbf7944ca62bb43e210b0993b56af3c761c7866a470ea5c5bf6f584f6368fec2fcdefc04ec9dcbb56a645b0f1a6bafba39992e19b15e91d0da12ce453b6ec3852883ee7ba228ac9dcf1f0e0950af62d0702b88edccc4bf2846c398810327ae4ab64d2d11df507c81c7d969ebafe6fa54b818d7efd8414fb7abb8128cf2d3284d53742fdb6294743630a520417425ea844b039073035277ab2ac8388c84ad54e51e800943a41ee9faac41659b37476b4527f4e0b8fe3ed963a6dc27eb5a10b9b508ebb71d2416968e520b1691a5b4a4ba344828bef29e49ddf964b2cc40cdbaf9c676154590bedd60d68fd0c398fb7f5f2e6d5d2e1efba40f4614f3024037e0b3bbee47574015b94277970eafa72c8a4d564ac158bcc4cf3d0a7e9b3d71f98b044d2f165b527f6ea8f68d831cd96192e9705fd51bafd000ee984380c2db072a21abfd9bfadc87e1071d9438f528343b8b5fffeb1a32588735ba438c08fe936bd09d3e29194cc543c508dca94692ed9a920eb0d5923c331463d39d0d36eb9c8ffbda2c7959f1582d74aa1c1304a64eee6fc4df515d9f0a50e6a12c32f21948dde1b5f9b5f33426806e72f74ae3f7dbdc243d74b91a0fb10bad841685f28fab8bbbb421ea99f7f60a9dd9055990fccf0ef6df7fc9f0ffeb8c1fd14c6b722b37f3695bf76e88bd5a3d62e9d706a8f2d1ebd92fdfc5c37f9f6313c7e8842108b6897e635d310280e93a46191bb07171959ade88b76e7d3fff4beb4be0259a24fa9204eb61eaf147c0497f11e2f72a0d80260fb4e1849090415b97040c473e0f1e1990806c9d752525fc5ce8badca55801ed69d5d6c78b0280724566845ace7fdeac5d512e7a17008fe1b205e63bc230a2ce775c34af01f6c2f32926ecc6ca2abc0274972313dadd93d2effbe518a740739df3886721f5413b6c3ceb6142861078a5437593cb78c7da1e86c3399e56a27c76248e3ca7a533ceaa1ff05a18310fdf6ca10c16f87858f0d3565e20c1a371a6bb7ccf33c75d35179598011a63d00cc654a94be6a0215880251006ed9e8164bb7f13438bd3d03958a08f6b01e38bce5c36548b25b239bb01d876a28101d77624284ec541568c97e8d86507f54cd72a64809aca88e65a076e7c0763a23df822dc853b2d1e44cdd32f98b3aff6ae3c37378791683c5f977dc1ce2cb1be46835c330f6cf64a310b5148d9edbc5cc5e4fe41ac2da4a11d69d4488d03766fec9adb390d4574241d7385a75b9c3e1b0b4e2733b963714af6ae8dea128b4e0aab891409508e092bc2370dace780e5b1f59e93e5cc8626912f08b47feba000b9b0a7e8d8849c602718e0ba5443c2453541b51c8681e6d5f402c44808155979c921e09b370abe222c1eefc5b9c56c59e089dfed8e62742c2299b769f6dfb792e17525b24ab31adbbc35760711331c1e4c09449174c835c74700d350a7377328544c7a90a5006e446006fd7e8570f0a7e5226dc71f138e5ab6bbe583374e4d10fd1cbdcf2e0f100ccc7b5ea6449e3de5477dfdcbb14138f1ed77da609f120785695158b2d893d020e8113e5182687a149d875b09dc136f6aba862d3e81cbc049b2bf766050e003da54baade4f5a2c1e4f50cf6f40d9acf454b16ea9689eec0f70ad1e637d7c55860dbe49cc95c9a43a3225b083fb65a75cd7aa6a7378fa2767b820d7c16251331a4e09e5295a1c2abc652bdc626a3256c6d72b4182dae84eb71d1a20a6e2872ba6ee2dd5e08dab2c316f0d7b75ae5b77ed3314bc9bfd81f819b74ec614b967aa50ed6f78b0a1f8b275fe917802863f7f3ca9a5330f141737c4110a4a9b29e7d47125ab210005bf73d4546ce3d0437265367caba8d9439a29459d8b1517d16fe971271995bd65fc0535b666f31a2f59a11decb5087384ba42a21f396c49cb31c940d67b80a025b74dc0e766e9fc07a8037eaea0e8ad90613410645e78581d2427e9143d98eb511ebb964d9cc1b5f281678aa71d75c01f3b5af2330d5f75174f6cb707c61f703975efa8f84fd4c2a7c84d65b4a3023459118175fbcf4ebecb5171b606533c6e285b9b026b6958a48c522ca53a4b74cde64815e530e04de7b1f85b510d84d5e4c802daef87a478ce917e72c7db8d5dccb6fc791b2ba9d5394410ac81241192f8cfb98b7992fd1ec3b5867dadd480c9269e563c949148dc7dc54eb2e4805fe2135322ea575814a8905e4f65808c8cb9d6e1fd6ed0f1f318a9b6c1a5b6a9f027a9e6942a1725f07a0fe2f34517608aafd9ee77acde5c250ec2bc9d1f9a3785a9fbab8e8bc10c016b5c67d1d591f43f63ec91ce0b60a17451cab4577ac7d66e2baa5119ece73952d3a2e736a619284e003cca966b7f50c79f7cbfa2907459e2e05682a5a26da41c56a6b7814e24a837d482fc2112c69739c6297dd295e26c090132d7feac6bcf43379740462df33270709c3dd885fc9fcb58249387e371bd8b288284c1f71335c0d563d7f0094a688591f56854a6445f4447bf87129f441ae568338cea4a7a7865aae5c9e1e8ce3a24656ce7965db13fffb6193e863598b3205d2487ba4217305a815c4b320ec2370b563366754decc467e947d9be33e944c08fecbcedb584cf1c396116e47da1724aba76daa349502ae14eeefd6454074c5bb744c29eed13961b5afe5d4340c20eeb35d78cea7209b11787dc2278b4faa55b767a0db80bf788f7842338a4f211b091aeafc88ba22d60fbf771ccceaffb323a29f2044e8af8f542ae310cad39f0f1a68e186a6884a3ad9a08a011dab93baca5fc7d36ff80879b4a7caf3a47d6c4248af9614390ed0779627127fc0f49e042fcc13fb72ec21e81204a3a8f2f74e1cea749c5e90f42a3bad789c44783d42c6a1a581dcf45607a1834fc8c074ddcf9b9254040a8c6e05bc84436d100804f955ba3d4dda7bed75533388ff4ba99b8fee17ccff8cd5c7b33d51b05cf3b31f932afbca18ca35ef7698fed57e7a423c3c76debc71512b2cbe6956fe6f1c061bc6390d379e63b5bcc74093f6434ecbeed3ca51df3e8a13ec8ff44b4a7f41d0a3528554347ec28928538e9842b99aac9a410e0e2fec3a089c3fed4f1470ee2f64e7789212b248a0ec7644bd1a391e3f2fc2d6c9bab7eebe8b4601cd47526b5fec26498b495eda89f29e33bc5c1300b4ac53f0f499e7572dc6374b903b2a4b02c116fdac22456d51002b6ef4523304560245e8153201be298fa82e837274494d374e5dc32272b9e90c41564fd3010dd1316f26a471225255393a0acb91aef6144dea821118bd66bf77735933d59ca995001b3a77ebdab103c0c0d0cb40283c5889ba54574caeb225265517ab4ef6d54e0886f020ea9dfc367d3a7b760963b6136842aa44a703470b0d051a60b46aaa2e0e744261e98c7e8d95401e75367f2b7b288091beebd8703560abad38e0691cb898321ac788ff1ddfbcca28124f18585ef95e30979f4c9c69c91d8d3c5b0863e4ee6c7bd2f69f35b35c1a81a580e9a456f5019d3e3348f8611688bb0fbad19f48b5ef3fadb4a24dc2397677db945e03b8d2e5caf24165283a48cbe505470a0db9ac0b426efec796ed605f0677fd725f5a074629a5c79679eb41bb6f45f08262386ed62af952ea0b2c95d1fb1a171d9687f1d147dbce218586d9a1a71d885624fc4966f3ec7c8a38e6c64f95ac8f9f1344ab3e7d918d167f47f6159f1dbae00aca71287f2c8a182b0dbd8bc91f5f346dbbc24a3d5d6660a3d403e3c455ba8a87e5a615da10a573fd2d1723e5c607d71481b8dd10bbdbfb96e1ed150ac834ba64d4ed5437c2391612ec3ea98a32831692b9f0b55423d5b1f9e364fcd3ec558f42a0973de56bdb561a15be3b55a9e53713cb82f3a1a16fbc493503b2ae7112fc85c641faff86110d90376480262f6d8cb6f0c400a2c211b894877467e47c0b2efd023994c9e3509d451bfb8944b6ad6fc2459a3d35b499da97e682cf6fcf115b27808d5ca59a38015a6ee07e26fa9cd92cb228ee350d8bead591de42725f840f8de02d68dc250af4491bf212f9f7e854ed9239c228bbfacda550030da936675f0ad2146621f810ab65bf885996783f008e98bfc9f716be939306e03e96bd68468d35804e180cde5f0efc914161f7e02d24ac0b8e2dda87ae14a3da58ae304277f3715eb01b828bc1e23b0de5eaa00f431c8e69e7311aa5d6889a8a37f3827fcfc45995f673314c899362fac0b2c8154b15933e491a9ef9c2436c8ac8b8426569ed5afb538befadf6884bc6379acc8f8e983e1c2bbc73c87ee06ec1b3ed5a4c600a75810ddd2b0fb3482661cff1aed41bee460c59c04bbd58580aa093672df68c228907ee54427b683512e31d25931ec89bbe193b26bdba9021c78c4d02b8a2d37d14cdc4dcaee4f7ab9647e2630ee4e3a17b94bac2bd8e1be9ff9a035ce3279f825ddc6f732a3542a5930c1fd524609c1a2679f2669bc264d852a1e6b8cb15e72980da9e2d0787320e47fce2689ed4c336272ace1c3670c68161c7e73ad4a17ac55b2d095e8cb74ab785ebec05d2aa451ca7f721ab4c118c61d343b511b9ff3ae2e2f30fd7fb8e3be93b09208585b17b10ebf6bf3a91c09e3a58116a15b0ef1338cbac49ac6b29c3a3f3d3050a8f8136e19b6f91272979508f1862356d89271960ec974276c81d5bfbef5db4b5975cf2cf5b336ba2ac9736dbb4abaee84bfd1c97bd439427cbd68908b1418ad318786de5b1c017f51b089a01aaa3a6111ca791f48f057be79ce41d031069c4386a39b0fac7f10873c9115d262122c0c948b6587310c7ab5efe91e5edaaa3d9e5819cd7f65f8c2b4d99a468aba968fc8da707abbc63c21a04a71ef2250e8b64046dbe2e0641b18de6394e0ca352a28562f413c38a41f25eeac13bd0d154e9f4b0f3c3330545be83bd737f88931f36cf88823f694e4b11c0292e0af37197f42f3044f6cd368ead6fed60ff4134d5d2e66a9ba1d6d5cd32758c71b5e6ce0154ecfa3018520b251df38105aed216a52f21c0827ddcf312462298f7d4879f73bd9872b66ec2302041576c6cabc36afa0fdf7d48662638346beb5c82a03718b5dcf9db59867331948204d7b6dfa286487b0e8541e9d0bddd927a9d8ad3e33b97e3d8627e2f4758fdac543371cb3d2f163fdbf762e2531f480bf4f235a77e229873adc2af525be8d27b9654f0511efda8e48f681ad4074c142a5e95fcd08ce83b34a047fd71a5cafaa7c0724784b0f5ef617c9c757926937654ad67f6d8388a20408ffc0044a8a4b1c678ed88ceda1a4b9bca635c467b2decac95f58842e472d30a444d9e64f02f2636f070eba06cb47f8d934c4872966aea48b4c1ae04d1777c16ef2ce7b31c230e1f654f7a260ac62497127e385a6d6ac9aae2eec5a8488bde560ec83883290ee952ad15ff76ac46737f032c4e06f2880882fbe5ac47933c323ed1150faa00f479a8bc2d72aed0eec26a2a51a75df6cee038275f79c505812f26b7d806979469e59cc5dc376b07d55c38294283d4c6d18d104727ce679cd5f45aaa9c52a12b2391721bef3749d3724c7e84a4bd741ac7843974c4c6d0652c4ec6b935fc48620fb6379205ee3eed4ae94f559768f7612ec86479812c166f3a8236dcd55c913a560eb9ce37e67f80afcd0d18057e1a927108af822b653c081169926d8c6f60d625185db82d83289e65ee5bdceafd8791b65f0baa991839b291f7cc02f7df6a9b0f539288365653950756921fe7947579057aff0dfe24551396cc58603b47163fca0134eecae4c2885bf4e4c3ccb6dc051d1da4a502397a6399d874dae924a8deb4db13b2384bdd1ace3652584b6e45f499855ea62ce1075732c22220797ec2368710092bc1c73bfee629fc7ce18c6fd87bc660aef13be65232583b8e09ffbc0537dbac8730ac9b99be7ebac8501181ca2ec525c02c92947f6ca08087923a7dacee88a05890b0defc106e2a04783334db9415508a6e55dc824eabbce8b52fe84252ce2de8c6e0fd20039bff2e732a81e27642fbafdcd773151ab4a5304d2730b7b165b89a95fef90a25724ef3a8f15bd25380f35d601b1c055c39eede2b8a735c14d25b352f92cb5f715692bdbb4453e3bbde6ca5de9afd59af73d492122ec2acf0243e1c229d6a42fb7e25b9956662ffa822aab64df71486b47ff448af201f2a97fa97798f2f8102b599753bd75a3229b4b8c08672e5722f7648832418203cf038ba5d78f83037a26ad692eca3784ab3c69a04b99f5c23b2d17f1cb72dc9508aa752362b1ad6866046c5eb4469196a84a302f6f39e2d55c1441d724b44668d8e27c0309d34ccc8fe6be624c87e3c5c5f270824a76fde971bcc02b13426954ce05251a82e8d802a122bbdefed8619d6b54461d5878a171d1eb585d4cdab2f757516e87c310820b2a5f990a96d227664f2630374e48cd7e720e59b95813e6b669fa9732c98d0439c44b8c6ae93050ccdab73b0ab3391a5240fec3013037895f99f6c5ae7baa7056c441238ca81a84327aad950bee593a8e2cd2e0f2c2004f9fbbecc26619980edd05422751d95852adbdf5733fb9a47e553cd719fd5c302b3148e092781496e16ea942811819918e1bebd0fc9ae8d0ddcba32113b0542f199883de2457eeed617ade490c136f31adf41b04e2e781095708aa16cff8264924b667be0909ce35a0e86a67d2216f4e1a7b4219bbcc130fb3d73f28664343ac25aa24886236c456f0f6f3950ec2db477f7afa6ec823eab76fbc4f129eaa2d95c1b192fc53a1836715fbcb8cc980d1e873042346427bae22593fc78ab491ffbaa4c49c3ef4f892fa0024b80c0fc5c965e7bcea6f9a566f5dbf6a106f84a6eaf2b2a6155b244f5f37d9906be78614f0576ca429cbd1b310a597509e66ca9958f6084b16e7fedc17182b118967d4d2c10fd7d077da5d3dee3d5cd7eac9f6188629c86fb947d05239c7c4ec6bc3663c03455a5888ed72259b8a7a16d1e393db51f6c4652d30c7abed6642fafe001e091f135d3ec9333c215d4873f28f8772b22b593903dd22b740c940de684e8b2aa0018aceca2521894019a364498a583b4c88cf83285867e1de3243730a508e70c6a655f393f68abf653f5e717f0d79ed6de5bc96e5de854782c8408abd5834e7b6fc0818c38ba30f39e2193e55804397e41245c64dc29dbc82d12df2623f93aedc880658bad70aa49e11c76a5fe3d0459a3e7d90d6b2117353ae23e496362de1a9bfd4a54cf46021d4da0fb2f1189b57a1cf5e59b6c8d09f94d011cb946955d02037baafe2eafaade1524228d32e095f92b92b3c2c941f93106aef0ef02d64adcf55126a596b2b32d7bce46a66c03d383c988b0f82c46f3b5773be4227180198e74787eda3f1225d54822a84eecd87bbb2b4a18b338f0a49f79efaa3fb1747ba26677d2ab6f8bd23f7be67324884f4be0b1186ea718390301ce49f9c43bb5446ddf08c1791ea9e928de9c683731bdbe1c10f2e26290574b0fd7507a4de91d8092f82651fe917ef3ec5077bd0c2d3df57a1f77e5237ebd3aafe502eca34aa3f1423f38cd06101c58cc9769c9e2380a2198912890bff6c6ba84f6f38b08746965388ca9142eb27e971457536673f3de6056386d6dd9d47da3d3e7833d16fb7d41aa3a01622afc1601eb5e1876d77235394288e5e0357572144091310cdf8a0dad4831b1bc321fc6e6bd0ee54d2c5ea7e63e7418da2a50ba26ba204e120d8f36f1337d241ffd82b49b6f7524b80d9c81962b6b4ecffd4480d9c8ce9ac394473ee62a4bbb0d62748e1353d880288aa3cf46f0e1de179ee9d1929e67ca1a835a8a379502d400213d45d3351afdd35deced50f7e1ca68139a6deb963b0ff967a2cee66ccb2b288296fafccd200a1b8c80ece1bb5588fd97970d8280fe818c31ec457828e86792aa57f9da44b8eed2a2df449bdcdea10823ca8722d23add2bf7785a04d91bed151d31f8502ad890e5469dfad0fda2ba0b598cf4b9796a2118dab9d4131870092e1ddd7f0c9d9f313ac280e799af482d5590d130da0f8753591bcaffed32fb763c3f87c1c3695246c0f306bd14f9f91841d84b0bf0b6f1dbe6f560790299d0d43f565e2cfc52e25ceda4954198f393179b307cee5e3133a082ed03910c109b1175f0010156a16638e066342d63a1120ece6494a7295812234937a2993760ad65b7e5ac19d5390a0d0c8b77de014ab972a785094cfeedb44c983e085d78881d3db0dcd7cd9eb0e995b5d9f989bc3328a5b43b41bd5a9ceed5aa4d55e3c1743ef506652f0dd16fb7fe9acabfdc36797595ac929f1f43948dfceba06891a9e953d9775a5180dcc2cbfd6963642fb856d2c67c1b77ed9fecb251e2d91b5bcdb5f3948dc9fa68d6877a9b4b90e05eccbb145e6ca07b49aff9e779b886cb9a2c61d71ff3512774910b78db2f64fb97e247d4128bb3a9b453eaba84fb84269a91b258fa89f4b3f3b031bfde30c841726e5aee40da6b9dd71aec624b74c8f0dde6f19fe5ce261c4258a169a11f3f3ad76975dcaf288361e0290cfa4c8ce5f83d37f590d4d11e1bd83237d727b972319573807e063b70cf0107854ff548a89b6e8f21a4694f7afb813979b7a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
