<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1bfd3297e2de2bfc69319c03e936495b98e0110f02fb3ca9824c1e6e78f452a4de4e8cc9db9e14906c0387b1bd7eacecc229a3f4f997598012a78e31b8a2627e9efaf3ab40c446e572c566c6368e1ebba297631411f970cf1679cbb8def65a470615fb8cfff55d4140565e5c72b0ab13b8b963492445e3b77e2ce8829a46df0fd98d644e618328a7540b35bb023af42d2a7fd1b3f4880f211583da6648a7d3b17d38d8e4a94efa48d30f0db9a18e112173ab429c8891b4b5a0ddee663785674354ffab7e860ddc979f759f4aa40e6affaa7f17a3e6e4d6b14b89a461c90e62ae946ea267ce1414ce5a37676122ac69ddde9ea7dcf1f3b434ac1eb4a7b9d89b2c7dabdcc54a1d23dcd4c2875714de77dabc3372350156f5a27a929f53137986916635ecb1e75ca1a8aa4379a66c53017acb978aa364fbb5ec23b30b6e788acdabf47c8d35c930ed2b970807f16272de02bc464306631772b263ed089d6d9fce316bc3fb38e7e38b0817f6cc9854a40aabb8260b321c66ac3c2347744deb3cb393f384d320306e486a8bf72260ae4e73c3ae0099f6d3336a1db6a46552c18e86d9bac35b061a5a2f2548cb2ec58142be9a6f30e9516429fd021f127748e4a7d8d683e2158f8186a653eec7767fec2ed278a11b3d0fb65521871b0df1a14a135e48be3b9b5dcc5c10541413968af56ef4cc91d3ed87bde943143c9339c82b5bc4130e0984972b1f9fb6f1f6e2ac8af5bb47eacb6bb2a9e422c2c4643be89e1148377c86436803cb2760e43823dba5323f381736f9ec59ea62df46f3566497464a86a0411facb9438dfb5399b2269196b3eba45db38ad178afd38aeae6892294c90b86f2fb507c600a7342e305c28803d0d622f0682f2e47d074b3e81a146311b49fc838f9b3018097fb1ae4319dff6fa8996985e8dd692d4885408c9082de791b888fac74aa5490eb40563c3c02029099a937b032ba7845d7d8df5dd7e9fda1d88dbfc319d22c8d61ec95b1f8eb1b48d57e286396cedf6f07e7cacb1bdcd7a3e7f2f73fbb5e4aab3352577c9e265d42c0b643ebe8b9c512277f57ad033db70e17fce2457f1c4ca3938d371e9f3fcb1f9d14233ede90dc368856520d4b5cee93364ceeba6a73f6359737653894b0008bef1a2cac82f9697f8332a48324c896e9e0eefedf2752fb5e49aa7abb7e33a19b97ce691e4c4fb9d778c44fcabbb5c4eeb5791a51aa4abc93a7161bfe4cfe0215b8efe2ded29aaf12eda36576d754df3dfab9b3d1e14ce251c721e9ae921e7547512ab177f8501b6a6f4bae2dce928e77c03e6f2f72dda61b793975e8a168339df72ffc9d7262496627d22a86a6576ecc8109e2049670d7e995c51304b6d7f3287629a8418ed51288aca0c0732bfcf83e9505c2b8d1a412fb0a047d00853560dc79043271032736db904a4cdf8a109ae8515f52906709d882fcc566dafa6cd696a975dd65486fe49f8be66b93b08e957c14e22b0b50a15479dc540821cba444b56fe5ca0a3e577c6d461062618bc4fc83587e7f27e6875d449d717474c5e79cc2d357f1b0dfe370f3da240bdd2498def196029897af49e4a29f8627f6b6227fdaa4f16d28eb3ad3941e1d82cde04c3456c2df5e411298b4ac23ed42f108a9a1b65e8dc3e1a91896ccdac469f51f9464626ef94cf50dfb37005cc629f21c613773ca0e3863873b7cdf8e7ea1285cdf7241bd1ad2dd7b04e0283bc32b40da168628395409cf1c6dfa44c7ea6c14d9f35c55766ce458025e1dd74696f26609de558906216ebf48c64eead2bda86212a08dcacd9c8562a496613b0d4a5f29550f3741ef1a62682c969b1444c3d87ecea0cabe3f6b45e8e387639a9f017b67c253cd41af42ad888e35f5f3489aabdb20cf26d10b00ee3290e8e21dd8d309629bc4e9364dcfa592be569143aff6e8d97408980662e632c3b6f44d77b2c563e59313ad3ed8769f3bb64a87967ff7761b122510c71e32e4cffac8b31f7d1deef6b881f5d60ac38142ec2972197e0bf66eea79b37cf2bef929c2554f08dc876d8e09e850d849ff4837f1e3cb81db494b5dc526fe980bba05ab4f3c7c63edb5144df73dcfc53d57e641791450d06e35bef57bfa34b388373cd983cdcc7315826cfd80ded5c074ae7289063b99e1d23638911d6bdcd0b4cfbf4b2c8edd6cfbbd7d421a7b193b3cae368228fd5375405ba2e4d6097193f7f46db0d4146dff57b0b783a3cf8a4d1f8405b1c2ee27b3b95fd26becf26c2c0875b74d4419d1b380e996a8d1a5449f24cde4e5cb154cd3ea23e513c54db7259c95a5fa27a3e20c4f4637752775878ec340ac936d0665524135c4f760bbf3c4913f1a4dcb7f85fe3b78268efb7a5e67b75ebba8562fab9078a484a64271e0459244b1f004b553e9c58c512af2bfd23752e4d36842118cf205b86698e419cac7378dc800db7369623185214172d1a7e0a4aa4e3f66de540ea7f998ce93257b7fd22e546ac82fc29b37a38773c96dc2f125641eb4da68a6abd93ba4458f2a11f9dd6e132dc6742fa3751855df4a19334c6e738c9a7cd512941e67a05a407e2b51d3521b07fcf1dd9734f719250ad5ae9e11245a3c0dc02f4fcd16a71ea31c3c1b3d8b733cb4f8a06675b14a723551398a0f979a4a9211ed2f4cb6d32bcbda642a31c20971324c05d2903e39454f53c07c134ab45381658fc39d1a40dce8ab6a60192d52b1fe04a0dbe950a3075bd2e38fbed6b5e3927336551fb1ce8262d13db7ab4ef2b0c7ccab2214b09d1e58361a170233119be005ef18ee7cc05dd7e9e7cc933c1fbe450a8191c077ed7e4583766ecf44f232ae47e6398e0b2b9e122f43f449a10cd3d8ba9f420e0f059fde9df191854e81a9210763c59eb4c1396d5a460404732613a6c8539feb35c59d5f04ca3a70a8818e3afc4e7ba42c184040f1e75176b0d86802ff2dbf84952e52599e6f38602f953d20fbb497723acd1c04d1dc585926c203a1c6999b7f18588c872f537982ed23e55005bb0c51e3dc0579ed4bf5363efd0650758d03b74365524e773f3aba3cf86c398986e7b38d3b73b2a6c663a0f2315f3409f8f15d7d7537799a3c6bee9e3bca2b67ce1fde1ff7091625221f2d8baebb02b1ad218ff6662ca6569e026955128cadc355469b4837543ea28f00e9646e4fa5367cf2614a211042bce11d7dfbefecf14d44fb16c72e3f9ef6090e6d561dd538711a6017e39c2a187b6d6172224d8ef45a1d74a6cc1667172119e7449ee887ac24f8316cd625d64f7c9d5d7881197824d5bbbaa28b065122d3d74999fda35a6eae0fb0f15da5495d90729697cf00362da119599efe56f75a430f9351b17dbe53274ac0879ee58ba1fe6858efd2e9ee0eb13500c777c84a7e9fbbaf2a59bf0a15700dc9445cae75b93a608e5f324c82acb9439ec2d043e39ab323a3ddc5e9115b42faa05d301122f17527e98abd09aec1c168a14ba54dcac8f9214ff090d1234579e3eb1d5b13a36efa604f89b3f5bf0b029d73bc685e98613896794698438f896b0ad2ac382788a953720f8fddd5ea042e30a08d140421e0b57dee96a0ac80addda648b169d1dc18a34d5993c851f68c390f3482b0da73b0e10493b03cb56e3f246b45f4e7096bbbb196070cf53d281df673959109ded4378d142fc52eadb5edc36d94104599e621dd58597f113c6262e44b04b7a37aeb62166d978283e9a499bd100297d3215b6e8266c3e9787b2bdd47573a056aff5dd01eb1f36f33cd13afffdd0a39ae7243ea177de2b72a14a307351839639490b6b3030a10676e370eebf80a31ea433af285daf34479e64951c80838606f4331ac99d20dca8a88c235c8369834ff7a2571541f0c8bbb597fd4d93d0f4e818098a1f052f2ca1d33d521e77dd50188ede11688de34597e350b978c6aadc61d2363f99ad72a1679aace91c1de8068f7c944674acc11303403ddaac47f5d2e6f5a5aa3f5ee43917dc899e0fbf8cd800c2df51b45150fc8f31143e4257e72d5389ef60907eba2ec6447421ed7ff5afbe883a46d0066c254c164bb8f94bff97e199f8dd08a220905d88ba44420ddfee6c8c32a96a6f7765a6e55acd92346083cf06f7186bf9b449670554c10b96f655afdaba5cc4e47c82a9fd4f4f065172047df04bb02ff5c8954a92300b3f61f770d993154f736bce3f83d6b4d6e3599d144813bdcad90b247479107f6bfccd95e9c77c041275fb372e7f6ae8a82895de71557a9864a3716f36726c7799fbb498323f57c490d2e3a9f1fd0e105e6869911f7fc669a20db9e965731d89466d3d4ba3ec1299d8b2390ec8d6875dec7c9f9833750040a66c7d48397782aa716e6b58fd13be187a7c6ff3b0ba3bfda2f7724de32d36d3f02e26912e6b1bf27e3e11e935c04188f96686d726bc8f8ba5a860fd13ad4687fd499c503b15f94b086c37a9e81cda999f250f17159b1739904b76df60e8c9629015877694fbb9d2542abccc41fce35bc642dda12680465f27c2c60c65d2107cd5c43114585abdfcf9fd070d371517cc65d0eda6ef96657b8f7cf36938438232fa85cfab8825d1a5c2f962936b21b517327158faf27dd487331caaaf262f2d21db6f6434e223c12cc66298ce2410614b8114bf2762262c95717fb57ca626dbda072ec82d6bdae814d0213c100c1e7dd30e7ad1f841c5a0f6eb5c1d488afddc3e219d1e937111555ddec31245bcbbfa3408f0454c57a128349e9eef146e73ca43a2ccc17a9f47691ffcbbb13f7994165bbe9659c0578e88a95127416c6993d949a669461c6159396a98237d2ecae03a85d49a606089447486caadd5ea607506f0421148086da7790c66210cd2303c8d71a57a095e1369eb5818f8d08971666ada44a2cf301421af7f26996593f47f629cb01501fc30430c90109de0a9b65e65fb1c0a97ee8865aaa0fb1f1c33a39cc6ffe277cdff9834ba827f3165071a0ef852bc4e533fca15b8300248fadf394d73a37c20b9e9fa1342d6b8aad046b13dc08995e4d60d2255a5541f005a3423ba0cf3b2dae90879a6d37fcc9c2db29711aec5db9c183d04e6cfd718593af42394bc6d7c5c45a38c18ef901d54fcce832f0a393588d136404e79f7040c0743e3ed3e6ffd26321ee62054290c5dbfd9887c1915304386c8eaaba05cf159217441397b1eb8ea390785bfcd0d1f9d55ee804902180c2ec798972f16003c0e871b6923c11a14e38d908568899f279a2288b34c9187d7b88edf7e4276479c3636034030efc17308c869b95d544646917a96056252e29a54e96f8a9cc494da77428c0ae583ba7dda14a8ca89fe376955bb8a269c3830c9752b5af3f71a2b032f765c4aed7f6b18721db815e46452c683b96894f9c95f922a2f406b6a2bb33e95b42c9af76eec2f13b6bd44d705ac7f895d7d28ae1942ab94d5c24b435fcbd8fdeb33ecfb6dc7fd26d3fd7256c82d439380e3cefc4ae6d83b82685edb9cbd7dfc5963efba2c6dfe5c84052ffc31aa25d8e8d9f4ccb67efe618fe18b6cac2239bf9ff06801eebf8cc9f8b4f00ef8fb284a49bfe0a4c4fb3a43b182bf71497f248b2ea52fda76696a1909e8c544dc0dace6cd41aceffdae4beee365cca90a3551b6819bc15b11139a8738e67864e4933c1e57465fa0756ea42c85874112d8c376b9e93b3c571ca09dc29b3bf3ad938a597d87b8712e80024fdd24d7dcbafd826bbe71cdfa96f1b7fa1008e3461f9d222199f6b56fcfd101d4fd055e2d487042758ae92fb29adae0ad8aed2d1ccbcb2daa551fccc4c0402caadcbdf5cf8c75b716bd533fdd40a1d8e6bee8ddbbe88f51338ff9725613841e74e47df6b332f755a05cc323a14dab3ab3f5b3242ea1b99cb204a7d0a21a250dcc0ecf82bfceed23901d87530c292461cbe248b6b83c266f7a6bc56cd919c6ea07be2597d60ea4c0899a882f9f73a52eca1e1512a53756fb6c235ef3dd0193b71ef40fe688921d2e60411072aadd147015a3f25e4d391d40aab9a99e04d5cf15ff6d66a8cdb7fc9daa0f2ee79976b79512c34d3429873f6a2c96998bb42c8d66e62ad0eba0d87b936990d929bf4442970736088d4ffeef4336aa9614ae661c1beeaf8578ab12b56e4df33305813c3b67e26e1b851b1d9d192b7642ad0d427e49026e3a78bde7ea0b51bcb560d9d46501b135735a3977d7effb5a0653c0d54bc26fd54867007acb255838cbd2591560263f7bcfd42e4f9483c43854390f19e7377a7913e7322164ccb35ae0aa1b3fe7d6f5d468d3e1f85d9b60f8dcd67e29197eb6c08ecf55487f80d1711124e3bedfc23a846d968ee4492fabf134779cc31eca3acaf881c71df5e56c73cd61da48330d8dc995735d378d725436c53738fdf0de06de14f9b59ce9e74b8f1578553067acebd82181e1a1e91da00dc2bf8ebb66d6a1b433282ceb3e312717639bff08c00107135a5d8be3b0529d30ab7832e668fbb9063dee55189d5642bdff9e7165dcd311e65e4d581108bcdf2b5fb05f3242d34318b379f8fe5beddce20078b8e346dd5152e844167a299f25e73ab82c8589e8c92df80819501c0f4fb916404dbbe670df03475751e84f821afdb56863d50284b2b5cceece605c33cd1c04a74f50a3f8eb4b7122b703839b816e62fa6a4ad0a882216e4a760c549b2f2137fea359218e7ebda8693ed345f06cc1180d70addc671fcbfd18cdcb12c16aaf9cdb64894105201e500daaaf7bbc5f32a753c1ef1c098c5f05f4ea2f1fc0bce65eed8f33c6ca7b03aa02a82a421c9e7a297a427b756817a1a25a1f32b1678d9869f59397e34d497967f44310f68a02facd7600d8d20211a942270ecdb26a06e995cf0822e10d7dc895d536661f5e912e9cd8ddbbaf47c823d1d3239f0cf42b51ce65a82b7a60c5a5c8d67f04bca6532f2fb0c298d80dd88ff01149dc27bc32098004ef7323b0225e1c6ef26c66de335438bda2b3fc2d01ce7f861d44b3b8e630d8814f44858bade492cdfb748d62794ebb8132c0af6a29fc23b811fc224fedfc39fb7808624e8f6cd021a3f0aabb5fc99127bf045f6a696ecf51d6cecc9cd93afaf5d80ff803897b0b8089ad693ed272df6a345b07e7b8ac72ab83d8f5f4dc57c3400559bdb9f00a72cce15ffa2ef7748b1faea714a617e794d9adc22f7fc9358ee8702469c582a78467cbd8559e6405e2ba3219300e4563c920ad954cdf0816c07c6c3db9b228725b8637923b2bde1c89d681f51ace420cecb1d56581720716480c83bd07070aad4cc3f79552105fe0d0215c650bd970b04aa70bfafe02a28a011baef27c6b6e894bb718ea0e841eaeec191e17eba9a1e5c5cef85dd950782d06b34d12d7a487dee053e39b96df51808f6cdf103faa037b7c4dc16adabb88ec80de781ff24ab2581a15f72d66bd42789740c86f31758698d9fe25b05f1a8d028c8f298dabe6191f274a9f36a875b331ca3f7d5d2bb2a4d284da660fde3c7e5cf8af0a2df86a38ae37d5a671c353b51c5a2915f34af918c7931ce0737a5033889389ccd2f844be712a69368a991327dc6e21342710ff1ec8634c4a03462919c14c8e37b26e9bd539653024cf9f7ca10216fabebfce043e937bb0405c7f52636cec91ad762a5f534b18c144ad497a63e24a5eccf57ac1862da16ac8baa00cf8a8979b59ba010a54a4818fc6ce22903b6547dbdb8f276ff5364064ea3bbb2f9cd467d455dc99077d7853ef030f352ed74ffccfaca686430628acd096415d6000a0ba7807105041f681e8e18b54a881d1b70aab3de1703fac185c94e510bd408f0a86a0128ac1429f7c485175c427159c98207cb24ddff3b0467c956a69e10be49248c78a99e7b61da0933d4823e56d4056d973362ea73e929119eabc44958aab0b49da04719ea8c63251ee2855c91386918669ca5d5343d8038a9cf3feda633fc2baa33d816dbd154b7922f1ecd56f672512d2648c1e0b079c806f7cd371c09f390dffeebc079a833db33ba884b7d37ddb4f781e1302005483cc97d79c1febca2e846358aceb1508235e217186108fa27144970fc02d8caee2f040b5db61823cf1b2e563c789eb169e3acb3a027abd41741a1c3dfbd9b2120a702e36231a3d98eec3a8687cd19330786279dd119b72eec2285dc170cc65776b2de997f3c2f2455c184c25dfc8ed9e8012f19e8cc3bb136ab76b3385aa86f6cab4a0f1577ef400eed7ae658b1e3cd2f6f571794cc3e93e227fc6a3b1eeaadd51586fa6aaeb76495d857747356f414686f888c44b8de64e0b51e7fb63d927e694cfcf20ca4e1767f9565af7d7ec8f14149d9301bab4da43f3ee36413954981590739ddffce7fbe7067ad639ca80ce9e70b65e534d5cf107a731aa64156db801b6639afae421deee5b6bc2816307973c18fd537c474bec9dfee28f6bbf4bd652387756e8e0aa68a0b0cb1ace949c28e15e86176271f5c5717fe76c90c780e7abb456c97f16764d3a1f54d3c4fa493875b148c8dbb856d13a8a0229661e0f05735383ea2586dc23ba0f7d6134e24f26c70adb52497fb77aad5a634f3ebf475ded9c8aa915dc0271015763c2c2542378bc843139866933858c977dcf73d984b45b0039e10cb99b3063e06cc2cf24c2559a5d36df6bd29f3c7254525915f1b9e67751ff8463c179c5974fed814a4bd775af9150a7a49dd5a0c6df7670ed7ccfabacda8fb5fbfed1d068ce6fbd93cc0ce639ec90144e4f90b29fe359a7f97f21b65951e66291c4c8828a4f6028fe7452a43b2c581888c3593b86d1b8d980530f61efe81927d729eae0997b74cc6c1558836e422be8d0d71045052bb7ad018b0fcafc5597359f08fd50c00d681ff3a231621388a3f45530677e6209668909e7de7b2344278e39340f0f395171e3b6149517b5b0d9a2654569263a4aeebefdc7638ec990afe797cbb68fb5f61aeede5e802d348b744cf17e8f581886ff8fd9fbb364478fadf1042c1730fc04f83cb0b5776423231d3fa1b7f37de3ec3ebc5a2350e133c1036c7a7affbd5a3aa04b9f20e355e44ac99783fc429c210836e0159cc28155c394bc0304196612b45de465f7841c62a480bb913202b47a9b01e964af3e56b3c8304f64999c386a6df9752028b17e85d2c690d3e810c77d50125b67086d18ebe70481219b9155906cfe650f9fd797492d0c7703cef24acc10e9a9e7b7f3c57c98c8b4fa5789950fb9df019253d8b3c9ad7be04046735da82bfd19fec32eba6990ebd791c631dd535e9f4be304bddeabad237da2b28b86aabd605be04a289ca5fdee06c60db265bcfd2f75816913c80ebc0cd683b12feb3a1e7455c72aca44a325b39b27e49c02d859a1e6b5b69cb5a9f8a7d3d92d55527d9c7f6b5e810c0e3cded14b5d65165d534e3889e2e0fe11b05798f127e57a2e1b9b53381e1c6debb0d30ef2878f8afb875c764b27027c02ed9e614a821cae2a659e8ea06252fc78fb7104fd7645b3358487cba1d08b51b1f17a60fc07a64d9be684a49de572d4c1522a626e9c2379d5d21f7b023c5adf4c4a1d89e907e00f017daf8d4cfaf8d8b9056a6bb7ce7cf3ee242ce0075c76089f4d2f6c3cc6b70daf93990fff704376595d3c4428440f597d57f0f7ff05aa92ad6a3e142310ddae2ff8e2645f7160168e248700aa74c468f3a064cb9a212a373ac9266a020297fbaf9eb70f3298618d3b559ac488e683c0e4562b441ec9de0dd4afab0738d19ea68ef3d718d16706164a851c1cfb9d2009127ec753618eeb686b32abf4ea8090e0024f2c8bc71ade2f5825a87aa62bedc068e60fefc8f17288d33b1deccc0f07124843e8140ada358a0600612e0d0bfb866868c29b3f0377a3d29c9de8823728a2eb84dde1c80687e9e30b22ebbc58be236cf31838f1b7c59e737466d30088aa2fb0d9f42e486cee24b12fcdb203db0278ca3bb7f6c3be210b627db7a834d8682eca73e250e0309b0ae312d87c048b7442340e4f9ae527c815b7fbbbaf3fcf567c32b477c3312a5f7f71a38b9fa2b7ba84ac249932695c67337c76a223bef90c0bb18a9eb75236b0f834d2f07a224df1af2a3d587cde87b6e6dd15fbe4fbbe67aa55af3707501b5f0e231a8a7f0785b78f6ac837a4c75786154e7f07b3176cf49ecf9dc55c8e9fe588dec8577db19f9f592fb3cee3d43c64c234b567dd454d6247ca636f572f374dd104db25528c4e99f313f914e3fc5288306646b3207d30ec011df2be819d27993d7e8921c93f0be706bb68da33b0d1b42e11704c8cc82e7a57a2325ff72a99d7487527923dbfb001e2f7d7e928a91d9844909472127ada1ebf6559d820f0c1f0374ec7bf671d094358bf2c809baee04b4ca68ca02821a0bda77ce480721f0bd7fb1362d8b3d1a21ba7233533d9ba871c1984c5a47abd2cb238c987ea1aad384caf6ce8a3ce6186cf8debe21a3e8520764a2c8b8c346d44c416c22dd5b6e1b14046b202820a30b005b69ddb2972db86a36e70d92c179830730d0d3d187fa7d309a1c2be897ec26b4bbe543cf4958244e0b6572c74984e0b54c41cabfa14d1841ab7cd71b985eb2b32a5f980399888f141e1ee0f0750b8a1e554a22ceb189c650c5ec2f15d27b9779a8bdc9fa9b173e931a2e091a487847536e145e19b8ef5ad64ea31ef25c8729886dcd3177cd492cf7e00557e1536c8e0376fc9291bf06a6550b456058b3b12af4f858fd1d12767e2bcb93d6f4d59056b48624c1440670a367ba716fddc8578e470133df83e53ea8fbb8956f526dd84bd388afa606f959505a2f0c61a91f18fdfc5da6a8a433a34e0eef1b4ad46adb062c9a2b0b73062f9a96196faf94685ac96e86c6a1d6a37d5f07607dd8d118a12d5c739caefc58c578bf287fc010ec0dedfdf3c26e8f4a2ce5860d0cf8dbd07b850f66db89120c183b58a934be3a06c5c772ba4036d7188fb2e50f091bcd2c3b123891934d5b4a7344988d96f3e83660bcce801335f7fc9ba192d5c999f2784e5ca5b6a8c6bf0021c93ec71844c58a5377a333c258febd04f39cc665af0644a0e8e0864cbcd33736606269eb4d5c160f14be790ada492456482184f05a2170f090bd6b8898d46d30ec7ac8d0cc3dac11cbb17df9cea04e48f765a2e1f42e69b8c18db012fa21c7426b4aead04018588cd57eef032538c599eb852b91a2ea49345edb22f23735c47781c9e98f948b471d47ff1fee0574b0c6bcf255819db1c0d5ade5dc5dd0a5e1eac43f64180c8ac1aa0127559ff219398a70b07b7ce2279ed2d44d0101c4749e46ee2c67d8df00b10faf2e2e6d6f14af11ff4354d87a862bdcd09d3b07eb25c0bb572a5e2e4894ada507931ba868f8b4c047d50b082af010d6c6e54a77bee35f24c2f12563e7992991cc587e1f598b8b39daf74b6e53391eb403a45d010a75156292e3bf6dacbb9483f5abd2dadcc16086ac4e029d88763da99ef140d5e1f256d9aeba4fcc4486195872bcd15bd741cac510ac5030d57eb7d70e40081e72bf3355a98758073584ef66b7f12136fae9757947e18dfb9eaecf08f03794ed132570d4d1d7987f36cbbd88930ece477743db6431a319bc66b5c6df7a23a1f889a3769537a3154690f9848216738b9c1083f785a7f993f2967bf5a5dd4869b3bb097ea5692ce611914085c80b571d0fdec328d4fa2057f2b8988b5fc695c3607c14ce01070b4cde73a8a1741711e1ecd44c0a4466f114c082d95ba150811033659249518eecb57615f668c55378857c2b316f248554f9e1cbe9a7d39aec87fd559c0186872634ea53605a65915eac88bbfb5377d56420c6f213cccbb3f1f3f72cdd5fbcd132f09b282627fd4245e20e1f72209333dd03cfdb5c0b380ac8ebc57c9c13efbcdf32f724839b2a150e1d44f3bfc930b34e74cef35d8bcac9b24137bfdd5cbdc50b5bec6f29846fb381834650cbb7503ccd2d15a5bb5bc845f2fe34207afee8046a9cb0ea0b18ccc9fee2d15ad0def65274757a8b2b3c8f93543fd7a6c3e573363470a843178eeb59693a7c69c1f71c5c0f810f533e8dd214f38fcd405629aed275dcd3db2bb786cadca14b8e6e379a339ccf4c3155f8ea9f1b333b9e95b083007904adae39625e90f702d9ff8374fc4424cf509a741e62aa8b95f080776eb7bec209cdcb61984de30c246e47bbe03006cb5bb6c8c17a1802b7ed0f2ea5bbe9df60874f404b42508bdd8b6a7605994a98c29a2748caa193c37148083b14ce7da8211ad2a8dda8657256e9d9c4e4c4e87bde8311f310081a3efdfa1f19dd418d65c5aa1396f575a647c6bf3b62f4bb7a18595662fe2d9a8679491baa6f2c0d8c18d588075af5a98320722858eab3bc3a867d69c5a0248426d43cacb3b856d13eaa4bcf5abc6aac1702db682d65370aeb9de2f62d04d832e964751fc28ffba0cff078750c3ada22a557985240d66702b65d483fad6bee7e485dd95bd73584d4a3b72e2ccd0d0e2ed0623fea2d4968ccc14728009848a1f474ebf75273bd7d5c4e456a86d25fa4f048842123ce1abb41878d14207e79d409759b788a47945b86e85c273fbe1e1a2a64a5ac3598840ec7385272473c70488489519d17a283c6f4fed470692ebd8d8c8262e7158d3f6fd5835efe970d9303c9ffe50b0f44bd4bbb56bf5bfcbd6d7bcddec176cf304b94534de40ccbd113394aa8ca948d7fcba877bc7b93820e9c3357d154c6fe4eedcb2eeaf071518eabe55b886b88fa857346ba790b1ddfd1b3576aa401fcb0d0a5ce70e54f95774ee950872aa3c4bb7e4946f5ab7f4c60ec204de5e5bb42400fcde214b0806a7949aca40eed98e3749ee64b5e0a62c60adb5f0e5e7236c8c85b3e385b09167247ab2d8c8f517d6ac578edd374ba03152656f0cd405d0088afc403d96293c3bc867d9b7310fc426f9f8275de658a5dd460db61d3e8abd5ab4ee50995af4ba9f92f5de1102d85a5f9af8dfd7c203932993565734ec58bf7a96c626891f02a7e661647f7ae6d2be4f4c2c80c5ab37281391a07487e87ce0ff5dba17dbc64e683214991d913ab0a15e83c0ac15a68fcfc725ee3dd85d0c288535c04dec2ba8f68c167ed9747cd39362864056d1fd818cd0037f3ad35a5bf2ee4d854421e026b6deef27b1d03ced7d85f4474bbc719cc97583d1ae87bd5b2c28142dec9427f0c09afb094e2b5e57e4e5e15e7278e84476ccac0691f0e1f02ae7b6e1d00d5ac0f05198230a9d3a27a5c1502b3f566e07969f1d2cc8ec95ac4fdf7347b94edaa439fac8329b92d0c80b20ee06090283c0d0967258b6b13eb1c274b47edf9c89ad5f58bfd0d0d42b296381c9718990f4a0ef036bc822bbf17c681b3181a4a88a0b44dcac74685df5dca5e9c282c685521aed9119feff29b3ce3d096e1a6daa6fe30373bff5b590c36f37db8dc5efb52f41fc3e1f8776f05aedd21d40a6732fc97cbcfacfd9bdfa659c39833c6ed80d31c9e04124d324fc98199b619a6657ee8b560c01aa8a5f69dad50f7b607f8d1dd6fe64b9b3feed373cabd53607fe9689b75da33386cbf444373a17b6a3cf610fc0e2e4900968db638946a7f3b935c223b233c21d21ff79294e225f8769a32e47d5bad24d714fa4232e95fefb458c7e9274c621ba547692b6120738e38638e8591130fdb10fc7c0321cf2e0fa94543ae66e90d2d88fbdd592a2f4b9e23ab8a52de095c8873823a8a55ce3226ef2e5e40563a6669394a0cf6684441bb390d86c8b835a9dd82d3f86f8ccd033a3be917db3e98558010bcc5a3fc686f937c30f8bd3fcf412efed12cfad110a66391ddc11d3c0a51d3ac65660f5dc56a9db4e76bfda998f3f3dc7e8d71b1a08c2cead832b7200969c9a956727306f4b66da860135340c562477ad80b9dda19206cdeec2a3b97b1d564aff96b7b35dc91b59f84a474b4fbeee90c358496db1710584dc9d0f290dbd0638299b80228f98d4b35420e99e6d19f7b39d2f9979e7d1a3adc0449e90411cacd92d9a6b4ab72fdcad7dd06626f8c8441c8090fac8512ab240cef1e84476c90a12f093a60dd9df6c1dcfbf0db23a608fa7f458d90a5b83b6bf061dfb242f0a457d8861ba7eb5274fbbd1ddb41ca48fe148f2687ed57c852db38670546a39c4b9b009bd134f569faa50ef72e7130c63fa481f2d89f4119608becc74d62eb07b440c496d6471a6fed3624220f2a329887dec5ab888fb0b9ffb873c4c2439fb46cfa58c9ebc23753e45eab37a3efea9bdb40717a83e26a4ecef73ba3d7adc74dde60d2e28c294bc3b10db8120c089c30ceb4c0e150177b61214765b2a20d7a906084e84bc43addfcd546686fbcb630ff7721429ade7830213ded7d6f3eb7e2f6f8816a7aa5622cba0aafb0e96f85023ec9cb784735af3cbed72a6ec5dc544444b8b271dcbe9ccdf4aa591ab4b3724902f310e815a8806a5621537f419fe84a01a16fe669b9bb5ef569280215cc939a5080b87ba9ae7c21f67074630057e56cec70262caab956dee100de2f1cd503b44ca90b8990c51ba7ccd2f1ec5960adaf7240aa5194569a406d31c02af3b26c39901f5eeca56d657ee2b8acbcb94274f9db30aee19a0794d5a53a4606a7634fe262809e1af5c8d98aa20f54fb1f4890c6f54f17ceb3842a72ccc17c225ac356751011353a6f4ab84ecc093c249c670a5642a1f967525eaac76d214ae11162b4f129fa9aec272978c4abd941782421c555e3b69bace56db3247c46e82c60fb523329c55ec5dea1aebf4dd087f6b3693f4475b5eaa8e2e754997e7d72064d1e6bb385a3d1d991c323ec69d896a6d1a7fa6bd113b5e6ba918994b5c59652beaee28b021cdc2508cd412ca8563d89d41428e22915609208da84e33d81f14fa4d2b7319179b77f93602c2c00627ad47221de30264c8339d3532cbdd2a7b7c746911b22774174b052565da36b834e006488bdecb5914f6de766b1a78759f4dc7a8492b297e8fc04205659dddfe960a6c9f7ccf7b981f24ffd45f2e30a27be27ecce67f191278ab5aa276e606bb850fe4f0c77aacc2fc3038e61ae36485692b1c80c44a8bc9704a1353c57e606e2ceaf3e87052221a4b689ca4518a0a1041c4c1450714a1656138671617e8fdadb6e6207356dfd1013a460967b386bd57f8d949dc84befaa0073d4b5f1ba19aa7a6bc11b2bcd308ecc5b002f5c0a80b64f8e82e33ebcedcefd5de23ed41739e1e8cd25e5f067cb6f95d310815dbfc39a0e13caf453b350276c6e1b3c1893b85b40dc9352b2e4b9eec9ac22fdf7bce9c0ce80c5826642e9b20b81229a84971f8a47bd1b78cff0af4b3622df42827a6bf77716b2137cdbe3702225210bfc85a1129815c9ebd516833750f89dee65ed3f29ff5156d6578744bed7e712a6ca446cadafdcd3d68e3b16f5a21485861ccdb142ebf6ffc06a2b6eff44f22e41d86d42312b7305a3b2ee95b14430620b0aa343c62270732280ebe4551eca501c24ab2c744939a94bc686b50401fb6d0990f733a8d0e31ec54809a81ff7c347f92ebc95557ea394d69d309c0838925c69692d5b30200250df8291997aede89dc8c05795f64b169adf2a17bde488cea3c2c2cc8444ea70b3e14b198ecf8e3f13d74108c99be4a40143613592bfd100a7aac2193025bb760227da930c8c862f210aed3e84c6faa59e79984e257135b597ed541b62f0c365ed43f12029fab93a6b2e574688069cee8d595aecb7378431ef2ef2c27f9339373b6db75cdb3e4685fc3abdc354dd0542ad1a2d6d0e64e1db8d7a17ea016ebf16a6e2e4d6f6b9a82e01373991b82741724f83dbf607e250443b1ca978df1cdc09115df728705609ae101f254f9f5d63b1a0290f530c270d944e8bafb732539cb276179a5c7c4224c4cf0da9bcbd1b580c645aad569e9c165973431ca8a729663a2ca93383ca322597a4ca0b26c4a77c8c1b380fc7b1438c3cbf945fa628085d068025e05708939e8d124cec54714a5dac2ebeaa78b094de251503283ea2ec18242b8ee159425ea19001376f9e39933d4b7b5d21062b66159b87cfb7a33aebec6ed24467403c0c307e9bf5eac3ec0a9a0d6994d3db1dd36010cfa8c1223edb4a35f6e30b10a152605ca2cac5a3fd8123712c451a1a62a4abd791bc3d213ec3ef6a6d3d3106199b8b0473eed89c4f38a9aefa661c2b70e9fb9c2440127d872d6fb14db84037aa8d102aea244a773285a7e93468b74d63450e501d90370d47758ff0ba55c09d7022c1568568f89126780de3f47565253229e416b4bfa521322661b684798918e3a76d4158329dc509d429dc8ac09b43e3208d21bfb35d927ad9a5c9cb34ff6acd25004d5c9feaba51e365b6f264db9821f00084d0475e364c5396dd7d6a331552f308246a4eabfa9c38ec30f6e0f8d62a1a4ed5f354f755a2f73c590a5df23314ff0b9587ef611ba8e2e401c0359f1a5caab08dd2c659c0aa6dae0728d727f72af39633b6ce752abce9a1a700682657c480b61e2ef2b52b985ec510b3a0d51056625ec9809d05256e06aaa5914a6e61d3e9a3129f61a664563c701b8d5d95d837cce17f3314917861844bd32fe8b6fbb3ba71a4212a735a3fa4af4f1d48b0689f24a64d4f5a926462506a84b81c00ce2ec98572df8b577a8866d720d93e97387c0d9664da3ec43649fe681b4c1dbae54c04e1a7e43eae68a57783fc38bd3a8e375361d214bdbaf735059c84cb609c4b1f09b972328a34bab9d5213b28cd6373d22beb2bee97a6e188eba3041aa3b446c4152566ad5170a7de997fd9730f6a84f80ebe9760d6dd00f031e1b4337eec2f31632b10b357d61d11054c0d8259c3c13a515105031736dea7d28560009bc7ee4d0bff30cd9795d59df52bb40e3b59e688645a2861ec41923823ceb6a036e297bd133c33395e0124f0669fe8b927f832c298fa18b414cebfc136b7fdee00e36ffe20784bc053090a1a9c0b03097c8df4dfe172748da8f0ad63acbe80076b597b1aa4dec9ac377bbf36ad5c44efd44e6752b303bbedb755ce79dfe0f50a1e1f2e6c1151057a4e8699c0ece092fad2c425f604ff8065508b8c56afb8720eed93b7ed01da60bf28636c2bfea53f58cbbdb83162b410c4d5bccc808fb381d41f9cfa9831519c5be5dbea580e52f4f39bcf734af5aaca857ae49f7133e808e9f2fa133f3d69e215580d86177b0d5809ccf01b3ce49b8ce81a3725b1c03c8c5ca101eb27fa5c65df30aa74472cf19f016a6a53047a09df67701c5382d24073329a9f341981422c4f6e6075c830acd137cbcc24b341af1e5dcd14f60aed2e232bf32966aae91a24c6baa81f66badec5228d7dde0d64605a48d46587008837b298baa6a9aa4d2b02a2d52f8f974a3d825028881e12690453309d1046012b507c33688d3d634ff89832b61c6fb32bcfebc8f9e8dea5e58ba2bc985ac6ecc480ba7e0f7b94c85ee9f85ae15320705043e7fc0ed4ef1620204acd8c742915d5fddb6e0209096d4950eb595d651d897f9b2cf84d79464ef79a046cc5efaf21ce24fa6af8d5322d1b4600f4e75574fcaeb4f62f664055d636508eebd6e6e897a768cfdc393224dae280d4b85901127d50d32c75a774d5b0cab93b5fb9cf763a3aa463749cf282c0abe892558c0a9032e6c1d1fc354291d90dd9cabaaf8cad5d3d770426757572042eae0f64feff47ba8aa4a3bf028cc9d664de6bd91608d0d14bfbe280e0e8244940ab3cc9156f0e5ca1f0969f56dc1f9a2ecb52b52a343bedee7ed68a7480de69ece6628d943c1d4bfbbdefc6ee8c197c8c9f44d875af3dc9f0e82c04edf20d72929ed25eea4b587ee232a2340694a9767efc6bc96b2bd09a28188ca17cf58731232e1b73b8ea2aee6b7c4cbd48524ba8f90304cb3caf8b728b0ec7c0ceee0dd8ffebdb769e8effee1c1d3fecd1c3a78ec1bca54a442d2b8889141d387ad68a2b1d7f7599a16cdf0bd0a4e05ff28e3aef5b587fa9015c5d70cc3265274b1c3bfb1820f1dcf7594e3679deda2b7de7824ca043cfb7cbe249041c9701a8329b0b0f24b247c241e7f17f35b0b8efa3e29eaf7d8e40f8b6a75c97a830f76d8887","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
