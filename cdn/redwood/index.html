<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ef0dfaae0b12b7513d1ab710fe3031c9814ce909d1e287b6dea8377d4ca98f90cbeedec3a414800710efa87de490c492cac376f0997c127be076c4ac7f5c02d181e871626e99e7cbc6af1050d1f88e4402bf164a9636082176a513e28a79d45615a60c2514f90e077d0724b1406c1e29faa6ca321b022a5a958a23fc93a822ff1153472b19d6c009f661365868dc6328cd6a01f8f8b6382e3d7b3285a7c30ebcb7f42e234d00a474e37855752c5c3f6e41ffa4669bf821b9dbde3dea461c1bd757e1fc1c851c9dc78db08e44e63117d68fbdf68dec5dad4c73dd1ed2021e0fb26850dbda511a0ea040d245a749fef1eba9d51f8299eeff9fb76e77e488d59ea7d98b2fcd69651fb7022effc0aff9b2116e6cf7e603509167e0d85b47259164e83b6d211245be1f4250e8b1f04fe8da1bebccd27ac2e8650f6b7166350499fe9be622d9b5de7ce9998cec3c7b7ef46d0fbfb58361064b478a7647a88dacb1dc021d4259079ff7945228c04af407b659f176040eb2ba03b967e3091fbe23ba3f7f8ad28206d9724e649e12c810342b759b4babde9aa46552ff89dc0dfeb1faa2aae05e9f5c436dc606aabcacbf038b5d2fd91a7d2cca1e22e27cb189119de84394be1d22185358ef3fcbda27851dfb0618b0d11c1f848a13e5cff13f58123dbd290456daaa27aed7a169511b24b2185a73584da338bcbe720c80c3431a57db1d181e4139799dcbdd8a4ab23c9a931245121838c77b9ab29cb63cbe044ae757ad9276185f9374576c955dee0b87473ebeb66b84f08fd71ebd88094a54dfbb2318cf631b58525c89b933506f42a7e2cdfac4f3390ca77380ce1604abc2c3ede9c12af6337a1a2a412297f8cb230e0d21a6e8c770fb1ab37749045964dfaa781f8784d233bdb9201b3ec50ad2680e618f49afc3c8cd4c1bf6947be5e56a3ba037e4c6dfb21925f087b23e94b2824742ac5adc5dee7ff654f3f9f6794c1df50cf73907ceb148dcb7631618faab6e587a65579af394368f6602348c8a18e5f23560fe7d02fc181c38318fa0a1a9529b36f4106cc95e2016ef2420dca301c9c0e815f1188571fc319adccbe0b26c4c01533f907b7ea7d9adf6d8765b3e92b1c67cc44c4629833ea37398d9e9745ab775b209da661e2631e6d5a480167f64bdd60ee43b75cc65885ace4a85605eeb441f3e66ef636ab191626367ed95ffd059f8de80395e588ced7f165b29768594708e3eab628ce80ac427548c22c946d24563d9021c3d10ab11355c27cc40a29c7161c702cc966ef5bd13c90adb438a4331dec02dc0caf9838b2770fff1add429fe1f30b28b3f30b49d7c8bfa8f8ac796e7053544d255771d45438b83e81b90226d7cbfc7e20d242929a22de85a2a2dbdbcaa6a8678025cd485ebd44c483f42ab8799e991501de16ed0be06e6a1afa25150bfc6fad956272d0ad0ade27e9c9b0a62a3cf68c3fcadff758924e63c633557da616cf931e68bcd44bd33e9dda1e969dd61b42fbc39b9fd714531378fee5957a0b485f801bf1886f983dac94a285b4e57beb2638b27969759fbdb2457bab91b08da43a3d6fe473d4c6fbb689a424e0a03bf6fff7c00993ef7b0ab1694c6aaa2fb98aea7b23008f2964c67ed8a15ecdc8595fde390ae9ad4046441bebd15d9bbf8f76f902d5903a8053054cda00e4ab340e3f1155b3a840d2d6aa8fc90fcf4438b5f01d9d3a2810e36effb1d260b291a1be2959f978744b39c7ba9e6545bb670f5ce3a7b9ee7a052736d398990790b36912feac54ca9ebcaf7e2d2cf5b1c45403af0fd7d4d9d4f4a9bc61c76b5e8226de66afa092030f50d632fe9a99223bd3f925baa2dd4d9283b902a7e43397731a161d3ef960b6e02b215f95af2015678c7d64e29d5724172f5c45671330714b84bf5fb9f082641f81f549a74e56196d523a8b39a223cf969ddbe0b29bb5aab6a0fb7399037603e0304d1e2ddf87d116e206d1527ee88c89d80f59c11c6051c78ca1f2695a8d10c7ae2691996c1959f2ea7da284cc0a528bbb5567d37307b3490e2c2d9a7ae9c92d5ca48b6582397deb18f293b91b6b3574ef44178972d26e286f0e6b3c2960408eb1f21aa575dda2f245bb8971fd89b687b0ff0069563d74d25d9649f82c5d1235427104cdce1161f3a64df2a544352b6f4d3b05f890fa4e4a738bd79ad3afe62f5a8d3274c1b46c841a3db28d4f2fe398ec7ec6b1cbc53a8395164c9ade1e5ca990cfcfd727b549edcc2573ef0735b085643f9310ff5e12deeba2761e6e6661efdfb533ce6f8269f48b6afd742d6ad53d808390dfcf826d284d2724903eb59cf459e4347ffd7ecf5f8d60863640db6bae325a6d7e335fa72b40f566cb12219652055c19a310d4720f4525692436aada42efb2bd8ee99c328ad2ed26fca1bf36eafce78e4f245d4d8c69e6ee892ae21037b600ed611a3188ac737dc4b1ba9c1e6bd554e03a0034d0b3ae91b84cbdf4f67019641530e20cf2fe88f49a5a6b815f31e5ea308480841ba621d791461d3e043818c33640a356dcea09b2c2886b5b9c0dcc730af734c2683d1dec6cec309f104d3e6bed6893905093634e4adfa31c3fa6dc62e321fabc55dba271f1000d0abe729163597d33ef5172d73b33e6bbf99b299e0e467348d3f87eb3a0d539ba63decd956fbbae482b73016d4648de6d7a0b4034d1a2983f1b2ccfbf5063916cef7c539c260c15cb4eacef7024bd5ae33913a21f7ce6179d8a05997a591c9fd9baa3de49da119d6d34ea456eb16b1e5139e22758f374cb8c1f7879563649548286a857b7526dfad2e240c370e8fabc16cf3ea7ff8cba5b1b6d7687568a29856636c4ba5676f43a144357d87d4040ecdba2fd70426e32413deda85a783baef4e937e170714b8d9347b43c33e9723ad05152908e53370fbf5674afb360fa98c3a3d0745f52605006091feb836c867b29d355d5394bd4e82434b2b54b851bdaeb7eb1f358b36fde3832975562e897efa64824ed6394c544d442b3e964ecac037304f2ae03255cf97fb55462903f501ff5bd523eb3874268ff0bac9912921cb2c43a47cf72fcf9b1894d5f292ebe0cebfebea548d5fe5bc7f6fda6edd3d38a3c4574e40687c47d48e38c07d4e831f4d49daebabc6c240185f9abcea439f372db0648868f202f24335e81fcb822fe5c29ccb155fc9d3d2969e3a47799ee8c09dbd742abdb2842cee5f29b355acf89b6ac6bf3d42069b5155e37f41a38b15c48dea8514d7300ed87ff961f5abac2ccbb0c32ee2e3bcd1fcdb574c2789091d6b0e1d1875a1aee8553bb2cbab1ae26d7f2bf1be873438837146eda3d25b870a577a27c8a875974d4731131dcac338b1733203d5c538494de848a24c12083dfa1e53eaf10380d9bcbf478602b354f4eb0e4f275c3d401287fd3ec8f5d4e2c5a606e0d3b128045892687fba38b1cbbfcbd249f2813ed8fc844d84b4327114012e919620e70064e0fb4171332446dd436fec022a03b720180106238b8c134c94ea37e362cf031c944016d40c3b103881928d4fb1056dedf4b58c905813917438971f448069302bae8f7fbe21c8540b20c654aa78978ee6e139294a632b9f894c61d69e68defa30f00a8e303b752c04439ab322ee46a96dda485d736dc128904cfc4032cd0abbf866272c6363cf8f82af9797303537eeb9f725f20fba268a13b445ad872ded19a0ef858ac3b1ddc918e2b986f19ca166c106cbe7168950e4b4fc780e65cb4e1b2f3816db3f89bb88b90d29f3a97a84696e6fbc33f5af765e5823811450f1210b72922687cd71479df17c1460e9f20a5616bee657f0d64840e8fb16397296047647c860784ecd8a70a7d8bbfc38dae0c2fc216182b098bd978ff287835eca03a8a540306d3e8ce304367420e3424e7408660d8836843c6ca0d2dbfc101ff7a6d48e1b2435a259d2b5981dd3c5d46843390afea5c8d0563948b7445d0300b8c9c55ee4609717cce772998f67cbfd4d041a6351e131e538813ecf639df8276cf14bd5b6d66fc0ee96a852cb557fb9c4d5748c593118257de7991eb31543a2433da12e02b6a7c095dc2ef3abfacefcda6095b09e9cf69334ffffed0245a71c8e7e1046bdb820c0961570932196ca92cde56de6ec734fc62045257fc9506ca8fe24b20c3e241be6c26b35c2103d8b63d236a13ef54499303102185520c19a7cca2bbb88dd9804e2e2b1c3828be6b1e505232a0709eb9f969ab22faec4e99c0465d783f5fe9a688b4fd36395e547ca70f1d35ed481065a628aa09e4bcf41cb4494cee436c521664702a58c3e48802b0acb35db91cc5ca882d5e7e24beeb0796df9c24e4cf899f0acc9c2a0e9a1ca05801edd52735f3ae102fdecd4a51b519a5246ae658befbd2ae72376828148838170a79e56015059117f0ba5471e2005a710cbb390ade206fc37101a8c6cc13da329ab22d556fb467812600b489048bd75b6e528d5c4eb2998e494085589921ec99883aaca4318d965fa0b687591b93de3ba5779efad40ba8aac2417920d3d7e01cb367720a9bdfa6b504b0c0dc51d80abe76f38ae5ee7de7129291ad8ea81b54e5ef283ad8184231f19ab78090725bb9ae08b415a0ebd04c4699e02ae451f20b03595428980346d47f008e9f1fd16e9f459389d10ac6ef9a108be443e0922ecdf9739ea43d214f79a0c85d18b5b3cd786a9c94fb04f58f2845e6d33ea0c196b5f1165f2e5af6af43af34a7acf3c6956e786815dfa49e09195d5e0b04fa15e0b7791dd264c56ac1a0b8d9a52ad1664bfb3506e59a2576bbb3d7c8850d101f162bea532fdfcebe842c09e0e136c938431dcdd3ba0037b57c243de837bc5397b92d7ba389727b40c3f9aa33f4f41a4a1ba8c00b1fa8f28177993158a883c364ff99efa6f0f845c8336557d6369266097c562f7270f61454100d966e7bd05ad6b4f2bbd095f15d14eec01759166050659666431dc0b0751718faf72a0416cd5d6ab9816ebc25e28840eb1912ce2a08cef1d57ab732f2247f04a3e82c31ece75de7b82a483827ee1f5ef9e189991e701b71b76ca555b60fe2efd0cf1233c900a76691ff03edf295abc90d3b8f14f21f088f7fe999e032b7b1f5048789c2c8abc7885efb1ad9afe4afe4a83494ee3ee1380d51cafc6ae07bbb11e82c6a8eb30c616e5cbae2c64647ea362fbfbaa50738ff15a15cf806017ce54da052c1c383ef5376353c30dd71eecd644085c454943032f447cdff5cf625b70412336e6bda17f1a223d1c77e5b7d26ab82af72840770a802934e641341eb495869e643452bcdc3efe1394eb92f1733774d890e14af00e9efa590211b186df3d5f87cf5ac232536fba23d73a3e2dbae27c6c80615658f94e8be9bb445b8cb13728ba283b91ecadcf1fa17e16a360fa193445b0d2813de7fb6e463aaa3813fceaa7a386e95b20dacc4e117f3a5463d936ba8fa503d955624a703d97533658e3dae580d98451c7f3a30430dd88e3e388ebf6e5a6d5c9728dcde061af1d1d85bd2023afbc92c553bc53890b5d23ff14fbab1d273e6c8df823f2ae7ab9a8a8096d936780f111c10c0ed0bdf21321df9ffb2e42940cf61686cd0df51d122f924ca67fac4033fc530af1301dc903b38a90f4f488f7b35496e710b9cc386b2bfb5ada6fabd9bcc85984507fc16b04d3ea1aac1be105aac5fb3332ff5445364658bc74a63f99c3f573f43405b6cc3dadf47bdc4e99ed85ef8942401d17674ed46d59d5682d29b494404d36c2cf709fe33832fb1eb545892a377f4a7cb4e7ccaf13fcc419b4cc6d9f56c12d980dfae30f715f00d9192c34be543b66bbfd9556751b80e99640b6b4bb461fd714f81cb86ae172e10326099e92ffd1f31bff27f2e778c5c12cd59a13f3bac48dbd602c783053960b7300d4aa333c711c26aa0b32682a11684087d8c829dd89a63bcf9e1d589aba19fbdac177ac5273737382337226f6c9cdeb34fc7c59527faab5712fafba418be70cb2590171f3180e2e2b0441d5c155d36461b7767886c3a843a4215352f0875e9ab5e9ca1e9f97996c5f4da51ed4cfd904192d013a7832f4ff6453d15066db06e9fbdea14f95759ae5bc619604db9bb66c6869ae0c403cea28897a3b5048381e94909a3676ef3bd909bfd8eb1511a7bcc0889600eabea65d60f0152bb65aed9dcdd95967e66d1efac5bb72bf63184bd1367fe608c7913ac902870c15032977cae321e8f8452566d3d0a0b9b96d8d9d96dbb0f19c217a354b0d764608ca3e3c3e0001764e101e113b95e956aa9984c7c5c230fdad2a99b0e3204e910adf55c8b07936b030af93d44382d5b18451b2701a68976972c4dd1332ab0d06d9522b1a172dcbe826cf67573fd68b5b6b67718ac793b4e4675ca2baef37694ca1038c61bd2b71b3e922bbe31742b586c1894a183215b302a25bd3147fcc9421c10862ec4b91efe60c256d0486ac3880f9d81d640c82847dbc0ca429d30346eb8244c9b8161d381a976fcc32ccb24d46bcb61c267598468c5a21d326dc9e6e6def4f121d4f9a195232f1ceaa8354668ffd2c5d78eebd5206b9e719a77333a36664b8e20d99e1d450fc587e93f24be261f7462902bc43b9086aae3f347dfbeea4433e7096875ec6e39c356ec12efae4f1162ea078774afea65313b297366226dc17af5f49b225551680ebc41996764c9045bb02426b0753081ad7e75ce35358523817b86339e10cbf038edb9f71b17f28a21a37802b003c200489c8bac89cacaa4c07d74355392ec135bf7a302b0e42d88ef4a877ac9a42b5c86ea617758d6e0e5476636282cce1e0893afd0605b7490c5b2dec25ddd942152caaaddc142ed99809a7427048c824d82bf33691d4ea3f0b7ad801429b29ff00cfd78f61819efef66194e73f8428162c6e23b0b4310947f6a26144b55d0f45bb0929e81ec29d02116921b94680ba6f809fa2ec17d601acbe3abed81004d54459546a935d34ed7ab16dbc830771b8d760aff5886ee29686c5d2cff5b93c987f78b4cd4a6ffa2e8a0eecb29560e532d82a868782e26eb0b6caebbd35cf82992be30d278087b4d86c7be3a5cafb9fabf22577f654098955297d1f396ae595553da7a3fdde35f2916f753c35f3e5490494fb0d33c04899bd962359c1d252e57fec7bc35867b9e09414d0f05d7540c6899d08a7ca17422a86bb8801dcd33a196f505cf98c18f876f83c136bf3a4ccafa8706dfcc35dbb4863be8a46e7c799a38eed77465de361ec09900e349969c001c0a93e9a7e300fab69498faa8ca7a0cfee4ad9d8e1acb117e59d0f4fd89f6d048f4c5172e16763dbc169b3c31eda575429a7094e3358cd535b7c03c9e7b431d191abc7d5b54aee4849b52bf4f5357782b2529f536242a7b0912ac9902c3f8279f0d37087a9e0c0927ec62b708f2966c8abac904b1930f77d70439d79991ed7df9b261fa0c2ae7689042ef1091a31073cbd1c2a76bc4c537537b056d270b320f9fdd8cba4dc4bcbbf684e9e76c0fae6f2b0538e4f11bec89b657a7631956f21fa4f7c80eb47f8fbddc71b9b3010057c6f258411beabcb4982e5e3f2547f4a7c36adfa5b8f59e5e6dc0272b2473d329cea7794c268ead7d53ecd4c4adec164dc6dcbc562e5885541fbb5b87767904ce22eb3516d844d311a50b08506f1fa517723bf285178a757bb48df9d5ee32b308c5eb37a50d57eb77b67273cb4628f0a40e0881cd51220d16adfad5f9a634c80fe6f31bf8bb0b4604c18e24ebd2d7264a30100484b5f47bb957c5b7a641e65e5a0fac0cafd610943222bcb8c25e62ffb6f2880ffc4ee4e6ae43729fc8c62960bc335eb067351cf3b643e816ed49155d8effd8d60a7119d5b2350ead5f11ec1050afd6b903d43e7da7b6046a571f3d0092e359d32c377a8a244dc075fcc9880622b285a609d5c586c5e21933072b6375c271a499b7cb04de1418fcd2b7dd76eacf99b97f5b560af294d3acda4063877af89af64cefc45d1697604424cbc05d950c9095a40146294c9298bca3584e9e670ea6516da8549ecc784194c876a5912c74a4cafbe04936bfb112a8bb4d5a78536fb275cb6942b92a611780b4df76f16e39e2e414995e72db9a6c2c7b8ebd41811e5a635520349ea9a20731bdbe1b40052e8ee87e880d1debcb9ec94dfd2f1fb5c51aec72c951c9a1771213d5e4c714782daaa1df96864b0c60fd2f169f9be35668d2990820d2af30f6c8a7bb051ebf487c0ad9cc88b39543d51074dde972f32fca4410beb26d73878abf07ab5f21b700d80fa89c71a89321e60e409dab0c5dd203db98f1cc3233881e96b803016a6beda8d3ef7783af9e5d08c165ad38b6ca7d0cea3e72f556dc1d80519d27c9f3affcb79426590d38cf072b455da217500c16d54f65ad3a5177ccde5027689d4698e4802679139d8ef5f1b13c0a3c39f95f807319d464b7e5e2aebb92456880a3752b6671d503150382f8411cbff5c05858cab5051d905ad00109dac5347b49f01cdc9cdca50073642df16416e080e33cc34a8f58090691fbff04a475cb648a19e17d332e5fe057fb261e37ca753e45f3dca625435b222c454b1540c09e88f901b101ed699313089f9c0f5a7318b8d477e6d9f7df520c8e65903b329968806f6e8c7a991afcab7320ca5c9b2342de26f8fafc823908de8bb4ba153509b2f8c893d8bd13033d18efee1a64fdda9d40c24a53ce7520f2d0b37004dc8a99e0e424130d65188e3ed748099e9652e5e344f50bc572cfaa837372ef827b4d784c4bb636421d029f1102111a2cf34ca2c29795d574d50dadea31c202b3c695f3c086be4468869feff06fd8d704b9a0fceadaf529821a385f645e09d77c9937cabfd94820a58ebdca0f2cee285ef7f16e91cec94c76337404f6eba49ed053939fa1fe4843eeb779fa08720abee9687bc6bbccb8148612b1ce9a4e55f7952f11a208894374b036962dd16082cd1b5eec7674594c69606a577ee9e04a0a8a877344c86b0c181211b04d0258430d61e7a9a1d37479e729b5b8a1b2d3a8bed8e464811e9166f4b1f7d7380bb2342fb3c38604a998cd1dfd33bc03a3372910e7f29784aa883b7407d6259ed09dffb89b4f479e602fb3ef48a62c84339b4b40886fcb5eebc0724b947431a29862bcc27119fccce63ccf9bbdd8500db44b5854c16f9b322d85c2ab945d1f479afd23b91639bb31bd22259177d1bf979af79228edd9881ae4a3438fef20c86ac6afff5003859a0be345f0a402f067ee42e04f8dcb2e46960d3c44bd83e9183fef086031109aad4302047a0eda2b2e53d055533c8ba70ea9d9476976406d6f55390a5e607edb1a7c6ab17c705e9bee1739f3de63cccaa3ce2f2e7de9a383c9938115bfa43069187946d074a501a729bd373d352cc87a6345f18edcffa6b127f519822a22dfe74a67a8b7e94a0a49927f907edf52786e9058c439298b59898bde53f823977b8f73181fbbcb131e3baf29bc02340539f96ef4046f0a320d89096437a38913a96ffcf4f5177ad0342f26555a6d9173e580cb4dc989861bca4fd24aa5c76d13add9100af60b160dca681093ab6930de8bd57e5a8fe6b69e52139cbbede4771dbb02757eb2a20a82b72ae4efda1a5b3d84f6c05180ebba4f8d2a8264505ba7d84a0710a149410590f7b724e9557aa12f4a7ca14a01052b9c532a949b3e606cfa4e03b74bdfc4a41aa4660fb6cbc9c083cad88dd1f4318b10721fc2045b81f0a9abe0159f3bbb12cdc6dfb661b2b116c67ecc9d16ba6e305a1431d10e1585660c59da4d510c8aad014e2a5d09f7821e871d02e760362e72becb4c0fc6e59c7d472da5745bd3372a10f0c8fbf6bba7291cae0656b38b92cecd6d28356c8e80008f685bb0c2f9e7264d635f329d4280966bf5507589cd36996c76095ed1032a3e6558ff8aa0c087fdce45d3f0cf5ced96008eb79ad1d40ec5eb22e2739af69ea806c0a20c0790165c6cba042f0c72b6b5f85b496289e86856be767313ae235d202bccba1a0dc8b1f63777ec1a131ad8ea6198f90a5ca64a13adfac22eddca7a4d5245e08d284aae4532fe54525bf0f82027c0d51dba1b9b775f2ad1af52381c0fdf92a694afd003172595ce26d894d411807aa973f5752fa293d4c75d883d32107d4576889c02d24d03635869105e4d18613070234c7afa77d73c0deab0d1e226d86c8cf62fd75c912fef650ab56e12323af1565a05c1a28ef2b51fcd9824bf09aab8f6dfd7fc4ff9cd3155afb9f0891f8747fce63c43f1a9a8203a57d0afb49961cfb257b43d84185166376e70b15c55368d63264fcfe437c959b38dd59394df34c0c97e67c80da60e31f6d4254ba13eb8749c15851febffc9663346a3b06944e998168770b125fe100314b61293c4ce197753fce0fc39afd8e2c55291aa546cb6054684bc90c9a82be0abc511c2fdbffeff1f5c920d3994b4e72d618b104a0bba55fd1057622e4d48b2675008f9f9da2018c516a0dd5148d46c1506aa17e40883694c249f0679d07834e07dca56dc4a91aebff468e31d66e1ffa0aafd1d13bb81479709a5ac277f4e12912f9367285a598372cbf979ad841718b5d8455ebd5e7c0ab6cd99d404cbc78b4e162662f222257bd99d9c0b97ea6865da51f22de979ec2f7a7cd2deecc90e0968aa42185d36fc32b97405108f651c07507e611b9198b8dcbd8604c4b9df8f8b85d5784c170b7e1e92cf5763c61428ef6a832d7ee06d3c64f62d5498f8a4a93520838fe8c9a9c6fd3602c6420b53ee5988a6f98cb6f8e491680c318e73694948040db9425353d4eaf2547a16dd835dcc1795d1440e7c6fc15a214cdc4a39f0645fcd6e81fd912578694770032bae5a8c4ae8ddaedc8186cab3ef1c9cec913e6b9513bfc7e0e81f5bf6e7491176170fd57965fc43465e789b731156bb512f9be6d4f1b76cb59e7e16f94db63e7b9bee7289475c8d95a1ac0a182bb5626bea5c55542048f866a1883ba0c49947d63e0b6a02993febeda78f5efbe9278c92e3e3c478b6f1e18b4373e3ddcbcc0254fcdb5522c78dabe7d0cbdf835c6dada1048b5191395b1a61ec157235127efe07a36322eefcce12d7dd28f0bdd5303318918c4a7fd37268e6888eb2f0fe5e1958c5b73d3c36b2790fc1f1df4230fdc49782e6115d32900b95304d606bcad42e3135f03f73ed5d76326b94399ad096fc404e84d2c3aa6652c61f78627755a7a438147347bd0005ffbc418fbc0a028b36ffadd7c96a16792db3447cd30ada13c2e35956daae3ae54e8a88ef97af7314046529955132e52bff4e506fc3ae3d8c1ba746438e8762a567b14565ce4efadfd565a4ec4c3bc2daddeb4c93140bf7db137b6e0e954fb6035cc84a669de5e208c7342734b6d01e0497f523163407d069ec9b9d23f3d06a0954cd60cad478e60226a15d1d741c4b19d9b2ed45787e0387601fdea64f40cf683c8c1cc80f9dd30b27847aa85ebc31e36de46ee3999bc23993e56af8c60eadbff03819766f0e26ca45397679425449211b55a5fb930cded1ebe8173d764a89bd253a1b24e13fc5db14f1d948452b061cc3dadec977c0f55056de36246d4280d70b823c28ea6447534ffea0a7776c4245aae3cc57cdbe3c64a0be8443f19a5d77d7be6336eb0c99183d9d4951e995c460ac5f62380697e14417213eb540ef863f927316a90ca74730a4c1a67b5fbadcd8fc48845733cf2dcb39830a4032e9e41dcafaf9c8614b4e63bd7de68c81ee4bf525adc2b2b91fb76a25a485e8aba9a354e1e462d3a1b4069aec6d16fd243b1d38292bf5b8a73d32e16712511b8b1ad35c6ef41e2084ed57e41a97283834f0ee227e5830bca033fe4a3821499565ff216a72a28672edafd82f226cd55ee41363c4019ff9f694888b31e74635dd803d89b702cd54dc2cbd9967d19a435b99d1c0944a1b076a181d2eb5c92749728a418dbcf6d7308eba7a4e9e0e298bbac31e52f9fbc1d500f9b62efadb7d357671799075a7314332e1907c7ccbbf5683b229fb214ae0646ac314347b18597c18c39b3b9bbe9b7fe995f0abbb41e156e39a39fc0ffd828ada16f0a187752505095522e8638dd3f023f5301e7a2f67c7d270b0a126e232415097fda8ab4761d114b83d5840bbbaa54e2dec864048a1c180e7fca1144c48944dfb547147cf8dbaeae4b73f8b341d9d320b3086f53335a77b19390fae43173f60b62de7e9c790be9b3730031edb3ed03506fa86ccba83b437f4de8671c1088c7a8ab0cccc0305f7764206d0d406e16649e2b4c25cfb671c9ab7f99284c699133d2ec6feeee7918df7eeb4c7480027b99b8afe01901c86a7c6c16708f1fa897406da3e0c4828d7198ace3f3e5b563a6405e0db16cf6ebf150ac9295b75129ad77580098873e918ff8945c01981810550349d059a841ea79ee2baa9604cfcd87343c64f2dfc54650c0a849e9c352b0a9a16b455592c0a087ca2bc1d07b4f4f1863bc20613d3ed9ff41c95df3000bccd802d97981ece5e8e0e589a9599b5026f56228048a2a4432ca94c763d498d65aac37cbb1a5f570c3b71e1f38c3a5ae01f13d19c8c184f4b45abbbf016a8de92698c112a6a073e6ea3089c3213468b4a72fc6cefad809c7903cb4caa3c9b57d4a47b4ee3a312ec8e367e16216dd8f31efaccd08d7074c62edcd10c93872ec454fb32219d6463f06a8ebd65502ce8ba495ed941689e4b47976482eb6c3de4e764d44e8e42faa619eba98cf0734f8b883498450eef1792948d523ff4060cda8acf68d401ea0a9aa11a95c6518475329007e45da498134cb0b669ace26243c6b5a474e7a25dd20fd7b6427d4ec6647114801d0e8da53a2cda1d2bc35cf0ae6cbf8763dc8ee0af010a26d382455081b90dbb0fcbd1c53d609e64f1b5dc9cf31e18e6e33e85823bf9e269810da0bc736678f0f11592cec0f26f64b2c9c206e375cd7882dd687b7721a70196c60156db5b9ad31a41c7063c4dbf5cd1adb9afebe9e1e033aca0f7db5d11f98f46b06485594c549886775b245949780f5e51a975c98e6418fef340d34642fa92c204b6f330fd9b955371fe6cd425c35afae168e71c4467fcc48e0d512bbdfdd3857faf42c4364a641df1b6cdd743611bd89fe59acdc9102f2f1b113014307572fb38746f67c23dbb0119cead542a1fda8c239791e16e5162142585a0b5e469f2f0541b72acd340359c57fd32d219a85ba6e6a9fe1f9d42257b90850606064c015b8cfbf373b79168660ec3a473e368e920082b5a1b5efe595af37d48a09de1db6d74d4cc8c151c73efae0e116997325c219065585a4d63df27be52d92fd9074de8100d01af0f41d100082a3ef1f59b4117d41046713fb8563773ae361714b42a647a076ac7b72457f7f66c33896ed588dddd9e60789575b1f311e69b0aab41f83d25a25e70054af1fa2d52816f6018ee701697bf237dfda7ac11a4b335b3b73cae840f90f5f70044553861799c6553f1814bd10fd8f06544763d28b674f2a34024174776d609f109ff67ce188098c54ef99129ab3f70b176ed49ed556c96b9ce963d7cb355a84cb22d1559020cef3c4a529d83876a9e94e139505dcfe3a47e9414bedf6cfaef83bee802cfd11b3ab5ebec099fd69716596a74f3791f0fabcb8ce463c6d54e92302194eca9b47dc4b225b71d289bf21c3031e6544930b898c2a27f57945d2323a0e078e6a3c47155bcd1294d39354c8d0841d83b0d5b9800f42ecf7e0358df4aeec3c1a07ab344e7c909a72401fe47bc4e6e1c2fe582f4e264944a03076344b2bd2f80be727ce60eb32ce72e4b2e92047b42d2c9c9d23d24e7a5ef6f56fcf52577a0c0911f0ea5ee73d39b3b1fcf46f8d8699761699e338adcd9bf05fc180bd208bf8d2f15d430b5133fdaed9a316941f628d461f40670c2fa5500362d7f27c2b149e1e9d9ae9206e57418f6b35e7963567288a7afdf6c35c9aa3a1130e00dc877c58a77cfc9ec25afc14e2328944423ffe35fc7a8ae8fc99dbbd5bfa848766993c67b2e350a96f46e4f1697996ccad2fd4d5c153c02a9226ed461fb255eb4905dcc07e7d1348d1f70016d92a17f68418d9806e65410d238fb8aa66ba1e22f3f29020e86403e6388cc8ca713095f891d682fc117133c0fc03c3b4f0f5e3142005d8788791c3c92172a104172d1de0931e60d816dfa204d1be5dd563537304ba554f7bcf0b52ae414598d159f616bdb4f91777a5b4f015e90288cbb51b4544a0b93b76db2e0a1e372fa5c53dda4957ca98af3c00a1cb3fd89c08978b0aa8fc3e2e68f48781d2e819559e2f20a0de3da862655050d1d2042411fc00375edf69346a3bf25910f05442409f3550d7428c6be4f8fe8c6b34893c26a2ad45a9068203a19fafdf673c0afd22259d7f32c3e7b0245399c2aaf09aab56fe5cd9eacfd5c0e6ad66128c12ca55f567764692e2c431ed86b62070b5204e1ecbb52ae255f3b90b12eed4d554aa0c6318978d87347fd0ea083f470d444033185d3382e476bdd8dc0f91233b6962a395c571ed773cb0a96057afe90c0b7ca7a28b843a07939f11bc7adfc901d7b7393768546ee6c569aeb33ccc7601f5ce2b0ab539af73add920a1019cb424c861ec15d932e3202d17f3d088782568bfe4a798f0d29f633f24bc4db6141e76019c0899994b739dfa19ef6fe0750d72a91bf8138c074200a4df461155dfbe4cb0b4b3673da4a8e0493636021d42530792b65e232ee9632e575405c8795d23c8e159899408a890e5c746760cfdd17f192ddcc9dbcd8a51c9d2f74a2996e15de95f0625b8950694c096239116d053a844c850e033f33f39af1ad71643cbfa5980bbf98d77d1b541431abef6a119b462bb94c183748befd9c5650949e932b301199bcb6173183d42e79ac9d258aed9089c5982a3da83ce446b702fc6cc1af878c8756946f7bbae23a194e6e911f6bff894a20d8c7b7707cea9c02b33118b9fbdd8835183f3bcdbedaefeda3b2693ead607192334c4172cf32296ffa3b984c22573f91f32c3522624b55b6cc8e4917d607fda8ce2771bde8317262e7f588a1dc6bec4cb248aae1bc5215299e901b24ed0bf25779272298f1d50f00d58fd11c61abf7870dc6d72dd7d602a725093090a28c7e73039305ff8ee1371b63467dadabd4027f5e31b8d527a9dbfa648cca9f6da23ffbc3137033fc68c6b6c6a6a0af76ba3187f2b2898561e08b1ff0205f9a84049f1e43c59aec188ae37ca1c922af731320aad028ec258d0e357ea28c8fec5458d366e77f4966a1e5f78f6664efef54a536d891c219e84a33817879c136ccafd31d488ca3d3ca5b62eea5f228e335a25a3e4938dca40a9c49016ca7a01a2712ece3df1005a66f1b12ca860bf7338a7726f261d5ea7b5a9d7ef74b3b933fe6ad5efd1706a31ff220df7972af9f049a2b78cc304b479155c88cd22269080dec8bec31f44e95eddcdfead3dbeac9b507b4de8fc7c7d5878216578ea97d02f490ddc8ade45517c054fe6998258ec65b4aa43f894152307aa973dcbc0b5ff468e79c5e7cabba6642755179a54a81ed3d08edd2134ff9f67fefe83f5daaa59237b6d4f771552cca4db646075c91c38c8c2b68e02c872289a686898435a5e9f758cc6163a90b92580cf4b3d8fcb99be228c2581a2ee582f84e88d298f0e809a948379bb90ea9a0181c5e5c9a8321ce169666c3aff845f99f5c4149458f8c3187421c792dceb2b4404dba5007ecadb19c0a6cd06c6d56c920a4d11aecc7623d3b44d6692a7344ae32e03ffae853131ef94ff12bde3257e9b118a1b892da2bab501848388b64f32c8eeae25f64ab02e58f18c6bda61601774b56f3ef487699a268c23452f6b91f98c5164048b22cb1d08ceab8205ad844a1297b709c4decbb08473cfb1bc78b356c5426bed836de01ec5dd916335165b4448ead819987c9b8031cfb7bb4100a41dfa2163c28ca3a66c8f9a6fd7c1d9f7fbb6338230b15e22a1d93033f31cac4a304be3867e79d2373005f8e4b3147d6f0ac30dc96036bcf067373b141a1fb1a7c221ed91532b4df34e1cb01a6c3f49ea1a8c9dc570eebcb83e67cf04d4388804b8499863a9bd2a3dc5330974051ae90cb066987f5c4bd5f388d0408fe5038df59b375619610b462a6dcb0ad54a471072c8b53b37940569bfdb07346d4d9c51325b973a6fd72732847f101ac8474b9619240bb02ae83558b914924624b45cd7f139b56b27e96c1dd6afe7fa4c36caa9877abdff8da139ab28fd1aa83514cbd506df871acb45c8455bd826a59c5faa8cc97bbc794a9b9beae2377b51fee4c8f423384a3019ffc5a431a016cfb9e2dde608698db5acfc546cce9d3676efc21500ff9d626d399c114f3d7d836cad833d7aabdffa2ec29839d1de5c348ebceb87e75c768fe5e5a7036a68a6fb75ce5e0828370dcfd9e9ff9bb2cd74050306f2c8cbf132dfe67c05244eabc302e94afbe5f991fd683f4e811fab3a924b93f45129c1caa4ea3a3a779703219d87b9554bc882645b71a07c177ca1e26b3edaf5683df92761fa99c83755f88940b0fd0539f9f84ee473f73cfec5f6d8e863c845820e50bf692f30b7d2edd5c49eb98903b27ddba45c68c6e3f12a8ceadc4497702cfa805e6fce2f588a6ba39b316a454025e070f9d5f602d212fdccf694a88cda91e6fe203ed1b2736012e726cc6c3bd101ea5775756698ab15ff66286de2e2826e7c5499f5d28117972e2a6b429a0c7eb8d9709d37402bcd69c7082d076dcf9906b7ef5e5613301eadcf981ec1716ad351071d2631394ce4f6bef448debaf12025d8f5df7bd9737d1a6139023478d704d8f4da4f9b57d73331f12b59f7522d753893fcc48c82c7ebf609f4dd51a62203136bc8ce71d06a1799b73019c3d071ea8bb02e200b9e813370155bfce4946305968227177e746ebb54ede218a89594f5cf35c3b4d752210a3deeedaaf596d5367e3182939413eebc230f2bd7d8ec7cfeaaecb8ea044533157697c18677229a4c469ef4ece6b7854efeed05113c5a79e9f834d5d19c7a7cbd1a54d4564305a390a6bc08a6d50239a60cd965175da6b362dce6e6d4ba2ac00fb2af7e390cc77abe9131908dc45e697fd81766861820f6139a514dc49a85de222d4be4788464e15f4001134797fff0c520dd212e8daea780a08fbcd960851f9a783c24dd3d69d7693da79a3cc6fd65897c13f6c217ade3dbee56909ff4c60a32a9bd99856056667b3a9dd86be0f2530c7581dfcd0ae8ae0b6e5f24bb05f99dae979f725ecb3e3ecb398e437d1eff29b190a9ce9f292198b8a30fa819da139a4dbdb811637dd3b859b4922d8b9c118f3f9e4c89633f21d45d708d22483ef02d3dd6e6fafac5ed8a9d9241bb0fe05b9d403ef9e465a22444790d02f7be9d7283f4864a6563e737a0c3c8c5a5b2ebc970c222356595d2a6f6ca920cf9f97f18ab5b170b1d3e037448ebdc0fccbb3b08d3786008c3a992682928d91719e07e8a45a0cb475a00f2f90c5fe595c8a9fac2f23b798c1a5c9f1c6e5d3965034880ae0853d3cdce3397d8370738b3865764420f2b1297f547140b1339c6b45b66d08cc8fe8d41f55ca992adab1924aacd7b07eb2944dcba2547ad7c660e2c5eb045ee35f302a349ad11159f903b97ee1da62316bea8d8238625b101ad8f5484df78711033a268e0eb498a3f067d7db9d580e20e927f311cfe5e8f2aa0f508d0661bec81b26ebf98486535a03dd52eb585fbeedc7b0ddf12b11f8670253b3eed32dc1711bb3e68ff2aa1295054adb57ce44636e4df6de7b44bc868f8ea3781e4e9c95224efe807ea28dfc32409a0cb7aec6197e9d48c408e562f071090dc364b698943a549838b74a80e3857b9f4bdad90f28c4caa73ec216547124ea9539d06808b4af2b87a6041d3a9dcaf15c975835a39bd3322fe5922dd690c601329626b782f4fbb2152da03949d8443a30978b12ac383209c9da95c63bd8b7980d5bd9fa9bf7ee68ae1f75001145ccc3bd6e49cd30366e075bd2acdf8fa04124","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
