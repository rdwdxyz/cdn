<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ccd2dc5c5a5c19e894b676aa8a3de8d3bbc479102fa68c4b870db26728852b0130d0742e4637547cc4e4cecc6d5650a226ae58d321c2871c7b4e3467ab6c877c0110c16965d2bd9b3538ee006ca9ee56221da46a46db3a5723a4ad27a69e8bbbab275f786477b825314e309d2ef76cbf28b801364ca2f26570aa434e2f81131dcec194fa2d00553295fcddd58057ff6c76680ba757ab5f088b6f66f81d65eac370ada907b2c2cdcf57c4a1914f9b1efc7c41e2cb25412e83d328d2ad29509150cb464e4ece92237ef2a6d5548900cee7732efe3633dfea21ea4ef2de06f76293a94d422fb4439770eecbc867d49b4b45e79b3a2ba2f65deeaaa23f0316aa72c705047fe6f4724ac8144a0dedaa4d20d53544a62782d24abc016b4963b431e0d24c167b61a8f2d305593fa0ec346109cd81272015cc636e89835dc216bd0b654b1c9548fedd2aaae233c0bd8bed1d01f64d10794be4b48ccc1c85e8bf1d8ca5f1fa90ba32ef6dfa077bfaf00e84a113f42b5a394ed5a86ba003067e53fb768cbc975d868b0a0b531bac2e1e0364acdd27d713ac715777100ed611188020dfded19e077a0a0edb73b9a8c9bd031c5fa3437902b551ae3b6bd18dce01b4b5908f1487db7e67135a873d94ce2dc048569a9f3c189f0e0325da704cc50fbc5f0ebd3b72d779c706e437624d8a5486eea2b110608b7420b86fcd1d35c430008c071f2cfcd460e43ccd96d2ea0fcce412d255028005ae67a2fa5a13f2ea244efd4c70d4479209d20ce7c808d9a15a5320e4101234f63508ae7e1daf4e3a02d98e10d86b9e729c93f7206dfdc785805c046810ffd99075cd406f306c63d42bac81c4d45e38848476c61e64c6c514f2208f772cd08cfb773257f914a42f515291f8a2398b8c9c9ef0ce413796c92aa0cd7630b0ec935a0d77eb39f95f94a97a0a2e61d8a4f6390cebf571ef29b52b0092ff9d34e917d448a158da110626dca92b49cfab5e18dcfffc36d4e254140b1025838596d1b9f787ad46fa3b4d16df61836926cd09badc219be69f54b1e38b9351607a3aeb9c560b50ab179ff8f59e17d69636a9e59632a96f1b2243bb618526ea44c4fcdb3b8be6a3895e0e5d5ef5fe57e76d4b962167456b7d66cc36a55be85363ef2cbae9513a8d1ed08afd7acd59dbb1954ac437f90936563fafbdbe0b146bf3d3993353b581114ad7c3fabf785eaaec596853a96cd426a1a8e90a49bd1ea5c6b701fcb0b652b736b9b657e8e31552f3160d1ba3b686d94a753a94340b26f3ebd42eeb4e1efc6e569c6b723d4f68fd8a61c07b4ef4fbef9d3d148fd0881d441f27fbd6d65bf6863f844d138cc3deea99d9ec1643d70130ba1cd904200fe92c747a58154529cece4ae4c1f8d58ffc8957cfd0a32b9c4d93d00f21777f24d81d6aaaba6f8213154961a9ed6e4b452b21d3b6b2ee8830d26bfbc86ddf989a53a92580b28acb160a3cb7354e4abcd8af91e41d7d554aef2699c8d39ee6f1c03225b55781a1bcf82ace1947caf6273caf9281fe3f1f5b237c5fc7c596b82fe82f2d6d582be678e92091e789fa0d5ba73437f3d7d0c133799e81817a24fb2488609f2d077eb26e70594a653114cf8e42ca65f08719bc94cdbaaf28a0f006884cd757db25634ac0cb6ed8a70615807bec74da9d5965182db7446cb735fecf8e5e9d8074fd02d59859862daeb04fc3ce0fe61bfdc15460de63871c4e53ce1a6e2bafff31d1cd0cd6cf4ccb3581fc6171ae6f95a6a815339dcc4602c31b175a271ec49862b24077892e17ba6444b7e289d490387340ae935c8e1b00053c913982819007de33ad7b83f7d14e3d3ed094b1f6a62e781f4ae7e34d98758abaeec308fdd79ae5ac8f503870cf004273c18c803d7125d882b81fe8484c4613ec2ed52595c1e75949fbb07b160eefb126e55b038b6d16b6b996069d0e77fc510b3a0f33f250ba87756b339753ef3a40f04cfc56eff28423520ce259ff7f558cb25329774adcdf36278f267a6f5ebef9a3e9bc69b8e7ae24b5702aedd1e6d0dac8859d938d4d2f8b903a7e21ab09f0b8abd51ffb337068d01153fea2b415c23111a09e4a580b5617e3ce99c0296f8c3ccacde102157983d25654e1ca95d62ed69987e42820e21dcd3c4e8fc0a05940978fc30085103ec67cd418d614e0628a00df2158de8d7743cd22384a25d735103c5fc68227bd643fa5e94ed5e7e3acb4768f148c7d01527d2fa873d9b31ad2ac41cd2f98cc64a62cb2f0f65d5a93040ee7f7286c0be7965634d6a6dd86c5486cd4b1f397eca6e23ea43eb734edafdc33511004a2b86998a23429cf01f4eee73e6cf2dacabd1873ecd6f899c66d83153f65f32e598fcb181918bbcb8b94e5fc0e7876b9d2077b36fa43866e1a3971d8f0c8a12b24e26737aaec8b4cbc5564b66c1ce2a559c6bdde786752a9d392de48dd4950ca8446807eb09deb68edfe4755eab768cc924c45998fd5d1cf2feff0a22eae48a6c75317aa7b4c089bf3390250c32810f4428ddb15ebb793ccc5eb314ec16334641272269e2d54551916b511407db82bb0746570d5bba817f4d05cb0bc8779488c0a2c0418b5018653fa7425ed3c24f06a9c25a479749dfa56e4d22cb37ab3b4910df260286eb6be287f4f36cf0f207d7e4cc0cd2c4125d4e72561e226259325b83bd19eda15acf67c9edbc8afb66e2f8318b10f665aa8a03701063a75fe56f027ad83353a05038e4382f2a51d7588c38d35a6b31d6edb6da4a5b14662eeaa83f828fe7a96e192276af7c0d2592be6878c61a112bb95b4426ea816c32620177f6b7607505aaeec29eef82ea357f44259a5a97139e260ef099a0587e6bd11188a9040d9c87522240c0187336e59286594ed6868049c6669f0c81a4714a181bfe58312fcff57ec66d5f08311be3d4a664e27be03bf99922a7295f969d700562536df3d9273f64fdbd78b82ebbf73f6b9b7bbbca974b0e99d6412bcb6b5eb91c3ad92a0df790a1ee964ecbb8bdd6ab88d1a3c8b17e282e702c61b4277c28bb1ad1a25d7c2680d2ceb1fbfc7897860309647ee7a798da61bcb168d4744dc9c2094f9e83b4d99e70595c156d722a43563e0d2f8ac370f2ec9f011c398982e807f1cb1303459612a014e651f1b8efab182a273e51574dbea7905689913d86e33a0bad393033a3f94455bb654b82523f3a5c9f953ac9f1d8aa1b8158cc19150f009a19ef21b6bb59d0acea5411d61a328c688726c4e79d4ecbe5209b8343ce84c5bd9af554dda7e39d41e0f8fa4dfecb9c926ed84e0bac7c8ee7be4a4710a2fa745974ca9638bd8276eba21db90b0463e0c4410fe78e5029c1929b4b94dcb9689a4d8dddc33fe4bc3982530a30cc26a0961ac7c2253c876793944d54a40af3fdc6a2a009707693154afd3673168b4e4f5554e111a55336f63e43eee1781dac3ece2a57599a7e269d7a0220ad4356015e0e5b7cd9915c7c254e3ba31c91495ff2b4e6861dc64d7725e6edca4ffda6f25ab16929805c3ec3aab4834f8ad2e6aff35d8887be7798b1595e4736499db5c8f00b623e3dfa47339a46170691f7ebfb1526ac1bc602515082de877fc74ef94fe5debc61717d4f40484c7789030d210a7a6e0fe4ad931ce951bfef50f5e1016a2e6b109648572ec15533deebdc6fd0d86c3857b014aa355bdba0442841fe20cb222cf91f1ec5334eaacac64d075415c70d92ed051b07d79a2b9e7999f578ac0c9e6f815e28d1f0be431aca16a8c158c1457ea323a4e767b52f13668b0b263c01a5af6b0aadec497edc70ff0ffb7228545778cb4c784f686e865f9ced3418e3df98960c2a440639739b7df37fc804ebaccd58686b73ec4a6c1ce9e5abf089e7f92157a119b967190e4c2025894a1c15c533de9d227c97dc108de2fa252f54f3fbd4065c8ce2d4f6ca346c1d1c1826ce1d53596649b4b292552d0d8371d44cde24d4735e9f5725ef687c3413d849d7cf6d38a744a7db48760928859b2108c7c90dd52c142dccb841f1572a32d323a85713cd1f9c31ec8c0e996d432cfaad5f00be4eda0d8ed5ad0730a93e57092fb1184058da4227a95657bbfa39be8d7274a5632ffaf900e01b2146b8f29a22849c1be889c37cc8c339a5e0d52e14ddb2252de26523c00f139960f9dc4793f7cfabfdce0d90fd7380ea750b4eb67272f5be210a5d8aa65a1be0a2593a27ff6c19e9a0040af158eda3ea1ed56a2c3e1912e5cfc95caeb1536024279fd5ea321279e7723b19d48ad4bb30e00bb92f4a5203da6bed39fb35e0978f880fdabef57d7a2e8b40ebe99ba9ad36cdab2ea7f0fbba51409dee31aa0fd4d981e341930be003225ecb769daf93b1c5252926e9147657adf207abf1a69b8f34796b9d0f8a6fc6dcc08adc5883a5af5d5446ff72db3fe3af82000870da41b30babc834c5329a1a77ff9b09de96844cb5ad240d95abdfcfbf8e06ed340161263ded7318d249ecdccb6d32393949a6f5c3fb975fd65a80dee38fe3ff7d6deec1cd7f73aa2b2142db4da9d97ba076577c7b12579c487fbeda86f300432efa2cb942e17883216a06e1056d0fe371b2be0117abe8055333bd1fffb96d91e6d0741060d105f47c553ec75c8d68d6f751477e54f7f7bd62c8b4896e7be59ba68d70eee318ca504d10e152cddec704f7887e333018e70bb017fd5fe4fac393aac6fc39b649e2c9e91cca78c6ba5d8a9797a0e52628803f802b909cd0118abe9156e0d4649f2fabb3deff77032eb2a3150caf0ac265431869957803f39f1d1f2a7a3f15ac2096547a2bbcebb7ba34f0ab84e4b11aee951e8ac4d38fb20c0fec1e9df49a3a2409a3a73a44f7c52aa3dadaba7a7cf2669ca00d20d53683cbfad4be22fbb28ace4fbe8521022115fcd06a7047b028ea54b1c910b30111c4b62d319b58fee5e8277ae6136cf995179741c96450b8107d8d5057364916d4859d6670497298c438e08ad531e3ed0c9439da90de81752cccfc9f3bb7fe6eb88beb17a4e311db8e546f046661994405cee428265aabcceb587a08188462c900be94ff99454122de22686c65a87dae68d5f0c77998ead18482b0f75d15b5c869f9bb82bbf08dca7b8892bb4658017ba5d42bd0f3e637b9a9b24bc89022a569dc7edfff9ad877e9f8f8087103fa16fac5a708b556232a8c7f3f0230c11319a358b2b22ac4c20eb313f544c3c48539fe2f2f9f3be5b447eb2259bea51d14149befad50fa0e3fbeba15a11c10fafe85eccefabb65159ef59bd4562e87450a44b1880872e7721d100ba9db369b0e2e06014721c4882436a0290d1dc96cdba3fbd45a16d6dd2c93bf8ebd96ffdaa800132801c493be3f02d18d69197e76a6b71277fc7dfbbee090cdda3f6a0a8b2349c8fd684fd3c1663aef59003a1b4e01c4984586d0a1d2e98f287fe7c8b2fe71d493ca30ae4b271a2a7be40a364b365d351ab27934174540362abf614a0dea174da50dd1aa66c2fc97ec193d0ad6b4bcdefe96c88d729e83861fd60832af424a2ff49d58d0b4eed8b2ab63788c1fc17157337c1aa7f9930c267ac33443170c9cc80e6898f442e2ed978cb91be8bd77a184a411a949693031cceb9f88e871a137f03d4abda396394d374be15d68efc63515b5bf86c6fa723e8d2e9f5236792d75585c051c2a2eb6a8e7dcb2246311cd827d5603a7ad0d5255987edb7fe47c8b0e38e81c18ec0993b5c1674d4a2d21a6e168c0a6492536c4bd6fb204c53732fdc21a48f32532dc1eb0c210612dc40411e6052eadf353dc525bd4fcf81e3bbda257ce4f29d1faec3ad2953afcabfd124065bb24606445f20c6aed92e675f1347e2a036ed4fbcff8f6505fb563170b67eaa107ae4d0ce5eeac1f563c7834836d5ec1c4130ea6d971bcba8294d466667acb1fa68c0c3e8916792e18e80054e9d4935b0da7d18297f7becfb1250fb77947b0c45fcb46deb86fe25e5d6ad73b83f8203e362396966b5a314ab15eac1ebccece5730165da39cd36a93f5c1187c44f026556596a0d88d03f81fb5329236df53c8f6091fb75e059de542397c2731ab7a899f941fbde24b5250e6da7fde4cde088eb96c79eea4fbc67fb3efbe950e36f062c060f7251e0d6358f1c92475a934dc5cd57fe0da3ea86086fad86247e01a8b066b8d17d0a1404878e887e9d6defcf64ee464f3edf30b10bc394894a7b9ad6d1ca9f80f4ee3ddcd5dbf136cdc42f27f36e22f2eb0b0b0f67d8c227975c7d38e883fff25f8033635e88e0a988507ab005bd5dad5bab4d38bee18a8979d0b53b69ac372dd42d1593ae9a348451bb19ac7ac6b756db3c25ee611594aab045006866cce6f1237b72419013d5d79151db07c91da007c76e320e2f6cc1e8bd361fc0c2d25978b5d3fcc9abce9cfc03e570b7fb37509b8fe3cbbbd2b05306a6e64ca8a754163d32119ed9a1c86c8b7f359d8627712a93ccc33d83c3da3bf96f6acf8f4e40b3d8bfe80d9833655f24a44013a56edb923c531a1d366f3ef46acb85cbb7e038817eac75b951b37f2c41d30f66bb83fde0380e1fed0363b23befbe3953ac777192a6a3ff41592a1614b7833fe61e9bfa9a6e45d8d5bcaa2b095d279b9228ffc36221571143e5db984683e9c10ca9b9799d7799e13b29ac7ab2e4639b06ebbf090087a0b918fd15fb5a7defa87a4f045d712ebfddc57bdc682e5aad7fbb85627f91316dabc868761311158d3cfa4017a3bf180f2de0f7f19a4507fbf166b46510b015d33452a51b589d8ed8729d7e4d007bb5832b6595350554ba8d05baedd1b72307af0883b883e74ced38b968a4c5f72a8a895fd25d9b87642e1de0e5410bd0dd5e8be3a5483272417a235ad7193d126a79a34e7d7005ad39d0cb3b6261817b7ce8b757da555718e7df54d06a2d4e6cf93c71c2b9ade2d3abcdc3e176e96bbbcc315924313b1dac8694ddb13276e5b7ac1cff1eddbf21737c9cba94af2664511e835282c162870591dad52d5d98a5db1befaa269f2027f8d3bfb73e9a56a074f0ef815e6240fc96515a7701a28378a2af9dd794bb3ebeda0a21ba9e94fd451e11c9f10b01d3abc046a0bdac3d794e1b2fb5d7b5f0f0a26f5f279a7bdf14bc256703fd5d54b5ec4c648a54d1f5a694d14f12c7afa522f3fa3aa6dffde1d1ea78cc92f59958533ece0e3d53a7b7efbbb7193b2b1d2b2bb7701f1ba0a99a43abf30fec335db4c03c324c657bd13200cc37b56a16b0a0600fb0ad87819b5327e0d86253c2de4fa1eec1811ed0365a82415125a4f95160e93e6bba3d9aa2ecd7bdaf408116bff2b115751eb812ded0d90f174cf61e54423344754b6f24ac2aa7b4b50d46706d5798c154c23e89e89f825086f497b484deb72ac5366e689c58f2da4e2b67a8806e48a94c7e1ce95b46d00e29dbda6b55c62e1cecd1563b05d1d399ddf391d818c8d5dd63822bbeddc535b67ef2b063d7734110c274252780a90bc8d57d9e8d729a80eeebf7e81278a8c94b1a7993ea64b6ebfa2631c5593e79dd004480674e6b23637d6c421cdc0088095f007519946df3447c88416228908c853c4b3f1cdc5752d7dda9fd29fdb4cbd63c269348b7963ab3684834e4bfd7bc3fcdc330939e894f71ec8f7ce63491488910d27d0d4f2b080b4d00fddaeef2da8088dfa3e8bca477f369ac75e166ffcc179a6829e6361138ecab7ea4c605ea2849f56a75b69bca89586f79cdb909e25be3376001aedf6614b49f78b1562d8da6f7bbd817e591631a298cc6f10ded36884c6d1df323ad5acb4c5393c5501ede0e161a7cfb6aa5104c87dc2afd6aaae960fe6f07336c4b34e127035ec6e2552727c1268e56af1152729519cbe7d5a24190bbc2672c119fd241dad5e6f604beb4d360afe57dea0c85e8317ee09f5f2c3f21a1872cb872aed3570861af922a3cb528b31dba366617a77adca8f090cdb430fb6c1a7072ca16045fccd882696d37f2db492927f0078d1577a199c8efcf152dd5b27ac9816a95313b758ef39999219150d4eafbf2af040d46173cc0babf1029159dad4aeb5453e674dc1084c6cd2615500f853879fe72fbc3fb32134e89f32bb1d55fab52ac36b89ff6be8f8bf1b62033fdf1843a733f2a41336028d40bf145abfcbc7e96a3e6ece0d91538e2f1f4ab70be34b778ccd2621fafe6b1d8e9b356bb7eaf913fa9b6f715f0e0566453687e6480fa6cd7b37c7b0a55a4802ea8f46c33315683f955881c907cd6c08e37d59c27f887d6bbf38eb19c447b2ce31f117d370b1267ab0520f04aec5cd7703e1955c0a50f904c4ad6b2627d5728f0c08e34bf007fdf78c6d8817b6e67c9d703b893b505c5f804ac61c79b0b947458a84c07691e8b155a5d7dbe52e03360dc9b272f7683edfb75a200016f028d3408896964322bd39d62dd3744142205569fa5de39e691f544b87fc605be20a73fe09acf43a2de064dcd1b582bd5a985ec56eb857f415105528ac33ded2cbd5e69d1f94280a1e1e15631de0e834e0210c7ad2e6b2c48351a368578e15b4475acaad04a67e4be9ac64ebe27fe515b76b8c898bad45de37b344a9af1eb06b9dde141adf80efa987efc1e233f94c9f9ad5c638e874ac3f6e1327c0a8a849e50d349e41701e13e60a9de4a665433c84a01bb73b38440d1b7e129632a740fcd9372315196878b737c4b6711a6268a7a379655092abef02266b047cb02d02bc0010b34815b76c1e1e239607dab2cda1be6bd618e975d442762ca152d4c20243e9ff4944bb06229c9b1c9ebf78c07298a4695f090b1015da3b91c01b057e4330f09c76304de3a79ce726826a380016fc5ce99b41ab5eac854350a45fac48914237d780a91732c74a0a5a8391fd1b6dbd1ea68b8ead0440fef027ba8c653722b7b54cfb5df5a527d61810a6adee54ffa9d25c38067494f7e13e3a34a3cdfb26588dc8f71ddd34be7f0a7a67ea3b8879afbb0f2f41706f67c143309a21c3b4a1900e0de3fc8242fa5be1481890d38663544fdc4eb27959c75322a13ad39c8f18650e8df94bdce04ffdd095a747c39268a3fcf63ee80e1bbb31c0d16828ca3b82b17b63001d261911d5e4c00a07efb83a5f38eba6986736241ae29b53b8d139073be4ef8b398c5f151a09cccff7eb6cf029333efefc08a8bb81b8c0114aae13b13a1dfc0ad93d7bea235626f93071cd8114a46ac34ce3a2cdaf6b5cc1b6e1fb6a40d8d2d01da421d425b0ee69513ddb2492657fdf7b44097c507f2ce6fb02e0ed6ed33faccf3b4b68a7a93e03a9569096ec1d1b694c3513d7349bdd6e55260680574512d3ed4564ba4cbd2fb6e291621432d9669a6a3f1ee01c17a7d6ccfc9e9335f7bdb3806c95dfcb784e8f0f452d95fe5c76ea48b88ba636569494bd1385701233bcbcb638cdf6e556e27162de0690b72555906b5443f99b2ab9ca9dd454e110ca6fed1dc4487d5ca567e57b7d81b333763f5d3e6b162fed4b46d719302d1b701d12124d8ba08c9195672956c80cd9ac906b883719a4514fbc04047b4653de50636f2474bb1b28e0894a920236ffa878e9625c08a2bee138736ffc06addb8fe7d2dc2712824fd453ef40cdce244e1e1cabe86f134d5c647ca99a7cfb12dbfe0ff48d1f34d4387584f2e54e1f150f2e443fe37cec8cd6bcc888da0bed56939ddd35b37deb25c6388c0f9b326324c774324f94d4470a713fa9efc44cfc5ec6d488a988f69760548545abef17120dbe5aa5123b8417543d8203986b5569a6edb254f49eff0cb2b243b1b27b5e801a2e1fb1834e59ddbc4903eb43101426f3b1588a093511b916813c9c3def71e4e7a1f06f18cf988ac6dc6e951ad2b9fb2566c7a4a8ec899e709dc22951b3f4daa281d9c51e8b07825da37aed50166c2b771f9d1883c643aab3aeb8549e8ae2576dc0737715aadc0638d3e81fac545bb4ed93d3b900125126234a53a38a8031e1786694034bf894d647dfb7ba7f319fb1149567638f522601cfe4412dbaad54fcbc4613eb6bed72625d6656e574c47575aede4de4dbb6edf5b895a9ce15ff4001a1da30428b485df9b743f41fc58e28755bb9dd1c8a92be3f01038c9f0e32ff76121e9c44d53d95681afe62349c6bf9a70dd687a7db3bd00d21a06133f473c65446d8136ec2c10562ee2105295a0697bc20226c2178db530b635362f095c1d8b0f0c48d0995af2be9dc373e1ad9f57e33f793276f814ae71a2bf6bb13b9befc2024f59d1ec229cdbb9c3e44d9fa29efff5ffbd28aec8de4d7e1731efbf3ff4b2222e8d93d060442b7ab5af66acc20b9b9178dcbf891b05de97f88e963bdc3bb79c1c071068ca0b90be1ad062aca34aae7a961bafe39ad28141d8d27b3eb9810425c64b32d175356f413bf5e4c1e9e264512522b43afb80dfb9d040d847974708c19ecf67b44cc95ad57fe78eafc331aa072790ef3bdd4fbdbef9fe6055cdc4d2749d3648b9c70633cbfc8819e11a6925f53b97d2611efe25d80c7e7cb74868b99393cf21a4ea9af9e5f374797a6079758278cb5fece721469b659fa1986b9b164ecc36012a98ee9fc149b6d3c2ece220416a7c61e89348f172a409e66e786cc5eeab4a7fdff73eec604643f48ebf2dc8c8eae1f734272fefa2cdb990e8139f8f7723484dbed04b11098187aaf7f46a22b94f211768653ca5602ca241f9f3587a77ec0b8b143c2f5c8379c57dd175f32b5d4d0e06dfb0fbac70fb0c5053bb40537efc029e1ce916f5410a5fef16c7dd5c147021e4cabd9ed8b3fbd4ad8f81965e68565a4dfe34cc9a8047458923e0df93028c42126ef827f3c42bab8bb24100e2ce5d7488c9ec09de5f0d1f09de8404ef61f7eb4c6a9f8d13709c45eb040a5a821441a63fa6140947189c8fe80cf6bf004b0f7d8af20941223681684971a38e379ce187019cc5357b0cf39820d508e28cc86168cbd9537eb5a8652ef193ec9f2ec4d8419d63bde7259313ecf2cb48e8d8b45a24ae5f25bff41b5e2bdf9234d4e213ee51c92d3fbc45779af2e79ab88e0a08ed597b7f04322528a4999d88bc056b1a73c2f685b5d4c0e5db136a3001c8d5dbcc22b0e34fe42a8171392d17b76fc5f9b724f95d61cbf26643e63299a3735220b6fecc91506a712d23e5a2973c26cb5340dd0a0f063e3c40bf8a5685f6c430cc259f653de4db0c37ab90046acf4d324a8edc2fef4b231fc08cce41a73374e9c95092e5e22912e3459896d6aa7271088f9e75d2a4719a164d9bc71682fca78ec27d57cb592368f045ea1a26c551e550b45578bccd1a44d5581ba75520261144d5060d3ab813391f847f6504add918c43b633b13b07f07800da24572b7b82da190c2a11c25758206eccba47c6a7c165c5b86af93c0d1e6f982bb4349e906053a60c086a807f60065b7050d6bb2c0ee7ea1b7520e725dbf6d4b97b9905716cf8c614b865b4ddfecf0ba3c646c78b47271da2f366858f9d5cb05c82304759cb8cb90f1ad198388b815e2e94e4cef460e9c7e0cd81e625c1f08754e1b609129a731198138c6012ee598da414cfb3afb665a459e44220c56678bec15305b6689ec7c0e2ce38370ad9a337603b935e7a92f29a3729bf9e0714b26016bd7b9c0ad229d7efc8d4ec3b342b7c8190083e65597689d429972c234360a30d3ed664e66f58dc82108e212ecfa6a491ac9eb1dfb8776f2c4f7b28cc09fc07d9f845092993f7e77ecc544feeae6165790934a3af9686248128485b53cc28e4e91f6a7d320cf969c436b033b2da73bcb0d098b65f1f3f6a3c58492276cafe78461baf0f23554dc8bd9b5e4b3b879f1d20ca3d57dc9a19ad2e9ac8fae6c9b8bb6f5121971823a9fc9962870694aaf687be6ab568b73fa2736a8b60bd5baa87e302af5c9436b0c8cfe6d39a45c565508b9cd3e7c0bd6d9cc77d2afe29c11abeadf1026ad77c9fbb9c1530327e2f8aa01c2099f6f342fc75acad3c075080cee1526f47d40ea7377cf248a9137d5fa44bd2e6695e64ef5e4983a4bffe1187772fc99a5c892e7d0a28081d9b57cd0d025f5d7250e594041b09e3bd06cfd809572c33aaa12c8d7db84edaae51e9cca808845e619eb16c88f8e40bd53b534a991e87a7015eeed8415e03196fe6a8e5960a213d7b1534d8d3ca4ce6becdd6932b61b978d6b49ebbddf1e57889ec025cc750ff0e8addb055b1a420354bb8c1b80b498e8d1401f93e165e0dbe4dd1ac93597d4f99c7bf1ffd49da782deae1fd06d3cf67ed6d36f78398e4a78fc2f048823417cea0b82515caf88c27b4c1a3c73d9d63d9a04e4ce38c858c2cd22498c5434b6e3246f42b0a3407f90cac040fb182be4ed260a384cc8841c9609954a3b33f3f3690be7825d8302eb27d05bde79d446e64d64bfa9939f49e894f2d4a49a72fb6e786b7a564be9769b8984b77d6d72d785985651428dcb247600d5d9438f67fc8f6f38abbb54ee5545294d5edc9c38fd02ee0236beccb23742d86ca8ac6b58cab9c3839265e58f6f28d3ffddb137acade2d88573bca0eba089baa4115d5a600999145ab93aec24e45b6f9c7d944c324317a662e3b468234f721280775fe42817324c05c36d784cab3e44d72cddd940e1a34d8a78a222595f9367176a442a5ca3564fb729ad48584017f1afcd78551a58a9b1964ecd3530ca4a71acd5c8f8c2ef800d44352e659421533c339b790fc1731e27fbf9e7d4dcf8482a0de8cbc30a4f9fc20dd547d221eea7741c4226a6d837fb470df84c56a2a347ce58dc474a3da4e62504ae205af9ffd026bb7e6fdd7c5fc3f64adc75982078861a6c3a2c575f7d60bb350ebe4ef8b9d41e26049e2697f9665db558adc7c5d3c3b2b69e6d88ea07286c3f005280f091fded8b755fb06a635e5ba70617f6003424a05389b6db3e284aa8447737dd7eea2f7f7a7446d760fae6b4ebe0d34c91c11249c3fadc6f34bb708caa1a7278ab8e2dbccb51a61597d1409e43a9bbb3ebec1ae3c508cc71d88dbf7fd1ec3c8caa75f1da1a3bd2c79dcb65520662100b79c15c2d51c5fb8eaaa2fde47119a244cad9d2bcc2462b346bc6dd5b7feff312b98afd74acbce51ef57e159316092619d636c275b8ca83469efa0019be2ab70b2dd01c92bb78da97b528389d3413242c9f848065a3736920da69696d7e688651b4dd6949719b19994415436bc19f6b2f0392aa9fbdb76956d811b2d95e8a96faf83734f0f0bef5bbc8e8c06b02fca2355b7aae97af3c1c94bc1d5d46a4cbdabf2f7ffdd1aa3155a859bdc31b07e5ea4832d1ae9afde58b1b25729b533cea8088bb21457cf6b9dbee05225ac13190efed6465a8b75b0d61095a7eda263cfcc49d762f4351e404bf11aa98b3512037ea7631102505cca62d48172d071187633e1b6f8072191154b8b476ffc092b893c27fa1fa0a5f148cbfcd7f1b069fdd9f575d0fd77a98c08b4f3448ada4e048d9a4d526f51cded49710c248289d489deefe6708587d1c6847e3faa1a9c9c306a3bb8a09d2a21aa16db134ca00dc82f1d36e67895ce12e79a320b7ea92cea33e1013a7cf3604cb92dc0d5a500c70d2c9a0d6f0f30a807daa6db0d9d1a1fdbb7f1eb010253f0610006cda563124679eb5632bdfabc7ea3e0c71f46b22a7923b57d0118a6dd1a460e40d1aa06ae95f82cde79a266018bf75a835eae540d9801bd2a5b4563d7a6b66de5ee8fbfc62104c1fbc2bb309e682ae7049e65c23ce187baf2dc190ce3d6715c03c66ac0536a67e6a6ddaed9f4833b779f83b56386858d2a162ba7e1c4068ecfe7f7cbf161abaab853355cdc2e8d57fe84e0235a24fd2fc181b4af1d40a925f85aa3c7b2cc0e3d37676f8b3a71973ae8a3ddb6b075ca97956fcebbe646dfc158f4e25a55753d02a538fde22d2df38c0316ecf10ff4b4c80dc96024a93c2ef5e8bf083689cbcd2b5913e2a99b4a7610a8aa0485eb75e2caf781c403077db8c3532668778f9fb33583e4b16b2c7e401a1cc3881711a4af4f69b244c1b61cb932acb1d10536cdb900b40c637a10fe64849f045c75c934e94639392848c9124076a926c530add19e78f8fada751ac136ac52687fda55a60fab74fdbb1e3003d1ab065b1ed1ebd9f7d429e2424238586e87315d741385b164b9b92afa87131daa828f7d1d0759671ca6313d39d2bbd379e6560f8b10d7db9c6214b4140d8c654878fdfc3aaa6ecc35110af6128214f416f64f7eea107888aa3497e3e991e0942a002395e59dd13a279e89ddd578a1c4640537a0f04bac8ff4028db5551f0e5345e646d44ae96cf793e68a200c31a0064e013c1dce99dd06c1fe8736dc9cf326e91b63714d9b03f31d7381028310dcb1de629ac7404debfaa21e852b81e31aa0ab9f7ab11288e823721c8d7bdfbf194f8ad88ce72fdce2f83a9214a8b5f94b32211712966a2b7ad8b786ed2d75672f907627f59fa8a1c70afc1e0b683762290bf32abedb23654fba9ba6498e24e92263dcb5b1e2c33d0ec5a12466b63d8cf706ff2ef00b18dcad16ab990fb334cbdb69028d678f194e4142062dd6bf1fd1cf1544efaccf7cdb4179bc97af4391d68bac63c6f4efefad57039bcee5086029d959d1ffafe387618b533bad133e6a24363ace93b5b585a4e5d231e83a45645ad356620a70a3c631966e83b2e241aa32c8ad883b94e5eea9eccf495c318d1db81e1ad4345da552c3a65429bc1f7c303555efadbc9a32969d16d25b3cbc58eb11cfc15665e18caab49a4bdea6cab2121feaae2ddde851a516f8bd83df64e450ad2b9e4a557dabb68d2d286704d66e7d16e25a0101a98c2d3d43dc2631fcc0c8ee553ed5570b5e634f0797c9eb5a903037fae804ce0e0233f9057e3567d81fc3cf00d8691cfbf9e79f82c5ddb2c4714ffb19ade6ca6fe821cd2a62b885004f866547f124388568038749db2ddd363fbdd92dbaa4e27f58a26b6e0500a83a4d3be23afc749e00430ef2dd8162cfe0ce2663e1695c16755feb71cec5a3d13fea01412877a31c62bb3ac930c557b7bf05e5b359b415fb82a1cb10caafacda2676fc9224969546e425abe1e19214aa009ec15ca44a8de6275776871e414ba6af69356d2be97fe33bca99e2f118c544bda153d7cf6e0086c20e3d5dcdddbd5bb91daf86548535b69ebe96bb6d1ef3b8ca64216f17d8e4413a07af48d65515ef96814338905e81de85dfbec239c7018671f84bb83414f90f6b5b1d69881344af7686b5e82bc58bf61ad3f226a0b580d7498338d26ba8cc55a19ab7295976743ed6c4cd869bc1fc7d9f65b1c1f8a1d9492d36b47cc896f7565c429e10b1da587648ff796ea181b1fff6dc1198ec5a32b739b9580bff1c6f281d73890176a68906f8c6fccc555ec7a985d1f0d4059c77ddc498382bf809b8a58800c011703ba39e1e30f6e3f3a9b029d384a6b6176833fc9684305f8353d9afa5f9d185b9ddc6da55368871f3d85d7160ab87dd6fe47cd369be716e376801d0b948d89b117ac607a01ec1807c720776f1546287b6aeb0a212ed3b64e7fd86f0296eea20494539208758d1be10667068310cbb1c14f75e1e3ebc4ad696db97eae4183eccc19fae443530f174fdb87e3042bf7f0500a3b597d1fd097e4c0f46abd03a1d1052a70a5e5155d3ff8733ed67189d17c6e4e3fb66ce6f3416184a3110852eaef9139d3af17972e8e05918fdc950314eb24fc95b6785cd257e08fad0f70cea085dd42fb565c2a0a85bbd15426b51a267f124dcf694aec9de14dc5fdaea3eabf968512ee3073251943c5cadd8b4260dbbc3ac8f24e0609ee1c20883667d56a5582c79578f44a68837b2fbf116a114bb8d7bb1171cad3913bc767d4d865f0229c6233c8828b16cd08fd4b7c1bfafbe3c1fb6062cd0effd67a56decc8d00a91f497d6be094e35dac6a4f1fb2589760e786a6b15ba5a51aa6670ff19e0732c9e6a148ad4456e10bc540ec968a4503dee4240e4357de32ae323ef515e2ab994b50c9ce17f210cb7b328074345de775e85342f860dbd5d2e114200f41153b0a20b877f0e80ef3f83d826b796fff91deef70af90c4fe70e5964340440973273ff433605a5eb76d48df23aeb394c47dbb9d26b8c50824a7ab22a1060d29e3309abc21fb267d8fb516be0ef01bd5bdf70fedccaf5377dc2281158aaf193a994c29aaa7a13720ac7f3bfd8f1f27d3b3b3343d87a3a730a1db292c3175336b7adfd3988c67fcb705334c8035b3afb27f04fbd2b37827385eba24beabcf60fa2427d11717fec879eb25293187ea2c69082e0ff56effc78d519557c153ab24ae3c17f3da99721659e992b3c7ba8fb1ecd144e79014ec78b772ae5ad24c507761b59780fe3f84189fef5f7eaaab2c5b763b7781b8864cb85bb4eae390c949eb3891161de5db06a942f32bae94d54844a410307263e572a9e58f9e9aa2fbbcafb3c3b09f38890ba596b4663528eb89e0c41deb91a65c800d71f77dd6c1307962db4506497fff2d01e38fd068e5c6bad8188552679a1d5c130bf6be12a5b1264b95485ac1778aeb5a332f7b1e299d9568ce325ba25c8e653d673bb69f47b7d5b3ba86d9aa2b62b7a321798ce79a23d176387a157664915e2760699d00a5a52a36cce3fc0caa48876b802c6472c56903f59af11b85d8899727c0cdd4e78150070f4f510ebbc495322790bfdf5a9b6b1ae6955ed1f15bbe7cf2386010c49685971ade0d2304623ad76ef1e7daac1b92bc1049c4d4f325c3ab3d8397385372acc44dac1a871bef6c8466c8eeeb79ae68023970dfedad0c49a8c959c344898276b26d935542be65911c6c60613eb86d4c632c16735617639e03720448080a9010407d134ebf8a22c31aa1a92a6f093a699d33d093512ad20d722a94540338c3e009dcff604b3113ce1d28a0b392126d5a6a1689de3e2a0aff73914044a46573f7d6500e599ffd655c50724f52097c700a464ebf2455c7ba8528514dc80171a523cb903a7d95f6b7589ca3616c77f26dcb16250a47776d97d95c2f38d47c8b8a0de15d9c61db9e0215fb78add1d11f3465d4e87621dc7b04084d1c7057e34dc48fda38349b19c254174a6ad1271ec4bf872b65bc6b3d61770f7eb05b448147891a0c6828c2e82645b085d7a3e71ebd9d77d27aee7080784cc8dee4f606be142f9944b2d3061cfb1320b6bd7bcbfbc5c99cc1473f8f2bb4edf71d1d9767905068bf8cdb06bfbe98f473b2bfc09b99ea5f50e687760535294724aae71ad7a5e895d4e9527e1f281b715f0afad82a8975aa8b1c5599cf43250dbe27c928f2c7df002a8a913b665c155fcc56ccbd486e30b4ba9fa6e8cdd331a0427f5377970dabb308d30217c0381d1d861a46c6aec1b930d1073d5834f4cfcebb6dfc5a2fc330bcfda94d950c5642a5213fda7c3ed618cf6e51dc8182ce5b006acf8442dd6dc9f7421cbf849d5fdb38797c09c5bc644515cbefdc309dbd015e5ed5c8cee72347d5f40fd86bd98b90ea81104f1a5fa5f65cfdfaabb090c889c7f3161af8cd4fdf76f097a80f6c69f017d2d68b0a7f3054d6726045469b8b6cebb913050c9fa2aeab8cc88313344cd028580d0c35019a08a9d929c9198422c40aba71a0ea1386617dfc0ae95348bc6b8b3b6bf753f5bbff8d88aa1f7db266beed7435fdf9cc22a98475eb9fa3bbe1f283d42e5499763f148e037d600af59a4612ff3b11874903b29655b7c6e322778059a665936ca04908d37201ecbec3b9d5abcd8fd9aa70a2149e890f5c140bb5b6e77818718f21d59a37122e550a7f27cadd971928ef104e0e567d424f8acfa14f4c0dfb0a095ef52a943353dbbb3d9c6dc329a8da5b4b1ec67d401b3d976dcaeb8116a3b53ae8e67619238c52358c08560785e9f418f77296753bfaabb3187573e2822a200cdfda2971c9212c8136e2fd66768dcfeee44071ea3f37975d8fefbc20750053f0ae9583d58a322b6a2c2c1d67106b6b3c702917100e8870bb1209f4af3aed3e74ca1e781cf1d224555cec7eb0678562030de48ff639ac6e16bda70f3a3939db99b5756bbf4175517b44991c92d546bdccf054ccefb9cbbe7941a8551e513a388182abdc4c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
