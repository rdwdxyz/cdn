<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81eb9d63d0fa30e46f62af6eaa0c6606ffe167636f7f84b390d11ee29871672ae2bad576781005882c2c45d4ef6e08dab05e44de6ec0bd8f23fde5e06cd54bd98b477e2f6f12187ad843e30cd44884755d76881bcd7060cc0883f37209f86f9d14cdf236fca9f0e945047714fa245451ed7c37d23f34f415040d675239a4a2992135181e7ad8258c12aba649f79f5a19162b07a6087a10a2019e8f9c04eb73a184f05616868aed4e1ff88c00be51be91667399d60969f6b7f331733cb715b044863824585a0a7e131ea92d455d4681e2da4b0f1072ebe05afed32d63e5cbaee0102ec6b0cc30aa13b51637939e225521ad9c866433edb25f11ae9fccc137d550cba72508a3dc7cebdbb2f822e6bb49c9d8bf2368411a3531ab19e8aac9ab5c15ef644e7cfe94a09c33c627b59225bd606dd601d8601d6319cc3e86184308c3a43920eb65d873b1faae9e7b89724fb7524272fa389c0361ece5ab3701692caaf2b50037ea75974a99d07fc32b48e3cd3c519c7a9d3d743fcc2b082238fd510bb81403c29cdcf925f64e8e4c787319aadf218802ae49e9e4ba387315ec7ae218aa68bd61eec8bb835cc211da51c67429ef57d9972f7be6c1f0921bdb364e85f6dc32dde21225eb1e5193bc10fa9d43c46addb0ea63d587a40213baab28c66cd80b8a38502e2ee79d120b6b023023bfbcca964fffd4184dbe1d69316512fdf4827c872e65bf28b822cdd7dc647361f1a9c29500550398ff8e16f00ca481c25335bd9924094040ba924e916e6333b6b63620799a8f765b8442efd0cccd6ccf48d8db13d3b0e77dc5fa4dbb651f52939586b12962615004bff51b2e4000ccbf80f8218110a67dcebc525a9035c0126983aec4fb721624a2067c18a196730a5b5ec48bb3701b807752c5de8f00aa3fdd0cd0541b047646d2a0dde53d9a00c0f8b5af69508c2c6b13973f053033b96838c1758bbb8c2293686d6e572f0d6d30fbc3a228db7d4b63dcbe372d6e5b5ea9b4a07178ed292b463f517ff4d0c960bbfa1ba6982b3768d8a4134f15599e49e78a8483065139337715b4917a2044aeae61b2a675823ae5754f44e0aebba8b9a5bf67e113dd4ae050772d30de0e7897876f2836cc78635588b0c5c365ad374046c1c4bf1c75de5bcd031b7bfcaa04937f2386c227f454e2e3d0e0c948abd1d405fea1b82864f9fc9c2494feadec825842f9cc360a59bf59b1a17e10ea68248e543645d1525d8e6151d283a2f2fc672b01245b65c778b3eca49e94744936b7ed8260e74e8ae790e32ee37c06de173a47ede9216974e688d3e43e7fc4e5d583ea2762a6b65ab17c8de00034896c7587bc29f34293b3527ed27884be98e3abe79ae744e4266b8b0d09e2ade1a6813e21e83e083f2d21108626d33c14a5808558999d232eac6225ae7cf3add40d2deb30182fa8d69e10ec5868a4f9d178523bbab47459b795b7951c28415c8500f81060e9b2e01f7e439b8f386c3241d5bce3d263685410284831edc1cf49f99a97bfd25823b6f9a938074ec5e077bdcb6cea19da6f066ea262f33de88c69297acff1818bec31ea41358e84d65abd70d3e8482d818d0cff7e5c533ca59571829833cd2c7acbc06e95b28c03b89d493cbb7e388626b165e60bd1c70030e2a32fe1afdd11149014d625c7f6ffbd262834d0a8e5478fadc7119ac9645d2515e44d182f0c269967f583e6b2f1b962c935730acc68284fd1ca6a3d01ca5312d776746bd9c5faf2a2c6aee84cfcbc73a1387a5ed54da55a816e00ab8fb32696f82d36cb43bca4bc9afaf7566c5c269920d95b6fa0a407da8073a7ce68bb51a130e51fd8687ffd81017c45f382c558716af4ef1c35ccb5c736ce745d1a68eb69a10550e2da75af4b4eec951529b861104185e0b8ad42684eb921607d518f8fe230e831616ba48c37c48314c86e8d64dbe08a35afc01dadc351fc035e543f2055c75302b15d5e3b4df4ff362e59b414576d5a89ca43eb68ff9f15b13b04e643c3e1e18a510bd46fec1c6d486e528b8d8fa624fd48edec691c0b078889d42a9e7e006995cd327b45a95a8ef14b540d0fcdf9254bd5148ad16d6dec728d7d660103328e99125b73f3c4aa4a6b2baff481d29339f529bc57c53c882926710c836c70be61350e426c63480aa36ed54c96610800a02fd7f3ef512c25f2c4891e5322720d08c74b81d2a5f076a838ba10f8387af34279f7b12eab614d95717171c7e1b02514357c16bb6dd4f162df0d10ecd8d8a8b0696112a53c15891a033d0ee941d8384e6b9b68db5606a56a759f9e6447663dbbcb701f6c5b5218a9b0d704770f32a7d19adb94353eaf69733a5c71a643a4f9b86f4adec4129c082cb21536bce0a22ce54c2e204775af2da05d69af6190752ad2749df36a5a31f2b5fdcaeaa4bc97a476bb1c68a76828d93c4c8f2e8ecaa7c3f1d47bf4bf6932a611224e3b5945f90713ad722896bf76d21f4ff59e9a2c211f30cd0dbafdc0542d12ff5b96f75c457c2fcc6970e1e5a49b69556b54814a59a4348dd2f26216c55091d477a3ce948f1faa4a0416eb9db01d8c08c331e7250ee05e40796d664f1642625f6d47816a726bff31a13f9d38e43c74ea3062e46495fb045e9a2456183d23ef58b6b4549b37436d65ba0b2c72cf2db1ba85e6b47fd5e270bc712e7a9c2630118af927bb24d76492a54bdf1ab001575b38a97a09b18f9577534f22da4bfe668315740079e84ffde3b3d1a4cd7a82740b9b6cdc4f0b3e290a2c4e25d7d2adfbca848b1b97033ce672dae559c93ec4ec673ee16ee9697fa11f3798b32c7a928c159bbfd6773f3b08c04dabe177fad16aa390a1a19ac1dd28fd4a6d161508678666d3c592aaac259b7a3c2086e244ffc4b800190fb528793c84a7fed5d996aee6314872c29f3bf1ed9823c044c6409162d84f91f209d9c5f0434187afc04490ffafcd6799eecb5ddb8c6eee999ddcc26751eb9c9c1eca38272ab9e38f35ff8b9c159542125370fe2d0ca050f7be5fa5189c245562c752222b30e2e56ef09b797084b5b66e7863bfa412b6b53b08b04674ab286c301be0285ca6cd36196ed172207bd01d806530ba0c2578d8650b769fdc14b3a1a94c71f692f47ebd0535e9999542655f1a7712cd32e51a31a073e76cf026376de154d3306621568fdab3989bbd2b6613cdeaeeac92eeff59cbb6fe721bdcf3dd6d2f5fe752b948ddc76ac56466b05ac06f44da4419a2881fb5ce9f3c3c415ccd101412b268852d3b6a9c763dbf8b14f8326e9282d2a12ad62d72d532ddc38f1a993a0ce8a5a698ed0a917690abc33402f7ca996c3a8e70648771440c6f8c95b46ba0a12660c2dcee0ad3b94f18421062e38c87d60310580217608e2007b7aa0040135244918a6e3b392f020f1dc16c6baa91a31c0148311f800ccb068778c3f950d6953a8288341524e9e1780164f5f372e15301c06360f4398960736d7a4a1da6e0c390e7425b215f7af93ea15236dbc7e3f0692ab45b253a4a3484caaa95c227abbcb0aa5ed8eb9ae39b3e4976c2e907b77d63d6ada63740541a8bd275d8fe65b2ea6479cc32f4c042ac13f3d98741aaa34731aa4ba99439926829694729bc4c3445f0b63f0c217982215029b3633b24e8f217a02876352adb1cfb8dff396b04df5ac47b9ba230706f97f6f5f6da430c787ec2ea2029ea1926aef87c1d4d0d9961b7749ac4c3c6d22edbcc137f5af594504da2ecd257554ca466130a57f0f2f3da65d90a800491a6dea1d68eef81ad2682f7f4684fa196f210dcce298da1c068a15c83a4f90edd728bc4988418df6d05d9cba2d0e370d6f563be9fd9397b8ec9084a491aa1351b3f23777f8031a55c8e92ef398b75a065e5ba0787cf1fb8dba223448c2802812195995100cbf71adb14db396234aae3c37c95f05cca927044215974709d0865eff92e02822c343c82847ec4517079e33e2007b4d93bf2df5c964c99c5148aa8c79d18781494baaf4aaaf3f44299940938490ba5f2fff4e527120207d1fd92d165ed5862a3e252d2ec8d2be714aa68c8b994ba015941f20451d6f7a9ec9d287654736d8191d367580c5d4f9c209a055ef012b740c42a9e12eb6d0555e69dba31a4df4a7a4c4e4e63db6fcd1cc3c9a322d84532d6704c0b23702a2748d37b7d6c2199536c7fb19e5f27a2a2b0566c9c5cfee5d56063f996a4bcea8c9ea6d1349b3213674bb4621f8dfcc61797ae3da740650c96b2709ba0593bbc5bdf97ad94871c096a9213ac9c9a47ead789e2c4987fb57b745726de4fd535355708bcb5770d614583296d167b83faaa6371ba11d33011580cad00dfdacc1a0e97c69efe2a66cd5542727a2cca495f846b1b8f88a6348bcdae6b1f4dd4310bf91a2b6568de20c9b1ccabca4644d17eedbc08dbcf092ba5fb578d8d2802710827c71f71fd98d42516abf1b21ce8c0b5ae8795fd028d212df234a9cd40cc41e73b79f07ee19b6ef71c52ceffb34d269796517a019e6773974736cc5daeffe0fdc18648ee17117f8460e55b35ed27143af38020741865f979cd07df29ae087acc3cd1deca12c200e4478c6302e5781e67ba98f7896e052731754ec5a1f22cc826529b78c1202ba06ae8676df19b5894d724c06c6abb95d22438d8c97c199ce46da9a3cf042baf48bc00de48255645e4f89bd54f7ebd4a229f11b89e3c485d51c7f66fe4ce14646af4cdacbc4a27e64cd6ebe108adb5bd6ca8478cc961d23465f5cc258d15649cc42c317ce87989afffe4c03b0d68f49c3bb1a96d381b1b87480e8b5771a46b9e3045cbb7374d0ae74cc5c586c0a5411fa80a16c7e0df0d180076484399e86856149290f556603d9b986eb5a46b12946208c079284e5634e9ac0012e38105c6f80778a80e44797a9d9a97abed5066a702575f77355c1c25ea1475f72466fba2a8897cd423df6a8918a1bd2252706407e8b688b5a663d146c383c5aa6461403cf25ec58443d4ab62aafe5b6ae8150d94a6ad991d5cd88395135dbf53de14cc55bf5f3790752021e246a1b8fb5445a965ec66c854a6d5fdd0c11712aa3557b99e7c587d4ed0a86f6203a7a18eac6c27514eafcdc1e1f01cfc09b549bd5e8071d635533b858627bc2eef89d08817b590e523137782c6aa135cffbe08acdb305f7a441f345e1cd033179d1088eb8fefa8444ebe45c54793ddac25af80251637c48d21ebccde477a69dec185cf60f09e134a5c4948c77e5f09f70ae77d463675d690db522b5e4579ae6fb1811858cc38e46291ca1f49c54bbeac6d8442c1875a1f077db032023fe13f55397e81f867558592da5c058095c23b159f0275ef7a3460ae252eedd17c30573ed27520f7df5a4cd8bdaaf2ce554d15691d11c1bf4b8c57a2837f5409748e23fe26a9258c5e27afd0b790d92cd49ce257dc502de3d33ccebc2b1107bb7e1731294167a1b3c43def5bcc55431cabcbdc20a161d924a4ad98e01d29e93c8f4ece44431495001fc78369ef2b8bfdbe9926acd9a77283e56a34e28eefcfb9bf16aad9588fd8c5eca37d556aa98f251be95510f225bb17b725cd0740cea90217c2102ee825afdd245a846be4cbece6faa1d0369b50711fc5b856b35ca69705e8b3a79a2f954da5555dd1b4f630e8c0942950855b16d2b06a531532f49eaf30b19f44708c2dbe330de77e94f72b6512578057ee76abb1e93716566805bfb1c177e81a39b6a0c6ce35aa9779147bdc48ed2b1686423bc7393a9d524aa570e8b48dbaccd04b83fa5586e8b7bde7b9cfd9af5ae2bd2685068ac10033eac7561a928589b2b3df594cc489154261bda9ce2fba249185521941edc71766bc31aecbc44f223f857a4cd03100833c34585b10aab8472cd8a9571b07a8693278c9456a24224f22d9661f074c6ccb421f4bd3c79607e7fcb8ecbd34a6bc6fcb153064497193a608417593d387743867fe2c4dff781a387c6e22377bd185b96a0e0e576d7894280b60fa11423bffa8ef50434b536533af0e264ce2f1534a5a14a7e3b5eb79c03724cc2fe5315c20ea92b24971f229e596cf6f32b463ef11b52ae027c412742a27c7107be0ffd57d87feae82d8b507dcdd555f3ed54d435b6514cb8e0177d9090e41e8e95c27aee120746ac05ca062095cd0134075839072076a2205c93302fa503364eee8ef9a041bc03197b6dbbe605db7ae210823f54e23b0f7ebb2f3985589680d39294527af6024d777bb398f16d902a55976438c2f96af68c5a9676932e9c9204d20dc29939219941488c8d437421cf4ac38893b91c50d693d4731cc90a9f7da3354bc07b1244d46743f47c546e77c5f62456d0ca4c1c6ebccdfced0486b677fa54a0091dec36ae9e2441522da58b3318ccfda6ed451335d08fbac5d7fed64b19383f0e47ecdd8993fa26ed7fe75028b9afb706b68b2692b26b39a60f3d438eb94c907a96e0f566691ecc697ad46519fb2bc64db8ab95226656985fbf812c48266ee1c1fbbc26fb55778a7dfd306a5826a5d5e1b081f87bc116cdaabef0464c0e42e704fba0f400be1a0f173904336409639a362039718d4bfe982b7ebd1a361ec6dbd30abc102ed6f84c7c7e9134aa7cc98c14c1223a0437113e73768b6f5c5de4cdc31143eef497062ce8a0ee6e09d653d0492fab4a2033af3fae2ecfebd4af0ba2fb629a8993099933ed0efc4fdb97976aea22cd830f29a7570ca4827ab428775ad1eb88d67d08121e00ac39d671becc4e1a640229f4f178c526ec1b475d13d06a85856bc449508db2c9aa2709923621fb8a584a36f2aeb6200a5280090a5e9d9e3788548c12a5e349792044be7c8e7e495882f7bb9009510e1a6ffbc15ac56bc99a4f2dad20d274de2e56d1959131d783f7e8d51f42e3c595bc9a2df8cf45ba822889c64799dc205611f5a4749b5973c17f8a543fdbd763408947b5ba71f5072a11cd77e8ecd120267c30acdd53c61fa552349eae21c508c9946dc77d1e7037f2f1095b7983d24d1b1ca96c4a0508aab1a1c3e1ebc7043be3ba2d1818546faf3d112b5b7ce7e7a9869d36f87d7371043fd246a7293c57c2e5626d5a977227d12c322eeeb45f8443fea48667d2bc9b1139c25de25682bebf9f0df5e7dcefb5f6ecd4d790a5f1748b29c3381879f98f5ae39782985e8ec4f795350fa5d497aca8aaf3054e315272a5adfd013b70f84f88f47109740057358c99c8adfc3296d06d716afd2adf2736e45c37c7ed72b1a462088d85a50302b3a6a3ac5be3d2b4a6dd8c2c359cc3bf445b02e0528a42510f4a52334da368adb04e2f8deaead00b18997f6df9c829345545715542dd96b05e0133dd546e377437a1a16fe2df3021bbbe5cf4397f8fc05aab8a63aa6bf0f1bb017b5cd4ab3af1a01d5fa862467aabd8ff87eef7e8bf6ac4afdca7c0f5a44a0bf0b719794ef558a8f2415cec823876244be57e0e7a01f9ef9fc5419219b79a7a46296cd7de7afa7faa0f4810955fc473e69ece03ac9bea12d107805ac06cab4efe19f0b86ffd4f76c2db16bcc25cf570c32ce22888bb6c4adde0f4065d43c250a678f1a42c9c239677ffa60c30b2f7d51a585f4aa5b50e4c85fb4f6df9b618655cac13e986b62570eb09e881e9bb04791990a33fa1176b5da34ae1ca19013b92a481e65fec8e8b63eb73e247f1b780530a370880260e9cc4e4a3084c8de5d5655ae3a97764f0f22eb85bb4c47b2529e32532f181642fdbd54ee08e77044c4c903f32000860dacd6dfa53f96a2b95766b37ab08152cf934823fe1d677ec8243936edf8ff959297bcf3ebd34da2bf25fc7f62301e5778feb704c48968a91398acaddd27e03b3c9b48c0796ebd23e32c3b541dea0b02a3efa85442768a8e1d814124dbd2a640b2b8f2cface4d464d12b93bce677fa518bc7abec918a407808771f0cf3ebe42ad33d913048d925653245c4a485ff09e58e31d12621082315e65b14d745fab160d4b129d2b891262ae730d0484a64a37295bf7bfe48fc1eb98069dfc8db983ecbd48f1c25eee4633ebd313019235f56fdbbf882e5f1da6377360a71c85192f5afbe90e60d48baf5a87bc7ec01ca22621b65796c09898b0cde34bb0b1822260bccb01f427decc9d9a3bda80b77e2938df19bf3db6756d29466a34a88cb5e156cf5ff470ae22dc3e8d2c2f2a7b2e2400613cfafadede3ffbdc19f36c5f1138d1659dab16b113fd7b5507908b1c9364192bb88072fc23be9d59d83a7340ae3dcf9d15e64da318adc693b678757344be25d46b5dd2404a52f94f88beee6068698c9b30838ffae57c516d15565c6bcd861f320b2a9443c8a6afc601c6092ea520aae7646d8f873f064941c1038e1b88b3f6318755f1cdc9cbf1679cf0e479745d2de9f82115e2675b553d576af88c2ff9e7c0fe8225978840e1ce8e840b37351f827618f5dcd86e49009540ad2a94a928b1309d7ee8769680df9b8806eb01646ca47c5a51bf7c66cbc252fdbd4118f1876a742ddead01efb7998d1e866cecd68a55701baa98205e08cf0dc388731369e984bae329e14f293cfd6021354696dc5b7d58bfe86cbf0f7c2186bc17125e8be701b726912beb0a61182f7357ed26922db11a1694230887ade88478a3fdec38c829873893427cd5204457f4ef833a2e0f816668146dadf062729c1aa4cfdb87e68658a6624a9467a94b149402254dbe88eafa7a30ebde6084c47a8f56b263287ad034c35221187bff515086ce6dc32d53961a718c97746a7f05672920ed7b632c70afb99d5aa49290bf1aa92ba4b8a217d71b6f6fe6059e0f107fafa076233ab653f3970e20d8d2a123dc01fb62eb8d6f5e0d342ef7842294191fe166800f40b63ebe8471fcb88b038d6441541a0dd3ce9d6cf10e1518bedb350e4f4ffaac9136e96d732afb4c7acc42caffd34f589a476fef2b4564e51ac335b91297cd1bd9779221e84d51be9d03fe88e36887bbfd5adf756a1ab27fca7e4c87d1659e4dfe58dde25fcecee3d3d5a19046d75a99de56af2782a6142631f141cc02ca1184ae13dc5d5ef2f5b27365ab9be21b4a52339b29364d33a0330096f4a50d860e3b021703dc9d921ab7b0b0c26decb7cd11e1d0e1ed959faa5fb1ba2b7d84c5d0ca937ddbf59c32864ff2f2cec4df3cc89b35ae3bac43fe5f0cebf394a19ee756aae92c766207402e6ecdce05af47d9feb7859f1d787dbec0f6f8a10bebc12896afd4c1b305237ed6aa939ce131101469c8f02ccd46043ba46dc76c33ff6c36b00bc1de06ced8a30eab6b6145f537c50709a69aa2b800d7f67fa5d4e103a630c4ceb219d2c1dfff383dc4b74d37bc784fa274d424a08a715fa436075df4d349712c8659f80a13c18865fc6ab91bf25479ef8118121c73146d41397ad1074b095e36d140d46d3daa6ece408d640adb02ff46f36f416356ef2c726b005e4ddce819754aca08eced7b9bc097d89f4a5a0f5a9cfa5f0caa0fec68ee7d4d70731e21330f20754435a18db8070bd1454f033d0821457a55a50baab54377b52a585e25736613bbff55609669ba4409d6c62c00419e96dbb16326815ce5879688132f0c726723160565ee4b5f72b922fb61d2454b1f1e0bd5829f6134971d873dafd59e54090c1bd061e4ef65f843913f7367d2389e8b6f675d825acd3b4c4bef57b1bd1d548c94ee29727430d7f33085411fce8c4ab50b304924458bd1c721d7a7209fe18e2ba37a595e850fe585740a483b1105a1f8be5d2f49fff4411c5f22ff1501863730dd6508d8d1490045299852b3acd437b25dc05bb95cb02692fd95bbda90217441e8559505cb5bf22ba59af90fd4b7b04ac84b398e68dbcdc4b96d8457cb87f1078e2dd13ee17ae120ca001ba5cc0deb88bd4b558903345f1ca141b0f93e05ec11db9e4fb840edc09d9ca5215bf88c9264bd672bdc93ed45c90fe0801a6226aeba00738e46ed1b34cb4d87e671a603e3106d84489ad4011bbecc0a04f896e1bef03ec63271dd11fc3984b14675045888a6e49694ff31f5e1a993cb4162a44d656e0c3e925c26df2e5162102700d82c1fff9b549b2b8801cb87fce30c3bdb1ce7e5bb79931006e97d3b31b3de27fd5e014f93def2127f6a530b76e955889858af67df364440288e9f3f62292113c2d15deb5cb347453b03346da2402771ed542e73eed0ee75ace84ef3ddf5c4f8846d57b513708a680da3971b7bafa5879bf924c879b5e532fae3343edb86664eab30147db5148132f74320265d829b611ae05eac322597b8fde9c0e4746ed9028554d4957f350fd8f0df4de97a172b63768ca1f3810103d9ae64ea629aab695be7635063fc52464f681dc84e42e832842646423b2e5733cd0db2193e3c00f1b53d64d96351c634602c3f0eb9d9fd3bd7bc05c9dd43cf208b191feabef0485ac1cafca6f5a3b4f4d128b10eccef0eb3af5873c2530581922114d087202904194e4f1b65783dc9c85f9e7e2c4f373700813af0fedce5ca4cb9e58f1ee8d2d220ebf54d91d0724e210b9c9d83af60408ef50ac77626b3adf9e3932cbba0861c6dd6ef31b6864b219d7e517a466da770de736af0514e5137499314cfaffdacde1bf3ba21dae4cf6e4174918d9d89f9556980d79c16a1902c71795b4e430a4fa5ec193c51b50f7175bf0a60f6ddf9022258efeaf36984c1870994dc033f853b08f42942cce23360d26eac7c29e77c04ab0c1fdecb8dcfd64c997e9f5bd1b8c3a72247423d504b2a7b10a2a5eaf89b4ac8908b1ef1ad04dcf83d9479454fc80e30bf95239cb26d03afbf21b4a7606c7e399856c63df830b814b48cad111c09233c5f5de52b7a143329f5c7ee3a74296ecbedc39dcf8996f163212f9a8adab51ae9d40aca756b0f80eb32ad4272dca75f6cf794fbe9d6a0ca7cfe9a8832ca0f55974e5b3be05185953a82be9192903d5bbb6ee323b978ddce987efe8c67707bf20bb4528cc966278ce10b485a9f57ecfac6f90e37a0b85aff8c52e1ef3cdf81deaec7a602609e80929263b56c904a12877a4aede780d9de646a54b159da831c27a46742c05bf54e74260d37f85bed67e7f7eff644f2adc48d6e72fa3430789c78d76108495748c8de71b716e05a4156c3f73acab0865dc23baf5dd44641a290c812b1452a8e5a9a12b5ac60ea1092d07dae003cae1e21eb113817ed990fdea45404cf5a9977ba4c2630030e896007c6957b8feb4b3fe012c79a9bc23d127daad64e8b332cd43d7952bcf7ee8096088b6387d43b2d8bc4b3f44f4d77a104ca680e4f8e831bcc49915dcaf215f2806d385c05705cecb7c8542e3ac3d5735ac259f0c3131e6b95a05801625b0b518b78e1a5c746ae8b730de2a55b0eb7d6108f24b9abf57bc6e862471fe99ee58ebad638607d3eedb10334c12ba548f5055767c8d46f07af2f1a68a49a47a65d354a030b44700b3682323ea43e1b845e0a0cb295ebd87adc413065f3a01a1d46c3bf3864a066d4a0f0e0731e1d9f8139c38d9eefd4a7644c47dcaa4095d4d91e234ea0cada527aa0d94a8b660b65fc86d43f5b8de3fa39edb5ea9ddf53ce1afbec83bad4610bdb00f68275c2591543929d38d03f6a94629d135f8fe9c8a93af39b7b7bf5b03f4835eb9ecc1e7c7247be588c1b3e196c414c86144536efb13dab1e86818f55ad68f4e36c8b50e4304c551b382e9c9374def3bcb5787ca83a562f66e17e09abf31d34461446074a91946b218079ac1d8cf7b27bddd89b0f60c53abc1931754e009548e7b50551284059d4403aa1749dd7d146f535cd474ffce86e98ef960b9f7f3ff577fc94364347d12e6a154d82520dcaf8ffbb955708ca8c8612c2aa71f0919eb87bf8eb90274bbda228af4688d9868a4fb5197dc4cee053b2eeba293ee8af8d6a1e966fabcf14956c5b98ecb989b4762ce4563b5611e72c1b1599c48bca5e8db9fde9a53a8332b4d2bde0579ae6fc038184e8d2f899a28a5867c56a25a1466ce1d8d043b9b4e242574d12255eb4a15db877a611e226f5328735e9705372029a9b4c8f9f254d5e770a2284da7168045ed1b836fddce793d42e59d4beec185292569ad22163ffb2b928c5d760dd622620aa323a5030f66aed9d2a45f4b6cda4741f0c7c7f503be318ba393af0c6e846c1fbf76abe033ed271dc206106988073281305ae9256ffc784957d581a163887c7476823a74a024216e2472506560b937da4d328993802c2a3e874e79e769924222f6975201550abfe90f201a84af81bf15248eaef0d9fe4ca1e0341f2069fbf3e1b254067b11a5b8d3ced01d61fc53f99beab010e5fb8e9e337ba35c0ee93697665a5b2cd4371ad531cd0eb0aec1f498ed72e019aff24c0bc261c75b63bddc35080eeb81292de199d0098dd4f46f964429ce5f5096f0aefc5d806b40ffed9fa128d8606ef32efa14d640882c2c8e5012e75ff7a826bda194b1cf800dcd53194b94f49bf8d472d83ef843acd906d6636a2a7acb13e54169f23b71e317b733f66fe4df69fa98c1ed89c05e9afb143b8a5f185d2040ba8227b179f4e5b72096fc5af457d09602a1672a8224c8bd8a3a04d72282a80846308d6263ca3da0c808bc1e4917c1763061f561f8e01b964589db7b07c600f3a44282d4daaa6af602884e714fc867cec041fb18789aaf41fbdbe15f384e6199f1048c3ab8341bad1ec8d43da6e6b457d04986623afce11efe489ff24e3966f2553c2dcf34891fbd83e54c6de8ee6cc4902a11bdbcdea530f2aedd4a5a23279241d35f1b09ecaa92bb5056ba0851753ed91062730d63add9fbc8c359a96761a4bf013a6b5234b1736cbf6eaf27032b6b76591ba6b1249f92a19061473b3a6e34cf1c178b33de9071ea4afe37cd3dc2a9f24f2d8aed9a9d12fed9191ac4e391180bcc2349eb89fb29f7c3296e2a1744b059b162efe8657047f6f5f3581657f04df571460d0742180bd9c215c833944afdff784435aaafdbb2b33d3cb78f58132cfa29b44ce6ae1117dde2b25748ab3e976d06b6823cd6cb1585bcb7c7839b4d77c0d0b996635b511b765b9318c8e04016d30ae3d8b744bd80d4c8fd90820bcd57e2b9637f382fd796a18fc0a81e4204aab5cdc8c0ab0952b8a341da706b8a1f18268ca79d27ae7f853ddbe2eb59e72cb985af71ba4214e06bd452d02c66b5d806d294da3719bbb109099d6834c265dcf06b70bf4b1f3c88b3bf485249480623d1675b2b2b1bf19ae2e26a6328587dab5123ad4cffd88510b9db3d0e947ab88285fa770c890213715610fdef848caa956bf5f449e4850727c566bd640174d53d6e676a75590d6cc1ad9e2445ab300a2b2edd8da0d3bc26ef39a0a2df754e5e8536b4983ae3d08c9c6d263f41cf692b6097387c44359f14b48cf7c81ff9f58c21e81b6759391701c539caa4d90dffbc92141efa035048ba01d4e356eed7e479698534deaba5e350ed20d9a2b61f80ddb75686d9f2e4db69e7d558a04e0f33f49e82d23f56ed2e6ec29e0610fd191d5ac3b5a91f253a4847735c85a8a780547f2db10be51ce3ee544afa14c545db791ebf4ca8d9e228f2c31c5ed49facefc967ce3c71868dd6374bfc0c3ca025f3301cd23949118615ff22e270b51eb1d583a506b690b7b419da10f7e9e18ca644b599643a16c2836a0aa4874888530337aecd68c6916b510ae3136953b8a5d6558b1abd133560c3aacdb94c2e10b5c1420cd073e34e11370af24fb58359a0cb5ed0e42fb5c21385ac218e67db4869d5dce2aa0a8169378242d337e925b1cd84c3a5817988a34c8f25bbba7ae8778b1c72cbb07ed1bdad9021258434e252a59d6c05b4d5a114950f5168b3871ce367b19662a525b374d99222894bd5c262a322b07081a503b91da17abf95567f3fe458b0820b291ed4c17d3749213b7fcb0673af5a5ffc424cd7ac59628f652324bdacdb60ba71465b8b5ab5c3298b38aee065c6c1a6d1f1b7ec6171fa4943e3fa9bc9683ee11d7468028f130e171bb8a65f648fdbacff33da7e006f3d9bf6e95ca2055519ed48fe12a86af61e318f1baf0dafa5962d056dd1e57fef91571240042848480ccfab2f75aaabe5cb24b387daf98e014d3fba58231e94c36fa48961f57942f2309a06311b9efdddb2179633bdc39ce97540dde0306dda5991f5687ba05f9ddec660b1c0e33656a548f894a374c2b016cfca015521745c66ff584f0a190af34ea3ca0b84d0ccc24f1fb6c0d5326f1c3d4b58cffd560eb8eed3ea4a800539337959aaec5ce7f67aa027594ae391c782605999e27554942beb09e49ab3940f9910b27dda092bea86d1c067fcccb2454f563503f577cac8bdadeea2fa96bcf055e1b6644df383af8861e110678ca070e22dbf6676f405096ae32681f33867a343a7745d4122497377731ee5bdd1360cda3c37d45426d05e75e8c4af66c578700c294a573533183edf06055ab83b7812deab2db205915636c2ac0a00260d4c1990fe6844618ac30a8943a2acc9eb2e2b853daa9253e3bbc162d3a8b48b7a9238f75a06e7b8f906fe8ec4ee1002cb222023937486afeb66a59de1f013be2e3b2fc94da0622f8938396159ff599e8e3945890eaede977e1e4f80995c72ad93ac8216d9837db9b44ef36bbafeb72d8ecfd8577bc169ebfe1da9858e503baebe32e133fad47ac5355b714415dcfa449c26cb1b713236109ecbfe4e91a805f6778945b9324c79d0acadb90f4cbce3447237583e10711a75945ee24b1af58117bea4a5d5c3ccf18d27d5160a8828f620389d8c8a0ac321d3c333dc85b2643dac5f3ca48da0de578afe26861127ca061fe823c3b879cf421357d57d71165017f1d0b409345cd436530d8301345e6991d5ad5c77c0de5d18f4b974bb57e38492bab7ad84d6a3414818d053ff235d8524c22c168cbcbabdaeca96ebe6dc817ef1869b845d9b0e9bd174f4d239b94be5e9aefb6239151f5412993abeb46b661d5e7953a389d816cb273c13a053192693df96bcfc4570ed9079bffabd7cbed5b5a1aea60fcb8eddb35b8eba22ed7ac46ca66b873ca4cfdcd9087689404de375d611c3936bdf6a7042fb762bc94cc11f3139639dc4ba70fe6429d3940481c92b43545c2e978c095b031e61ab95d7d0daa3871749fd029165363c91a30968135c59c2e0bda59e6d38b680b607908f1f600640bcc61b9aacaf37b71452a14d1bf941e96a31f2c5653941ae84a6e9e606aee4cdaa858da40503038d5b0e56108b9cb8a8db2698c29fba0a4e5f0871d94e1d87b1d95d8e003fdc80f8d3f2687ac1501188f8739929624524c09fb96d5bd3cb818db910bd7a7276032b9d00baf19b7b1425fbe2882e4a82fb1bbfd25f9aed07e15d33ac41a7eec54c8740a244da05603e1b957795378b9c98a5132eb226f7b5e5785188ce2093b628d10126c5ec0c3c9ac69aeb6777018c0e9b05ea2a5791edba3ab74b5d6c38d09bbcb64b0ee025875947edbbd95d2e2ae8d2b2a3ee672ed10b1968ca25e93bdd1b7afcd0cb1d3a96a90f6628aa2d4326b32bcfb524f056721b842854f02f390d7e4fc95f456b12d27c055dfa5719d7096cb7cfd4e6ed2ab9b282c481e03ce88340769d0ef8fe259e06525a5f63d03f39735bb95d0beaae1186588e12f3dc80fc7ba93174670d63bb4a3c2f54097044f3cc7a0c79e97fe50d332b4a53e022e89dccd46f297445aae660635eb2606498a1d56863e850d378e6ef540c66e87e6d530d2bd84c46496ae86a6df1b11e339040bf07e51021ead161fc3969fe4fc970afb1a5d4c9eee4a09db62141dce9add07fabebd0d806ad806716ad1dec707f69bcbb1c49b1a8ed01396b2efb9b5f5c32d747a66b594e0c9422da25bf8fd59201094f91c959add11d62612c64e46a7ff6962fcd0c0c48532d023a0e3f2863127e061212dafe3ed3e787175b33b6fa058d68beaac3dcd8e28382fb5fc1fd2622b380bd6b259ee9fb67175af7e8a0565ca444fb4d861a5726fb185e86d0e568c37b6d17b64650ea3bed2430e68327e5c7ceef7d9858710711f8195be2d122c73859b0c3a2cb19305f042a8561b4dcfe0860b4830e3d82b9e79ca263a4130fbea9d6f13ce9b3c8b5e54f582df374a89724eb00ade61e88e9daca4fb552d9889b7bc2344af7fe87989a4a2e41ac3e0f3fc816b0b383b2768afea5f4436805759e34efe5713b42be5b28d24923e4268034e23f72fe2daf4fefd1ba4480a867cb85014ec67cd9fbdb565e7d2221e2bf1e80fcfca8564543aae3fd06dadca2b25fecad71e6a9277bdf5397ae128928f94272157827d38f90a5e7e40f4bf8aaf5ddf353c99757f918fafb0f82af6b299a8a70c932710aa301fa99a10c3b4103c1ceaab3ead5ae0569ac37839baac37f19fb829a7421b46b03f8a8a9b68d22c3cc894adafcefa383f5238a628435d9cfc4c2ab697f69d5287ef7a76fd2cb7dff92ce0870d6919a65bae6705521846347bdfae03c087aba9cf255da5eacf3b54d148f5acaa5ef07cf0aa28eabe9f2de9b91cc642e200dc97570e800139b87df8dba7c04fd34c3f6ef1b91cd0e24dfb20908e8ad483b9ba4e60ee62e16dee45371519ff30eef520b075ee3a1bedee1b6cf07d253abfa31a15059b7056b6ba51aa7bc18a5ac26a0b87277684716efedf0b5f84d435e0f45649cff5c6f873e3d4786ec1e79cc3554a26d492e7ce663dd036075ff1e43e95c711e0aeb4aff6eee10cf212656c7d51a978634686cd29dc14a87646b2c52416b372334b93edf85e328000d8386471a70ec2689789e6bcd0ca6116baf6d3360003b415e596c4a444bfe284c40282303472c2cc235adf1fef87f4df1a5fcf913eb22101f0f7e78fb470f50e5a5e01549463f29978c8c5c4f20e05ffda0a765245de28a5db214cbe265440fd05efd91df691385292dd477c6fd345ac4ea246478e84dfd75aee21b653c0e155e37c4edaac9fb34a67d8bcad3f22d19bb0efba32871c42a54c445a1a59b59b605af0379f2da53cbf8688e13b290e1d8969a421a0eb96db83df120e2213dffab1907abc0ccb99635a945c241f01ac2acf1fd3a1f3102b12237179db2d307f0c7b612d0b8236402ae97fd3fd5734d6d737b91821ca1566358a34d8c836a504e4353d5248c8f42fd3061084a9b4f0d965b5d65e6aa57309757bdc693c69504fb77fe10c860eef4670b6412c697bee10f3217e3c4582a0c94dd082ddbbd3c3df26e5cb5c601db2e2e1c871dd2dfb28436b90bb5d87c7f4e104f0b4286042edab812666eb8178a6328ffa5655515221f4beefa62e988ef8d01ec442095cdf1d8c57cd2eab93f3a5e51950d504de63afb6b5a214cbd3c919b2a6326333801a5a268741b05f356f7fe4d2ce9bf40e58e0c669fb25c8aac915deca7c33a0d31d95cdb92dd0c3db7ef3d0c0a56e60dea553a38f1436ac3c7f05f1b7600a58fc4a6472d190a26cd99a256fda2f098ce623a61844d9a1f749eed19f6280e4c17c46f5e041336c5e75359861578afe24b0da3fbb8a7784089dc59ae9f5787e70d855bd7e14c719f213c284ba71ec8299a53b38e3ac9fc2cc4ed2c4a898b5dfcd523fa90bbfd9a7fd1501f35f1593bb513573f6b579a226186c2b4a369ce221573c85a38309720c5e60d245a8a9ac29cf659bd241d9915ffab35445d63d40ed9c1bb429a38a781dc8cff3b9b62abd054965c3749dcb8de57016146c2690bfb68c357f2a9c6ae329c2b7213abc510f352c14745648f75671d5b43b1a16f4dc2c2f5ec21ff6507f2bd210c5a82a35d63b4b2cc02aeb01942276eb7c51540a3e089909506adb10f387dfcb5ccb06d5198494a5b23488d46c02a1d7415624bf978b18b9b5681f80c7b51cc502a15b3cd9e37f6b7546bb8cc3d35a0663fc3438d5eb15e9e988a78dcc1d0c7c8753bf1b212fbad95145f72cbef84b226c70c6060126fac95bdbad18595ec63e6bbded1b8d90ddee3dc1aaae0ad1816a330bf917abc81ceb682bbe214a4781c0194e0722a017ed8199705cac32fbc0345f6b4a3708d5f062cdb465b3ae642028f4f7fec0ee63eb2c83259","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
