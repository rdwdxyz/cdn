<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ea18ba49a4d33955711b497c1e5d43e0e209a9a334a3567ae1a28ae7b88abd4f340b25fa6ca1cbfd1ee8f77c4661079fb5dd94d8fbdd4d6d662a9addb6c80c3de52edaf69553c58921316da53780db37bd19870c8739787e8ef31ed6b8ace2bf9a3ffb254dbd9d720341142df6d12984a9ff8cf8aa3d3f458ae9b2d3b3d2710b098bff8896bb1520a136164137f860a25f0e82590bf0ea60a776e5041591d5d2e1dd9f983054f96a6271b4bf1b3646d7a3b6a41fc3af9b9d9cc596c1f4cf0b6b10f0ca98e52bfb75925c9f0d2636dd86e6779741265e3afa4f0ff38785da1da070ea0b6dc61a86fb83cf94352ff619de320b02b21204b104db3808f71d4bd3db183caae8951547931f80fa71214fa4f8f09ba23c78a74c045ecbaecdd05dae8a3827001232278c08ba9f26df6e2265e6cc1e74fe98713d88a7ad2d9cb26ba6b817f949741660a306b4f72c75e466676a73fc2436654a3b54635cf03764ee32194fd6a0dcddef5690c7df03cf125b2791bae0cc220916396351dea388526073c82762dfea1868dd08e875bdf4881fc54bf241c50e73e00865d850f9977ed95e590d65156fcbd4f3fef3f6333960ad15b3b482ca51242d8525f8e1f026b7264c3743428ee1d8eaa9bea88f57fefb2e9235d4119d868f74ec535c62b1c90937729573c861be7a25f2eab7bcea4d0d56107345d8b50c82f968bce8b175a9827c8690956e9ea59786940ff3ca090ec70bda593e1b1f7fd5f1c3b9a7b26aabddeaccb4124f8d40b7dbe47d711ed896ea14024bf93ca0b5dc96fea54d847c22a2ab4dd954278b54a46deeb45e972650143335f1dcfa6fded5ca04720cc75eae065f51bc94e1e04f4b6f52ea2106f28d2a14fb0b31570141508fd0cdd5983c5bef3baf412fa8282d2d121d54b7bf76ee9718b14adb88e82898938a588597846b651b4ded564239df0f072847be4412925055869dda7d86ee3cd0b3eb4086b7e78ce16a835ae329583b2cb23dad1186af7e86090ef8471e5908e5881688dc6dae90e8cd79d613d5aeed3e25bee01b00a49db15bbc395c9f7f827460bbacc3d26d1a38c460d71ac137bcabd3f3dfc198241bef04d72338244d7ae2b5ac2c40cd6be1d81f047950ab02a7e6660dfa94344b8c7982657b3062e6c688788f29bcaa3e9a9b8dca502fa051e9cad7ded0d224ef5cbea29415ebe2d76c3730c455b707514fec5f8526c4e576f7b84dba935bebdb93f292e41331b363b523cd65f25af0921ccd0d172fefa539d9710597d5a73cf83ee19e7c2f28c5b73c6387264929663408f312c57cdc0668c29d8adb5cb28c782034f90eb9ff032649f84e79c4d587f3eccc23fe52239f743b2a9617c3c044d059260093c0c3b0e4d8225d5f9a588ac272fac24f737c9d27877340c869e6e45dcf5b77837ebe2aa8e1a9da9fdfa195374eb3d93e7177f2d2f4dadda92d17d8a416f8f8bfa99a32ab773d16592e4bd69a718c604ac8d14c0012e81d7083b46b2fdbc385157459c976495782e9921b6ae75293a8d91c619d2529adc3c40952a8d3e1377ce95c701e076d226d465f09dce5ebf3710674266befe618594da426c4be1657cdc74dfd8f14440bfd9f667027e74c383bcef187f996b696377fa86cfe1e0ffc8caaf2e2a6f77b767700efea491c9945cd880eaa47d140d0379489fb7310c859ab2662272e11de015f5d68ea219aff703c4bc147694a9f87e78c4f96a3cbead70bf67ce094d8d7a505bfc21104bc355ff25e8bc4c88ce5a9c9e5b6313f936059cd52fa2aaac53f577579590cad34120d055b298b5d2b30fa10d850c63f85fd9dc462c17c0b3d51ccc5e5ec7fcc4bd0f10275801b7114deb7c771cf8307d53880400c3309b7105170764f65f9c5717151de8be060d0c580d7b8b7038a90bbf35fe2de6aa8c8c5f164d1c8ade237483784b5c0a2496cc807f0c2a9e075e15a747840a2981ee59616b1459199a9e6b5c74151a1ed10956a8cfc05f931b11a09e22a43d148f30647a3d1e332049734e1dfd44687985ab42b417a273e6301234ebd33859e8c0107bf0f18e4d3d35cf2bba6c45296f11d320816d222c2c3b2a72cc6e297a261ee07c50be27dcb97cef008190a96cb1c12cf2fc8ed5d2a6b46faac1f57136697d49ffc6f232669b785862ddf31b271406394ae8adb9dbe298de16d7597a2a12b919508da223ee60062ece6276774515a32e2d14009f6308f83f8e2816a3be89d4394349b578f431d77f588f0576de10aa3a592cfc73574e62c887fc2943b30a508c249e1d32f35e0bb169e82102f6785c0d2c4a8ba43d32a0f597e8e5f8c4cc1abec85dff8653c969aff2acac95fe984fc680d103fdd80e2b245a2bc959e793131d69a359da8e0c005807d75016f0f3f4bf79b635d8d4fcf3171393b3fe86c6d416ad4bcaeda376f9af372052565d0a358a632e278a7ea05b0aa904252faa1a1a2c09f2c7078b6ad75be7456dd49d26679b298a246e13cdcf94fd3b80c7ad4ee6dd6badf4f7f14f9e6b88258d8c3ad7bb59c3b9bde0d7ef0ad55100069be1472ae4e0803d5b0b94d8b2c3db73193403ea9a11f499423d361d243a9cc257542d5aa3828b01babb97758d28cc64ee5dbf4dd24f3293c7a5448d925a162b960d7c2f20ef96c0384fffb06792eb54ddcae98edcd7f79c776c2ee046b0ce26b439dbfa9b9691df9a88a10e3a710f19d20ade5af4abfb6f4a522bb944ce353c3c76d01b57e6b800aed0b0e9678aa0544b16613981eafc0b1033d10d76eee5a2e042dc870d1ab092a370c48c1d66ef587b1505c21a0a57b84446bccf3880a7547ca13b9ef7d5067b69df345a4541259ac4f25e0a7327564562fc4ce5e761768e071bb25587edd0a032f84b67a7a08378d4d00e42f949bd56e5cad634a6fe429899c46a053d927407f9cd3e11855cb35cf54e69c17cf8884efc7887a1acc6b6fd1068ed0885f8bf9f10506a0cb599730cc3a0c31ae5f545c205380f802b5b6f690676e9cd5c76734e1ad731d5c06866460254c3941e2c4782cea9103e65122916b3140ac61065f250ed794b0109eaaeb3041290fade280cc40fa3f6ba4dd3eeaee5c30ba85fc6376540a5b91752937d703ed5990ba7222176876caaea769a6967a4468bb4731654704c2ca42be0940dbf657f5820b908d87ea0cf32407542a2e40b6bcf732f9d567dadcf361ff1138227ddd49080de6aa38bd3cfe570daa920fecb45bf8f7b05cb979249b7bef69a49585dfea37d0ea5077c750a1b59d1554d7f56d01d4878d7f8be19b419a175e2c2679afe2c9fc82467e46db356f49062bd321b38056ed2647e6c146e0243308f82009a98133d026fecab20b6cfc1e5c16dd62fb0da9d3d92229475f7bfc6bb867042ad9db15e2afd79286da0e5a15eb13f9bca344682536b3179716b834213eee1d4e3eff45e128101621e4425b66ce485c1b62f940e3e8c386d17ef574c339368fbd85b8d4809f0875fa54ab0b45cbdbe99febe35880bd12b4c538b8f37bd55c23e948e3330cffccb1a30dc317bcac1d9ab14ecc16220423fd60c9eb2ec4cd30e52b7b74d6a30cdd7335722a65c5d632222fabf6545b68cde7bd05464a3dfdef2655d8b62943d2289e3b5044a874947fe3ee35961aca33228bd31c2cadc54005fe5fa7b8936ca837491f2ea4e44705ec92a14bd724d01d6698359e2264ba9815a7d5a7ed24f16a9984ee176f8807f72bd24a1e11917648dc5473e412976d980b7a3313b4541a91af93511ed6b52686a66fa37a70a377c8da6d88f0460e95be45b12dd44db621f2e538be6ab12e7778d4a0eaffceaa1d65b233e16eb90ac8e26bc0e45c6391526e5cad447001219ca155dda7aba69fb275266b49bbec5380225e1ff7abfbfb3e252d21359098b3d68c61190ff53a6537bd1e0d49c7b6dadeedce4953537fcdf802f260ae41a0313b956bf8cb4bfd5b28d00609333e946a0d892f0cc8df7a659764cb7c851ab8ca0c7311aab38b20af9718cef41e33944557cc592dbe7bbdfedc68b5a2f1064ea85af4b1847524f5b1dcd5de0bab9c0d14bbed8890cf9cff5d39f57ce2f4add8bcf0ba9e5f7482582fb66d739984a7174853835b3f8f196b84f97fc039a035ada15092ae4ddc07a286d576ab1a5bb8a239db83cc0149313480c80d6a309395f0c261caa24ee04f46ed1b892907cdefe1eef37ae4550def85eb5ee2528fb45d953168d11ce569515fb63fc8641c21f80ea5ef14f06b18fdf50b9989aec4774940df1863507a0323adf72d77c4274d40c8e6c44448b3b58ca38dde6cdc531eb17b15412b087f58c60c9f83a8605e77ce7f26d9c10839b307ff90dec4ace543d60b9de6997a400c1e428a316d70d228eba87db5a7908086e2c1855cc6c34cc0b9c64d484afb646a2f8620a0f62486c4211f0bfa56f71d7d635976a50fa84cf7197b495bdca955afac888625fbfdcbe184ffbef7b7a08560fa307d442f4cf910863d670552c2390be4625f2260b9f5ae1580115bcd4bec5842968ce1f81a072bdb600b4844114791b53082286ca883bea2f2ae08c622c014d95de4d0b8e426f69038e525f398747411cb58722a3e79a9f9bd22f60cb9ecc5f71dd4cef45c00bd7b5e4d70de768f9bbfd5055b129c29e9ee015b828756e39a3a8149faad7f44b57f2b932795deed14430bf46c8783f7fd4ccc9e5c67ef4a853a4f8a71a7beebaa3a2a22cbf340db23f4312fda989e5c85297f4cbc0386b8176c83c3d2b0f226ccd2c91c9d4b1d0e98f8ba73133eedb97ea26f36138ea1219d36404c823e2f769854fa76eff1ed58759e0894851a92fb87967f996ca922b65e96b71effba3b8433e6f630ea1d04f728299595eb8f0d2b99a81c2b15401f489060d21532fe6d5681a1101738a2f6bb9af2d7ca9e6bd214d4dd495a3cefdd4578b16d1fd8b0ba83dd2c74c7af66a97ad3d3000ab4b58606175a9d7586f93a83ac30cf8ab3b336913f2bda98fb96b6213d047fc25b9ddece99a1b368b58c2d474e4ce96508658a89049f5a50104f1efc0cd7aeee284fcd49e34caf6c42492a754f87a15d5761d8b2661aa7c32b8e12dbadec7f44181231d789606016535222fb51ea2df1ff2f57fa4faa0f4558ee9099651878841fa56f2ab0ccee4cb82f6a363c553a7c3b1ab295b4f70cdc6b90b7939da6943efb129cc996ca5ef909e4a430541917c011751ebcc8ccc105cf3257ab631c84397d6f509441535b507e6c4fab720e1a6140a7dcb1a3cd5407297b03737b6cc686a2cc724d3d499769e4a67ed30587ba3957a34c5f1757daa2cd146c2140b99b573eb5051c5db5cf00d14b360554a129b8bb16b5e1efd603995d7a1d0197f8a5219eb96d6fe042c6ec3486fc7e295e1d537e9558d2aa50bda80db6957c05e06b54722e7b53b2d0af535d592dbcd00c79614ab5c4b53c3bef4650ffe376e1f422569a133ec38137e9073d992fc335ae6ccda9219db396ca691146c38baae36df48f5d5fd517aded98dde85090457c488d1836b3c285748f1ce837e30793d7d63caecf0f806f4bf3de61325c0fb43feb0fd392aa9c5abbe563215abab8d4217cc80e6b15e684cffc43694138534e20bafa370795cd75082538c1b92aa59a2af7678fcf1963c46acc61476b5417a638a827cf361935a6892856454714dd79bdf6a417b55795dc2a43e6df3a3301e9b58b576e3669d129436801397e038c1d26310e365cc3c8b24c348ee699204b156b4bf6bd9975da275a14ce4e784fe048a084ad6bf62189553555fb33a5b06be8ef040c1a72b84ef0268c69f846a21453d057a7f4b20f766333af60cda5fa886711b7de3a38ae9b331bc9861c3858d5415d098c5a1e3631b4540152f9ef8d67b236817d53f6a7b58a1150b4263ddffa513af4d8089a0b88bdfeb4bd8d56f61d3d3db3ef5c404acb77a0dde67e575e84232a3c04b929675fe8454942ad0b218915f52c40db9928b42154d0cb0336c9760c0a7b7d0e99dfdc78f91e3ef34553a967ee9e60491d6a705268d740efeb8d5b808bae5ac83dd55eb48bd5a5e4f9a86da109a3e26cfc5e69c2c1da8fd0bad72dbc74b8359e284a7d9451cc42bd082128b7863585929b8fab34262fa7d0bf49ac61711a7e1dd1f6d08419d555487c14d9c2fe2749e46b925bf3965f09578adbdf55d16c98f0c7cbaa66aef405bb5463631c8384e002f5139bb1f1a0b68749f27c3dcff62f813734fd75917e3f5fdc378ff3d5b9b4b22a3e2dcaf9594c045f71c3146b61b54812e5e8a941bb739ebd9a0a00d0772161085ad269bf620906abd4ae0b21a4c65432a0aa3d90409c96cbbeecc330aeda70f6d9489e5fd3a9a7c53650021d04ad7fb8d488271627bac02d704950813c32dc8eb6b4cb55a20fc9961f4eba91adc6883f5f32b94116e25809cf77a7da5dbb06663f46dee4bd7dc5299c42e93391e32a828b147d95fe0cff315eb6e374f8ce650cf90239e831c157ae0e6f2189b5d8aad96e86566126ae56e245360cb8a4e794c8e066ab48f612c7609fce8b98a971b6d178899ac3077f7bb09551f2079b214d043feeb92158839ef5ede4c674ad6851e8bbc896e555c1fc66d679177036492b0e10c884cd48ee0040e32231d21939e8fbc2d52da1403f4f6dbb3a8522d7ab4753a2eb14ba811162b941057918e2640a3c0baa8b99e86c87e80108adc1d3a65f2509b3c5bb226e2d8ae770dab9ef627c65f305fb944269711ac384a48f6710da50354445d01c16dc8c64a5e5c15d7605ea78050463d8be2b075b0c3eac6b57163213b4d7f98d39c790079bdbbe4e626ba51a1f1e999c34e4dc529989d27e47cf56220c1d3334c37373ce0af5b9df27bf00abae601a5bf88ed9c1c9f6096c83b20361aebab7471458408ea598ddbdf90d739f26a736018e591849e229a6012325e6ecb3e338c43a789a75f1db3c154ca0a5322258e139d5fcbb6352d22c896a562309f22d429632e03d172ca79b168658be681961e728c57c5b3fc05e095224d7c0929e5419af284591550074fce17bb3af94e4338817734eaba841b8fd5540eec8cd5d33f99bafff5d789a9b5918011ecab5de690a97e1f563ea6e0514767d1f20807bc85504a80fa576fa02122e8d40260ab2bbc96484078eaab9fb8689d61c8491e5404c6c3188058dcc1c522f53c0da71732054c7a863a45029f3c2f7d59a882a7bbe2fae6d89b11cabbf17879d261d2675b76a3de42b179af280f21100c55d131a1f5d4f0e3da1e66acd79e71b809b1a07699a35ffcc5b45dde16facbd342a55d9985b95dcf22b91c92ddac0a6f53065ee7a4c04bcd1ae24fe7777e9e32357fa377a92a1502068189e529164c6d3be09ec4728a3a8f3f0f9eb19803df946cdd273f16d8b43bf7ec2e6f11fcc0bfc3a13f3b186bee31c35d45db8a5e46cedabdc13dec67b47610f1739edac6d6691f703cfd431e4aeed9ebae2ceed5984192c75c8a5612b4f227bf0277df6318fa45f07db3375132607caf33b334d4ba839acb9dbfe6498c411f44f9d3027e4770b7ceec69ebec6f67c1d59548d7e7e53276f4b9b9bbb21dcec714fcea76b86c735f45be47b725014a585b491cc907ae153bbac61f25ab03a9bf6f8d5c80904ae360b031a4d0ef7fc6cf1c6db5c686d4280045675b9299bc54073e56fd667df5a7bec679acd141eb5ced818e2e47228fc8648cd13b907a6ef418519979c273614dcb9ae12f63bcecd3ab997cf6906b08c3d1b89fef41b16fde9b312ae75e46f97e7c92c1b7cdd269528c7ed6003241bd70c96ae02cc8f7876cecf7b465e353271f27ca303b774d70c2a57ae3954d6e3667b2b5239d57180f1de4fd494e8ee0c90702f6c9f939b27a526ce8eb49446cf6fcca4cc6f3ff7524cc2de2fa3bfc4601637ef59c67635f691368d53aa14516c8f152ceef43f2cf1785a09d3401fb0ae1ce945c0f00e5162844c91b29893a79020ac2595d660750614ed779d7afbc4cf77b03def702ae69c43939dd291b663c7eb30c9f2a1647758eb8715c3d39b8f2d2da17e0972e29d38aed5ccf3258a8b1cad97e4bbda4cc02b5c4675471d2273be8fe3257ca6494e3efee82c192623cecd4ec4bfdedefcfd57fca0fa742ff73de69afa85d69df2c51bbb4c8fccd16dd5a825b298b97956de7959172a28ea6bb51f371a2e9b3a045ab5efd94086a0218f8042e947a87718b50fcc5b24ded8b8275e447a2e39c031a7facd98ff6a9bee50316e2f3bb5148b6c1c35d3bcbe14a790479741c0fe2d1e67c39004fa0f68fdafd789148e39a12dcf423c9d4500908f54714472257020e0c74da6fbf67de1bccfc5968e92c3387791158d454f84a9b9cd2522812a0ad7c8135df62d2ca1ff7f956478c1d995d6db279b9c31750647638793e902b0555d080ddea13fbe3b250f17923557d60e59ab5fd0e69916c6543300c1edd1a67475e704b84dd079feabf24400898087dcbff2eefa843c7004d4e9b7aeaf46c16b18928998572b7d590e2a1d710c63ed4f6acd877024a60a59345806bb2d21543ac2f6338ee386a66d610d23be6d5ac78a2c58789824a55e772f3d169f43ab01020fcc9cfbb70363e793fd8fc521d9fe27ee666188d863f42285052f24cc04bd38cd6bb587e759f1df9ed9ef0cd4fa51ec5d1b45b549a6016de9ccea2e00c9f960f872eb9576a948215aa43d7569eea7a34197951f94e23447931656fd09970d5e098d7ee307753ff214e87316a043cfb8736b9f3018c4e4a530cb4a4e43c2dbbfb44eb61b2a68d9d148a1bd3f0cbff305e0f7c016aa8d7098eb1e4d3dfa2d03b2446cd7c7119612c2d26ce56692ea85042ba38aacd6c04812b0d0c1f9f685d6de5c3a3b29d3e113a192e3efeab7aabf949253004e6c73fdc64e9a005ab4def8effc1019748fb1ff3a15514dae5807a801c12fa3d4dd1b02c3602cf5f03ce160c7424b7e1d7076e53e0c393b672459a06bee02e50999484280b2eba12b5f460cf3c44d961a8a6889ac3223cefc89834b09663ff14720a741ac239bed522f009c3875939604de2f88fc8a16d8fe0031ff48268f447c3f973a3c85857d44588a24673b214bd2aea3c46e5c568e78294caa2892e73b88f5493e500395dcb96a4fc859219beea09bf172db3801c3f1abfb20267ac1705dbc37ce100c67ad0adede4c99019de4ff2ef4742050f9839ec01cc0786c87de2cb666919dbe29d1eb8b404d56d5debe4269f9ae4d5251f1a4b002c8138fc009ebad8d607b29a2e29079b3115f3f5f870766b22cbc08d94c17435d839d6c6227a702a1bee5ea5afffed7f8f1b7434c30539c2dd2d78ce5f19d697d4e510e2eca92705fd75cea7a63bceb804a4839ef444c1b45a330850e34aeb724bf62912e8912720516ea0617e8c369dbbdeaa940e4292ae4da1f12bc8438ce863e5fba35963b0e8795af5d587424ef52628d0e3757610fa017b7a559f428290063e7d1e98305f7d9fc70fec297c649bee41e6bde69c7d0e5ebd05b1420df1b56add079ca379086aecca110724c8ea91ccd4f4a0fd161cee455ffdab3bf38a83f521bb807272f7d92ba2272bf1b6a0938658f6750d3ce3c5529213744390a1ed9bd4cfeec6ad5bf6b88c3710fdf0060849a75aa248d392577ede52b63b14a63b1c896b15fcf242dbc455faf52b318d21a45e3fb1464cfed57625660a6191894be2a7d1f9a628d61ab54bc0b57111593cd437d429f15618fc19f453457edb7346aa6b85fe71bc5597235f06fc6969a0502ae9828bbb943c18ca118819d408f25540dc069048de3b862687f2a41d9ccfcca77abc709ca723d3dc18cf90ac70e34972e9e653c500d3dbc464da98e60f3545e6a1a5a89cb5f6952939e7273c6d0b372a10244c5f458e72321ad7c7840377b258cc7f9449e707a18252e4093ce675f794310dabe77baa12d0aae738dad5c0a41ed91b946eff152379e13d1c9c492d7b32ecef3e5ff994ea425f5622bb63902b655e275d48f1b496d43a3992a84add8666428b1416a6fcbb9bfc76cf614fcd527a06474922662e026a79adc5c54829469721c73a9a82d455ec08e005b5486fdb5cb0a35c280a4c5fbcd3cafa04227ee60e47d605cccce9a976f29f2e9796ba09a5f66d6913e89f45c90927b859f3cf117814167922ba07edb2fd1749d6791c8c15eaf40f5604d8884e1e7d326edd4e7465663b5b3ee7cfaa63bc5b9d4345b1141051c1bd469620046a9274666563be2d10b4de97175a867a2b7fc9a5b9a88e0d54293d28786eed3ddd0f3a34340484a165ef3261961443fdd220b646bc3a10d4f2241bc48f35d283a22248fe0fc29db6f3d836972a8220ea3e7f5afecf2b2bd674d510619f4c35c51cbe2abdbfd5ae1994cd4d795d9e4bafc4737ae9d6f8da4936b88026ae22ea1db0e41a5f2085561aaea568a7714e711b20810e24ddf698fc43f52d77498a83ed69a73d935892ba8ed06184df9c875e25acbfd3d01c743527994bb762404c2534a7635f4eac21c19f40e895ef1cb510412219334ed90b68151482b94e3511e9ea5bd627aa0d78b523ce6fbff79ce2254a2483fadc43898dcc59441e270f635f8638f3a06f8c9023e87c2a40e745d5d1460a294b2e93fcc4cdd43e4f91ab3e4d5380388c404a20d9ef0134f368136bab8118cd8537781e5a1b4bde61f1fee4654452535428bf645b2dab1feb4ee12cf0fa6dc62971eb6f0b78c8c9da5810736dad536db580fc92a27ed8062db19fbb460d156a6d180d2284d19f84a73f1003f93c4b0895e178c0becbf92f0255fe4da89e7802e7e397d665e46277c42542e62897a84160fafaf7b678759b45c04c20b78d93a115abe24d870efbb0b8fcff5f3ca3a507e44b943cb0d00dc4b4eb9e9456d85b2083f4385ea502b6d2784aea8cc5f96c13301ed8da397d9d546c5b233ec864c20e782027bbbdc433f999033149a58de8c62cef5dd4c02ac0f18a8c3aa7917bbbf36e90ab2e4a59ed4733f53867b6d66c31ba203caad856647e01a41039182952d64c8c2d300602e8edd15ae6428e343650ffd6c2177d0ae97c1ed880b15600f739ad06c685645b9a7b8d55a431c5bcf4ba607fbf324ab5fd87777a6094ed7093bf55474ba34dd07e71c009d00e99a9ad55dbf9a8b58755bb9392a8c7e460a9ef0a4100efa76af893e0756f009d61a5775e6e633026ee380bf641532d24efb12f560c313caaab3ff52807df99bdce258ebe11ccdaf7ec339453f48ab55c6b1a8e9686c7adb5c117cce397f117f5af337b1f15b5e74babc98025c7d1f26a41a000dafe90560b8adff3af30218e35bf76b077b2a0ccc0733c03314d80f4080c9c0ee06037f9bd794ba180e427c9e5f05f6d9004512596e75e6fc48786513299d2f4d53e754d21056c023622d56c40b8b26311c48508c0aa4288d12bdca60643482baf6a98bb8412428626d22b97b100562969426c950cb9fe334cfdd87de9f253c4208211174d1c201eeb7fb456980d206e303cd2c1881f7aa7248b67b60a4bf507d7327585c4226cb88340899c2e1e16e376ca3b8531b8f5dad4c3bd270d8f722ddb9c48d45b6896d154a12265b5669f98d4d827e789fc75e730bc0893a14c93e0f7b988b1197a3b3dcc96c369172ddd323e06607ec3c4330e2c88ac9b6de539fc21dc920cd141aaa496e51be44218e13856ce70b1f5b58057cd534b80960976d245dfc2c3db91936f136985c774b75341ffd5f7fcd90a1f74980314d98bab589415baa60d772af9f840d8fcc5ff913f0843338c863bd915be0a66fa87052a3acb96268455e94701a0fb7ad459fc39b8dc5608c63969bca9d45672707d95ebc95235f78f4a0efd1e055168ec2380bd714d1a48fe027d940211ff2cb5de7d49c3de08c0a1814eb1f3e8268c2bfea19d4d8620ced7b26c8a5afdd0cb261ecf287688c3222c0468b338b0cc5c86b836c971474d65a782a1aec07ab8cffb3acc96956754ebf751ca3e9f7d447c08c0e47454e2d901ea8a3c8820a25cd737554f8a9d497e4af228791b8896780ee02d216ee9be64edf6fd4c15002f78c2d38073c9905a72df388d78fdd4e6f431a23586d18bd4c8e8ec9ccb258a5fb3862b76d08616aebee8aafd7d6e73e6a53441144079939b846a02b81f4e845a073cf94b1ec7940b6115a3823a7e6c51b3294bdce8b769f28b9e82418f7cce69e3444c2348d1eaf157e6d7a39273f7cd806244a1b8bf56b7fc0fafb0e08ce85da243fa4ba6f5453933477067b73a9eebe7e21f55c2150e9a427576306b2971e19a6e463395b2b8cdf2f18e2e103d568b4c6fa720c1a8a39c659f5b3ebfa24da0ac07a69270f2d793c1bb5d6b8226297ccc0ce73ac71f777edd25965136fbf218f75958630bb35727747bea035a14ea3df0ded3719eb8e0e130df94f596b2dab1e86073960919db332e1f07310da3ba65abc28085f0a90b161bed9aace45700b94f87eea88777555b0f31edac4b210f822c4b200f0fcdc12a2a4bd1c0c3716603c9e5424caac3d5cfd0c9e4ea762242b2c4981acb9f98c060893cc42c8d6f947918b077864c725fa75803b634578fd4808f9f34224cc6c10b26d2a248ae6fca4fa28886874e1e4f800a7652a79630720e81aebcea07d932c048bcec74ac26f789be8812289b3c85233f1e6f0c37d6eeb2e4610e7dbd33f2cfaa2aad809f6037d761989e5b26f8f086a4cc6fa8fdd5486dc8e3ac4082efc2a0ead807c326f7c12f7c28ca30514259b4ad5934a5055a51f662ccb89d28707c6ac67f38c0f2943dee81324ffc1382ee39cfa13d0c7e500e227fe0acfcdb3f975ef23321c8d9b45c94a7782a382860d1367523ce403e535a78fde8c42140c0615b073fe54211175da7e290f0bc2fe6e747b3dfaafa6a784500ef2f4aed59bc0cf2acc0193e46c7d80f2a23f06e2338414e43c35bb32e023ceeed044258f4c4b2a02e255a2eb6a601c34ad3527c59566883cabaef11ec1f77cc80c2441357780149e7e4a48992ab3ff529807686b8877183584bc6c078997734243ddddf1d26acc8551e396aa4baa5e4acae52a3a00f80a5e0370cf400e89b54ae774b7a66c3718f54542fdf3102590988a23e360860e7d683a1427a4583303d3f56a05ff05c2f7d5dddb801e70ced64c668401eb2fe7b3f1735137c066c1c271ffbe26033551200c3c6138bfb6625d2405c16d5a967363701d234133e7266e4cadffe52b9c37c47bcfc9be3ff7dce6201146087db8e1674da4e6aac82449d3783dcc8dc607a956d35283829d6b86dd827a0a745245b89282b5b2995315a007b65ed79610e00d3585f7e6496edd8238226bb7f7c9e78d4e64c98707d68872ce72c3993f7a7d93338f8b386df5c9c9f23cdb080fe89888f188693d95523e8758d36cf19b42e3df7fcb5243720fc6632557169176f6a620b5c27620cfeb937b8fd1092a6027d1cea9f45ce7289e1f7e45ef7b3d5c44667f4673af84760d68b6518469e328508d338753eac259a95f0a5393ed714ae163624cfd40999b22754c936f6e13a2d5ec880227413389ec687eead9bd2243ae8a59fb28ea48ae5b5661690211be070be75222d6f4998b5bdb9693cc77e9e50e2714a7ae7b58dd7a7d330bcb7a0ccb637f813869e1bfb50638499a8a4c7f713524518345c2a1a32abc0e610d0ad474ff8f0c67cf07764a26c12c64f591b4e2ea0d83b767fda87c8cbd8c3afd691cf5ee7b273daa8fe72039bc2c013787cb6024e36d11bab07df2602e97473dc46bf7a86aa6c95f00ffc722266dfd5b43a242a74d57c0ed5defb61180a9760e053b60e1ec3d992b4dd630f19070c7344578bc0c4ef1b7aefc7bd235d4f7f4294569cd468bd5eea4d408ddccc5f1d1f8b4f2b4d3c86fb89c641aa37b966e222d5eadeff874a643e3431cf9d30c0a8db0d896fbd6d3458c7ea2400c19a7889cc678ab6b2b0422f1a415f0d9182238f8dcb6fa5594213f4beb1a886a01d8f22b52a94322692e9fee129f7a248a6c70748eba8fcbd88673bbb0ed23a71bacb65fb3eea6898a7389f7403b8e05898654b88c67d02a090c9494c7e521f307c42f477271c8f82306c45041b0025f6044f691b749fe97623141938271a2fd86232e7536f5c8af5b645c6008fbba44eb8a40adefff2fe884ab3fd0bed49f47deed98b033207bbf3410a087959993106aa8a5c89c4b072e63aede7040a578b7b7e16a9f341ec9952ad4ecb7cb565d08fa0432731d35ed7a83eccb676da886508dee63432e81f91078325682047a5eeb2b467e11fc723f21159f3b4315d5ecefa8e7c4e8ddd714f25659923871d879d2ffb11a060bcf1fa11cac5d952c959dca2a09b143b779e099dbaf8262a3280a304e9d3101f7ff9e0929928f2b56993c80cc1c700b6b415930846e9e99f0629dd985041d6a1acef64369dbe60e20e6226b946785cc7b1e99361e2b48ed2562027366f11b7d7f55511e6787529221631ed6dc3b2a145a68b645999d862ec718bf9308c4300b01280541320e554c9420347979f7642a9a16e9de13fccb3aea4a58fc25f9fa22dfa4837db63f79aa908d6a94b57d8269c4c9235fb86e93a3b7cbbc73be897f8f6b63fa47707108b3204f4e954da8294a6affa761bee4cae6edb0ad54f25759bbfa9828620259ea3c670a57b7b151b6194f04f4acf6344508200095f596ef5a93d532473c338e498a35643594db51acc2991e0ecff5185fb602dc442d9b4121c0793fc7852944cf8d655a3c6bf29be0d672e22a02d84c465a3efd35e2f20716b4f160351274431cacccc2124e5f96742c44e24b2d9fe16ce141c98ee92f5029327b730ac0d47b0ebd1c864dd46f4458ec1ea2ad22d7b54d70de2cfcc3c8877b22311c2f9b657b4d3451b72a0888b708963b6844fdddbda386b4074d98dc76a55b9088056e9f95e638bdce09a60d9b311521e5a5ac7b311434b84da6f7580935c91b938f41bd0db8f2977ba0826ebb24943a5f2e1925a5d3d248060112f2af75bb433f84578f3a82edd2b844f69d193b69b469068de9a7e14222c2579dea4dc11245b12c1faf0ea8384890da590579fbb29729dc0811f44096dc56b47df6b10078d68e23864d9c6580ff05983c00d7b091ebb717894a0cabf45c397fc6182e38056a8cb6cc0eb8b2ff06ea65678afb5381a113705e9150f040d8a33941d3ccb0444b3efcad9ecb3dccc3eb97b7036abb412109eca8b987ff2aa42b7082ce2469c89ad008c9992703ae0ff9b64d2d99ffa3e38c7469384d103d6145d34ba95486c762fe32b5cf964d8b99bc1b70ea9d59397712937c6997dbed548e413bbbef54d3ee598cd210d3c753ca8cf0946bf9864ec8abdfd5827513253b041e2a2c0c6d1e19d2a0c46959d21760eb87523b12442ee91a9ccb7b6ce02df58f64304a88c7d819f2f9b341e82b899c31c97f289a975166b69645573e56e02c01033d2509980b6308c89c90b7817c505c1eb74f8604fdcaf27b687c3c2f1ccdf9037429f89f76b01f011abec5c1380b851b570c05518d1591779608aca97db2c0d9165b87f81f1375268bda794c336fe077a4b23191dae2a85ef6e243ddda142587df28a97d01b35caecbd16cf0cd8b36c29e2939b64148926bbb10790b784afede9b0ae13bc8e1ed6dc1f387d5b4c0bf32f1ea72fd7adcaba5ff2716a64e0913749662a33e31ba31ea17a01352ebf5753c12d8402ba91de5a35f72ad3d0df2f83aa27b3a0f795b9bbb7cd82c44840ac3914d7c3051171c5ba5841b5baa02f7c6fb61ed53f4567bf4c0bde27eeefd3358ea72dd0f6af78efe2b2f12503e8f014b5d7be9c80f963bf4df0500a1b7193d0a77ecef30f50e36f57f0b5f06d52b80991992714fc962607be3edfbf5a8c177bc4d590f0c3cd2c2f9b6e8d3b5654103ddd4146dca2738e7d709f2ca28f72c976995fd08aa4df877f14a6182f8f4e4a085bcdb0122525a3cf405fa7a8d19a69efbb697cbc81cd60a22f05eacbb847ceb8114961299531c7569f3a4eaa345ee6b2ab15b0b3e1ce1fb8a7466250886955235a1e0bbf323ab0a9a446e4798390c7bd336642b76119c5c5945a67c70fb1cfae4fc0e83c2a0579ee52651abe9276a722dce3e80afb350cc9ffc2a861b9bdae5ee638816b071ac270c655dbc0d4776f5f2e051f714136152bf187d79ae152163a86a63c4a267a47572c718c4b22e592306260415fd3c6499f1be077969975b4ef18eb6a8735d1e2151e2e1408ad5453acdbce608cd7446f5cba25a255e63ec89466c2842c7827045d1f7f26a6d78d8d349328ab3d4f4a815161ef02c2e3d35174e6885c60a6b0047d31fa03898c328d9c2716e7b1a35f520924ff43b8b61b5a56bdb1f05725fd0f7af1d9840476bd455091069d63de1ebdedbbff084037583078864186355452e0bb4a452020e5697a41ee9214f615b1f28b0fb7732f11a8e73a7eccf9ab24cf9839eec5c6243d4e6cf808813f9632925a48e018320e28953ff4ac3b6c898ec8e80d98b66310b1c1e0dab3176a6a2223263039a14fabad16195b1713de9d848a1430817e6dd71af47d10f07725a3adb1f701120218b69e0eece3941dbaa006c17e0b45374304c4890cf3969302cfa84d892bf3644a7f58e1aaee785f37113be5c06d2762e9eb27c678c4cd0e3cdf44bfe4c3688a8c2268bb57da5a7ae89e950850b0cdc1fe9bcc82a2ad1f722e4f87a87a37d960456d2033f46af0ce70373525415950f006fb9eeefdf028a1543755cb247910c699d836bd4cac0b10027aa8fa5569b93cd6d6c04faecbb2943c49190195ac5b0aa7f516607b4602eeee4b44538363073191abddee8232e745b389a735c10b6f52ec54a7ff9a76f7c94094ee707282a03f7eccbf6d3945237c589987f0c0ac993fb0e00290e76d862400474ed50e6682014bf125477ee6a84d3bebbab90bde9ce1a1e8cedad9d59477ccd33bdd47ab3d2e1ac824bca23bbe090ca323e76abae5b28643b8074711efc98cebe543631e4991c4d0dc85938d4e2cdcc2f28dd3066f62e3e0193d0a1d1d80c3d45d01d931c9b888ffa5cc429839b18f57e4ecf31e8ca1b18bc2652f502bb4412c0bcb2af8207f1b1f9b44b59f9d63d004f732052f14a63929e62dd51849a4d4980c3143246994939ac276ab0bb0a34a626972f05a1956d4361b88dce0b8042d6922d795a219a1a21f61d34de3219cef7d73a10bef502a059cd7272f950b6b049d78d4ea11a4d294e65d40883120bb2e708ef6ee80189e4fd1ad3d213b28328059925c2cedea8c4768cb9af2b8d7413133ae31c54053838d8576759f450efaf01bf1a9f23c493e19a9b4b837997cb2102af1f2640cc000af3936db8e7cdaf1445cc9c57adb00704e6cc7b896c05e7b698538f147acdef96a8e7dc33ad5646ca510f8a87de7209b0f32f29aa27ac79a1efd4596568edadea108a2552da94116178791f96be5dd6af9ca1f245f628c889779c49db06a123ecb682fc58a08c807676c7b3ee9980c311f81e4e4cb4b506f496b326a40ea6c7101e2d71eadd63b29077750122795e90813cd16684686cd32275332a3cab7d29ed879787c8c493bcfbecbe850d7f32d6d337e5e81ceb17db85a269d96f95e5cb004ff88c3ea70ffbe1ef6d991a22d3b6500e73458787f87f3f5b727045112c77b21a1a5a2630663755b7ed032ea038a27042a8ed54cb6f7f5276b04063352e3aaf00332b3b4923b7b56692b195da0e496ac2e39cbc00206f9128573aa860923950e8485f19bc0ce75ae882c71638e00d7b565fb63d881ecf81a9b3e40ac9fdff6686e1391c66853f674a59e947cf3e37c76816b626e4f8ff28b536ccecd971d3bbb3b6d60f36c5accb6f802e18fd09458eeb0016841aea398041f8151771847a7702fb0c9553c969a2fd6af3c9378eb7b9aff3fe80bf2afa8c5c26ae987b39fac51ac58c0e1f9fb33a83187250a378438ef111d4e41e2200146459992b80d7b7f3dc69d76f98695733cc25660e71bcf78081c8dcbb5d2edb2de2e8f093da25cdf21b6c3d8831c75ef743805","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
