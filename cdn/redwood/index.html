<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"640b1ea057768c28cff8c117b6bb07acc38956fcd991ea3844b71d9ba1a6e4b19eebdd72f1d83608c9f3151a8ff6645ea343c1f94cdb7d2a5993dade82214b90146913ae292867e2470d6f890e744de2b78b1fbf2505b99aa7003c086a738fd2e68af8a9353b546c702a60a17e57bad9cb615d98658e360c89b94ec27949a2e6eeff561eacb8580aa3f904b9d9d54f38ad5c3de58f9e580189498c0719e92bfa9118fd97ee00883d16985d694a5ecc8c1422af2fb5f5d82aa04a7b960ab86ea5de93c06b8412ab38719899c4172ae752756ae51aed9b164ffac0edf272a431b6c39037779a6449b1d473a848fd9d23657b85d58391f1d5216ea8cf1bdd1ca79435826875f6825432a1a33bbd518e283f82abd44accd1a2ee5a2253d71cf48364714f5fc7d7b308f4a1164a43f4f4730dc64f2a3c6f3d0aae19b59695cb25268b1e6219ee51be85d7a9d7e09f2409b3c95061566637d7711f913b925b41c28b89da5f3469939f123c0e03506c47e0e7062a873cf01093d6d3812a0ba4518b26e7817387609f508e60cf0a1908a7d2eebcb2b1557f53227aadc0270a140a39071a8a950b7478bb4b0ab0c0a626c313d64a7b1c50aeb9b2353f443f9dc6e03fdc92a452152576f0b37b939f1eb175514c484e6487b327c2dcc1f494a89a5ddfcf1745b75b15b2e767b5f9ee4fdd906363f1f8109112233eb470c80878218a4376b545559756f13ff253b62f983bcb988cc14316ac60c2f1ebac3ccbd7cddafddd750965fa5cf92184dccc098d100ef20d1d230635b17a773ea1819824fa1bb46984edbf2dcc2866c11f97440bf2e361442fa40a2f5c2769ddfb90411f8a549910fa988110f237c61b620553564516e3190c6bf7aff2faff0f49042ab23aa397a9c37876899af3e303e5c88f0674f83fa974e6ab242c7f3a12dc2e59cde5e90fcccd1654b329e9974edbbef237424042475783a8e1d67ca107c9959ddc91525ae5b3ec1300c16029f206a235608842cb2721782946baf9e8533522f033c95fed8d393af94dd9c141e97e08a09cd39be094677c3a16ff40e632003a28d2abe1651bcd3ea02156c6d997ee636227daaa40d925430a631a3c6ad4abc6342a3a7d89ad014894869953cbfdf3cac77234527c336d7d7ffe50afb26d23f34357524ad0ef9afae042b82ffb095379514ccc3488bd4a8e264a24e718574807ee77ebeca058555ef1a15b4268ff0462bbe3a2b68a955a4fe3abcd279469f49c18a8105d5c7ba825e9d8faee3ef5c2f298e4c7b9b8b3074ad6d203a1eb591778a66a46861873aed609d59cafdf141e3599986bca350ce060da15b448d53c0cbcf91716147a678890cc77d5d262373b61ef7afa2bf17410565f1a9dcc6b6458d9156f41ced6dc90f1e6867288f16618472becaff23125245ecb85370840812ce54da191c2185220def2f431dbb36102a8043655ec5aab1bef4b556d1ef465be02e64419b21e24f3d043aafcc06f42ed7fc13d6fb2cfa97ebcd1d76ea389e5448a463337cb5b754caa75cc59574b9acf3c8541a077a1f98950d70c4343b1664db3a3b8a92b2954bc394a07557334efc46c65f407dcdb415589d9a5d17e8a90daa690ea5f4ea7720dee6838620ca9b5c7297ddbbf810d22a52e982cfb7a1409b80c04488f3786202b2f0d81c5d3864f10e207a09ee1dcacda6e799d0a936eee833dad268b2d6a3a018c45376913846405b8fd20fe3ecaeda36d77f3ec6ac0c413ed9af091bc223048f063bb90af1b04f69e47401874dc4dd86c3bbd877c38917a98075cb400bb8d7371405aa735257f2e85b551f239159ce8d605615fe3dd11589bc4cf44423a1e9131c37fc3ceebe641be99693dcb7f0bc317189119bcd4ae49a514cd06df8c412305be977c25aaa2bdfab44d49810529aaeee3261197754b526fb4d54a3b98588d11443c567ff0feabd6226b78f023b63f0b9422ab43cbe3a94835d06bcac18d97ab1d377792a0e5de297d78cb63377322241ac06ea112abb8523d0e0cdf5c221f169bf9b49d3ecf94ad3b1d8fc9246046811d8bb8bb7b471f363b31f8244159a713bcc3425ae3dfda087c279061134b890aaba398ff5da5b12ac2479a3b24ba60558ecf0da8a3fcdd66a72c173025d48a9e1a3a45d70d8322f89c7382f207e5f7651add9aaed4aa1658fc21cf507883f36476077a4ea2154fbe8cc3674512c98f6c022eba140b5cb5b05b56ef8b7ded248679390dde473d7309598002efe67366a10aa571efe67f0382726c89926068c24423a7f18ff83a83fabdff33050f617cdd248f112537dd45529628c239457af71a9e25388e0eac90dbc54fffc19b54f7a4cf7ef56b5dfd2bb0074c74360ea4ef50128ae9187a53edce80dc70c7bc26a8fe75e0e57bac8d21b46e2f1c63f08ca57d29025446a2d5aa84357bbe0d2a2b1857e4fd370aa7a06000ad55b293744f1aac8804c048b9895aef9bb5b5f986ad9e64f786125459034f3c4d3d71ba8cc269fd600e4d6e3bd4768d02ba75530ae4b25a7709e90f93d1a2cb5cdd709110917e2e523323e34d1228e997233a4aa0862f13966accf79dcb4e16fe4a07c174d2635d708765f3c36ed53132e21ced85ce6caf350332791ae1a1cd5cae04a0db5cedf34b482e8414f775ca40dfea616d4d079af4cdaeb8250fb30dda034c95958fc85e6a2f580f7c48591988be9c0abe6b64197b8e5d608a08c8595c96d7aab69842996c465ae3cd520ba2268ed8ac9343f05addd7a48dee0769891d1ceb85a5fb4d90c5d7776b0562187cad9f63c15b2f5170cd2b342bdd4914767d666138b8bab4ff7c82d8fabcdcfd89f64ad57f23c1efd7327f5ea613b0cfb0df755f477561556a37404b198f372074b581f4d9598bdad57a5778b01351e790a58388f619141594bf887b92a18938b1be1ddd72e812b523e92f3728a09bb4576fbaf202ffbf090b77811e1fb655a71f7652e73631c7714abe459e36c075c5aaa78716e3582115f879fefc905700f0c4ecb00b5ae79e4d951eb2bdada815e06af092dfb9683ddae2a7678dfae53278711b3e4c9fcf7552d5de885fc502e338636c7d3846d001e2534edd241fcabc0d010c18373d63279fc800616848b23ba04ce72238d65be7aec544aa330c087f8bcd244668f651eb78b5e438f8de9885fcf49883d6342d81f8ec9369c83a72b4386e304acc8c58957c1d32ea6960daaffdb0a63caae089a49978f4ca02acc553eb4496f236841ad27ed96dc3f702cc5b464e32dfa6ffffebefd11c9f6eeb8d72fa243713255a8eccdad031b25a59d7b5a2bad0b7df2e3c9ad4bc6d8411122e421190bda22c478642b11c30c2f978aeab2fdec0e7a69e1377bb70b2abba203d9123128d88b795a7b8ebb86dcf57218b8633bd3c52917dce56d8f10663a81f59676b9a3b46db20cb263bc4f55bf41de7a5d1847d1fc89e3c07c53be24518e88906bf1c58ec6eca3107bebf40be95553d172a2863eb7fe5ba145a57b272603f5ab835690aa38ae295a49564057e924dbfe76bf97a3856b837523b007818418d7807b1170b8d88a5043a4f750afd75a638d69ed518f5a6cb951ffb385347b57baca04ebf7afd6d405b8d30df8bc6fc6f8f6e8b5067fc48cff758e8b8da46ad93da6b62b1cb9fcad989cc151cec4645596f558c3b8e73ff2d9b2653319ef57289df8d5801dc2eaae3b75deec6fa0d54c80155b597c234448f7bb84e9cce479d10c1cf95ac42b6032cf9f9ad8c133d02a314e29c298d3893cf3261f2c1dbd6ec4a4baee3f906f36accc17b4f36f5be79294eee6158fdda0f9c80fa7ea7d34728e3987fbfc043961420c0d543b2df6c65422e207fb10af0328fb130a536b60e2f2e25e85b753af7560ad43c92744a0d52562e70062d1c9d441af80eef161fb8207bb51fb2d3e012759cc2dcc7cf9ea24c57dc92ee2711e675b69fb2379f2d4ed73ac3659d2ba406c2cfb974c096e6ab4a8690faebf8f6717e9a909cceb7566d53884bc5fcb74bb4a2b9888807123e50e1ae0a7cccaf79d2b8b16cd1498dd451e1aa44f50e534c0d7892956da386fd460368faec485c411951579ba5ac13c2edcdb9b1b8ce0d73b3f6715fa03201dfc63850dd033820cff743ff78fe1ae34975e73633a6cbcdf1365b9e3d2ba4c2f47785d39bf202f5a1ac70656b193f0dcb20bbd47d70679ed13a6cfec7d8d35c4ae6bb7cbbcefc68ee41d06401dc84f501e7ed3c22a64d18ea6b9128d8674552a370b9f8f90ee1fb80e89c311b18871ece43450bb185ee954a745b64ddb6b94ee7e0180af380fb32c37752fc08378116f3cdefbf6bf9debe17972cb48c79e0cc6f35af5356c0c16a924cd6608dca4612a15eac6ea84df3ac4b11bbaaf8897e89ca21393a46b803e4c184e19d6637e056a969517137654cb24a6402736817a7c7c8cc467636fc5f4686681483faf43cbd865cbed021a0fe979888edfb0455accc8090fd8a49ca4d05b658e238325cb7751d8dc1c84158b89bc50002011e1ae7acbbc4f924eadf28001543f30cf37d4ad1fa9b2ea832299a6976e17cb5a157b3e944f002409383bf1588ff4afb1f1f72d5bfc1f2c82f608341da16a9c3428000bb9293ad51944094ce3d00828810099aa40c9850a9aad0a7517f6d78f90ab511b75168be4f1ea55680395da24598383c1b61cef2933a2f7b1a794a8a91c89c7646b32ab203e3f372e84367e2b2a953effbb48fca03d358ab69c92fa922233ea51093f780ac8b8286b74dccdc4a8a930744c44aeffa34d95de6fc9c208f04562dac46a08a843e1f6ea59b12c828fe7ee017c656a2a7975cee07b0c0ac2a1b570e0bf34184c312585d004501e3b0fdaf2f627a6d8f76daf6e2bad7e65429730bd8e3f4ca1d4f160fda6dbf70e692fc5aa2c79b1d26a84298044d58d938547769d7a5e981097719d517429b429bd7c51486b8a019793a62a8ed7ee30a6518e88e19ff5de3e9e1a9b79ff7df25f0fce71a3753f58ac634ca3bf45525090a5dd8bfe271babab80b7e42dbabef1a7f50f94dd00d2b0103866e58f9adaffc6a54b0b0dc47515116bb29163aeb4d83ade4c8406a5371713bea7556f1687c74bdc6a341df6941ac982cb8d863d63499db9661ec937bcb4c38a3976e172b6ea0246f3079a3bdaa18c60cae18db341b905aaf2e687e49fb3a99d109187a17c102aecb56ff9d59136db3e032b78693bd3c7fcb5de80ac291b9a235a57947dbea0a92e94e52a82b06ba245cfd2ffcc37ba2acf857cc6efa1d67b2f8e0f7b90b4bfc21b4086dba0cd6d54c6d4497ff5c50d697e9d798caeeacbea116c2d8ccf37e560a1eafe3185cf810c0c49cbd284572fcc7da78c237374cff5bd00481929df297b6c94707fe5d2c60bc045067f6b89d6036975780298e738f63083cca4132c287b880b866671760b3f42bfb95e30872bf740da72da7d672a653d01b9facf83a32cbb77071d88c9feb2b79d19ee3cea7912e1b4ae9bbe36e9d8b9a1d4023b2b2546cc211aaaa3badc573a50ec0a49b81010a4297b3ab67662543cf96094ab29dcd9e59721f3336a3753f7e2601c433f88a6f807fdeef06dcfe286b26bc2c0f2e041a9d73ddd4fc54f9818b8192017709fca2da6ef16cf88cd4e5131a728cfd25c03d94b18811ef4056fbba9e1ca940bf97802fb2ac5b3ed7b0082255f525092c7783e0f574d0409529b97c980cc655c5744756ba3c389c1001421ddf271a942c183fc94182301eea01617bf938fd0223da74c17c36075b4b2acaefe26137ca6cb2f9780585584bb9af1e178d23c84fcf13a8365dddbf757da001c3d1d03b23378d5f0a941e91bfc1d2fcd1a1457b6d131ede71180ea1d183a6a42c5a70f4e92d0a923a943bc445690c4c756a4c72694eb7271c3097dfa2b8a968103d0cbd9a6376c27ea30d1a2e6d074be835f2c39bcaeed11211c328a7c2fa8e0c83c6404a28876781dc5666c8152121741bab1367c04f69c4d84d1417d6c23e86a2fdc047241d6c06e401e2d04c5d1b339be5d3c2ef453400e70526734f63d92af343dcde444e7e4c31f51cc0a5853cc9b023d5e6675f70f8030fe54412c3eb8b06dbda8a8e3c0b7c6ef9f87b9687562e922698147bc8659446ed8af68c0ab8e6f6ded9bdf44c7e516e35970df2e724a9112c930648542e6f477eb35e576a26977c080a175eacce9f90a4a2e480789bd7b39e0ecfb22190c191a380513ff364909ca9c6980f3ac64863d78a3a9bc67241ef67948a70e12e14851881a6f158023d8dfa9dd9250882ee4943171e9fc11ae72a9be25ca309d41cba00e72be19acee14dcd927e55ed51d8fdfcdebf7ae2ef148a5cb0f81ded19486ef0767922773496badda81a289451ec2ac590221dbf660ce8f1b09108524dca9f9b98bfbcdfbb5278d016ae8ced5ccca2bd1c8135a7ef87af32755499b5b31542c4a07b790f59d7ccf12888325c403d03c786ec9d16786721ab33d7695fa82137a844ab4a3a9013b826c2a9545516073acfa6c82942b09de994d37b5c8a8e8e314caf396ce6b9c394ed42d8e803b413d2c5bc6496c525acb6d0efed0e7684a802a4f7236d020b58d2c50ec6cd7dc62f56d74cc6c976b614ec609c5f830de680f270efe883fdcc49fba9041b3d763272d0e294f64c0dd118341e92cf6e5998730614ff267055f2443fe21dbe228d28222da2bfd118a412f446dc04aac3e3786b086429fe52cb65cb798d3e0e99e5e3e660ca3e64a2f06610e6683f150bfa85673e7581286918fbd8c12b562722203bbd0fe9ab7b7143247a1ad296c798bbeea6a2b397f8ab21c0541773e62965ebc1705b4419ad544ec0c0752a8668020c318bc974fb1bb51623c509d8461ac55ea2e29b92eae7782a54275937dc17848872ecb7ecb353fade3905cb4e07d285a099cd6eff76b9df2451f9ead057c4bd065a474b630f1a41ccf2d5c5ab5ac3b16da46feee273b8a62dcf7b144645f493eda7c8b99742b290ccaf901e68dc92028efca5a4d13b78d5e045ef1f6b9c2cdcad47801b28d5a6f7a26593d25dbebc2f62f48b2ae401172b81ba694fec83413557072ba7e322f112c7f862fefd275ea39380cb89940bc70eaa8177c5e5bbdb07663de808de65dd0e46cf438a64d4d4b3df45311455c23cbb6fed335bf61b65ce2cd894bb3260962e2a3007e6bb257de72ab3934a7a0fa71cbf73af7099428a2d17814d9ac99b147e787dd1b9c244da035a6699af6e3a532886c64beaa792a2f0d99c04401a7d2eb21e07d03c9585e3587798acbcbbb942c68675ce22d5fc3c66c35b5f052a32ad03e6432d7a1cefa7bfe596d6bfbd399420c07e237c7c43c946c29e6557cd501df566c8d34c0721cc534c9b0865d2168bbadd06812716910043e286d0968be3d0d620f82580d5ffebed238af8383937b7b91f473c2a073f1150e11098423edd53391e2919635e01513711e8e33f9ea070a70653eefde26060c9c7576450cb9cea7a4ea1039f0e3dadc44fbf232521be5a1e959f110065de50bd54dcbb651f88f3bfa03e9c2742c2f624114d119c74f77a79825077771e7e4af375b02d552e260e6c0717df678f31d5aa03678568f6c9154208657b0835959cd92b4b383db4dba47e563b4af99439d8924da82de295723e19222b2f026513019365d3bb8b7fa248f5318a32f4f6228e8c83916349fd0b6e08155a3beaba4b4a22c01cb2dca7538e1c05d00fca98cdbbbc105a4f3bcbb61810d0f750683acd50987c8945aa8e65592e97ca5e90f31a44bac83e1a7aa489026a636bdce4a93089627318a7a0643e4e721f3e5be6169f2ccce428c47acc05fed8171b553a9634c03ac740d599235da60ffed38c1074bb57fc19ed51ad9a76110eaccda46fd91b34c3b1dc133b057ff754e9a11496ce1f3541f517cf1ad9d4c348acd2e43a8d433fdc40ca6c7c605a7aa30ed1677039630c0831f06f38afbab27f29bd90c2898039a34f624e3ea224f067ca8d1993a7426a194698ae00b036a31541a7fa3799c30f10b8d5fe104c5f635b279d32b11558fde7dfe8fd493df39989d6c95dd39af412f95ea9e6306de8ac96c38cd052a2055ae23cdb9c504df2eb4152e7391ce46c6fbcea3d5eaa84c987002bedbfb5aab34812d4786d64102d2caed0f1e6610db660dc0a12e5c090bc2941bd3d95caf0f031391bfccabb23aacf1a105593a4cf292d80bc679cc365dc14514c801776cef17d262be55533ee5abdd1d885fb5f62aa1bcb892a40c6b967e9ee474087477e1e8ae7b1f03f596cc9b926f81cc7de04e6f55e2b3f264043f8cbaac38b6142a75344843d9db6621ae9e4676ce7bed8fccbbf2775df828def8e41d6286e6d51628eb7f6cea27bd7a57f5faa4623bc5fccd400ca4259792b5daf96c6f175dab7eeece13113fda055c08740bd108242f3a66bb47b3246592695ef2b41eca15f4235fa5b0740ac96258081c0421908a604abfbfee5885505fc0ae90370d2fa325187241e3a9fca3666704f32467ff202f41438d9dff796bb5ebc94c554902c15df5c218cf21e0b86cfe2d191a0c81abdbbd63a16e217eb854bce46a58d66583afe40d008b45f3eb0b78e4551433ee73f5db269e3a03fb900d96b714d410b0f7d1567fed530a0b88999510dd5099a70d198828f31b86701118239c6592210a67b8a9ec19be95b5dcb92bdef4c4f60ce99e7e18bb3bdcf375fa294210bd5c62ae86afa0e7607e1bf68755e3f70f5ea368f237aef75481fdaef8562b4e6c43fc1bfb255998fa802a77f12aecce14f356d6cf02d07413fb43fc36d6b7114f0368259ebbaee32782bcb18d1b278a2c6264586617131a4be86a0156a6c2b13e52b29b67b8a7b00065c00bb3a0fbed6d955305eeea0cf4715ea3b42e85e379e9302efa2f405f2cceea93cf87180a80d97923085bb56b82b3846381edec6e53bb41a54e56ec8b447507f5bfdda5c6922307d018ca30e97cf279691e7e9f3cb0734c4e0148c1f8bd4921c7a9ef65aba18270e70cb9f93d6f7e60e10629144019ee9a836be48542e27c32ac2bd84597b5c2e638ca7ec9bcfda688264aef3f21ab4a804d33a199dc205704b1cf6271cc4b3393cf7d57e32298619ea2297a398139dea8c5db1a6eb0ee5e3ee0eb8d35739a9cf96a3d035ad88cd6dca4fc429f9e15c8a41c5e6155b857f717848753b0617b9c58cc008c92edee7a178723055f20d5f3a576c26678d6b610deb87586fc2a7567654a52978fe7292080f811afa6f2f947f67c7f34f090065bc07f8beab8b6605f249499a7d37da02605c1aab73a4cdf80aa331223d747fe58068ed7ec917a7fab7ec0cb2d31053e09e0603e36b0b685df75f019844ad64f18809bb06794756ef91d83d5f3e2dff83a3d3f534ad917334ca4f022f820ae63fe8fc0cb3ff1a2f5bfc0d80d17d298af5d07f7589f8aac8eae8d61309b604efd7f2eb21638393f5c7b610824fb528fbf3243bcbbaf1a34a74d67490abc3f278a2944206495910bd4286b67060c6b682d06cf7dee88a00ec8a8dbd0604f5c7a7b263babc6b3d91db55bb97f697fbf618c848af83187581e74d3722a0fc383c00e41a37d3b3990c8bd79ccd40aa0bc115930f066363b7dd46c06b638fe526a2a0340f79707cd30340efbb4e6531ad6a229b8a1f526499ebc0a6813be1eb13a5223adf3f73d2031afe38e88826020f8b12ac195921f5288ce8977be281dcb97e853371cc8df5392584c060b86a503525ba9ef645c3654d8c0b744b3acea86e704d4a14dc4be9bd2842bcda3692fbaddb7d90fbc04e38f10d26ea85e8255a850071ff00e679b948bb583e020579bb86748321b7566e1b224fd4b42508ceb043ccddd8b28223757fa06983c07d656592340decc9cf5bdb4c37229bbd6e4763e91c6e021fce61227f91cbbf4d0355c1c6e173918d0c17392b119b768cfe1891aca5a44763dc996c9515e71c29e9f1730614fe13f02b0527d710f5cc0117c23a1a205397c0335af95c64025a73b0440c32c721a7c3f493447028657d4ae150980ef1af2c20a144265b11bdb85681320c964cea9315511d3fc7d20a569d11738a67e7c7c3495ad3528b7b6b0f4ef3fc8fb5f490f375206be175005ccb6a32289b7ecbf49990c5f0e6b754282942f8808e2a3f529d1e841f0e14d91840233492d084576df195d8dc59ffe2d2ba50cc1480cfecedb470241b8627ee0fb6450193c2268a6e5f1bc0e4320efd8b80adbbdba9039ef1803ae5e3a3735298bea3966dedf29ee4f27b68ef19b4e18b36b3eb7cf580c4099c95f47a87da815647f5f28921433649a07097a25554767ac49d23bfa646170e4bac1f2bc0e0962d4e784802889d1ba068d39ba60ee9fce0316f01acb017aac743d841b674052e3a29fe564c305ac8c3e7b0eaab9a0a6849bc8e048dc6f74b71aef9cd68f374e5033147519598e7d8888b5485c1668032cd621f984e8f8a48b6b119a81eb2af8e3be5de5026c703d11221a14138134a95721712bb8e9d32e7bf0017346c64d093d23f2435e3135bb8677586d2ad2ff59ebb4606c8bf3386f7d5098d363b32a5d377ac986701a892c79ed2da2b851d036617dadc646c384372f714fce6c49ee96e3a3703bfb6050be702b43050638acbc45b323f316393dfbaee208310f0bdcc4a34222ba7e0ef8fb21f2c0dc0a4d4c3046e548519e6c1ddd5d0d6591ada7252c8387a83352a7fea88ccb698f28f6a2f493a55afaff5d4235c0ac6abc2afd210abc7d273961a9b7ac7264c384a2b4eb28e800829148bda04d81a9af4a5923333f3409f7853286bcc378ed815a09ac20885e47b6fdd3b0fdaa3359e9a0276aea72d1e525c6358ddeb844d93f6f88014319daa390ce5e22dcdc9205c3ce352ea18fcb918da853075d13bc45814036a30436a5f271a02fece25904564aa031bbeddc15e4b9b0f785981d520cca6e02b318100b0bda64587e10bece94fdfaae200a1d3e338860a21a5841f46afb79a2b9419916a62df8e691f30d60dafe52277d0cf8d312ec75f4c37473ffe2cad64538a68a9dcba9639ff0e9fd425957e206581f9a3134c0fd0f755718f5c8bab774b60c5cff6842227b0de75ba5227f5cc538d97a7156474e51d98fd7874c94fe7291e64235cf72aeed1f83e9c9831124d64104a38f5300936ec25b108521c144d144b2dfc780083c120e1a21d02d51c67dcff4143fcbbc27435a2e5ba9e4b215baf950c92eb298b3bd1d993309e6589567f00019e51287264a1c66b66895e4b2f4e92f0320b81d2be8a9aa19676abadccbbfb9c49efe85d8b110a48fadfde8173ab06f416daea4b04bc578fc79cb69dfec77e02d99305804d2023f1fe2e692faa359f49a42a935a9b1539220fef9e565cfc73ad3902ff4da4207a373bb0abd54b5cf5553a339483643c45dcb68a6b09e2e849cdc2ea30e8b8d65e068c538eb4f46a0e32e3e18db40d81e91c34a03df28d5ac4230b63e1dec018caa509cc799704d7c5ca63d993ed812e7f556b59144b7a823eeca6a1d3604bd1976bf2662ebe5a9643c8b7d41c1a29857726a21b6e4fe7becc10e107a34123be003693a788ebb970c304249c303d9f7161daa132ea0f1c30de73646f5ce4e5e4110f0c099199defa534926931ae83b690ec96744e638fca68be321fb79619111ad430e234b1486811c8b5561fe77e742a3a0c5043a1da7b40945c957634ad5b90af45ae6b4bbdc5ffe9f3cdb843889bfebb0399fb7278cd9c015634ebcdb9fa781432f6c2df939101079d77b0cec55eadf41d74776e222b0601fc4b93c9efbefca6131b4bd956c869800bb3cbef936695f82bc8d1ccfcbb1f6f046590c057b77925291a2c56db59420356ec3332dce36f479cb0ceaeb9c59efcb3110a33c611727bd48bcd5ad144c3fbbf0e3b63b5fea8d09feb1e86a49b370434e2d8f604790a085593900c867c4381647a79abddc9fbfd0b0333ad6767af1665ec8d8af2a58bc20acf425200f1533fd1c8913413eca6c84b4ed150c2fa79b1ba3297a0e4f618018b0a429944bd1642466c52725bc0b8b585def2ecc6a99b798ed91320cbd5ecb575d31c75e515e289b853fac76f21e605b00ccb9a0ce924e4e9faed541f639b0845f33d3c64f5879686476a3c7fa595ce10e7d36e8a4da1da1b9df3962f78c684b1fd016d9c6f4c8832d6c9afecb2afbef6e324b417505b081090a37acbe6af5dcacc52df4f9ee86dd93b2daf5346559b6810dccfe5d7a20dcb5cf32f61408beb26b0d5a3bd16b995ae0207a6f8354885dc5ed8b2a53fd54b2fa30b95f45fd67fe453b0f7fb38465b2be26c047ff33c3d94ce9017be7052fcd7bf50996e41bfed83ac53189c427f6696304c8a65955f04259455401d3fd19e0ba59a8d9af94293cc95c11e430266543ff697b37be4df4227149cfd3859f92b38088ce4d8f0506137ccedaa6e551f428ccba85f4b8b7ad6ed731b13fd11209289106bf74bf8cfc8544f033fb716c27a0532f9a25408f5f83966ed99f9b00aaf29c175be39f2c85f4fdd723bbe40511ebce2598427952478a1c5b012a0aef9aa8959393c8ce048677569f58fb56b84bdc180ccfe9ba965b5138ace95b1e2a1c6e18a7b8d253f0320a5ce34eea92abb437234305489f149bf6b184d51b6061ab3ca32017a929d04ae603f234c4e0d6436998bf5ebaa90f8722efe926ab9064d16fd0b8226bba731edd8af14a1bba09a2d643b51e92b1582f160c52e022cbf22f6a7cb545c5b530edfd45cd575c931c2f96d5d82da8af5b372264a14851a19f690a29c7338d9f555f2b06ae39e08a943b3d4ae9a78271b7da39d0d1ddab2112a87d3f5884a481312fd254fa8e798ee6702778f3508b9e6fd031c50e15dbf2f98078b6e726eafc37f783be2948fd28dd89ae79abffae4404999481d3e97d7284ef0173b54218e0e60655b36effe419ee4f5b1018d5a94448d28b94b046b7348d4e8dd09dfbcc445daa96702b5943962b878a5acafe39287a0580afb497cbf92e520ae8cf163cca731296aadf17f25af34be1910113247ec4cf636476941e79e8af9ff4dd997bcb93062652bb276286233180ba74fc5d08fcfb03117183fbb14b042852d6b841860a2ab6b829697620366325f5c2211b9bbfa2684a36a7a718ecef48bf707c76aecb928432ed2f4bbea7b7ad8f196c136c3baebbd6669ddada766847f57bab405cc2ac537fb45ca49f960b2604d7f6efc504e7ccbc7d080bc3a0cca7e377d7858874e40c68e9f412a2e6d896a7ac5c629eca4bcc99b1c173e3b6c9ab3fe80173cd358789879bef37309f97ba9d82b322141459abd18c31fe2263b686610deb98b5f2f4fb1e80940418c8e01b04f49cc82a0ddc5a36a68224d6ebc02cf1ae78c4938af36a4eda17a2ae5ef792f107708144bd5797f1a719d88af565ca7387a6cfde5a091c32e0c55b5be952c65a8d9cf5a04a7e784ad51159452d0a7d402a0d86e89dc016fea98e4c8eb7b9e24e478c4a64c585480fe2fa16fb6b0d3d54c8fe4604ac004aa0396b3377bbc713e75930baded1ba7b6ea7cd71957a90e47fc82d5e394c218e2325c651179dea6ca249a9e6ba4c8546a48b91cf777e54572007aa5e815e35656cd1ffaa23ed7ee8ab2453fd548f1c1597417532e3072ff044dd290ec84a21b6bc1c11d567e2a680d48081adc9ce5186b5e028afd162038734a2361c8d3c23572ac4e378f7d35e712bbc6c921b1c545e23f4d0ae7cb2010087203ec53fd24147374c0bad6cbf3de624f508be72b1852b90172d3764e8d1013ccfc84f9975b4a64722b5b7874e723b2af797bacb1a287b10f2fc22f136925adfa115a146a70178834c65bacbd16870f0d8c8321e3c0136f47c6306d2c79c0d84ecb62606ebeb87b0da5fed793348672aa4db3afb89401ac689bca9290d2105eed123c3452d820c9c7d4002ad50676c6617027b8916af66ced66d176f57feb15622ca79b34186cd047a6aee365646bbede1d9b9734750f347f255d064495fa593f56b076cb4249bd057aece9094342656eb16b76be4092ad6572bd85ef248441c2869144ac5bdcec09b1bee6917460b4c6ae1158d26936a0342926f6d2ccb4ae9506157e344e9ee5e4f7873cd9a14bc600c5af638db50a1ac0e8d615694223cf5d4c04126b55ef78808dc3402287eef8fee2f9fb154e07569332649e8d85bb0f0197f723c066e43c8c45ff2dcfbfacd2b335a3cbbdbb9f0dbf273afb79e03df8ea0597a921a025af81a1fd4a01a0f49f269e69e18667aae951535111d5fc3754c397db76a333241bf572c2fdd0e0cf54adfaeac1c5485b9cf0bf880a2705861734455862b67e3a5f5b2db8fa41962a64b572a32600c7a144bae7df4a56a8451a522ebe00907a7facb68488ff5414b48761513909d121373692f59edab674f751c360f91e08636fc68a54ce2add491e20e8294a5deef9a43bda55506c48c79dd612954b3457f03d4538e6f8192a905265bcf4a698168f6d62b9d0e9bc42819ce940853e446175df12e8a323ea693e320d3bde54ab4fe8b3b9fd628d4742c52df5b1b9a9d68c8430bfc5d0ad69a71c00b98186828164cfe8453b88b23c21be0a2141e5797e9fca681f1e67789fe8e3b200e2cfd0ce819ac6a01a5c90afdf3c448f6eacf6b88f07225ad385a0a90f90b4cd57ecc399b52d5b7a7734045aff2d25e0a4e80cba3e633e3355ffca0208a5b29eea2f36bc969b2f2166bdb7f93c6eae3d2b2e39e459d3fc4695296d889060e14944a5815b016cc20ce1a19d0e4cb8b186b231608f3d0e5ae09ad71fda9f68585cc59c4fdc803860c2151399549913b316e42ed6f6acb9f06bf51b97e33d53b146349b9a90740502950ae437a36efa3cfae0fbae4ee6b9a816fa0edb0dd216765a9c128f808a289534077d1023c29cd13dba839cae4b4aa91a0e58d3467bbc18b15813f7a6df82963c2d341f71d290c3b977b04d8d40a8625ee84b81250ed0af515726f72db1cc47c4ddd83764e2b9452f685cdb8cc4dcf08ba4e8f8d1916ebdde3842eb7c9606a1f8ceb0c22dcda986c91d33c6f2366a13c94555d1a0641dbf45eb5064187e871d9cdcbef95afb1e078c237eaae1068c60a2bf8395f16020fee31ac15fa7b7a53e3103a54560450fd960ba0c23c2b9a3abc576c240e11f4abb7edb3b08197881e163c07cf30044e9d1d0e2a4dac0c6c00675385cbf8c39d963299c585e056da08778834be9cc6f746a5469fd0993f5d5b81d4e3a29abb06746c313b0d1db5b17633d0ee0f11f4d05999000ef9f7820b6aa1d6b6b667adb90b73f7293a32fbedad05b3a7727d07d4d81a836372a658b40de287f4e75834a72c15598cf16be9374e3f735f24b5290ff391570916cff8a32f3185aa0b8073561c6facc88b2909f5394576ad9c7f87af9999767ff84198438356e808b80473d4d6daaefe74296861f9650b8843f477006a93445dcc930fc1143a5b6bc7bfdcf80545017bccaa07e1b7646ab422527e3a8c7a5ea6ea6b74c40bc3a63ed7f9d94cbe302aeaebed49b0b48e20b05c834fb9bb2402803f9beba2bcfc134ca2043ec56a2de678949dba9cb7066a0dd9d7d2499fcbbfb56634d4ddfc8121c173e11fd4ac0ff10f87cf585ef1c1675981b8d14be079e75f785cf4e99fe3c86b386bddd8c901b41474bc069570681c688d2be8ae3f1bdcaca98b72ca21313e57698a20b23783f80d2fde6031e6346a52e49241f2e424860cd63c2f32032fb1f5a7d3ba4a2244da982013a7ed60aeaeefe06ec80cbe5cda889075bdf1061801b354ee64c77429eda7f72345ef2a0396f776b2d4d7f9f1c993ef9c7ca85c7edc74e266832e8766ed47dac21b601cea652d2a4f4f0f708ab6214dfbeaa08dc9178ff63104f01e795b4afe1cc490a2ec7500ee565411b43b3a7e2a249b02a3c440c2a853bca047a98c79b8fbc0b648c504326c93feecdc3f141d60cdd7144de1d949ba250dba65a9926cfd0a010ea5443e7e4683706f39555492dc0ebcc4bdca3d4d85f0da574c442a9d3b264c75bf25a42567e6807c364b8f4902ad2a870a0ff502544e70f39cb550867ec90720422e1c875344125be1421a30c6b67a965134ffe18377868215ac83c977bc6b934371cb72bc493a43988ba4f290f4839c70a3e5c98b889e1eb9f656372a032535218d47cdb7b22c142c5bf85f371e1ee56fa958bc19d60fa34bf2c2a1dc1b10ba3a86ea90b466d4e5157e67a55090c487f0d822d41ae24b1e74a0bbdc19726843204619df7e923a73d65bee0a855409afba6ceee8df82b6e04ae6e8eefcb4d9cdc6340ea73203c322bed661beef23a6947508bde7a2bea383a7c49482911ef5a3c13e56da9a27df9698887216bb75e5010e10b17606d53c042caacc52a4d6c90ca8c00b8ef65a0518640665c31056261e38472c697d86bdebc728f0b8f2febf8b08fb7bf0405c45ce10c2fb5c198dd8c9a0254174674997cb3abae9f4b3518422216ac6552aa9d3eca809a89cde617457564272f42e0fb97027a6e39e8496b0f6365a5209ecbc602bcd241d7c32538d94d06055c75d05ad85ab32ffaad400b3279a4700cf87d718b48939cdc9711ebdc7f0e432c5811cc2b1ca979d778f8b98682d97c8fc749c68d3ad5237623c51f88c0e6d7a52881b8c6f834b79429dd18c1cf56d797b1c62ce980a7c14dda9b8e2410bf7c07478f29a3edea373f18e83d8e1efae85c529a4b4d040ba4c572917d13c09eca70945da6f03cef8d665555c1673278055621cfced17936105a77f2a0bf7cc122b4982e2077c6780e99e641f48bc090396150a1b90416e542ad4ce675096bfe1c125df3a869fffc4b5437ca0f79098e96ee0e207c44ccc14ad40ec1b55a86c54b5865821e9c8b9e4bfbd20a33ca170d2dab66f188b7bfe91c457e5add9923a553c40adde9b33600743d2bd1cabfeeb2df1cae5bcca347f606258f22c01f6baa37b17628cf3b7ef42e54cf58f6a1bda08d4f3beecd64278ae5e8625c4821a22969472bdbd0fe7781a77e893f7d04bd4f9b5ef8424775779bcb87a9faac2a21becd70f19af2aac29de9470b4a601b2158d1c91c3909a3fe6df04ca3f2018e02c4c233207040621770df7c23fc9c1c452e009794dfeb0cbc688a342bf2b9dea26b1f5ec80dc7680665efaead585f6260d88d7da7200c508c07c45d9d93df101f2fdb95f47e0fdef23254c995fa4365314124bdb80917589a6ef415f5b317ebc60757bf5d84f20a429b424f1071e1993b8baaf6f8f69fbe45ee469d7b3b1c6339e56bd7619eac426c9f3b520bc405c4bc91d52a4ff9777e5cb443418ac29e6076797467a5b5db93cb4d48ba6bcf596b6c76b4d8ea10d19e2257167dab20f792ea72a169ca9b10bc155c6f414e086b1722604e38842a88df3510a9fe6ea7b10b30932e75ba70a54df816b7fd2c9eb78dd409e87a54bc333798f3c81947d060481e7014c10dd4211688d41c03eb65fc10dbb1e6312453c8f1be84db07676d065892e83b3897693ae40b5dcaf612aeec371d87f21aa6bce6543dd96f931379be861d2e9107ca8e33f155f54eb5a5f33114da7166303b3fed34ca9c80a5ee4ff44a7be54f3a60746177524ad8508bdf33050de9a5a1a337c9fae65fb466d9986bf4c2a69e047842d6c83e8670cbb7014ee814ae227f903e6fbe3ef5b7bc789274a92c3d111636c38e05414d330ce9b755c971566f40179bcff16665f3a8aace7d2f2140b30f471ae85823baa1f45da217bcb0e3f6249216410775e1d3c0ca51495ab9acda094cc124aaec8703ffe0611b5a963378673d97e5b5c028c4d449e92d73d778cb46612f14e72d9988c26b89f6a28335777e678393a50595e25454c6a42a4817a25e47ef27bd11766fe27c56b9e6d17bed3fb232d250909b32c3e1b40e6145ce8ee2fea38b34d69ad0ae7eb26127c2fd6fe9333ea14771608321bb9b87ee803b6bf2b79038ca361822f6ef2c80ec3181e0c4f8af7c4109b66ecf9826e2357a782dcec0454cbfd005b92da","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
