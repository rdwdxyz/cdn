<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee3d6876acad2e0ce82043e88e31afdd6a96070ee4f2e0d21fb638fd8516af6d4139e035ae29c153ff01b30434e02936ce71be12217b9662958e516b7a8a07ccf477f8939157f4683928722dd9f85c0f733df395c8232ada6cdd18fabee9c6dd748189f7c2b4ed20a08e14295691034d19f27a2bc0af6dde69434c4a596fcda4db05c473a09514b95ce3ce84a178e32f38458fb991b7d04c895563056d94ef7d61faded99eb744a05a4befd9a56c3f917aecf493996bf55b1451cd7328ff7d98cad141a2cb2cf8ff5a483ab13e34c75ebd767a2fd70eedc739e2e51778fe73a85c9ab8706f786cfc5840d3c41189a9af5c7c06f1289a1dfcb70089fcbde8a794edd6c212dc30d2d6f3019a40cb2926931a610d65d2c214a1de8b2c6b7df3df20932696b588999c3ab390914ce87d57fec7586276d4dcf2b6c1403d95e4182e128839eda7ef382475c77ed7df0e6402203f65dbe51dbcd32bfe64e3fe0f334cec1b92d7d57a7f98c495f4c504177cdf46cc17849d7941a5e352433de79b637100173e202843a11ea06baac26c12c8882e37b58f12f1818cf4a2d7cada543f01e8ee9f23b9683b5440018438b1800ce1335a44c135f5c353492213892e128d8f15cb4155539f9aa83afbde549be498f31d812a5b218e697cbac993c9acbd16bf3ad6a9980c8c4b962fb30efe7b1dfdb148aea1b8f49f413396a4c7188c17dc58c60b3481f1eddfe811bb141a8c1a24ea7d0443c04d5933b38bb60722a3b1951b2b42370ae2f424594028ecf0e484b788a9b8e8d5c005590d825fadc8cf3d85adb1fb57064c187612fbe00089886730b04410f6894552909f3cff19c05fd2a3927b1e9a47131ab8d5ad85bfe1417b1075783ba17b3d7fef824cff3d38a9c8543e17c7a09e99a96c85bd64284cf597a168180218330e3c4f67097356dac6e035dc267143aabf0a50d87dddb5c3c5b7a9d9186b7875e40617eba765a7cbed191495ff16a4f19bea12749afd113e6fd27acf600bd805d0455e73e6a8c0cd8f626a3b20a5197cac3b9c0c28941394e16b2fb624afac191ccf362e8f3105ea84831f381d91e2c954a92051fa534985a1e47bc116b6850ce43a37598640da0a9e0713e1a5be2b7c8efdb84ad8fd52a90ee1bc6904347b6bfe5361e2c1a9eadbb031013f96dda8b0913a6081c2f92c4523dbc58cace024a5622d87042336753cb2de51799c20051d39c1461c350d9979c882f1799cdda0aa67835cc8eaf66e6a827b27717d2631c942726e8ccb047ea2fc816b84c1f0f1ce59079d0f54d4e620ea497b1c57724f24b630a7bc45b6472b9791b8b79e94bb025113f91c2cd887e09e8bfbda25a18b308204d1bda186386acaf38cbd52322dc6f22bb06bb69c00acb640ee27382daf97437d03bd01b1f599e508e5e92c6a6e5f0352df308ff66000508bb5168d14e3eace918b1d5aac07330b9509ac94ace92882ea0b8b3da71de1b893805adaced73d69b53dac04ac12455eb65e9b59c1f831f0d755e45260f1ccfdcfe254f62e823d7872c8a6244a4c48c3db09203a40bc3e51aad473f8466ca0a240c9933352d306ad2bbedfafe263f6820d61555337193ed730e4fd36e79b04caddf7fbf369585c93849adf371b0308c4e0dbb8f058ec0df453cda52496946863ebb91c192690db5aab5dce9ceb23a5ba99744db7807a4ffd1b3885afc1747e19d0ce0a8929eb95e0938617cba47b1de38c089044de4081842441dcff9fddf593444e6a737ec470d91d4e4638db4ee7db305b4a264450fc7ca3cb873e6d5b2380d54ae82fe9f8cce38647a392fa61aaddd80d2cf09cc350f5642613655019318af3043b5eaa0e3b101b187210060cfe2d7619233b409d25c1742af4bd59b31d577605e3887fe362c3580f961a3e7d40c785289cddb380cbc99a9e07f24e326fe86d02fe2acc4617425623fee060303ff62bfb76671c8cd6acea823023c2216eafff5e6687c8637f7c31921b3464b9d1f63b684f89c15de20e24af52a3d523c49d827fdae17f1015e6f71499dfcffd16bbf47a2735edc7d4ab1652cfe7379038f5a0a41cb907513be166bd85ba7353507bf16e3b8ef1a64317e8309c73a0ef12bb361a960bad7b42320b697c1359c15d6b5bdd8d10f7bfa0c792fdc2983375109791934ceaf929189434f25608154d121e5b5024f0a4032fa74274046a4a3e19873a673a9b4ce7b232e84c81528ae00480aecf9c28748a53cf2dc8d38d203dcc4850162f57f232e8723508864d7b376b54466c5107b697ce3349f689b1ceaeb81777b54b64c944b888cae813e79c10d41352f9e21fc7b9c4d788fdb12b01af3b0fcbb0302230b374bcc17713c642c4c3b24340c4e2529dcebf926a899203604c2ca9d2cd70d4258ec3951597e38cdaa6d8de4f921645c06968491369199986210cc1a9765d84b7c5ab5ee76e8d0e342d80491fea82c1fd8fec76165ed3aa41e0aca5969be451d8dba2084ff3edb2486339196e2abf9f06e393c1fb21b835683cf97cfc43d3eb837913373b136ca3c8c781a961cb078ff3ecfe1438e77ca93363817ba71946d8da6b1f2982ad3e7c3130a11480951461dbcf6c87f61df365719048089493903c83c63a2d53f857ff5586fba04474d5aa14641819097a6682e061b31e683910471225a8e5ba2df4677e0e2e842701a3c7fae76167c142f5b75e8ebcba76923768fb41eb0ae56a12f76ddb1b062b9d06b74d7e853b8e58544c02e898ac3b73897fe61d4fc5d8d4f785cf9c6f7cb16d939c7ca05af61c513388565bc882951fe3b1ce325a12b20ed5458ee5adcd59789b223c00fd990cb138f89aa2325dde9a0697f82f0edf72997ca1f111e6bc67f23121ca1bc4fcb25a4b0c55869af975ec7b315f83c5f4cbed12590a4f7d6efc0945270a472dd9932aaf04055b4bf2e418420894aa14849f6f5317b51fd70db6608201cb944fccf42332fb42a499f96dc800134ae6991931b9f83f864a6bbd29ccc5a74335a8a5423de61276238f066ae135c81632cf04bdec29b105fd0e42bf566147106ece638fa4f185b605f95818f7c6d92c659667111a34df4815f9ca5c71ee01880980835d0635fd19843f2e4ab9e736635eb811149a424fc5001717e7295a1767f5067fed0e24334cc3828052a8d930f44ed24305b90d4e5aab92aadf3ad3a3426677150fd05e7afbf8d311a6d3dbfe0c17b4590dd88023be9c9c722280a92ecc09c40a4d51f5e852cfc6764d869777dae4ce3a81c740962883b0c1a7a934beb3c536abbe43caf222055f2746dc9cb5f36fcb9ae230476051d75956415e13741afb3f3e03a8717497296802a123878a66189411b0e9c1a2925f8056e6b977f77384c4e502bb9048859c746af078a705d081ab4a9d6ec4e2419a85fd113e81e5909e6bfe0504b93c1a0b5d8824f8048e85acc441504a574dba93225f8ea9b1fe57d2ba391aef8b53839d7e85850bee5f98715769654e7232d5a50d8aacb77d67e797a23480d348fee1f34b5b608a6c7c07526a9cd6325610d7df3e1ca244770e305b79dbeffdda04a0bdfec846b95a7d4ff5047c6492228ceee77d18b3a90116497bda7f735b28c2d6a0424ea8aa80a149e64f3decfe8f6f353cf539610716d1e95f04ee5b728a16d8985ec6f9f07785a5ab57dd122a3f106ce9b0de70eb206524c394c9b0a4695d0f72da8dfb40f307026cc23bb7c15342283acc9262bf8e351908be81bc0c91bad0c1182a1090009ee737104d99b21887a2fa9b7b47debc0cf0c53b2169c3e08a8cd367aaa19e9d4a1c420c227dd35c996d7e72e9c561ec38f9f4b4bd8206ebb2673488b483b237a565881f1e8fbfeccc28f092f10f8007f96e9c37f39585c2a948606c2231b162e45fcd15355752b6f879443ae9ca25ac2f7ac605d5bc624df54637060822f4a30f7ce9d8eddc5da2df17f38d04ef85ba74ff682c722b1c7899e2e84cfd26248d2c2337788b574fc92d9331e1b81f6ab149e18cc8a6df7ba984405c6472d36cfd0d4ce983f5df48dad02f9e17dd1b520a0829c0cfc33203edd5d01552285679c6221a4507c7ef4e6f73580a4d946530d18604ca499d497ae0f0d58a6c146b2784a7722834bb54b0740ad3add95afaf6f207f53a51d3fe5c75d1bdba9edf49af5efac5a70e18f0d8c00d1c6e9f818cfd06722da078aa05ee1cdad589a102f165062d6d95fd4ec14371ac39e382539c1ff4ab2c007a2ae6e1bd5f68c832da008c71d779566b6579d62f5f652fbf122fe6bd0417451265c13b5e364e01e0513d0b931c6499452286ae271cdf2b4f456b7eff50aebdd427544196032cdaaaad2ef8dab59053060e29c737388b37ac3aad39136a258d15b9fb23dddcda3a8b4360b9f793983f99ab4499fb3bd2debab1bc696e1b02aa2acea382869b1eb381cdc8023690dc757d48d323d7a2d8afab388d9dedc3baa8da4f0d24f54a7b02596a1b2da746a98bf40c3fe256cf5f5904e43021cf18fe0bbf69d25dc900297d6be2c9b0711964976c645696404a6d924ad5a1a5f3882b2dab082e1c5baeffd64d4fee6644ae6a81596c02d56b78cfe9c520b56c9ec41bcd242eb32cde56e5cd7757810bfc82007f89b8b1a74120efc0dc7efbacc731d5501aa6185ed3831501a84fe676a041753faf55d0bb9d514268cc07e57ac95c9ead77156ae0718e35696eed55f67ce2a194d16bf4afadc7eac5d61c16a5ae1753ae94474edb6402f0ffb97af9f5233c49ed44e0bded78ec95a1aef5c016bb2706bc06a32fa71168994aab2de72c0eb759811bbe2da18aea2c8d031a7144a1f94a4934adfc8347d70302f8d760f4decb7abd0c9a40c0cdacf41dcd2df97096df318abb9da9e0e447e420e9e40fca1d5a77dac3f6abd2fba4311b07e00e1001c52a6bbeb4b7cc56cfa0de16ff0230ef069b422f8c24872eeb8ef6412f83eb4bc62fef00a496341800dbcab5200596134f03a267a432f20c8dddfe990a763e484622164a202e54fb7a4b3050b66b18e51d370a5374d8c9a91e33c6e8981965262870edc6ad53c5af380dc49fc05d74f018fd276d02db7a92e6bcae361b7b8a99eadbccc6b914aa49adefd7a3b974fe66c50a6af9eb930b4e81139b11fa233873dc1b6737b87c8e45d3e915bd7b95e2b1c2088b4ba43b7a962bce1cd345ad0fde7d0dd0900b51cf567b121cd5c41ece506fe560ce0b5f415f8bec475aed17bacb6be3e57e99f012019810b6c946b5afa4dff99b6a11ee9f9fd7be93a3941e1fa194e199ae9acb8540f7390425ae78cdd27204209bbe685be101ae6cac6625490c79294abc3dc62ca47d55ea2c9fd1b003107ba504d734f993b7eb10e16b7efdf8a34b3556edb974ccd6d2b9c7edd2a478a6d78686d017f8b80e94fb05c56a0a5b7440e09f4077e46ec70d033e029d55c448f4f7db798bf74585683a7cace050a7fa5204577a61c3136804a7b7b5a550239a2bdf6227694cf1f67fbf8f541fc91923ae5dc7d0855c5727259b0376d248abca960560b72256d91f9eda45736038250de289dfbe79a2258f6c2fc25a67446ed4a32445e1451d080660703de0e0521f93eab91ff060a28fd15054f4270fa8d7314303ea7625a5d9c063afa33135922ade082d159a73acd1a2ffff3bb0b015ac570057c5428c1ffbf8d927bee176cc51b3e2bba0334ce2c4473d198cb3d293d41dafaaa10d15ddae3749ee40e2f24b8ac6a902f12624be8b22e01eb4753f9d6da4cde4e349ebc087dd0c3142960155a7b1839209fef464e87490fda21a2b3f3f4468b1d5582938fbaddb4e445c84a6fd0ef9f9de163cc0ef17577688b16577767a3edf40fe4411ac7e4b89e2e53bdd494fc4295699c4e77d39a2cfe2153772a4d86faf44e0a820e19b2188ff710e25603e62bae6bc5622d941593d8f02b525679b33fb2b059f9633f07003de1330dbe0a02dc247bd80e05f2548a492c957a3df8a5eafe61ddd3c2a81cc01647bcdef84b8016d471b2cc99ceb74b26dad4ae213d491809e7b1169ac4cd0b8bd6e4a3dcbdc0e12aa40d806ffb66f8720146b5b98e6a7f8d3fe6ac5c6db3a498e817a508f3c12bb448182a9ef3208eb70aa86fac506f91876d4d4aa7da1cc8f331bb7f9533a81a9f770d8724753914819a81396b43ae281fd95a5232bede5201afebb8708a676c1e996408339fa10dc5c39b2f3afbb466a596b8558d3280108a26b7e114fd7d335743bab0caf9269a7f1bc6c23a9eeba992c99cac37ef3867004fbb912cfd911c9773ca1cba127cbe0769a637c7fe272c327f174e71b6a3cfb16d5a981419a0837e6486892327c8d1f7ab2dfdb4990f661878bce56f56bb67c4e5bcbe972d57b96ac18174b665bc10fbce13041f92527618ba7bc693fee51894ee4b2380b6e1e08222e5799cfc6a24bca6ba5b524aef68b2d315a644e5521850fa57149b9caa02057576d92860d6f649994211bfa53b42e05cd116467f001a7dfca848ed06ee05619d1545cbb9fb957b7ed04c481f1be0014daf23028583ae3cdf8b4eb82e230089413463550b2bec8d43e41d950639940e555c45acded1121c660bc42e9e57bf7b6cd595e912f5180ad2ece8578c8ba35503db468d1e7c923f0b4f09086dd3a0e195faa59c3e932206b6da28c9b5c88129ef7853d9ae0aa1a971f5674b55054a0b4bf4e60551f92673c171bb73ffd446f49b4377c4103ae9392635785ab52e291bc3fcba35c1640343f6c838b0f36b23dfb39c3bbef89170a5b096def4e989a756be49114b5f7914ac7b143c4f482b353a53f12a3ac0f21d53111c17a465e86f83216dff85fc5ab63be20dccaad5e386f8846d244f98dc4c84a7b671ce7ff92d8abb5f3131d3ff3fecab32ac6adba91ab5c48cc87205b93e1208870769548ebb76b9a8a4329c3826a9b305d28f280ac245a422b763c168b6f914b1ecf2da74a78d434063eff73eddc3849d28e2640eb29a6b70f522a937392d21e953d9c8e2ab2cd596c54cf9387f777e1c489e85d639f3a9ac029bca0cc771dce849271a8178fc240d7f1b94e22b4edaeff4dff4ba12f40a5caeaf34aeb9300d6017619c38df9c95315863b9044f1c0d7c213f22b96cb40c764f70fd9bd6cce3f44213585b7e8e05e042f8d8f6272cc80694d5ba17dcf067edc7e444cf6cedd1ccbbfb62e93b7fc9894afec76a2a3e6bce9e0c9e5c3d05b8809934127f04a2f42c902c23f1b661818c49dce2233a301519689dd2e1fbcaee12112c2c74097712992ce27083304a25cb5eb14970aa112e2d0f22490a2a4d6ecc5fcbade5fe5da5a8636878ce9d227d8b2b866d00ba5f7f25c558c2c5a3f92c491a4cfbb53e530f6e101642cfca3528b4963b98031d9022a31b33639ffc448a808747609c8775b3890a95bc143f9965d2207051d0ca9acd4fb6a501a7e8ec90bf31fcd0eeadb98576f3fd8ac78504013052c2f5e50fc80d40150f4fab0f4c8e256db0e880f7b91a3c3ed15d63a850eeeb1d3e2f89530653df8394f1594d9c91e036324c194907ec4418025bcd84eac71b7a8ed57f0d1f9a34f38f2c57b0ddc4ef039a878c88b2e571b1ee3b2590c2828dea69e3c2cc5696a0538c2b855c906cfb5af2bac4b546834eed63c1a1a4fcdc13699a8b51cb37d1ec848d90e1cf33cb67246b7b806751ef4f9071f06129b075cb1a8bf84a53868f266afe48e6a258b5b0c89ed1045a6c4147391c2e93eaf3ca8044e744fb1e0a6b6c3b2288f7a7fff867944eedaa0c4346c5cdbafdcf1c9ba027f2f9d3fcb50c71acfcf05de79094dc0aa58e61b23100d642e2f7f5c5bbc29a724516ed03f711e30f7622a65fe4c7af73a92c6421dd8fcc0e7beefb4d2166bcceb54658efc54204f55399043a5123f48f469f86a31c0ab3c9e4936850a500c7b9ca1e4db61f06210c46c82309f088be4ab678164dd0c9c0039915b5e9833616181790de273df667e05d19e3016753406ee1f62fbd99c00b85793bc1a5e254a7a760f8927f35171f5d2f1af22141f89284b7d34156fa3daf044f7cd71f9937b9fd64fe226790fc3aa0e2926f7aa6628a7ee631a6cead6607476021b1ed17b89a16c6d3c87d08b943563b49eb1699b2afcc4c619dc6933c2df79c753ca7678f2d2ad474da7e1876ab8c60cef18978de0a3824c35099368e4eab54ed28d68bc74e281b2d4a5b37d0f335bb3522be7fbad5bb73578d4b4db718a3c478e204c32cb37e9068f32c3ca150cbae484759b48018a42036e6b74a3df4078e9080376221fbb7f0716ab649d868b3de5fc227792b86a5e449c8d1e59815baa333851d8e9440f17ff4154a7b34be4e92980b011f6db79e57d865c64bbb0b1d1ac0f03e3537815ee5000645b8e01d8e38addb9bf39475660f04d035616669cd528aaf717d8be8826c8f812fdc9d2a55cd164c7612e09f13bbbf4b68ab453f5d4985364500670ba48a91e432d44bf8952d291b26925afbb7ea119a741c6ce49d1936d5768b3b8543dc69adc75e7a06e509fd12fb70d773c7df273fb0f6ff064ad3c2cf0180627fa65233d1e4b8481cf0aa1a207a4240ac21aa9efd5a69b40e93772f2d987746f0b2470ca752a426fba20af62478630c0e76fb992aa473534fa87759ae1bff85d495aa54653619267fae7b7845c20e7af32ca13af1d6a0b87b45c3c42406f0663a33636b2415fefad0e5675d7f1c92e649cc202b40fb2a7dc1b8bb37a443e695fb4e536e72b7c9fc0fc57958e45f47f98f0025f6ed7959c1fe40e86c82a1e876ab5a01bce7c01ac54d6c766b984e39e09cf329aaab67adaedf4705584c84bdaa4e7922a351667caf5b4715e9a64006c62a1a1425719159eb3b8e6e7aca9bfd2160df0b1afe546029410a0eb8bdb725fa293f8aac103d08165a1d41f3ba61fd71b141c6384eed4f2ee84a391b09fbc6cbccf83a68d51997354fe3be8c6d6571254cc1a7aec09246d9eca4657520d040d3909a8012077a94f93899dbffcfe65028de29e30b58cba650f17450095098ca299889700919588fdef059231afbc41732769837ec61a43e1323563b2dbbe0d62de4447b9e629b8205ba45fb4e567e7231c0034d8c6bd013c8dbc12881196d2feb1690d767a0f0f775fc9b90d7cbaec86ad4ef8228eef1efcbd4c545a7002b772036ee38a95502ceef143bd5833e217bd7d423b3eb5f18a1c51d0dfd4b16b71eee2388ff8d3d0cf71f2265f3574219f17febdec7aae789d41481dc427ca5cdff3ebada92c84c66387148f92a9c992b8bad2787da524bd97ba18ad0159e5eec8ae8533602436241ce595d78aac9027341aad0b145ec29bc3bf076d7d1f7dfa2bcd5f1a0d6a7521d66d89ff42839e82169f450d447cd0b63f37ed43885b47d268cd6d6d3f67c5ad4e25036c361410612262caba409f1c556a624de8df89007011bd79f7ba4b94020b45942d98529b827c80d6a2450eb445be54667ad2c4b2675bffa82bea2a777b79f791ab6459d305e342066db424d69061aafc4f6d44a825fee7c22bf72d945ef18d5d8ef460e999d884c8f3cde009f1919283dae4a793a6e42c714a7a1154a74b96301767be7838421ebe0468180d72dc42dd42bfad065bcba09ce7f5ae4fe571d907c2aecb7a9848b40c6898a98cf8d606ea345725522d8f13e63691d625a219c9da61756f495b2c6c1ee5ad65fd8242c3eb4e1ddcfe74c35748bf8d90f5712ecd9f5fb637f7ef6a7cb6516e99f63904d3552a7fdc9d4fd8582f4380450e80c56a03c5e1add1f2498e38208315dbb6036d6711b58da8fa9d51174f1114faf75878f09139dce87c02649523790d1f9d387f72d987cefbd8d3be8ceeb68ac10c7212936223294d1cd68df4119fb55c0be4fdb683551151dfd63649a4afdc29a17d0ea1409e41673219e3894aa7462d512c3740071a08f5da7288d90f5eb4515c0b0708df2dca64ae2f084ed707932e34807e505453cd8365cb5d053341de0166fcadfae8344c2aeb1d9e2ef4b895443e497ee8335f2531f2f39388c1127d27f1dcd3d49c5a6635663b6b774be505fbf92e7b2bdffdf499c3bcb97f039cab1208d7e89104823cf7cbf17e38bee09ba867ee00692cf0966bb0553859364e01478730a65b7a93ef10b009867f86591c18dda9c352d4b49214cb09881892abec88fb8251b63bd231ffb2d68e28de6818e0826171207767574a3dcbcd9b2dd4c46d0d10c3be21efbda55799a50b60431d091df0a650c6f2cfd1d87a756ad1cf9507f358e2977df0afdc4e2551531286e98b9418dcc784d56469d7084b724bf484c847662f14a803c247f636b43a60d2a8c3ab034370ad447a7870b086f004d9388d9e2cbf2a976168ac8e20bd54be3a650ce8864bcfff77b007398753df154f691a1191d24b7dcd2a435c6d34c174bca899a4f97ae82d9edd2f24ed2a5b99a17e45663f50a02703231a268524bceb5f15dfa2c397ab2967668609493bd591a2f69084f1745c0566103a3cdc10ca89b71e032c67ffee298edd994ee1e6f598f5cd83ea037624e1f7666f6a329a4fd8d1f2ad1121e34ca17687fe4527c197b33f17bb58ca64e1c5375144adebe1748048cfe30d1264d94c7186e531e2d0c43f6d4f9c1cb2632016617cf8a34a3a35b75074db6744874c64fd38840034954a48192e54754cd3eaa408f33ac7e2a4cb07773b983dc1796032cd4c32a5d43838d850f73aa8b02d189d9e597304a037550eb14e57b556bf3d968bc354f343ffbc9a36a7ea34e2f353c3099490cbe89f665129f1327746167dd5efc352843fc9eb62f3a145cf902c1289019dc5c6e5765b694622fb3cf817ef291ac0364c6e89ca13e3ef460876f64c2e6467da2d213d3a31824df21ad9744002eb8bfa7554e2211f30066ff2c0a3e1bada9b4f6a675a794555bfa5848ee32cd4b9a1e4a00135053ba8d620b8070d82448088ea5429fbb41741c6a841797a0151f8b64b34e3e2f08fcc774fff7a685602cfc1629e5c2011b7a93682afafcfade2c3d49ceaee462a39f03f08579d9815a887201d02e88816af19301bf9e16d5131242c4fae8bcaf0b7086d2ff14157ce3a21aa4c87db56b623c599dd1f7ed781feade9d2bcc42edd080cae02111d68f01f99b22f1a5faeb30f49fabec64ccc07cd90cb9a55170509d86675b022712c0e167d2e39ddb48bc2267bc64fa39d8801d7fcee46ddc5156bf7bc23f546eec7bc75ca78faaf3624193de2f0fc4a15a8236373f2d15a9266214561e53d3100c460763608eaa47720d3b3b0f44bdaa1b530cbdb13c114a89cd287910caaac849749fe3807cf8ff81657b7aedb19c0f132e4e1ce35ecfceb2a04b0f959e1f1dab527defc5f0763cf752657d5d93f46520eb25d6a46d9c98f792276d849c57afd7cd6e3a4974c29e64d06b7bb20b52fbdeca0bd45f403b60b64cb26c5eb29877ccdc534fe5736efecec57f72e5cffda32035f14b485270f56961e4796cf3244f3dbb73036b177556c1300ad234dc4104dd9e88f1f042bed36664b744530e35618ff784206c3545deaae1e169be9cf0c14fe8b74f279dd95cb6d66d2756a3bc1bd61caf5c3a356fea60a583824fa03cadc7f910aa723da8d589e67ebcd48e2fcc719d90a8ea845d31cafc0534238f2ba85715705ca104fff97d6ff141146ff11aee5d1b0fa1ff28f70ff822bf37bbeaf7120c8607604225a905d9d57c64da0a7efa3d238bd2acb45a4867b6e7360ac4950d36b4db1235fac5fe546bb12ee4559cca5f848ff41a3b38963e70ec14cea822781cd8dbf119ee350823787df6928876f330d0911f6908c39d4a604d1dfdc1cfe0721dbdf58c835018759f11d580e4e2647de814557a94f8f48f15b83baa87a88a9b7e4707583057fb10c8a811dda52663fa9ed1cc7eff88ca66341e617c228c57c5e5cb52aaa9fa689b5bf0a293283371c38d915c1f333d3366220ebf0c1ec8ff69c87012173abb64ae658ba684592ff37660b2c13ba5f5967aa2992088d97a146019a4339972013d98a2004e96e3cda14b20186f1edb8db3cd64a66c4f8245d64f9356a2ea3d2c0f202df0733000ca777474f3b9fce23c979266d3e84de0797b3a97d215b72fdeabf9eea04c9d2de736819c16c1932069b585f1db1ecedf59c6c81b356c5a8ca83707d6a8178e8f20e1d3147fef71fb5e68414674b87bb793760c4dfe75dd14a14bae6cfcf01b5df148b24e83271c8a277d77e91fe91170a243fa16694737deb4d504e623f58c80246ac331af12332d8319f8eb128b391a0369ba57d42cd52d432e527b39fd65bcf2ea173aafd28ca065cb75f118a39f7d0db406c0991e3ac65bd70568c933fce24fb79e8d1c98380fd18709297b0c6759bbca9f8a24ea52e70f3c6a2fc6964b0d73014335e31069627f7ece9b80057f8e3eb2ff21d06e07b5c1ed203d9738534df23ed76ace47778e32bfbdce7dfbdd50cfc5d5efdb42b835e367de6226263c1ddf38e808cbd36c4094bfd176a1ac3cbbac0c06c11d5161624ba325f996c54a0d6c9ad38b791630f31665b6724ff175f5114669fc9143e7a5774a173b082ad7d8c4d3c43015b214dc76ef04275bdb7eaddd7199fd6ba9fee5649dab6c112967834589c0982d3762439fd00a6f3edf51f64b5c9e46e6e0f7ed062c6fcd958d05487047f6a578478547dc2636387a33ca7fd99ed805feeb5f9e9c3ea1ec809f069262d717fd45c7f532385acf1632b23f2d53bdbdff003bceb2c89834bc68c4fb2c9b40f882e0d7604f084338e1d3f39836ed4f36d50fe26af3fc1a0c4096132ca05d225b08549e7d20fdacfb821cf86480b0b4ccd589cd3dda2cbb787ccd17ade36654328851472960b4d88974328b3c1716b345e0c01748a7cf4c6e8f73a9981983eda796b06ccfe18b012dc3ab43fdfd8d5ea8d04dd7bef56742069fe3aef4c623ffc104e08e00d3ba6f221cb0694f50afb1a3e038a1152177c00a188360e00b8228a6d8181143d0d453823b7796ac3efc4f247facf563c54f5e4211c65f4279e765d54b7567a51dab9ba6b979147a13e35d138010f90e5ddfa9fd909260eee1d86ca5fee82ff887b81dccdca8b095a5c51d71f5dc446abfafecd7db182d42ddcd92e64ba4fc1171f431d5dcf0aa203dd260ec51cd314e8b2c2573985575140c0da8f90a044ddc9a390a5f9abb6ca661f40bc28b172a177a91b81fad07823060d9c8b8a390510d466be3d13679d94ad2e32d879e567af5d3ae25cffb06c5b26adf889555ac0728e80148b2a8f866e17aa3e4b92503cbc915d3aae00f0e74f8e35d4f9f1f86f8e9a431f820d1afdf05736f6537e310c28ccc9cfc640a7c5c242670e9540f43a2d8f98b63669a6ffcfd5c74bf84422f83f74abcbea4b037870c48258bb021813c65cade056230610cfc9518f1ced6250c9f018e4764c3ff27a10631ec97d019763d46d36f6930bcd0030248485e7f3bc9070b900efadf6fdcbc516cac5c189f55097f7255239426fe8d6f0fa9bc779e5071c93691580e4446e882e9ede98433e83d487d497d0f376972276fdbf7f62e9e8b84cf160e7a5cc80843c05c98bbeab2a2ee294bf51d3f8cf0224e11975d0a0638e1473fab9b542c91895c2a172f507240ca0b0096d714b173becfc638e8b0ffd81796747a8dc3f45881d9ab815eafc732db65ac27640887e43edfd6330b291cfa7d657d756cbf7b80796bd3c9cc7ade9c07655b1fb847497144234be36765c119ddb949889fc1db569eb1e0169cd0b8d92b38cc9893a12bc75ae45a4bde1f4cc127b3140f2e3ab9fc020374b5f6df00e73520dfbbc95f16df8cc2ab5e60d4c6dad7b0376fdd4750ae8cdf92b8692bd20a3b430ec9ecf41f7591fde1f93cb14e501f29ddaae69ab82785152829b143d2996324a0a96b6f2394599d6f09383c4f3442fb9901fae781cdde1098ac96cd47649a8fab42488a30bd156a5328323890a783fbae3ae7b8e174dcc6a56d69869d39578d8e0378cbf8fc2730176a591c126f5e2a49ea2d15bfc51be1ae7761313cf17184fbe727f92fecd20679d2810ea4d47ea876f3cdedcd4b7958948c25596730943ce37672e8c1ccc51e1a6ed2c0681ace4aa7598be9196e5840fe0c0e42d439954df3b0755e3bd3b116044b909eedf19c50f0cc4d59fd3a382f8632550484b912b0f794a9a8e74fd6ff2e0d59dccd40ec703af1169f638114f88986b489b6e2007d3c7ad31251cdb2885fed0eff239edfd270d9b7ccd580fed74a51ea8d4baaadad6c75fbec15a0783ae69d3f247acd521fdf88b37558256eba280bc800c83d02b58673aa0baa312da656b80cf2780c9d30fe785abd3f03cf0d77e1318f9177b462cd861424ff19452fac97ade8fe82b58414316226a909acb643be6bb2e8011d4dd930890bd1031303d355d01179470d438dea2cf3ca4c479d3a1d7ac1d6662fa94917cd2a5945dce57426bfe8384081954fe52473c45dc300b32923b9813e3579890ca994de804c02c43a43c990e85f471f1a0225d2f43484dc76e3e12dad562033a353f4bf6d51896a2b662083125ce468cabd0e10bb7c8d1d05095fa53271ab176a32a5e2c5b874c1c2405072fc35946b9ba50554cd3ac63e729138d2251a5dac7df2fb908aabcdfdd837c20fe38503c9420d265681728ac80681d9bf801654710e3473ad0caae147a4178a30a8650c4cbffdb143fd9a10d213197c440cf33839bf75218653a6999d8e0dd3b3ff597c4f3146063f9f6cd4d7e67572a2ff62abd74eeccc17ce3987604ea9f328e2d145f2e8328ea773734b660b43b6a04cfaccd865272b540b9aba9b9280993c7145abdafea5dac32effae87f6297a9b29a8c1d5efe0c632c6e0c257b772563bf40224fd1aaec9fbe93bf5e6d954498017c7583315d74ad530cf6454b348ce449e7b720371c6b059f4fc62a5705ee44b696af0b98c94fcf416058e1cf6d152dad07f1bb32841aaacc431d8fa4f12cfdcb3807e8ea4945d7ba0668d9068d0437e3615178a146738e020f70989038086b32a14908ef3678bc59fd752906f7b36efc116a76ec0654c1fa51da336996d90f89568a4c08c28b345758cafeec5df45c027a94ac6712e93af1f20c576cfe6319142214ea04a2273bb750653dde4904873dc6a559b9309eace4b66c5d02b5372ba93540b5aa2005d978286a79bda7bed647ac0e67322905d3107f5e4de3d7a30fb4017c7140357a8f02ece9d92cd5a64f434b71ea644b550d2b22f0fb3dcb8ba434a5632b9b0ccbe581dfae88d403618a96a7c2c8699c05098549a6eb982a7acce54994f8ededd2337dbeadb0842c1565a8a5fae10f2043509f55783f81effe0e2d03da7af959ec28fab53f7716a61c7e3d93933b787bb7d904f4523095e2fadd4f4c4d70ba42dec925b1b93435b049a1a1ab652889c36206ea1c6b66b7b0cb3905d1caa5d6c8508ba464458a204fb27067fbe21c675e9bc6106a60904a18ec83acd4da9c9b14628e4534909f624e1796747857adead595072409cfd19ee20e21ff81461a944ab362d7114030abf5968caff830c52665ffa0f96a914cb3058d6a605df7aed59e62e6d8c923138825e6b5e85437acb4bc1345333f65409a48ae4e16488083f87c68d4d7dbd08acfde8f537291301318e07c66013daeda0bc16965bc2958f7ee14b2b1e7cc308c0dc13aa147f4c447593388105a1a68800f8e3b126b93668d390172a28219886761c2e96875c5a832a6d75e053652aab6924ec1b2d0f6720db5b93e7bc1ee7728c7f2d8045a9479db2370e79b82e311f05397f3c6cac77287fdd44dd74772c3d21008ef1d45281ea033b80908b03b5d5cfbaa2171a03030f6128217e837b70a2b0ac72d661e73032031edd158fa45e3db8dd32b6aeb3091b0e2c4d9eb27d0757a586ca27ee5012fa610278f70493d6c5e5da7e99168df2a47bc1aa197cc33d11e28ca3379ce1c85a73f6db579e01aabecbf52e9d34fbd86c6c06d96fb07eed175d6f110a27a66b58d00d10a968b640fc8770b5d1ef015e9db882d9510d69b3ada2f06e4fbc05fba26bdbbe1c889019cea1cb5dbf59f7d33968524d7314b5953efa7f72e9dca654d9dbd0535e6fdc11dd42da738d5b33685c6863ac58baaf0e805d3a58334faeaf9ec977833808c1c5e3d292392b55931d57dddc8b344b297d77fbf1dab9ed7ef0ea9ab75e5b56d5c7c39bb828ab56a9a76628231c8872db269097a93a81720be4eeae0b67b01f33cb169b11c5a694be6e0fa4958b9f0b3a40fc708fed4f07bcb86821b09649791c035db106c83c062d80d293284b8275482c4afb84badcdbe309b66def973614b915f75f97aedf3e550c117a9c920648b5b967add85f80f073a7b233a1f088dafd48d80679d1453aca73f6a77fd5871f9a158686467ade5828af9b98bd4bbcfcdcc48a1813e2cbbaf5be4de69a0387a2a26e355803aebad8a47b48c001a20d83ea4e774ee45c44beb3d0111f4fa7243886aaf24d9be1d47562adfb0b9f2e99185a0270bffb241f1e1cfc6d168f57c323e33354fce56255813c0217bc02b64359bb9b50a04a840caee15c535b5cb59b09be556cec4e22fdee9f2cded2ebda0a9ef826a75c7d6caf5ebb4dd99f24fa720213a1781314f1bdd3fbf3f3a8cd59ef6f6ad502fc18ff50f15488984a0a010d97c9ad5764f88ebe90a668abf40f407889c100371d809c91fcca2ae422cb2028fb3fc7c37b068e3ce846243e34ee4d39ec81afa29191387611f08fc15e82e76c4205ec5efee9ea0510c48a07b00bc9a13c112340214e2310551cc5f805ac27b4cac248559dc3c19ea70ed404d2e238e1e92737e7d7780ec3edf3600f2da5a6f78934063b830ddc3e042eda279cd814bb73ec26d69932b4089f39a095b4f36e2dbfc1dba1b27802cfa0e40090af5850fa0e3c1adfce3784bab58f60cdaf8dd95605185f65f771892bd1dbec17276c59f4bbd48511c75653f2577f5ad171c42f7faec71085d7a5f22541618b0fad85d90428871fba92da6db600a4542f434f0a089a5f6451b90484eb26b627ebb786a2fd9700fbb17e2b2e9e89795a464325359983b7f3f7ad642de08540c936d3d2bc64d3f3c51bc4266b08322dfdb2c51a7929b9807b40842c69b56f4087480bdbbd8d13de47cb66a40600bbf8b850056ffac25088a97ece760ab2c15848376e5fc64892af46eb8b797f4f82b343febe6ba1dc6db5ffe1201a02795a844fe43b8d8cb68bf18dbb8d19c821a3674785af0dbc2dc188222ecd0e7150b8ff1b6ddbdabb8d0227e653a6a9786519099802a50f5cc5c8e58306f6b0d12ef8bbbfc3c2f515f7259d4625d80f9f53d02b191617c1dc974b42ef1394810757a5ff142106cd327f0b1adb8b12b44010c466f5d8253e42be3b1ed8edb44fe54fc19cc45a00f99f9c375fdcf28b2912f685a5dc393c6739514de0f06583fb139e28529185a7d5bc9a6359be02f94160af10c77f596999f38444ba0dcf9d7c9a57fcb7c7490e12637becef34cf4b1e622cf2df2c08b8c8829980d25509dfb33244cadf0bdf407901b24cbd99aa10ed26f01adf84a6c5b3398482c22d335ab2d65b7cc9b35f3df5be7a3d8426f9a98c32bc860d1e868e6ec2c54d00d3fd2ddb73b0ea2ef313448c4e621b6dd499256d2c953e2c441865420f3239bbec8efeb5e5597ac37b8b29b90614e13cd5d1a356bde9ac04bfc772c4a9b847ac6935a004061124451950f8691c14c522a15f8933bb3a2266999ae1f158d9b6da5c16348a96bd415f047674692e1b0b97a99ecb930802e39390d424848cb7e0c695384f77792ab6c4f755ee1f28d521ac343ed5633d43e58573c084ab1c9aefc82741b7d384fe632c892c5315f73cf62f5e44c58a0cb01f0bfa4b40ef8a138b64c951e554fca3c96fe9cb0e7ab8730321af28580a10f000e63d3dbc20291effbe6adb4f99abfe9c5f6fc85ae09a9b2077c98829030d76e5ce10cac3a0f4540540ff7b03c4551cf11b8dae329ab186f326bcb6f6e2ffe471b1f76dbd200c80980812872942b93ccc5ff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
