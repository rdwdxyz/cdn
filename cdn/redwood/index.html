<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"62c6022384614a415167ebbe2e9cf67049bce8e370b22b4217735ee55d2a62344b52d28f4abd2e51d8192d1203f4abe681b3deb61e94e068079c3a2c9e940ade1fdaf1171f6c6dc8f378b025151c351018c630f123de357a8459acf09a7b2520837932c8a3b8de3e4fbe5cdbe7a3eb9539d07cf9b8b6b9295141b3e0ed39287440323c750b94e5fbadcc64d8d954f22e82376537cbc6c69b0d7719d757659be95c3c3f9f47b28e6473f00ea4e2d41008353730265dea5b91642384df1fce9ad4cc168ce8d2c0a77a10a42dfa46dc4d28de703394c698c9c8a3824523cd156b3faefad3f31a613aafca349dda1e5a486c278be5089956833c9d032356e0a94484dff7bcb8620dd04dc51dd9bb9ef1ce5640707dc79d0382dad580865d6e0417d6d457fb87274ec767892713ebfe4388c90d37e9b7d87c8c1ec54203bf49630889ccb47a1b39c044f1d492f9b57d8659d35fe80dc876de6d4410a37f5d3378711f822e000780cec76e9c756046204c0a5ef86eaa4172a2e4d79605e8bac0dd837f82c6572e9066045bc9a3b9429abcf82a6430f6f7a97724fe9bff2613b53176ab55f12ee746e34ff0b6dc719fad8ff0cf41de9cf811d420bb4358839aa53b22cc8b77bf5eb3c60947e6effcda2e43dfb3299803c2d0d209d756a55b4fed85bdd581754c92c3c4306c321af2077389a2ef868bb4013ade0c43a81e7f80e1b021c216f8b6fa2bb2ab57038e3b5bce5fcca50d9e89d3911caf664cf3ca474b649ac939bf42a1fa631ae612f06a096a55faf6674bb20ea0f3f3dd43d5c1c159c14c8947c704ccfb1b1df4d22d174f6423a6131e94b4b609dc41995c81b5c3880af9c111b4b4743cab24c7305cf261960c8c559d37f9e3c0d521269a44f17a18e87a99301eada7feab6bb8db44478410fe7f731070e363bb5a6eb1143a04bbfcedebccfd6a790f4527fc36af91e4f801412113da065857ef2c5c286315afec5563cc3d801aeb93897df94d65cb38821137b8924a23d676fa98020c14ff08d4792e88450f08bc698e6d7aaf19fb745d489c1ea31e1489b7c205de537bb3ffdcda1512336e36dd9a2b2ad904f9fd467efe9247a3d9291b956b5f6d634d0852937ef122366bb805290fb2d8930f445590d5dc6336d44ef76bc4d89ec94ca7221ae8e5482f7a12d7c4bac237c3080fef6f9b11c6220819df9ef33c9a469b8fdf03f66a9550c9310c818b28fac033aee4cec79d8f431ece843afc8d079be98e3fd2acaed7f736a3d80cd3d53df5e7882b5803c05cabff6e2cbafdfc5058ea9172d25da2cdfcc69e9a71477353b1f9bda37db15dff5195fcf810d6898cbbf70a5a6df424e20279535f324b42341a282165473fcfa5e21ba80c808ba79d874253fb5a4d0001b990ab360cacb988c2de184eea5dd0ec7b5433d7c688d3a786352a8668634587bb32846cf4927c013eaa75764ed9c199862cf41bca9787fe208670bfd67a6f489a87b1de1a1ae4e1390fb59d8f97adb6416dc9656de4c80041c39f925da89c508a8fb4dec2d20f928131119907a3c0152e020746cfa9ea82a6f88f9cc2ca7c704f3680c3defebd04016e601e0dce8af214c263836395988c6ae3a1de2f61c1cd5cbd35cb86cc967f326086855456b983d0027b201f87a27a13c1f86f7922071326333f69a2155815b8eb11de4e318085abbd2a63e2bed91cb34363d9b45640e4e3ea37a82b8e6c723d46cb48efbf4fa8f92d459fa6ed9fe6af0b9c4766791a479c97f9c93fc4cae9c1a6f11115b72f6a43cfc5e5ee6ccd34ae89b5a91fbca8053a82cbad37524091692921f2296293f63a17fa5c4b2c3c35d677175855cc878cff32d084ab2c7c9c8e2ec1cbc59f299313480fe1457a9f0de9ddb9a45f32bdd8e99048d50544482eb0043e4ed8a727375d1ab0d03154a9a38571c950d1350548eeb1435b1ed6ebf0f116680966034f44472f482741316ef975e8a773baee2880fc2abd687b7ac19002a79bd40b7617b581117687c1d81aee9dff0a124373e784740a821659c93d31ce0ce7891746ecc67de587b42f7584dd0fff4a8dce630b82829b3ba98f37530d98301da30fdc4afa812e2fdd9a4726299056b051573057e397c57967898e4af9c59ddda1d5608a86e80c04ebef89235e285913877d234ca72da31f66d45071d494198631f696a6f87490040cefde0b20746406c05c77959b154746dcac6f429e816062cf9c6f97ddd62128666944b45961451fa7774c1b35cac311e7ce1e7d146d9aa2ffd29f9eb1776b41c3c9f6a006a757f56448fa7d0eea76cb65f69a495868b720ab93869574a80951e8423489da2397583a3841330edb37ea7cce6d140bbf1760aaa5ef77d12025f5e0cc5c3141b6f9bd62ac8a09f932c074521910d18fe0189e67cc799cd69ff7302beba16ed732f508208d9b6637a490cf8ab5c37a11249528c7ab16e989d438983ca8646bb360413454dc5cc95cfa5050552b944ae4b0783b2ff3f5edfd07a65cc87db1d62abfd8eedd094fca61887547349dfdfc5d7bffb7d381592a2b283c74aadef5f3ed03d89cb160b28fb3757186cf05016e9a1788970f1066d7c8a7bf6ab5c6a5947d77246a4cc62a8a09c0ac8b2a784e5f29e96534f919b1d5bee1a41992a5ddc2abba16f4c7c54bf5ac1ce2dfa5e6385aa9e84ff22b99e720816b5de5f0489313e3715173bfbf27860747265090619a79138e1dc22dcb6b0fcd6d83c5207859af1544cbaf2af9642c453c243e2202a332a586952d3d235769ba65054d7f1811c771d2c66fb5560697d2f68b7883925144ac253c06bc2564c4b52bd108a31f6e2489201eee9e78967adb0966bb553f6f70029831611f6f8513fa2b38cac01e614b4d6f54862f4020db75ef54bc22ef214403854779e37921357d44475bc1d50a4abc9bc86fcf02446d6195c5ac88e8b7c84e285c09e494df71713ef7964908c3fe04692969b94eb864ce3b35f8626f536f79514d1e87156416a2bc602573646f1a0ed55865aee315645ec6a8ffa18616fa95cb3fe41b967f77d74778ab9bf320a522f4aead34e8e5a1ddf26451d9d3390a121e23ea5164edb45b894d4a6af2f41270574552ccf8598536d32573e30634de90b95b946b0c1c0e029292d6eb1fdbea46902b5b644bd0e3fbb950093bb594119f5c77dce427099a075d42215238b25157040ba5a5626de322bd07d6ba73cf6a4c1604260bec819b23e14f163c117a4bde18c05a3e5f1ed5ecb47d5ad43bfbbc45dd32065517438eebc2f3e40e01cf196037805cdfab5159ca37fd2ab1c22b1b70c8e02060259ef9488794b79a7698c9c468b5f3421523a0928394db3d14f33ce3e98e5bcfe253237623262ed51982da34d14459710c9356e9440f567bdaf4aac26232f98606795593ed2c0c835a8da67aff5abc0ceb231545d10a36caf7bad3aed94bf149d09871db2d14ba25b9e804c71141e20507400f542df6eb16bd80f686d10a4ac73d872fbc815542c44720b72c6627965b08d2fe32b4c701b11835b065ce200ff84d7ea14bae90590e1bbceb152e89a06e7dea2b83c2321049317b3c2a562ed78e8e2962525a1e1659290f0956ef1005ecc7de32624aea7a841bac4bc582b304411aa843fa58f980faa1400f0e1de08b88cacb7d8915a2aafb78d7de1deb7be3ccfc1d66e33202b76e37f594e46d2ca53d69009ece5343c1adc16ab0fb072f1799840d0144bb64a91d9611a51fb9c3b86c4d0382e0c678582a293ee406b21a02b7d9e5d5232456ad0e286ad9e62e89b948ef88b58fa2320def23fa73cdd26db8cd5aa7491ceee1666dac9b95d58409d629e7af8527019854378a3e95f628612f7103332c43ebe378d1385683e99c9fa7117270760338ccc719d845792e57561dea67b5128ba48bc41608bfd1eb628f978445b2cfeb342a064d0e37c2496997e9c083bac7bad91f3960f61b73afcc2453c09e6e43a244fed856985d464708ef65f3041a5264c2edbe0562d79d407d90f63d7e71eb5eb5978b7abfa538bbbeec272cbd22c7a78f1a6e7e008778b5bace022a4da0010bf26889b2443520ed2d0fef29dd1d94a35aa259fedd42904dc4dde74e9f7718be1c30e6e9fade1126499ecc15415267dfff1349d67d0609963a0f4656dc5850cad0f1f99b01217ca4ae548844e9f5d44fecc25f3eba88fef7d4f366ce76110b32d373fe3fc4425277e7a07aa183d58fecab478b5736ce631828e7ca671f39cb109e3b038a0d19f56352e59d3e8761ddbfedfb6a38426e2c324a837a6f2f479e2234f36426f0d1d36ab6ad282221698f2f336739d1f3143fc5e3a38addfeb025425ac71ec732168a677c43fd8c560880919ad2a321256c61af8f6c18cadbef36edeb94e395e350729e67a2dbe8b5e4f90896357ef471ade5642b0303e075a2c30f1e02659b00f118b79ded682280e714217c54123e9142cd4d7e26f1143bb7d565c34b745e56611f5ddaa34b980bfd33080b27973a716c11436c880653cf36714bc6e64efabd9d5383ae049f4226aeaf29a494cb1ee817bcb098dc68bb24e8f8f68e9d37a9be6360d43db0af41293805beac73be55ae1b6357801110c64207b1f5da2350976c1d2a79ac95da699b0c38a48cac62008bde9de9b68fef67d9995a93417dde1a729f076034ae55ac69e05d3c7dbcfd9f40205d04ec14389c0161bcb78b32a2fe55f257180b5e6b9dba585e70b98bfcb67c7f1e1490d807c451a531402da0edd5e9a125806102a80cefd26216680a297e038042ef99688d6fb67ae6e33ee8ce8ac779db9262dd7387f894d629c3479264f8fa616242c5831dcab5e41612ca0f2c06db028eb7ef6b6ed7ad9044c6c3ae7ef3ef8378090c9f33cfdaef4900fed2db516c43c35d768a20774ea13344353f27aae98a6b3d6ac9cf9e584ebe0a453cd063a7230186f5cfe26ca5d53fd3b93616c851888df3dbc3616f51ce02eb925574023189842cd8644518f7a7472031277b705e2fcfe12208568ee8b55a1f0ce8a3576b39ff31e73ed807451fd09295e99db63defcda1a7c11410605fb061d87320dfbe8bd9003519d26a0082d75b7e2f1c92f899a623c8bd6b356af3e8c6feecc89a17b9e4939aca6db16b574a32936e18d7e413e2d305190f2cd7ab85d884b97b21b02912a671742245771403c2dcac4f9f6617d53417fb1b9528c687bb2d71718622a847574a7154c37107f53e15293abbff0ff51e1db6c4113fb70cc836f0bfa01078cd5f4c8f2939e6af3dbaa462928fb3317dbf75cb8ef645ff39a4b4a3b0d9e178203013ac8af2cd1f2b0c44c9146a5f67cf17fc58df32e69e7d3a84563c3becc63fc7c880939272c99f26e5bf2f5188b94def4e7fb05bfd9ca56203ff0bbba5d563a5da671ce0b6dfba13118d104b88bfa8f0955e18352c72417c72b21460dd9fa9bb9666ee1df900732542dd7d985ed84102de44cb2b05e976d183ba6c9b12db06740b18688427d8591eb569f4c364fb8bc4e1e01a679128bc5e94cc4e6d2275e57e6e3f07117b26e45dc2b2eaa82ee1164220b964ddd6d01ec0503a2e7f8ee1972ee0b3cfe639341adbd6c7fa89f04370193609557fdcab96507e015320d88f27383992eb34e2d0a104e41401024b7a3aa328d939e37e7e712b5a3dc7931e367d5ad40c1087b34113f26413432173cde7b7736a89ceb867ae62ec7d6571a6f2cc7899608b544543a0132f632e4b12fafc73820dc3c00e826093106d83f8185534694aedf900991947b96076a8d042148b2677ca899f093a7717d879d9252d12b468159c25eb9b4b502daa83906cf78872beb92119be99ee432de96cc13426d34259106d91bec22be682ad6dbe0b5a3298a552be5daaebeca87c86219fda93f44eb1dd48729ae04fa1f5a50d678f0a5acadd4d68faf5df7f9ab22c618e391c17c9bfcd3c749ebfb4d8ee01ee125e5c9237a8f34f50eeb3e33810ecd87e72c8fd886edfbdbe55fb17611d22d605afd55f54aaf96ec2643563c1dbce8cfced84f9b0df2bbeb7dd962e1457e2e61a095bacce4bd89c376ddc360bd33cb6835b7a88a7d1e9c6a6000df0b6f1b64f9a9867b96a1fd63a955df34800542be9285bcf3643d27a58e262060c2c328503e890d3e435276353760ab3f2fc4e2b2b9e4688581e92ea386d4c7af9dcd9ed27f48989d0f9aae6d8229ab8d93c23311d4032313856b45f4ea9c4c380a52c3f8dc274e433acd7eb2b4d1131dc8dec5053fc2001dd4b1e991c1cf5061cb417460deaff50c40ebe43584dd24c73713206226aabff7d25a266175cec9df3467fd8768f6e23ae522aae8d06a8d9718d4e071e0479920b95b50162b298f5088091dd63a3717228336837fed6623cc79a59033d88fc57ab62b9ed6c0d5f6c2e1fe564cd78931ffdaae3a0782fb124f42bd69e1b3d6639c6e8ca8e4e8b72495d8413b0909c99974161d2312cfe9eaa9d28133726e0dfe729a43dbfab6dc6897367e8b21e29e09572d399e3824b98e8e28271e911e2b2f26aadd6283adfc301788b0bc4f19a03268169940b193c1e13deafb592341079747faae15c14ed1c004514c78a1bbc043dd63a254232681494f3ac2d15f288791f5b43bd9c79a75d5e5725fceb724171ed90686c2398b19a1b96b2841cdf59c4f6da5d7abfa814bd967f0c45b1129ffe22a9931ead65368014bb253f1081fcbdabc6570aa0fc2b3228887c9e0db8bd58787e0582a3c5aec7f1ab6524ecc4f9812aa26dd0de1f33adcf1229c8626e101172a7b1edaed4c1c4a157a35a5782d42eff61eb1e67e58d2d61e62b51f10e6175dc8a3675e653dab1426e6d05ce6c66942fb80cceaaa65e1a8b1d8af1c7881a82ce073c969529c5c164ea381155b393e8c2e86012deea8ee20d8ecb3fc9361df0e5d78bde9a37f4e6b4fd8d03f203bc348e88c198775ba8e429279799d9e6fa7f0bb57d70a9c3e14cb44fc39ac26eb84de0e4b54c3b9345fc83bd9bb709e83e35e2cd60050d8edc93e96d2f83be58276efa7ff2f9e505bb2c68acbc85c0025c1f29d1699317cc72dd91f599a1fc366a5d8d327a87f2681a020ec750f7030eaec4125dfd4acc821ca8b5984d0663ed9f9a87af07bf83a6db8c60b8655d0f7ae47db1fc521c2cd66c4e2bc8d95ddb2c2cf5cde5191dd2bb3f4dfc8b4d09cd7d1b74003badd0e0b097bd682b4161c54defa06ef358a6a6fa2c11efecb36a561a90e9b156dbb86209e8fa6113c8a8586629e21561ac317baceef700084f3118af0aff27c142251deaff39cc8fb4be92a0a9c991e72265954543c7e7564e466344cf15d903783a5dbcacab7952c18c7e3c11f99688f6943d0fd1d2d51fff477e95df01519fc46fa721c7dcc627c55a08503500f0cb3c071faa1b29a8cee7405bee4f64b41f8731d03743a4984d9869c94eb3c6be957c7c29697abbc16db8f5f50c58e744394269cd1da176001e81f5801eaf5823ec9164d9395d524f8b4840c97c7427a04f506c3468dedb17bb0c99ce2b76273ba9cd307033053f473e3af611b42bdb072c19b3cb2a6d296f8c2f96080d8c24745dac1434b4b9179b48c94ce730c3e712f88b3f248e6573c43bbcba1d08d190b7549b87aee5927f4fc4d25eea4cc920ce9538547852c0bae2a84fb7971cbfbc44298340ab73a6d7bf9cdaaa04aeeb2aca0b306d2277af5cbbefb88869ff07b2968d45ab1c816cd989a7dabeafc3c7a30d141311a95df30fcad6df4d61f6bd7768327be03a5d00c7276d345da11172d617bfd4d24aa1a80c8ff940d04020cc4e335130891895f825707c96525150cd5c8a1875c247e55600d3ef3a3145aa057eb3d51f85c47ef5c6e477422f2a29900c53ac25994277e817f0c934cba0c64a2b8194b3a71da1a76eb6f54d544625f0a3ddf0733ddb9fac40959144c34a6164f744581c1099fedb1508f4fd63560081905e897cae9fe48bddced195580f930f0ecbc7f851c971bc2722cf452985555ac34f6485bd99509ba0703c0ff8752b19ecd2efa71805744dcabfb9e5fe9f5a0fbc9c43ec26ae270efcd23687050f9143a87dba5e830ba706fbc7a92c414aaea269c28ddd89897bc6f894aa3f0c58a3357ced5d1c24c531619f90b1f8b68ced4e8977434401c5a6f9cceee5eb08fe1953908bfe992823e7c5a17452498cec806b8c73f38596e612af203d3f42b7b6445e99b2d589b669480cb99cffcfdaa0613b50bfd089188da4b497b28eaa085fa593cc582a627c85d1baa951fa06a4fe67efabb2025a74b3792440052096b26c9e17bb710459682fa71e54c61530a69e83323aa06881b5a9c5a94d34bb3ef90b66362f703af1e879aa0f3d20a5a09126c209d900bcdfcc8d8da01216140c7cf7931f7691d84466892725c11d85f3a40a6d76603da1cad5e499932c3076fe9186855d6ddb158e5b70d495a6822ff71aff7a2b165826f22e8f90f8fc46465237cd39a531e1ae217ea56bf9e61efcf8bce46f33dedd835e7d8f542f49ff3517570df6b48bdc4d78b12cd480b8856d8e9b82d46639d7fc6299fe8e6bf5581989d30a92c6b7f45b1f6d78122b9b4f5a45e62f8c5fffc676c5ab885412ae7c30851d6f16e60b097a76511806fef4769d2b79380958eecba0b55ac7b07b22e00c885da65877d997c016feb31410694fe502aed1d195bebe917346b142c9b6d09073810665d4b919ca74c7098faf040a4d806d214079a27c4b24295b815a0fa76d49f9ee46ed1ba8669497a6644f27aa5afcfa2843a61554a76494d6cfc25dd2f2a72be92cff19df6be08d1811962f753ed5d5ef24a63e28fc52385e97898037c5fb13e729d2d45c5c935c4f78a54ffde16aff815e38882c1e10ed048f54075257e13a1f4b94be3f7f2bb6f44f88fcebc87570316e960748de17da89f00c4ff1eb2dd1394774632656b978840f012f04321cf79974d787e955aae3b2c93a4a464bc03eba4f9576198b3516cda785a96a1a353197b0f381bf2c546fcf97f24673bd17bb4c791d4687bd2f71e0edd787f8ad9d1e94616de2fbff89f2a2aae5c0548de6ba77e0b5ffe5fca28e148ae5888f1053df4b89f23fea03587f23ff01eff56e0b085f333d9a3ad4b241914b2b01611f3aa46ff9d16993b81699491e0ab08652f1a10f6c3af247e3ea1fce65b9231b1cf3a6b4ec0c722d1068cc3f47ef71067cdbe33ff07223f58a5d7787f477a01a15edb26c3af84921bdbe01d2e668bee32a817a8b6159c0d36c60510cfb5f6436e2f92cfe933fc65db21603f3fb65afe9a5ca90228d8617f910ae0412f68bbdd79c51eeae26fd103bc78257ebaf1ade156f45371f8f8bbe725b90ec14719933e1d8101dcbd44b9c01fee03e3465d058221a963e6c8f0ae2ae88aa05d4f7bd88a0608bb5174f130979474ccb5c82db674665345c2820d063c86d09dbbdc224ede068401cf03c2d6deb9d371b88e5f7340689fbe161bd3f92f82e4b5e86bc23c16468916e3b04278a8e2d08a92c7bdd1b27ab7b9145a75e236cb058bb4d9609a74879f49e1f743f3b272c4fff7586ab0241cf1596af7caaf635fd06f6e04ed1ea53914f915852ca6441dca0df10315573d959b13c40c3b7766031d35ca8a034876f7b6d4581dd222161a3581757563619f5aaaba4471fecee2ed9cefa31470b24b86fe6ae366b422194cbea094e2c854658deb088269116a12122b69a5a230f8bcee38041da968e8b29988be28066c8377d42d150ffdc14f4ea417f4f59d61c2d8259f3bc7a67a1df3f1aa2799ebec3df96f50929f3ab5463724b2be801342050f23a00bac2fcaf8262cafbd0ddd86a4f7080b9c873a4234a03046ffed815c4a528c296f7a43f07a8627b7d0d6f4957a8e36fbbce7de80e77d3f8412350c63c86bf6a41231790f13594db0960449a6af242bb0da436826de3b3c8f73fb84cc84930da1266e52491dd54577e8f80c355b179060426474886814f1f606aae2bd6362d13642221ea77d1e87b895f1095eac28ed72fce5995bb252ca1174701710d416ee78f4a28f157d5a51c50d358ca9974626a614040538e8ea7cce82003df9d360d541fb571298c1c0edae6828a1a04bda854c5be5af2ccadc64360e3b4dd34c0e33d5eb28d440f88909ea3c6d349ef8b055cbcc0f4366ae9e924ea3ebdc995e298be36c7f54753b86727b2ce6e4cb56b0af8c9b799d081c21bbfccaf73e34361100234a2b1948cadfd8714e092cd6f8c9158c67a9fbc7643a8deb1750ac1038d7ecc97def8fe23712b9db4dd5c84b3ea0e207401066efc7d9e2b9d48439a5b29c410ec57be6dc2a1f8827bdb7d7417a94b239217323e27f8ddf1c0dbd7748163e3d3210ffa329a4e9a7008bbe4394084533688bfebf96999f6ce969ea4cf5d5f6409ced7f93d543e8a19ee6b78dc0d450343cfaad877fa4c2e499ec7ef51776e6e8a9d0a602f5a042f48787f0b1830d135cf6235b095bba03dd09d9eb7495fb93563517d7a2467cd17bb684068cdd87421161de1b98808cc0b377c6392ff3dd897545488099896cb780495cced4cc78691b3e47869cb6dad460aae72fb539a4bb6256bad8ec6006be51ce64758c3b23d3b9c829dffd481482adb6bf253be66d15bee01953999c3ccf645b6d8ea4b24f9af39baee1365329454e040ff0c2cb51fe53b34a0e533a00d17bd5f3d37b1ddebca898ace24a8e9be0981960fa2036c4e2b0b273e17a788c711b8681fbbad20fdb8e187fcfbfd7f699b0807a4a3088c63157e7e21d0194acd1f283c59df165a85e6b357ffd19d7eafda691dbe8884769d1d69613657176b598aee59182a16892947e3c61b5cee000b34a80813ffcea1790d99dd84097d7e31b44f79b274b308ec1252e376c764e2c89956e146d890b52b7b3876548b2b282dc472599cd2a300612eda84bc48395e650f92008ced1ce2dc888356eb386d9dbd71b03003fcca84e9edebbb0e1dcb52bef242c7b3689ab8678f0296f87e6b497a82ab93eebaf895d41e9ff1646aca37f6f8e6ba835de438f0d78abe723ef96ae19656b420b280d62df0dbbbc56f2c853acbc99aa1bb1291bc3253f9d81b03400b2ef3ab18c381087f5c178d41f7765ed2816120f4899f813c0dc074e50a92bdcfb7b1bbb87b873744e2e5d146b700b3d2f81a525c195c0b6e9a967db777a408a0de507f4968f0502a8878fd583c46db226a0c6b89d00ae56bffd1b917fce8af0eb6331b2f833e2ad726d5fb55dc396f01c35228c8520ea4320041fe682e51ebfd49944669e820fdb762ab05d2338288f7ea0c0724351b4abef276dcd6ff8cef0418159a3aa345891ebfc023a4fc7eeb10f82129147908da2f435261b2680674c25ec7fa9c838b523ea0e154a6cdb3e3168ca074114de3ebdc71e45673067e7562523467e7043f03d63405d49599964d15dc8e44e7c70b24ee36b93598e0621a11c57373aa46ee4852696ea621a572ee72e40045ac700efe550f603983856851fdab6a365bb6e2893c736967b28b7266df47655bd55a1d0a4390456557e74fe598c94e6773520a0905883a3bda72a8e077ef308f34e00b1ad443b47e58c31c42f5a9b82bb06def5d8492bbfbbf6353ec5f513b0aba23a45caa84d27f837da2055ce7a1e1276220467ac8b0f9820b21dd9ff6c33ff36cf16a5d534c37e6093be5bf0fe1d29869b754d8c4b9e3e80c73228373f3909524455f9a78a1eb6214ac42a41a39b58ac21b2afd5cee1ac3178ad38874ea599c78d113e9affa0fd379fb035f5f55f315c8d381bd6488b1d5c88d19af4501ea4d388b546e7bbd2a7f4a8c5f2a231f3990543278139522b067d06e344015669c9a1e37a0acd567d744966a95582d67c7a28fe9370e7ee75d47d76a220f27902f07ba5e919b9a2cc7c3ae539171b8420c7a97266dc7391574f312930a4ff9c49cfad9ec8662570f27a6e34df61ef418d83bf3b4d7d6ae66202ca53d6f6add84b617a40df8bfde6fb97fe383c658c4df0154db390532749664a76f5a0791bd8977d36fa9792f46317df8a6dcfb447acfc64338e420d6be464c6b8abe64e616a57081966f0bceef3f41d5fff382133a9b33d2f30a3f3c73c9ac3ffae06a01165cc034f797fa94bdac7a203599bd6b7ea46c4a7279abb83cbaa9ae967d0c0781e62ad14980ebcfef89a7cdd7cd47a6b0048c2bc28a8dd3e5c5780ce6d6367940413e432c05bbc31d6e70470fb6c05cd73befbc8f6e362a2d58a9fd4e6c3a36245e0401d4b22f81a68b97593a857f51d13f045991bbbc5282d21eba496690a0b8fcc77bd6a55acfb70da689111f85d3b2b43736d23bf38f0dc9fa5b3f84c7db66b5f22abad8480afd037f7642706c7c3fcff0f445f0d2b8901421fb28b181ad4ebceec780980fac6bf2a2aa62970ddb0de6131c2b4b885a84109992904b3a837936dcc1c6786d5799e74f827b6d9beb2d8747a0dbf9e289428727cb3033fde18fa42bc352e7103c7d596b39b8dc031ce2a70418a4f67f275723ae223a9fe1a9eebc469bc9586a12ceb593d50d9dcdc8186652aff29289b807121aae698cadc311f10f12021d98da871f32219729eb8d0c82da1117eb13feead7cb7c045cbf5492bd7b8762ae9885098aa3cfd31e6f33f9951dbbc6e33c9f62b3288dd38eb5924a476ece9848750aa2b6342e19aadc0e4872e996a49846c5f14eacac6bbd9695564c95a6e5cbc0b684a806b7ec84b8e4e023acb1a3c692f0d8a53b5b599f223b2064e132e0075bc23bc27e0f14cf57e7ddeb30b9d4799562aae10663f0cfa9b85d26320c18bb1083397cbb47ca84157caacb8defcf831314722f8e4629b1be586f5fca9eedf41c70727ad8194c7d1ec4144033d37871ac0e485d4a7c8bcd9087663883aa0cf5e179cb6c1abe039e3fb56df8d790d99ec3ba5d7b2734aa5ca87b6f3afc7f51aaf7dfb6d5cf507d640e4c5f1d8d21da2c8732ea4bc084ff43e7ec95b0b8518568d59bf0328c616e68e9e6df71201475b01c7c4a1535a54e052c5c03bdba44c12938a48aa83887e9fa58b9c03447c2046c95ff6ef39416987d2445e20e5b946c0f8aa1541c813ba0e9f344a5c0740f912bcd4423db56e4f2d372a18a01e700dbae1fc8b8401fbb3fb2fd18782dbab373379e0939892ff5e3f787e4488ccf6e9e6ce46f011d9be3cc948439d2f1807783755077f664d4ebbee7a11557cfc1f731106a5ca415138a0932f9b6591900ab5fefeaf607c5f562753b745c4d051d95c4c721c85886bbf4854da5e47b07efb440991f0090f44fa8155cae79155d7be3ae13928bbaac4d26b36c7fdc940571e85446ab6c0b7c3ae37f27213f70b547beb06def802c9603be47c7c8a83465dea9ce666e25f63accc247776fefa080d2c14b18ce42cf01cb14c65f3acc87ae38c8f5133c98a9c27e9899ab5d0aefe5afafe4de8841264f16944a576bc9ee6b1f240aa888d4b741e73b2ff3cb4bf70bc8d88858df35e105d347c7082b700cf5cc7b5339afbfc4262dcacdac8f5f49bc3f58e39c10f18dfc0ffc0484a7ab097af5ba1c5c6518e0cf28e353eeb4e32676798203686383d756e3cac719b474261300642956fc26fe95d06de7f539b80c038689a16ed6a4af3f4631f3f117e2c5188fdd6edd314bf7c65998a6efae320db65d3a3c3df3c68afed0373158e6b5ac0b5ab799cf1f545f043f6566b99c6c92dd8b2b2a1ed525cc2670cd28967bbdb088a448c3cf3603a64ee8be6b88bdad419b0c045ea4780b67598feb6a728198e2a1fbcc51c98a19dec40ac03e99890fe4acaf6f471c56bbbace8eb765136aeb7f9a5e19d39fa3ba126d858ff445918c11268c7d61e842b10f96c60c68ca5ed07503d4e384516bce122dcc3c8c5ed6bde33ecc5c478edea38d9cafadf3556545d6b0b62c8e68366e065cf9ab0c6a016c0b2cee5a5b8338a2768c2286b45fc14df2bff1cb81bb608942965040b304c54ce03bedbde8433250b907ee3494ada4067f734a65cb77ecc8adfa541f5af5801fbefbcd21ec27e80560e4895734ea38ce65519402152f21e2d5cf5a26527d12ea3f13f3686d734424c82848f0d3a52d0480c77a66b5ec18292bf3c37978ab74f74a67be837aba6d0b17aaeed629836b7e94e5e02255e7e7b3420cfa1bc3d8f022f7bde072b80c5babdadcaa6f3125c552a45e3fef0645de4b98d5ef17d6f5be65915d9e940700b8b81d71630ea6c645d75ef27935e0258dd081a6a9e7ef85f9b9d31705536d9f453b1d025d58c6b759c2911c8bc64241e381c83b5e42fbf6b4277fbfabac7dc980992d21c46955a9c477ec1499a42069f7117aa47ab4e8e54f53ba8d5907aaed026910970ed8e49bf5e094a0fbfe10a4ed4e4a8da4a6b4d7e6274c3758389638db94b32708131b52fcfc4e385f96687c5eb2fbe872cede00d52cb01f28b77dea750353973b24d302e2c7f99d3c513ae645ec26ce6525f26c8f5e1831eca14c12cdda68527de46afb69aa80f1280fb796581d2d830e95bce1781c2ed7dc6a4dfc674fc2d513da90c7f9fd7047bbf46e78fc02203b3e1ea564f5740efab1cbce43ee26b25ad4082287f40e8a4449e69c8bcbeb8eb99dbfe1540251b7715516372af97745b97376d9bd89e958e4d4999b01e0f0cd3314bc146b79c94e33a08350ee6ccefae484835b0c15bb73ffd6160c7c5562839bb659a11929056a8ae2e7918a20010274f45e697ff2c21f8d8d2e58206e0858bcf3758fe820dbf01c61d1040ee91afe0e7452f300b3795686d998d848641db07e4e565fb01e6b365cf0bcad57792568e1ff623d54da197b9ac3803a7e4bb3126969542c5ae6cbdd5f025ce076c7a6e64c4df7bd00809ecf78456427af988dd6c8efda85935f735bf85398f8b84e2c5a203454af357dee0ad3217e17b2853e712d629e2144c0689e2799b25081973cbf7a7be20c69df9e680dbf231ea2ef23086a22bf9a832a1877da26ff46946f8ea417624e89872e2a425dd964da423190894a2d43b9859138d2a8db396daa5dc528f85e31258f8881b0409f4525d2c4f64316bdfa57fb3c8d916e8701f043b0e0373b9972099908dd10bae5ff07afa571360205ee23ba857034d5ef93fe914a749d2a6516","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
