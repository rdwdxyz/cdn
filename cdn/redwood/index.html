<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ac3c46a0236cd2e57c1975d58743bd99f9227f0ee434a0e4cc4d62486a2bdf97f78357ec52bdb6029f9793899ef238f45a3255161f56b3d66c697ab7d1b01b16bcf186e83260f221a2e70ce173a18a517a013c6b1576c7bd6d174644fcc5a4d92f9f10e1de87860862d0ef8c5f15d06778114a5fde2d8f201182f00cffa3a83b0d824d6bf024a33039bedf4279741df9d61e8adbae80e921e1faad34e538d7313d544eab0da4121eb7094b6ec93a7687e60326adc766a200e81a52ab3b472e8e92b7e7e1b45ba2ad34d8d481c15bdf5bca4a33613f457994fd72a81a1f01c9f68d943f273e2287a0183d1802d7c4437380d9bbb816c0e458822be8bece4d64e1673d6990ac50fe2ac337614445e9cf80e510cc6afc2ca2c1eff2a20ab0ae0467137aed4a8fbc2f2bab2df9904aaec80c9a935828b43ea9ba3b06f142fd754c670b4ada388a49da2b14747ecca01d284887a59f9632af6c58475de6eafd8d39812e79765d3927e0da75cc509f0833577fbb7a0bcd1fd86b32317225f4d75712e5cbd9411177fb15c7c3647cb8158c94c878dde3f22180367ae04f93d6a334fc0c9411b7a9e9e20e9dd6b78583af813397e7484797b975acfdcfcc2d7b889a6eef3208af6b84dfbe409304a7d0f47a97ae9e1f8045351eab8b5f1efcb27a88e0eed855ccd189c55264d9b9fe686cbfa5f73aacef776fb8f0423ac3eb6a0d22885c4551b100094f85ff119bbd306793640485d06526f9d027d99380fd1469e5e6eb4de6c4176f40952638c6621631f72afb3d22ae32d7de54f9bfde77fba64e078813b773a03c58d5f0fbdedafb698f9d043ca909c5a06dd0fc4b047a4e95e5281c850f1797052249aa9eeb67258af4feaaf899ee7d2f75c2caceddc0132f23893bc6f43deb96b086c737741baa5e8855d4c2e4339749d55464042445eea9d1d0871080351e4deef878367917de0a31b03cd743e080d77169a905e807711179357bea647ad408504eba7b4e72a6049e91c0596e6ac574bbdb0c0a1ee1c97f4cbf8dad4d688b4537616e4a4aa00271a1e2986607130219046ed6614b39057e512b1a511bd0b3274ecdaeb634e3ef6c7be303b7b0bf21d1bf2eca54430b8e53267da1ff614e9ff343c3beda76f7af5ada8209d3ba4417883916506df7198bea902c125f0280bda03f69e4141041dd4db3227fdbe445fa50e181211adf3ce03f7adc38e0eabf98a14ad1c42e578a416db48528edf6500afba5f059b8d43aefb042750fb3d7c6b1b52f993dfc023923a76ee86ea2315979bddcd8e78b58007f509ac96f154d8a7165523ec1f500c7aa7346801a6f031b3e4796a0f9df4a010c5164899d1d4f6a1621396f8d64aed07528ec8bd2238066e6a69aafdffb66de6a3c5052caca35d0e1c632a45a02e18a436650390055fd5e27cebcf67a786c9278b239ed868f8d2c4dd5e0233f8a40bfd21ec7376d6e64bcab9e70d5be66d3376fac2695e14bdbe8fe00926479d895d842acfbc549a99d1a88e200fe718767a5b98ecd864a8bd76c6e629cd044c4a4257994220de22809195d02583d05e4f590eaa818a46fee067c6d222d1cc5fe023cdfaea6d0d785ffb757caaf09fc7be49440b3e123365b2216e2d48a09520f61ee9df5716cf715f0fdb5c8aee7bd6da2638b8b9044fc62bf11b51d9c5fff829f13a902106c3a1d57fd621d233f7e6782e6f4310e154c242af0386afa3c715a739da997c715df7a4d0c5f2a55672195278323d1b462fdf4dc332c7ddb5d749ef7c6c47dfd595b6660adc7bbac2aa5905896dfa1acced1741644ef9cfc11049be1f11932afb6f269b56aa85aa094c766703c9d1d11d01b6ece58579137d85cbc06b45bdd1bcd7ed11b822ff4ef7d4b7eac311359557af89c25666a7ddec6b7f6d14db72438bd1b8eafeca9075de04d559fc7ffcbe119c6f1a0ab043ec272edf29ec29b1f938fd4d0903b51fc0a30f747629126bab1b394bc3a591ab4fca39ba45e8c4f2ee06151fee662d244d696d9759235789480edda1d1e9dba3896f5d428ef37df356b07a46124ead00f4ad8ace43610ea115b79442421598e18545dabf84f46f2517d5499be4c2fe933976279f79d57846decf8a445e12b378ef813788ffe8f082f34fd47d94fd0a0962f1e2e3ff0b7bb9d1ca1d7f06bc662a3ee48e8bcae03c912e47f347c0393e50f427bf62c1170649973c77033078d746c6565c7b6d341978a72c8af896be8fbb608ace9bdfce43b05c9cd4f0de81731fbea63edfabcb906212167446325f05dafb5e378f4fa1130983188a1f31efd43247f5dbd439214573f1edeee45579377d5e1668098f459606d88b6c50aea97e82937f9c72feee2b8e4b291affcaaf51de7e2785e67a72de15c9af8bd6fcd71e401d2cb4372d6002adc61298fad25c2e0704fea9c978bc86522522e0d558a9fabaf24c46601aef89603e7e31d2d49b3722c2b24ef933d581193724e91077dbdd647b70330a24c7066131b2f5492ceefcc71147f19bd204c4edc3db8912ef40d042fccfe57569be5105185e49d8ddb4937facc3b4822659215af6619153eb412cff1a05dab0def79e499c28ab67dcf65192c3ee38c1b0756cbf5564bc560a079c16492116aedcc6dface754bcb388edd57491c7fa7bd858868ebe9aae9ea4492cef420bc8eaa0443bba78976bb9a55734862d46f80a66c01824d4ce19f666b595af1c2ff9099e7192e61ddc5d923eec8a345b7b23765c4232578fa9c15716fbf03f1307bc488946518211cc40de82be5b63a0425b6bc96fbf56694ba9538466a708a41f69f3e063fc56b565137861770186d7768f12a1fd3aad0e6eac7f9351f497db0015296ffab85071fa3157efc90ac5f0b431b6c7475b362e53f0dc6784be5925f703f9d47e1ac80ef1d10b83a62b67f4be827658964e34e47c23f3b12bd345de00443b5d88ce21102138762afa4f679b1a736ef4ae5c1a956e6d707e2a8a103e7418964022c3cd938ab83d2f8eb530e14d133a35008c42cc487b560cf3e343c397ca97dcbb1fd29069e940abc1aaeb28fb52f798d9a8d72c4a1c537a07bed7c12d7aa65e12e714b3957a0485fca01594ff4b86d7de307533836e073d389254f1ba529dc3c79ced205220d93512ef564bd79fd24757c1e0b977d189cf799261b4d867ad4a0f5f70772d88ff3e20d7bd1ee5c6b762a921ecced5d5435f7d6abfb4daa3ca24e7e556a127320e8f23fb873040edf6d990b79a6aa683c0a322994f825ff8011fda5515b583b42c50e3b60c2259cadb29d416aa0f3181d54697cfa5f837803b3398be855f6b0be02b7472c05bd16b609ab938f9c7b66892fc840ea2afa3b693e8ffb5496f0eb825bdecac1a82c8597d6dcf5b6db36e2aa62ca4bc1717c7f6fcb17adf6eff3ad3377792f458fdb7ad46c112e00aadc4411d04572fdc830e759618cf4c7f45c2a7f7ad2b19b584a55c695736ae046d3a20fdc6645567530966b1ec8c4dccfa4c7c11cbd93675823618b61de954c2b292c09b5e027a59e4910a5b6b28f26fbdfe6fa49b8f2c345872aa198a475357faa8b5352d93d5e6a1198c940fa4e9f378afbfffbba506d2e5f348be574c0f41dc831282b952a1900bb6b53bf4194e9a725fc3f0e0ee9c62fd1dcb03258230e27cf5d53245c9537b6a16555e74231efd111f0b8483da500d16d343ea48c9b6972fc4f2203b5c1eeef29c7c2652a324cce42634bc37a9ac7f3e80ee576fce5ee6a2065146f3cc47288c79187ac5d4f5cfb614f089b78149e4a80306b3d034c47cb097a18519ce32811512420cc05f4db9677a5c2aee3b30349aa717ce0f57a21be00c17e8a1014202a0ccca63e34149fc9a5b4598751a0f170b2a7f063f31e002e94d6ead6b0cb09145fc61e5acd036d84fa8d409c32241e0ea5ff14a4e5216faf3bb52af1e178c639cc96d069d5ba94cc78faa9d732baafd59ffbd49f00ae6d043a1407ed88401c1e20d5e6b8808edff2d9a358092e9bf01533f36f760c5689ba8b302c89aab1fd9cc45dfc0b7f6ebbf3b54bae046430f96290fc6e1a03aec9adf8d6777023bf6398332ef0b9aa2002400e137df011d98c79a3bd0edf80dc583b7e9f9a4a2361518bb44ffc0189da68a98a1b5f3343543115eddca4257484c4306e92e0f74f5c7e8d16e7e83527ad3bf347af0d4a301b83ac48ed43e6219990ce286478346856813b0403be3a90ff59bb61dc09af894cb1954389e073d80bc090572a61995b45042a4f28a4fa180eb5ce82552005435268d483b263af01a6af51c71865cf9b42ead87299841a543fe3cf7338f4324b2c95cbc135bc69e1a70f2dbf56e40fef97921a9a591b519d5f910cf9e33982ed8ae273dd47bd65b2672ba068a77ede0907fa193f185b42b856cb04db062fe35ca0a806e28517996738f32aa2e080209a3f217bc4d9268d928ae8f190f6c539ee6c2746f48f0db58f122d19f77caf987bd4ab0588f6ffbfb31f83e856b0534f087e29e86ba5837ce72f3b83290de6395ee0499f70519699924214da9c02cad581ee1f7417ce57f0698d1330f8306f4e8abc16f5f0eb703088c98258f8760ba88f65810db7d0a7675b6b652d690136918880327b48708077bbe171528f4d502c3cb5d735c70c3f10e11f38a6bc552aeebc3fded6674f5f079ac8b95beb6358022b8868160eef2970e25beeab1462faa929166e5d75cd8c0c4c7a178322b6710e84e7e4312106e6a322194e0480f963738aadb7373cb46c6db38725edefab94563102af91a0b7f2a6d0950c55e19ac89ee221311b66465619ec4e51c6977d6432007f9efa2210daacd151084846dd52c733028f8444140e55e887a575a9c512578001f2c1ef9ea073fa59285a870700c492eecfd6634ec2d5590a50317bc6aad16900fa87f3efe9a507fb6e55f28e160fc2cfe4df54285a595abffedc9326aff6fa29e7d910e9f580c316a1dac640ee92e552908b355a49d664bc3cdd514c4ed29206cdd03d3f8dc4f142c40942fb1447dd6c28658f063aadb5e34c16c2fc35872aa45c9dfb9c051cd6a762cf2301e6a144876be43729655a27e009d01e2c4b11f7206f8ecd295b2683de6ae9aa22326b92a8a57c95ffd5723e38145c4ace52f8b9771c065278426a89c99ca20c89b4d7a57c2a1f284c60b06030ea95262dec32005e893a1812a36414eef1ee0aa19fd263c1bc88e87b495069b1d23cd0fcb6d6e6c8f86793492297fb5ecfb2fedc75a31b449352b09255bf079ac7e03bba4e86ae493abf4d07be6038f14f2f0cef82cabcdd882dbc3ad5116fa39ea1b26afa835093d08af7e71c819b3c89b3e337ec4f4c5b09310a55f1e02a2b859da1fe1c3450ba5f4a6172fc1c0bab9bdd026f6ee26a7863eb8eec38d17f98f74cf243f3adb39ad659586b9e3ec06c946ffb6c03ada52e7de4dbe25467ce0f81b70653ca7dcae5dd598e6ee7237eb563b05c246981b8427ca0c6d04ee10af8ec5cb6404cc49997d2de27f6572e46626b411b77ef003fad85ab2edac044823974b566de44e3863fd7116052672e4fedc4242190c36cb29d77649265cec52b45cceaf772fb9549c8dd70edcf9e1c6bb6c2bfdebde20638e38e340cb1c52527743eac78ce4f93d10ce80930ed40bec7ebaea1b03b307c45b175ce076e438d2318e732e6ed2ea1babec1c9b242c2f25b10b4ba7285491f871e270c4820e8a3f873f71f0e8ae1060ed3a39b1250f322ba9fad37bbd8048d9f6864444aedca0f93ba637f84ebdde335c281bcf3b8b9b5d4dd21d48bbd1ee97a4195491b7210d13275b63b1ff1a169ae41b808ffa6f5f25d650dc2cad0e07850ea4ccd28b2f5d99d78fd3f34bab44630058fb04053ed5c1d2ba8e2635a47c74fa087a921efac262e3b16ec784f55422a2ba35d1bd754895a3c964669223a2c1b430fb391ee12b08390c509f11bac2260c2926d12a1cf7a4bf547adac633a361c948bfb0cbd2c5f753c20c91ee695682c47960ba66e3860175fedc12acf16a24a020f55b8a04b46ca2fc0e1b1675055f1a382dc6ae8e840b3b98e8ce0fe0331cfdc54c9d1d1945f9d18c0d186941a1ee9bee99a96bf18f03d371e952fce682e17125eaf179bc61ce38b21f7f1366fd61d7c8ef2b7d27059e08001a9078119320bc99e696919e1b2a0d024841814e1e25d3ce67e91748b4b151685c3aba1d754beb3e48a196eb948790b43b6b212e5e92365ed5d0c93644d9a4fe3a760ab8ecea8449ea17de144e0e73561b4ec96eef4e9cd902497d14c586bfbe40b59b6b1fbe2a98d5795ee0296fb51e6c9edbf577c0f05386d92c2a4a35171af589572765b579d0a10506f439cc635ece26a7620911ec8cd2bd67c76282b42078866d60efbe1b10c969c78a3a7fe7b3a8f39d60b5e18e81b5cb8fa9e8ef80b267f9f7ff6d6421538d3812718316e6e79b6b8dac70d807c4c2a8b530f4999c3ee4a099249e453045d87f8df3e0a6802f74f00e292e343f41cfebd04b815cb280084c12db95c894c0894c0cad45f2a9b31981e26a9c181f7cb7ef775ad7de349f53e6aa624a844398badca393a450d63ff7644a6dbbc5461a4cf988ff731eecfeacb38a849cf71e91f168d95a5e72c58c0a126dce67fd5c038626885184ea9b02bd67fbbfe39a6854b1e654096cc2ad6ed1f5077ecd73ce9d9286da6ac0e5c0188ad94bb2f89bf70cb5cc2768968d0ea06ec8b1cbb2a31788e2fd8a39e4c5ebdabc95e409b2ce6097ecb07f5b0fd34b891ade9a1013c7d47c05242214c84c0986f35e92db4b9d1904b9579793ba3d38bd6034d2860bc976fcd60599409465be4d3e79e6444fe75d11b7d7005a275636df6a9dfb0a146f386768d08b97ecb4d6346e4efa9d20d28a6483add01415e1e3e629258527abb2611715d4b1cbb8dc4259be41e740b40860ee960f9c3503008d07d1b514a17443ec4732ab1a884d157007f976f1f3bcea6545cd6dbdae9bfe4f8d7c70e6424ce1b7f72a1921d0a3b9ee4e5cc93447db308cdde3c01bf3ac6bc332a04f3b34435ca5abcf4c7de36eec516aee6da81fd0b2fa9607e5e2881eeb5b1c1baf260e89bab556ea7e8eed5e50f25a4468c6ce1420db0d8635f57ea05360aa617542cb78bb4177b4959b3601d0d7e82ebf36f133815f82ff6428d6626b628259674c88646754d8248e54459ecff06256fa32dbf65339cd1a5c01bf322275183f31d72243cfa2351d76db54bd2021955ebb60f656bf8ab09ba0d0fe8364cc85d28409345079ac5bbeb8a92dd2b6d02038f2324da403814cfe9b4731db86ee166e9533a90b933d8ed4536ee3189f42b8abefeed94c76af2b7156259c0bb3323e831ad51273ba6e48df5d6cd365a83183088426136e39b53a6cbed4634eb5ed3643b76d7dc06841c053e053efbbc2a37be44e01ed831024b6b6fa214da0d22db36446997ded646f35528ced615ef2f174cb11a94c3658c5db847a0703792dcc241abec6bf4537821836827c3718c109897c0b5678dd15def26aa345033420584bca26acbd96772bdbd8096b2a995304d0018e87f5f5423eba2b0845e9ee594e236e74e97310a207d74f7ca7ec556b3aedd48acbd3eb6bdad946506ceb955fdaef19bd6cf21dfdbf2894d5d9b5ceda3809d54b7612f6b8f9d41dafcaef978696479a71a0837a7686ad45797601c3fd89c84fb70ccedd3c11c373c77b85454ed465eb1544b7452b38705793a9d0696c555ad310fa08118ebf88554446e3f8425b10fad82546bad7b5ac7bc57588067939e7962074be14dee3548a95194a11fd3e734acaa896dad2acfc6f1d7a63a7662a2bb3b70f68217a5bf31b62552e9a2798d13858ba7381ff1725743fe84d0e1d7308d248c1204e124872de864ad91cfc424d81348868833d75455f76ddb2a19994ad75ab85eb7662c70e6f64645550061b41844dd330d779a623dcb1b373b6391558e87d459ab5112fc57249483a7589be4cb170fa275cf8348e2c92e8c2d8930d2b1f8b752343e7642b4877dc86eedc60678887a9c93b0609728ba554aeb322a6b5780144b52352f70e146dd743867c38293f030baaf4bb15fa9a15515e912c82c9a426a9c4644e578426014d6abfff5787b3fb2dab6093c284b8166b8f1408e28d930f4e43c3be45d05977b48c8a98c6cd3fc0593c0c544613000957469407105e32da66f1b0b0fc556c8653469cdc36c198f5d5b0c0f77d7217f1ab1301f41445a022465d9d2132217ad3582835e20c6c7e27df125703fb69317c786eadab2d064834e5421f55c378d763748bea7a95d8c787f7edce07db779491935a22643f42e53fcc3a5f4ab576da273c4bafdbb897af693c30b09e12783e87631ea3e0da4be6e631bd7e19cac1090f5d894188891dce0193e4ce2fd685f5e5a9fa28795a41f8feae939858c9a716f2da3bea58725520a22fa6762c5cbe13c4225dadb2bd7be8209bb5650a3c07f5fe682df4db8201ddcdc05009a7f26709d6e2a6eb320c51d2361aca100fe67fe78e8185f8f1d2fd4ebe34d096a117f7da677953a8b7fa4a5040762094285989c523387119b0084ff107c08431afbaf464a89dc219fcc1b39d9217f65fe46fd575a1785d2d2bd3ea3808dcbc8b2a2ceabcc0bc5d159265eea5699e09e7e57599b41bb165e1dd9c248970353f5d178c0163eac6a5ee0f268a56b41ba976c420c36b066cae7e8c045867493eed8ebb2d023f97ffd1184b50a4f570c1c058882ea6a937afd511e7b819b108d203fb477ce5d6bb6e1aa465062946962815fce315448439d48f63ac6592f2219831ea58734f920e14afd2f1fbda71d154b475910d7d23da15bed88b289f8ba58476c0539d7a5b0d6729a46878572aa38d72c6129bbeb03d5c9dd4ed531209e29f30b08737bfc3da20e260832601ecd6403ec76ce83c234af58f3afdf44bb525618427173462949d54c370a5b25ca3d210e383424c4522d5f0e799a7bcc13387effab527047ed4a37005fd5268ea3bbaef5ffa4e13c5c755a518b561cb7a772e9c2aff87e77d82f6017d8a5a9eea3f0e51487a7dfbc31fcac0d1b4a0e150b8e2abd3ec8cf080d77c11c57a5e24650a7894b431ba70f5c35360f4febd48da216bbeef0b6b61a86d103c94a7918744824dfdf8f1bde923cf6c082b4ab15eadda57f0f162f784113795c7efc4a55dcd13c2b63bab56f5f099247157a39a369b76dbb1926d48462332d72137c83ae25b3309d3867ab8cea7a0b039111296bd0bf42105818c6c58d34f28aef84f79c2a74bc0f72c75f14503bd15384225976b3a7163a75158a160265d51c5b7c1c49667c3cdec7ff9a9ea17fb3c858de1e2745ea4ffc65a4c169fc07c22bb2e67a27025dc628ce6bef809af88af9e6465292331d9712fc2628d02404680d6685160a0f4371af321420a4a084800adba53d5af4042dfcf1b0b2c1bf8ca67a2a6f8e207f4c08c7abcf555819f568e7942797923d4da79ee74a164341f02b78b939ca33a6f9121d3ea68d3a6e850084de55cbd5313a615998d560706b6a7ec717d19794e089e531d2f9070b8c9cfe99e1ea2e9954b226138307ca4fdf73aaac85a239d34b43647d52c7f1724d767bd5dd0f2a85fa81077403ac4df075046f426d526c3f888288accf0ee8dfee67ee3b7794921830054e1364c880a903df305c5131ce5af00e8fc0b15774db9437cd29c45c390ea3efbdc9afc3f451a009952f2a2db71ad2836110c9b120238eb26d5dbb1752f73ed737cc6c43876d7bd9f3c67985b2eaa95609506302536aeede372c5f1bdb23ce93bcc3fe1db76d2452b35936402c65aaa4cfde0fcfc2c49bddf7e64bb459b011f1f326dd52e745e5cd840cc721019b34c179cb4dd09a69d0e2794a75a98385e7653f4eb6a35e285d18c3bad5233be5ab0d37a6258b49785f6680c2e4e6a163c697c18f91b4c9fdc8d0e1de57fd133cdf28b09c9cd461df6f7d739582210476186766fd91745005eebb8618ca810ac24f21e6e60acb1fbe560a4c46e5cef8913437651d01ad220c35fa8ff7c3daa10a203a57ec7fbb9c3d89ba56c1f41d1f8c7fefdf5c3ad083b7aeaa0514cc769ff0459b9a84bf0c0bcb77456a9bcfb6e216d8bf79101a54b7eaf5ba1af42e79d9ae6a3e904bee7cb8572be64efc508f3268363b6af101a42b515f1a815624650d6a66f408d5e23663bc0dadf7d0459b3e376b4d46c163e5cdea586e749765c698597f7b1555d8c02e0f6aac2719dd9517f98844e177f5d97b1074b25b4f3379e4ddf2edd100ca5031aeb8a22c76876c2debb2466dea1fd2d4104665ec73c74ce684ea8fe65a27db0dc4fa6479a73990ac2f978c3e40463c392bdfbd5a564c63717ba301a4e9f9fc2da647782e81a0d6d2ebde0f993f0a90d85e401616c29393af5c8f27b331255c9382cbda62b984d7a0ccf1bf9e5ba475e329155cf95eb63c837a2df3e9e1def72fd0d398d736be1d083e39499562e1f0109b8d1f84657b5f59fb2cf1177ee4f235bf7cf575ccfa09dd07fd77a52170cdf91dadbfe3b9d3748a6cd9747ef126643c58a55ec1e3761a9820723838292fb2c6317a7df070bfd93f2dd3e36225f05180664b62b26125dda82855bb2e6f906ed33240f5a0987aaab837855ee93ab4b3290de46dc846388069738efcc817d5c20f25c27dbc474310e97920b75a5d68c463fb6d78c786f9c9d099937b9d6592c00fe5ac97e118502bb1b18ddb4e9f4688e0e95aea1b2208b0e1f1702375547e43f0bfa9cf7799af00f6ddcbe25b360bb90fa4c9a91c71587acfacebc6da8fd4f15225d148e74738e025e72bf7cae258f9cfdac5f0ecca772022878f1569329aeef890bbd09ad5ec1e8aea0056884ac489477ff32c3d8d1d4a3526caf0043071c2048efd77fc4eb88fb38071360cf11f21d9840c610b791835a9c7d1fa7a52ea7a3d88729e9a4f50f36aaeb409bcff633a968da7a88d7f11176feeeefaae0f2fa3372840102ba223f150b712fa5388b99ead45b2210e9e814caedd20ef702b85062f6e48469d04454703c05be65ad0fa721daf875e2df4aeb27c7cd4eded3f66ebacc0ed9a073b48b956eb12d28b641cb7662698b5336790ade6e004d43481b860e870d3c7fcc5c8f7bc1789767631e0d680b953d42068e133a91e159b49ad16c14a3c0b1cff5b6084fa1c010cdeb95f797111c27042521ced223fd339c9094199be6af9e8c2b6e4f178ce7474d86bd7d2c4e03b138f6bfd8a1a1f0d46d36dfc7ecf38028926e835f990369081c72ea64225290ec797ab203d96268d89bc9d14fa77d63176095101bdba3616ce51f1e74dfc9a6245ff620d294ebe99750e15e42962e47d397dc8ce648ff67e751cbf3433634d7df8b8d74c97032d6c177bd58ece22a281e77832db5f997249a1dcdcac7f45fe97d09b370d5f0fbf21877a5d7f8ca5681a88595d3a6a2fb76346d35dceb8a4c83f3267559a424438ef1f8935ad46ffeffa0c93d4dd9d0d3690d7c42acf1e0918cb6dc6e8d9710f43407072dc78eb63a4974593277072e0b6fc9f0be49971e6f85ade41df685e036a3d0ce4dd9e310b5e13f3001c4ad1af8e3247a5f4b57498ffe66b6b465a94f4166b0cdda870abd0df4a8acd6ef305400b2e81c7bf0a5bb4b9b2bdcb07d0f4afe89ef4251ebc1c5cf75e236a26322f5dccf7f184c347302ec277d46f1aca46cca00fa071aae0b707c203d88bd63cc05fec89397c8a4794bb59b8d59404776fe7db02c851434b39830096448a8bd508b4d4e90efe729bdf4ab2dbd497793baa6b32c90d0686e82fd894773466551e427cc5244d066ca89acea7bdeab8a714112076fe44ea19875b6a4bb87505390b061c048bcec5495ca1271414697f36b20835fbf89f0b8efb2432b8f6f5e80be9774f3e5734cfa4fae5ad6cc552cf4acf1a557f649995d5957fc822c398ec6db7a17c14a0ae3fbe3c2e31ac40d0ba805162e74881c2c17b9d44d91619d6e67dd8765faf35522eafac1e99154e6a8a0b75dc3315afb0ab8ca23b1f0676b233e7c748e3a407e09514aca60e419053678887a0a214c0cd18fac02aacebe30bb676459e0c5270043055916d1d3edc3e8c8fa93d82483d5bb14eaf328f9de94b4a6b2256aa95ece7d9a26d05faad575c425084f18d3930ae437e599276b9d9e3eb083dd3e1d58e687a593b19ae3de1089f1a71d996434d08a677bf013a06dca4ed64e0a21c45f781833425bd360bc10e9ed220a7d01bbd4b825ae871b1c9f11aa641f150b3da07d8ac8feddbe37dfba73246a07592731fb447467407bb6dc71e2291af6cf53813c83c3ed8e784c57cf2c41dabf1cf766375402948d653df829de9200cb278c60dfa96028c6a70309a070a3740d7d9c76a73ed07ba3ebf5aa27549b7b18d966d01feb874cbcdc0c4a458562cdcbfa4f652fa5f8c1429518e70d48f6494e7d20dd3fdad49faa37a7da9451cbc0b11504b0ddc89bbf7e010a35a8dd3acb245bb2787af96ff1781639a906ce6147184529b2b7ca6a48126444d98a19f6515e423c78fdf1610046c952b0837e2845370e38dfec19d6ef570811bc96dfaf3b8bfda6682240544719e95696ee4d89b7a1ee618602c93b89d8cbb62095e625d90c2dd9d279e0fda3f6cc1889c56a0caba850612bad6044702f35e274d4eb4b244aec069dd9da768ccd3f7ac4727b43b43f26528865295192c8ae4a3d1ce363a580ff1aa0102803b42ce8e3dba31dd3914d1130b69370a103ac0d48bddcaedc8233b9497e5b4c806c0a3c3baaaf0850a33c7a0fb94b80a98a7c9b67d86f2f7f4b2afb3f878c9a434f13d81ab4f0760e43c4149de8e0826a616986dd8a88ed2cc0ed514b5098ff0d551dfea21ca774e9af773673b1e3c76f5958b76cbe67516d56b8383e6ed5f4941e2fa1d977ea5d926b33f777f8e9d30c8e3560a2ed665d7f1c818a76348644110be11294268614deb3da1d24216e7a39ff7432f95361bc0e9ba320861b0835bcb44200a2416ae6442c4eded7fb5f4770c94fbaa5b8156b9dc90dc41c3f8ac786682e6fdd0b8079ea439b67a0adf6b448df3754e1a9d13e503334782e3283fd2a8c9e95c3593a5b314db19bff42de02d56909b91e279b105d460458730f8fc731de16c03faf24db95a1e01feccd26bc69c4f542a88277227c4c46a895e06726c2eee5aeec97588cfadc853a01fd631c67f49aab1dd1f26026c4aa541ec5a9f114fba91072acba8ba55eb3b3cd795e26f10749647f3b8e95e89511a8ce892f432af5199f1e1cb67a4549eeeaca794ebed67cd37bdf9b1b7c2a62f6d4eb9d6ed556efbb5046c57935c290ddbba68afe2ae53f98885efc2d4c17c18b6db382d9a3d1dd2064009d6c692cd152fdd3a56b446afead23d444840face077c72871aae2bf54dc49416b39daf78a955980040241d3dcd5547eea2a1a2ef868a5b296331c37268ec646f8115760a3c0d03fc400f647e9396669085ed3500a6859495cd559446cf5c29481ac30f0b421ed9a38e9b2ed3c77efa4ddc7efba49e1722403d5384b5d69fe41811d10d0218c811942ebcbd55854646e2285c09f41539fe1bbc378cb7a60c8eec676f4bf6285aa6845c095420fb557236889aa062b3d4eb2e7294c9aa0aa01f4765639b10d0ffa063fd0a87375197353978f4e64153ddc68eacb01ed15ccbad0ebc0af17a38df379f387c4e6a686caf8b5d05d107e78e0ee612e5f464a3f5bfafcdf36794d9cef83593192c457be0f93744957c6a83e1f3e9e353edcb3b13ae2c9a9999549e856c0a6a87ad2de1d5b7f788fbfeba37f0b9eb4a52d1076fc017131159cf63e4ea86d4fe424db4e1d60849e47cbfd3d09b945b4fd9851e071f4c263c3c92c0432129606d102d04c546a6f2e4602b077a3373d59156981f98a5656ad570ee6a6f6c2a993120e4b9470b93aa1739035dfcff98cba3c429052564f307c7a71621e6f858bf0ff33d8e6829e3b1515427b9d451e4f7e7778dc1e0d47e4028b710dc74d8a31a489d1da44ca07062f4165fcd5d0ec58bc63d32153841158ad187f6efcc20c67f3961151fb681b9ed5d3899eb54426cca98d87bda4cc23e9a002b9f72ac464d36c83169bb2c3168d79eff4842e5442205fb1bc1dfed425204c6abf97a8ce2d0d586f0031f99645995f74fe2d0cd02889417300ab79cd736e6775e851e9f61ac26a3d8ee7791fad52072a498e0d2bae10e1fbcae8df4162d7af80522c55dac6d172c9460af0ffaf1ed71f9212f135b4ddf5489ecfd202e1cd84adcddeff1a34e4c1dfec2f918d39d2ce1ae7c5f953a1ad7136cc37d39698f5953970385dbc4b0b2a4b1fbe61d5d9111025645b54615b273234da58034b5aec5356462c2225e327bddd0b9ae98814b3196da10f9f8f88cfb846130caf60358acc60d76ca227922ae4e443d89a5373466482405cc5402012b5bb32319870d812cd75dabd4006394b0ba386dceba14294c5eebc0cee50726e95ea2da304df3e26a0963941aabc656526a209b62acfa8d3d2877a1778f027c5f90c135d72e50135a5392c9c48522ba1158ea278f77f98ec588b312479af87f0a59dd95761072684428c8fc155827a8920d80cc1bc0bb5657b4169d7539f23c006c495afa6df56a1906ff6d624bc1474419e6e84c8904ec092aab7ac83218956ab84088460dab7273f4109e073e493fb1ed8bee3b1ca1e0cab7697885b3c5db4194b7cc3f8fdaebe9b77e35798d07d74372910628f890d5b964419c3e81700d8b6c07fd1244368c83c5961ebc864940d7982d9788eae92d0ae291b771de29ac6549ddc20ee602a2fa46d5dd348dd7fcfcdbad36ec739351a721a8412feb0b00795b2485be512c15bf1d3b90840e95bd49efdae63a356d37f5c2f42d510af5ccc664bc13b01f63b99b091080a80e0a6933a8ec572c6c58387b4a6a2ffa2d6e7c49bc1c22badd40d6d888145cc6a6dc6e25fadc04f55915a0d64142ae61aff5cc7db3461ea867c694966c4110ad1cc6ab0d569e86edd52d2a640705f59967ad94c5be48317b266d445e2adf2372d621b45832efcbd7c52f28c9487f9a8f8db4d8294c719ae615fadb0f5bca850c29fd8ae1918b887b85dd92c053cc9908db111ebb681d577c00aadc77d3f660dfebd849e62cfbddb14b53150feb38690c657705b7701efd2772eb2ad76c8f8c6174e9946b430fdb5bfda544439e48f78c85fa49f574310fa0ac049ae31a254a778eb7e0a96c50efee9865e9ea963db70a0405db7d36fa4672d9bc7a0ecf0cfaf93d8790aa89301438efa70f7b4d0fc0f871faa6cb5be163cd853e72617f943d0bdfdb547fcf2415f7bd5c2a1376ce727666fff646f6c0fd683fe6012b362e4eee97966471c0ef4e1aaedace95ab639a0ec599884e3f570afa6d0ee77910114c3985166fbbfe2e7dec1a7ced8b73c03848f2b6712ce936f253bf5616264b6f967104d3311c1fb2ad63aebce1c6e406a5a850955eb0f696a03905a9e07f2f58de119b2bcdfc1eed5eaef5529bc75eaffe5ecdb37c2883a8d2c80646f4b1ddb5cbd00d07fa6e4a88fbc71533c4591cd46eedf6c31fd9aee9109846a2e10e3e5038378d59e30a3e2b0afe9b50990cd68b576d5585519e7f04c186d2766e9691cdd399206f4e1d349bab761d39868620fa490f8dabe858c99020c54903cfc920659f657af405cde5b8a68a3969d6dc5caadb1cdf0dcb222501f02cb948e0c715530e4c444dae70b83ee62d986293364220daaf6b97234dfa454f1baea6a348cfa2a4614c0fa18ba9b4282ab4e7d2c5a6a9fef2eea91fc02567249fa5e7a1eef5c8a56396c12915aec1b8aa0c99ea81c61b56ce1b1479c918dca362d5a9dce5c30ec1278a64c34c8407e3301a80918e2ff7b8a326be5406e79d0ec5988f9d4faf989fee31ab6fd459e518a48424892ebf7748b32256efe3fe195f483cf964216e9187125c38c370d646611205ede275b47e2554d0182c7ae8f9cfd667dac64b812e6fb0839d47ccf1d8877f7be9a5250a2fa6962ba149ddbfc497ea556b5d993fa8c2170c48d1912b64185452f7da7fb132d040bb9bd945d3e68ed0eceefe566b71ef90c1889fc74a56ab3bc4ec7928665a3070b106f3512ac249203ebc6e93f2e975d7074c65fa023c1d382dbfa1c4f47fc144a0c63c87fd375d53cd488fe222a1f52c5ce179cc7620a90da4a95be6ddf4365ee9c4d9f0872d48d87f1305fd61373a534fe0f7c6e8e57b9bc0bff53a66b705636489c9697ef3d38fa5a071f2c18a8169a0c449408fb79f4896b8d820c63bd77c562ccdeae9f8edf39a9922bd2436d72f36ce631c9bf7e20346e53b30d8cfbc54d5ca0e9ed1ca525320b9e2dc664ced8ca40d2b88dc43e4c654e4b1928331f89f7fe9c18c8cb68a6cd73fd7bfd8a77cfe0ac13c67620d4eb83b2b0e601fdc94a576a4cb72156bd645ca6ad4226f9c955543116cf99241a2de7ab05c6512cf541b332bc6083a4c0c5cd0c685c3ac672afcbf1c4a442a83f2ed24a30ce2b42f977a1e11bd7bc18c102b0b99a1bd55d5d9388b19fb8dab89fd94501247c7f74878a362f3ad23cb8b2f75fb8fbe8fed190b338d199269b1d2af7063a68f0352928126e2cc199f2e3e923f091ab8877f6c8a9ced7337de39dbc7360345e19e1fb2b0c28791e0e32037d875b2ec5247b4c1ddd7b76a395a9e3c68ecf27e6160be3beac51f6c11b6ae43ebc41a292e274147f36137c118b3aab5a0a6584bc8facdf1a73674c7ff1f3f9f27e6db55912c4c59c123d4715e6891c83d2860fdbc8428555500e62b5b93f9e3f024ea04b003596d0df7da96f01a195701b7cf520cb2757914126f1fbbc4531b33cbdd8e4cdfa1b15c31cfb1b79ce10b3dca7b8f761fec7a1ee2f127a20738e83dfebe79bf035c29fb84641236d0073e9a63b9510e6e72c3de4769eaaa638e46ab97113f5fd46c604d76cac66df1899b7be0633bda4fa50ba51c8cd77eeef71ab44b7b9fc3f26ab9f9f84e3b1d417311240c4c3e1d9ea6cc79b119de0c34fa2a61027e95a69c97531a1960aa7b79df9bb87e454db1fbf160be708832555b4064a9bdcb240cab77cc8fd380483ddbec5c0753f421e303434c9bbeef9d3b78a7152e657fcde062a5d7912c4191cf25e133145c2da54607b1ffb8d61f3be291bcc5a2a6a028e2c9f60d00ff1b1d790783d3973de5f48dd639b2765e5b471b7c2cf5dcb6794bf97133c9b3e38c08e200c6106ef22c4964f73b2e16579c0f443e1944272ec4b8ca0b8d43f0607c5332ba06f70006973c3fd8a3546e4cb17c39b21bbe24ad2429951cd4c39976e81062aea9cf1466de86357942384284251f53544d33fdb32e362a6d9612f5d487b5c6b7788095b485b894cd2a7dccee11373c40c8fa4678a2cc7732e586f0e6670163a75acf55bad05efeaed1100f5626f1e4540025305106c1fdef4b24618d5b82cf032f7abe2dd5493c0e1b997704fbcd27fea2095e51b8343a051897e4280ce5d791348a841b0b336834088949c1c2ca334ee63b134a8d8a60872939b02b7030c085ce9bda1364ea3916e0a78cffe426d10fd3d3f901410434b0de8bde262386f6f0713fa815efadc9f8a1d6c1990680f78427e6273141a5d6d9ece40d7f5a0ff203f67116596924b996eceef94e62e6bd37d98fca93f29e18ad545186cb9b730fcac15e50ff7dc17353b1d148bcd0669576b1e1eadf7aea9085e19e12d56837ec9e9d1acc7db7407493e6a9d6454013728930e6101b508c107235d680426cd42522f4f6fc94e8510240ee7dc8d1177c64d05048036af24e9eeef6b8f97ef0b62e4a90df42c24c52668c265c65bf375955ae4223dac43135e895c16d88b7171d692e9441b0665593e4ab51b249f175dc497792a2e0fd0cea941910c48f86d5bc94e612e018f2830bf3a2437b03067b728bb4866e3a6c1c61a017d9d3a26fe1cb93cd94b3c113e5c5efcbeca83c2fbd0fa18213134554411c242b6dbf16590a473fa565f90e91e0d93d9f71efb45b7e599e2c260a95e1fc10","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
