<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24843177f2aec04b262c07e0d9615798868b122105301fe539e33f28f2b81aea960da2d903c698398a0e949d7fb5399ed43fb38035680ff378fe293d20eeb10c35f7fa279b3a1896da42917250088d147e9947f647546ca52185113743e81fce12074d936d36c3ff9a845bb8447d6ee597297953bfe0d3732382bc866b2d459b55473385639f887e2f7dd07f7fd8abadb04c4dfcda21ddd99b4e3dc5414d89a5b0fc2c3b6b1af8eeceb47ff39b415e55631b257ea9800057c2d84e9fdcec5f04be2155574a98f0ce8a212360bbec880b51bd615b61ec9ac69f33f4bafbd5fe0c435063bc67a42226ff29648026aaae654641588e365d93493f8712e7492b9dfa56f278ac994803303eb4e2b135eec515c3025e60c90b7b97e6905b9757acd8e90c5be3e6adda195c462faa98827df8bc90b7b3b3b0cdc38c3d3006735674e34fa20774952050c6c70d5e34f5ea4376030efbf85b42852d00f124a5b063c73714451632b8d3b40ec5b9cc1046f8c3a35da4a370395047fb6dabdac3763cab82bcec94f3f682b806d481183ddaa926245e8365f92c634ca6fdf5b055a2bce432717442ffa7cb4eaff511cbb9ef3c6960ed25698c6c4b16f707f53e2c7331cc501fb5675cda35268089d233ccdcd6748c1f61e205829bd5d2214b202501382165be63071fad8c1116816add24c1503789599163d82ce2cc7267224284fa836b37ecef7437b2736170891f4fc457e11fdb1086e5ddd79a94b294512fc07ebe3c2dce70a5684b96449bcfc5058a31e180ef66f84602cceb219627e9f801ae2c1597ec83717d4aaa58b46d739251990ee2582028e771e547e06c21a706d54e10348da00ded633624885fa4425135a97060bd61720a5e07de2328aaa713af9f47f27fae561f901f1884daff2c0c865eca2ac16852ff3c9bda3d4a8ee88ebcb0e8fc23ce1ee8dec1c41e5749d782a65d94fe966b9c50a7693f8a2c39f05448e74459675cd8cb7dd3debc478db5e7aa4c4cc5b42736b226bfb8efe71d04a68ae576018bd9f6447dff5b19f6fd59b8b2e8f0066b1d4c00c1f4fc61c99428c787d1e4b3a937959a1f9151c7a7c6d2f6bfe3391193acd10c35c733aced7bb853523d051af2f45ec77ff0f1d57284900d1144a0a38d8991cf74e7d47bf39b1bfd33497e0e90f72010f4598cc692762db8ed6f53f2855c952d2b58901f7fa27292ac3802e5aced799c77abb8d66285f99aca1f2d159d17d50ea4eb459860fbc0e02cda14ba7fc79b6122be422eec8aa2706c680c90c9734672804dcb8ba75e9711f610ff6c1a2b9bf3947a870e97119ff603e88ee34bb42517e0cbdc5e29330c313cc52b4a700112d7c7c12a269d277c1ac26f6b5f174f6051108b31a6e3ba479bea382b5471c18f2a16a9eb7f0ae77634a4b6d935cec30f25f1799b1f5a1b467bcc133fa271ecbca4e10d20737af148969f4f3825a7c092a8138bd5f2012b825f1d866b66641036e2b8e3e594594d050379f1aaf772c1066071af11025b48ea6f0575592374eabb2fd033cc17592a819ec5ffa4c977b4386a9315858207eb15f22dcf3c6a3c4b0d97726b830afa25ba87b2f5a418545ecd0b4102ba83d37c086d394d6e345acd56a6b8470cbb0088680630dae66f3d044b061823fa4db1f66f6c00443758976db40ad15467b5b0985ff8e26f8244f3681f53d0f7ebd774f0132c8e5ea26fa9034c21a9effa2f0a7d447b4677529e8e903206b42c7acd4c35464370b5d4e397793e730267fe90c82829deeac1cdc268c0d80eeb049721394c4b90da266cde12e854c6506b3055c3730b7dc23b4076566c96783a447466fe7f8ea759e217296691c65598ddf4416a1deda47a4c470f072bb3a47b82ec253acaa27fb952bfa12abf46505c0362c95a11d6b0ade9261b9b3fb2645941b13674a04a56e526a6aeb8784d4b0d058b281eb5518f5d4accce7d8e23baf7f401920cc87251c0c21c80b397e343e034a10b0619c38524418566e4a0801bb8a86f8f6dee4379b65c289f4d084324663418384dea31e05b1d52011a82707611e78d333fee7c991b264e40925d8f12935e674d28561d28d8dc4622cf38fcc949d03bdf50a0e4b2e4cde539e6e6361eb4b2f15c336853b5420add658e0d28e3f54a1db39dea5d2a1539783a487f41beb6a96038190479e6cdec57512d602c2e7d37ee9e44734480e719d00aa47a1e215c41b475bd5c91b091b40b71f311b533bb46ca21eaf4b897ce2f8fb37f566a33160879f258d97f38399162d47815c9bbbe7a6b3e95c8183bed5e44eda6ee3f0723acc553bdab69ce4600e401c03c783cc88a3e245870ceb23dddb59b2607febfcddfc789a7cf459396c54f96a62ec0368bfdb16e27ea93ed0059b751fb77648ae1463b4b9109755b54ee30bdd747eeea94cc2fa351b541f86980e2c6a1795c2e0951eea3c4e81d14ddcc2cac3ef7da36c2cad3f99452eeb947a5535690e0602bf61a97266f7d2fb91cc1d3be9bc93dfa7b32e58721e81fca1e83dd34b929b8c67872e9b3be8390173a8bb1827ea03f832f76e3a45f0d17f7a28dc6d1962887c2156e8c062f31c19752e6fef6669ece9bac2ccf8e003e12a2b585b22f7a6a805a0bcc1d38b4768d5eae603722f40a0d366cd33679e547cc6e2897c778f4be5a2593ebf80a9997773d087b1c9c19367f14e7f0af9fd5d03daf3f74bfd84cc4c5de4be7af2a920a160a6f9a5e11494e95bfe728b0bfc7201be17ab4014bcb55bc0b5622d7007ad81865ff998d466c98414a90e963dd7f10d693540f1dad35ed7d9bd2ee52f9116fcbdfccdf366addc6fee49f9e2959106bbba25750d0112d61abf1a2fe4e0cd7d070c3d474c89b2cb3c5f18345c2550f7082625e3349ed33c6c0e93ac1c8870849b8e0fb4b97327e86fdc7f63a31182bc4b795fa3b587fceafc81544d2436bd5b19d79624ea53e730c2967c800116ac101859ed763f7370c23841cc53225c8ded9da7c7d74d198a7ad838c11bb63b938a22c265343ebad52034fb7206aa629a12124a0d27b4ded04b79188d16d6afe9b6b1f1b79d8e29e7e7110e47e67f9b5e37f16e5651b7c5b1d98a23505f3ad05c1e6a99280c49e57ba04d5f0f965061ff5fe910016b3c327ac4d1cb6d71605e2140898364d70eaee037dcc6f6bcfb49a8993d0ddb10c195fe5e423a445f924a9724482655716d8a6748830ef90ab5d6f9e5cd2b7c9449740f4ca50da449ffa94a7888471df5c88020a00d025361cb04a42e9ef056d32f4702f9e3f357b4268a0c9a0a8aa84ac67c6e04b0e834f0fc22d7a2f3807e869a0f724fefab6e30d886cd0e9442abe15f07bf63647091e42b8d05fa18b17091fe5a67d4175186a8076044227d5ea5de4d8413caebaf755abb241295cf7a29bd112288c1aeeebfbb8e90a6387f4dda9f84f0e21d019e3054e438ba2f9a7d760256e73328d19e7af3aed13708a8082e7c4b46b5000555c2cfcf02ca440181f79049787bacbe33e0cb80ab58c6d0b60e56622d462bc9db8eb510e645e1a90664719670fdf7f2dc80d0d0b16a6fb2691f421cf57f56c8fff97eef85c39e58962329711548807b2a4539d1bb6f09771b5d0bc3dcbeaa85e87ecf8d5510563734db750eb0fbd3b31c815453a1f266e7473811fdd5997195bd9c768a2e4b2fca40ec83d6f8397b0bf35d375f4bb08863fb73ffc9cbad19c8e5802392922a0bafc1fd95fb97275c5deda4547e6e3b1479298c7a010000906ede8b8ce1692550e892f7a1b063223eeb4c729fb00b7923b81a2677a31e4eb6d72f499427bd7441423d79b949927cdca9cff74e023cdfd3d90c16cd819c763826beb44d95a69be04133e66efee6328397d997911baf11ba31cbc844d2bc516023a2a59f358a9825ed6320b25ff8c2b5e8081d4f7ec963e35b9835b02a049b1315a4ae7747b1fa60395304fec285d78d72bfbb2bd517accb72812a0740307217809c2dfac2cc9ffa820cf36ccd43e57e8f879e13b661bbd3f723cd7ef8457b636093274f5e88f6dcd9a0b905404ab52c429dfc54af5ac72a70505857cffd1ae91201b492a262f30ea50a16805eae5adb0fbd7654adf6d2c789073973023a7bbe32e437b1a9da42cab8a2173e0504a0b25db7e233641201690d549f69db2567bc4082cfcc1711351c0db9319a6aabd8351582607c1ba183ed676d155f4db1216c4acf5c9fa7ed0bcdeff18a5b9a2f2aab1180c6652906a33c737fb59801dbd677a84f1b93fd47e5bf607ca0dd7baf51d45a137697190560149c98a3704700c9a15796b299a697165336355cc4f0226c1ff3cb5a3d8ad02ef8bb6b487d5416ca60e522f14fe7325b0e2d661b82394e510ef44f09328583151ac62eb245b0a62880e920ac0cc1af27f261f60cbc7163a410731a7c4d06ccbbeae146e5433009b533735d8a96949fb40092aa38d482cdc53790442f991259c316dadac60b44ad1d06fd502b98067c00facf19b7f9ae91a209efba772fa9bba8098283227d3f1fd487028b743a51754f3650e7d4099a07c413189bea454379c7a62db08a77e2f3c08bf504371431724647d9a650e6eba5537b87ae5bd02f39a9dfc9bf1f110e742e22ff290ad97f997b4b2c32a7083947901ffba0e82f10a4ec6a7354421624594d2525643b147f9541ae56a80a25ba6c94ab6d9c3f6e86be95ef5b7fee7f3c732a6899246bc22f9908af358763650a001ede1a20f3f7668ddac6105b3799706118fe4868e57b29a3a417ec9de001c28177dfc1a6d6d43c06d1317745016b17a498bf70ae629b45a7228dc24a54baab6cf49867360962ca3819e2f208255527a21fe66a1fb76bde968e6ba4752cba0223452cd358595987aebce89228d2f19515963aef1765bf34c488f0c5cb40feac54e16330046dda030a426abdd7925a4bc530beda41b50251700a29c3b7fba98697bfb0ebcace097da431e7d87b12b8d2e907f5f82d061e43734cc05b2203393a2b369e213c74658d8b0e733c6ee527a886c98671f5a5f6f901672a3e91a0f01ad2b904294343b647130a22f56c8e269e232065dc5ca10c9a7854afa1cb8064b906194ec8beb2c8e31a3994ba63ba8424651b6e71580319259bd4a5c016227476be1ef008298ffbcff4f31aad0224c48e9ceecd76ff5aa31407b89f6780552068fd651b92a6324fa8f98d88673eee247ef219061a119b10e525be105eda05bd233e4763f3e600ee99db9a69be38304f6a422d86dbbc6dff3fdf702bd805b79f77828fcbe2d4f29203c1cf24516837d8d9d6d423f62ff72711872344e89604ddaeb48604848fb529980a1b9b4d1e9c355017927b79abd9f2bf5d47d75c36bbd7f85be95a1fbd8a8264729ed4afd58efc162351cc36a46972246c274934cac82ae1e8402ed2e105049094b202cdf53a7cce2fa70e8d76bdce3601eb49bcb5d1ae574f8de75bdbdb61c594a0ce746182c4cd735ea30921062a41f9758c161fc7e99543c91caebbdde52c8f1afd12772f4d7d01aaac701818c42ea711822098b322e0ed1c825bd2918d598b490ee9bde6014d5b7a5299166e538faf1d5f5e0496a0f2c0d396346be8729bc3e4d3fcbea2bca16715f2e397f3e08521fd29b81650476efb8667e80b8489aff5851c44e7fc8e040adbfc75c0d3e09035d8ff016d658f889973c28919b970769f3e210a5dfd585dd99af330e812029c909cacb1d874f463c3e68a2289bc836dea8d0cf527c5e8bd38d90224a32ae9e6a71b24ae9210a48a867c57a32e509fb8f928b277f1d40bcf2819d82da2f6baec8b60105f7721376244c5c9d24fec4cb1bd834eac50d7c4c86de66a9cdf686c8a4ffd97568be86d17f4d80712fe281ebd057f72c86565227082193c73852e5db1a20c9d47781dbe716918c9735fc1e078ba9a13c59ded4bf3d961284c237fdecd8df06d3a9636d7c7d8c0e132cef5d53c34be23c6698122862a44dc9352d0634247d06d11c6e843432bb39252e88736cd778c0dab488d4ec090704c7c96ccd588d008c85257adab056a275001214c7303bd7017541e4faf94d1c831d44afedeb10cf1b38c859aa1afeea1236abce0d14007dd23a20020c5cb1e16fdc47b75d020829093b0a9a5cb94e7d98160cea9343d3bb827ed3c52b2244cb54e92678a5f3f60722c375b8d183413ceea94179d59a558828a52f6ae444c7ab6876f5429e730600b925cefbe387d7b419f3eab8e6f977be631bb436f75bb5a4595bf8a5e9ccb5b988d17366fe7c9eed9554bf3e653485d5a2016f0f7e51073b24fc1b7625bb40ad657934b2ea920d5a99e17a33738d2a36c376cff901aa1c2d9bad0d7f702d0db4e09b7c4cef669888681c7b9d365d743d0a01ae02fc29b077bd5fb894cfec1c4dc64e4ec7ee59fe1fb81f6be25e2ee2c3303e02c56d9e236b42991b78b3837136f903894da8c486361682eff6ae12afcd991ff2fd0cbd08179d518f3c6a347e3f4b735ba87cbddfe4acc971cfddfdb73b0dcd84fac2228eb72a0d78b8e70494b8fcdfc09eedf56acc853bb38b661c1abd9e3602ef4a7d7abd8a7b82a7ebbc504bc069b137f998954bc891af025dda39837ee8aff128f905324ef2e0fe96f0e25c4c631dc63629f566583ff21afd0c51206e8e3f2a24d595018d85d0f621ebade72d50790bbb0ba2874a7d67da61025db131a85fc113bdb2cba136e53b6e3c06a79cb7c0861f52de93877a52a72ddcd2a132cedf289ab5cdeedf8bf75ac39c43ade0f0eb1f502184e6ba3624eb49c4d67991d5343e3cfa80cb31f518f3635bf1e0083f6235e518eb9fe222968653efda08be49f3b95d8dcba8842e86e4c39dc4fc422caf16912f0324b597dd9f5169dd7efa2b4a783eeef634b390313f8e5ccd0a2a1e8c756f366c8345c42756f8abfcfb4d20d1ecf0f1aba25c7df2c1a6956be04eb65aeedf5871f1ab404afc4d015348873e2bf95de3929e716b12d0a90b5b1a3fb9c22a6d9bc32f574162f5fb9bdd8888acf6fbfffa6e6a0ef3d7887f2cece9aa81615a69741f14fb39e6f2b856c9bc88d00c0fcf3a5703ea49e4f2fcc26665aec41c2c0533f221b222e7793a0e2af15130a3af5247f1d3dc2948696da79ced41523c321fd9296e255c52843bf0a9429c42b89f3aef352e014afb5ea16c46a78af7d903cf9bdb08694e6597a1e9d29328e339ebcebc83dbfda49360bcd7c80ea1476ea9304508406383acfb6af8dd9209a1aa1987f51bbd3d512abf486d05d99458a26bed5aa66dbc6ec835dad32f75280563259494cc2ba5a51714d940dd9cacfb9d93be81c78d39dd4c441d05370cc5e3fe481bd9b9f3e84ead2b476ae72387f21364f2685b98a3d745701c42704c905c27a14d681a44aed48b8b56b95552f58503676720ded8af3ad0476627b2cd52698e94c4b7fd363ea52cb3a6fb34a9e7e97ebec7e81e9e0067c148ae49a53c0bfcfa6f8d569f240102f2731c417dac79784e7b9eb237521ec6b47cab867a38b8e7124fc2b3a81081318defe0cade3208a369ffeef936750f0d463ef547e19e0f8610c9498eaae7cdeab5300086c1d54e9ceb509e96354435687822ae2e965433b48b1319e423a1892f78a0a67facf7b1ce59590f622073c619e4ab453a3fbd83b1f02189fd136f3965a0c4dd1fc665f353c85924a5bc34462d3e1a693ab61871f25344187a96f7ad794bd7f15310e8c8687a10d7ce343237d51f9764a7793c865c6e42613d6ee8d3946a07b269206e0598fc00095e3e3447abe43b9bff8106a7222c51b3bad125a27813dbf4591560b191faf65247ce954fdd956253103920900bc754d59d5b14424c3d425da66c656a2cb08c76339a4b1011b955e61821c5fc9324e083362909bc4bf72d0336d4f702999c941c39a9ba591076605f0f0cc344805aaf5ced61976f48d635d8f47a63f1a3511e7b1ece50f87fdf9159044389f7ca2409a11228f680d928bd9827364ce35e47303915ee37a62b643050e93af836b216a6f56c27e4c128420bf19bf4ced53ae33dd59c55deef08d4df8d006f8b9696719c238627bc7511431c38c18580b9c8c54a5113b82fe7ee774ccb0a93c5074973956ef8f410c7b2eabbc7489a8e8125de59ea329ee74ded1d65d98568acc258d94d6efc84121245eefda163651d50d5cbe575d2a8396972528bcf3cda5c9fa1f2f0a53e26eafa1ec7916fb353a37ee689000aeeb0e9d59cc38c10b2e51fed374256394307d6f444c14749da3a43ea86fbfbfb96f8a18eee68bc46860a2890a43c48f96b9add5e68708357e2901561208eb31386cf661fc49d857e4423f813a773a31637e3a0be2fc4f2ac6b5ff1243745b4066c63dd5396a4e8e6064abad2070bd2f1cbf7aa69f0f9cb8ab4b7fbdcc52da0fc048c0dfdba6515cc9f704c98efa2f8e287b331e8844cddc8df09b89c5dc2cc42106001def10f7e9f7a41379d72205f98529e11e907faa4255e4d33a93422ad0d147c0f67f9a2c7758b6e719aa81bcb59c5f0aed05e8e9ba89dafbcc731a1dac38991987c24fcc5f4eb2c92350485849cd5c5c11bb10e74f24e2480a6068575739de2c0db4cba7221a95be2bddbabfeb5cca8fd892e3fd832f5f95bd628ad2c8db235270eb1f282b196dd370130ae101d29ff04fad2e2afa9d1d7e04561f4685bd8bdbec14f63c10c9111a1213c6b700d2a1e84ff835ed4832421261aae053e57d5b68b8c1c0a5653917cd0f2e596bba62fc6946b9697c655335e94541b2e1daea63b93ba80c2de1dd7e350fe5073cabb07d30ab075aed3bf00c77043756098436977be845030afcffbd9dc3bdb15ae2aa2b71cd60f0c80eb77cad964c14c18c3451ff8ca8ba638e394da07840640d79249eb69bf8f901d6597deb8240788b1c359d9d71a3dd8df5cd6ddc963f4abaed42faccd39ccf31c603d907c7a7dd19cc912580aa5d10f3396d39dafad7c05db340cfe7f0de3933abe296813aba8490f527ada8211edb944d64b0572be4dcf4821334444fc5a9b7512d7be2a73b4a0d43792db36d5274c54ee237ee7da3f2f7798ec3d8b734e10518c6587bb919f835e661271a68c17097a2fb0f15304299e8a28185ff6796816a3dca4a4038291b5f7ffe916419aa369e85d2d55e6fdd49affba2cc592f7c9f17bb7b380a2d082ec06e1b7b14d81d37d33a9094181d1d748c887f0072486909049d13b3cb8db095980d366d1e380890197f73d160e781f315fd7908c3415fedb6566f828f7c407128bec83331236e7d3af155d68606d53529681c4b6e259f3f966c72915c80e9ee015a73d7f6abcbaf860693d953fce6f1e261e1f97c5d153b864969e8cef83c4867b065d70481d80de6d5b739bbe896a03d253353b1fc7db53751c6d11f2aec21e72f1e1bf8f5e905c54b2d3ae574a52f86b74fddc2705784bd7654aa54b51ad2f4fd1e21bb032d1f23058da805fb2b0d9e0f26d73cdd6f6cab165a41d679c3565fc292168701a6afdf022050a4c04339ed285d4e940d1d96694b25728d0dcf5d57400581e12ae4f5f24f4151fa94c8dca052b46d10736859d5a75e17d2a2baf4c1976d9481e52ae2f9f6e617253e90d7cebeebe9a631c43cf731a835ea47e7bea73f72171aa098c7d6359c02db9942a2cd9b8bed2ad0a0c017496ac15e70b68d411e7863495063fd4cdd3b432220c3ee44e942dbbe6046e341eacf17015fff590e58fbd8749069f50090e9b16f1f95962733a44e4a4ec4847f81a23adbe6a5981fd6cc451c0470aa8101c64d04b83d17535f51a57b7c6aa9a20b92e644004eec945ad4f996fba146fffa2e73b71eea8da238cebff41f97552fe2755f9a0aeefdb429b9cf6e7a3a011ef07359100a6b43ceeed5d2d95fb1275b647bc81b5e5d2f8e1d5a65abea340117c1f30c10a5d57d7eecc58543e1576ae34df5d5ef0bfce6ff4253904a3dda66502936b2ddfd6286dcf92f2c131ae46b47486c3430b2a9e7b2bb4fb51fafdeb0cf3e84ecf770dbd5432839e2966512028d5438a3b5ba5bc1c337f2aa8485450307fecedf543784088de9a67fa7c3e442e9d69f172cb35664ce6c4ea87008ad0782ee2dbd7de394f28cf8900560f3a387d833ccd15e7a55f30e8b1eb9583e8c905f969e647daa7d659790fc810f91cefba24349a4f7b5f792c6d7258589d7657b3ab56d68e9ad3426337b7aabed1cda2691642b9e5d66840f581ecb852cdccde5ae0379ce4c442b9fc7fce88fb612bfb90e69354946153774949d9cfa0d597817801d21d4ebbcfcd8397836bac4f2e36735c6986855a45e1c96f9c68a37116bf073d262f725251c7b780a892922de247175ea76345143dc20cb671cc8a63988fe5b3ab26954c7a2f3c3a800f809c533c9a5fd3398838195af69b99c815d8375642daa1b70f4bbea0c987e0f56dc7e77350e85d70de85be5dbce440ce1dc69d2a7d3cd338ad96aadb76171ddb02a74e63d8a763e0ef5af2928e9e9aac03634b2c5549d2e4f5439ca6d14b8a1c53a1915378900c06caef1d36a7f62daf20e957ec2de81519fe05803d0cc0de4b1b8df74aae2c430cc94c0097c8f50e5b7f2bdb3c77f6e66017540b14d2d5635a7170839248240bac2675a20063146951cf45c25c87640785822b9fe6eaf9c51adbb35bbee89f6c363c71de8865acc814d81c3e92ffd4988073714ff12e734422398619dffb856a6abb97fcde370ebde6a85311eff9a8ecb66ab90e2beceb3b329fc62b0d37815b3748e6e6237044adc6c4eb41bae7ac1ec701dcb04eff058e6f10bc39435105037b9ac120c70733332812ad3f1691a12ee8b635ae006bf4b3ef05ba4eef61d91525fb3514b8ba328225bfb6a28f1921961a69502bb975cfd8a516332faa5cc321b34be9535567bd5a617922515a9963bb7ae95b7760b39dd59d766cc0e42d4f7a37efdcd6c3c275fdbf865fc29a2a2355cbd8caeb2e8aa8163e47d034405c6428060e76cde57f9d95d55e960d74769b063784a0beb2c8dcd32da49716e9673b88016ea25a358053ceac651c1227543aaf7f344b1408e46ee68ddc96dfc351b4d095fea0f4974fde4f266c4e556c2f315687cbdcd510725e0f1385474defdbd5e2578c582dfc994c2e8bb3d990596368138dea80b0385a9ef4685da22b5440da2a20924724cf40551ff7049c907358be9fb66dd4dc027ee576f59eeb4b9d29ab7cab454ada10f6f17a24da61c00ec6d0543048a230f09f0b1d540cd6ec5399f9b776849a3ebd20c2c85e156ff7a54b8489a03b7102be72f5e52157b30589644c5618b94dbae3e426edc034712e444769131b89b49becfebf31c1371137e06a0f6f8c404d50225fc0a8c4e76557402a3208761893a7bd7162b840cf88619a1748b067cb727928724f778c0cc4871dbd7522e0ae8386db5eb99cd7a074ba7a578acf656be22004b6989cb03ae8c327960cabd839efeaf7bd41aabebf7d7b5cb2d2ddad8eb99650d01362f19df3b47dfa2c36f1043727b911bbdc7a29a6fcb3d91e5f448e2e98c6926467a96064f1aec9429e4032bf158881e8d44cdafc9d52f1a77df661e5f283bb82e25723cb887de98657ace1248266516c4c6250a25682a6669d0fa3ef952b3a9a1435c306971bd1dece7a6617f6ab9d4b09460236d1d2a126c423b47126ca69cf2ed36a8e865c7a6c0e86f3f03b24ae35a646ba56afff57fe6441d34f28aa98a758952f364fd186d6b7e0ddd3fdee117b1582adb2d727048802249ef54035fba6695ca2c390082b85540387be9a55f3180d479ab607a7409b8a094b8712e4cde558ad128b5d2e395188062061d41e9d4a60317e4005eaf947d5f6e6ce3f6c337c4e2af05030fa20dc0776adc323bfab7114c7875fdf02889b5e06e03d81745b48a9b34da7b14f3c9dccab23b32d1dac9b8e1b5ed89bcdca7dd288091df97499efbc6d7b4693ddb3210082b8f85a5cb38757d55efbec42c2e563646392ba455a8b0c5a91c7f0c8ab522980bbd2e04a99d62d4efc557aa68645182a540c1488d08aafdb5db773bc78cfce7d25c314ae35817efc56ee7ccb2f64c552079ffc17d7249952d3f35a82d13f685aa7cad8023028c9bf9e8b6be279cf161b2775855e5c7929effb948eea2ffd36265abe126ea4e15a90776fd94a99a833734cf4831397d341018c08b601e037689f631adb407ff40710c702a95514b7411219cdc9ab10db7266c596fe3e542e4a16448eb198a2be5eaaeb612cb19bbebdeb92864b8e9c271ad9b8b42337e7b860b4dabf260ff9b5779c86e2cafd8fe96fba0ff2571140fb67d8b4357b45111b819bbc8800ebcd71ebbd4ffb9014dea82cea1176223a0c6f55e5a5f2f6d126756076ef36d36257fd5b489ebffb615a37ee0fbc5d644613be83f1f1a02d17580b66f7409cfc3ceae98df828b1d0445875324f306e27990a6ebdb07fda04025dc1443267b4f89eb621cb8db91aaad64af123e855c7f78bca1b7aeeeb80865279cbecb590a8a979f75b8bbe202ae724c3bd347df2860d3b0fb316d933eedb68dd7791ae22ff63aecb4940556bc34e616d87aa60e1f6344c193253879c35128582d52236cf014867dda65f550b488d9065423373039b4d98ad403732342aac3822bf7e23a03fdd1afd136b4353af62fd7811df24d1eebcfab23ae7c46581322f4cba1fc8b5a4a6a60c9dfd0f3fda0196b2d46278cb3f67c2940a5296565f178bc095c2603488edcddb18b3abc0b2c360bb10802fb8dc3b1ad5fd1bfdf2e604fb38a4fe763e424d1bd7cc441121604115ee98012ff8ec98e77dde1759b6bd240d1d4325503cbf35feae927c9b16248b365d696956efedfb34b2e658b00d2a68db8511fc64388c85c35a5ead8c085048fad774b3454c6f5ef7efa5e6e3de9d6053864889d718c5e29b8192b4301d76287d9a71ce09682c7b2fc5cbb51f26fdf9db09caa3c6b51a34897b781bc23b01928e22b5d226351a38d05bb9c501a39596df0bf93768dc71919205b632733a8c937ebddd8ea0df7fe4cef303530a513d8f6968e45160115e42cb29ad38eada7b5265742703ceff715928ed9a9ca541323c6b7db6dae3318225af2af45aed85c588958c1485ffb4c62b7028e973dc8859de7500fab87c1771f6ef5335934dd17d5324f061b189f635985c628fbeb18a9952b85a86a05cb440f1b2e956acc58be2942312cafaa65e83e697ff946c0acee4749e3ae2dd8e20393687c1eb2e32abbf2feca5ff95f96dd213010742cab9940605a3a22bcedc9bdbef644eae9b49b7e4df519be297c15919243099b4c1a93b8ee7d757628e2ce399393c9d0967858f30709ca3a056b8d781fe7107fc4fb52eca65f4cd96b4e3c32592d3669fe3d39be5322f1237c7b54ef0d111926084130c7c481b6bb150cafc61b73b0a9c0925b8f34d0c9ed820959102b848f477132772c5184687979d1e925db8eb1a0e05151c9f92d8caf8b64fc16841ad0621666668bea914029a9252230262e9d9025f171d6344ceef1f67292fe6caffa04d30c8538d9d71cf6089452b5521f257f0684c3377a355a3c0c0d0fe1e44dc46215f8a4abdfda9eca7737dbe5b46517309b8083de47502aa211ff14e980efed9a60484fa2684cc575c82b0ffe77540025eba8862874f66d8b2a3a620220c90bb5877ac3e6fd7e09e383ac94cdaf99a07ca1cc55711c2062cd237dd9dafe0a1b597f742ed92624e1c8f40f109a20ef02f05ce2a8a2da517a980cc0e7394a7442c87095f6d5252a817902da5b9991f62c6354c1bf3b21fa5590f34607fecfebb22c8e12d1de9b9c8533c1138c227f4cb95825cce4afc78b8b113b2ba7b74c2f7c5db940b3bc25f4ffc616b940e72ff656418809d827dfe800c7ad392259b8a31c4fbce2232d78befe309f7896ff034d3c2e16282d043adeb262eba2e51be40302230d49d213fe621797116b8e4e513644b49df45420d4a53532c58584749f02437827ec9542989f25f2a4ad6abeec204613a9b241595149b21048524642cf1f4b66d14139f25e348391e2c342ebc34b10c20e88ed7bac2a17a461fdbb902ce2953b23657a60b77bbcb7ae00d3f1437dff13b2b8c0bcd58110a611f05a1a5f69248b96ece32459e913091339eb95fbe78de5304ac16ad6c99ca9c52d4735ea55ec3f2d8f34affc515742ea9b9ab7eb4f8b8a6073e18dfcbd91ab01810cd7c5f2b0d38add1b9e75e0b37f16cdb7360b9be38b494424c256146be7ee473a53e0bbf334bb5c44d5adfcfb8aaff6ca26978653feec480860099d666ba079101aa8bac22a8a094a1fdd5624566e98a080ae058ecaf0b347adb5098834e69cce513f6cd89930173ed03507d56e807dae48df078b59c714c436e8d82a6f0097a63a7be6a147736b14d55e65f9c24389b6c94cb22cc856939f21db2b0706314d636054f7f992b7da542f66168aba797d9b32749e7b4a35d6730376c0baf58ac652ea22dd909f408bb6522b310ad6321be3a865c98924d542d7452dbfd61f1c4c4b3c120572e42b779e0fb5c41939eea28fd21fb59c9f25183017627defaf0bd7d965efe0241877dd2cc519af8afaf6d5c0bc44e3fbc6fd7661950005663633237a896c4e5f076acc7a3777ec19e6c0495e061d9d25dc66598c124e85385994802bfa6ac766ce76aad783cd8885a6a7126f4a9eab8146dd26ad339d9a5687cbf7c87608d80213eb37e006376df251ab1820a6c964bc8171a0b995756f11ed6d9533660309c09dc3bb880821b80ffcafe501733a90610d7df620e03bd3d9c3bafdbe82171a9d5087d3ffcf5be28543e0399e64f874187136d14e31f7d4d83628ee8c1ec45c88be5fb688cec9d0355173e3ff23591fe0f871e1e1977d34efd270a46ab522424da1767f1a6a2f22ab4e9bc460e074ebe887cd84d7025a4e6c94869a7dd4526881f0bf8e0dca9e5782a75365448eb342ec10062605baf6780fd965cae2d2de9a2224c9881ca7043111c0c6d31fbcd0bd317824f9692bf2631f45695d86ef5a753488a033ff5fcbf29bb15cdcb70872819f2a6efac6aa3d98938f86ead99738bff318877ddb7b31da9e5b40befda114bbd530a0347ed21eda7d7d15316ba5e0624f02785db953f526a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
