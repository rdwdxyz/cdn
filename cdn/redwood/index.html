<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f1a1f7232866e241cb7ff27247f56018b312805a1adb6aaf555478d69a7cd18bd88cbcc8cf1060d49d9ff55b73c396c2b2dffe3f51114c916b1c3340980682ccb7664b94bcb0dbe1716dbef926f1a1e43973f6ec7275a760de89d10d470235136129889c82db84394eaf94d6e56038ca2f4ae566177d161a94cec071e297210ee223e9bd4f80ccba36495f2f49efc703a1651eeb1e33899180f27880079f47162200194e599a3a4afd06bd9e1a2c0084bb8485388432aab2ccfa54ad3d46cbf2c2f013e54773a731101bd58ed762cededfd3118f4d35d0b5747f9a53941145ee5b57d2c67851039c0f948e834030761f16633ea0e0306bf99165d01f19743ef030a0a8e85ee27db00ce32f9c562d5cacc18aade350cad01061312c0b8a559277428d2b6b07c4f3db6a2b6084380affa611d075a596dfa2058986859ef7fb2599b7331ccf8a32628fb09f9865b2ae635159c1faeb902e81eb61ef41ba92d956b109783dba2efaa0036f4d2586cc5acbc972866f0a3425ced462b5a1787c8cb23e847f3c4046146664526d2eba9612232e9a0fdfecef08d56c21c199a50811d48087167964bb7fa4ac8f7863978893241263a2f3092522dc7cfc0d2fce407d0af42512d87b91b7a0b4ddd39599f78145450922c298ac3c11195906d8bc353199183bae75b3235d930ea55ed4919e6efe6e1e59efdf9d19c1eec8282faac61348c977b82dd253b85440d2a658baa869e6d62fef37bff32406c81b5970065667cd809b25c537c699a496f4a02cd40ce6f34747ef2ede440ee50d2bd572f90b795fd156feb968e4597dde80fe03d4a1b504c3ae0233ad5ccc40bca7d02f374868c11d86dded892aa131c40d04b7e4c1d45fc221944bae4674e3f1502ef9b049829306ac311949f00683152455e35acfe78e07ae750252a5de1c68c0b203c47dae87b46fdf12259b0e3bb83c693bccfc0a73018362ba6b2d065dc372fabe067e112dc50be30ce109146f11151f2f0911c3c75e002a1c3a5c6b4dec338e99088aa69e429948c7f8b9fbd2edf20aebed4e8810254a99eab1e839dbb8b63e032a4bf8955c333232ea560ff2601ae0f6b642972037c6bdb19b13dc60af3d0028eabf2bc20b0582e5463cd2d0433e3872f463e2f33586863851b45676203638edc1f580714c47c553cf99728385f9ebce1a4cb7099173abf13033bedf307d3a461c4c9cb888183367c8f52086abca376fb050e9791fc1fe9edd5f050baf0959ad5c91c0a4af45c7b12d365d963565b773de825e84e89539b58c93d0524433e0fae10124153c01dfe938198449e42568f52bd8796aff9c460ceef39797c678eaa98d7d1af924be293ebc7b0c35bf8040e852e0eeeb82a65747ad28dc45edf3514d53fe489316c1c3ce69e89b1a71924e99041c343164a29bd18f2de887e2d16b1a0a48203007e71a632da70dd8181dc0a0f1a6fcae5472f2a1131ddb2823915a787e87cc5d5812f819417594f4d39220a2b2fc9224bf860d595897922887587480e7d5d628f148edb20b743efb549e656f53b26a5880355e05053b02c7e3262a1d22a3cd8fcc255372dea4a59fa3dad55c02492bb67b4cb9a68d46455d64dd32fd40c4dc1ca9201e256dc2cdb78610dffd7fe3b117180a3a971c55e37a33fe5fa76d6975f800d4dc126cd1620515b6b287ef7affc088f733037c735c56cf9ca981be30e1d6fc512c257ffbda576ab03ace65c777b41ea7d63a5f5c0462673147b57730d6f0415a2bb2926a28f5eb3fd0c1371869ba44733e0959abceb3c139e12d6081ef42d5c1b05895d8dae554cc30abf5162b8790e294f60e2e62212b4c26e6fa6f45f573c486aef62149f6018333fb04a771d32cedfa96d53ba4fad80ce2582f339e460e9bff72fd2c1ea488b4e574e85f5d667ead25b58d268b9ff0b989afa9a35b75e0b4e8be8b8b5372c6748b5c7f2a49c78e2214ca42fe8fd9517452244491388c4e3d9fa5eec10c00359bcaf1ed599997157895a815d566e4a14ecfc6987e5081e1693483f1256e3b9b1279e783fc067b865d93a9e3192ea56a50973252f4086b06d9c3f49fea2dc662e3ca03204a09e4579e57d9f41410609c90c34c0c78da706bb77ddd1e12e0830e8f1bda9130cb57ea98ca56f6affaff3fb47f3092ca4c797ddc29f66c364a1df50719c0d2642c521d837c137c0a7349cdddf3aa7b039b4cd146f88a1451a5f490478f1c1be8310c443c820260a550928da79922e407589897f235ef2b03ad415e854cb6cb44a5e070710c1dfc24e4351c2d8a6a36ea7074f9f633304cfe3fd0e2b354b945255c1a2190e6965079bc3bbceec28b1b2eb410ffe5c20a0385773aaa6e8f5545b473c2f231dc0913ae78dc8744ef30c2255897383ffd35c1a1936396d183389b1a10583de70d59737e6836b796b3ebe75dc0df078d10150d12ea028ae1444a88292f1f7a486836120b319ea2a96c1e54b0f18f91d863707375cf2bec2f5c1a275ed856c551b0c2e1e748fa0ed0787d4cf0af138224667b5daf0391938d881520e2fe45291e2eb2141094ce7ba160fb4d4470629bd77c55326c3a50980a345a582e10cdfae70ddb442dd9d7689f8c4e2a5a82d09f7bf362a7bb0e3137865c4ba117eb02933c148be8d216693f0f8cb35d3ce178d4f965c3948c942b3a4bce0f8ec1fe446eaa64731178a0d55ebbe02b113ae8a1ba72970ed890c5c50a5a8ad79d45d69265937dcd819fef15a9b02db7da5123d887b8ebe96d82b400e26e5c67f5ebbcfa2f0cf4afb0d94b1f447887cd1759ed1669f9a0ea09c1c865c449eb1b085e92c7848c36222d7bb4dc7bd08ce113835baa7909eb4d711d7924f8aa65235cd356b6bde92312da3ddce1f9f058cc494c197b37f1c0924a06bd405ee8ac16f7101c984460450b1c98966ebb2d54aeb8f847f4313b099a3368c1e9d729681e90c7214c2a8a236a008e069b4ffbc4fdbed650e98e75996bbc869aeaa4acd986aa9eee6a1e47f806223ce9723e41f39e155099ea04faa73ff7afd988132ee3b3d87cf6c0b1d1f85c0a4fbe505930d84a2f35423fed94812ef3b9a8e8d79bb267cf88913e753bd295a1d20846ae7b3699aed6ccaadfbafdaa88b0b9a77e493b0c417e0520ab8906f476d3eb9c90b57ee7a64092a0216ddfa4b56682912b31b06a51c12f27e390a5d8497fd63c8eb3263d872816eb537cdddb38cb061c9705f6af7c35d770cc8bd614827f78f225f9a9bd32d9f5bd7091a745fbfc7884c98b642689df235b92c792426da052a2e5760484e9213fec9b47710d0c48188f28f1ca4113ffc0738d5bed9bff5d04b9e45e8a4f5971340d5a191f7fb18ac5acd09a4ad4f99438b2733204b448c1fa1febb67665aa1130ef1b6cd88d3818217d56c848f7dde6758d9491fc634feb579fc4b70b59329255e4d5911e743005e3cbd0f3db4007878eff38a3c226db5c942d3c693798a6c264eb0d78ca253691741d7796f65fb9528ece6531c0b88eae9b619f280a1b1ac241c3f87c0aaaf2342d27ac30a8b6efc808d088431eff172fb15053cb3e529d2ee00f9460bfbaef7f165d4e357374d8d941e8de8e0b5b2ca7716f64de4e817658b04368ee711886a3131446a92bce642c105f5c51da19522ab662c6ccc48acc2dd01792082491d697ba0eed0a97bda7a3463134e1d321cec3a9139c1f61c28a9ed4d1a57bdfb7d833f3c2b04ddce45d5912736202d5c04c817d7e30c8c1b02c143f588fbc9b608d3d88c66bc265326f41c560130032ddba53c6d4586f9b862573ebfe1a801317298a983387e645f9f62e7709a0251c9f9fb9b6bc4baafc8574f085f02122f16aab74e18022791837e4cade4855c8c237dc2de40a2f1791736e62760c02ef754e02cd9a4893378bc170fe9634cf13e3b0c51c2f7dcd50b39614a756f2b9c90ddb67cef472b3278c85f206ca8d0ad9055690c259ec00b19d32c9a063a454f3890cb036efe6b800e12170e8445febdf417cb8245d9808d542f277499e9cbf5ccfb30fc9cbd8e831d20dc237d834a376475a62c34f1b04ec796115bd8a55e98befdc0c12f359df16d506cffd2fe1da5183ff75529fd33d6108444ece8dae8db925d553eb40f1aa242bccaf75350d83a00eed1e57abaca5eb715f277796c118a4a9c7f42fca3f1e9ad09166cbd92d598ad61d2d52d20d6d5c30fc3df8ffdfe35ff91dbc8b1c279f21d2b68775831dfca7b6ffb100eb34866374d554adcd67c49d5efbc22f8755e466bedfa3a2c8d5be3199f5f18b39713c047da93d926ef50f6df71965ae1938bc3f6fc684d6fdc9f2d253f2c82ecbea50439f5becdb8479bd6e60cd200ac6d49240af6273d091fdfb78ac10f28e897f363cc771fc618e361f4c5e2549eac7ee010db9c4fe21cbdd8f992be5725fd27f64be5502ca2ded0d56ca4cd70bb6180128378f03793b0160a8f3d2d52dee03488da53597c6d259f6a22ac52ce89fb9563735e7b860797d8cfcb58401c8afe09bc8ba4bcb909797e6b9731d382505c25498db089b4d3d0f3ebbc5d3a63997406fc30f6118f559e96621d029bdc81d8c1d8dc47d6cb71dd65b1c258fcf5da6a23448ef20b1624f8880fd35438a68d65747dac7f617ad9a8a162d3f53709b952cd480d8282a539bc5786a0836d70b98c7836ead726c863c8cfea0e071badc61fca5865fe8cdb9c6b102dd1eb6efefcc335bb70e9c344035e621d254170f2fd6c6b65719d9d79fcf8e8416ca6ff3b1a927239d800f959a790b8717e2b5017bf51e0b9fa3158a171e92e8d2ead2ac2e15c62d1c03f41c9c9be4243ed78c49aa302ebd515902f6cf66544cf5554d6eede081a7546aa9234f624b445fedf60bdd0f2ba05b56be43abb1989ac6c1d1367fd2d56da2eb82db9623f41cc423a7fcc7ca91fd1e16eb5b2806af57dbc176ed971f033ef1655f3a347f37633b8c7dfa2d017c740ea0894af3c609f6ca1a01cc038522967136881e2de9d01957a47b0769e9cb01af67a2e84fa01112ad97fca14a4bb7671912331d6cd025204cb306f4623c07ce3568bed6b504a048edc9c510e6cc9cbe6936a45f4aa2fbf4013ddb9f1d02198d1e436df928afda19a303bcd9195090b0d0309a999e11bfcbcb3c2c1912dabb7d07c6f9a1eeb8220389298d04980150b6b8fa38b6a700031fe0eec268ff6b27b6ea7fef41fc2be97746aa90d8ee0861203a35d570e0d61dc2e5904d36e0a9d5467ff99d3ce87de77ccb6d67caa4837819fe23c4919b83037752b604917a0927eb802bbbd466998b1cd8514563837d83f7d72f0506d2ef15e70eea92faf4ed0b00904c9172631a3882875c222ccadc0dc5817783f8052ad3676a82563a56be1a80c9a430f35aa063213201c5898164ab7468a684b5e5ff684648f970c0b08b03dfb0286329212b0e6a1c9bfed6ab2baa4031ad84ad79b5c16420f6a2e8894dbbc9dcdda13bdecacee59788d2a9889721aeec91a4687dd287ff3cd64fcb48721a7699c181f73b2fad91fe95ec274a1a8e5bd28340b41de8233e2100c4ffd90f77641e0b15b1e60865012f7a2fdf0aeaf78c3a3723f4581096dadc17ebd0f07efa045c0f5828b502d2066b92e00ab58ed37cc1297e64deb8d58ae485b892292994af3b016f162455ae1e3e182d4346fcda820c5be3ff39fe781e821f1d16d657468bb41bbde3fe7b2e1e716d2d59c3768a0c9b2b3990732089370283cc33ba93a1d0d6db30928379268fde9f8dcb6c18f03f0b7197e79463258ae38584a9d1cc77d45f7bc5ebe2f85d659a2d31e88d37755d9b3ca146e21db82c31074ac99cf6e06f351facdaf842d2b796fc441023e4c0cd147028d2bc285ce2340469f584c6d5e7c13c0991fad68d9f9f5ab3520ab398d260ae10b9ae19c00bdb8c3a5eb961bbdd91149199cc5418432070e22a7ba55c6b1720ae6b13faacadf84f984493392038b205ef2819a81c6a8720967c14e286d27ecad94c30a36141666be5bc963fa3f6983647c26f76e41f60a92890de559ae05a92c075f5ddab521501986a3388ab3b734c31a7f3d3d131c5a5994f2eddfa738143cbf26a8784ff263e6b69e6afef1d05a86b8119d0a3f0f9b9e6d63afa354ec25a2a08121e4829f1e82d75304c5a82459244028311e4372a9e3a2b54cef919a8e51721e82fc8d7b50767e76f108c6bb6740a07909afcf9279a49b1b7a464a440d49bd032a464c2237fdd8b15c7390f3e0ed0957884e86ec4eaf165d8566e6be8ad1cbbb73b76ffb9c64a527c2177324ceb53ab97b5c86367ed0d22a01aaf4075de45efb8b32102956568c86859576c677c96a31b5ac2baac4da4ebcfe28a1240cc1d25136a915dd220c2977f783018084eecfbd4a018f46b7b26d7dee1a988266f8cd69d8200af28230eaa66e64fef06df1bd65a1433c1ccc5afcda22eba0a8cbca5e7223a9d6b625edd33398137f07be7577103cdc44575db4e62a26fffdc9a50f5b89123384bd1a837a6ba354d8d025564087eb50bc83cfa330187ed8697ebc04fad765b9083b018cba2ce8703932546d787188a83aefd301bbd4a3bf09a7de3c8c34db926ad10126db0af5c4b97c2c5b1aeb8e38816e2204606285fdb50dc3ad51e1480a8f4565083b9a9f6acf1662ce598a3c119c13563d54f1bba64fd14f89cf2af15203a60d19cc130f035c1370bed56026316adfa0e36ba6c6b699dd5ce46484ada756873fca63233bd89b24b8e866403dd82161186b399e604e411a99e294d1d6a15b0e6d1b04bd44372183995160ee7fee4a3930c1080e463688977aaeac35dc996c61b0aae2ac3a28d7327d1e9882d9b6ede03802831e0c4efba08d34cc29a721553988149cd0fba818562a71201c2adf37d0857a94f0842ea26a03111cbb4c54b8ff57158db6a7a23db8401fcddc93f6180a76e001bd2d5c4510601fa4e7926a2d4376af08d11eb195675b9da6de46051a8c1153bfe4a9dd189e591ff2bac4df01a3334fb562815d021f3e996d5ca4430d79e23bce265094263741fb880869d5b03addd57ceb31c624342c12031b7f8fc5028e81e61b1a18ba25546424bc17cf078ef54665700f880e9dc0ff64b757cad554e86013a8efce1b522f17cf42cc0661d1b1404df155afedef9f15d94ed193d422029bfd7aa25581efe57e424dcde9220c70afd3dd7c8a661ada4175e9e2f1540404e7e5a66de728a86df6e9dacdd3a64dae53489d4a6ad5f3b3559d58e5ba2dca0aa65648d3e875f3cfc121bc1b8327c4ceabe41748a95984628f8357cd4de03bceb79d5505ca6bfd155200ec13f841bcbd978b2793a7a8506419622c049a713ba857f3683dedd30baf1483b81ffad03d9dae6a771be7341dd765eefb978dbba30b5325957bf03d8bb230a2335b5d96cd5568ba2ee0e625ad2e4de9e3df68996968e53c86a24dfd2cd6268fa3e0771049f00217b4276fcbbc9f3a4f57a2dce2743a8c149c45993cf956190fe6ae6932bc5c8d6509c82ffa60f4690812987556ffedaf565cc1bc2fbe8ab8cac85bb32ee8e31c7e244c1c7791ae81a4267039df8ae323b5f3a953b5e08392a1e7f6467de56821199e8811fef2aaa60b5d50c78cfac62b9f90d602cf70389da43febf7756d247681dfafdc0b7abb9f042840d5aa8b7a018a9e3e3b772ff8fd5306f3b0afde95ae925e60560d5f73ef1d8a6715ab2be27c5f2dba3a1df72a77066cc9bef02d885f9dadf44ff80f46de6d88415190262751136d918369241f92c3801a013ac8444b505006fa6389406e461a1f29506a063a30d7e5bb5684dac8f6486ce30b1744c62a367008e6397b19b092b4a9931ed37316b7255d9f83b8250a7820873805c2e9ac162516024f00434fa78d3365b5d6606ed3f743baef6c99e2a5d30b8fa0ba939c905edf5681a5e3fc7e36910b084ca349e0bd79d22b7713ccb47778242e906bf262667edba756d19c12e32ab137e094ce794a70203f85ac0c898ccf96c64ffe41375e4d03a8479479fbda1e34aea5373094805eeff1abbf3481ece9712d68a5c3b5dc373ca99ca3634d390c31cec84bf09d99e5daa430e2b8a453392e7ab96733c8b04f63b3506a1278db35aa315b217fff8cc288b2526ea57ef3b26065fcc523ebe24cf3702e8ce2b66790699a082d2e994ab282bb5588ae819cf131d6590eb4475e509bc36658c685ca3dd43fa8ee2bd4cbbfcc4b002dbdc447a030cb814e2ed803ced50ac2e0fb40d0e85a14788e1c4452e27b61a7d6e80c5efbb6b23bfe7d4dff923ddc956f726c39f49c265a437665c155c57bf226f4d394eda1d5a6b958d23d207da60cbe8f777a6695582146ec2ae9476f4b2a33ac26c8cf4ef4ab8f737d7df8c52266efef2860427bd6995ffe3f3d0ea747949c771c0047a63616d8d805983a358d846dbd04fea8e0fffca4e49be8d876a03bc962dd82ade5a13c853298dc314a70b47ae19c97f4918875ac7793585882709aa8b39b622dac69ffa23312ceac16d3b0b43e57c5470962aac494c0ef69f0e8c0beb6b7f18bb217b78196fd2b31ab7684c3554d776b0bc77303a34af847affbd3739f5e1bc7e91097b81ca81cd206eaa9ece5303f8ab4558f8aebe87a86ca2654a033d6f7b9d2b563ae6b626be9c33c312f6aede110a696e7509b4c42aa6b34dae6d92be04460737ecda571096980b16b8be5cb7b8d8ba721628956627b9e3a3a2f2badc33d90ec93ac83cfdcd4507ed46850726bc8b12a8835313b9035bd050186368c6e5d5b7c72dcf340353f45759c938fb73a9b479de848b13119258a4449c2fe7340979b86d9575ce2b13297de3943d7b3bdbd1409c448b8c5c05e77153d627dd0b211b4fe0f68bd0a28868afaa7478ef11ddad432c35bc27e6842f9a549de11d9607369016b18607b11835e2c4725730a879e904e9ed6cf0e73cdd529a03bd658400cdc20fab6bbacd893bd17dafb5c156ead6cb3f94e16c2828e014bd8c529152b8f3542eb8325dd79bab9b156656718233b7a536dffeed8598bcbf482a16cc09d22737feb8fd02bce14361bb4d2868e42a441ac16e0ce83f825156f35f68c53a546e0b3407ffe4ec02f052790790133f191c13204a9ce6ef7b99e2e8de8f8ce5d2353a61537e76bda88f1c443feec0a7e4606bdd8b2bc85aeb27b8dfda47476f4528de63785eb2b33cb0301ca2fac60791e9de1f6c0a3711083c836159fb58a23d7b6eb845a659faf47e6ddee48de2c5ea84c4ab11452fc95bf75b9a63097a30e25216f5b0e06f6e18787f5f7474a40afd5fc470ba0cc7dd9a2057f7c4462023a9acaf346d66b6436201d023df306bc307ae13b2563d5889748eb4e51878a8b46e3910bf70a5ec5961e43198917ebbe51610f0be996cb0edbdf5f7e3dfed2e32d51bf4821e9d2dac945b3bc02a236d17eb40556f05f1d254f7f103ccdfdcd3d303b681c63873f0989d498844f9cdea7a4f77eb68601dc8ba61317e2314b33c43ebe22b6ca05c7d583c572a7ad7e3d4dce368aa30970ece6825b846e716191d33508ada94f5fd5e54fefb7995449091167b45d436e7783f294a653e4559c65ba296bae4b2638acc88cbefb607bbe5011ae8d83c837714f4bbd7c7abf558dcc2b4260af67e0a3011aeebdcb135e0c0f26467f4ca033da14743a2a65b964d90590880fcc483ff1dd17484a740f5834adc8af72bf7ceb52a52979c4c7fc28cbd2610e08c6830980362864235857a10995d6effa461906dcaf31772434a02576a4a7218b5496d8c9f18a2efcb337e93cf4b31387ec5da47dbd6e35cf74819a01950e7e257ccaaf958257a730d331ebec135ced31883743bb48c0ee68c23210f18b1e7321d3f1fbfdb80aa94f69f2c19c8e6fb08f6fa05cdad529dc0d23edc4da6ccb452f0e890b1b4960a088d710cd5c47f85a79d5d7a98de2f2727ea207ccdac95eec99d5f26f7b62f62e49ed486ac84d49a6c1a1c8227ce489fed145ce9eb31cee2bfc0728a915fdfa0fd82f641d6e33f29523555e9ab5389d53677189d3064b16c59d551734c04e70c8395ee6159861b23089c646fa95184768038551f030d42a727170cd81581f906bffa205968dfdc389cf5440a3cc40ad07018b965a7d8fde64ec4d7e9c0e95583e33c9f7455bb5dfc9df2f13cfefc1a25fcde5d6533571accb82c1b1a9e64fdb62f54a6a2fd5f343a99969c203017e1dce50b1a79c28d033678aa1989d1a1e028248f4a1916dcd407eda35148bb659079db2fea478e9ceb59ec84948fd29a8e153620cb552cf767d5fc018fda89fddb9a31e85b7e9d20c263df985b8fb6150a4a638f91bd2dfcb32c6c736e18704510daa9229750a18a90b959f3bf084d947562ec717c4b9a67f792999f2ba6b0ed92e39bf81ed24375a67d3fbe20076354d88c26794d95e60627da42359d62cd75f9e3d536c12c3497b27da44fa6fb2d282562a6be72c87ac6876efc7e8281010585f202eac5146df5de3e0b82f9a792bffb604586a482c303c294b6a59f940badbd710dc0bb41683d53401fa84bcc114f2239e5646b19ce06fac4e5a4b024483f4efed3e2d550f9e1f3fbd7d84d3048f4e4031132735783993243087cab285248efe0f6d8ff5a5685acd11ce3106f4890e809a2a0c4cf3f93a8f8d5065f106e8b75d1245ed908fc5bc4198adf384f59251669fd11b32228a82bae9fbc1555b82e0029baaad19eb6fe3bde7792f373d0535bc8a9bdee6929f69cca6b8bf5a34f3f56679d9f6798f0f366ac2041e902152d4776efeb52d85eb45a30c7e68ec2a90bfbac3f2b54e3b6294cf7d107d1959efdaaf7333b213f71ec0a22a9610cd2691cd1be8c2cba895cc3aa08681f388d3bfbabc56dcd00eee76a0beec01b676fc7ad21938cd677a0a2dfdb3b146cf25e0962a14898a21fe908e4ff0e96def6e6e7a5677841c84c66e1b37906b63462d5738970a5f0a00c6d3c84074f8b9ea2b034aa7f5f25f493c7c527d039bd9efe49192b82ed8d3e57c3033510d866960bbb508cce19862e1315aa3129ad590597133e1ef8b5f102881ed7db8efe04528e609146f35e3eafece66b772f9acde3205d33fd08a21298c5d724054a0d375971eefcbc95e715179d9212837b77404b205acdf9819aba300230d422682c64c5810e0b18bd61428576813e57b90baf9465e7af6fb4e3716f28fa57bf30f56ff993a7ef4f2fd6ea2b3eb1c07db632dc9871d4823519a6eab8fdd602f6a2e8bedd047076e0b583428ba3c4e02d5b421471dab5360f481f212ee2ce644cbe8d28bd2af729ca86c122deff083240f494a0de07ff59162d6e690dab89b9040508c1333ab56a8fbb2f2faa09f849d13d01af0b66b5aca5d405d6d4bb449daf75b17031559d69c826968706070eadee752fef9f279963742339287de6a60c432d160df6866ee940f5af1e3eaaf037ede7dad5b595ed098861e0050cf4376427d5b924a4b27eaaa8e35c75bb469beca5ece1369f10c9392232f2c09238b6354c4c5f98bdc9c0adea79893ca89db7b2f1dc9540fd782f7709712a0a2eb85283b49ce615c48b2413e9362cae68ca273c07aa92ff152ced0ee0bbeb1a242f9fd00ed863a330dd40bd6465c05ff98c1be490f6ffdaa3dfafdca3873aa75f285156f21866ad347848fb4a8a1f125ccc2502a34c094c3243f7d035467865f43039c0ab6c2b4a3a10bcf8cbfcfe67b87fa22d956ed925088cf8c4f380098b1c93ed7425c458dd5ed419ab2a1717d55e819726b1e5f2802f3d63f1df3950a598b9c3d80415d8c9824c1c76153eafcbaba0bb34302c62444861ac50fcc5e6b115a89f1212878cdd1e44f9128df1f8b664859e9c5cecba6540ecc205eedcf26560883a74bd9ca4c88a621dc29a96038728ca44bc62e4fd13d6b37249664604d8621a31c113560bacf8807a002aa0ddaf3055c7424ef05cc7df34958b9900f2cda790423e93d55c9cf65305565f9796ec8eb3280a27ee829368a61fe6a2b1ec39953b9ef987008e4fa2fee4a358d1bb0efa53751473bebc77614f23c3043a640265ecb1115805b6d3e136289842b300e12f5f978ef4fe1f2fbc6cf0e2a883f0bda1e2cb45749f4c3caa90bb88ac8bd109b0b279778a94d6cbf5ea2b97dfbed23b222602d0bfdea6113954a79bb6e02af2878720e1cfe12cbd4598ee611135938d515b80f17151b5fcfcd6100fbb2a8335e504dc0b343f9f366bf02eb4af5561fb4c0ef12189b6631d336cc5ea1dd9e6ed0703ba73c3b6d88ba01bbea71a06ee50aebc7caa9c2c460346e05c73bf1bd86d0a5b89821310bdbef53f5aa1de0853a167fb842f5e10b6dc7acd120e750f24420b3f1ce0bb466707b1e56ab5ba3f1b87c26cd7c9d5d3418a3bb75976ffbf63cde06c0de8e5ee93e049626f1cd350aa698e0397ed6b97154964baf89e967bba8fefaec66f64a6297d88bba98547112efd6f2b6c226a01eeeae8ab341fc69eedee4442f9b4b14bfb468acdb91234d2bb3b11cceb9912cba71321bd115f1546e4ca0b6acac7fa9ff3a1989546b0c6c7c5e79edf73259e7388ab8aaddb13e87e62d42bae0c78279697cb2525fc28ddae006d1740ce6cd5a41194d76cca634367d77b3a171c0121371efb5e51b35e84a57ff59e9a078af6c25e58d39625e311008d2f886bf2085e407a6bb077c0ddc95933c5b8fbde53e1221ec79d0bd6545df256c8f1df520b5cae657c07e6e3ff53cf567cf7ac6f7bc20d95a6762cbb5788b53a3cecdf86743ae591e13a9e708119282aca973693e6f4177bbc38d80c83038f2459739921bbc877c1509cfd9ce6a7da29c8560d72e97debb7f2abe3100a1c3b7676710a8c680f753ffc7292c9cd43c5a6113d659abcdca7771de1e7ade89b6925f18a00b74a508d3de39b84ff0af88c2a31b144c884fbd76f4c831e9a36e723463d3b9b0394baadfe16ec743083e6d1cc614e5673d9a41c96ec16932346066b1e839ec203395f827426acf09b8011cdd61d30ca96e74313bf446e3c6cfe5d72fbae6e0ed1cd3a69f5376adfa608f7c6023bb9977578031b5f79c2b39a95e5ef52315b29dc5a2f1f24c53ee5ebcfd337bb5711ca74ae755a2c0acd3ec31de551848c1e93bb233d6d4c98a87a4b346127a4bfb583f9a690b63f54d665a721c9ebdf311ff665bf69bebfdf8d2c87659bb196fad053464beae657eb4c50f085ea0703f2eb7d1f8d38868c1f705138d90ce124f564ccba1034042d3d92ae3134dd4b9403077ad6c2055774c6161972a32c6cf878cdc67a24deb25cb5c7dcbad375bf6f9cea41499ab088630359b28af668da736fac902b80d77774435266a9302d38e3c1bed54aa766d4b744e0f638e29e5f6a0885997587574c7db1799e50b1d68518044062712dea8482a6db42e41c31f7fa2c3ff1ea0187d4efb5e2b145f49795c8aaf7d52d539a2b1c17f0af9e49103aea0f7fc965633cb88d5898ae4bffc1018992cdad549040c47b777685a78fc61d26f92e3654a07e9876d7fd1516639d47be16a6051de7f09d1e9495330dad5001af4a893bf5a80e1d09dddca4ac700a3ffeec512c377bb76c322609ba2b7bfe2284e21d406ab1db3aebbf483d5562e0f54e634ac60bdf7c3a5830a00ab811d1ed0d88296c23eb0bbe3eff6ebdbe758c6ea47a3a86be4c3ba2d52e55db3c997f9f1126ab4ff42ebe171f964fd9a26ba6cfc627dce83038d38d4dccc6c86e14cf0c9a293ba7533758e881a47d68f768612e1e601284d02c4275765d59082361a616e13a03a9aa17d333d8e2f935f57a2aafdf2021414685f557236b87fcd5d10bbbb81ae6c23981b6586bb6542da5f5c75d86dbafa3ad76e797440badd9d2f0cc6a48734b8a9191ebd5932669ee7896cb24f1792b90c1be7738818c15b24b2aeba333d926043fd7aeca1e7834f6d07910a7168c95cfc7683045ec2151cdb0079cf2d6bebbdd5d28f6b3352fdb134ca226fa87fff3eba1d527939d1608f9458b38424bf41ca8cd7c9d17a667365427df5f8b4bfb1243de877d35371550cd0e440b27495f4c6d61aa8dc1ef59b74564d7cb30069a92c9ee378bed710c312d056a06816189eaa0c8c4c2835d17784fc4734e9d5c45d8faeea8204d2df3e87816dbe7504be812ceed0b3eadb68ed5957aa50da90842920fa1f6b265afbe928dcc9879ba9840a80c90ee35b4612b1edfde976a295d0ca96b9831d8681f8d49b1934369ed17a7a507f770fd8181e3088419615192697cca196e5c70fbfee21a35bf199ed1d23832a45d75ee58052ad72f7a5d7fdc4cacde3a832a8727b1503828b2fe168e0d286e9fc17af15071385b9b6b280a15982d2498255e61d31bf1f3c8f174bd602fac84f9bcd8a73c501cb0d3c118f5a856f21ad836d66c431e5b5d0ddef2d8c695c5310ba24728bac80b8051f5aa321e4ab3fe60eb494184367c744f344292ce3d5da87db631f32320c8c29cbaa22343403b1ccbd8b941aafaa972eefe9bd60f978b28fb27c4a53caae94889d3525daaf3a577470b92715c916e1144ccc3dbefcfb3050dc74c56db7b9bebe4dbda09ba53d05df42fda4c99a43dc23cee0fe66423a68d8c044e3ed83513d57c3a3ae3ae919c10debf0cd7da08433ce41b300c29bcb7224addaf437ac00cdea04e9cb0455aea325a6ded6084d293c9cb1b4fd696f60fa780c108696a7aabdfd35ae6a09c4c6dfb336dfa2152d695ff729d5cdc4ac40564e229e24a4771c305ad32e1b9695dd0f867a1bf19347300f641073d56d2294aba632b7f923c0f133a5965c2199ea94a1b84eed9acda69b216087e43a2a602d0cd0da700d758c171a967b61255b53723cc0b7ec9affce109a4653f6aaa4a133e314879b27db568881cce79773be4f25eccca79e5b6d399145c4f1244cabbb8ce1807d8c4379226befdf82e516d0a28816bf6d111734065c20fa600668c08947541b8caee5bc02c85e441bd818db2337353e0a2f577602f81e9ee6fc88b84b56595d8a01e61371129cf569c68603e1be9d893b21253bc41c2055a07037e5101ea388c3d1f30970fb6977d4d123efb06cf1bd7c49506e74fc35ba24144916ffb273d728b354eb9c36ba5f59d29f6ef9ab10682e783b63ca452aa6f2b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
