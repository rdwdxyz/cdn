<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee146b32abbaa366e82a5bc917d6957b1d9528c69378b5110adf8e344e6e05c0fa84042165fdde58d664faec9e01d58236b5b13814d054ea6cb6a69837327bc07c5b3a18e4038d6895ecb972bd9f7c23256ed75cd648ac8b046f1e4003585e7f17ca92a93b1031a838a347bc0c33850eb7928274cb4519ec19e689f7f3235ac03d563b6a8d8fb40192ba2410b4f2a0beb99959f31f6e6dba294afbc286ee7107f0c6a7db2f8eaaf6f0f2d2ac9130235532e8a502d0930a0c97adfdc2bd1ff085e1b29eea91e128b5c17bbc4b8228cf623c1155fd759a35e100793789c17c49b2029e08e881a18fdec9c32569e1e4ae1dd77169ee1433c3d3aae7808ed39ab3fdbba90d7cca0face980f369cffda5f2816fa71b48cb41c11d73d74535c11c90e6bc6887ba106e0b0663702816ce84a0a68d83aa05bce80741181ffa072594db4524e76c4b2ae5185f991b0b5216f0c2f2a2aa8b71f2ff8cd98a7271335e18db7fa57a8a088a985d8b754cdec94788fde2266b41f01340cadf2ee09a847fbc63ad9d2c3ec537beca80b5b87895a3ff6e57a7236c988c949229234a43fda3eb5be09e010d02fd7b27b5219be9d9d15ce5724636c82ad57ee301fa666e61c105713e44b1220de06fb436d824973cf74ab20c4997ece54c005af4079f793a8d2700938a41795ff8c302a7a7889925f8bdd954e80886ab62be6d1ad407795a9b59b814bd2f09c29f39eb8cc36b3995f7efe783ffa5c5a23b28128ee8ff850cc6842de778cc28d0acfcbd47eb09325b4f43b2bdf51a7e01f6f7f949d8988b4f1fe22b0900723576da2d02e41d289c30981f069b3689f2f8d48943ea9ec817f7d6d48f4c59539fd81568e2e7fcbc6dd132e66069f7efecb67c5665a42cb61d44d1d2f8318bec87029e332bc5f9d385b22ecafadfaaa84e31f0ae656934e4f9300361035a982812e6353b49733a8c2fa790dec8c68e503d3f6621687b7210e7f48e29dbe5568b3bd0ae5dcfe57d67d3d73d2759dbbd930cceb0bb36d3413fb8fcbadb316d8dcf9201da75fb7e560bd7736bba76de4d6b9eb35143b3f5eb7f5d9ef05548d71b058942e78c158759cfbdd9badcc0cfb45fa7e43e89637866719d89b63dad3171c538cc32bae9a1cc7e80532b5a564caa66142c2cb090f107f61249a8a9d0ff0043700b259cfdfdc968573f2cb60d571ea79777cc92e674c5e0a2916d09a1680d065c799be71f7c06c6ddfadf8d2658ec62ccff9883e9a9dbeb41ce95fcc6306742cfcabc760ffd74b2dff5f1e21fa3814f2ebeb2592489afaf73cb7c00a49812b7925d51676b8dca886d388ef9fa39ba4fc40420da0ba617acab36bf46cd9eccdb63dab4cedbac25a7e29e9a7f315770c11e23aa4859e74989724b31904d268e35fcbf44eafe6ac48d6056f915cd6c977d1d64c59f85f13e5b03e2853a8550762d87c97c1c3db48fcf06f8b3f2487c821bc839f1e6be718a018ad127cbf2f6599926b96fb87439f2081f7f1e1b432d27a074a7845637f797e284b3559d483a93e2e9e2460ad4b6b9d5a9fa0fe5811890eeb3e94b06787515c765868347e93978a4a74408553c8b07450ac6559ff6e8ffb14715bc589b5975b8dde5a509c76a8f994af6264caf419b1255636b6a9e008592d2a68d1fc4ec7bb980ebc6c316c823838ca64619cde73a80f378549229391bddc64d77d8709a45bf12f99a1318a90728a541fd4b1f43b19417d64be8295e62bb1fa2779b40719f84b0a613e28af6fa5e267bf6b244bd4e550606fa5820330d3a80b8dd771321ff8c12e66b6a65b5c57a3da57d44b65b34096f9e61fb0755d70e53f6ca5581ee4a822065239432abe1804fd8d11f74bedf2258bb4b61059f877a9d2ff37994e5d7c4ec9fb9e810da0cf0e643d7e7415818d49ccfa289b0a8c9a895de8cdc3678c0094fb8e16bcf066add9bf791cd9208de4a1199e3983da5bd006c19bc4c55ba6e16471cb57a8439c0bfdd53bc1f4de2f5d54f683182d98f5f378ce5793cec1fb677958cc42b44ead36dda47c3bc1e00556a106b304a9cdcf1df60d62ff03ce3c3318dfed7c871071f3a2d551c2313b53817b04caf225ab29e449fe88f711e4bedc25d07bad8878e4283a278a8e9004be31ee0bb7203a2f23f98c3b6aec1873823b6cac58d9634720a3290ef4546225ce22c87e9eb8c93cc79740734c3f9823c256f58dc71b2e3866eb3f4d2bedd09403f32617f80f1e232765c23225e86f61a0af003c25f55f1d96b8d71029b19fa92c092c6d41cfefd967c3b0a004f11ec470902cdbaafa6ab92f2934cf99b898bf10845c81e736096a753728f49176a8a0f58622bee68f819490b7db6f442f79bb7205161e50faf06080594908e868f77bc21802f68134a0e0be9d691b653bf32fb0c9b5fae45f19871b10d28b81d7b47eaabec5912e7d90163ffea8db95e482f01b15b45cf6930b3ad5f2d45696633bb87ef6a56c1fb0bdace3e8cd1d14e992a336da955d8e809dd9241920e3cfa6607ab856cef99426631274706209dd64210db0140cba43106901a68ba37b6f024ef73d72d89a5f1fd91be038316411ee5510a281c0cc9c0faa7bb20d0258c58ba805c43e1fe806b5a56705171d0591e1f51ae8c33eb22b0989ea41bbfaa4956d252639c4ffde91d36d6e796935afa62672a1b47c724abaf74cfb0dfdc426a1cdbf409d433f3c8fcaea32d47bfcf648e9a52127025ad9d99d0c837872c235e27201107801fd75d9f23ab74776e2f215a28a00f120881fb6f31cb3693bbec554683922238ee99252ad7c5ed42050aa66689e818f178af5478f912ddea227b28a8cdd486d002bc30c53ff042781ce42303a06fbd5438d9164cd3d7ff5d500fadd80801542ab9ebefa4bfe44b0fd5f6e3f70a070e9e733d3f4e346fba7e90267c06d812f1ef6b53a0cacb338d10bdf767944d06c1fa66fa72d80bd5f2013fcd7d23336a7174e44a57260539d3d4b0016df8703b9a9585c97a9dc076b361e7da436cec23f8c48a442fdcca2b9c2d0de523fc6aec65938a943528e97a0cff984771ed434eb46eefc44de13754c4fdd548e434138c53c390b22346f59f8bc1c8b1c7198bbbd4a6574dabdace3f0d5e53742eb93a1eb511ada6751cc58d8f1d66aa76bf104bf61b6ebbf39b2ccd5723a2a6a4931e2a731789a4f7c974ee9a989624a7e9b7ac6335c3184eb48e7ecc7f8d0e247dbd23351cac165ffd20f951bc3913914729733ff6099d189b4d52f23ae23ea0d0151d66fd4cd1aa9ecca707460cc9a38c6d41e690faee5fb7ad40f3fd5bd34f0e3d95153ae2781c4f8823d3f07bda06184ba2d1f7e1e070f730b26efd59486d35ff4957985b80c955b8c331b5ff4e27e8babfd54f8b54d567cec7eec26d08096adff6348482590b3ba49e31c555e828d3072e0c9736423073ccb7327e3fc221c50fc6f57b53bc5710da6686a0d4b43c46c405a6984104e0d5ed47336f707ca71dc0b3a7028ba5c6a831a111ed3ed32359f8c17346608f834f491c463a0acc429e6075150730e7191d7989ddf8d699a13865ccf543ebc2fc2621d52efcebd774b985164ab9ccbb385f48946831b7f9fbf5b3220824b8bae5b2a2b8a7329401b1ca9f5f72b38e0741dec95ed23636223ffbdbb8d8922b8af1e58cd7a92586c7608f2f09a73151998dcccda4aeebd60860ffb4319fd4b108d6064047a004391d10a9c2cfc975bd8c8776f65506b4b9f79093dc4a4de1c317a4546c4838e172b5ab68b22471df3c07f7d13ffec1d86afa73b90e6e5806b76043b82a3fa84a21b3776f7c8199a2250d9913ae209808b416f3e529e42e53ac828e7834fbc3a5332a2caec26e3627f55ecf845b4433c3d4e1c5ce789c6d758babe3c1bfb708b4b050c192673ef3c00b02637fd62e4d9c046d2bbe369198dcd2e3d47881a5aa5a89ffe043e985a3615649d0c1d3ba1892962d1832bfcdb89c86d6657da9c61187262cd55b1febe8f6b7ae0b2a11edc07c20324d3233a0bad1663b61b1f9f3f8dae1cbb4e0058e358c62a5c69f4b8335014d7954d3986794df1cf60316bd0ac9a546ad916acb0134d1d6b5452a7b8a36bb88edbac84d8d80912eb2ca651fa1dd88a9c3cc2a6dcea1b02693493e1eaec7d243cf9a9be7aba8696397c3730a8186a42f6d92027c0884d7aac7590425f602266220bc26123819e8149c8f98675acc265e2379884eb424724b7c29d63c389725155c2dfa0afd321254358d5166065fb2e27442a97c49b53a590b1903dace44440f7d07db113e38c858c225acb923d4913b454a7ba698ae39246743c72bd3040ff00928884c4c665dc5dccc770dfe590462627b5e8afa39597423812b076c38de8d7e4a0c078016cc7abdc9c66b7f3ef528eb8cec8a813db2cd5e820447cbfd3ac70aee5266399896a1bada9182436e417881484ba4c0e4bcb34aafa59a30e48f0cc76ba3170fd2540d0c031d413336cb203a7c01630e4c2336a88356764c5e52cb3e0bcc2842652f7fd9e1f2a48a910a2d26098a97a1e41048aa13d95202650f9f56520aa508ed06bbe76a1a053b0cc60a5c1352f41c31e5abb8a4ee25802abd16695194350b1e8515d230babfd119f0bf49e6ef5f8e253879f2d64bf370ca7c97d6834f34068605f302edfcd22e5ea57716b8261e4b8592703587b4440848c6f5e19ff7263398e554c575a0a2815bf626d364d4e7618489b241ba3adf54281bccf63889641e547c52ecce8e485e7679a17b44db6f1c2f30f32b60c16bdc7a082506bbecab45f2c5e78e0a9828561323f823805089dcc180812ae3cd49d67465c72c068839fcf2a9a3bd827015cbb41b048714a6cf76e3a80f24167d7164c4d9eae5b6ec463d3675585806c4307442632ab0d889ae9e4d484dfd4e5a76377e91326d147232c3103d5080202f4eccd96425fda03d77abb9d01338b002666ccee4a601f7edb49e9d99607a1b3285e6e625592ad079ab94999313a2d65f522c6463bfe963bd9bfe760aeef28c7b938b2a1214c1d28c0a047dbd0734625e1d6fd77175207841e7fe3132bef74c5312432b8f791b4320e647e74a8d25ece247cea7dde48ad689b2bd2eaae8fea8f6b44d2553bdd745d60afb8baea17578c878231ccac7c08f7029361a83895e467236d4588c42d0e3cd69e6c1e2d7db22a912c82a47c311ae0cd7195a4c37ba36801940d2ff4d2bb9b4c53dc3eb653dccd09b7580ad88229251f182aee556da59ecb8129d49fda14f5fa733af5cb474bb74c965547c822e5f73318558154455dc1506d0c27f4584203393245d67080771f9363b29d602ce920b741ab90c187eb812b5d0ecf247dcfac1f9eb5af8c2ec9b03f584dfe992383d9ea4452ed77d980e632a735277e3bd6b6ab4813b0e9daf8f25c83bc14e8567869274c3ac6e82eb8dde71facd6b4dc29fd584f5780c76117f2fd2ff0493364e8ab6f12e07e7b6f15bf1dcbda88d65d23621245f27c10ec9265efae955316d69d4aa27cd72768f4289970da954272615fab5357c3aa0865974731aba8f30d7f4a069ef16cea10422dcf95e50c2ab48f07f673b99f6d5844a8087eddfd02ced84d443e407c744c32caa53abdecae1f05356995b02a3b05727615358d2e2f998635bcf4b292cc079752ac41cf4c8179053fb2b56205cd6328a1a8857fb2239588b730c2ebc3e94cfce42aab75e1777632e95b52bdba5e480bb9ea12767d4c6801d1141ae2ddd6de3cda13d15791df3b7dc4586807c07d05bc3e6d8fcdd00539602a7cb26d12ded5ab21396022f7f178f87ae45e1ee698e3d4e20006695ef1f0bfa3ca2291fdf63f8a76d64daea91fcbc22f3cc69f56ba318006d680923fca5879d1997a1ec2914dbd77ad6e9fff415259e04125ae81d6c175ff9c2ff957ac933d82daa3e466fec219fe20f6178139ac24569ea402b06ed347318a48b43d7911f0eb0e44edae3215e9defe7c06085650dc2d3a7dd34dfddf82de1a120adbe654ccca7cc6072109b03f883cde2da0622e26bc8dee64ebd317bd9e97677fbda404503fa51f5345805f4df6ea47af4467e9308c0bc1e55d707fc01052a8ca7e8213513ff72adbda98962480f2bf8beaf0f02865e76ba4f872dd2c3ae0980e81da7c29b94eefea65f569631c5c76b55b9cc147b231a9e8fbb0a9694a98b38f79bbbc92904a8a8d47a6bc0be4bb85a4a9061f5405b82ae3bd71d44b0bac574a8ca6e22da57664f5a0730270ad92966030d1d0f3151ae5e1fa1ba3986186406199ac141ef7b6c15df9930fb86dbb3d2a9d18923f71c420e9192a23f94edd63af35e5cfe6d019da3ce6c8e271d582db76018d87bce3bd492d8ed4e19ec8a726a92879e2e65bed665097fea022cf2474da07e711d77cc054e15666c0c0a851d19a4a29419c5477144019c3006b1d6e1defb09f7093f217b97d89a3b1ec50546c3681e4b0ff0472aad7ba18a4c1c5260795f4c508a5a247d8568c8ef08956db9d9166edf76c97bc1bba1c0622992a72f0d75cb7c3ab50dfc3bc6cfa860dd83f7bf0060adcbaef9dfe2c9548e2bc131716214354e565f5089a4d5b4d91777b9af6d78d6140aff07671a945ea817da3124309262e5747c95a0f89f2c3b37bbbcb68888bc59076a53f41c2199276d694008d3855034a5498be423f0ac6dfa9f9f98f4a1a14d0931c337c849ee5b572763c881022458064e44756d6e0b4735494f209b815af18fb6088e587ad45df778bc2a77a0e8c24d8729df7a862768567b36875393759ae563c745c944a2d270b90feef01ab71af3f772b36940f4c11d8fb401059a2fe1e5f3365a14cacb929084d65c45f17a114b030304b4083ae7f0ca1fc2f2662df810e286f9336c38ef5176bf5cef01b826b58f35b533cc9c5da9e8e07ce83a1cb14617b9e28c675041122a4247d4a3c7f170d995e5c406a083dc799368691e91cdbe4c4b5701368bb320f22721de35a474b365bbc78720d6578d3a8b827423c3913ab461961e135ac79bd700d3d425fe795fb54b00df6f405e678d0f6b503e9947529bc1114d236db97ae2e978f64c040cd9e93e5f7cc76090d419a780519e7428da378a1a074bae36dd831d52272dfcf4e33935c9cd237b0e12aa5bcdfa2b14a7c935c2bbc846295cd8543befdfea5f26f2dda1da68e2a24aa60efdf7a024103647ee5ce4c7935b5a238f77710f2c7bd60c1cc97cba2fafd3ae0cb2b1d217ebaee51a8e12804cdf0c3302c8c2df220d24cc7a64ef250b27c56e761b766bf23ba61bcf9b8fb2f0f03010de635a4c1b3eccbbafedbcaa8ee34837bb23db06c72e614106caca69d796d90e8d612a7d7e64e2879832da3a7d782913d9e59299f8ad11962fd8665b0ba44680c85722c73ac05868c21a0f220d5ee454838fe53b1a5787a27100b7c7e700a79896ace9748ddbae728453430ecfc4b97061b565c64b6c64a940b0abea9cda46fb13a12e79b8dda4f4243a637d0f2e99f408643dc6c2a299a86737327165431b04c034b3121fe0b263811a1642ed9ad0f29a1c539a34f1bbe8c9c0344c63b4c3c95001b09ef7a92d915d19af2f711fbdb7a59195c5bde8c333207f71fbf4b7b9c90f4fe18f0cfde1638032c7c078e8a2438f913f88dbf4891c180993de952fc21a43c6a78ab5c15bcf1df179efddee085a4194a15e7899585aeaba82d8ba8841a3c893729cfb085db0c04b2442efa7f6e87874ffa82702e514aca493e768ab7f03f7ce9e6b5b3eb34c3de987fb0f868dbd60e981957087120681715a8fdaaab201b01abc3e09a5c2df4ced3c00ff1a52bf0a38fa660cdc1ffdf466e12d113db1f8b1d45af4600a1e4ad8f7de046969f5328040f785dbe515b65ca09c62b384ac30c9b6ba66718f533f6db2bfb45388c0b3c2bf1db12ae0ecc5f960d0e86241682ac961dd7f898374ac5bced521dabc2fa11d27f8ff52348e7380304a9a95fa292cd16e1f6e3bd9547eba1c84350bfdbd450d77388781a2f8f53550a82fb1a6ee38834ccd4f6ae936d55cfad789688df32f1f297c304ffc038424f24befb5f911e84d350cca5fbaccf6fdb4c434ad2c17761410081dbd91eec170be8d73580cac4f6c764e166c39b6a6477c2a01385137cdc068d3cf14c60b762ad9f6c5dafe909fa6a8563e62b4d38d7b5412ecc6fd735e212e3614bb425f87440cf1227664058c11b9d0658e7e659395960298bbc83f120335410b656ecbc2ee0de955d9dd454706e22689d3063f75648909c5f8facdb790766ee67e16966355165e72a895f00a1c3ec891f78f181116738a9a24c06a3b6ca4712181c534a7f03cf20a5b5aae0e131ae8a20d775daa7ef4078e8a7e816a17d190fee5ec84ec9d063683c3ee81a4c0209f4a51a6e5179f2fade106e5c6632ad67061482881540e617f53e8d6a8629edd0b8b8759b7d34a08aab4a573bccf9e92841e154063e8417ced478d7e2bf19dd3d2e6786365369d1efa9a48df17c0eb6f28b78c587a41442fd7fb97d48ee95f7b6abb12625aedb4b1eeefe067ddf23ef4792f2e5f9f35a1070a9d95a1f851a8a8b2f2b8a5c38d164c0d6e665b960969153008eb0a1251cca8963c3071b51d9cd75034ba1960b23b394d1a55a4ba055edee30fde333f49c2c233bd77a15799ae3020ea5a2d41c23946a0df9558f287bb62a018dce014a4c0b59a8a26acba80b3b7a9657c2f281da41a34a575d6caa9c89e010692dccf1d21a4fd2cb863f202e3a465add6a422a075bdd65d08a9ee2551f81e36c8c729fa891c034b0b4d8f05660d9ce8a82e1ca5174cb8e30db973443faf8edfe0b0af7fa951f9875c8e7ced69f8897c249bb904a150d03f0973f48cfe63d65440fbbfe247737d4f59e4d60b5edaae94dfec4499aaefbe9baeb99acc7164b1b99c591899bbab98a48108499d8e6abe2ee5f099fb76d93924ec1d71fe554b90bc2fd0f42fa4a49f0ed7291daf76594efb02cee7d8173520120d41ab2fd9f4ddee15b9500028dc4c43757788f17b51d0c65641b3c95843983037ea453fa67d864b54ccfd33b4052ff7502d4921bfb8a193a14c7ef5bf2c166cc2026949b26f0659e680c05ff1ce0443f1da0521ed257b7cff3bf3d7be43b6587675135bd0b759b0c19d68518a623d5045499919cd4c19a1286bd6b7884dc0e76bccbb7ea7037e06c1f53965c690df96a60fc2b8c14da7bdc29a26758b0d4ecff0bf2b5de9565345d3748a1c6a09c85bb7ce7b66f18ffa70baf5fb4fca41fc3ff40fbd3eef8b00e8f058f6ef8f3cf1b338001531a4d1a6db92bf24f0a539010a7935367258953a58d68a4547dad2a5a7c316103abb48a3de4621c1e86edfacfebec847754aed0193db54c2317c4fb7d81e47e41ac2cc3e1ef56283fdeb6b75cd9547fec4c9d12a5b7345c9f1baec23f2e2436b7ced3243f0a86423f4eaadfa7f7205c1740199fb065ca3adc64c4de577d6af37b754dd912336de8a9dd3d6a73857066bb688459c01e143add072c4a2ea5bd857bc20a1d5b250ccb19ec1d4528034f754a60f6ff6905fab479975ae8393f3cafb57b9fcf720e042c17fc7df03116115ba9671fcd30411cab51c4ef98bad3a4fb69fdedb215a04f7d1ba7093ec6987b13df3c4683e350f5feb451c0455b901fb083e42faf92a270df968ddde89606c11d37cf6b6e80941513e419a2978d853c0e18ee2bf7d1587c3559baf83ae83be014c8ec134c2a94fd640248a379ac3133c7ae4ec2058b08f47dba902b4bd21783e6b53d4f1b58a4ba421e2e230c70f10bb52a7be260bad1fe2016dcd4bdd6ead123a9577699431fd2acadc4174c180d76d9b226f52cd3becf4f9547c38cb618025f750e034e335aec8bbccb49d89684c22eeb31c5db31798e2b988bebc2017bc1fc1a4de460164d12ee20d5f6441ff5de5005ea2b82c8fae6721fff527bf269a9d3bcf6ee7a9ae712e4a1620b5c536d6f4384c840b1a3556483fbfaf20c2adfc223639b43a5e03d05d09cb8b3149bfd99d46bc47d7073aecc8972feade5d6c03d3c57a8c0352adf6ba3a2477a0bf014ae9ffaf4309ad5eb84e7318173f6f6ea8e6ad3ad812392aac69fffcf197b8b531b017e4a06bf43b58d20fdc96225eb31fea8a8a35f2604a4eb61f9a8ee0f8e2f958d2b7ba7741c4ca6e11fb5336e3bcadc94f1c3f72d31bc34e740ad5322de1662f8a7013961a5dc5aa656343d2480fa56eedc51c75a07c037fce386a25742e14d0cc5a1bf3fdbb10cd3589d13b0ba11414a8ab9884f40db5cfa8f3598f2cf28bd39e89f236898ea8e03265c751fb749d41d943476a1e9d431fdb06ce4880ca7e822625ff181111dd0edc117125d6167f8e502bc82f862a72c7b3b902269a2baeb95f0ad36de9cf57742965a09df5d92345973341fd92c6aeb2b2171446cbd8e25887e8b798941768cb045d229c84c946e18ca70f7404264cfef8023c808f8f9b03af307bbf3048720e890f4c9f315a349ddbd7c753cc870132c876eeab209e2e67387f36042a91ca239d7e127302b1c093d2035bdf1907745b3711242e6ffd12d41f79ba36ded0f4a49d8f0c6831814865b6a32742f0066d69ff2216e1fd3ca4eb68b290e51d9f8ea6403ed4e55f1b6ccb158681170d5b80f0c32400fd07a485895cace07e982633a569bbb4fa68cb54ef81d0c8fd034aff8314ed0e3eff732025ec4a010c711c3466f6973ef0293b1898fcb618b6406d9e140732f2faef6e246a48c6b09d44b26939444393972230b865e97caa1ffabc45ddbd555b5cac3a72f268d1bce51069566b7f36225e21a40d4e31d95f9b4fc3fc22a7c288f2fd64624afda1fb8e0f1e5b0547ca83bd95cae8dd2e9711e66d59965f0d0defb77227dfd8f36289a0652266ba7127fa5097ed7dca91ba2d88d17881bcd1daa7f17aa118d4dd2453aab5fb33b713f1894de40b6819e0bd9fc87386600ee2bb223f30d6f00a4491280841208670bcf94f7c501e975bad47ba913ab5fc59f688cb9fe4030c44408f5e5b89ca5cec1e27c48f5fda9572b2f9647aaea6c3ca88d858b065967a7e4c6877d29cd57e92221e4833e57e00928237928abf8e963e91786aae3f0c4e61ab579478baf07f1267faa819bfe5371123eb9d1d0a315afd871aa0ab75944812f002879c37f70a9dded05419438d3b1ee41f1d5b3a32611fe6b9e2d48a429d952979071271b09d20e36a2135a7dacbfc48b0a6a0cca6a8ca5aac70f5c068e3d8949b8b43ac4444c9c2438b506bad7f1ada140c41fa106f3a9cf0f3d5e438fd625b482a1e6cbd6c80e6e262d1927f535447d0285e9bb635b837b0ed6ffe97d0b681f9d88e0bf30139d1054262085b5278f0fd1f5ecb433634098e5d87ad57382be5c27c9c1305baa4834ea8af43d610c61d94d9e214dbd0dcf962887f4adbf05044284f090282d63ee01f586ba34df6a9339fa3ebae735f6c93a1efa61afbd2a2dbc1cfb551287266d8bf9203161066715767cbb06804cbe844b711017fbe843ddc4f618fd23275a6cbce0aa45cd1b3df9c67a4c72e43f5df89f895aef0fcd65257f69ef577412e9126ee1e8bf784569de295501ac3be10705ca6be28bf9379f429567953d638e2caba0543352b7f686070b343bd1f956022a2fc65250e777317888c35262fba1c7211c6d5f180095b5f62b4acc86a0b7d9abfef61a1ff831aa752e9fc413d69218094e8c6fc2b168470f14c600787460e78618e4f7ff289dc963c619d7b72fa1ac5a32f6529dc296a2278db65749882fd1d876b861d25fbc1a5dc98964dac19c26cfb48231efb6e2077ca74c26a19ade6b5fb73bbb8c4c3d970dc9808e5610a83ca04e281058a8fbefbe90ea640520f388ac7fa8e65efc590686397fd0a8dff2b6454a4a195080621a02d4d1545eefb906823dfbe6cdb7a25dd66a683ce25ab2407d76841bf1d5eedc5e069cdcbb7f5a33b887459f58c1579a0875efc4797b8baf3fd566c7955c6413e8f4e3a133451f7efb5935fc2208dd34ea9cee0757d97c31722162d999d54e475d8f085d397d927256eb63a8024c3d828abecc48f295daf17e2b3b37e319e607f01277522c75e4b99d4916466ddafd63a71e06c12e8b1c6c4ae5708e6f36ce89420a0aba393239e3922a10c779c01261f258abd9c0f5995482c094d3c18f3c60baceb3eae52deabea53154a162f25c6534bf5e4b20e5ae1bf544e70ce7de0db6839c4e753f45b4fe0d2295e50640500417de4b835951164930261b6fd801752255b888145ae462d2a81ee926ad940bdec98be22c348a3d6f3c99cc97039ae2f5fc890d10578ba977418de1c5dd052c26046e07a4f6d57af360b6610e0c104d7930273d6939f31dc3a8e8a5120f2abb6b1820fe791aa21f69ffacba14e55a2ad62a23e0b3c6c5749c61f47b4200a248b6f085d5cfa9f57efe310b915f0de11777aba8c5e776d0cabf59b2af45c7d473cb7f5181cdec42e4ce8903a9dcb5d8915bb35472c37be7e1d8aea488e31f0a26e47d158f119a04f25f725824d80fc450bde5a1c0fded9cb4cb38bc553945ecd9c2d117d02a14cedfe79fba718a571d6197220c140a1ef1a2f9b135c5d26effa767b6f3a89360b7988c30102f150101a4645bb5225a5b186b0bd9fe40ccb26b0c1dde0d2b8372831b441688d9dc39d7836a7e40f060fedc2b41301c2aa0010753e442594eb6466b03c77bb6d6e9ea6089a5907fb13a243420f21d9fdd3cbbcaa6226cce479cfb5a27e581f03baf47da1ec932193a1b96f227ec8afeedad00fe2b5e83d6313d35801dccbc55ee108539ea5958026f068210a734fcb080fec82e5b40b6f4bf7f5a525220c1fbfa39556974ddaa9cc03aa1ccdeb65baa1ac94f10c77cb4783d7c8ef22a5a1f8ed126fa9d894a649ba7176530aefe68e6a2030234b74140b821f10ecb7c34a376bcc5881f046604423adf9cf4e9b304dd2c1c78798445934204c4ff9af9be3655fd478858e6adcabbc7a0a6613f358ef543dee8b5400706496fd2849681342c13adb14661b1daddcafdb027120da92ab13029cfcccec94dadd145785ae622fc2215f78366641c13f10632f1c98966ce1e4f7c9fd867e074c4700d4ccea892bed7b50bf07eef25dffd0d9611c045d291eb1ab0bb5d4e6e9046cdf5319bf5e1ba5c1baa520f9af2337102a6732ae8b64c37eba78b51d36f3d43fb52c7c22322a7cde3bba30fe599babe31fe9706f70ed6159dffc9d48ac926723a279f0e85631cccd80720cf2b63de2c43b46e9cef2fc67683a4d9eed5df1b4e39e802b3744458d2874c18bc72e09d622c0e28ab483b4d114338065d10b028190ac52bc2bec5af41ed56ab1759ec6a072e8c58b9e4a0bf83c8514510ac9f16604ecab3459d8f648f1d6da1737074f27dbe1746a1a635e13ae259ee0a2cee754a8ef0d4d6886ad0e3a58d04cb152284f30d289844c586670b6bd5d6f066099f5fa0a6d4880ad97f6e4e14f540c8d8b952808b7aacdbcc57bce0087e0322334052c25c312ad66441abe421547306a090a27201347a16bdac6e084e3d0902f5bb048bdfed425cc8d854d95b08a556de90d513b82d153f5bf69ddb7ab5ffcebd5e74ac55f495a8400c29370e7096f0e6d92f5ac7e09e759aacc201496c314175103644535fbb00bbf08ab124e287c8430a7647c970ba8ac20fba8efbdac073646ce5347f245c81b11e29b97c4148030f56c35a0d8e53d9ba53020af9e14cb46e9e44c3e2de507d43d7a41448487b132e2cbe8fa01b4503eaeb7a61b27738a264bb7c300e981f129e77b89df7b48c9aca77ce2e996abd7454f39922cc9e362787d993973e0d16908461897f7ae9d6362233992659cf2d9650c3d6854eb504e3ddc9a0b45baa03f5b6382290465b2a7b57ef30cbdec5ecd8aa84211fe3742058636171c37ea0d6183686fe4ff6adebc8c0bb7609c14cb99ac86e54c5defc5787a061cd382a46f88e5eeb143e9253366915a4234dd590983f0f7230c88e48d89cf27c867579714d068dffdbf9ce7cb9a8768f455e2a02827b64d08556b1750ee4adea0f0a6b562931a3d4f667bf14d092a01617d3550cf0ea10c37db30c4f1779f35b100f27a530b8e24ca2ce663e193ce721fddf734618e6128d7738980e1d8fdd66763e4b9604377b898f9a2b54c14d3c908d5c1115d7ff6780db7eadcf0e6dc6666f48ecbb5817dfebc1c56b5b9b3331f47e69f9441f7c0b89c3afe323286336bd6d4f74452da78f7e2cc94ff37be3cef8b6ad114a08d2f4b1e1d77ccadad44347dc9452b7f7bd93a604a164c28426622e0ebc1280e1869c7adfabcebcf7e9f4334397ac0c5ed98131fc83f76938dd2e4b55c0d7daf5ed3b55347bf7945a878c5af87ffa3c3aee1bc643c20ca75028a3e5674921dbb3f3400c41d9b421e1981f6f44d6ac399c93c706807b39db75a8dffec05a6fca6131ccdecb2c4054e83c458027904ee37dda9395cf9943b027bfc2a2b5a358c050754c7130d7d5f15a43af2e0a4a8d6dfeb229520dca2c3d0570418ece180ffa3c049f4fb471b1037de30ba11a7707eb86d80eeaf293e40c35d23fe1759286c262a5e8da2e28ab6e51d8f9676e8051d25cc9053bff106ad9babc70d1ecf30bcada2e14a905c5216541c6db1bfd4c882665b76fe20bce2e61a33d42e40b3bd43369bdbc0778d688f59ab11156544ee4d9a685f764691be02a8388e221cf71194df7365c276a30b91fee759fa0f5b80e8871d72df045ae8e0dd839c912f1d5b3e1bc10e64f2b81921051419c9979cfff9825f690adb818241e9fb04062c531ff68f3a3c3777dc010de3049aee26b82ea7991c105843010b3db79bf8b0bfe1196b4b4a455b878e2c6d7640a8d628e9e4c9a3f935215c2e9215b22333e994fec6a50edeab181ecf177184f40c1d758ca980614d59ec11c49d1607829f10dfbab0d1b439c7d20cf5f7a0e8a4757f1ef59dd9f011ff9a0d4e7282c31191e2f7bf1185fca0fdb4a3bf0c906b2f48df38d70c9d5f4b0481a5fc536468eafba0657c18f7de166994b129c5bef146e1ae9ea626446903138df13fcb3640b634abf2f702b77cc49cb760c9747539dcad24447b64ff631ed9f8fa2f57bac76cdb2e50c9580c33341341f170d5dcff8be8fdc47721c490ffa02e8551ca613d114be5614b73671a48b9acab5c0589dcce3b3275f124cec3ff365f50eec30e0a8b7fd5d8e103757e1a5034de0cb3ed3e0442da637021f908b8e1fb3515db6f5a574587c2dbfdd52fe63cd1453d4d4001e06604119edb2e1102f0bf768ff325ca202448e60f803c7bd278fed9a69c9c894949a4f8f9d234eef397bcfb04aaddc0c56c90ae025987d5c871c15f1d92be7a2d9901cd97e4819f9c3aef0af231bab8980da95d8d05e2e79cd16d9081ad42f7390d808034d0b251ed9fa132427f6e20cf790e99aabd35ad851d1215056ac18ed89163964c2d3d8bd0d88f4f4408d19247b15287faa551d90c8f4dd0d0644e4cb69d53b44b316ea01ac7e730c10f25b72187ed61dc4fadac26f3203564d146f092d8389055b8fc0dc3bfe14014e58db10a4a136459c499807e0bcb76b66740a78ec8141e0aa01872a6578890737650903f3db1d377a7f2e033fb8c017fa1e798b07e6b0bc32fc89b8371e87c720c8cf540cbd7b7f1efc1beb073104ef2966153180cd2c87802d4d4325006d2cd1bead49a483cd7ef25bd4294cce77c33598ef1cac149e25558fbd3f345e463ea9da6d8d3f64ddb05a1e14d427c7a436dc905875a4cf913d1fdbdfde3f1feee7085b46c37551b5b0f015dfc54a9c9a59c9c47f2241e11b48da32e1cb4aa54502f9af7f07948a60dc3f3fe39cbd2b32cc81ce23d540d0e45e000f0c9241545f1bf2459d103997a3f1a92b1ae728cd3dbec539db3a38466633e6b3489197664cf2aeeb7282dd5f4feedc65395de76484981553b538bd7f3b164c5bff4b54f3717a0084e8afe2b939e9a20b3d9e1cf28ec6823bd1b6560325cfe6ee9135adbd77475f5e710119dffcff4bbf28a00c1b7079828563964e85948abeec707a2a36bcee527cebf5459adcc7ba5e28f76060fb65bd57ed5f6626734faf013e4e5db9c3404c8797130c1f80bd526296162810e475d572e65c9519f6a175dd797002d1117b969fbd0bb1ec0bf11b6f2135daed5d20844d9d32f70850f2802aac530d55b9d96231e4adee575789d1976f46d024f2d77b5aff3b3570eb891fcf5d5917e2422bf661b4097ab86088520018f7d51e5d7e44201e715432292b09fffcd0e07ae115009cf1bb59915a89636f557c87ae5b217fab543dde2237471478bf12a5ef3993e55670aeda2fe1d4c566b188e81eaadf273ced8f758ef637683a7522e9fef31504bdc98d340e0b1fae3131707fc53b376940206968acd10c03f8a10ceb5fee2a0119d7d6330f1aa453c5625a430d753d00cf42f2c8ef2f3d83c6ab6ac2578cf31b871f36c75a49ba6b3e3b11084b311f727830607d9251e55a2378e5c58a078c69870220705c3c1fa8bca85b767d4caae6ddc84b9da22d74c75f51017d1189a8c0d53a1f3b4fd472e004e94c584e7c6fe93900ba2e065e77f70dea1d9403b566f679aabcfd9e943c864a5c50917b1a24f8ce9e40b8ef436d9d93d1d953bd1ea44af2ad5a6cabf089ddd2ac424b3c239bf8c6525c2b6eda2771c82b99b9b618d456507baae2d271fa597f38f1f475ce21e210c1f987718c677d78f5fc12ec12e657d1cb5adf1cfcf28036d0964a46163c357451ed20faab7ffaae5527623fd7f4727bb0d9a741ef53a7de3899ed831d4461efd6c67dd6230eefbacfec39d594217109ebe0a5b828d852daaae489eac7647dfca4194a60f8d3d2df4c8d2e6e289870e63e9ec9930fd16b9e7b76b3c6a8854527f3cacfc74f77b6e542e14143ca480ae3302e1b75314ba7239ca00eee1c5bed78e29f63071c47846d7c53c0a0e862fa453d626f40b770e5ecd87a67120c0b8776c297ee9887fb7ba9f7790a810cf96ceda88f6f081ecbabf70e26de1b51c97dcfa7b498d13fa3177f8df3b4cd98be9489df5f030f94bec606139120f0f8d3732c2f9a3563e59fb54b67ef631aa5a526da42b37d69b7d1962e3ed2fcab6bd36afddc6c1b271296b392d6027e992a6a6cb8bb445d759c66cddca641fbf59a7089db82229c51c24326e654bd2680c1bd5290fed6463fbcb7f832e9f4812d33cf7d803f98d02f97037189805bbcda024a2d2936fa243a5affdf2f06f8c1846c037e48c99ef450658766ae23ed3e219da749e82f761f795db4a74e9159fcd7ecf538162282a7c31b07f79e753afce6f1ff70388be6c5d7b2ce16f6a8d1bd3a4aef881b5692fe7103d41c3b9d116cce90be9865a12b8699f15e0cd0649ce4cdb5ab27eef7cb3e62a8d6935ea31bb7c75521cc934e3debe240e0d51a0a51d1d9053a74aab6b6fad45f35fae7d18e003cca5919e5f9ad4886de677bdcf9d5946d72e48e35adec080388ae1aa017a76fff36d07280a170f268606a2c29b4be4e0fa0bf2b4d51758ed102fa423418540b1d14d03f53c631e049ea567468b13d3336b084ea6d9de277d42c317e9bc794978df07e4be5cc079acd15f31940cb6da42d79454dba8d8a124afd38d543b77ad28d496d58c97936dbd6da158020b9296cd4697114443fb73a754f0a3c42614b71f9f420527466977dab7ce360a954bf869abafb4cda82af2a303f9ae86e3b2d08bee33deb18421355c73076c000231910c032ab4f1893db802ea41b2e534158a9e1bb481437353c8edf985eb93e0decd6d58edcc4fd7f1ec8efc650f669430950c33796f2e5311c6e4ea821e6474b354c0a3107aecc2be341daa39b2c75fdddd20c0b27845a2d7e95dbf73b375f9aa307893eb82b98abafa1dbaa7a1a10fd873e77a10ef3244f7eb3b38d26df8e236d6eed2fe2f33882f1f96f36b2c73280871bdc268cefd7ec7ec82cc80c1b2a30e756b66e7d25a9644d572d8ee7a376921d7de2a13d558e5f0d84ad50c5d99d7a785f72d86b716e54297cf6e735a73ef9a716ae6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
