<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d40baced4e7f0f09b0b9f35f776e7ebd83f31446b32f8e74ffc422c51ce14023bb73225781ad35039dbbdc82987e462edab7e60ac41b4ad9c2092d45e5899dcbbc8ee6cf4d2ab974499ff1757ba8f2e66a0a72b3db5f9005da3c5574badefe660dcbc729f8d8738e04a8ce05fcff595d07f81e3eb7fe772b5ca43cef7a000700ce64093d407b6726f49700d13fb1e1a65e2dccca940c4e5868dd1d5cbf5f35dcaa05cc694e3d3a550b1effd5e5def0f36be07e813f9cf7b4a4789b1156d378bda66b8393dfb51f05c6630267ddc190af055241384fd207696e3d19d47487215b3384cb29885db5f41ed292e93e26468a2e9a0de7fd7e0213a703047dabcb3c016cbe6dd94fd6a7adc9f4498e39040c0e495dab6f6fc260e6233ef2f906aea4f4c8576c34cef96089e59448a321ddfdeb79042f7cf3e446821e396f62b7afa29c8a27349e861c33aac533687e286e1afe4ac5b8a2d06682cc1f10346d1c8c8226f0e310d9f08262953c7d06fc35eecc9b87431ed2de5c4c0c68744de44e9e382751c828ba6d23a956ca9f441587c0a287441e653256ee6b33225dde59b154897388a71d443e071e316130984d5e202807dad2b811fa63135c30534b783f88f06e7fc05c705934d7985c946ff8020397b0ddf6da62a32a8a46bc517a50bc9a420d5e7db058665b0a26be2c8bb54c1de2c75c2090b1c15e9c7920aae3117465af1c2c026b2563e04adb460f63528ea2a9a363cf68ac559a2abc12f421471cc76ea5286a224c5a6294bcb56b432a21cbf80b775aacdf6c05ee09d7b56816fb43e30dd3be0a0c385cc75b153688b6ec53d8c50154b6f2ce7ac7a64992d26657e6b9ac99ca055c2af48649ac276940ed54fe1234c64f7ec91fcbceed7392b771c3bd12356984277b305c15c69ff29d436da578863e35e7c7765cc6adc645babc26e2602c160d2864ec2746274102edce06a4d8ac2236e9a0d6d58859d3c6dce9f14f87bc3304721b52b07a4603a4abf536f315fc91d68a388876998f21a60f5123f83e2e66e7d1bf0ceaee1814ad3bf85c7094d237d9b8fcd8bd9b28f4249e9ff129ca6ae656c98b7a45ef6d429e07bde426df73c7e2c30cc28648656cf27024d3f8fbb2b0561a59559432d8543ed567d17af439481da647f5ffdfb1a0482d78ba80dc7567960bb4b28e2145d8d3ef924e4e4c44083def8e18732529e5f7f975b04276dfc5a31b9b38a24f4cdb3e3761ff6af595f6522d726d5a37ea2aff29fb18c1355afd20f636555f9419c5d290126083de1a8500da0ad304dc65596466ebb3399e8d6e7df5dbe12bf8cd2b7f77aace276a6b7345e7d0bc72395475fbb254cb454b1ed2476729637e9a94abbdc98247d9dd9d1189eae5b4ca5b01091a4f1e345b5e1c56f64bcf3a846f8713f5a864eae5177b88f546cdf1bda68628d08d49fa7fd42b8d67afed2102a7d3dbdbb57b93da5e76d3bc183351b78aefc9346fa35650c89fb46da95b0e42b2bd6a8644d9455a50d3aca414292113b618207680da2e9321855d9474e57244941159aa9638ccf26a8c593fef72b2b79b08013699243663a2c84d208875dd613b1b8c2d33eba476c508e95daf870e06b99c4f4318cd59a13a9ee0f24f453db304eca8094bdd2c86c4c0969f393dac47c0b705106b82548c34672b0e1f3d4bfe0cf9f47d2b9ab90837a65497b798858ee8277ca9f236854b2cc9615f49715509b295761300fd991133e72954c031b0ccaa405ae115453b150d111fb1f6ea04ed8dbac0ccf55a494f39fb5616f7e09379cde55b210273fab0a1802c74370d3e65e2e5a2434e3225df9d13a3db079936750f2bfe3952ff432c6c35eba15d684c7ea910b9bc396897a0236d53402644cd9f77f435f6897fb541fbefac03b37d249d2fdb270cc5a3ec302311606fedc5b20937a1af125d3668980fed5b5ecb69f751faa2e8de41b1776eca631fca6da89b6111f9ff8423bd8d505c6f05ac102ee2d2a09e2f96154dd26754ebc83fef2bfc2c0d74356d64854e5aed1dbe0b2715920c43af73e6fef8addcfa3b2177d80ef78b7653b03897308664a116fb6d4b9affc1ae3cae360709f5ffd022aa00718f41992048af5d6c45904ea90f5dcaacd8069b9e16f730bf075d1673b9f4c3e08d0028e2950487478e77cd8a36f6190435c6c8efa58f9c27f4417c4cb76b510725b9236692379546c4b8721c178044dceaa4f0eaad281d131d96e5adfc7871ca605dd37c31528398b9f5a2f7ca27b3d6316b21e4d18d9b58a2113e2ef480facd9284463dfe8547cd41fa9ac2d8707561398dd6c0438aa5f1dae36279c223b11833a01908c5fa159b4e7f9b90dfe3547d45d217cb9f34368c135c65dda85d2541fd837267e7692a9d72ec9e5353f3c356d989c48d5779a1a32d11e50dc79c74f4753e4f15c0cdc9ab957e1fcb018a745f1ded56df1a7a9188682a833c75e6f6e108d92ebec2df145b282f0fc6c7aa687bd4a2c82cfa13c90ae927f780d6604c5e078609351d4d0066456d367f121cd0f4061990151ed2eaa74686b0f1d49c6de0bb6b80ecc2265c864022475ac9eafe7cb34ce7b93b5b65305b4089c6354a8554c48dd8939b0384e24bc732c4855bc52059b3e908244cff637172257336fb27760dec2a06de9287348e4c0937439c672044488e9630f53a655e76a350951a7b28356af0f4ab3b05ec5fe81a5dea31cea3d3f550cd1098e5d832df3c39c55845440e4fd8142c85c22e31fed55dba37ce15aa2ee754a852d0fe1f4718bba14237ede542fd9c5ce29d7579c0190fe84bb838f0c58284cbdb7dec245599bbeaf444165580a287b7e7a91c39c238539d2d2f3fadb17fe7a0303ee1d9179055f989d74c150802945b5d118f238d186fb8db0b0f4aee89748200c50f1026c630ffa2c8a7b302b624c4ebd884f0aede9957d43f93a4c10f771ec986b0e7696bc6eb5ac18db7e0183274ec925ab6fc48e6088094a805d4a68c49e5120900a606db5d6207f234347c08cfd86c0c27355d0854f88dd241cef46955b5a5785127452857f3c71ba67f2a9f30a76b6199485d26a4f43b984df2aba6dccc85bc75375c611ae8e1f48df98986c508bec4424c879890637d9a80c695f830802a75845684d6306ff31e82cf5bbe52a9aedec587f95b18389b7615ed9fda551300f22e112f785c2bb7fa817b93b40149b33cf7e54023d1366253deb85ebc951e16d9f4b78fab19eaff9cec26b13d319f3105338d54ac9fc274f7af20b5cf0320f242145abff8e3939cb7866efb76822db0b22bd2c4ce7f6c8679b7c30a957f5378ad0055835449c0074919a936ed4ec7cf7de3ac586592527e7564e8939beec25994c75dd20cb584c80f38e26d0499ac13aeb0692066391881a4808fb88531e79f091b6d6fa58115322f7d4b2fc58807311b3d2d00d27c1a508332d8d0cbc6ce6b9d9319e6ab3eedb754dac939056580cde1504f652a7bc05ba90f40b1af5162e42a60c1c08c62060d89dd0b38890ab07f2ed22f38266c468636ae8a767678c7ef6e1a0d9ff31abf63b31227082bf9c2a4aa184f10c10eaef0025204108bf54f4adda4d5f45960d99819a15bfa95569a7c440748831dd6794005ee3c05a45cf809014e5ee5cba0047038dc1933dbc36696480608f0bf9729d26a683edbd4ae81fd572b7ac42195ad350ee9bdfdc860b2bb21e781e856a43fddefe073dab9925126867909a3636d40aaff65df6265a322387a1d77050539326781a22f85e127a68edd566dbe878aaf820b1d05cd191feda939f28c16e19f2a23cdeb1ce39ade3946e68ccd5f60cbf4ea89eaec36cafa74ba856bed5ee3f6ead461e9c6fce1ef848706440b4079383d79737fca425ea3182800ee0974495354df6ad78d8d826cbd791cf8a8db734384968cfe58f769941fa8c976c5f733056d72f35971fa3bf4c802fdc050dc06a47a085002ca48538f4bf13fb11156934b0e748b54e82a445ced44db34bf1ad9d89ad7781632e31e3397c99407b39011290bab7b8eef2e772a50c540a18ed48deb9ae1a349a98a244702329d86556d90259dd73b32da12c9140a57a04ed84b639e7abc39a4fa4d8116b94bb02092c29d49b0bca6f6b9370f3977b45177554a71b4f89e015674c2de8911cef6d06bdc195655eca68b0419f170e4075a0a2187c45a9d94eb80eb39583747c926d0e3249dd6a93dd7fddd4d997e2456e4b13decc56f8c0b714e13e56daaa70b583cd78643c352bfb8400cb38e8598037df293e99efeaa973a9c35343c8937308152bd1e9ec9c38aaaceaf268c8c0939c24863dfb1a92b777d1f74befdb437405ed2e020f335151de81eb8dd82a519136da6b1fe31f61d6d43faa18e9941c054b7482c0674a23781034e230553e102b6e00e64c52d2e7082d7fd90f66c1a74ce49e41b5762f6a51dc6b0707a06e0df89e47666ec87a2319829c8498924184d5e643f0d6c12ce54107687cb8786f004e376bf7a3a44bdaf77735fc4e0f1e51ecfb5c936b26541daf0e16f1a0b9cd1dbe4761eeb1d7a00d0888aa54f7fc3977789aa7d257bb9860b9f43593e2504fcd4bcb48f97f791f158b2a977a72ebc2335eefd0aacf5c4c8c80f4cba8d155924643976d9adc8f8e992bec55208d1e4c5d24cde71f8155aed50025988e0ff2e4a9c523ac77aa64c52e6528f01b205db2cb6d94e39dd4f858b3d376efc48ad31be04ad5d3e6dea9aa8143d4a5be363e5cb186fff180a6e88fabf2a3bfd614555dbfdf71abed12284a85a7ca5f58dd86660ebed1290b534434a91ffe9aeb3c02dc05ef9f3c2d6896cf8d923306433645bc017bcdcf72ea91f56605f26b91ef389f10bfa70aa9ca2b50b9787b39c98597618ffbacfb7cb38d2005663f3209a917b23295fa9b9a4d5dae563a8b191173af0a6276320c3e7afa4a4c307854648df27b994d71f2b459cbd272cc61053a9097c252632fd15b476de5d984c5aed9ef72f10f5ac33d4e01a3aa7c54436c9fb97c40c78398cad3f3b77524ab5f7c8a0989a5f09eced5ae778899c4fe28f6302d5f790e9208020847e86b5943572166b454ef142843f55726500113149d1daf0929b286025e693a0a17f01e65c364a1ce8b5fa8311ef4b609153a05acd6ad2fb1271c57fae02eb559e2dc6403f45efba63a894401818ea5b876a6f3dc056456469b71fa4289926cf9107f4baf2db282cf6b64009b03134ed92b191409a4aba59c9abde4c15f0ac58a296761faeeb328631c6983a533f32b1076ac86d3a1ffc373fb19b6f8123be83484fbd35e0bd24b7ac099331c5582621f294e4bd53b23441dc1d41c8c321c0a768e39078140785129e9ad9d28f3b5d820c476c58cdbc347724c092d4d6c72f83826db696ff46d984d90dbd072cae5f3a5cf5e2372b1fd1f8615dce4a959429fc4b6197ea57a81b8930249cf534a8bb9d9ae6384030be0f6001041fce5eeb5934ae12c022410a49efe7452323e437e93ba0dcc985e0782e03dca6d2b455814aafe66a206f5c6cc4b2a4aedb280561bc66ee8440f530af4b59df7a66af2bbf36ce4ec0ca03d2cb1b3c494445ca7548a84cc232eb4cd274bd065cb5f0865c853480e677adc70a56c3fa2f4b5b6c2f9aa8fad261f1d52a8197431d7762a5ee58621b10e9d94d90d9aa2e37aadec1e912481fc44eed65917cb0f95315c795a1133e3b4dd119eb361d566e8446391cd3d3d23915de3770acf8b887093c476655cf2712045adfc79f2c77767fb396d243984fa75040589e539a65eb47721ed43b68672b76ae0035c6a24282ae882e8d05998c7334652406b924196dec3b2e4d3f878c149e7a6884591a2d3310f825131e5ac1350deecd5288264a7128c54d0e600e51182a6274b9664d6b65c46de6991be8b06a166967e6dbdf2b5595ce5007997a4ecb1b947f5949c2312c65fa2ecfaffe33957cc7d0d236c215e27b50238f89938f0f2fc38a804cf0119c5d7f689da7f1b092220f2caa6e3b9edc43277ad5192bca2df23c801a45f5217149387493d0057fcd1a6410abb80a62d26ecbbf26fae91e3de9ef86920891692572ce1dbb5938a2c221222caf21302b20291657847f7a2cfb06fe76a5001bc8a54a7903370f178ea0d99d1efa663e1ac59640efbfbfda8fc525da6e13050e8e3bf6b9d2dcc75cec81c7ee1570b0a3745d5747f33e84ae283e423f818cbfcb4502a1939a153a469197c09a7945d6ce60355b4a5c3ac0d101261e056eb8c54c8a488deafe7ed4e3cfed9396d01630d6a90234ece0772da8cddae9f0e9da587ae26543dc1d9bed8d3f8c94a8bda95d145a569cd808206a574a2af2e6fd83b86029246352635d10e5dcb59d8d167dfda4a84c10e898ccd5c3eb5ad1a59304d22ee06ef500be961c91ebd7565a3836a6c7d9fd9acba000ac619d2bd97571abded5d78e66fff326f4df7e472d42f24131c1a7f373bc88dae821491464982e2166a87725427dc4897d51910556d4bdadaca59980d611de50b449a6bfb13cc9a7e68434a0886ca6ed4ca0fb9c0a609bb9e2f88142b7278e84f6a15fb97d4c421051f67b8c171f5cd919d6555a1563fe120eb5f1dd1ffb4ae26587859682ac7e81feea944a7c0307c2f6dfe378a96b52a8e5d292f35cb47579b5455cfc4c8088ab0659acddb05f0b7dfcdad560b4d4de4b77f882718e79bb1092cca0850eccb7ad0245ee57a32966467f3e4933557ebf55e189ddcf5670ebd97384495ae53e1a75defab927227bb697616e091181f1f5b9b0bfae797ed75021e64c28b6d928b52164ad9937b202604484f788a628e0bb59380c57aa224e9c59dd4dbc697595be6815cea149427c0d4240c5f370d43384b0231043f324524491323a6cf20c6f3b1f1f5ca222346275f9235947573eb1d318eb407d41121afbf4be0c6b6e3362526c1a0941e4a861aa8dc8af9d51a8cf4db53066562cd6473507e893b80b483f77fadea0b498ab7468fba2dfe6e5e5d332a88cda201f5f0f67eb9560e9b855ef0cb00d7c04ad404325c48b0632d7a96a33967c608d82683ccde2a4ba28336a39c2a8d5a3ffb84fab54066c06b2e5b2955026720a3ab5a56833cb19649020fe623cad2766d90ff9ff967c8011710c3c424175eecc910a6c7094edabf03f353df85e4eb0ac663294e8467d1abaff26854c7660137d779ccfe3b180994d608c902c54348d2bcf02d04923c45fa7cca71e31d47c57b2aceed98a5b6e8124a77843a4543b35bf7cef8eea9bbbf85b0934b3eec2bbcbe4bebba1935bdca2ba5a51b20e2b6e215c2d0b3388880f6c3d618d08aabcf01681316139a0081f5616658f97cf4b7b54fb7f46d42466f70a5955d485082de90f95a2f69197bed849233c2209a23eb668748cb6a71adedc3bc565e866ef16cd1375c1182233ce1559af657476a84f821a90ac74b61736cd663c5c5815008754deda1833263152e8949880513eb3929b89f5e5a84bf38f1615bdc0c546b715a2739e882b7d0aa5c308e0b7d9e5873543e94c80418e5bf0f9ad62a5c976f4a934bd28595ecf58e2a0c4c082998065378da68d0b16fbbcb2fb705e68f0a9524746c960a8c885eba121c4699805386db0769f57d8130283284d2ee0b7c25e32d865e82f3d66a2f1dcbdca84a2ed923a183d11ec85a3e3d5a6aa76aaf663380d3451e70a5592348d9127f13cde0a63bb18456372d2918d229575010e2f48779b10df80c6c8b0104d9329705a01f9410d313fe04943d5b3fe8553889d18ecd707c0c9f221b8c195ae27d0fe30a83bbe5229032b93681e8c6055f5346013bc0a0aff146186e25dc0f9eb8714134c1b05dabb5b5dc15689b5357508f0147c80e59ac1dc5888b2078026cb7d5f92fa404417d633ed74566948fdfc27e59151f2eae58eb8095c971b45a7814b2e87b942cd5ae0b310f57250ec2ab93e3e813fe39443abed273aba767c49c50b387b5d1a7a92a035952c6d39b400355879a38ef07b13d56c58ed1cd9ea17884fdb773815f76dfdbc4b0c6a53a22013a08141745284727625e0a032d37c7e5fbcb2254e23c3691314e9c011099c21a264e4e14be2157f5ede9c6ce3db77661572c7669ffeda21aacd297e43b220a63b753c0584b1d8144e856c83bca9c2b44ce83c72aa9e9bf6b4692fb9b9e7758e65b9305444a52dd5ca9998a6df93470bc48b4d191583d8c0c1d3b96ce5de5a3924f9b2a3056ab9836cda13603a5d96552119833c4ebc2e53b9463af4b2f1472f9fd55c628e987998d09805e5465ac6002df1fb890ef8f40252b72e180c2718e8f25228a955b94f5ef0eba79574af98cbcc7f9f476a93ec1b36c07cce88a02419faac8a37a2577b2e12ff763670ba262001bbb125c1127caefc07a310a3eb017df193e4c040da00aa44088ea6310540ac37c8b7c56d591e7bf24b9ec06369cb60342d7b58d53f4089099b8fc879dae293ec341c26a3d1cb0097bcfc4778a84d78ccfddae1000047d512a1c39267f8467fca3f62b0521fc4746197cfbca08b0e61d2909eb9e91a19fcb0fb047e423e76e0a07cfb06a431d8032300e6b49d0f56d54e4e5155c0e7dfd24492a73eed392c2572ab572cbfb181d784c7a6cfa7ec4f9d567de92866b3798ae355bf7304278cce294c80b9dc79839e83fa458d51c3e2ba2f11b57afc0c26d8b47502d20b208fb7027adba96d2b4ea848352375291032a8b2f29d0249c6878f00f20b6e3c397fed0618420ad29932991b9552b9ac2abcfa9d996918b9fcd9edd0040140b94bfc8f489854db647b75093d102edb34302e67bfc6b6729d5be6aa868907246b588f408b911d75fbf5b2a897de3e1491ecbe61ceae5e281f59637212eadddd2e58dc232f18d02255fe62b87baf802523114168b27c036c47dfb7e89add697f70d85b503ddeeb79b40f2739e20a275f9a32d1693a2706fc3fa22efd1985a3480211eda989f84cd8a178a0dc0aa1ce8c22c20184c730477075339e853931456b6d70e42888c53fde20abc5ef8c8247a190dd6eaf25def499e17084e1f8accc7e2a1cf291655a3d3294c785ed88e813d6c9b2f28d379e74694fa2e0dc118c97c629de5c8773c41a1ccdb0028347094a75a14283a4cc0436abdb217d8dd05fd4dd7dbbcb2a08a262f18aeb59f1db411f6f2b040f4988064e872ce4945007ffb9567445376ddcc84c4299bf16c6f3e65f0d36f5271398bd77a4eeccb7cc922a9ba923ef7d713366e29551606b5b82c7446e688521efc959ef06436d7475b4770d339822d060a0d0328685076597a0b7c486009c6885a767133b508abf8744efa1cd23690db9c15d61942d2cd3e0b404423aef570b65d08d1f1663222554c42e776d53ab4968a8b8a97191c6683d54ae0c70baa5edb5ea3a414cdcb32d6826e87baa015d1607c07735db32b4af98ca6db84c86a70e81c66a17d9b196a8cefe778348cf567eee6f5470975aa0f5cf6026357933727e17e27c8ad7ba9f7f62ebe6de833a9d3bb75c8e6d797ccc721b6199f223a371c9cea8b840ee99fe2f293b3e18e2ff1de8f9ae3360ae8851a534cd57f6e51bcb571c7e82d674389700662e73ab598333429e3a8e2b009e1c8ee13a50802f1cbee07c4094db31b7af74dd38f3c647492d1ee9ed3008b3255420f207c74c24a5e151ed9062c7cdfb1843e5470a99a3c6ff864d99138d878b0b6dcfa55818a68d3f64e2405097b0450e09eb31fdb19c84d02b8dd9e271a0431a7fabf65cbc6f121eabfc403165ed1ac2e7a5f997e46b6ee4dba438980a03b22ef21f9a6500cbe96600b84ab644f1913fa91f6cf884363303a959dc26b76341fcf2dc37b6d0a7fc0a6b9a58673458f58c244e25186eb9c45a16aa51d1c940450ac4a129ef86b547856f363350e9c48165d312526cd1554581f9808f8e5b45e7b304c4f61d69ec5daff9b5e8ddbc51a55dc9de313aa8624f7bde6cf153240951e113dbc6dba6b12bb405f9dbd5bee11c12d9b4bc07f27d568ab1bd4cb094efe84f2a2e90b7a9c1f7cc274345cb236a8b59859386224efc9d13e4615130553f5e48a39dee4ff5ab4db47f64fecd7ced46e1e81ab28aa49446bceabf53c2eef853ac55d6b10e6f4f1f9811ced414dc38a867ca7f4b76ff46641e96f73d50b527500fb335dec981a20ffa699cf9dc833308c47145d43cef3d15cd09b1fb2e83a42790aa4ebf0c2daad334dbcbdf2bc936dbc175a7600ebe83809b0ac2dbb437305bec42101e0fe71c5c14ce72b186ffb67e73be266e54602f3a86a141b4ce3f391eaa9d72f25e3ea18517a4114b89cbb22b91ad1d6ea05fc5fa1e6013ed1c8d0b32f8eea27d57cf315b734a7487dfbcea8f10335dba2f57e11e0df4f4a194b39c659375c0827bdc104f1e7112fcb389c969edac45067dab52382a1e39d1b04d957befc9b6cb4b6ef7951ea9f391a795bb3cba10b09469d4ed4e7856fb071ff706e162e49d3359b5765b854af1d608cfcd7999a8472ede1e96f9f92565da764b1121bafa893bf8ee6e3842e197e1d136c1fd03a3b9f1c3a3992764b2cdf59203a1bcb50a691b5e2e7aa306125bed07b4a083e3609332a6ca5ba83b1aadef6b50f6bdd3b3c712f75b8df4e6bb84f4ef9469bb0efe1d049582f28243ced37871eda89ad2eb0e490974491187567a8c7cd183fd80d51b03752fde930ac25a9df906c1fb157979ec7dda238fe435dd529931bf2d5048277a80fcd8933d1e87b1a6ad667bf618008a5ddca65f3f069262bd1ddb2ddc3e20a7e778d64753d2e1e012d97d2568f494414654d5e996028f03ff4e28739700f61cf65842dbe75c26e9f36b30b768f675cb5692fe56578387067cc517985a4542436290a1e2c5e561103e78ab76b7ded6d76688fb66656185f18d3ff5bb576c8c7017402cb987ad561a453632528326d37bf25e727dfc4a71c3ac8e298bbe49c071d90925863cefd9599213007bcbd38d12847a4f830ea9319344ca0b8eb2d094a82f8bae53055225398584a03d40d002d72e818121cc835763fc888f5c4e56aaae01d697a8f60976767d31514f3cb33a34d551469b85b49eeb419de69036d2d74dc162bad095728b6614b7310f95d845bddc88d3ea1394f31909d70e184ad50d3c0b9a11a40cfb650e297774b73f4acfea1f90ec98df4a9c7538e6841fb1c0a50d92ed29637672a723b8129a48ba67471972e23115cfff0b4204993b790b938df626d41dec0719cc2bcff60dab987c81b0267fbb377e99a51e827dd0301702dd0bdd12ea5e157e06ce3562a18bca45fd1e6ed14ede641c4c0b61a05a985b752ed6d367bb5c41197a03e40eff2f7de4503691b3371d83a6f2ad968255783e767e9aed6e7bff78ee9c7d19a84ee215819ebc504036b5454efe14fc40d90a633294528d82f50e0b274ecaa67ba300f0a3b2cc4916bae07b7806a62249bb08fa44c3922b7a2bedac6e32c9ad4302ba3ee7d127d153a3da95dd6109a591f2b89d930c45a6f2f728c064158dc36adf8e6fcf5e7a2ab1f71a4ada388e8352a8becfc7f7bfde1c29b204f3ff9f7194adc31d0731028905818ad7be481270667d2dc04703eb04842c20d65791ff0c664bc34a44bc6b76b9c2ac04bbe6c4d92e5923eff7cc3036f654a2177fb53ae80b9b1f7c73096db9f83c9683501ea5947124792348c12c21832bfbc7fd02f35d8a42eefefbdb4eeb2a32175e352c305cb7901f742bcb6a777989d78f1da381c20e9341285bfe0f2c44a5ed0f347ec8cab19965db80248b5bd1fb3be38f15eab9dafdac00ca1038ea601ffccc992d76ac9ccde982e1353d7c7349ad1a91f880e9bb5b725a2bff78c0cc027d92ea5f8aaf096bb05445016008770e4f8e0cb0eaac018e3b4c0ecb3ebc468c2364d7b1519ba5b512435b68c63499660ac8eab2bca0323fe5ff63b82958573bcf9bbee2745bf76de3ff4896bbe1b726c226fa476d665c5d889cddc162dbb92a25855bcad9a1bc5bd617909ec3c8d3e960706bd49f133e2feb6d39d265776e9a75b87e1bb538b54ab61ba9ed092ccda70438e940234bd27cc68396a7472aefdaa5e3176cde99cadced701fe71a9827c80b7569c3f7b3e7e1364eef643ef081860582bd95e8b157bca8c0cd7142fa944c3b6b42ba29f7620448244d3cdf8bf6a8519ba82f717a2db45f0d2fa986c1c7c4344a28daf7641287cc201b7ba0f1fe5fa02a8c701ea2a176ad73d5b43522878744d87e84ce25fc19696d1f799e8807a251d0b5810ff2938bb84c9ffe7451c3166d73cab033c4f34821e6cff73c7bd7b44caedf773320ab36d4f23177fb244c0cd4514ad66744a2f3b0d6bd84385baf695ce87fc40480dafe50032fa3e5114affb43cdc36cef818902687767f7f368cc755195c1d62695e2da9ef05c32258e3efcd608b29290a16a1717829faf94a5db3b7a95fb3690e9052d0c74078c81e47f364f68bea09bd99838482baaf36159eb2c7344428b2420309946a8ebe4dea6c537a0c5165672d294679ad704c567410a7d1e2a59031399a52d951d523a1374e5c33918e7c14012c1bdb2d3e039e8bbc99908434ae1456edd9e210d84930518cfedf6622f2c8e09ed3d17be675a100ce88f4874c2741b2ba583b3c82ad86fcdc53a657ae40e17bc67572de02fad452039976d56d7e42de4939a59a0413ed5d4e7d45da6b1813d2dfa45534000829c4ab90f3f45fbe55c6a9a75b8cafe9dd6725249d9918e2d3ec19f750c6dfb45898953864fdf845d981f09a24594b67dea7fe8741b65d78046f6773415f3306c24cc12b0310444541009e8bfedd12384dd6a3a8566bf05764ab9e25ac3de36772a0215f682b4b11bfd77c94cfa36ab7d75dc309bad8bdfba151cc868d1da7cb37ccad572f6647b3b47f96993ca5001bfb01a03097a675f1e28eb8ebfc947e807ebfe7d6be65bfdb8f8dd34053a396d38d2dbb889bd79cde02da83eeb4bfddf7f2cffa8f8ea2d5a79bcfe2b32555f612f50779c73bb5685c760fdf436bc1502a568320b929ee8c732a090958eb5e470f95a96de35de14250f029da96b6f2b51c61951686f8f21e81df373725bfa4dc1da4c588dc49defba45a40eebc6c9aefae3d6b8dd269309bdbdbe849a9e96f96597b3e56a5fa90e745ec73e1b2c09e15b69ad01d9e7ab0f1919ed4ee33b57ecff771bc6df008662829cb6f575751f0cb5a4291fb2f98a668cebe8ccf183d35ac6ff160007d94963b4867f0e07b13ad51127f9afec3b232ef9853d94a2382896a2deb954fbe79576fedc88fc32c35f2607b30d0ae095e5c1239f1f8df95581b911baecd77d521a9938766f0ac1a7a3be1ab51d05cdd729b6910d620426d0e2cc349987e8f089bb7e5c44beb8ac4dd77c9fa2cb78255a56a29216ba7059e71091553c70dedd279505fb5e6b8956bc2e796237d64d1a6fc19361acc327145b302426a9521afb8f0d13fac7a05e90bcbbcac40db5e82c1b3c8c3b320754450044aaeed38de564bc826f469a4ad4b86503397752b4cb7b3818fe6a3b0d6f914c15a3081471f2942a3b7bfc01bd79acf0aa2879f72a4f270c9cf4cb0d21e47e720d6e9ff42e4fce781fb015e6b21dc15283621db8ee681fb943c15a586b3cb2fd240fa8c3afda137b355da3bf2430b4058c896c194ac5e95841d08cb5ee4c4cc24da46c09684c0a4f44baaf865f32987fe353440bfd3eeb8433e6de0302671eff8c6d28213643348ea50ebc6570a29e8c8328aaaec3ae6c4a00f7523d54e829e8c3698c532cc0f56550e5a64d420ebf76a193c9221d32be48f74fdedc1b06a6fda262ba8684c92824d6b4ba2f96de9fb884b6d7acb7f573a3b2d80cb6880ad0100db97903853dda74195bee0b4dbc98b8fe6139b0c2f91c23e84c5666c9a7db268a666e6002c6903f603cb23fc9752cbe220465ccfd22c039b6b2273cfe711eb536b43744de1ff1c2dee54dcb47909ee7beeb39c309c4d4535f8d8628fa3ff6f3db8812dccf0e7e0fefd31b2db188b68bd4b5faba6a87f40b21486064024dae3aeb63bd36da8fbfdedfffc5e23a0d764d707558007b9a9391be207ff686be65640e3b99d7160b5b2df4eadeee730f39224a9c5de21f90f1d300616395be19132e35f3a6119513d78ebbca8e6afea4dfa638f52c1eb7289a7e42bb0985a41f80d01769dc951d8ffa1783faaed5946d60d9f1490f3df4ff03838dfd4c3d980cb76ecd1164367f020b1a027bf114e5a57204ede839f1b56fad1f000cba3cfcf22dcea368420b665eb2a8742c938265a432dc578ec3b15104eba60cc9d4527a9021bef3a26530f5ed465641e5d357d038f1c865eaa4c0c06f0231fbe87cb3129d8ffcc5a86083591b46ed53fe320c08a97e84f2812965fd07ea99713363dae4e3ea52275fadfa67fbf33ddbda72a6e352802e564fb5b7ecab0e09d00b34a077d933ab70f50651591ce4f46757b41110df5458b9891737eba1427f96d592c7f907be7d72ca587541adaeed6ce0581fede02790dcf25b064bdb691733ff6943b7b734aaa9dd3c0ab4475ce1b04bd8a33d211fa4884bb0604fcf5b399aa54dfdf28ae25da21cdf12caf03aa70bb8a6675d1878cf02bb6761130715b5b134b81cd3764fbfa77b0318be6048dfb9a70c60307dc3493dcd753fa52c905a011c0adeb268f8ba36f57207eb89b0810b4a20e024a3808e8e2734f95772188b13f10cdb92e9c9be605761a589f4b1867caf6c125158fdfd143ffa27da7f989a997ff5c4ba97aeb9346b8d5d5a3dafa28bc88db4118bc33a6302a899058d0be9f35e743296943e5f4f0d3cca6f2dd3442b3a223f2964e8cf2efe7b869c4610956320d65b7a8890827757bc97d9f1f6c6257c480384596fe28d1d0481da727b348a075c6077abe6b674dad46a6dbcb1d15a1a92e1f7fdd730f54553b3fcbdb8a3491cd68178d6849c5ce63d2ac50283ba859d40ac1b78fb3639cca77cd17b0800c325475278a45c8461f09742227a7f68f7e2218feceedbc046e502c9747011e70d379ff0867676d220abed10f0db86baea2f89cbc2a7c34fdb2ab3f608e74a44929f036b059ca760c84546b2d677eba7df341c1cac88252955d2801af7cabf08d56dded7fd2bfda58cbe3dba08f6a0689ef0b9f8d7f2f78f38f089a07fe4273c36be516371718ce7d29cc3c61947526780a701d73bf4da798a555cc9416b7b4aa7e22bb858c2a93b1a132279419f728136905c3f5740b8c9fe7a756d52298583e348abee7d356fb4ff5fccbe1c88e88598c431698b84a78a6798ba24acd36b7cca31070c62e4ce0fd2e944dff15c4d2643220d07062725bc7245cb6eea2947d0dc3c3b72b5b1121097775a9b9ca85f226d5a8ef816d9afd9bbb133f51b71f85e28d18485dc5984f8a61022a6a31217e5f46bfdafffad5bd37bf6df9dd0ea53b34dd9f13c6eb1797fd6ba035c2d22ca12b9000944b68960f0585a474d160048954a407124fd8e18243bdbd5d502a1bbf90a10e41fcdf5d64ceb56f55b3de1e2bbb0d965cc7d009ccff036adbb229ddfcf4daf5f06ad41af2419fddd0e284a42e214e0609a598edf6478e2b4a75ee16f05023fd660b276c5a6fabd23f2df3b3250813ab9612cca5fb021baf95cf9c72bec167d8be5b0bb73b67069cbc034a38c713d55245e7a00fc954a66e5d086d1ca416b10c9adf1eec293791f3831926f4898776235f272a5b5d404e44af825b2379a1c09cc04b07abcab2ce11ce542c64c74d1562784ae876b9787ac8792d50e6391f4627da8b4793392fd50bfa2015ddd148373d37467ce3cd5e40bb26176db1aff9b0166668fffd8648a62f72c0a3105534bfdc063caac39962dc09e455813073004355ee8dfeec2c28fca202e770b67540e1ac0aa61401448ea0c13a412957760b050d07183cd12c5723f8cae839a24578acc724d15bbfe3bc0262eeb1c8292c13503b6c8100d8355481744536e0fdf90eabee933a7dd837c34715ead6861103867f846a5fce5690df0d3741ed9f62af021bf6eac76ef6d8429a08faf57d86fd1c4c0575ae6241d3339b62e5af31acf25ca1fc9852850f18fc941b2be483d829d440fe505aa6facd4297f77af5cb5e55dabfe327937c82eb37fccbcfba513875b45ed7b247d3e789d16adfdee68978a5c81a46821feda4ccc6c0e832fdddb242e10e34dc370dfa5608e4d62d9e227896792c2d0f0d931d8d82ed5dab18f9be8240ee4dca452ba4c7f5abe9ebd74a17b64be49bb496c4b49ef103f759489a9c4b1c561a8df266e7002f1d68d10a55269b4452bf46ffdac81ad47b5421907d2aa365f9b6c22108e54f6d27954574e889fdbc1120e5e7c557a6783a2cee3209d7243b80a9357f7372a04a408d01a5cefd461a0ef78f9b0d969af752eb6938aed64657754edaaa46cc66940c15bb7aac00a9d0312a378b23057366b4b1a17742c5c91b7c3c72d7dc081fdf266c7cbbf81a31bf32d30c9be1fd8ae05efe3e7b6fe7ca7417d6b087fb5a51fbdbfe73abff873ea7e2d799c7b2067c1391b1d00a2ba04d54309eecd687413a224924381fbcd328fe94b0c0fef3237eb5cb430df73d36ae4d29076ebf12c33c11abb8b15d1ecc1efac43850f9d961969d59f506e9eff694f9f258cda45523509840a1fb44fda6f73a8cabc11d125381548987f29ffbd558004873d80f3a4d48e488a8d3cc08c97c2e6e8547ddf907d4300ef45f795dcc7a91d74c59eb9cfd903ad7ef57f3d0a8e55498c3ae449ce7960f9177d0f985a1a423a21a8f4a773b8f1e5bf654d9b7733eeb631310d5b99bcc5bcc12a3fe590535d14a9af748884c2b58ff3f9dde845bd9b1c34dfe5044e9768b2a1776e2662a996660428204fcef3bc36ef01efdca57b988b26baeb62ea2ce2081de75344598a769be7358b64b5f4fc2eea6b0a51b6450f46a536b3fe8c25724fe5b9c542cfd7e164e70204fa14e1fcfcbd3f051c6cfafbd0bfebca2b5a7505edd2c1ae695134c0af797d3e6a4973dd4360ed0e84c3b11df6bd16d7b4de0e8559a8ecb07485d782c02618b34618da0d4ee10693c31021fa4ffd3154f2818de960d418f99eeb64db2824e4f2f961dfaa30182d67b5683b3a1ac675ac61ea7926009c41ff8e664734c5f9b6e81c9cd6724d8d5a8601cd7ad662f4ff86e360f1580d7dc900fc461b36dc08e64dd887431a278da9c477eab6062b645a9bd90feaf7db841667b466094a9188fdb8af9ea8174acfd61c50263f7180a3311767be008546838c94be0e342c048bb1b27f6c6836bf57650a4062837982b9631e90a6eb293b6028c3c7d3f2b3702375931c62e866337c0f35cd51c2f02b5b232df4d57cf2caece727e2ad4fe44e8520c57692ac530b69f23e1ad8b878e9a4bec1b42c09b211e3dee3cf131a697b10b4e6197c6c1ee0ec9f7344432d9ba943707b4d86c70773acfcf825d5accf2121bf75729c630258a8bb2c212b67283b8ba961b10dfeae71c7f205d379c42225511eb25ec5f97e90d9e52191992255c339cbc20b56eb487b18d0325b886c5b50056383a0fd73979516a53cb438de141b8032798683e444c1ac8b055eb33b92c9f70698f05d3341977a5cc3706ce9c3ac04964bced77ec38ed98d041b9aaa041548df3e7bd51e3f60220e8b1ebfe58160fe54788078997ffb7f9cb0020812e00f784a2b0114a342563901201da939ad811241afd94ed4da17e94c514b92c669d8812ac0a28c344919ce63d3f5f6d13424ddf409109ebd2ecea593710350321dd42c81a47092a973c246c7fca02b8543640e44e7c35a8f16e1eaeae7cbe03e9b2fa00639e13a12dd1be972aff1c0930f218523f8460a2e2482d58f6be793339aec8933ad7aae97916f6658cbb2fd30c0893242d2df740c952c39d65f2418d782a03963bd609e93e40026030f3bc76f5701f9f6fe42dafa7de1809e9c16347790a3a3b2ec4bad12462a8de2dd3fa3e24eac4e803be854e057a3d17d6d78680b0c0f552f68ba1f41dfdbf6ba831edc41906d90f42b4d25ee2a8c73a20a07920492ccc53ac3d5bdbc59a41b7bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
