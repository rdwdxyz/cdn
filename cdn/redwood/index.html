<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a62f03108b3fdf301cda5a00a18bef20b2a8c527920816a8968506688733eb245d007d2e4541a8f3ca9b67a0c134a6e11c86c8c08c67f1420b9334fd2eaaa3b942d08c9bbdd31dbe24173ed30b0a2e6f71f858f63f239179601ad711a42a14940b7a1fa18639f2d23e841d33f0492030184d1d11ec3a2bc22c6818e081c0da2bf3dfb020fc33acdc81a71870b23436bd674865c7d0683043050fec4c8a3918ac5997a21145dfdd839b47e0dbd578b15fd27c485d724d56fee9e25374dcce7b09c5e06e9fdd552195a55301bc1f9eb32b3f225ebd8a368b8fcf142fbbf89b69e5c6ef7214f75495be346f6f1115a5c60d757117d5f11dcbcad88851529d3d7622f2fc96e419cfe1a18158b87a8a2cd940c9aabf13d7cc6aff7b1cc4cd8422aa85cf3aa65f7d24abafbefdd8e2378115dc2883626f36c3a3506ee27163e08cd2cd8e03e578c96788d4f73084c96ba2257df04fe77907808c7a7bef2b3b6e51ab4dfb47e501859cbdcc5cb0060f4f34e9e2c8b45fe2f0d374cb8c63e11672729309dac06342b76b070011c779572ec8329de9cbdcfcdbe1516203ffb7f7b7204335d528702609e7d057cc6947806170ca35b77f6cc654b5db3f7e3b00eb788c6017e25578c84120433dc78c7b9a20205988c3acab5253e4d7746a8d9db396f815d7853833f77931f42aeaa01175483c2845c116f775a93530e6ff6576c6f1ac717ef55d977422ca83e3e008230e1cda304eaf04fd3390b17f60f5420a2c0631027f9c61c3bec6c02dac10f27f08c2209100138e092badce425d8c909abfd8ac1a97d6d3885353806a9d03f26ca854c2c37b1893faf75232bf927647e243870f9fd0baffcc2790f32442b1cab6dcddd65906e647c4ddad3513f9ba19612c31aa45b2b3e397a29baafe57d6c91f0c2498fd0289936593e8813ad6ac84bab9b7184cb1e81885e1bf044dd59a31b5ab1f679f85fd0898f58eeafeee50db8a7d40f92f43c847feed06dba2678922e81be8b4f3439e29416e3288173a2f3d422aa852a8147582cd4d0a8e3a5bb51d30289375db5e6d2eb0e2fa801583798fcf62bcbb6cdd53541d05f8a88844162042a4b662ac34d71ada8a070db3756517f2755598e8b74ea1d56d8b5a18af3247a4c3e628fe4b4b4171b0b14f6e447a930ebe27f7f19519f40c6176abfdd3cc2b42156c372d7b4de689b9a0b6cd5255d7b7f36070e61993b3d915008d8014eb280a729af59c13a513d35697dee8c12cb4ef0297c1e496c58bdee257227087c4490d7b6772b35704e60f9884ab440adf834be4b67d9274e7ac42ebdf5c64d04a65b6419409bcfc70ef05438db8e62db685509eebb7af9c5c65e42332cb48eb79458ba6f59064630614ef847104f929fba883a46ef3bb3b8b6756bfc91b70fae11f06789b931ef8cad017480db6dbf011fa8054c8c0a1fc7b8e3f5cd69e958132b98ef1130c84bdb3725691aa36b89c5c739d7d68d4035e8d08cad7b54c9611f8ae4158a29c4b3c38c1a05c8f03666b1210dda38be2e8e4259ff3763d67a9bce7520bafa4570db7b63b7bbf5e9b529854b6dca0c36b84366855d01aa225d6eab763245866a2827a5347b4bfadcc0dafdee763dac078f0d1f575cf73dce923352aa7ec514f2a15f97fce6c51600296bc3e83272717cb38eb0d2a1f67602e5fd9f5e2a558eb863e2fc85cc9b44ee096e625a7680b248935825ae0abc982ab67ec7320083f61a60d9ff9c4ab73c46fbff7c31a1d4c4c86f6c79089f571b8a79499aa2315da1a62410f7000b796e88117a482be53a2bad425055613b024f915b4e283bdca0563fa9a117627331c3df6d55fe7d1054cc8e0df2bce4fdfe382ebbef424ba60ffae65d56f162607b95fc7bb32f37d61c0506fe1748606672422cdd30f967ec4e0540744e4056ba2d2db6da1960136a84f849271e3258db777f799a110f70c9b511cd2d03746a5a3dd066d812d8cd09cea936cdb59a70c34c41e8f4f4ccb4df5b46d1a3682dabf4517cc0b766bbbb68a2095118da77e03a43d7800f5b0cd999a2c3a5edc0b8d19fc7e67c708408205104b9fe29ad68b7b055890d3bde45216c1afa3ec93b9d227fbfffbcce29348b6e0b7ac7cffb853c100bd371d3eff96ee31780bf9e90a35c92663fee0fea4639c67caf66c32ab41122fee98e0c849d5ef00bfb911251d3bce8698a619530f48f5bc6fe6932201205d0eba1376937e8a6676e3bb46998fa9c322de3ceb8cf8506263c0ec82910cced59d855b0b1945bc8e285fd28f2bf84f66e188128b006db8b0c9563b4c8d51907e7b9399bd1223fef5c393f0f344b61da7e4a27b190e73af9e8404120f89a03eff41766a6841af6bd4e21512c84900c9e0671f61e40d7240e983134a66d1224cfc9fa782e23d5461e3f66db98d778b072b3ccd984ea5b521f9fbb5dafb5a6eb505396a57436316f9edfd89c5da4f92c2c511526b573217ea0c9fc6069b5da593d046ff36745f9457c8c0cff56bc68c1f0c5162e33168d305adae78c2da6e0765a5b794ed67edcbbb6969533f6c5e66a97ae6fda4e205e272313f0ab0240effd12deaae00d4936ee34495fa8c57be8097967d9021cba5e52875a60a8d8f2876513585c83388abf7b60bca35c35671c2bbff5848ff0aac5ba0fbda82a51661b5ed066bf2a1bddf05c36a67362b8bf39ff20ce2ac64fc6dbcbf399b3ca2c8490b82b8fe86574b3f42c218c7a9f5c734cf2ea776454c4b1bdfa35f32ee4647bfc10c5d06f7e3e94d023ec359ec00f4d3d348c4863a0ffd9abcf57823b78ad5c7dbf0a701aa026be1cbfe3635c9ae9909dad52a517cbe58d1062af74a3237731989a973fea3d3bed7d38d0389f50ab980954ba6a48fbd210efddf3c4819d1645988f1f6c0344efbb6e4b273dc2db83d7a69337f8267a35449e4436b18fc8238ae4cc263bf0aaa2cd8e4b98c6e46f27a78b9bd63adde832bb83ab43d04a90d2dbcbd9b924a181ec8aac41775f57c40c49eb6b127aded716f7eab3cfe1bde0ff12a4c30eead3f9fac264901d5091dc6ca950b976ba431da91a69a023ea7576b4d1a45a3bac8e79f61a39d1c832925e6935105b932461a7543ba9f003782833a7123800527bad026a61f02757122413a4d9992db5d518dbebd84f3c62c115983dbdc2e4dc2b94bcb223fa58b5e3f6050d49d2b4f302b1303d70b1a932151e5634fe4bef423388946e4f32c9a5de8fd3bbf068a2ad9be8f09d745863a0ddd27309d3460b617ece084e5f088b2fb210b4a9cc6eb122df7a81a562f293761388f5a8a0a1ad1ad87c1062daea7f292445d0f0ba5d06b19716858555c67e95430336c878a2133ab53e72fed79cfc0a96687064a31c61506acc90961ee65b8b8e42c528e53228d115d1599cfedd4e49e01d20eb6862ffa0a3012aee69064ec8ed9064fe8cfba844ef75dfecf807039d6ce5d9a492f6b8ca2240c38c9b680c3515df11f0d442e89fc3b13242eb9c635302ebf3e865eae1787c5e998bd54d1f6c39f581c8aad17e88d0f067483600eadfae58923d527f30e10b4a89d34cf4441413cdba7879d2197a3a295295594c78191e785299c3fc8c3d6977765a292b3de439c15f01f8f3faea3ac9c388b3643d6d8c3af769f82ec70a19aa901566333378845eb2bf35f397ce59704323c3b86be5e8115531c804b6c85020a8d3a9378bfd6d8185c8cc6ed8e43711c596d40e22492636a25e446249c213896a3e9f30cd79737205f0f64375aa3951fb862d9d3d516e772ff1f4e686802aecc890eacfa4c43e21cc260b3f0f63fcee270e8fd3755780f95f890edda3d9c3c09612680797a011ca130ccab994847a29aab43d7ade73c2b48765a885c9d2c26c375c3ca27b48907157360ce76627dbda068e0ac41d0fc3c30039e6abf05e916f2c122bfd5d8efd25f6d2e44d5c87d17d6846467643a06df5277fb10bc6cba88be29724093986963dc431cef3e5e497b63c2b74e488e6aa627dd1887fc1e577107124e00f04260ebf699430f8ad7aa419dec1ff01fac88f41e8ad0e46fd245c38114b4381f1f4947f4e14c49c8e46b7397deac1cf184f7c06f3db22218fb10b3b104b8ca19663489ba0cf2d7b0c0a457d94051fd28b38df348aacdd1dfaa7a519b431bd1483bdab0dda2717285c4b55f3fb921c5cd1312666292b7d73f041e461c2e58121423325f67dd77f937dfdfd319cea4992c38c977fa63d68b7b0f1511cb4288d82aebc885c7bf65b16f852c337b7c34546ed3a74dfa8eac050cc68cbf8234fccf728d24afd0547a83d0225d79f4091c31fd3f0379f9e955987a2867af4239b9381a21b361c70182e008950c4f1c8033aad066b964b9fc34fd49d10d6f7c58c21f74e493eae3ef1bf70b6caf6c9ad7df525cfdc56f57130d44cafc94bece2bd2404d894b403e61d8d919bf03793d47658dc4d26ff6e6ea8367ebe40413ef9a1b01269aa9de14234baa1076a50d258545313e92c892ed577b4d882c3bf03c7aca8cdd981083373402cf2d11a62162062f1561a9575fc86a2b7864439aed2f819a8cb6067d7e56b3b4996de86b5701116e54069fa841fb48dc2c56a4c3c007d2e88d2ee21d077f9acbae501d2b50fdb0c7bb537ff2db441927e40f2f70e72f05d7c03380f5f15553b4d19ecaba546d83c959fb95d84b733992239aa37ad03b6c70ccd7d0474d4b9c96fc55a2e5e92943b7e15325d3632c4d134c4c57f2295083e3a0fb51dd06ed538d246386fbcd592064c7023fed3ca78ea307cd358ffd46d97d6da1ec8d89737053a7e046c1807174fd1b00ae40bda59967f26a4df105401ee7e3f865d4bfd1af6e0340cbdfa88f1201472926e660d5fb6032cc7113715a074216cc53632f7109877ef42ad96491c5ebaaaaabb29ba30fccd8eed4e5ea7a8f0f387ca7e53ab3751a4a1b5761f01c91bfc79833aec17a019e9ccfd9f70fa0d571622c267853ea286933123936fc37c25fcbb44d668e670ae2feddc1fcace046468a3a21a7db9a7c8dcc3594e1e9e9e371e214e3e3e1a5edb2541c807a59d9ce87392609ff7cce5e1414f0ade5940351df143f6b549759a30473047a77da25483e1bbe8448d7d0ff7c5e5cc153020aa4978387b6b405cc963adb55e3a0a59cce3ff9cf7178e18995c90193756f9ae0420df4e570922ab4a51fb9729ac1954ea8e4a8780771be748704f5675e2f6175dbb29eb0c1dae38db00ea90ef37bb7059cb8e5cd388d383c9b4e1bd17edcf51017d296efaf589fbf82affb486768a31ed3c46b5cadeb9d0ed8e3bf7fd77c10ccdd43720bff137d28d38fe235f4465d011c5a7f19aed1e7d0f48f7d42ea1fa9c07b406030c605fd5ca36b93ba337f3c036392a4a3b3f3cd664819abf7ef6a0ab7d24b5704c77ea3a19b69d44fbef7a9696b03a704745c7aeadf21ff2e876eb2658ac545ffbdcb9ae1fa33e66b7ab555de1c62c79767615e12228404f91f3d0227c569285050c03bfb18fe1d5ec7787b2f005ed6a6dfcd39c337cd78c4c3fd13e9d84a26c7bd06eeb6f245235f1448df54d5b2ac82cd9236df3c3e98327315bb0de209d2eed1973e3d7fc3bac25768496e5930ba3c2d5b289d42b1baa00c087aeded866bbe986792b8100eb72b83b9108afd787fd7d09aac84b339717eba0827a77b02f54b630d27016e62333885d8ef495a40dddb28c933c3ed077fba8787efdb05131f5e14dff3eddb2527a7316dcac073259c9b3b7d9096c06d6c867b84d7c818e426d18d8b253750e0d684038e7727201bfc0738419046eeaa41726440f00384451181c1adc7b6448f5eeaf53ea89e5b16bdc79bffccc9f1a53e3fb0a398d86456d1f20bcf2a26076d7c4b41cfbf676bb0cb484a9c702517ddf301ae62719faec5ef6137f5dcfb84ade20c8650eb46491c96926622d3ca3f3759b419d884aa257969fe943317e6da65e85ba913139f5a1d583335e4b1eb0ffb0cf1231a6a4f452f9560539f281e7b00c4a6b15e553f62d36ed186449987eb91dcce39f86e18caaa8ff9c8980266122bd0f6e6fbe8bd00e55606745e7999a83a9a41dba1f85a0c8124f5f67a175877e92623b1bd3c82cd5d346d1e0caeed1132b451ec07489f41f6279f68340e3b39665074bf7fc43200c8d90e387b47b59ef31a505783d2e4a131282dc5fe2c65518505cc1ea47e852570f551f5567e8e5780b68c4f7fc30596fca18880751463ec9dbce3c66a13b807b7fa4408a010be9f40bc35227faef49a1ed6f7a042dd016909931de5e20e6577b5f6a8ef6b27c2b8130d2c20d5c099a25e3a91e07019ff51d3f23a950fcb049cf2ac567747922e7ad6b2ad9d14c6c273e4bbf90764d882b3fb2fbe5cdf139618c6e699aae9c01fcccba73edf6996db8a5e82f96b7937500a40246b924a517ac3b2028bd67d7a80d376d75fc7edced7a53516bf7c6d1c66df360a3a18562a8de2fcec2412aaae5d255e0d77372906c824c8cfef4aa1aa194cac863ec3fe4d8bdd236777edfef9bab2d07d60493127a7612e461130fe9aae4aaa9b96f8347726603941e2edaf16e76332ef0896aeaef1ed44c38a8571b2d44e117f41501a1f23cd11437ba7ae05dbcf468a02ea0c2ac25b8e1cc53df785111d089258a0c532b35747f68455a3bf46f2460827c725ab05e36107d6ec77b87328a676dfc608e35b9951bab4f25b4f9165fc0ab05d47cbfa5791839253b1bff890454873cb0c6155fce1dce962131af820cf12219a7100643a1feea8679ab64c96e7bd31f06af9fdb6de8774029c5cc0b95a31493892724a7225d6e4c8233f31d9430b6bdca218d1675acec5e9d550600170c1684836cb4f0ad400181378b69ce685b3f1cb4f38323eb00c9847a090966868fb6ebdf3c1afdeeaaae79babfe1ec6f45596d6e8a918bb12f22b56338833969cebb41506c3796e893a66255e1bfe323340bcde6a157ea6d5d6a728cd007d80de72306d7025aca79e2f47c1ae196588fb775eda90f0eaad2ae9d9954ffd1466e052678141455b20d2b8d31473d2f9a71ca7642e3dd580f8b73cee839f63ffc4017454a3e39c4866aa45a9e7cdadd69a5bb1772a694d9c51658ec2bf11e362ecfb8353d23c6db4fc1c491e845cd6f599ac73355c29a44e7d9e38dc42d03b1db88e15b4b28e4c45d504fd544cbc62f1bf6e1457c89fba6f4007ae692cf25de61967da18995cfc9f6606354a15be2aec4e42af059590458883cc0730a2a224eb0d34b47078fba3a9c5c0b36613bce353ddc726aaad80d5f3ea408a70bb19be43cf2acdd80eaa591a023ce90a4ad3c86255dcafa3d38af5a67d4c692d69b69bdcc16536a98db2ff0e88f83d6e04260d496ecb4feeb5c2f0c69009b5563ceeb74d3a33f9d22824c5396c0335dfce25d2bf533275b2ef158d56d0cc75ab86efd9d1f9b048447e775bb0d9d26c1b64f61d9b5653e3d45d925873123c2d75cedcc111d1c52e4b32821d4365bb14c7d64159ed791b732953deb021e755cd47b12e0c57e1aa714a18664376276791a9f01a42ba5b21cd6acddf866518b4773478b1568919fc1cf4b105229d052fd48b9645f2cfcd5fb52d55a5ecb10b09c762215b8f7174636fc9a26a427f7cabc80c0165609fc511e850ae8f4edb01a138e3fe039494fafc67980344d472f272eb2924b00cd2348f9bb2a5ddea3b55df85987acefccf0d95896be004cba19da2e80a29c8d2fbaf64e3721c430483b8dc6f0e9e104842d0b43fb5184880b906f828bca4e91d57391d9223c76cc58269704f5b7155d011f0d992f2f1f8c04b366ca2957718f8518879bda19908657446f76376d047912928a9008067fcb7462217461a6f43bf9a08f3a384319a3022b784152cc013f0219e01a5419912d07557c42a3bf1a6be7353200d63851c0d7700d796b195c83ee60d496b4d7754c6b5f2901db4ff1b2a37bc7b40beacd0b07008e90043f1b2dbc5012b3064513d2f65afd497534026b48dba83f972bb229eb0c69936418b2974eddc535dc8e761914df7c9f5d7ce9f70e572f88664034a91625452c74d6db6992ae5b621037b3d5aadbdaff280434be1dbcec2c074805c1193493d766b2fe3de19a8e26773b76414af0906c9763345d792220d4c691b54cb25327577effc3702020f564d84ce006a15e6a3aade1d6616810f5bcba5daf06dd6fc9f610331eb4d57bf022f8d7f1549acf14a60cf57073a2f77e1071d17882c83a1fc83c0309ee62636a45da6b339f3394f19767bbe0c5f84bb79bd87340f0f5f779b712c2dd12bb072fd11dfad87cbb5584fbd3332662400d76b8e08e14b832aec86292c7297ae6fd9792ca6082c337e217bde3d5d3f5d948c5f76f8de5da620a51f9e1ea9debf6dc99e767e3c5cb48dccab3b4e559ef05e08c856e2b6650b270e4ae10f6805eb980844a98501209250a18d6bba52eee3263d57c59f2dc160b4703e3bc1e8d867ae1323ae48fdad34be389ca9b8ee21d3c6c570d50a6a8a4954d3c32338c60d4833572f9fccb44653520959c77cecdac04ec102af80d0a4e0f40174cbd225ac8ec69a641fe478da96c6e033a4e852ac693391c52149babfbdb7fdbacde66c7d18dbbddafcd78255636ab8ea1b49eccbaed98c094e9a998496ad875e66a95f857a567f765aa3c82804f2c6a0929b59fdc1517faa5289c538ce927ff899bb940aea2441ca4064a3ac9c9d625a58c1afdc35d43847e9401ac36399fe99d6b59587fea9c32942bc9207e85b99f027864f900cf262a4a7a6036705078fda86b489a03d28acac08e80b45ead85d8c5313b77dc175303f388c5d1fe3d43a11204e1b738841828cf736539f23a710929f321cf30673234ab9919beed727e9dd56417d9ebd6142bae691db4ef08e64bce0098e979125ce0ea3eed5097ebdb909f9e92eb3deea5887ab63a019568fb146727fbdf17dedb8cbe8dc573e59db1c0f3dc5eea84f14f672581a39a64a878a8815f85fea9ed30f5402daeaf5c14a5506192da81f5a1f5b83ac9e744eb5dcc2ac1ab4716ad34c603adaa162bc419a52476567575e2ce25899ce391a33d9ec59c02a32776b4ea00396f3856db51fa8f75aae1a2037e9740f7a26c974b6c6d175b4590daffe34a7aacdb8a8ec7181a387382a64056b7626f0b566563509404ded715ca6077a32e2b21c55f58329895d13ef98bc8a1dbace24b09a95d32e8ca134ae909311e4d0b7d1051cbcc473c50417888daf39516ac946b6bf8eaff8d8074be3292cd7c6d15b2d3135f3a517377851e0461aa70e0f94a7e07252357c4709d136b7a488777f757a64448fff6ea1c4147ef8cc02ffe9b0992044574d5b407817fafec37eb7402fdd89f51a6ffaf57bb30616955f753f315d72be5fcbbcadfddefc022b1a8aa1ecad081bfbfa5b9dec7db9f19570d5296f59ce0ded300f6d4b1edbad02dbfd6cc8a806f2396bee9da669ed5d79861fed954aed9beae97b61c93a987c7428bc555fa3bd676f2f503d7ce4ec6758dae622d0e71c6d4f011f80a90a7f7fb0fe0877bd96d15baeab8965a1f4ad227cc1317c3d50e1ec0b80740229c9310cd3ea8d4ad570813746b8dea6a25a2b9271875e10b6e21ba8be8313fb79a4d4f9d7eecd8802a9f01ecead69f6fc16322a39f9720fb83c213ccc3c62f540f476e3504c4aff5c28f0dc66c73a93b5fd7a485024f7d7e2086b7caed815642a736b4e71e632e6eecd040c5ab0a511e2d1a8bcfa29fa069c77284cea6e72bce59496f7c9eba3e6c69de725843ee0f54a574612c71a048de6ebc4eac5afa216ace2c114f827946c68ab09726c25806996fa07c2b4ca9d38ff1df029c61b45f8ebc2479fe669b9c7c993b5e9abdca5a0a3475a4d383ebeeafb0f0765a6b84c596777b8d0a36e9810dee8bd623df2c5eb4e55eca382af4815f8152eb25fe74ad3748625817f8428b6f492d882b28696802ab82d8d109610013fd23f56d65b863a0dd73a663dfcccc005ebf5e874eecc0d0718ec915bafd56ef6fc6711163dd13c2f319c36e2e4805c34a18f2fb7c9aa2b338490c3d36f0b52fea6d188c417b4433ec57317336c5fb8b1d6786eda475bdd098d0c39c2acc740899b9ad7d8b7bcd3fbcd84c7ae485138e001cad31db27c0e9a36bde62465adc91992740672eb0cf302bf6e27fc9339f1fd916b00890ffce28d97db0726cf69cb5369c90c0a5b9fd96e86d3d074b747ada0cb0797c5488faa6951f26a0999aba2339feb2699f1f4ec9d6fb55249518832cc26db3c5f7e5a16732cd4143c6720a04cf5277c506db9bb9f17941606fb1b3ea3cf9e761f654b8396b37dd025e97e584bed1c1850feed2a050d9b643ff6956c89ad6e1997ac291cda027efc9d97491f16a66557fa2e1c98085826cf67bb8dd1bca2cf2e40eb40accdebaa2d94dffda8fe5bc8deb6964c86fc4f1d3d36a05178509787017302141db1700d2f8d2ab56bd8ee5a08154f9d63000302f3496dcab78c632beeb363316fc4cb9362517bce882557d30ea871c18ed833b1d632684a8a0e699b310838c41ff418c758797186f5cf520c9312ae9cf4d4c49b50730f7424feb63b7d10f201d940f08fcc6a4036e14a933b3bc54495ad2c548ae96b2345475f345691d917b76e296569532a9be4a8e7d1cdb69beef332437a94e23b8399cf2d4e8e355b5a4241f0cc59b3ea22d2b9aa97eb972e60d4a378bca7beba599ef02b588d4d9a9a38efda698cd79f616f7ef67a1b3088669573d48139a164f913098f8a8827d8f6a1923f96b86197446a34ee901d4f649994ae1b078119a9d1c2ea3b7fe56b629b9d92a6caa5610b0d74c56670dd98a1b4cc5c9f4c4bf07cc1a675d9b815edf547d8c221c68c4680a30dd55377ad6f5f2cc9fc1e3431cd7e890f5f9720c0549315709d92e7683d7995d8388817c3ea02b0abeb9e18adf6b9f28a5d808fecafcae711ad0e55950076fc7b53b0864a7c7ea8f772aa5a3b1ab9a983b55278531cccdffcbfa34b01739fc5a20f1de9d481403b5e02b2a31561114c7986554fc5c708044248b70d5377873761d1867c33e241478640a41f2089ab96b1e7e4dbd1a8fef8d6ea38fbcd88c457fadb1441bddc47f37dcdb6131514828fc7b529d9f1f999ffab9d5902e4ca5320b57911919164d4ee683f4dc5b9577509e7c6eaf88fc6460119466f86ac82f29aee89dc8225d39e125b4283a13b53bb04b0a977b1e9943c2afb8472ae10e537e91b04df06bc09543e5b962fba9e3844d0807f2dc00a4b19dc22e2be5d016f984ca4acb636e683b283e9bdcdf663642a6b4fa7f08088f319591c6e228468ed38c3170e284917d592c168314fb094252e4f14576b48c99c557d2021bd3f8a5a1a798afd3acc785285b5249b0f21628a313afb3eac4a7ec189f40269f050ac421a2788fe7496ee1accf78d7cfa5db6ce02ab752c60c1d1ed65f1112654a5118b6f9967142d4808280c0cef839da9a9aff077aebf62178be7261e1c54cba61f89c70bb779f673a76aa93f74ce6bbcf59b59997ae83d9c49fe9fc8172c49f976a082774c23f37d7a515edcf87f8d9d2ab02022e2f0f126037e91e69ebd8bc4b5a1c83e88eeccf913c3cb5e153c8a3f735f2e047ce3e6a939f709d896aa861ac6c8591a5fbb5cbeecb16e575d5e6c8e0f9bb13fe79592036b8292683b3c36669b735f5499f25b631fcdcf79e2f6ce3f4886b9d77019538fdfd2f6a55c371e57d16c84d46b80d606d1f3f558f7b3478438d4de6b2e078f9dba8020950e0b35dae2cfeaca9017bcc7fdf9b4f75c91a4c470210ad8038428952b18f86bdf3ddbb44661be5e4af6a1cec3711c4bdbfcf89ef764530817dd34f3dd340be74326bff189f98c1837f515a218f1011e10c285717ffd18dcb291e224c3c04537e33868dde9b7c71c8d58a5dfcb261737a8af04613af3add2dc1a70c2011c962bb1806bc42757f0a6ca5233e8a06ceefb3a54177cc1e028cf87d638d357ccf6565f7d2864e677f48f3e96619ba17f76476b9a2aaa6d37e60514b7b86389217de40196c2a47aee04f6453f23193b3d73bfe08fce8ea4a42b5ead978b2a2ddd7599f58eb4f7751944cde28d0dc960c8f07a68019a185d8eb7123b5f6683c964c71f1cc58cd39f08e4020deca947171283119d49f89aecf14137d9ffbad4d492c3af28ae9d99458b89c0f82eb33eef2c87d9775ad58210894126b3333fb2bb8499a4aa8e9825f68f17e87305b7fe656ed95f4bbba2491d68404ec498b100a71830818d4be54d230ba80af0c458ca2cf06a36c26c78a88d7219b75a676519eb45581ab3ecb0b4041334a41997cc4434d7ee044ba85e316cc328c4595b034f1b92dab59e4dc46a100d4ac1de938251e5a579eec4e2a67e94382c00df059a0c8c754edc7346962e95e90e877bd9dd40b5a2697851179580d47944b65e22ea31eb51389151139de6375815ae5fc68520ab2bde5de8db0b2a931b7f0b9249dda9609016f02a807116a23bd1bc8b2a630c07be0c7dace104ae09ec57a094b1faeff07ac50ada3f65c577b3dfa2061f14f19512d8813835477d283e327e55a32d08fbe595b3c85ca0e633d2cd3bf0a8e7597e5726312e5f6b174e89247b4b5272d22382f4dfb7263c59d4904450cb63a513a460f71c42c384e10dda69eb9ccdd44485f7b3774e025fcd6a08c458bd8b51d3bde8c0822a584330caa14b334170edf39f25a33a280da4bcc9dca87dc5034f71912efc7554e095afec25d8a7d86825f057ea28f9a2ea04ce633ea1e2cb87fd46953518b9488f05ef1b171e97bf0be993c19f78346d1eb8326c7958faa1157dc63c3600b5aa63950d804b67be63a4e07204a7dd1d18bcc0772e75c7c8f35196dcb587364774bf976f87b04ae1247dbcf7431d386003ebd556ae117faa95114910afa9e7a7a389c07ea74c09a0fc4767292e14f607869723be8d31f349f184de597027881658eb922424aed6afa9dc9789ed12ae5a8c29be031a0e0282f8bed7701f7c6a80fd92dce7d574298e940eb72ff23420b018d9181c47540a4de8d919577f4f7eff4d34e52ce800bde902b86565ead2844d095f776a1a548628b5444385795359e1f58431ae0fd54d9215489b7cf5c0934e654d56f267028a770af7656390ffa939bb3e45cab77e8bf7d9fc9fa49b46d074390a9ab0c7190d547e2d21f1bc5a251812eaa0c3ea36015d97f2981d68562a7fe27a25e462eb5c37cca2a870cbca3b19555590fa899db5776d85df8b2ae66dc94b1193f07d4e41d079df00d2fdbc45d1fed48011724a15bc9f67c54e63fc7b1db766e2a72f1dd65a5b90f4fff862897ef14230c8866ebb944a56f3fce51e55eb93559692b2640f0c889a510e6f828587175a30532cc8aafb08ced4ab87d71b842a0531fbff7cb50084ca1b6f042c83dba06fa2d7d4c8bb205391b495fb2f99ee423958ed099fbed630f5f075d19a1a666ee49400dc0c86cc5134b70ddbfe04b6e1569ea9e1be329c63224b1b69bd7eb7a017c4085968b1003d96bd2073709acd9dc068cf0922dada6c907cd71e25f0a0d2813c6eb3ee32876ed4da2f4a6d65018cf7933b8554f5c3fafa20a54467357236aa4dbce4acfb0e59f85109096b8400f1f6489fd62ae2c9e85b8b695280a0ea58c9727976fb53a8602297576650ff4658ded05f728532fe8f004bf680385dbd402421c07132ad9919be58006112c7b72a9b53d10585d8dec286a0d8aea5599a813803c68e87bf9e51b32029769a825ca75146644eaf38699aa17924d356364466fc96b954dd2a0711aabe286013cb0c2f6d32a0d5e79dc394c20d744f207e1726f0764813be029d1ad40795375f9df0c05bac0b885904488c3eb21a66819a2ac88fcfff8ac8bae98b389483c5166eefa36f4596edb0048f8ee45c9dbf6e4a9acd7622ff41dcf98d096bb8150a7d53c4ddca9d9b04dcc571b5ccae1604202ecdca3a9780412c50020d03890fad98513d4709ec01b717808601e300c1ba2caf976ead7097055f6a8380c494538584086f3461489e3c09b37b76e72c6c0bf9febd62810241efa36001a6f7f271c3227c49e107bf0ae6481c8c33e81a3b07413c6d1e697f7849d35e3c83584bccda0ec963cf4f48f4d5d318a12aca6a41d9d43d3ea134f0e8b9c287af2e7b6c41f9508d3abd945f5308b34d37e4179259ad318021ff38f080c62f00eceab9d9020f6658db06c53261fad81283200008905c95d0c1448aa6a435515541f45235363ec36e94de5886ab548b6617ff36753aa96e2ad9bd5f10b76b2798975bf5e2b01c0158e97aa832707104d1bca3e6dfe60967c54ce2583c0c12c99382d1de3cec775b2809742df49123efa3962d20bd897fdf25ff077aca86e82202dfbe5db11a19cc5a070d698384dad58cb1b5b173e0227a04d862fc5deb4662de4f397363cf332d8c8e1f1d12fa29b013506bb979c0355831a2638e05516031e3f3a470a6fb107c0358bbc1d2fe534a08d5387cca8fdc324c660825a0f24f7914687edb5890356e5816eda4077d7a5e5d6f786c78a24b7a7a7910dec30874edad79eab55daf4a9312689abbf8d24baf1b2b371d01484c5d1edfd2a807c3e91574c3e5601369c881620ee4bd975e20e1369170c19f06e0b7eb01cb7a11193ab7d8c03e882fa292262f7af04b012fdb3709315a712ec544e5fc6c2951c012316956c2f0b4461290d0f55d15349fdf71c36141d4a15cdd5992d4b21e416cd3faf2897fcf20089f0744e0ab6247eb3d2adb0afab425c711b7d6865bf5ce231a591821965409319325061f13271ec29dfad04c8de43501a02cea4af267abc020a52583a18c8469270be2768289581144ba53955dd38da4a6aee68f456aec63ae1e9cdb574d72d1836b44f174959bf4897af6b69d80f9541e0a9c98b8c4ef830dee42f91d015f6923bca1abe9808a4fa871ffa9432b1f47f2d6f013dfa41955dcf981a5c2182067ecc16be0afcb3869d1bb5048f48ed00a554017aba2f128d43c689326c6deb45a8d06b6f98fb7c8f0499d70428979d344bb11e45b185a80216056c5af8d3f2a039fb28d8431eb65df2b009ba8e3ebaf0cc6b13697b93b23fe10eed4fe3b12c4e766012abd21dcd22c2727da3330c34992f5695cc52e20a63f545ba88ef24fb2d4acf85d02a22bd3b20c266cc270c2a0ff764b077e47d84d3ac9084f49e7870c29aa6092042ef993e68857d1a8334b63136808659480bdb132c2cba60371553c15b5b7123a805ca1f4755b222008b8cddcf44450190101e6d494b10ee066ca296da4dae845f66709f5e68cc15142529c2132df867bc6e2ff8a289ed14aeccc47d58f768549b395df0482db71dada5b7ee9471b95aea2175e4c512f543625039e513b2d65b6add4aed018ebb426908565ac989ca611298f9a1ab9470d0fadd96d6b5337a7cdd4ada76ec8f46ec662f98684c92853e90e5901b6336d17feec9e8157acdea3acdba68138b7389e7ebbd6a39f41c83de15d78433aa73f951e1333c44a790d2e27d33da378a92699304bc2d00411932cf85420a61c2218985d7fcadd685f842ec5fecd1add82a808403591c1750bb029518ef73f8a7aaa38ec939481773a3e666c924e3771224ad7c9c93396ce19e187440b83b09166d141ea3174ead3c4f2f78f8b90a2d817286f5e719b3acc205a6578111a5eb4d66d043db37ddaadf10fe83cde849b9d7e1821f2edf242cf8164da5d0fff01fbad91b475fa75db4b604c4ece74e1276de43368d7dbf5577ed4c3f19672e1b3628c9fd746ec3532ee69601ffb81e684e651e46bb1ff472a58f103ccab9d3789354bceabe348294dfc07edd3c44a8809e4f79deae76e3f7d7f722cc095da44c563ee7dc516dd8be2996d00dc64ffccd6468b82f59aca0c6312ed75452051102401471e547a817a8019b2c49635c85378c130389bf4c73b3b9663e639fad03bd74ce645f5f6e7545cf7765c122a79d3144192882231da1485da48e8fa4b5a966faec59f0139c9a958381b6de0b3d1bd56f9cb4e2dcc6b9bbb38a5b370f3ef71792324eb61c151dda618430fb5643625980360b89f3286b505666fe09118275703ec2427b80327242b37b9ac0d3a460be6604dbb138e5862dc01aae69f9304f50ab3d49bda51c9cf20ad6e0b8cd929ec9bc2699879d62186dc436cc953993cd5a8694f580a85e706184584dcfc422a3edb7e00eb0ee7034b906107023f919873afd9bae233a3fedf0a5f83d41cebe79473d12cec493fa23f2257e18972ea3d0eb8f806dfc8b5b579a8aecd9edfadfeb6820f76465a4360aea9944df1eb0092ca79a7aadd9b6737a18e37132214f0297c4d5b06fe16486fbd9a74ef6f52f2d72c86bda6cf609c4fbdc5fbc7b14d44b6ed66b02608f0f8ce727a8c674aa31d60cf3e9cf51e0480d66b1b0c411fff76fc2da68de685065972c289e2c5cc672b12666a4504a29230cc2fafaa815ece85e3f43787d881c8dbda87207d3450b464c0b159184cd4b123340bb8e5d7078dd28d3c1000dc69db79565a820faeaad0d8f8635ff6894f95b69092072e2f912c91db6d1518f7ff92eace8f5a72f2a9caf3c3b7fd371261f155d4be1c155fcfc628b10e68ab6a63bf11f86595a959c62891793a9f758977314cff6cbf80d9fa1e297ae9d79f05cd04096d9d14272728fb10894e7ddedbfcaaef06ce7807f1d15657098e438a155d1bc80af32c0f9c90326c815e99b77a1233d1f68c979b91645c1ed466e60feb16a947f0de1a4e859b4f968fc6d0dc4cfa0d81463c6380e680ce8e77ca47e9dc678d873d469b36ff617e441115da3af424376488b8aebb3a6a2af74139d005ca623f250459e779bc9e753026be6119422f9e2dfe8c799c5bdf68a88918a01ec8794a647ae3f76a6876b121bdcf26a0be50677ecba55bbe15a664bdbae4b164e80d010cf6b07e932856f6e9342151eca69bf563095eb5e072b194b6a296525dd4c51aa796f970a3c94f7aebc8b75335eaa0b721d9f9c805e3bbae30ddaf8977223778138af483d60ad86a53e231bd75fbf1c34ea8d770b405ee91ddde99d85c06e64ab30c2309e6207e56de234cfd3abfc20956458b4539f3da281dccab6a810eba4eaf3dbd2494ea077ecadf342e6bfa02ab4d57273cb74d4f6dc6af5e7ca55172ed54db8d418e802eea02d772064a11be909d26e9c7c0afe8fa5072aa66fe06bff84532ce5dd4cd40348f8e1d9fbac8f65f71ceb4e858e8a1cab97f68902d27ed294c2c5ac2ae74fb6df1749fe5bcb1fb0d74cc36baafd500a4abbf1083de8d3e0b008e9a0523447c2c5f93b6b955b8efe9a6165b2f5c91e5d447f9ca72e9c0a1f907ff8d6a0c23ae2fc9181e338ad670a25d95df3d1e98172d6829f42be0ed79a6fec0d0f94bf70e97da9ccbd560c515659f23c934a8efe02e810e46a0345d02e8acb838a838b1dd20750ce5afa11b7a0b293fd7cd921e808e136e4ee477b3ee50b392e6676a6ce76c2efcf4d31a82e3fe383b14a8220ee37c2dd360701046866bec5db84b38747d8f211b613b127cd27c204202a3c1fb6f1d3008f62002053635701200c5da374938d6f9a585700678ed86de54a3a622f49b361755a9dccfd32ee06001c37e9c0cc1ec53e67dad11694c1c2aac0eece66e8c9df4f6ef8203d3276c82c8fcb69c9c6e5fb84c7622f44b7db9251523d9f0c8527c46bb2ff4f82fb45bdadd4df5c670e6c5a3142dd4c9d01723b2cb7e9a8ae1a473a2e57df17cba749877d418919bac768428639c5d4afec12a7025ecfee35356dc691f9eb99c705c9d47b61299b543febb1628d34e1be742a98671e0db474c9d55997f716a19dc3cb766392fce781c846dd1fed62e160a1c8f98f0a79762a9fe9470099b23dd08626813a21e50ecb29e7cd76d4663c3030fd268dc622ca208118218a8efb2211b5c603ba85490b7d4e9c3b2da1e3c0c8f39afa66c4da67c0775e986428c9dcfe53c883d9433e353cd08edaca1767fd50d1cbd1cee2a47ae3833c2feabed12fe0d27db34d5145c14e176b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
