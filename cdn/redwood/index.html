<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"029f727d9fca05222f4f5bc1bd6184ec8d64f4c449928ecbc836e9d5e472799c498b42d24664b104347e96b35f877f2b1bbc5b829f2862c1e7b695a8c42878751678e0e9b58f9984bbe5c0e87326b7e2772e46b89fe3e5268cf2d6d4a83742d6635e336668b10e4a792b8552955bed78a96ea4fb7f34b8c914acbef81b69b99393ff6cdc7a19e8769ff9033d6e48cecb74931a6b5db9c63aee764f669a8dd6311a275c9ef25835209c2283f7fa10fa83f430786e6e5a0caec07d98009d346dcf4b0228354b88b4cda61308de69809d5c254af8f2293703e3f0ef1f62de058eee0c62ec4d34be8bb8f2610ab70c3376abdbdc5daa56afcfbd9a07b05e6a65fc0ad5df2328df2f98d30442b47f24d917de6a0eb6aef7bb18a7f6b75d05eead6f34376aaebce72c2bba1bea78b2e6d58dfa43ef5a8494a35a178f8c27289e6eb5991626b82a07993542f67d1c428c2f9b92242c37c482181c565f1308a40ffebefbebea8a48c036d450f881bbb39667c0305b5e0fcbbec8d48f1787177727ef72e1fb1281a243a435453e2f32b802fb4c06a2422d2068389487b63832633e84b8181b72939414b6ee518bcffd261f76d577ad31cbdc46af4f4a05c675ff926cacc4b14bc1e0b1e02ec14b4e42a0d72906cb18ba0f1432ddb7f98319d36b0e823d3a105aef406f64e20eefdfae4e75098edf0c041b22d31b329bba327af8d4f29259b4872dfa635f3a476e3a55f5e667ef6f588e6dbd83325e04d9a4dae12832a669f98230a65fdf1f471a21f8f7860afc10d1015a8b2b1d12b0818ed5f0406eb0b4dd87b06de2ca143fad9fa30bfe1c87b21bfce98ce2e4219277d2fc839d3eee132474f96d26ce992770e46068dea43a000913ceb5a0503525734bf8a47f5ec3e15fb841f5942dcb1d052f8ce5bcaf3994d9f03b90f5303a176fb7bfd3511515f6edbca4a6d084b1f8c42c4901e875923c69a8aa92b2c13828beee051f9dc48d37413456fe46ede3093a27c1099752bd5e52ae9139777d9c21ac94c620d91e1fb3cd3918fc90ab42c671b0e05869254ff61a5e883d281fc0e5d4bac02667663f1d69ddcc0c93abf14265d9297ac568782c2720f9053717878126dc8120e1a6ea157813acdcca7548103710b483ab926154e7b5dcc355637b71c8e552e0fdabba1749a8a518ac0195aff4410ba4a082afab152f9434ca1d822c8cccd82408040309af9c9f67962d81acaae5dccd26909f4c3468c53cff5398fcb67f31b1946086f8f3a964b334f51099f7a46e10065514de2563e2f00b4d2da01571be834f2741abb75e62d3537ff3abd4ed8b80503c936f1b5a3e98a117578f959941dd81b93f6a96b54b330b8e21e94491b22c3b5cf6130cc39f74cba8bb8afece030cfd87d7742c506f856d645043ea6653ceaf4c6a057f02ac2548d254c44b73a9d9ad7ca64a92a7f00f1f14cd783fdab5268fd0639a219478677bc58021c4c27cb1b08962483462acbee78a03ee0ffa835b8ca4fc19db4c05ffe381ebe16b0932e8b326f14521d3f3eb7d91e6c0d71ac98d5b60e5d224aae7b5840bdb578a2c1af445626707792a8c5bbdb5fece16aa6e24bc5fb2031b455d05128ee96dbd0e4de7778c3633b8f65ba19bc88862642ef314b705bf3bb77dd9b973a1765360f9e69b345a86b9b14176c1dddaa63a3c4d7da92904991649daa4796f19642ad95bd167874725783feec895dbed995f33e283638345ac2077830df3c6e34aed5d210c5b85a20bb13f96f2d0355a8916e5f8a2fb42569948fc3cfe2db32e6552af4a71c27ff8d88aabcf1b827979291726e1c497c153b5870fc7d4b01b0e550c8cb3bf44588ccb522ec745dc98f49c5e4e0b7b6f3b71e95a52cfb8613271b60234a9567835721b9240446375800bda08f7b30efb2f59ecd483bb3712f2bbfc2c51f3f05684380395641f4e81ba4f2f1ce510be2f422f0bbd4cde0ebfc2a81576f35a985b1363402bae25f4e2091ce03ea45c6f184d5e8649d26818655b1aa02092d72f7d5246e14e7a828c2363904493000c8d37e940d2fc529f97572fcf9bad8b6894630725d916ff2fbf6e163cc06e3b78d2f9ac54bb47c9a46897231ccb090ff81d19ccc2b14ad17618b87738f49dc869202d5527f33470f5cfb1698b4c86f116b9ebf9bb646e174141d4e8a52d51229dca6406733c670817f959be4e1e569ef658aa6e1154632a0473e9cc379786722aa4d3310408503b5c25a242da8c74119153c42a20e6e34562381fa456fe009f44b022435228300c28396406547f06c232a96983426db09942b95c6e7801fa3aba63032b4f79a3244a4cf45b991041874adf72e1c110615e396d3a8feb8af68a78461e82b04728adb18f6f06f01b142c04004eb430930a1899140c9dc5ec2b91c41598f4151c21fddbe940dceda84c8d41f449871719bc82544b5e763e7f971031424175912e111908d98dc309df24855c99d54e3ca8b53ba55a500b618b3c4dabc5d2ce892360fd52990afd186aa302bb38fad99ca67b66f53a1398a9cf861fe338d59f915777da1c4d7f2683528377c95fe13659ec9090410d2def24e9dc23cb6a84d2d1ee1343f1242ab09ec014e2dfc858b70225e68f3c22b61318056d996c0f6dd519cf0d409b3c9e6b9b2550acf1cd72b13c1e301714b7d2f0ed025c35ba4dd7c0171182999216447cc486fdce27be242580daa2c870f99a1b14fe96df376325e59701052497c081d01d402239bc047e48ba88627b19ce9344badc5bcf5c4319935581b7549b076aff9c4b293cba8294088203a24253bd663d92484ef2350c29309b328c2bf181cd72a1358d562f99d40fb7b95f8ff7a8e5ada2cd13fc890cd49f2455cb770bce4abc4ebacae377e837696f912dddba41365e66c033166363f18f28d84f1abe7acf16552bcee045c9f64ddfd5f919d0989bfd25422fa299eb880cc5fa4a845799a817244797fc68c4a6640a0cc74a5e1ce12fbac3e38c2070533d4c69a7ada25caa1a83c1da37027fa1b814da9595e083ccfa60ffb553cdc55de60287cd954a0a21f7fbc407428237ac5ed3b2fdbfb62a8a0640c4df3c056d748c93e93a2f54104e491280d8a0000f49e7cb88efa8f1eafbb68e968d42c50581bd6b09a32d211da8cfb9e20b477d5aecb63749e041060af6003f95db8503066b0d3c8f871c9feddcb51f080aa7fb0e43ae39bf68a48b97cd2f0e54c4b630e4905d78f7f6b88acd2db3c58bf9dd99c4a20ed38a6876c0e52aa2a67ed625616134205fd9ad7d67c6ac8596b613b72e1470ee93e09b722a4a683e7235ebdb38dbcfa24e0bd296af99d5883464c9323fab00c5cf883c527d43e27cc18fcb1b5bf92efcfa37bbbcc2b77dece5e0cc3544f1f31c51f1719a2d9920ef56bbbaf23e17e930d38c3cd8e6b83209920a30eb79c9b5e0bce89410df55640c7c77fc9e5f1ab5d394af0899dbe8531d1368e3c510c3c076a45bd11739224f32e84698bc6c7a83b8610796da438e59743954dd783bca293df5787bd6d614bf27416aed3cf764038dd24877d3d7ba93cd5f4e8a9ef6b73e09c0727d5710343b6a468e6e46af71c78d090e874759936fdedfd5f2711f17b6cee42de853aab5be9cfba197219735e19bf1b5385918cd71f567ec85683d38206d9ab655f21e608d0ea79f5b370ea12939159338ae9375c0d44366bcec47bbb2a972cb50be44a42a6610c5fac2e0868a85367eefc138708bad9fc855a3e11f3100e72289ed08e097168af9f930ca8a4fd92c2e494e60d3ff7d3319481e8b24f58ee64f3df3796d646aaa49be1b3217a052f4bf4cbf01bacaf6a1554b2c9b34cc14493864ecff87538e32551d3104384c54d3017f387876fe81eb391f76aa638cb3adc65cb43840d69d7cf4b931f86e616aeb6467a1e16ba89b034e3b71f349fbab208eaa873801f6c500d14f2ca55c7b69811087d1a610dc3c19dfcad3f6eb4876915d4245f2e5dddab66a0015f9d83e686bb5f0060de9cd6244bda8eb9d99a7dde7552772433032f5f90033ba992710baa2cd985624016981c3cc5bb3415a012bf891649807ddf1b4bf9d10fe42633ba3c26ea6933a881052f027f5eeb9bd43898c959ef2d236a722b08c660a0e65fcb931a68d3c93f2261fd5afa53e95136e029f23ce6f7f72adb200385f051ffce54353842a8a8016aec3b2738202ab8db8cdd840c268adf6e81e8fe0f34385a7d19ce7b3d9813792f6df4b3ff3d9151ecf9ca05335cd6761c4860b7b0317d3e92c9fb2238e993b6a8062cb5760791d68c59d094fd3a00bb9cce89db6f69e8dfaea997ba17f9ba7b03f7bd86b349556c3c9a5a10da3e77ef2ee22bed131433e054bc73de275b88d0ba77a4d8fb14a66d72b893144e872dec4c407c71f4f91b9be0960a2b1b1059c7aa175951f19f8d8d2e4e808bacec75fc15afd7165ebc30e7c1023e4dbe7d5495220f01e42fea6339b9e8b700048ae1612edf63212f6350076f5411b8c3956343a274546ba5ac9d7acdd7550f149ca3199f1a9896fc4bc969ce9be76e0f48c888c27a0734fa60916f5558d3cd2a24928bd0b4ce4436f3b81c1c52a8ba2029d794f1634895995d22e0085ba1a237fb3b8233f3abb3b5199089178b5a831dd0810708db8719abee5f67e27e399e7c38ad9c58f9dab5e9e2b6959b5cf338902edabd293af00b1a162da090620e0ca9304060b6de8486a71369d2cae4ae75e135c017c8f70a513b0890d2fbdf143fe47b63ca4e790f99ccdba5f6a4e2b05c5bac8b5f7229e8fbb71ebc2854b98b13e1d49ca4614210469890aa6261d28ec4982f7f29f62ed516616a29258a5d74b1c5fc2b27048af45d0575678e7e38e2979e069f66c9fe8ea563dc7672aa658c078147ce9afd3f49868b116a961fda4f022708e4192ddc4f18cb62e883a31177e826001ce4d5d57ec0afe0154a2f213471c88c18aca6a8c518eaf28f2f218dedfb99dec7d306019e8b3b0a971550da2e08ae5d8b55382803f27ebda017c2b4966c156fd42c7ab763453c954895981b671384d97f1f219360dff6b61f80984a1631c91e4c530f7a01e8d827346670522e51247101f8ae1019c3f98ccb8d6ad62b091da645c6846fbee993c411f6f5555a77a57fbd43c25b1c6ecf6870c21f9cd4673f4c16118147c16e119102f4a85cdd5eeebcfe4105762e8b07c8e47b0ca81ba5fb8d9e44ffca1708df40e85d8e4c38c656f11c653108a3207beb99f3c73f507072a47f7e182bc14e7a70d407c72f8c26493f682efce27aa6d1e00da1b4ed7cb57651f2f748e22614912df80181ba525456c38079002bfe9ad0ee4a29109e77a7bbdfb4ffd6218262277e841575eede6033f45b176ffa95b4efd385ec5e12f8f9ebf8fcb609e92be9e2685267897866d3e1a024d097105543f06e02c5ea8f1ae51de0306ff26d6460f71517ae63a266aef61dc2c28ead3daf45aa78c96454df9580146547a17002fff2520abd84443e09b5ac6a62b284941a6ae7652b92ea407d1c6831b96019049f92a2f96371af456448398d8f9699dd7fc07c21238d55b2fe34488b8fecfefe2fa88130c8aa6b55556ce295b9cdeda8ad80a8e4be0fcb8946ede11ad04a4d5d05863dc5a7d535b4a99db8bef0664ba132df2a6c9afdb7cb3f570b557a45285c478167ab562958c8712cc78263005574bc11b2676336fd9726512139bf06986c14c78548900b37c2a1d79beb32f4f6215080e30bf9353c70031c59c988899c00dbbca1a8613282cbc52bbdf29e36ea7463c2f616c76420ea4978fbd09ced12101c0b269e8f56b2f0d58382dc15e46b5eef0501f3c2260000471c11ac76be5ea3ae3d6067586857681e2597b8b2cf5247f21f51cc6a62571063ce45855362cd6ebab6d91de144ee5188a3f584fb0b1b8dae75f15f5ae6dbaed617d1c89a8733fbcc011f05ab612cdf6b121e93318fe7517373c8c04f6e33cb1da27de6c5055aad97809c6c1a3a878cbcb06494bc566f44b6721393c2df7b4b2250479100d8e8347da3af6277ccdd764de01770618be20373e205d5eed85352d035086fa352b2d6139a03c56b62cf5e456805c4680d7c9825404b8d8931029ac7cae690ff905daf7948014eb806e75e0c16cb25f4e1ffb14f0be506283415100433f81431e5acb03af1aa6f9b81edb685e2f0bb9f1d02e7ae5220cf98948a299f5b3b9bc13cec46085a07781f084dc76d5d3e9f450c677108a435772d876185ce146adc49546b9c5b57295b27a1312fe88ccee8d1a86f5157d4e655f788ed0139ec51274453b9b278e9460e45e8aaa62784d51f16d101bfd4212b3982feec881362f873a19cf282d8f7096c55d94f3c7b98b4ebf757732a34bb8825a37bb1a62e9ea9090156834330a0f2c0e483aa07397169cece47de5ec064ea4a0e3cd63a3f4fb35da00dda92d80878d90baa2278550eeb78f1a6a9059a0e6eb2a17cb52880b609ef5aa7745d6f7dc8ff6288e038590d78056eee94128089ddb4dd63c2f0ce5784cd546c39f6ec89e173e571c4db4cec1c089eda4b201add9d05a137e547a6eb636404e38b1d2c802d94333bf41ac1917811e63bd0dc6b2c536643da9102870bd09c6511d1c1b110c5b4954e95172d082efd3535e0fb4c5ab0bc0dcd0379022fd89e4fc0db34e8132c1f62b3b3e22d2c979f4c89ddb1cd482d1abcdc830bf4d5f6efd8a71f2b7eb1cf21301c15bda5cd2bc12d3684af7e74e17859fbae778fedc3c3afcff2dede08283203c1c216fdc991a957545c1a516b87b47a88775405c8654bac231e88df8d38667c8abf633f3c84fba64930a3bdc4d23e576e8264980a59bdffd573f2e7c44cb4642799b80e67ee5caa65f955eabf6ad2a85452dc66a6ee304925be952e61ed57e583d0e1ac771706c787fb06fb0cde49e2a26da2746f472f1e358dcb32fb75c12f5a09600530b5470d5d6fbd8135d15c83babd4c9f55ec36116f689ce0eace4542ec925a1adac61318f46e5d287f83f9d438c225d2ff54b19f00abb8c1b8d9027b8b384cc069b3ec9349cabd36f2af5b56db2a078fc36a8729431c6bd6c674099aad537605e453f4c310fd1630b1615c74a1ac9c681af1bec53887196f2f30fcfd05bfad5bf5261df90216ea5f74da9745712ef09519ec3aa1ada8468b4170c503247a700bae5bf785ffe20394b6056e60a07f85e9970d7d85592d1f8bd7e2533c92cb78152abcc6e9b65db52aa57809e8bd6e9e3dc4e03d18d0c457e4811c8c3fee07595d2743279bf1a9949c6b0943e57e078683c721a95edd571ab9b29aee5af907a69e3d84fc7f30969cb40a15b81433c27c72f950b793d9af8665ff8011d85d02a3f644c5686c8aa9ece24f9d5605a66bc42c54c1058689eba1a5914739fe4287b2333a987652b3f2d1e7376ae506613f1a904e6739d9d2fb971cf69c870b10fe2784dfe806c0e2ac27315b50d910098a9073c388015e1433b2428c70de9ca571945444c521666e0bb406bb248c252ea50a2f6fd2c01fc21636fd2a74511296586ab9fd425265d8101ca746409a46056eeabebf9b7760e0e435a07da93578ee0154be015ca321d95198fa176a38fa58c10bbb367903973697524d27a894d8d8bc53e3e767655300533873fbca56884eb8eeea4bdc777596000aa3ef23fa1db22bb6af5e28b05ea4c56cdc115d73e6a1a46bbb4e83b04ab84a1950f54468a138f19cd70deae22b18baf620da3219e19f34c8a7846992e0dabb8f81dcefba7d9a30de224f748965395c604fcdff9389486f3934e9282e46900b2baecfec3c7a81064de29e7dac027b53a12d36d88d4032027048eb627db72dfb92546894ffae39a703cd133011e9694ef73b2ff02d5f9bf192ab25bb7646f9fe6bc4289fafdc4833c54e5a7ccaf6f51eada5aeb9bd5eec6c167d66b445784490a61378fb18ef4e54707985230fb04f84161728059fcd89dda71f83f567fa8125dd8a0ab6e1784d17874c9eb8e7ef6c281b0c842734f661ca1f2254d830aef7659f8fd921807b401e311271818c9ce4acd6c278bf39298dc9cffd71dfad9ed048f8bfdbf190d66bc4a63db5c95fff061312a5d27882f3a884e7e41b00da6cfeeca7840f2d044c56c1d589a5ca67a9b8708ab39991fd2096145e7efab44cfeec3633601934ff39e27a71765952a5734928741d90fb7ee948837be67dca5a62d0d8df1c8a1bc1283d252d60fa4444cf0a171e02f469bf2b8ffe1c8b573e9d725c034cab5258eb64a558001cca5a060d0d4a34149cdf547015cba7584e13c3350b74a7365a535f488eae37524afa75638fdc26745ff32e0b4afa552016bb62acd6895ca27079d23158509d493495151cfc8f3d9d11f4e645624dcdd81726ed02bd7ad878d35e072debb207a759654b4082063c6cd9684abe2a0fb93e5d2177013f3a337b17dce77f2d4a5417705767e5ffb76d783e20222440011269c59cc8b108e64b34119188553c2f47e13bba665505dcc2d4eabc51e286a892283abcd25ad56b569df9c2758933b741f3b4f6c888ab05cd3937a0be42398324d9b6aff51fa8d33c919c0a9bee2e6f110775c107c0bb615c9dd6ad225caefaf0992f5dfab4baa7aedc39695e1bbc5b396f1651da23e3bc17dcf3e21225cd05b0e254e72d83b35ea605f0c0d58a2f699514795d85b36bd5083d2944b133f8da7889d2241a5fc7647e0d477c8c7aa3adfcb1cf4a2d4b427f1da4efc27edeb5841c976cf2265de700598d3a8f0c46abdc7325b3a2a79fdccea7e9a34031991fbbeb7daf2edcf8ee85dde4c9078b1ceb084a6083b9ba0c9a0d634837bc752ec1c686e7dff4e18ec412b61c1052525f412263a96a9964586e8735b41413f60a8b9e9578552dd211a34ddd6527ed971475f79fe7d5881eb1422dc82f41a92d3908c7d9bd9cf4bbef7c2fe5532b3afcf4aa8cef71f45447bffc60a58d9d2a95aff030eb8de62cdc1cc269cabf9ede0602e159645b0dca3e8617e0d07a2220557f3b8417cf75d664ed6c9097dcf08d8a20eaf493eeab2adb63a8a91ca6a9ab56bdefeece0d25916d1727d9ea9feb2dac9397dce6701554e58d1b621b224ad27cba7edd2244928bcbeed0f3396834d727d8aa454ec43f9edb6268d28a30cb90a910fe53279ca83f0163458f4ed0d1d0c750668e22cd3d3762f43acf5ebd34397229a1a3318773098fc11c7cb0683314725c0c2fade6c14b37b1d32d014a4d0f7cde59aaf9429ffa8f064569fc81bacdb181072dba0f22dea41c637b79972978fffeeb14357a9202543c020372f260b012884eb482c608d5bc0a73e8e875cb06d199682ab037d93756ebf392807a3a4f3375423cb0263050fc195b3850ad20a861c25a93edc63916a4094ba3bd2bcbae05e58182ac26139c30f1bd783786546f605e900eac9e66de5f122786f8ef9febd959b49c9bd3e6ca8ad55b58971b0302db7c675fc2d498ff60f5b4d4dd7370c29564e48df55561251395ebfa17af8ee1c931f8585f5f327e678fd78c434b6a87c8324116cdeab6cc5543038abc7e73fb9d4108f847551a1f286ac1ce32ed59381585b6a5d4f09f99558cc3d2e65b690ab668c2880ccb306ff9a00f2876cb3e0391fe49519f1db4f865aed8f8f351c0cf305fb8006a4e6442548e92c1e1795670b770ea83e250b27e1e88f6db5abe12ecdf387573d6d6be40467a5db0ec2ec387d07285684c34632e7fd31e2de7b0abf6c368f21d84c2c2f9ca95d1d959827431ce9df4ee8ec97838f62f949597b111d1a82c84227f51f6582007b112373e6980939c6b673b6d131764a3d2964eb5bfbf8d3b3c72974c7f0a08236e735eef862f55737307f22d1a2ec933dfca91e614d45f12337686bcd5e632b21af9d13f3e2183784c77165f3611a7a392bb14b5ff15a560b3f6ab0566cbb8d28c92265614238660b71e972f1e37a6f965b8de08b4c9f2ecc587a66bcfb8ca81544b6b04d5e3bd7a5eb2fc98ae8cd8ed12e8aaead148caeb2b9e76584c683dcb608165411cbed97c076ee74d3641ccd585865c135915f9b6d07027e3524fde6a2378c35936e92e6417a43c7abae218afcef984edfa71ab07251e68efa24966458cf2741e2d89a2a48b5c75c2079c525a508ac289ca570aa866287c196d3e231aad7bfbf95c1099d152736e7f2add9fc99d460ed1469814ac787d47bd25285101cb3ab749904e921acc3b9f53fa48cc81cb77ab8835df7f909887e54e9668fcc55db1c02b466e0eeddf9db343c88292682d570c83e8830e472836de1aa082ce177c41d6bdfcb2da417cd8c3442aa8e64c8d4cc504bd561eb5e17ad72b0cc5de3b6a7e16e0b2c42fdeb82d5d35e9555e871565296af207df21455de69ca768658455206a8f8d0232df4e317f4b7fc3c6192a2f79e4c6fdcddcf0f5f448611af5b18acd6421701e3380d4f3ce01b901a558988a33152b844c071bb4dddd82359d4b63acb72f47c97ae8febc896900f2bc2a0e8acfe564cbda12d17e5b3b10f14beb5d75dc70079cd041228a8ba93e30d64308328c7ce8eebe0f499f2257002ebd5ebe443ec84c4cb4c36d025ceb219762ebbd631f9640297618d370ce61b7909fd3363d5ea21ff064b8d3de16b61276a07b014248c2ce1cfbac7b3c11dbf92da505d1dce7ded7f8a44c34b39949f661dba7383f3c8e8dbf1f9405b5d5b544af748f2ca891ad55370f111a1524f67b2264f345b2f495fb8718626145083ad9ec90483234edd2c6835b5acbdc82d367242b1857fc19ed190448454184ed1b06ef5874da7e4232b0ab19272048aa7f8ac81674d447046e13a0fe6b131f5d0ad79e7c54de09e054fed68d7b3293a335f03231b19467d2f2c9a82d276f36d62da95b6ff6d06b5e934f90e4d3abe7009b1189b70913db08c8a4cc9d0411c6ccf348691013025228e8bdd856c0a99100735cca496a025b32534d32c921eb360c9ee90b9d1d7fed717f2a53ba995a3a8fdfb29cde215dbd9ee46ccb261412aa5d9f5748ea9be71dea4efdd7c302bc451bbde8a702bdee92e535293fca50dd36b4380b40ad61db4bc16db1d20889fa6b39034c1acb37c4a7be4206dd18496831bb0199fa3cc484d3fdbf5cd48de86d6bbf89a70e82e9190f3505f616f51e2f6ec7c189e80eba323cb11a2ea7afda635c22128209b087ed5b223a8133b26af3115f8b591faeb318387207b788c70e4fc11a9d4c408a7946deefffcb843e7fe187d63aafcb7e99f4dc60404b3ee43b628a4041611511f1423a9eb483e9476cb924bc3bc03a51d4e8ae5774cec80af2d9dfd6de695db9326f50bc0f6cd8f7d4527aa907b3d446cd0c022d16aaec1dc21e0788aff7d444c13aeeddd3afff486343a78a8b87fc7453e4ad365ba0649c7ca89bf29640130cc5ba9e410fa766e2fcd3121f31b28ebb36595e2d4d8460d0f6098815c14aa19d8a0d4ad492af079191f658309e846c2af465b83020a799c54fcee7d224f213fe9ba2421bedef4f769b9ba8ca93e529e3b00f8ec3d26160b23b2369839c3d412e80a5a1d3a25d580813c601b79046dbcbd004390168918ea1c7d4efc944cf4df30b461388e8c36403bd6c09da3ee735de5c601f2561a1e99e51d87b65b6356e559022cef460bd85e48c737383b4444be4fdccc6a85eb50931cf4102853dd6dda10b26fc323c3a9256d8fc3081a2b26662c4df1542656792721d8967c276c9a9321394585ab834defea82958c67d6cd1eeeaf2f10627c43baed4c623668fb886db7aa998c8733ec3aff1b91964e7729981bec7aa73316382545dbd9762fe49bd0c9d7b80ff4bbf0683dfd50cd7b3573f9fd283d046b931b6e8c31743234b19ee2435a59a17e564b96daaed71e6a3fc2f6a05faebc89eaca99c1a0ed5a6f73e49a4a7ecd0ee0b0b5ebd2af650137a9fc7c7567454580b2750ab6b230d0e3c89d6d25c5574d7afdc2672b1e720063648fe56ae1a15447d68bcedf0d74b06157e9b457be7b77f89ef75d4c002052ae70c44459f76f962e7b249c266542d2f5a300a92cf754968fd4115dd14e7f47e1c68cf390629b62bbe00bf2c64d5a6e845e82247c37fa62e7cc4b4207a38ec0d4e39db560a6b2a4b6842f861a19daf77daf4a7812a98fae1699c7d1a5b3f8d8fa8b07917c9b8c11b03d74e8897fe21b383733e11ce8220d3549229032b96abb0925591346e34b2a776b219a685f620fb4b59d1a7f3be9ea0e38650424e737faf7005e71857d64cc4cb6cfbb471241028d93011eb73e3003b88264e827197645397fc465cb1c31a5a957c9f29063550592c591bb445c6523698f5af466afacb9fa0ff8046a2e9d8ec991c060c0fcfa3e48e6885c32a5c0759d0fed671c9efc3c531ceaf037b3ab5d6a0bdb510614fffb54c618c7548fea5bcbf284ca8744590fc0bf5aab8e4f97e72e96045e70ee26b6f26ff72c84b5af9a5930643961ec762078910ee91873d972d0b157e39e0f4e46a61f5fbd3959d1c924e8a910910cdce8c9b31fcde6b5b77bcc6a5e26918dd286b6ea6ab9991b0aee2f1422f8ed8ac3049c8b014d79f8bf420c5efcea4e3ba45dd318dd270f6a1237bfd89ab7f8db417a882f2d68d5efed3a7e2538f8a1242d27ded49f24548f483da32de6cac731f5d29387841e901ed1f44c0ddee2556d5627a2929ee56623b91031af50fc76da485f9c205450ab2e0612bfc7edb11827f80fe3aa87167eb2134beef1e9c93f627c70df6fe5dab7d156021e2928ebb3e13f5aae98bdb0e4b28d91c4f59af46fc78c1ac06452cf7c2dff499243a567032271f13461afad728f9d94181f452c933b7c1417d7a82db6fafe28e93c7d54e27f087f6f8dfce21d616c16c2ea35f864364a2679dc2f6d3254e0a54ee0b5cefae0bf20489f3e16201b6f532b89b6890e009e54a54d197dd97806c9b12f7dd62b97bd9317450bb8289537f1eb6eccf9879f466aeeed75eaa47d2ae4495f50cc7ffaaf531cf5740fff3894fd94d6f03de7b06bf518f700e6a5bcc16000b290b9dc91e43e9f1f80793a3921a49376ec645ab2f784c9a97accd6405b63354be312ce141eb4f94c90e7b309fb72d0983c71e198840ae0bee3dc1c77e447ff1b08290890fd18ff57af812871605ea425bede0ec69bf487b3f1f1bf171887f92a3f754678a1a708312efc9fb6c0f9cbd17b0c9438f8138a81c9eb7cd44eac05b6439e20d813b039137e236a63411dd984d8d98abe73d4541872820439db8ebc575bb54eaa64023af16e5f372045e212e4f10147e07adb0d0b9ea2290818cdc5340ef58a3924704a716328fa0b76897e1cff380bf1e35534b7619064c11ce874100d03a0ac43c5a4c32ed11fc8a4cc98b7941363c59baa52d49c7284110b7a00472bd295376d0fa3a7e8b0a5aac8392ed1ffdc639b8c2386a1d4d32f1bdbae83b2bcc6fa134716ee46fcaaea97c5965a3dccbf1addb4e4dc9d069397169c176e659832796fa17ba816576d2ed92944af7826e3f8bbc7a685f594aee7bddf7484bf601388302b8f9398ef136157328c27af0ee8b4303565ecbccdc6bf336c66aaaef4e1604750656f940459a7c207f6de87837d86f68934b9208064d33e4d4830b19b7cc0b5c191f12b9d9584bf2c911601d88d12bb28b4a084a88ebe976a5587a8c4bd86cd850067f9af10d962b6d7bc5645adf4e6cbb95e502cd538543616d792c1f3b4ca334e3c4e421955008b43c01e8e7967bc0165b0aa6959d8f90270d14761307f05e5ce9e636a29efaeee1b7428706d5b3ff9c90fef9c6e5348232cdf9341ccb39ee57f98cb864da070034a78b636966cbfd65bb99fdbfaed872bf9fb42237d69f32942a33b3e57a9298fced4870cb5ebeb910d3f4498b6aad195fcc10a46958dd3606904bbc448af8f54c182cb18884dd1d71c63a1d50b7cbff39a3d63aaf6680187f2cb69941c16b19de43bce39832bb562bdcafb3f32cd9de808a62cf50bac3bc8f6958860e6e6c9befb89df1ba67a81e013150bd492d3b4711a656c6c801da74b36d7870b2f891a76127c2484c720889d98bba54d1f974ef61f16b3d9745aee5c6820af268c1bb3670ee58902a2cd36fe70a9b61064f54e5dbf5d52c53b5553f43d3aa4b9031eb391969b75967bd72f05c91f48b48e4ba98177b285c18d285d689702a440a4f9081444d23ba3086a61a23c6457b97d6f7386273164e0b27f7539ffbfcbc0e7ceecbb81d75c1d794eea5d247eaa7e6a384a8de687a16a0714c35bc25a7ca1ad47e6dace50d7b6bbe0e34b11a98b0b60c0d74c62236f870f17c788816f861ed0980d3f176adbf1f7697efd5f74e7ab2e3824cb736d02a44b5f852c22ece6e753637462274311e4b94df4efc65aad597496d1c4723f9f7d155d5df90bf087d4b88122b8a728c40d364193e2b224b2ec318169d9fa7b1d762329f67bdb4eae94bd5870cb3fe695f7fb72224fb5a262d4e041ae6cc704b7129d2ee79f93ca944922f7567d6afc5ca5ab808c83b193965a0d3a613ccee3a0357916b6582ad8fe2d6931c0f464bf922947f7bf05c601e8633a72e9df1dd19301aa7d173b1ebf16b522283569a0f722b5170d33a81ef043c53638a753e897023938953d9cba4e49bae7f875ce8526373112145fa0fdb565cee115954306734ab163a57e848d2ae037ee98fabad986e61cd2f1fb369ba8aba195c927601e717c181121e1c1f00bd0ac437fa1aff07dd22bab785ab8283fe8495ff7d6ff2d94950f6f223d262576b359a80d061a3abf023441058be07dfcbf8a578c9e758e58aaa1d0e7905f2c9a3673e5c85ec8ee7775893cc4068ebb7d555e6f3f1f6bc5fb91b76e8f311e45161dd1ce2780592f2a762b14d571e4cec8397f597ec5c62e530fc32cd27ed73c99ad8beeaea8b1fe6207bfe0215ab55c3ab2cb17db596e9875ae63fa514d522ba577dac62868084c2c3161f5ab73318d4b64740e8ad3a1afd3bd36365ff8bc22f03f0193eacfb3862b1f5cce943ed445926ce0b1387f53ec39a0032d531551e8538766c68ba56d3a912ef9bc9a6eb3e72adf295d61e99f9258689f771b062e783a8eff9d5e86b8a96a66ee0994e23a05592236397889201ed8aa4665591ee924f33613dd48182afe84bd904b4308f24566c148","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
