<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58064eea4775cb2757a3bb165c8d7da9e00fb82ca896f010aa099a709e664c473165594a17e95266d6d400037ed90dc3852bb74bf9059c972c088e77c4b9bbb48533b90212aff16ea98e9e0cd9dc2b48894ee2de104eb0e314d9be65cb95fcead27fd60526de93a33db99768cf266759c2bcf007ac459ef05a2081c9c51dbba14c747673e998cac774094772c3a858671025627139f7ee0796f4801a07a711d7904935bc3a1a74e26ed2ef61bc3c523d8b91f57c451fdb7cd969f4bb7a623e4299a2f4214df90f9d804e58dc17e83753d47cd6cd516c38313e7ae8e85c5948e8292b60d47e19f330b259e800f1241a1d3971e855e6d23d6d8f705aa71e75f0004ef2f6a050e156b4e717f6dd7eedf36480907362065941628cdc75fb00935a71d7592d8e1fd7b17508eef19364b202ac669ccaebf6e30d92612705d42514f9bb0eb67148a5c9faa2d0f5ba3700e716b57ea749dfe50cecf59a106ca0a44cd2e8296b09b12491b57e2c4f895fc9ec2a30ab82d732ae2f5d765f01e84776282154c5e6b2d29c6f75aff360f5f7ad9769ebc767d11644fa147091fc68751a21ba1c4dfc82470eb094ff9c99f3590640b49a01d494a978c38a7e6a0d4b1f61bff9198df475cc2b2ca348e797f2ba7015b6102bc7173aebdf4d8be91e6288d5cf370b378958339b2e6519ad531e37444e7b98aab5307f5558e0b7656ae0346403b12acfca4f3f200c6e7d351e0b2585318018e339dd8e08f2a1f4b67853e83b7f9e580c366323a2f5b44c74da9189f7d6e16dd3bfaf982a30273a194e402d0a4fd275efd9ec71391c03bb4f87e3b4f382cc0dbc26bfae442a714e5a0e406cd22aea7c1fcd2fb3018c88b8a049d9c4ca4827c78a39b3cc3a443a03a456ccc73740c1265d27605b438a7897b14d627a7ee688aa5b092c93ce95e5b7fdff6f84e4a22514f80f15f01e3828464af019f45d714a17aad4fe6bbeba97352a6ffc6ce6034f460b2bbebd1211fb093f34a64286d02993d7714d7350ae4d7439daed13010975147c65058be7d006cff308ddf2e5611a9a0a3586a234665b390f28eea728d832342590f4422a363fcc69ade360aabfd42c1fa99b5a381471ef824021915e424948531991e0ed450fa44b3a47d868d59bc8d92c0fc40c29f5cd63be95141ec45aef1dbd1c9c506fc72969908d7110b2f9d7551e12784b0d72398eb504e17e57054e8a976ff0e3fd2cea77173bd2b77554ad5cc03e37a8785fb89fd53d2a8b7835c065931cfb089f69db80389cb83e4ab5ab95c773cdc443b83d46d6ee86167062d5c0880c06626c76d2ab81a1427775a671a0ccc9b09b08723ed70425d47baa13794a86d435d3cfb15dc964b369a23e2dfeb231053ce59af2be134193e59ffc27fe9aae5e25955cac8495f684f3510416ca31f93f672553bbdbf28b8c72c297640ca87d7f21af53a921e3e97abd6e68761f0b9659a32c7f48bfa595f449f552fef6dae12eeac2e1e5dfab0d385dc5a1c3ff04de174c84b85d7f74c013161a4c720045adc9672a2a14a4b69fd18e18a4e1dd23359472581a73f20df3a0e02ec6a80dfaaed32d1a8e2d7244a1ed46664354d67d931f13379739f0384c051d56f3f72c7722825b95a6e4cfaed081cbbc34a9b43d21c9faf55b6648890c090aee2f241f7971d595eed205c59bf5d2713d0fbee7e1df245cb5d0e36e1d3a4cc50099bba6c97bcbbe79db56262e432d8618e677cca7a786e90749f295383382afb5e59e5736a4ce7801a9151df0b59a341049e1d6fd87c5805cf9a2aeac8dfa0ca52ca1423fdff30c76a08479428942a8084fc5fbbc182a32d03d14d4be4ef9e7e8ea007f31e470f52da30b9d53edd44023f49ff6d7583b0b076fbb4c0e2d6241adfa18cffbed22e3b9348a1e5e9483a36140467374e9ccf92bf583ed7b290a799063cf4c6f8acfaa266e3c3041be054cc1d49c8634eba7d09e4f76bb312dfe275e34b0c084239835544628812c1d6c3b0cc5ad8491986fdbe32bf8a922400e2adc675d90dfe482b907ba1539c173b5a8a4f9ad1733a85b89789c5802c69921dacc744a18dcecda4986d892bf6579d3c21d47b8ae442c776aa03ae9a052c7bde85722bc4a516262267512f10e6f0fed9bea2cf735d2306f45c4ba9fbac17034c03478ae61c9c5e972be7d6b49d8c6d47b5b14f3f1e4c976b7022da74f577254d4cf955375af3fabbcb7d2aa9660fb1db212fdec26a2710a1a72ab531b77d2517cd5ac004d8870b3f7d0a17d1d95a5883ecd4d7d5e43000d960222e155cb7e76c734b4ed2d562a7d16c1138a0fec2c6a413ca70f7a220f9f52a1dbe5bdf1060e81aedfe8ada8c886c7dc68be563ef199774e8f4972a8db0c1db8bb76689bde1b59917445e818f741aac74a55f6051ae6f9e34641f8293cbcdfedbf650663e767e63faf8343d31f4ce8d28ae9294f9342a9aee747db74f8efbb938406a15c1ba15d675ecaba477e6ae1b77e286cc1cd0b88c9b242706f068c372694bd37419812d79850b122203891e3e7ed22c18e548736b9620fd1af47026e37b18c13294bbe8812447a4c67988b869587014766408a98c2b86bcdaa953bfb2f316f474ea7a20582e3a46bf4e1f62528430571e68ab42b602c8b8363bb1a4642bbb7132e18b89a5c8722183d4c9611bc64bbfb16cec0c914188dd4d3cbe003858410faa1cc7347d08d0682694daa28269c41788ff02e2efde235a0e61b5bae2d53d9d6e054be803bd99581f2449f29f53c2a3894a40178d448502aac416af73186d861ebaf463707c95676c7b887fef11b1f2fed2f5b1e36659b367d5ec324a6cf3f2757dbc8e40947bf1b9e36af4c2ceb0498753d1c6747e414746f9efc1322fa2766aafb076a163d3a5686df1e16da1de4b763d931bc31abbf58facdd3e092c26bc1a3982d1953b6ed78670f1fedfc4298d5a8edb14b8ae9641c43321250812b8b963d560d1046285b229f1686947d8da30c085973c45295f49710d191a3216f61a92bc14c7fcf88577a6bcc03304b7643752588a1f0d0cfb33d4ae8edbc3b28b715f95d591c1f4cab833d1e08ef0e6b18a56f295d3fa507aab52e664784c6b0110582b321dd120d1ce579a4d03689d931851910586aaf43f2f4076c4846b5dbdf56e4b60533537e16fa2c85d8a8d08cddfce4ca761ee87da573551466e202f8ebdd9edb15924edd0b36b57387982b4d0d346f9ca81a66127163a5db35a948e2daa81c8f2568ecc2c7188244156e8f8c8213031e76c7f9f44248fdeed7e7bbf19791ac2a08ccd02d1af31db7f41637f4f86b8106e29d66ca44d5d33e8f190f2f4bd73370a344980ef1641a460a5daa95861e56166dbe61893b298f6101c3573b9d1262010f9376bc8e944c0a9560526ba434a0b82edcf6d2c82a41a4c3f97ee99c6b8fd697587a38236de1e8443ffdc9cb1a3f1f3944dc2ef698f110436291075adc44ecb9962c42f403409fb4339a36ac6e532651b2b52653690cd1f34e7d4ee3e839a5966d136624bf5d7f89316f0aef9d8111e1c3ced4598152428072197abbb464fdebd84a413add21f29ba2d5af014353179bae077e7dfa10a58bc8b321d1e3dbb266e59dd48660301e308d1b0967f863f2d0d977accf804b5b4613d955b529e8c79f75bd859178c56c040a30f371a69ffb6f53a21f6ae1fd34e44c8b086d3c5e628191bc381919f01acb9ef7a777c5cd831a1c27b2d09fe17690de8d122d589976aff6fc35bf9515cb8ab2071fc7442a525919d6845f2a214771cab51e8aeb283153e89a3f723898c44e867026045ae3a56cf98ca8f2407445919bcdc6256a7470bc69ca23afaf40f9e518496c37b7b7ef8a23d4c31e1a4f4ee98273da47c7f454cef65b30aeb8eaab32f22159cab4c1a450b949d50d8179f72267655a5b9795e110a36c9f31f61507aaa7a09fa88cd2490eb8bfe4dd455c6ad86c0d965e1465049a8f960ed18b31e5ed5bc01d25cc5090db50682c72e9ef6a9534c88b14e2bb5c5523565fbedb33bdec5664832f34fd2e20a8624c65b45c26a63cd3f4db6817b73e11023ee4494065b9324f3cfa8ea4d095d71b570583934c59edac2156664e41809055a4f0ef720bc5326a584ef7d983739ef5cd266946d6ecf4f7304c068a622480f2eb2aba97554ea6168ead517313e6dc8a441029e1c40bd3ef70a4f8dc80766df63789a754f69356c7530c6ae3ef69d65411f87632d91a14ebbb9c41e0c9cde79a8a1c55311547064c4418d2fc6d6350b2e7d4cb3680a9302744ee94d6006c40b8279807e2a6d5507cdf08462205958547d0d8880aa98c403208ee51dad8f4135cc9189c10c8eb63e4573b0b9c8c0dbd208833c80fc08b35bee684f3d0b44f7fecbe2dcd13b2c21b877dd87fa0809632e2e96e8d4eec2aeb67cd0e4e04db44242a4e3f9f06d29502c2f473d023f235c6f2b1672f50797e0df217994cc26924f15c40fc2d89fab8a843e2757c22dbd2f3a24f3170c1f18f12553b89e9f4ee1720f72b8582cdf7e6b737b72e911b025b50d7dc881f9143d5c8127f1289a639c0e61deed07a6d1f53c5258f3ef5ddbf47d7d6949c8af04a936f7c13dc57c6a68fb2ce3543664cd43c4ec1f432ecb1df2aa4bdbcbd60ffa85ba8e95fea8f449d20aa640b1ea9023ba4c8c99d5382a172df4b63b256e3383d6db3cfaac4a243e76b34043fe495891e4c63bd87cb779a10f0fc48e58be1ec6f1359989c959c28acaeab92893f868425772918d10c22e3c6aeb352deb7d36b5632c6f633401a54e1c74c2bb06dc19cda0c4319a084a398ae5768782e5a0cced501aa3d3d0838379ea0a637e548bbb3456459fefa51b6559da380961058b3d43d1ba1253de495c5ae62247e0bbd1dbf767d460c8cf552b8702cec1a2c6b623af1b9e4b5928d7d3ba03614fbd57a802dc677e4d325bb0a111451262032fb6f8f7b073ce5a778b20d4a6787f35cca14dbe4d3237cc715f1d49df5ed27d1ed2de0163eafe8e4ec6537a6f161afe97bd2eea112bf38ecf003f9c33938a7f91761d88f696d78a103d989396faef21633fdf18d1213fe3bda14123e99c30d66763ba872640bbae0f9996716b40434bc5914cfcd28bb80af41687fda67c4186a552ebc830dc608179577647de84362ed6ccc2cd2946831119f70f876e6ecaf376dae3b2fccf3949075f2d488863bfd049924706c0a48e85179b1309969d3317e7b4421f3f8ea2f97f66fe094590a9f3cd699aacfbdf4106be8c13eeee77108d33a8e9da83194c8cfca99e04cc9645037ecdab692b9a0982287695fc89ad906d329665e0f0bd108b27765fb8a83d71252e27e1bc17336654a8d99a5aeec859cc95e98e9f881abe558a593d9cb4cb9bcfb321c937364757dea103183a25bbd51abca6aed8ca821d6ebe6f0945272ed1a0aa60d48fc78cab2f7c302d74b27c96bfdad115085fc9240a5105be8bcf36a3ac4a82bff4eb745e09e897ecb12f0f807ba0c9539971530c506b4bfcec620d29efdacbd3f1564ede3fd6e12ae5e18b760791849d2ad9683c8b6e2deb32778a5b69444d12baedef69af2515db874ffdd397d7c0cbc3c4f65edb88a726371e038ab75ef558d098dc43dfca50a4ce4efb4b9572a3d3e3024a96437110246a95e80550715d38cc708cc55e526b32c201e1e6f1aa679c45bc61979419bc050cf42113d356e0c006dd28f361e2ec18ef9566184b45e710a5ba4d1c9bc18ed744627d48204be956e52179162fad1eafa47967c9c6b0cc1af34f9c40554688588dadcfb64747bf4c40c1367fddbe2b40111896d9cadef7b74f7240f93836a636f728a9721725b47e86023c582a044547037837253f6a7e98780ed7d143275d331a5ced3c1dfde5290b78be2f3eb5db17096c406ac850d6f342560202f856c3686c083815ab129eeae65aa6c46d029e8112183544da3c3506cb0096cf873af48229506af56142a167e7c4669d0cdb2bb142c7e339ed471723aad9b467edeaed4e73092eb094fae84e6b1b4763b7781815422d6da49cd9611673ec55ff311186cd5e388dab7f556b4f2c43b42c251bdaf5394c50e83106987385ff0b4f667a997e5cc2a2498938031fcf556f26eb70f19806740915d93a78aa8efafa3d0d4c876a95c914951854a2c9735a6f12038cc8490b46dd64356867479b4c661ddd150f932d2b39fdde0fec6fe0f1c1ef6162d61c7b3f3de9baadbe3a771c8872f93d90be04a42a6f8d9a2c7d955b86e3843ccba0004de72380a914373de5534a8608e84b28c68f9b35ed97013c82b5ae88fbaa6c58b6ba20530352cb66a9515f70e4596e94b31f7b79ece19b46bf21668728766cdf34c8e798861ff6408ece04bb7f07439f26110501ed106653b681ffd50522ca6ad47c81864eb307267aef1e00031af060c1e04a335c598305e9366f90eb7cb30ec889c4078f5eb9e3c5fcfb624cbaf8039e88b52a856e8bd1b073f74afcbb26a90a6040293c493c880390411e4a5067460a7a7c5e1a009eb37f076861ef6b539807ea805eaaa992b37dce4628260fac1fbf5e3d9cb2cb2589a12d0585b82f2bf5377257c3b353e32e5328616b246f4affa1c9493b05e5f5d77153ef736d8faedf32644b8c601878608ba51e000e64c24e467999760259651cd547f8e7575baa5330202a387ea33984e2cb5069338c6390aca143c98b57a4b2f61521ddb253ff704439a6dfa1af833c253e972fa02bcb6b0d41270298108f8271c8232c070e3cfa1ada2f4537726d96e7dbf93bf8d267b279534803298de8ddefc0ddca6905d417720b82c606b5c2849723de47d8d6e5fec0fbe634cdd9c0ecaa3f793bafa2ecdb697a414a5d14375cc6a31394f77757988d991a50c5ecd003598e2c14eddcaa055a559730c0e618bdee6ad6ca66a1b2a8b94ae28f3ad94dabf60722fefe252dddba0da6e3e5191344cac1331fed7c32f1d88cc42d1fbf11ca64247bf327521ea5fbde01c8d916994fc7a155fecf9647da7fde4671557de7eaf8047d1d9a819a6d5e5587154c603dac9f90b82b788ef0182cd6c05b9d8d3dc9426b452716b20360870af82c9f3f042ed570d8ca0a09c2500047781457ebc2095c89144d3d7b3a6dada85415f628f7016cb841a790b6b62aae2274cd1470e94466ac89861cffc75c30bdb1fea94a2db3bbee47e0f354b5a3c88781e2de36eb8822d60b25fd97265ba900b6fbebd8f88b7226c2a5d14b250872ddc7c39651043fa091a3016c04c3b8122ad476a41ce5ba9e2e6f4fe8613ef1e48bf391d3e7b02ee50d4af6cece2045fdeb84602d64954a0e14ba29c67f645f1c518747ae26fb0ff8911b5b33b629582394064037bb7cf699c85cc8b4d1c9c213e0e2225b20455ce502a3af51752e16d2291280dbe442b50159f94b376b9bd1d66eb9e82e5838a14b80f9ca1d75cf75dbebe97670217e7a3741fddbe9fea055e0850c27b29476779071a1ebca2f569ad78ceade56c6a7818efd8b57dac035e14ed3d853436a2fe615e80abf52b6fd34610522dcd902073b629c7b2db1b41be00f8849a7c842c55fb6490d438e93bc2ec3064284c6b1a1bc43bce4cf3a8d3a499e3607bc84dcca59124e75c8507304582ece7715544978d150154c6a6fa389f8ead5e872841e3cde04f5ff970b8b7edf0a2c3852fd419b006dc447f6d0a8aab970214ad73284b91a9a4836cc9ea8ec27b81dd2096b1f9a1e789d280e4f038c55de1acb2b50d4cf3ac23161b039f02fd44d47099bde13594fdcf35df299913acaac7af654cb5395958240cb92cad0ec8ba088c2d5895c468b0fbb65c442aed798159972142e07eaa2c7510d1716d554238721f8fd4a606abb0f285d042bae09835c7a1fcebbc256f9e6707cc96f7f30429734fd564365f3b77a779d4d965ec990784cbea640ce8c40ed7ad9729961a4fb1793242df8babcb92c27236d0f8bb9fc95a7a1ae34432193b9af80f2f238d6b9ade91d2c85b5646ae6ffd992bc058806307f0f5d794dc74aeb748d4b71a5a487fecc8bc399c96d67adbdeea99bab486266d5460a25474d8d05909d11b816f999c563b78fac2e7e0a4d36faa64da3c33824da4e67a41f36221caaf5f4dccda419a9e12652b867298bc4822b68440643947b8ee25c9f4d677067d0007a031d3eaa90eeab1e32e6a795b0ba11d80c67a225c44aae0e65a5f3e44d0ea78a76fb031f2c7e790b443f1a315b467aa6ebf723dc0bbed52fead43bac5a45b867e70816ce5600fddb2d7a3f253d5c6fdebfb66551e89b239b009eb9aba2f23bd4719cddbd42feae9a41aa01b2f8066d34e2185c4c7c42f9e8e5bcb097c18920e739c58223efe64c13be7552cc6ce3e66d7c6b98bba36aa1baf3adefcc43ba972b6c67b85e9edecd639643749aed61c58eb8d81cb66a820d994ef447e642d8bbd6e2af586421386ffc1619056065ef33072c210551b719e5771f4851d052403d2b31b897f2bc4eb98e3680fb3b37f9d1a09048c8347775de68eda85ef0a65a5410d8feb62ca5f07743ecb3bc2a67549e355ea6cd2893b91e984a76f47f4804b53b32a1021f517bfa8d74364c72c5967743dff0fb735d61cca5a1362a43d41ab8eadff5dff1bdda20978e76f1ae1ff7c06d9df0a6189d39bc3e2080978ac74182a8211b557bf96c35a9870f104148d9f5fb8fc3ad967eb4b7660f5e8f2dc675718ff16757b862be2e0abbd9552608dc98e3671ead46d27f2a5917323dce81807060376eb7626203b85aac02697b78dc9cbba57028f1685d1bd0a96a17984dbdfc0189bd1709fff3dd44e1911ab56a1de5c70cf961a2791f37cf832f8decef3879ef3d62245dc11ab24020e92424eced5be6e8452727e858c589481f6fce9869927442c0eeeaf55e8b1ed6c0a278263d47c73ad06177ba9474167c7fb968379c8c268a88bd54572e748d48ae75db768539b330e098e4217bd914e1923060870a34b4155e44e04eafd50f4063a1348a38c8ab325dd75a1e128917212be785442abd34a339fa56bb181c78fe7f6b241fb38a3bbfd3c2f273892dad37c60061d302e34ea30f79d621f3d4a211702e436a458947e10b332b3e54d9df24abbd77b7f470e4aa65909a482abe3fc2cfddb559acac1a3a8273f2e6b7f16221eba567e371f8e9f004fc9a3b55e1ac599a96dbc7f7d05817d9acc7805a8f91f81c1c4bbd5d48b4cfb806420be764928332035ffe91eb1d27a515e1d3b314eaae65a9eca74ec138f3b39b07f507be162b64b12214f30f4eb8261b19c00bff9f46e8d553b83bffc77b47624630550df44745fe2528ec59da6b2d61327766a31717ab4138f9977b227148eac2f881c3a1584c48da263d7e3fb83663eef41c13fc6498029b72d4eb7b5b331a4abb99a010a5e087732ecae97ead9e37fd44069e5221c77f37124f46c4248a31afbc70150a8545314b9145379d43a90d69fa01522f4505f3ddbf822c1e01226c7a8cec6f59f8f8742c95b76e461ed508b52cee636a2ba1f17b10665aed57ec9a099a128dd2a9f97b13284972e7d771d77d67b6d3d1b65ee6abe9bc2865913674c0a2ca20ae0016b8324763694c149d94409dd9fe9dc433ce9bc3718828636f0c34ffaa335d5f8bdd364e7895f598bbaef3b76373a8374a1aa2e45926551a858c9f3693d1f8b72e52ecbdb5cb61af635c83bba355fa8a010b1d2ad098e3033751226c9f2665a275965cacdd921fd357889f8d799c7aab8dedc867859d9cbe5957986abb70d654a86f2a2686c04069bc84faec135eb66e718dd3cae61b6c6b3406c126953da5ef9feb2ec9932bf320cdc69527acc82c8c2cae83355939e06c7473fde2c23b575960f95d3d319a7e39bd15c6a46e4229a249ed8fd3397568d0330d2932f83d412b423bdea3f14749d806e10d42c74948e4754266939fb1264775cecd59d657f54c2fb115e80e30b7bd67080ecee4446c7fc16c785cd051ad0ca72dd52abf64a9acaf2a889471320ec672ff8e71879cae0d9799a783d6b9f941521faa47b7972a44689da87f78dcec2f74a3e94a0146aaf109f369f9d68e20954ecdfe670afb29317cb60541bbc16bd3c445583c578e15b3e0dec2f283c1fa312c0186f70abb2dfbf0fff482c9aa00c924b19582653a04cc1f97f83adf78dba8f6553acf72030d51bdce5846eaad773c5ce3ef8bc31881bc07526dc372795e9f1bcb1593ae19bcd866aba209e305647070dd4b6df951556d21381208e40bcbd88c7c077ce9a4136fcc98c1723845558e9a4cbbda4f7c557f635cd03251c184d101ecbdae5264b8e82cc4366c4d28dd4614c9d25a9f316264b8251b5c41e3d782b06d871df9f42ca27e156b217472ee104955a025df8a1fe65c42df33e626becc47e911801d4ee9dec41758fca28570e26c78835f02475d5f17c06eab4081153fe62fc480817c7860865e6f6430e87ed9702d998277829c24d84f2c0ea2ffc088f4a6b4b2cfea0b2f8cf7902587008263fca35a48e1046c34a53f4773cf968dd0a35bfe211dcce17db6031e8fb85478746eaa66f62bc8c85beca146536c17c337627e3e0673a46a782f4cfc68c5e7c38c6fdb2a0f8424b5b29bba12d5f8b047240c10716bfd9dc1918e03d8f2309a5c4413a25b103ddd5e807dd066e5793646f0647abd9d12ef7c02806c16a1d8f5c0be9f94a9de01981e229b3e67426253a5076fbf711ed5fdabec20c3a11157f0f2813026cf168b26c615125fea8f4994ef3435c30fd87812df3e72837f277c7a87a9c427b9b1e6da6c8a7a8d7b99536d83ecba5cc1db85654297e320da51d56f7d4080bb07deb5ad7fd499ba55a3088445d0527badbb6c0d679ec23813c530e118d5ccbe70211652daafb3bad24bdf2cc81dac7ebb58f9db2d96d6c15c2ca332e1a405af7af45daac1ccc105165741572d4526a24e03754c494d95ab3dc31936cd07d477734b4e64b9a89ca73410c69cbe9caf62b2b585487391f5b0b7232317904221c93c0dfccac5430871d6a629a66f56bd4b53236799eb45f8e2ae15a8549ca7e0a2ff61e3ffb0192506c8c43b0061c4ac2c26b74a94cdb96e886b99e83925d1dc059a12f905c6a696057b5b0a9f6ebd3eea9b5a0d246293c99606d575535253ce250841e097c6a6d6ccb87598c76effe0b90bb3d62ab3c100320c298f418150f783d87c690005bbc5bebc3bef248e094e714ed762be96c05afb0683183e853eb6fa3fec622891fd422bf7116baa12f8761e0bad9fd5766424b697111dd6a68bba35c461200f8a36ccce9d0fb7ddd3cca7e4c129ce48142cd63cfd96c3c16353373089dba24849f01ab61a512a5f0e5947debf3d453cae97b3630894038dc58402500ac690d282a612ba80a8474913234ad1edf639bf2ad5f486668811559a5892465908f6049da15b9b1722785cd510bec4d3386eff90da849bbdd7c514c2f0720adbd7014a14c271253cbb763b03132ebe14c1d20fb26a1d0a586acae6bfc9899223684253cc7719d71270bcfa678b39d68c054ed22736d1ebf404d10c5af765c78c012a1f6d1d017b4ddf4e295e68a3bcf82b5041f4538c4423cf3dd56aeee25180b63bd40cce20c4f7093250e2d5a5f6a2e5565ee0036e15cb5d21e5c3d51c52ab59f60fad43812e6ad921638564c8993c2aad900a17861a93bfd25651c15bcb2fc5e5c585dec526ac900cb90667ce5088786de2bec5291fbc71c60ec2d2ac04ad195357d9f1ca82784adca10c9ac961c62a5f69743956ca4027240bbcaf0d73324261a017fd4b6d5c7fdb8cb62c84dffe42ccc328b35d62e2361da4e77ecfe7b54083a7ef72925fbb52870977804b29397de292edfd31a3fe71c625ea69b485f463be23b2741bc684e8393882c9bb50bd912c0f72528ce042b920b175ee378178aa50070fa5d6f75fe0547a56f3b9e969e87b006f369a91dde9203d8b7a1c7d8b5261bf986746e2044359829dc5f1fe3bb30da5488d6e45462d36f9749a90847be3ee61464439df5a73cffbaa1fae729b256ce79e20c4b8d8668049242a04aa6348d2149eb7287d5f33363bd19922a05beb31d85fc372575d252ab46f870b33194174165ba919f4fa3faab362ac0dbcbdd071935f25ac07f61efb01c28d10f9e7647f8345c69f6486b9d8c57f9ac6423f75027a3f327024793c531b178b045310d5c4f16e9aa52b74111b99a5bad966b034284c8b36dd836956de89e3d6877dae341285ec90748894ebd424c7f1180a9caa24ac2353dbb7d31efcadbe32e485845fa00cc401bb554bfde57007f1cb6fc8e303fea648a7a22cf05513706d7cd4ad7dd923043cf0b6fd5d6391b9f77223bbbd639317bd7fd1205b26dfc2f214b24d378cf51674096f7c0c3bd0d5865bf291a44a2223f5afb8292cfce990d1903dc20b4c0b4d7f2584a465ee7ebb5008c562e766bbd84db07fc48aef3554612df37b1baa52c7b5ceba77d6fa1eaa9e01ecc51a91aeb7de95c523858e4baa632bd67986c328de8ee01d162137175ca4340268ef08f6a929283b4525b3371e92dbf36d76296275d9e2b7ad494ad0201011a7ef810b341b70b85493f43c886ea01b59417aa1745394b4ddf8e31d8fcedd9c41c4518b22c548831e60dbba949da325ff067a7e84fed58f414da533424829a8121af6e93b95be95832e4a4b2ac29426ce13dba9b5f69bac84e3d00f986c7c56b61b94b57851aefd01763ff7b0e3ee3e6d442a1016a9434f354167dcf2e68c1f49aa31962a428068d221dfc128dcebe0987a891ec38b02d8cb5a2978190805f6f949631fc7e7777643badb3fc3cefe340dc6fdcdbbead8333cce6776fe319d1da25d2269b4029b21b2161efb20da0bb3fa92cb942e78fd4d912704684c5e6630900aee8d52dd0bcb8ee0059cdec091a8c91c65af3c53bb546fdb70a7591bba3f4326e55803d83479610bb00ec8f969c020d9ea9e466adb66aab5649c561c90c708b2bd0152d6bee06c88f18e887351deb8f9a4951718349fc273afd6ec6e0abbf015924ff5b043c634d1cc974eb168f31d0a430c30bbf5e4961d8c7ebaea6ccfe807122fc6943c4edbd689bd24567fb99ca35b8bf357424603c4ab496c49dc0dcac8cde64a7f7fb12e2aa433f6623070085a5d613ed1d38df2440e85d511170b21191dfe3cacf3a91d5e671a3e2507846f2328576c0ddf7cdd4267b7f85cb46dedad7702a9d67f7ed02247df743f52e778a140ff9dac1096f97b6e3e84a1b9411512c4dae7db4257bce10c58ff65a3dd1f0e9275fac84eb6b3d6b0a2345c113b36174228b681cd8adbf3808843c4640853d23454731cb6c20b8a9ab7cbec20a52e6e062bf47a8456a0a1063005eaceefab63b5e54486db5bb627b2bd8edd88686e5aeb1f8f6a7b6e0e19a8c95e3b7260fbc5afe1f888da2dae09d02539763cdf04fbcd6a33080d7ddb31e90b7d46f271c17045a5dcd985831729049c102557f2717bb641f959c18862c953aab35a85ca0377847cd7d835342bf630e4a96f0aadafa5300d98e1c84a4f565a2b67e59b6757196f92076920bbd7efb06366660f93d70ddcb7ab2df848957df251214c3b5eaa7de5fa05b13531cf7a9e2009ad92b5e8ac26155b5d8c9c6ec5054f14fc3fcce1f5400558c9e3bcc7c18e1f609b154b0a48eefc57d2e060c217ebab5cdf943c514aa99c12352493cb0e242a3ec62a4d1bea8a43afa52145e2d2ae06e43a310ff62dccb8ec72dde83b26787facbe9e481276503cd7ec7fa5e3011406288f20ac9f95c819de1a6293bd8674862f4ea0ce67865b569753ce17657b9e85baea136bb2a73e453618b7e05755359c53762cb13272d39a7169589e3febefa8f2c66efe8b8eec91a9924bc9309748b5f9c6692f92791e62d9ee97cd5f04db497b8cc95f3650d02aad9bfc8cc57c1890e72fec1002e4668f43c268284ee85eb4911eb497bda77a63c9bced64d6e2d4d6d7f2ebbfb37b5fa60f3b6688bc6db7a63267f3820d806cafda14dd59745f21a9ecca6a53665a528dcf4f4f35e8fca552434a30dee478a47f6d143172bfe9cc0e2d1f701e2829aeda2fe1e89d92828f28e99e56c4365dd0d492d9a8e608efd6eeb0439b540915abf5bbe0214d21a3da86c60e15a1db0513a2b6169bcd7c513e2bdef0e6240d8745744e9b6b945b00be7c0bf7afd4891e48fda6c9057c087957650f31d747188c4076c91e6619076e528fe94899e493b2e129edab7e2bab4a39fb74ae88bdeda43e35dba3bb98114ca7ccc0721bce5fefe39745a6f49eb72edbe154be10153edef8b14d4b76e9b26c6149d5fa1f8377ad31df568187a1511eb87b95cd7917bb9e80477855d9e7d8e38f9420b83bd75267f60be4f8bb8bd5a901757b03edd6dc4a22e4f7226485da220b1850462437744525ec22f06d19a2662f151be4809e0db756b958323cd291b4b655c8d099f59c5462efa1e4e09d289e8d28f9911a272b43fecfe6cc54cc64f839fbec21bee198665ba4af53e58ec2ea9cc8b1c5612f12d34518d27c65a09bed3edd4644f5e373a34fd40507edfa4a69818fd5b3302d63766e54902dbc8f4352fb6e730135844f25d92aa7815402145bac887856aa03d8ff78b9bfeb85c4f5dd31e4a442c3cdcad2809bd409c0d09e6b9fb51d3c44dae46d95ad44fa582645ecbc8e6ad3a0f05a795ea7da089baff734945cad1ec2b2064d46f2a5daa9cb5d305dab13eb71af1e8bb4db1029675f2327612363b8cf83ca4ea8254b7e7493d7bed9a6f51a83179ea3958cf808fdbe1737013fb9dcef9587b36025a6e11ec09a095806608187300c1dae01c2895a965c18692d3d9e0ba0dbf08f24c40a0785bdfd9562d82bd83ea9e7855a90ad707a49b387d2938c89a69ec0e6e25bcead5a6dd2d48490c6f62810b76d3fa9bb3cfa14de68b66c79a5c11fca3f71192a474b389cdc02abbb1fcd17c7626b827e83de2c9776e7a4c43ba84e1c1084f83c5b802ab4b52711f3b34d3ff626c4133056e24a3e0251c0f0e7f3a379ef73b02de072cd60a01883bf6c357cac6d276a2d0c51f715b02e8c055634481812d248a15b90d347a33c6716fa18331ee609f5a6b3befce54a3c0ead04eb5a1327932fcc47fbe1bad11688b2df37308d884f23fc4b08821d5752cff2b7c99a37a15b851b68648b34ee1601c313e67f1b742834a34c43a83666779f145f0599617f9ec151295f1e1ed3cd9c0ab7cc30547a953dca1484c3b2e3aac1fd87bf86afe38e4532f5fbeb8899517e79ac51cdf44c4b88365fd1306bbcd2286b6990f5d6357776e8cec92be0825efb03cbb531ab66a426d6691a6af278ca1b2f3615ae6f96f1af0315b421fff372d38d6c77fa5abd1975516daaad8de0de7bd8fe8e39c5c95123337bed608f5d3a91b31a2bea0006e16d6ddaa8751722e30d1f8837cb49da4dda05cdb56c6a7ea2f4ab8421b9b0fba39fdb29eb2fb53111a0d5842b92a489eb565eb2670ca0f4aa73688effa7550f88bbe5a02aa0a2799138f59effbd2c253f1560b9f19ff635a52919c282f675be6d07f9bbc335c11ef4cc9599004acb9f38237dff50e2d9746a2f2c996151400e68bc1cbc3aaa5b4c4d2fc65aa83f7130f4e8c51a19ade48719fd7455e8e26ef975aa7d5b3c611348d798e916b7720c52857743dc6cbdfa36e69946989adf57b57d127395a60121d719e2af099264c088302819a30f2f195340a6c3f25f4f26853a62007a887874ceacd0cee908758293f083f6a7acaba1c427e60af88f2615f86a99e176f211ba75723a99d7966439f2a2b84c952eb4449dbe7501bd9c324c44f1283f89c376483f8115fb787a446ae6c03fb2df81e41c39dcd4a422c053b81aa42e1750570569750aaf4dd31eec1ac13bb3f2bb7cbc059bc4cf436ef7af5dd26b8bf2cc362f43c829a30894ce5838c07c04c02c710624d8269ca6a57d3083aa81df9c86505ec489c8014061aded81d4c7cb7dcab6b0c2623e32d07ae1622757430feb8cb8c13e7186fb59dc62925ae62dd5bd75bccc2b28a97694f0cb2ea9c3874e1eaa6424f42b2232837a37b9d610d6b2b08d9d8fb6823c27baadb92b3cb8cec5c8573f10140247d923830edd391d99cc2c07d7eb136a14d3b9ab98bf6ec42e14a520eea48fd2cd5f7ce2d14433d47c61ef2904fe5f3753ba591735702408dfa4c0edeecf8ba2daccf131141ed2b1bcbd016e894315142610bd199d6e642b0f039bf1ea48793d19029fd3d2cf09eead740eb667f1fb4673dbc52ab2ba6436785c3bf159fd24df9a02d2ea514b84b6670a2d792d22c8e5a7bd9298eb9ecd14783103556147c6ad8c0a858690ddc3b76517c9306f3fe56e8cbff41552e7fe0bf431a1d9fb322ee5754aa3e5bfb7792508803a042adf10541e62771decd2ba5d7f5309652b62f9445eafc6e89de6b8ccb9ba0ac0cea207808253588c5dad74740a9cdaf6f3be3fc3d933bdbe03df9ad87c446e0aec483b0907b92553a45c7514ca02b54506d8261808f2105187983b150dad3e2755a43bbacbfafd7845bcb20c672637b390072d7ed56cf551a4143cbc75c6bcf47bd63ff7ba99adc68ef1b3b6009b20903ba9b26b19f6d5273d85b147b0b92673474d77d258d117a35ef88b26a1d957f6deef264ff9197015654480f744066d2a2ef9647eca9810c446d4c24266f01eeb2675079f2f2492db7c1681ab2e186a4e212058935bd9fa51b2d10fe549f977e78a11f1b5a1fc93056efa74b4f9883af136079db79461a7c7c0767d2ddfa04e81a581d97b00a87d9d53e040a83f0a663caf286177fc1b1b80deebfb77a856394d1c0543c4c16b47a5eb7e173a51e1d7a7ffcc406ef4fc143d0bb743501d78fbffca86508b860d0a4521c45d81031282cee8869c5191d44bdceaa776183ca0fb04e8925725694631bec2f04e7664769c45ec33ffe34e9c3ca5401674c5d6e1d31c249eef769771287d2fc25fdf7f10ffaf2c375a8ec99104ee381be81ab53692f48738dc7883fbd45c0571ca91791778512d8b4efcdba1c0f8e1f9b448a2eff8402634a281312adc58a1d9cf6c1664c1a471f813d6235d566e1e04d41ccaa7f206d4868b61d65fe8849ffb5a9f919b81e6a362f3fb644d1f08d0ac36ccd25d9a37d2475233fc0562880d756dceac81d22fb324167d033b17553df852f4bc4bed9c0ab4a3e42f8a9ef119e810b5ddc4098814324025f7314283ad0567443f4ae5af08ab70e370f6751428ce92f46d7e59123facafe010ee92b59c84e841eb17612f1c97c378d169840bd4813439421d89a92317e10c1f214a0eacc91cd68a7b90fb4eb9ff28930eb3ee486c57b368ea7a4cb0670789c357de481a5c56e9a4d579287193f1bdf40526835b3a778a8534dbba058101448cf6de2ff0ca09b446a1cb114f3c6d931a5e00f8dba7f512e64a93f24742f4c4440689285a6844283bceb48f5ec20dbdac6a66272388b54778058a3ab254e82d97da2b6f24ce433091de0d609f5579ae419260a6f5a5b3e59f230e57aeb4bf5733746228a655ce41d1a22dcb65f1be597dfd8ee290665ae0674f9766a2ae06327134d89b92659ebee042037190c20a0c2cce41dcebc3baadfd426837e94d110ec9b4d99fcd188a95f71931e4c481a2d7dca59da1b8e10d254c21f5bd2a7b496e8b4587662a63c7587c7ce55b40f10a480c500890fcd9ad86633889a10e61ebb7ea7a84f1c90b974806b06b90e43339d6e61743517b2b04337951e78e110b7550a800c7a156366950fec795a49601783467d2c6f6ee7991c9d506f8d035d0b778da4214a7098a2d3d732893da1ffe93fb3584dc6cf5df450d22a8e90f7e821e0231155c0fabcb35846e9d4feabec8fdeefeb779e9dde40ef21556650a1309e994f334c6051e2a6d3fb35c8b071ff43df0207afae7e96b7a941caad02e689797c188af9e76ffa44174332b3e23028f3a1c11ac043b816fe7caff391c80e1f2a26017230db2beab7719bf75e54f7b20dd5d816ad8112a2afbb17727b0445a8233e1ab1cf04b38f75eaa864212b296a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
