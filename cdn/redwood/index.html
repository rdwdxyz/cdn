<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aace7c902f560cad1c47d0ca06fa3a3d8435a1977076e25573e2bf964557f2f7c6b12476401b0ff39a3568e8c11a14c79b8dd8d722a4f74c732477964b6499bb737b497be07ac14a8d51c9f5c4c28459f813a13e928453f854cfe4490ac848ed62977ffab6423cde98d641219b22acde55a1871b43eaaa4b43a42e57f97a50c5f716a91018b7d1d80cc7840200c61fee60e25f811a1bb16433df76e9551f7d9e6c30463bc46079808f2f0d0e92495bb669af5f4865594f582b0d13d9dfa19b4514ae876fad2682fd1b2389e9c4231ebe0a686fd268afff622970b5376a317b67be25371812b43de17b844167fca78b4f23bbbd8825e51eb8f74a7c81ca94522e2853364cfd8b6d04fa436d8d6aac725142597ad950c1b5f0c219fb84dda78bc471cba67c58386b5d39ce0039ecf02590fb1937b636d1fec03491ffc07cbeb294f7517576a2e1de4b462b3a771de80ece837a9bd25023cf0cfea296b23a13bfa0957b4d9ef1b1a47bd72244c440483bfb6c807de5dbdd5f29bef5043fd2d837db8b791f2b66be3646b63700e51bdbc2dfe26a0e27e751943a7b844fe9546794512503c0673f6ba2fbee2af6f28a160926a1ad3a7cdd301e4c24eac0af7a8ed581f91a7299868db735c5f35e11f50bd0c8977a97f72d2dcf3f15ff08280143653296d9e75a4f3c59874c01ecf4a9b2f7047427d4848c8425f918d9c0a886f60f169680fe2b45a9f76cef213ffd90e115dd1b8b3650220a369c0f55b3545cf05519cf4d5d8ac5672e103fa98d9ff16ae5bf5425b63dff25f770afc9cdb8001e6916664a2f4dba3bc9400dec90f97f1101e7f1064e09ec66ae37643dac7413a67a6678a1c550298b3c218ffc9d02fefb73c902926862bff1088af9048938077b2311b54177c815a62bc2f5bfce93ae4626a7934a8cb76e93e2b0e465c501aadadcfa30595d6dc744dca198e912233feaaf5945c2491bcb43bca1bf902391f6af03a034c0179e405ce6f1609c6745d3b825fa42f973bcea5d261e384175d3e400c4000b170f1786a97364fd1b7fce2fe2eb7a374e6f5d65e28553a712eb67facc289b5f40a6c876d3b06f05b0b9bfe6a3b5e04c5f40ec895a4867b86ffba1bbb43a28c94c7f549f038ecb38068df8b9ca270bc45749445b388ce27d41737614fe4c1591a052884173b77ecca94cfbcfd6ec5830175effaa3aaecb26b0088e02dda8318b68ecef904ae5b2d4cb3d49c6ef55f5f440ece2a4db4020efbda3aaadad0b1473bda594245bcd13aa12c8bc8755f05adf68c67dfc02990c8e055ea38c28b2171ebef45a13fa4e379f4b4e98943a3546368bb2eea60934061c16834a78dd6f07846bd65a5fe19c27fb8728c35b0edf0ae5b61c04549bd82d3cfc57accee2ac120cb87e7280175683b9539b86e952ca0aed06d5e0edb7545ac942f54fc7ccad7d904ccd9f79b1a7dd97666a63e122f0462f86c12b2259b40a56dd523bb3f11b6cdad5df5e0f00855088a33872f49f7d523cd3462bfad4ef30aa797b6eae34660282c62159bea4bbf8f4e390656bcfc3c1f7e63992df812bec7f2851067adff324f063259f64d15165b33941462c94e44e01076469302d2209cd77befd55d7a96d6e7c161020c775a235529c1da0e3c014b80cbd1582cb14a12b78e3e3b0157997d83ae0514be590c048c4d114e55a3a146f2fdbaf2ed5fa2206d5811529090590218c4f70eb93f222c8c411277b22ce1ce37d523fc133423d7d24f26fdcebd77794f815dcbd3e362a9aaebf278b30f0ae17d261a8e5a0cca19ee51cec5e9e5e5ab78c02acb32ce82f3691930f868ee92392649b0a4f235c035a9dc9d3578ef6ceca9bd2ae2e3542bdab963d915eb61977eca5769e6467e2694b9a50f3c7fc7b1899eb4b54ed445f89df78ce99ee02b13f56effc6b3ab37979f8841870970c8324ee0bdc276aa0373aa1d9e9b60020265b29055284faf96ebe35c79139455fc1295720dbc8afd5fa166fc8fb7cff11ec1a4c65b95fa8cbd220f6fd86c69389f0496db347bc3f9fc88ea3552cb8d4e288843c22446c735ba3d9b2dfced0df5e231eb31a955161a7ee1b9a619fb9c15012fa67c998cef138be2c201b660829df3c2c08b9d9674ed042f3d2ac5ea807c0335c99bc244cc4afa2071ec0c26101487efce9f996fbd2a34e0adf153b76ac74c65ec7e05392f0b9932275477aea268ab5ceb6cf64e94050d14fe8c0aef2d61e52ae83272ae1cf28864222f4cefa841ffc89bc450897e3ac0afd30ab87c7c9ebef2293da74d0b1bf237e7d974f1921e8739fbe138d6a6c6d0c644ce2c1512c481a12cfc4b90fc48fd384d8b24dd10173f313bffc2776f0791f78e943d72fc890f919f76e2f0ade4075e867c6d85ca26de8540edfef3b01755d6e280e8c0edf6a6ccc1207824a746edb7102e31472e2c878c9b88abaaab29ecc74d7e6f086e6e155357206c92278b98683a29e3098621237d760c70594e118ad6ea638baa09a6d66ce272bbd9c0861e253052d50b43bf889f90c0c3fb789aa36d3ce520427cdf28ab6e7b3167130c4c99557411028e458376d5a3be908984366885e2844c094e5791544e3cdda1129f790dea95b3bef3ce1224dd5798f23f90ff5c3011b9cc86ff9edf88b9a02625e8b5f8d48105bea18fa24ef69579808952aeced4515fe981bf0417a6f50e322b552fcce363d47c526bc2f9c32b25429790a2dabeb5f71c89aff07aee78e582652d4ece3009eee99d345d0bbb230c7c87a6dd583c5ce092fb25704a58de7278240dd20563c1c4789118578aea965105492241f4e05bbb933e37d2d7ff7bb712da48e1f86e69e9522f4d0222a9b7c4e2f207fe4ad6a314bbe06c70c8276aca40aec9c04b2c86cb11825702f5912fb2171e6a2b2a0a31c5f9bf9412ad5ccd2196df2fa5222893da0ea7a36b9660d47a975e99e753dc5d6f52f0b1a02bf13b8ff33c87c9b35b2d6ff15e26af37744b4928a8a25b3f5001a3fa5870906ae78c8f9ec9ab6b4965126888d5a04c377b4a006c320034776db43e30cbe317d1de67eceebb5f5a0febc991a5b4efb13b680614224e29456119cb5efbf65eb0ca5d0301200fe94cd7abd588978ffb43aa9a53e0c6a04fea4ed5ef2225279888c0e797aaca5db160598c0e16c0b2d8c3de4015a062e7db63c41127e65855e57fdde5ed794d26263977ac16c2bc26a2cc635d36f332bda4fc4c094f8e12759abfbbabe42df4fdd56a9dc5798af3ab8e5bc54fff90374a9c70a8ff72764bdd83c3db553394314038967f69f28e6b31a442831709d21c7edf71ca58bf579402bc00b686b46417a6aed418407d02a24125ecb0eab3de3c0f0892a69b018e504a32041276ac5b3a6d987261138d00674aa3cf0f8763627a4574265747fdd6650a3881f3bebc3f2661e745d4e079c2cc6c89871586e96e6267cb972a2e59923a1f12ff349d21cf55f93c0eed980e78b224ca4a0a04e2e3b22d2ace2f2abd7c099444554da977f89c24eb7e0275caa641341e66efde0822cd93025c86fdc6948d2d301a493df5fd60eb50a7fccb6fa0f8b31114aad5a5ddb357781d4e037bd4618a48e19cb9771bdaca25321106eac0bc1b4a5c93df98906543565067ed0d0bdba09ced14675938d21b8e9e7b7cb99985f31dcd662a3855bd50846c0680165461696caf0d0cb6d6632b4f4e9b0a73d7e3bbd2cf8ed4b1d458315cdce9b67948dcd1f5a43e477c47de983f698129629c5eccc2ab81b7c2fcfd212bfd923a85f682577fcb9bb988f7d40561ba4baa028349d07825ffd0572e202befae6719bd6aaa2f6f60dd4133a4ff2bee9593aef9413058a38b15a00b8950a71f8a4fe1ba57b1c40885c947ebf1bfac8f826598587519919c02f8ac760a659bdb0a7cea59ffdf936a25e339068336b496a7fe62f975c70c6893d155f1266294614feaf2832e775f812d8447086b987cfb39e82c0020d7e60647979fbff5077e624f9e885a0dfa42ebe79c4052ed2f892509780234e22d2f1b7def16e203f1c3bffe6c6dcfed9d949e70f5431d0c95cef551435ea7599b77323495eaf056d15dd39375cc6c423907522212e39273d6860af0f6ac8f2b38cb912d212280738b9e5e3109c233f82707315d9320c4cdab706b9c4a46371e8ec1c588a165bd966e310b82208188fb98fa3c65bddec51ff25dd825306dcf90fb87832823101c9f196d4752a2d605ffccfa40fcc97765c2d1d1bf969ab6bb6d9b4b74c82bff09704fe91a52021b92e6d9a8d803f9439e1521eb30da223d78b1114700c394ffc3f733071e00180c8e1458b89ebe3fa3f15bc061deaed1b88490d8bc64081b810be81404cae9dce2b9e2443f0e2e02fb2297448f3b0a035af57f3e53836d9de38a7f713a712a4d57cbb64466992295d38f9032e1dd3fa7ad1de8be5d6f75a3c34ec9d5362e88b8f95a3e531997ae26c400f48b8e0b46933aa2d7fef7d1c5c666474ed83f3820bd6b1981af891eb74ccc103c2cfabe117cd7fb547a192ba8908a4120a785021569db58d22fbbabda6022e09c4a6db2dea247dff0bce718e70d539e9ccaf0fcce61c318bd8dbeaac626bde430965b847d84e5d8d473a1ec6b04411f392c32e828280bde574eb3106dad51cd19143ae5bd7e3ca498a8cf7460e18f41182856f3965b8f43817af53d054ceedb4022d9602d5cde188990b10a911e6aee33ec7a849a29e02b47cd7aad72ed28f286af07c9aedf46dd3d3c04d87e991f2669e6ced29dd333d8eeb75dfcf20320c761a3e9cf53d2a5c08497a8b3a3f469eb5d5472f39ff21220e6fa2a083a77040dc00b37f9682d1ad826dffc1e85a26e1f3b14b92a5c14c871a28277f84fd9439207fe41686cc58bd5236b2b14d5a28c8f1983f2c6b78b4362b9308616584d035bbc2e2f9486db7aceada74047cf838edd17f734608bd8b18b4331153b95db2dcbe8ca335772e3a707c2cd3c34e166d6b055e4f6d9e83cbbadc1c0b8168f3aa6f81e0a094a0488fcdcd4cbd3f33f1a6084a7da041d24eb920f8c325a446423742d2bd53766883d055b0f3adfa9ec484eab393dd0ff80df687030d3ae5d46aebcc7e253e73a9a8e9bc770e5282eab5f2dde6437b7f152714b42dc245e2763cfafffc217a5461c70b26f39b7fdc71d6ad2a64e20d8b768a48dc133187e2120c6e278dd1509711aed1314f0b511108f1553315879edd7f2ca67204b47ee7892fb203b5f1901d17f5cfd12e2c78d16dac0f328bb7fa8c9cba1537840b34f84c959a916e6ea7aba6fdf9c4057dfe6e3ecb1b34c1802e573bc56148481d7b8da97b1185b5e2a7bd1c284f61f99f3eb0dc7af9ecab804c7d343219c61aafa5610c07e8894b4abfd06472658f3fbe12da90badd00ee9f541b8408cd7fc167286918366bdb34aa66c71f53dddfcb8ea4635c51449c3d003b77e4f39396ede534a8119085cf996d4bfd4dd0b891f9aaef534b0f0f438f45009caed622088e885aafc49ea55e8a87900d7c4a4168a94b7894af5bbd62d816fff1fa9d3887580455c5ae033a1606251d3067c508c4ffa37551558f73536352e6eb6fb97f318558a893bcf8ecbe34c879e32dfe058cf7e4016e30b185eebbb7d4599970ae0dee36a1dff74fbc421aa04ff3a39e180ee2e29ac4ce73c9e39b97da683bd92592650d7fd3344e46b8a382861dbadb3d1436f829c63ce2e40182c4ba80b3d5a704d748f767635deb244ba27118646bc1e4873d9b304af6f783a4311a2dafa4e9ac27b97d18fbc65514e1603b12689f7793e8ee760d7650f129dddd7fc26ada41cd0e5b5bc5e9cab083b9baca987b6cc82f61e08e3545b3e5585d0f405bbf6e1ec944438808e6fdc4becc30bf7bbd5bc281c45e1f127229940ee6399fc5cad1ac3dc2d8e7e00958b61dfd630b393760b957bce3ee342868486e585e7d0204d3399358cd506284f10fdc04ff78763f0657b24cdb070b60d0253c2e5124738b803f81bebd3ee46272cb0731549fee968b8fa9eb8d7ea198f6ba543dfe8d12d398017fe4884506eeceb86361155256a63d81ecfebca3f2ab044c8121ebef10126057f4f750e4e5939affe389023a0713251065a88971b99ad9b3f5b8e3fd3c16931e923498b7c757aa1e8ee40fcbe508aa18c4731dec577a7f6714553188e3c456b2dcd77a7d27dccc8b8c01ff46bb731021e577aa4a42db971d823fd59c1ee77ffd70215afc66a769d963ea5decf73476fddf74ed7999dd1a466de8aac3e2330baf501f1dc0f2f7f4486f1114e018718c7e2c3bcf83b575b73353b9356ef440407f93e7f02d4ed2d2bb9cdd0959eed5f8d142d9b1f761f0279826daedd4ada3f5cacfef6a07f14f6ded362646c288c9dfb317354cf26636100e96bb59343d2504c82e9444d98fa97dd184ea69302f6f1bd05fc2cfffb0e305e19aa08f2842c65c576ae23148c6da8c3ad58a7a94a4065747e1f8ea060d08025e433329a2e208f51f7ad04894a0b853c91dafba5b4bfe18e28cb4cdd86491f829a7760d32813d6d67b3a8cd6b911aacf78fbb6997e324801efc2f19f35a7e9211b37c3ef8f77c0edc21fdf44c3a1b3dcd8f475db05ff23cea57ba662792e15434e696aa72bab52aa2518d396a70b991747846996c76286fff1eded309d2a87ae4e078cb999fb23539bad85f03f2c1f0bbcedf3d02047defa0ac8188064298b780d59b37da209cee8132666472e52afd7bee1f6f58e92bf8fcd41572ed031bf1db07b042384c96804acbcc07d09eaa104f6c163a342266b15d74de188434a8b3f5978853aa1ebadef0494eb9d72e91b3a341a7a5a4583ae8fee7559729ff96d537aa2636af25478db897f886c18d50d199434df2d3be8ed97d2d4db86c5117f42b58090695ef6f062d83894773edce19980d03ddd4e3b1f2a955f9e506613b864af4943ade5420cfdfb18291411897a246da5266e26aa34c66d1e209126434cb9319c5d21f59b06b627d997b72a4e42dd7d2e97048fe67565ccd9212db19f4ca31f5c0e03067abfa0a26c7d741f32e82d6fa509ccfacbe2955e3a47686239225971f3fe685825028e8ddfdbc4017f6b1c74cf534a4317cd02cc0bf460b1af82bb20cd62ef7550a518dce75dcc6e02c6c426adffa11b3583141288b7bf4b2e47bc9f3fadf6d78d2a26e08a37b197e1e8748c1504e076d0166e1a2632accbe55df97da8c53056f5b4c39b2562d11876b7c327e6db61d53fb2b66da33baf1207bf6a16b447d4e3dc71c47795ce13b2e195a79a3268ac4d86fc00b76a57a4fd2134e1994447de1bf66b06bf8d2666fb3047a49213fd09d1110e51a11e2034b80b99465125da7b99f4e230b34f00393cef692a6540cb07db3f57bc612943f8f879b8a9fe39c6fa259e4522a873379afa4d64feb2523c47026de282d1d0dc89db288abc3bc32c6dc0b97cdbd9ac7f5a347c55464b89eb6fb1c06b92dce94f8da0c8f70ce690ebfd5d837054dc88553b9f15f2eb8a17cd06881db87c8c0a4b6a2414f8a03feb5f1c94d4c1e3cd92a1dad927ee1db15b2b393e3ca6ea04bf523b2c39cadd4cf4f7edbc44b5981418d806f5eeab9ffdb8cac0d9da033a377254997086cc19871b977274090b631b549371c7ed65dece5cd5f0d0cf93946e36319a0f04d325b9e20bf7c1b8c91ea1521e9cfe80c6fb6108aaf017cafe51c404070c83663156692c004621a07bb8812c079f6e6b08e7769d09a2267bd89f65638efb76eefc23c4db85315648e303849730142ed1e3651bfa427ea6926d7e31a886b0a1728ecdddeabfc53e8f04443906aea240f4752bd0bc8fd094bf2da3400ac8af4c67f48b445a4596d7f0961013f04a75e68dc693682e76c684479ffe71a325d30ef68d81867d422706b4744861332ded6661f0629f193bba693dd89b1e18180a49f8235aec53e952f6ad1ac6692bee6edb1bceb7c92e0d1965184645c86e2ab6ad913603822ddedfd113487f252b1d030815e514c6ad5ce60ace08021f8df82cee55a52643d30e140a5d81ab4fa3dbfba36224e16b27564feacd7a4cc40c716e6832517653c27f6ecf0c1fec75067d56c1b07743803a2e6fd8b9337f8a1faeb4690aa470419e5ff37a092b35a9f555c10efb15d289723f8c3edf42a960db309dbcb28f68c6091bbc62fb88ab9995a4e6ee5f2c241178ddf64236304614a470009fd31b1c6b2990127ebc1ee875021d8de42490b6d3701abb7c134a25fd4c2795795a9fd62ba6dafda66bea9e43cfa10b61175748c9438ad83aaae575b230743bc4cff91d6d228d1724a2f2811ff720abd63ba9f077205390c8a7d9621e3dd60591d89eed7a03a42e0e64d44c7ada758888b2482afc3af86ade183ffa6827aecb5f65f1eb48471269e8ca73c897b96c36d65afe3474c0a273af73ed76a9d4fa1ce68f21441fccc3114c41c07d116522f07fcd24ebf76e5980923ac0bd5b33730cd204e0844a8394cfe4de84b6745fc0ba2a677a94878dfe6cee664dab80b82c822ff8fbcafdb1361dd56189a3e1208f463d908efe7b66c0f719dbdcf19e93bb015c48919957b9b8889a4e9169eb47116ba54a408b74ef1a31a5de9ef204a7443af4342b2ddf2b3afb5e35d1bb835d9a3f23efbeb8ad4fc99ca450856cded9e62c74d591742da391a2ff6ac14a9f93d10188a4f07c4662f4f4db754e0cb9a2510e04b7c09cf6e45d237e05eb8c5bb32754475581b8b1b815e3767e4a7788c1ad410ec90e1e134e67317575b211686cc77756104bbd0cca253f751b054a359f3eff03fde56f66438e39b05da8849ba5e96dc0b29ab06d222f0b74ce510e84492dea0e4e88e9ccda3cc1bfcff90a31a81a5557452af2cdada872a493edfeeaae777306bdc7f8ffddcfba573f15f3de2ad8053748ff8ada8303e40c0b610b127b7b4c30c80015430553776b663669e5bede3cfdc7000c4cbe7a73e8c59b9238d17d3f51fc35a0c24179869f010a5a4e895b8d60b408ea10323442905de1fd33a7bfd70b62bfd74fcbfdfee07b6adf37db9fac4c856cdfa7d4d2ce434b886ca659d1745d8c38dbb409c8bc80de2564fe4e249422680367795eb8ff07e2b127bf46565ad880a91ba5a9b6ed5c17e36b831081e2ecf38f0dbee802967444acfc08b96e5942377a28fbcba379ff11e58c48192a6d8ce9407c4f08fe67458679055ebcd77de6fb27d9999ad73a2f2f8d70a63b20e515d591de1cb635b3205a0e31992f2fc885de80468d5a01a83a654057818cb8c9611f1805f7035169a6f7ce4b639ad90440f0dce3eed2bafc37d65b60325653167520d32b05eb26ca0630d8fc30b6529f32e60e4528600e34ade8604450ed5c2d7733c49c660ef4a52207e601f41ca1cf763f7f817692f9077a02af4a786bcf1fbafcfcb5f7c34a5a3c00ebe397ab3d5f46ca6564aaf8e50585af2a6181fccf9865c00b8a1a25258ec536c2ed26141a0d9a252ce866d9b6814866cd675ad2e76484458400ecef82f27283978dd8f066c5a90c407f6500be3d705cadffdc7d1f770801827c50f79f439f45bae66b4b88a137393b50130b8c7ecf2b0e37ca5a998d96ce280ce81b861df2bc05ba4476817b27ce6ac2a607f44492936bc83cc52cf58f452c4800c97e29e53866ba51b61fc7a4d662725cbb3363e6a0ca7bc96c238b595e135a1e8a9d6e9a4358eba30734a815760d2a4f74364dc2965ef153ad7c757d73e4319c184d82e10d9e9c3633af7b8d52d8877d8a8db7654f139f3aee1e7bd511db64ea0059cffe8f4068a692c6c33c54cf724fe0ab0e08648f8ba200eb5cb2c932c52d0623c87f9e489ca3355dba3e27a1913eab1b0da31877acb30a98389e765f97ad09fe3a570ecc67273a5cfe763692101d37f133ea1fb914d6b4ce2720ea322ebd1a4d86ff13d3e1c5b8bd297c027254a70b7115de94f24c5cd93de64d8595a4a09b4563c37deb65947789416fcf47026cc9bb91e8b904fea7ce107ccc980d2548470225b04a5e1d4f698270bacf4872478c54e483230148c073353f7dd5cfaee7640094116725b4c1ee64492e2556f399902a6e9a0074dedf27e47a793a190832fdc09cad954808d9371847ddaf574022d82083241cb74d1558a0de657ca6f82832c110fdee6356222f0589dcbbb9b94d74cadd0535aa9239a6fedf6424723cfc7ba5f733d456d0f609a8460844cdf039f99c78590d24972547be5db4d266586ba079c2cf326e1f6abb043347983a5e8943398343fa08afd5a347f6950914695e6eedb28a30c02b452b8497cd36368db5d58efa1154c2494c0fe545c258fb8d28fd013d54895aa7c84b58dbd53a5f32fc1cb77a94553f165024b5c438313e99dc9719bc60c0ca5f06b6a11f9052aaddbb1a3e6b906007678555da472b0b4fb1f226206648c6333b152f61cbd65d41993977ac97078895a67b868d8fabad71a16fdbaf487e1e8cf4f2cb512e1bf76c30d1085111788a3f1059501873bf276788e5e8719edc0826642f46de399f135412d2a5c62ff1045ce953d0d28fb50603710bea159a57f04b63dc3b8fe8323087eeaf326d3e9a478f9882950760c69efe73ea84902d7efad10462e58f49da06770057974a7941b98321228f2931dd9b424ed0f8cd0d6fd9ac1a95452af65a8174049bd699fb7dd26d93f204a71817162448818415a7ebc292b5bf1106bf9b39c6f82579a7feda66c08ce0d996964cbd263de61eabcb58300ef2670d254cd31c14ad0adf69392f8391482d46b226e1d02e78b8a752178757e3c8685690ccace3ff11017c2285b858f8fbb5ac71f8e5f5ccd26c37e51e5fc1df1d07533ea3b28f0d6a4099c8a770e52ff44f50715f37401820eb66c53fb7932268f287f147a0612ed2ac34b7776c867a5f54a374b1b6b266c04bcd4b6abbc2a438f5436957d6f727be8386f80e6013f3bbe348fba2136982ebe33ed404882b4dc6df79245df251563d6b00cfb6c280fd2ed58ba280907e9860755b49db2e0aa640216dd86cbf1b5e1e5a3398e6e1e15beda01a64013b16ea51ea495535619a20fbfbdd0cce769eb27885cfe39a4a53a31ef1bcd75fa1889c4270141fec5419ea1c96848dd42b830e382fa4a8a48ab792f8010bf9eac7361267f2e964a0128a87c2a5803d21a27968ec177ee20857be99efa6116ae05ab910794638f78ca20585a838b1d096b4fcf97f55355cdd55970e3907cd36f0d6cef5022dece47253e8655febc15c2384a62bf05eececbc5b09b5b61dd490c56c4bc4b4bc76516a5eecb88a335d46bdadc4ee583224dd707abec578bc26443a71adec8b7b7b4631563e9626eacd2aec7232931bf93d03d6030cce7421716282c18bb862196ff754ca0b58d80a7ff9e2bb62eba72ccbed248cadd4cec1b5eec01bd37859eb15bf16e86bf20ad273cc972fd5118cf3414738ec993f987d7dcf1caa1fcd1fdc996175d41811dcd6ae94527c629c20cbcedb4cd7fd14923c50c652d26eaa351d5f1ef5c172605ea4183d83cefbc1c0468c25dffcc046aac8a1f34fb6914c945f4b7b76f706bad0f8a22e167dc7baba28f97094d721a9c2bc47d25dd1d7cdc120f79a0851fa07cbd8be0ef9b193b32a77f126214c1c5eddc4dfbe960a5dedcd6fe63e6291aa86e75ad3d765f53317ae359436084e8e2db4b425fbe4c4341cfdef13193c48fcd4b0bd237b731d3a4192abf28f2eafb1e40cef9ee1990ba614c282d844ab2d0e893d79644fe63a6e363b595bb8b504b854425c208936f8a6581f48f466b401b7d4002c888a0b2522ad4c038a47a1a2d0b5d240a8e50c19a526a52b991f8ee8bc9c3d426089ac1090e0c0e78b87a9c1a860004beb9416707077bbfe955b8bb3645aa2988de033b4c970055598b38b649542fb9b173fa6f3aa3d33e7ad34629934754e2d87356a82ce8ddf00d258f27d1191a836c379846388bd3b941a9980b4be972c6bb2656f329cd9265b7c31e3c3004de3b6fde920675d96c1aa8db31bcd940d3250714dd464cf7f6569b852556e9299e36ba5b0a1d12c1b16c413b12e9f0e5ab5ae0d2fad11c2e209d879916fe09c9e8a67dde77a1c9c5ffcd8c3f7433eb3eb15d1faf5424a1db142a9ded8f95075c0b04cb9a567baff7635039ebbff8405bf3b87683c9979dec7c48a485ade0b1155f1a69581e5d8de73c2c778d865dbbc590ae93cccd19d330869d62ff566afd980840c379331b25f8b3496830b574982c6376a13a7fd294cd75096185a2ae42f1f8b954dbebff8ccf3b2c858d0c090ede2c9572a2159a8643b4503bd7cc9fa98b932cb96b0f18c2c92a9b29c7d7b4d1a31d03370408304282128a8babaab96714ae626c7237eaa8f73cb854d5ac9b6b1e1810939336aa1172b80fdd779b01586b0d51f49cbb893b5d2ee2d2aa61384a36bea11ee4b23db0150fd29221cece2b6803ede66b1b09aec5bbf90610e2ec85a7b5322532fc429f23a412a14ee3d10742351e7d982fd5b164db75b646b02fdbd51b326b84fa3eeffa4482224386c9904659954a43744a3b75622790898f21b61a2a02ea8d02e4a954c1b0d07fc3ad33cb5a2eee63a7364a9d78501c5a502abb6dd00d473b379d78263bf3bde44e7087a9737d3a98e945075c68a19c981ea4d41c06e131bab55a958942f284bb049ae6319bdf600800962e29cdd4515d4a8fe1d55ef59210437a96639de1b151cabb14e6d4d69d12a02bbfe0ef9b11e81c1e003aa41d05a7aef54a71eb2b94d1139f08bb3bbb85ddb787d9c04f2c8c97eb136c15312e9795c22063e2d4be7d5d991046d232bf210ca8cf1f6c1aff606917865ba044d9a3e347583cf8c04251ce0eb500adcd26dd7316999680d999987bae856c58bf5051c7ef8044d02c3bd376d45604ca0251df2fde7e9bbee3cc407b82b598e787b7ddef619ff94a38fee1df66925785d6e8150212bb6c701397a1f2f1f34496e258b82013285be4deeba47d14dfcae36a33bebac2d5fabd6798b402c20fa7a08d0c3d04e1d93aa4874ec2c80aa6b3e67ac696307bda4c386df82485b50220e3b63e838559a687285a86f39a9ea144c81106ccab2c0ecea86dbda8107f491502cbb097c3cef739392e35509163a840d02ec7fecd498a0005575021d03c96236b20a7918d0b0c49bc36af033472bd3c92608a1c498d643c4acec220acbbf514d6bb1a7b9fd8fcc0e8d52d24f2a9f0d2c766e5ac5639282a0e0f90d39744e826de3a02e12582a3ed9ce93025adca81031ee61f9420d9952a7080ba9d7ea19164f172b329b1332df75b61c21ae7f9a8306e71f592455fb694f04e87a983c19018ffefe1dd428c691e48d8d102f34f9184ab00d602756f8b245cb401f62657879b300aa899234c6461bc7b95cf1e62a1f2a5f75e88efeba5b596f93553aaa532ddcbcdbc677601577fff6c0d5738d42a8dc2678a8ff7f2c41a6cae72980f726882995b150f589bbba8fe0984a6bdcfd7e111b3f110c365ca1d3affe10c4123b19dd2057a2be302c02924aa4dd70c9d9d0198e4fa8cd513d2b4f90b44c06700569aceed120fc0badc6a0ea64317eb933e9be49f89cfffe1ee6343a172ae95442e25c5a64e68ce8f4f8c563d164033631bad8ee655f8fb984d743807eda07b39e63aabaa0b311005e6d77b2bf524df979974dfec091055d3583da6df982dbf2a2a4c467f4bcdf4bb9c2007c51084af1e63042ba6f56909b8de51a9169c48e9bfa21548e45524bc3fad53a3508efd443c4ab6a5fd1199928a642a023ff3912bacc9ae1d62c0acc4f6b6504665a1a68b06051e6caea020b22a616a81bc77e9b37c94546791206559747a44a2cdda6c9914e8a07d2d72e3b86844486cd548eef386c2396857e015b599479fba468eedf3ffea051e43fea5b7edfffe26edfa393e72fc6e2307ea9c9e3c370bd04418ab2c00dd8c02a6c53f9f56d7ab65da211f6608e1c0f6bb8ca3684b1022da0b9ad3ac6805787ee649e3d3621eee2d08343fc44f0f58456f5195bf26040b782f2222269ec03fd5a3f715cb3250b0c51e70304f4624c81a317a5a32240158f43b48de93e8322bd908be4e52ac9d263f2abf8209842bce4f5e979dafb555fbd1d35558e327ec717d1a4ec0ae1adc7ceda154cece778055debe7072a188d17af0b651db884d0d4fcc1ecbfd4ce47f4a1ab0c78c2c66550cb65f638ffc3e20431d5f5a7c7acde3e632353065b31ccf4ca9bfeca8372be1d4f162f0dc0e7034444dc99503f1b9134679443994a9cf140390d35a5d38f6501a4bc5e9e4053b0e272a9ba5d1691b8bc1279009fa88b69856b40b0afa806b40a97d1ab22dc528887e96c454f8579701218432a200dff8c9843a469439190f2dbd826b453f186a797e01d187e7835e711aa745544c5f1dfd8b757633443545eed8def418e3ef7fee5d245b4ab3ecdf97706e1325da61e69ad90915fbdaee67be71cd7afe21306974533f13617bce75481b088162673eb2fc85bd5fa2ea35f22c086f815657a43d275130576c06dda941595437aeb97665b85e1923622ac44bd8d96088c0e24585c79d320bc74298deccdb85f4889789fcbf99b4ff77ff5616bdb600bd2124b2dd6a8ceab21e2ee7aa418dd70c79132f3d4dfc18841bd0668920864ca3b91caeda87149921e627adbb2fef8008bc461ca0af0fac96c09508a532ed266abea5ec233aafa9bdee0476489ab0297852493401aa7b55bc5b118ee8823615f098ddc480bbf76fc5eb1ab83df083bf945f74bfbe66a8295253bd5381a8bb55d750437bb9c861fd27dd2df328322e962a61fda8918d6552c3937385d07992c1ca4b837355253562f67d887f23733835cb91b60882be8b1807615a3a8b3b56ce4e1ce227fd5b69b5ff8fd7559d8d716106e9b507268e24d6ad3b7d6ec5da46cc9b9161cb4abb87243377a4d904ce0a9da2c3d2c6f377d3e11b336be1308ac199ce2257912a23af037260cebf50cf0ba1fdcf185e27ab5190f0f6416a7618fa9a5d70b21c5c73be28c09601d691d23295bd8da72d885a2aa52a7fb90c45ba51d118fa072dd6bc6e6e4ebf6257c2c43ea8309606c6ee1dfac36d39fffdd0a2f61e6420d34cdc75515f3db12d19b0c1815113427b57b9a3dfbb7e5eb62061859d4855f0895511516850f08fa8388af82a2fa6e75a97b5484458d483086872d0719bd4fde5a894f695c0696f5e9bd1a5c2c25229e2bc94a5c75c33c8ffd4394f1c3eae1005c2e4179c2dee97dad3b842c284546aba7d9b9a780eddcec1446ad971f2131eba9ad90850c3a353adf3b4cee1bf55c8feeafa783a60c9d9acbeba11b6da3a182acdf7395d613e5821de07d9b0083ddd5607012a2948b53586acd530e8658e7d5f426eaa70a2125f0f4f80d3aedfaf08d7740e2f0614ba111b8e2b73b28417bb9ae8d56275b54d91874977b09415974459cf30d06eb5300d9656945838d6172be71e4af26acd0bb999208989ce5d9461df63488feb8e5d7a657395de41cf30c263d66831b3cb5a08badd239384029fb11b27b0b86d512c840f761eaf59de89beeba27a726d0eb027c7f49dc9ad840400bd600653765ac1ad2e17708f1c6408f8fa9cac5b8e401552e5a4acd62ea0c2b180781892a11b62e58110f1fcebacf5065ee73a59c7430360e5470085f9c8aacaae045ca2552131523417aa32311ee7999e2aa38cfe35a124f3aeff6daf5ee9f7782598eb97d0a6ea76ba1f9701bb7cc18528de90833fe96a01d81a541289af18ac5fa89421ca6c175e8f6c7799559674b8a05067c2cdb4cc9602dff644150f68c1b2d390955403fb231cb39b5099cf40affbf83e7032e6a7acbcbec8a34fe4151f241e7fa420c260ae6ae0a1c50391a8792add9a60057794c8ca015aa58a7dbef58a6db64cea3a0dca20c3741266239f8295ca3c4e474c2db21f903f8a10cee15d379866c050c351b08ce53241268eae1b39ede7a2967298afbd65cef96031b808ed544dce801dc1be83312ced42cee239f9b0b0070a57c36d799b0724dd25a7687a474a66173bf53a0a986ce04544ea4ad700eec5587bb31913760a7c3a4919fd3e58ca5c359aebd74a275325866e1a56131d5ce8d6f43dfc1689a9db7e8989774d49e10fa4a731b5ce5c815b663aa84cc7e8680ed879de723183a3b8835512924c1feee4fe0e86284872d4a47cd188cec0b71c4875816e0ddf433499f654b4dbe5fb8423c052b4d4831035f526b243b6658e773875cd60e4d29ed809cab6ecee3888603534edf269c78582b1996697edcba0a9c915fb9dbb2142f8f912d5c53ef029d9271bdb5ac088178f0a2ba20a888999ac98dae7d39945b2b5b3aaf47b2d6212ffd86c9034c415b5dec429d6981e34c7f826a1bb237e63bf381eb05c40e1686b9f630d8f4318e7db91dffb50ffd538be8635b36eba1c6f54b18c1935e6fe0b5d95dc823e3303a9048326c7c409506a5a083d29600a49aff7b329caa4ef4e46a2d8276f07aeeeebcadc476f4795815794327c5482bc3935bba91e191f72710284ffb8cb0250ab499dca7c2870647eb4ce879cd0a8cd551c2cff4b712635e981bb6882bb7d342f0398daafebd9e8622ada7546b72c6390b52af36756c3828e723de6b3dd507e4818bcd5d4207655981e7dbd54029c9a85f49c6d8642474647c18b4e72f4cb0c450cb183bc09347cf79e591d7c118fdcd6ed00ef4044049a79c6f795ff93ca8ec5fbb46c7b4cef9b37d7489439139efc63eb2e4b82d6648c56554f5703d7719ac1cfcd075bb2a3a304ff616eb04284087b8f12a470dd634e51d86f97b11836a2ad5dd7a17c28a9dc0e7e1bb0cdb8ba734d15c7f494634bc43aa88f093b5f10465e9b50f2da4516d9303cf57c66f692ce8dc10693b6dbdfcd7ef2bdcc9c21dc1b69ed4d8ebf330c603267b2fe192be2e0486b1a7915282c0e314f571d31d09991b175fe8f8046cea1bb1ea8d3bd1a4a56a9128ec7697560ff6c1d6fa5cbc7d6a12cf9cf3a586fa581d865e96804c4473f05a3f08c7b7046d4771f1d097bda47e10322f7e64158312ac467b188c14849b178f6a93b190197ee9ecdb9dc61a90d86c78f5122af5d23bf86c39822402ae15346330ef7b28df9813da752c1e26ff80a9216478fa699ae2d86a6799a26a3024fa21c4a863869953b4c3e2dea125765f5026015563731fe6f6668b7c6e7d9a8d1462831d4f16546c37f949cd91c2189e409ffe377a53b37095e9eb75afde3893a60ddd2955d7bcd5473dc587cd51fc1e27e7c69b0b0b0f22623713aeff6adac63717f06a9bc15ab38830cee2f58160002ead548b7bda26fdc4becbe653abbee130f5135f8e5b46a061bde30b9c432c717420ef44b18331b4b65b6f165bb10a555fca4005f3df349ec84d6ac2216608820052faf3511922d24d640c291a69a90fc308b47eeee1fc9adbfccba46bee3281c9426da3bc4e038646167b136adc34af5760e360e620913e3536cc6e592fe30cbd5b49b18701c03ca9276e4d53ecb2dd2986b07feb9b70c15db677697c33b37d86be32e7dbdc77d5043446343fbcf57e1b2cde1e9e477ade61fb991b6cda94e91db6021505b3444a6a65ac82f0e8cdc03b30393e73fe5501570ca0f851992aa2cae5abf998a61d9d8535a484ef323101aa8cbc1d40300458f9840f41ac06c23a3b48826d7eab79f217b9505f80d0b8df495433ed2b1133b0ae0ced2f424e6391bbfd7a0e34ac19de3402abb13e2459165d974b8c02821e2ecac3cfc04aa226a5db7c78a5d764c2e90cadfa0aa65c62f2a9ab684c664536daa1ebbb36d62e5e8b85ebf6386ee46a284bb51a59731aac61a6353d5e0317f7cf17804d200bb3085c6437bea6242791ed818801b6b93ae88abea26174cb228356fda0346affa4b0b9366a87627019cbb0509e10817359777f1d633c329a101efa8aed4812ed84b9a069e24c6a9aead000a5f1e8f344c0d6096c4a6cffc44675e8e751b4183a2d6f871e27da4af361328991132d1121f807a115bc7a1d4af88cf483f53dfc0cf3aa6a72327380c02822189dc1596ff793cc4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
