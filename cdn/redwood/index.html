<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d77d89c48f4012358316161d960417e112f8245188d92c7ac11fa50224c75e924cbb4e974113a2edf7fd88be38c1d9f6a3ae9f1276d47da387aeedb100a14a6b544d7159b0d0c66472cb87767f5e8f411efe6bc6825df664a0e2e61570533de6e5ca792825e5278f7f41165f17c2d4a5deabecf5bd9efc42cffaadaf8f218cfdee228ec7d9fe35cd6989e8022f95fff8ec5fdeabab4268ab9eec6350dc7ab3cede553aa845fd129274570a5d8852d09ef95da02cb9b3ea61aded352d5c6ec3f4f3a144b5726a4772d960f36d49737bd2a97424e3beb524e90496d29c00b3401f3b2f73d40c6e7eea0da688dd1c26e09187f10c3573125e821b55faccdd810c0c8e06f7d97936c32a0e15f4d057fe630d5e348158cd99242f58470b547ebc717a03fd1a881faf279c63a9d41e965ff533215bc9ffec6fff46036274b7f0b20609aaab8058c384f520446330f64f5a6cf93fd07feb411c0999be412103037940987e757f9636c5cdc318d58d3aecf85465f8c6d0e3600c8fce80d930dbae68e382a00be4276f1954d9f89b9320f083e67df882c7ed185d3d400841200204e3c8e4e36a111e0ba4f0d635e9025e88f6ce0c06377e65c7c4f7aeae4906a9d9b4d2c8544c268db0bfd11ae94ee6d484d1f8be7da86bef64bb8777f3fcfdf59879e996c2587b4cdb12e8c561b5ea9c770c172a14b2015b12b35ceb69283a01296763c6b8c7809e1d5af178411d32f19e4a4d55472d2bddfcbd302fcdf5703aeccd7d47290fd48cbfc3cda92589088b64fdece388c93631ee1d5c1da3bb08ceeaf35f2fa7979c779ee6650a40a36ecbc6280435b4db6a8eaeb4c796cc18af56656f583ee3dee7fa2a261a575c47cb53a789d68ff688f6955c2f92b1b3ce95d96ffecb3af705780c519c8953847b792b0f512e52af5278ba783756622d81e82433f849df870ae7a6b8a1c562b102ae40ff343a38ccec4d4b6285fed1c0f3fcea55b86b759d3e26c2b2bbb3e476cb824f89f7017959a141b0c6f981c9aed937cc36ff98bc07e643eed083c802385de2b9a965fe1a33a249ee61f9a8026ee92f21262e7f398ab77669d0cf0f68ac1bf5ff0d16a276611c62b05f154e897561e75948f8ae158e8048cf1651b85b44d5c63a4688265b9f530a87a8a192bb18e77882b268f64fd1bfe01f36a23e65ecc6dc533b917da1f5ffbacddf61d9f2539aced00001354ee57793e2dca7d8fbf4eb8b1ffdd3beb15d57307491fa00f80631a06ef15d7d1c94b63a0769508d8c0756bc643b9d3a58ce0a2e612f2816354798a49710162e43e511613ba72bb49c377109241f3276d78ab326921c3de74cda424d2daf473e0593fb7d9ae7d01af7b6cebf0e1081a80ea98e3602bf9ddd8310e669496581deffd333b79305d24cef5f90c5a5268e0a25f71e9f195aadfebfbbbe38905e16dad81ca7fc9a5dd7c2cccebd9968438df72ca779c98e602b4c59a7072108cc46304d7363940e198e5ca3aff948d655d83b3b75fb3ad28c22175d110289d10d4471eef7d17952f75ffae56d29742e9c3bc2c9646767f0803e3c22d0a654d1acba179836716b463fc699365b4f2911eddbaa39af642c524d524bfeaa35209d99424b370c513f690c08232cb21087086af314a4ec982be6cf47a3d8b890ddc777e233147beee6f520aecbf5185e4376e4ad8a7764189c99c7a169a401f60f8b0ecc98b4e5efd3a4884b2753afb73a10f8e2786f65492d826209f041cff4c7fdb7baf90d140cb9cab5801cfad0c9a4bd3a98da8e40a1c50d0a51f18769b31debf8c823a6a48cfd1b817d488f1cc1f687f7ae63e98217932bc3e4ee8ec315636d9e6298ef4c4606694e2bfe7f9fb9591dbfa0ffaa1e2dca47caea1044da06d49e78daf71b59e8d9547e270f19943001fed5fc1d1d6c5ddb530524ec2b6778b34108feae61876efffffa4b8f945a717275907893bdbd24ec96fa2f473b8019a84695bde0b14f8235fa69fa9f895823798c3e83ffdfbb2b5601c0051a0816f5fd4aa772a03cd12d965681d263d1a7fdcec85721027fe306eca10639d1f95dde2716721cb96beb1e8ea361a0a80f2508f0f8c655a48024da82fc38762275ebd9d703813373ee4549298ac722dc197bdbd1b72d9c7a67d183b1dee08b52799768ab141b87d8c835c2daa923e5ffb402b35d0af6dfff1d2d47140d17b7c66e4f15b041443724a25cac6df071efcf30600b04d776b50a2ba3041e12e88ef00920bf32453ee7f8fc1247a37b64e0a010ab419a625fd93c909c4ec919d1f873b35deb859cd3a9b537a94dc10ca24baa4a86078c2533a88b2980978788cd67ab22577fdbca88f55e2574c0aae4124a9244a376fbac30dc3d1d2bc151eaee008c4ac26ec3992e69546c3532829c8566be7673ebd600e623f0afbffde0ac1c2679e13442e985bc2ba34dfc00d7b34240dbb288ab8bcc39bfa59f9fd39a8306382b8e3125ae2b44ea77244b457dff12341ecd2347e14c94a6b2660883f72f355126cc021c62e338ab4b6ecc32ff45374ba393be8b7e4869bcbc1b4e4eb8a440f9784d1d291df41dc0aa370c9789ebbe2bb2f471111ad106c50d7864af084c0fab3c3a0017ff776bc7d69b72e357ea144c3f8fbad47dfde90ad04bf5f1806b8b8d08d14f30135965ab6d9bc5529622a87696cc72c791751d005e0fe9659a26946806b25b5aab5df36649b7e6b6ac5ea355ff53660e48c97ed929db70ef69eaabfbc5b6836bb2374c04eed54af3378779326a4d5636294e048aa8dda5babb5a126ea5b131b93530875aa7003cef3284fc4f96a025d20f07641b168dd15b35bc1fab4b9fc7ad0a022d527c0e23f91ce9d26e00b116ad077cb2f2888af2902101937a6c070466f5fad775ef793b30b52777c75f29a84c4ebaf5bc48550d702dd660278904cc30b0ce83feb6d26b5da1a830a99e69df031da08639efcff624fbe93dc9b9f99948fadcbab5e3395bae3e4301918e33b09d4a041c6b21c20dd413a90f9392e4d3ca3f698b2175e2c5955d110d09619e1aca05d3fe3293c6c4a6c1d08a109aabef3f61077cac72f3808c103be11285370fd3f9f779d07437c75f2f81c2a49512cf84c4cd3e1488e80a936de1a40e0682fe6bbbac82f8e83f6fd93e2aa311b858bd1e64c6d1da4ebce9b8e6c8e85024f23f403de6d02672c50952c4265e7370723a8fd5e013af2fb8127ed72139d847af402350a121100b7cecf7b11a0c68ab194296b4c7808ef1dbfd30570b98956231e7fc93b2f6dea59fc5b6d9fc2577639a1a10e102f29ae88f489f8d14f04aaa76d6f9877a6c0ce92311d7f084f8bdb9873f673753ef090b64971db3afeec3c3fa049071946ba04918663a9e89dd557ef814fed09bb6b89031ae183776e4b877593cab6469dbaec628946ed90938b6bf47f22179519757390f9cec79d10d3eee0ded657ffc0eea5a431c2e12a0816520774adedff58b56f5c0c39f4e27c824457e41e50138817cb230c2d0780bae64c571ab3801a64a2b81b2f1edad6376542d6c46378efd3b4b8f1598ee89d6fb07620b1cfbedf4e0e888cbaf301bb7ad118d9c87c790b9cd5eb87ed22962b7c5e76f4b5cefc49b0881e9c4951db2db323e30bb36afe009694e712ec4bd40a0b713036876e16a79cf1bfda54f9cbfacb7f7b03fd0402fa991beb85a350db9d7af47adde90a878dff6050759fabef9647f7f0063d845249ae16c303ff4f8e136e270ddb4bdc8d64f7cc1cf8be55f49576b2e3169a0c05417e2b4a6c2b4f35711be5c6e9f2e0473d6ac96b04e3a423fc831e427245349bf5cf43698e456570767f836d69177e37e89cb8e608a12123aa3408df9a89ab077dd4cc6351ddc71dd5757b00291acda963bfe3691a93a0d2811cb96718f3fe4485a762673813f27b8522101bf56db6a39a456b1375cc8a4fa0f34f36e827f8cfc69070f76901b9e966599c2ff15df742ca600a9fb948116440cf4f2d62f460a224f52b41d299badb811e874dd7821e60dd26b678ee53c8633c41b973bcff8129fe35a86a21d72b5b3785f50206bd764c26de6c0cea690c7e51f28120f555ca4ca450e60de2e046de13fad87365d33c4a01a80180c840b31d22ca59ade2d66758f9616aa935603945863475b783b5ceaf76aab075d375d23e4a66207baf4f98e8fd6292cc8fff4bd56e8c3b554e9fac641f8c5ee10c2f967a7a44b3a18baf30c54ff0606da3462ba62cc7eb5cf0382c3ee9b7b8740cd02a94386877bc36c615cd693ba7178cd2a41e1bf7c57303f674e94e8a716f1b52a8e5c97fc1fac0dc16cdf55f4d7f09ea77d11a194c2ff31e0c7aa98590b4c93fbb52949be76ee753308d133be198dc4072975eb5c52c71f6c5c9037d8478f5d7fb5256453bae2a365ea865f776513f961919430ee893d24add44858a6f7ee02ff19606ef5c74f6da4726f4784c7d4626341134510b5253fd43d2d773bb7236f52168df7e7a40cd9ef194110185a146e9c1008eacc2a19c6f6f18159aa1143a4bd08d372045f5a2a899899dd5261233b38b88a3ab17cc56da2f33c6932a3271c420ce429feb0deede84421b02227a3bd014d3ef27269758a5bae0fec9ae2619cc2c7a3b360995623660ef377904c599affff544896e9b8b3eecc9504c65c991cfb838da66dcf2dcd1bfff7205a49602739cf8ac094a98371cb3ea7509337893d23a58ed96f86d548e4b92e965bf7ca993cafb470e120be9942e4ab20f6916b7c7c770e94bbcada812dded2f56b9c560a56fecbb13c3a0848014356064f355405c2a69ed4b2b964826242f28a8552150efa6f8e95946329b6eeb8a82a0be0c375bfd4b3ec55f703755015766f9170e4e3bfd204cdda89906d9ecc50799387235b95b3bb1ddd86d44dbb9b8015e518e626d3441498c08d9c981f56cfd128dd4e9a636bbbf33038539dad405f51e7175df225c7504a1d14c0b90be0103e7f9f557356b6a5c8dcb7d3d74faab60118c2068f857d4f432af6a84c43f8f96acf4bff092879ae2274f5d6afc2e575be91fe3cb22c285bd95c73fa5d87540feeae6304d61739faa9ba45af9a88ec3c6d2240a39e385e437d65ccd4f4607f5d29cc35f8ba5c031bea150428b8ccbc7e2161652dd4caff7c35adf7f98869657605d8bc7c7d7e7910b1bf4c447d64038e18ed6d0446b104449dcc40992122ae10fa2181f4da356184fc8101db8cf4011e715706e08d7acff5e69587fd572a42cb141eece975bcafae23ecb7a3ed36c0737c7994c5f4014c1d5070402b6a9c0680bd378ac130269ea8a285ac171c4cfb01f7747f72a3c8e4c0230cfa415449532df00bae83ab9d142d2f1e3e604d219902393d9dda57b737c859987cb89979f065c904ea1c14a8b785ab257949e756c4a8a46a97ffaa4c8cb5ec8a7fc7fec739a862b6a4c018eb809b677d7cb77756923ab62d81ced96d32483dfbc80d773c2a8ac0c7634f24ba2a323e0d6970d1a05faf0a904f2f592719089531c9fba7abddc5e9a3f6aac3fb0aa3421981da7ac1f0cd8d4506c3b684895dfd96b24e22b3ebbb15a9895708a8da0cb059456e6d5df939372c2efa3a7826255734f24b5d045d72cb1275d195690981a9a9a01c51ba27ad1402edc79a5ee9d30088636a39d84e560eb0e8af3f80bcf0fe9a2a40b2e5b3cf5ea9121d6e5193f614d709b8909169e950744967ae0a1b86e0c6999eb23ccfe74c4df6b513a468cff293c03e523aa020d734afe692a4afa3e37759868af2b35c84ea00db31198338a7c78232718cce3f90a7dab5818025a846cb7ab96438bd36b0e3421da26f1d18f238d31a9fbd07b05def5830038a8d7f1ef446de36f382c5d077190a728bd0f616dba48dda44e4446e1bb5ff7e2c2826f6b55fe2a34c0b211c0ba79ddf3d1f27f2d845fcb68dcf8ad3e37dbc29dbb8f05dd8a4b121b1304938b61f02811787c74d686f2693a54342a7a0fe143aa3715df5580acad57d92d6c0c2f7a03270ab11d65f7acc62a392ca1ab9ed661de8005a7e2a5a6dbdda6faadd5d832eb95dd7689cc8a8369d9df1d7e96dd27358e154753eabfc85f195526fcab38cadafe87d25b869747a2041876d279bdea8f6032e7312de8f30347e5f5fa353796465371be819dc5a87218357a09684e6217425d294b8aa674a28262df3539dd3406ba89d50f6e64c2046ad54e6f406a9a802c12ebbc5ffaadb2ad0c7a8da532d759be6833673d1789d81786b0fdb1cbb13b2dde060497b20f7bf0275870b258aa054cc8e3ad6619f9cf4ab84adca4caca9dac765648b58712ca7bd7c342a8c3da4c800d638439ea8818b9a74a6b8ae3ca73007668f8074d93a5d57ac28efa2c23fe74ce69fe6a7911923957a526e4c288968da463b7859ccb543077f0bc3a6db87f70435e26ee8913f94844b130e88a8a2f74ad37d5c9930422b0b92c33a7013d180057ee3cd5b8153ea92cb8e84e094802f703d2bf8100eb4d56a981e34c771278930e12798274c0567b3e42e95ecdfb132149f0f1e09a56f88a357c2d2f5be263d42761dc4e9bdad57d1cd2145ddac5fe9c543358dd1d31839ebc732b5f123b2bb6dea92679ffa3ff1aac64978c830be8d03cfaebeeae259564b592dceca1110158a5cfb408463ac9da68e312d61861ed5a25cc65116625a2f4a2800ba69176d3c961e6a85c5d5317b455b6877c71fdf9db657b47bb44fde15a5bd55f54138b3ae989b6ed3be6206eda3abd252d0d5b390b128c729cc62c69c28bdb1e9560d7dae279a96524d714f862ce02fcd0c2cc790633674c3c22236b2ee8443ddf2c544c66f2f2e2bed3f668d3e4586be90bf550390606d20c94c96c90ab6b85aebcc12a2a1c52db12bd2e068d1b74293689a59c4dfbb665c37c8266b5a0b5df1b32f658956eb9df301e939dfd9e4459919c70f538d7c9e0ada37ea5e733010104171e24c978c40314bc9f98c920b2c17e6ea258ef2a26f9ae66254e28dea5c8e56200fc4939fdbf25710aace1a498837a8498be4f786a89a819dcc00121f0564e86c8c25fb2523f5f94f99d8e8015f98e45354288ebe57ff776e4ddad4b7c0350132faaf2ed229977d103920e57446ff160eeed7f8e61c842126e3ace120717c17ab5ffd2a02569d1b890e114f1bbdd7acd465178b7c46936ef7ddb76b9348d269d2e02ca4b82c315d437bd6187e9d15b8658ea5a909cb7f12f62c5d6482572179431b3bc225684a8cf8967f46cf404a9c5aed415dbcce2ba1db5d020379106858b0d75b995c12f92a917d8848a19ec03a9a4d83b3b398a04fd144461fcf9a99e60885578e7c20bb04008d787de35a537e063b8a95447d1ca601b32b3b8de8ab3c966366ff8f639dc62adf06044d5c1130e81f11f700d41351c7288567c7c3e343e1502198db659b4f8186fd7353c8665c0cf17ccf78dfaa38053ff34d2ee1effecf7e6c113946246e08e576b30698cc41e7cabddea37ef1137c13ce0dd9ed38a9ce0dc8e27fcbdaff36d7b9bf98e532472fc5cef14e97654610ce868a25ccbe2e61fdde47e9e6bb70fad076e5e0f0e04a60fb7f8ed3540d3c5be452b803213f2950f304a041c0e77a97238708597d41c0b0dae6d90ff476f70aef96b763e74e36418b248177560a0f18095756858afaf4b4fe8adcb6fa4ea473df5fd0f517f1f8818c91d4c4a2c434c83d3b41a0b5a29438395a9a0dd8ef38cf6578473654d853eff808a24a5bba7f846857f28b87358417a9f20e6dfb5bfea536ba30da849bc44505afb077682eea8249e66571043d289afcd44705463745330c0a4d8229ff5eb3a7babf44373b86dbe539117953ba1aee17123fe234319c27094428e02a5d2e29c1e92652c22783b3658b68d8848ca037c845a41621cb696fb231e97b7ddd91c7b3412205252631c16bdfd074cb128a096c002db89c42b5e4fbd44a5e95691640e1e397d1a3f3ab91e188c78aa6ba7ca336ef83b5cd5b677636c025095ebee13d35b13a5ccb9d9e505d70fcc2cbb63e3d64bc8d4d296656caec231c5d85bdc1a100ef4d913f6f18365070fc7beff3f98c578266a08635125993e1ca4ea8ffeb59cceeada7336ee3ee7b99fc40f1e7adb9dd21894472177e9042303d56f0c1e770aecb939c358ec66893b0fcc7517185ab660260be3c21b7cd025d8fbf58945687015a655644880f6f8771a310a05c89ed147242c27605178e95c7ac02a9a13ac02d091d065193e5aff4009d14600199687f27b3d6fb60830c0bbad35cc07586bc5fce766042f16959d4faba907a0bb2c1a3e8b0051b521eae712f22cb85891410b50cb5b76837f004eb57fa693e9907d5fcd9f8bb6e0067412dea4d2851c971678199f788408a6ebead01bd3fbd8ae6e6b436ba9ab85d6e7436c64634c40989363eead3da032eb502427a175962fc5b607c3081973f23e8825da1e0a8460ea84c1b7327ada29c15103b9735eacc8db42a141a1edea22123ff97d2baf12e10eb7a8304f032e55cb48e312f9fadb660285100fb8e6be4bf2421a975be32bf7f66b0e45b62991b9f1f738ce44922d5ef414220e2ffba709f2703cab8ff9a44a2f5bf12e16b5b93d29c4d443c4ab32484b22b13b3c4a96860c3b51bc07546a94e80f1a8ba005796750db49fe99a35928fc5149df0fe1513d642a200a165f5581b670e02e92177316917e42a3070637e4588118af7ea631e0be98bf81cba147a5ee26498efa56e65ab20caaf40f59431e593a6e98679ff1c8b0c6793e892f73199f097ebee6b9e48f0bfc94480a9e6fd70a44a762f734f1e64f85e4e97243238af448848a3fa5960e0b6837fcd75943ce486af7c82320cd7085076cb2faeeebc56f0ec49ccf3983ce4ec47f881b03bb121061b8dbe9405c20ecafa2885bcdff4181592cbfd98e8469ade5efc8f2ff829edcce22e1219555af285308d0777474fb91e2cf92c4ded41658a839aeec90409027ed1c6191a7f68bdaafbcace587292a267e17fc6641a562173ef93c121627ae35d4af1c24daa4e419a6aa1929ccdfb46c7d11bc7ccd3c763462398c1a00a845ceabefd6e3d98a4cddcbfe8b50cf83157d6b5a1c81b177e716d9577cb037ef7f47aed56e11845578530b3e3badb201802abb84416fbd5b96e332f47edf3d1e5de5885bcf258d9e4cb3f9950fd8c4e8cb58be2dacd116829034a549bd3320385df4d1d7cd0fb8f9d29f24cbf747692d5e9e655b99383a600a7548074a6b23c9baea0ddd77755c572170b949651b4a8c0ff82f6ffc6b7f370e055a444accc8a947846cbfe482f5a50682c72db3e802f50659dbed00f84f3e6faca96e8de9fde5c4bf44de1b51668d601de59ce8380c8cf359ddac4d180e08ceb64055c489709b161081e059a829248ee349abd67773ea3cd539ca7e0192e8aec54878680a9ea171f69ae81319ca93e0a820b6c65d54a7ce7cdfb0638d5529a417b06cccb716a2485232de7eab1d1541ebfddb7cc3e854535a1dc8b9a415b12fade51c2b4a2b4858862a5b3bb812d850bd1a068a5d530ae90c2299e938a854e6f00c34a5d2574c31348448f8f11d6419b4175a8c7c31101de7ab7daf2f1da18cc3342d8e5a311caef518942a33b276cb0309c4061f44166cf4a02c8c63e9ac279d3d3b9348cc79a33880834b847d40cf8a7370b53b8750b2c2fc2038b50d8b1566b43b4d1174212f9964149051831b584573a8ac6f283f8ea4a03f72e05609bd5e85790fba3f6eb448ef2e66c2651110bee5f6c72d9dee9758b45c9bc251a389eab94dce57c6a3a9c6e39687bafaafd761acc2b91d9a701b79eebc5f9039117a13d142f4efbc2c87aa2e08da7bb4171f9d88b733fc1a2e36f2503ec790b8a0d12951c13b5cc7e9be9b36f8464866613832eae084424cb54a7e1a4827303d1c321c84028cf686644a06135d881e27fb9d2d5af681378fbf5ef25fdd7b41fcd5be0121c753c06c45c03eef0c6fc78e434ae6192148303daafcdbfd854f2c9361da5aac41cfd9cb575f1e2d3c1dbcc3f9864b78e707bec5f27b2948d604b26c1274bfe2c066555411414ac250e4cc747ae45c7758b0cb84b8f68e346614ad60715edd4e166faee5e6b7f341ecb5a1babe4d347e0571baf1faab536ee31e2d9375f6905bcf59a12fffa9b1750611478774754a19b5fed407a3ff4ffce63d8a3efa8c384cb62c6394c54057ba243e7b3270a7089fff8bb35840cbe94745e3c18fee8298b1bcc7d9b3261acce913c98ce201e52687c419f5b3cd9ecdeebba49eb228978cc32fc669d07b22e788c75c386b8d0873902297161ac8e148836864c3b4723218d530177f79f33dac76a305487989e9c582d968b8d23f426b5b296fa2c839123eb384cfd9b2f56acfe5a985b2cd85299aec68782fb038fa617f50207dd3ed90614535483a178e3ab1f9c9653dd561eb97994756d9254f6304b81d9cb85c1beac5e857ab58c0e7ee94c1e0192b1433d874c73b109924cd4adf8097ec6ee2bb95062208879c8649d0acb143d42b55e19c41f6ceb8d0ba99061958814dd58f870d50e8cc91c481bd58fa198ba5a925ec4c6312e360b5def33f000b140cc174779b8855e424cfeff1662b6273a9fcc8ac5d200611cc75539554715a56e6d7b4bf18de0507892a8c3ee3c66e0f32859d4a6b499b4a44f1eb99d37dfd32de9e2f971bdc2725a1d2de489de577b37570fd19d587bb70f18efd2fbd18b16e77bbda98eebbf2169879c894ef69691f0c293fe3eb10ca9f2625c4af4624efecdf88405c8d79d19fef90f2ea638c6d64313cf79727e224b6b8ae93005ffcd74a3f0009d4e9871fa093fa8b600a1bb5f840368ccccdf03249ab406f37becf79a5d44619065c34f6f7260acce62b683d0ba8fbef93d34351c138a9003e836af9df6b91542287157bd2046e9a389bd01cfb7def87e723bb5ce122df0f45e89b5523d80b48c2def14829742dcb9af382903d5232e2a1a3b52d48c8086d3d6d87676ca62b055f3a89e21cb1ad7eebe5b6d1b3dc359fe88a02d25cf304c5eabaa19997d1710469480f02e917cfbbf47ab0a2a78b8cad37efadf9985124e58e09b9c083de89b59e0b75594fd7814bbed00ef1a781468a2bc9c14394b6aa657226788993930c0b2da706aab6514dc556bae0b973ac0da122e9210ceadc668fa3686f969fcebdecc4b14a2462b832ec0e8ad2e3b1f6d55efd99a27c64dbe8f013805262b7702eab74a1e65e70a4d52fce4475593682df99b34a9f00186f46f3b1a06482c5f4fdc2a62b61c2d155526f59f11739356d8f9bfc722972b1238c42f34ffcabc9cbef55b9420decd23f8c5b75f2ccabea13b0126a7dad2f6213c109074a25875530b1eaf980dc274d570f745cf6c5d07b561a447b571e0beb55fe41cd57a7081ee29091d59fa7bd089e9e8f477db78c4f1460a200ec5ae09de31dc0689969e11d4a78fc85aecf8cf8a2608c7a445e145c2832c418d6e945f364de082ab32c611f40fc48d719b7f48ff020af23a0b7e1f6878db841936d6069f5188210b947cf22a3abfe319e9d8aa9cab652db32822da6355f5d1d5a663cedc6ad6dde462b3dd151121416607c927a1e301bc5c6bc94d5ef094e3cd873c5aca670897d57db0d00fbba2f6d34e8741e1ca7f777bed695c6c0cb9b1e4585543ee5f5ee547ec12273bd59cc6d4b7e522ab360a1a152dcc13a69e8e4a67bed3f66256fda7e07c4ec9d601e4aa37ac48289f379d357f9f74c377054d6c1b7f3a9c53e6ba9dd41514460ef6b71b78d3cd4c3aca5fe3eb13636edc4b6a29df38294b22aa8125170c885ea3a2a0735217e584790517d54d22744d87534cfbea176382dd55008d011d5a546eb99fbea5e0f596fbd5af017dd1a397936bf5bd8550fef0b96e17545ba095e0b8085defae8f803bff396013a0e832161bbf0315d70f2bed93442708a41a2fa597c8292af6c33749e20e9803d614e54bdd329922bd23cf974d191f7663c6d2243aa9bb74d36b9164fa505c0f904302e986ad00474c279b01439fce0a6445460f7e954d0397da56fd31e2a11a84be16152426a3bc2dc053eda9c4b614d9af330cdada87ae9544f88905a99b9938fb7a008f991af1c48149a9d32b039ba85546b23ad8845627fec561da68991e2b221f45819fcdff0087993af1917df917597f2ce3024ea58cb4442499fafa3f6a02fbfcd3119a05eac7cfcf11a4a0b41132d5e4a3a6e32b631977f77c299a7494cb84bd83066700beadc8afff5b8b8d7ce371d82e5d76248e83dbcea47d51784e291859988c2ac79e72ebd7d514b912bb2a7163f93e448456c89dee601f6b1823bd6f49b1830053c17d940fe5bc1e4c7d9909e6cf0ad8015b5e624e76b4ff50258a2490161288dc71f9b2730bf0793c1fcba5299475ed8f8e171280d07c56cdcc2e821103e325c3eabd4bc847d3eaf4a67ff4c517015c0b8f85137fd30baad6f55c495476ea6ac15debd429f9ca62e98f3d76b4cf6864ecd77a668d3d3112a081776c1f3f5c92ca5096124fc3fd222943c67f0a1572d7609fa59f5f3c292564c9037eec26461234700f5ab718d81fb71889f92517c0de8e53a3836197e4fd6c56ed4702f4f3ce33970d6b11c8d47a97063a84fcfd7de037016824d06c766106e2fd0dc93f1092a6b3b8c5bd5e5081b5c7476c8a969c00d2b69e58ce0d36375039e04eebfb739e51dd4799c47032a3ba6f9d768e2afcececab86939e30f00fff4ed0075c42d975b355adbdb779cdf2f145984ae61053451febe25d46c5acafd2454dd99079d99a785ca576a6b2576499113e5a4ef124ab6cf5d8080146d09d7b7565c740427b8c41d7ee7eacf3f8b9c82925627f29753b732ec385567f0b2b561b429ec2368e3f3a404d3f6f691dba628a56e34f92fa397d7631a82aa1e749567864290ad62896c2eda8289559f357f83936a27036118882d81a9830bfab4468b99efb48a2a7b4915f898d54dd55b74e8fdd2afa1c82165bef7e6327211ea0970ae4e4cf5e30c610f9e1d440363f4dd71138946b1b9d9917ef2d8f0320058492bb299a90ee8e4d99dfd6e01f8347feb6e502bf0828cdf623e14b856fe91c153b6b9ceb3940f5d9e7b9172ac9cc0d9a21972dcd3c0b96d68a4c5ba23c41e4f9de6406de31977b8e0471550383e0ea1aca057b471426b1008ff68a36640d8009fb920ed39fbe4d021c8b60415e82f455a4a336e21433a7b3445fa436b469ff627bfe02dacf17867136782722c6d1471156cebff73cd9614a430ccd17d26316613532fcea5aaeb38fa752d2c9a8864784284c524386470022bc6ab9d0e5d6798936d85da2c26ed4908be2a33e4c0971282fdb098413079f5162ef173b59cb5ff1e9da751a5ded172c0931a23295eaa3f402e547016e875a8619ee0be30e62efc659c704c4874bb73e8490f9db4cbe4fa1ab5d77b07654ad2f34ac7baa10835682e85d362e7dfa71530315548b509aae2d670549439431cdcbe9efbea9ae60204a95947f7b27baa20ec40b1b0b834a771357dc34e8452048b6f15bd36771805af0bc4c2605dc5a791fa31a40914e675ad9005dbbbd2cbd4bd6d5e0bcfbb169522a39e04501b80ab06ae33abc649e4f0be9e63b5068d4f674920efced7765f14a5a2447ad0b337bc481977f7b5adc3b5bfec8b4658d9af221af8b7a210f7eb4579117b63bcfbb6d71f3b9ad54fbaae018fe8b71802020ab8a2821eb1ea9f6ee3e2cdc9da98a87d38069b49705d13f19b9098661adc36549975b1b09094c8776e38fdee06156d9206e754f0fff996809c41321a54c9c50fdb2866ca16f17e45ca208cb5d87bd5fc4620d869cd650f7d21f1f4a24cb4bb665e6fbb54c752635237ed1c1515a4f78337b94fde61530315d176a0c61c6d69ee14212cae85f4b9c478fac64aa2b52418db6dcc35095cf71b3e4d096f6ad7b1d58fcb179344f0fd09644d13465d4e737e375117ee5b5f1990b5dcd44514f7cf57d6f51809cbd2583b9d6aa082eba1a09542f14f3cda7602ea32056a54bc66c9c4e63dfbb18d54c121b516eced0b05403b1fe608211a86a978bf946706a3d9a59b8ce91da40f04982bb6afc214688f7a3d5064d0dbe1abcff94710030a8ca4b7de8f50ea7a73623ceacfbf2a69365f780f246cecb5a80ee3c7f2a1114049b0070ce322943c055ee5b1f8670933981158e0919d7e5dff918ac7f7ef82866738c8eeafe70a257832ec63a066162fa2c13f59ec4842b0578ac758237dd9bb4d95923453695eec37ece73647e173690c6fece6a81c508f73b075ad5dbdb450c49a98f16e4ecd832a99c7791e4518708cf551d5cb8354f4ed8658d513e8397ce4af63157bbcfcdd35ca5d5807439a039ad7019ae677a211b69aa0d2944e6fb4b39527f4489dacfa3b39b4c5ce645de6a149039fd143788fa5b32b8057eced68e02cbe0466fe8e9462d125fb7266102c5afc452da2f0159ee51b27d27a759188cd5d4f20520d01ea62e330e72b9a393649d4cf03d3dffd0365b1b22ba0c0425d6e8300bac7ff523a738aa7773793921da0b940b1317d11791a308d9a3eb2fab8a5e9fcff5a449e469b49ba201d065df75c07fe2781e53fd7e34fc1e5432d4e83b8ecfdfddc2b461290c34283c28e09316c1738d626b0237cc0386f03628cefce48a2045f404d058afd66ecfd9e678503b99258770d1fa8338efffb494a706e67b05de064a860071e8732ed9935e2fe571a82d91d761d057f6017cce25dbed9591aea16576ca72c597b3ef0366e3a3cafdbec1e295e7ffd9f6e69d8a377523c910aad351ae25743f6115cabb1c8c3ff5dad307e2401d4d581328747a1db86feb64c82aacbafc7cee17254ce0f5cb608fb246f6286201b9341bf272fd4968261edd4528a9c42178cafc326102bc96135d3699ed719a4be516ede73d8607389207d3489fc2bad3e77f729e9acb735bc71674a442525f22fef61a558d2311957dd7595bb022d6536e7ed96ddddfa3eec5fb1c6699dade3d42c2b9fd2faf59f60e4857087a9116ab5889fb7b6a3b20595ee252a3a72ffcb49c7c4c062f4fb4a1b890ac57063eab7c27db8b6234b930cb231d5cd9de0153fd480296c9e4c14eb513e16d36e64754cbbe5f1f42b955f3eb74617cc30755bb15dbe1c5ca127655822a9059d93953a249705a094692eae23e31f5b39bdfaf3fba8c6332d68c9ae67cbffac326c3bb37529b0a04d512743fc19b087f0f698309aa1ae7846813144a0ce5633b673a7baec58521d2a200d9d8301559924bdbeb986d8ab417729f011d308a9bab249f42b52c3fd91da9d0f9a956574afa1e5d006810893b2f8dfc57b39b7766e940033af229993aca7afb5176f79c51bfbfcc80448471e5dcea44e792e6e30e86a5d823bdf83fd785eb0f0d09aa59fca93644917b726af9b409df69f865f402d7206f156f9cf723e80adb9a1133f9835b0ef62110e4b85bbe78205089caf16904d9d5d9d4fce579f90ea0aa9969c45243a7e1abdb72596e72fe4c4b1fd2c514ef65aa33f5df06fd3be27e0aaa1f49e09f618e72163bfce040375fac13dbf2f55e65df880eb58eecbf89dc6413a2f5d57f41528e48130a881029973e5cb53dce7ee9a1b0169e02b5f58db1ce175bfa0c8c599255b0d713bb3fe480589f63eeabcdcc5bf5823ca91aea57a48369866f592101e2eb8d65967c7d300f6bdc5362c7f5e41e9e8bcd224ebb22545ae773982b3444bc840a475ce0b2d91688ab085db553730099696cf6bdde8ed101c14ec66ccf95a7f441154e9a8b95c505b43f5b5dbf7f063b014b5bb1e5c2d1d2c8641bf51e6b50f052384fd1d862feca4abd7b6c117cc2cf797dcc1acd575ed2f4baa796ecbae1e100ad6bc0e8239a8b7007cebead16c00238f79a8347f07a0cb4595026e1870647a2b4ea41a139c9aee46c3dec5c8172446ee211fac3ec38c34e45a9deab1527caca5ce028c5866a4cc01732ad0a091ca0971eb28d9e0fb06a04e945d53628936a459c6cb034bbad87f390d0055e5beb0eff4da20965b20cfef21b72dd57d056edbebb0d3bbe455b0f903390d47ee1d57cdf91ba4678696bfc7759ff9a9cb59274c7b78df6b6523c4c6d04805e52bc8e4f808ae0244faac282278f2c4fa0a42e99d4934af4960d5f247ff865d2995294729c262ca18e3a47445059a9714f9cdf80d599f3e3e67989f7f33912f2a1a1808e5673996f9641460bf95df48e9c1386fed5f2bd578032d9ce7047a1f777f2fd4072fbb9f8b76346b9355546877a5b71ff1ce5ebe918293adc3eea7d9af6591489295e89f490ddbb148434778d84dfd5d6c9bfaddb6f2a53f3a17886ba72cf2f12249707d4f9ad637d0392a4f5d715055c42372a4ebde74371ecaf1a2179a5b0db4b74a869b0c4a77d309ca9398cd7aa70b10a48a3b174b36f217cd9d99c3b071b8af5e4d4897af097960f00e734b1d001778df0c183cfb89e589cafb484d165ed5ac19308fbc00138c69623da6f23c2637a1b240418b14757e4837f58c2ceefbe66d4c94e66d094c3961ab6b00a6fd387391ac1a47c4e02b2712af8671510d931563f255199506db2bc2c7e990870995dbc151a72fe1647e61aa8e529098ee3eaadd529230425fe55cc5a6bd51e38d9708ee846db858ffe180d0decf7edfce428be560f25fe068eef8fae9aa3cfabdf080b6fdaae481e0d8b351bb20bbaff510675dba5c3743e1910bf5da88738e4a8d90a3762b342da837e8d633562798d56df1d97c7ccb5d69a381b17337cd52a72be0f9dbc8feaf8dd79cabc9b0d851cd3ab2828aa7d555a78fcf8b41a29db70120cdf54e7f9a9e6ffdc4540a38b2f4b3040e73a81e26bf7dd56a4b24851d06286d5911686667f69a33bbb7316bb57f2a107cca17aa20afbbbc3da35470b1354eacc093fb15fcef5f229b20f8a6b84f335a44a266c50dec5711dd4fb1b4c1d575c61d329327866c1c6682e3128e94b97bbee1a73121d234665d7b5e83686681524a71b55570ef57962bbac86a83db4929d837bf394f43a73219afe6e95f70ea2154845fb95c2dd63d9a307d4084dd8a7c2074694097d83d9273267bed9a1329d04e201fcdbf86f7245c7165249c57a1a40a6eba23bf7143796bd89232d4e6daf07a333422f83ed5b2ab1ee82501da1f47c5714afb6c8fee70dabe62c971fa1107c71f38beab08a4e2d5ce81c9d21934c485124da026d00332969c07d829d442e2be6cfc9705bd953f74208ac012116413d8da63dbf8cc6dc778113d079b9bd17e6f95fe122ea6038f233dc5085a95784cf0cb2ac332edbe4a11df800a42aeb59501a90c5997905e87598955e6e80ca8e5535cd697ff1ee3e22737bc10f754e923a0f711d8469d65131cc787a66683d8ce201c92927a86ba9e691ff0162723da53cff286f6a86d977fd41710d0711b88000ab5b6003325c21009cac2c7b59984db0a3c379e4e45d0fcfb35979893718714ccca722aecd2376f90631c5b2be426f8558339573098b2d94b088aa2a787d3ed81109c4150d1140e75b6dffba95f2b91bfdf1e1be23601473a6d532f94caa66b334d0fd852ffca0c69cb8678a7322c447394b0908e40c59cc418ded79a95f095894db4dcde5d92f4cae23a36b0fc61b1d91e9107d212c8eb0d55a0c04a1ca1a48c7adce0b34634bbd7e9f7ce583f7a0917b064d80e1ee140a80ed812fc96f1ee5c8efdb24791d2dee3b2a049005b961f46087ca2eacddf6f488fff0bd5446f058c0d0822360d3fd93ea2d702a7c1e496a762c8342d152f4e596fe321a141f228b406333bf279493afdd3497658b4f888a279ad76ef96a729d31671a964e5a097dec0d455a902419fe0c69c00a48be0fad340f792590b6c6872b09a97f960a5ebce5cc62b84ce283d2f70c6d64b506d6baed2aaeda2f0b92a4b1467e840ad2ae489b9e1b1465134d37eb43fd21bc279fb1f356269f2f6698e6df9b86bb8ec7608e500c65fac4ea869f58501bfa341ea0154bed66513cd1c24c500a6594cd4a4140844fa4199ec3d42e00cdd2e7ece73164b177ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
