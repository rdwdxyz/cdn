<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"10c9bab4335042822e43d454f776fa01a86c66f84ab1a4d3afb46e5fcf0efd208840839f508394cb6b64bc32cf9fed46247e04f1667799fc3a248242f696213b1bab4f374bdbac8858033c4a9d13ec6012b6a314f1e45d665cc92dbc6b11cd1d203e05403f993ebe6a90143e0923c483246a61827ee6f454166b905abc0e8819fba223cff028ab6e7f8b452e87c2e0c8c3feeb4ecb8388f0718db3f1b36ab4e2ec950448aac59f5f94e6d04571c812943173e62c2cf481d5ccc6c178a29746b8797787a168c1cdba9c62b1de901a2ea9d3de7f26f271e8bd77cd6671f43e54444b60997f81213cd878d72fd0c28896c3e50cac921045f3fdd8085a2a934205c41a3c4c14390c16ec5fcf528c9f7c7d8070d5f250e3f1933146bd53cfb450cad5e68b72052b9e1279fa95c59caaf9d56e5b43c06f0cbded9fd6d10051f40e067e1e148e4e3afcea535f42063198a479153f426de6aa1068d7e5570d6c80693680eeff569ee0a1b7591fab7cbf760bcc695c960068ee27aad682fd8259d95e62909ad9f129bc7d14b5bd0e53707431d1652ff6d264e2cc9a5dafe63a3a7adb9f16f5f259174d3d8afe35e1e5460123da65118fc1e54ac1c3238e28d68d29570d0c14cd2263f3a78a78f868e68bda6c3cbdd16e758d7b4da5744ef8538308f471a1053cc040e221a1b1da62c6c908064d775a4a7415f94298aed96fbaaa781159d141f7e7aabcb880cc53b5d54a244d3cc20478de4e7147546543a18ae6f4b86060d9037adfb5e273a8f01b5ca0be7e5b293cc79f6c3b67abc69da9284fea16754b84a6970aada115d13ee824ad240d20ce19b64cff2a0635bcfd45577397b036bc2db460acaed54bf44cb67ce520e20f0faf5f3b8301d54e8081bd3b70ba2effa1dcf7397bebe6733df75c7bf43fc3a9ca1815834d56a8b52e4f939c6e02c08db21f50e436d3c1e97dff87930176cbe21a0705c7e645c80f3776c1832d44b297932ed3bcb7219731134b30a9ddb042997d5c3a2f96f8b90aa0453f10a18e0c38d1d7a04e3fd1fc09ec3a1a9971eed609fe7e907a973250e5daf9a30a232ccaf1996e332dcded7b16d7ce96ddf342d8af9df477a1fa6bf51c92b3aa5e054333af1e96ac80192728b63d22044e7fd9b490ef8248af2c7c15ddc615c666a81d508f22e258c4864a28d95b983e41ca38827316c632f647189200a3748b33858228acb833c1f84157bfa5a449cf82498e57a64bb3befedadd646ed8e06aa501b2499474eea9279cb40cd2648daf81275f76cb1fc9ef4d28783350a8a4f6b3f84715b4e598bd038a51a0ca17441b1c40e8fe62441298949694804d8414fbd34db5e9b51d0810436dd158ec098ad40993c893e10d5cdf2e404db7e3334698e198880fb6f36382a8583bbcdbf564198a495f36d7fb86ce0731e01cb3b824a44e34877b266503a6e4e07d42c3ec62307c4d73b76b171ff1e429bc1af4c46365df917a15721b189178a996b01f5fe217539ade1fafc2436da5c64f0f506d6ead96637b643fe2d0a621d7af3565004b99844acdb0490ba8c3dd9ac5c7052fb9184d1998b87636305c275935a28de17e2b014c3d7f589eac5fbf6ac4ffd387f3704ce984cfac5adbb25a07fc2287d3b6cbfd9fbb2112ed8101c1baeedbbf6d7faed6f5b7efa4296097092e987f310079df88c9103cac39bfa5a1334e5ae7facc8de33f61613bcd9d056485f7b5e15f4db3bc7f71e068f952354454a7f9db2ed6adf3014815daad10cf0ee11e0662b9b10f144803f647329e5d6d6c51ed89762b4e0dcb89bfd4d08c1abaff2b635d1f3ab4c1c992a04b56fa49dff6cf92f6d912a9675ad7d92d41d2fa5b7467535156fd6f4bebe68abb41662a3e69255527ad238868dcc0bd40c935f658b2985f834216eda7e8a6bfa0ad0aeb197f871c5db56279f6149d73779eb2c87e26bcdbd394dce99864c75b72892f54ef096289cf74e1ea0d7d0b513d719b059635d0f69e72be190ff5ac9354c2240adf9caf02eb62718be66be152a46600c6aff1e84885c9e0c399f715c335d8ef5c0efbf6e171c806f1f3adfda42d6894a20babafd81d68b7c0c51c37801895d0da4f70b0c6e1aa66dd6ca80631a7d15172e6d15485890f6296c33f7f10ec500e3d76fc5cabf0f14035ac3ad02c4fadecb1752b5c2fa79fed1e41a9bcb831377ea883752ff29cf03c36f89d466261ed5982217afaa1082c61ee9278a40fc9e263a7fc61d249568a408a29535a17fce85575f132247678153c6b8f63baf99ad35a0a9692d78d999f1463b3c599d6829a9099d7b8ef1518f30250926a5320d6c997a0d4ad03df4095b2df1803e6f7fcf917c5baa25a7ccf3340892e51f4075f85df412a31606a22ea8163cce15990e4498d8687fb7766692aeb5b151d9eb1056f104a6c0c87f7f75fa62e887c677d10b51e5e44f6b2e1ca227878cac44b192cdc670aeea7efcc558bd574c53564158634fd653d37cc71ffd2b79e8b5ea2a1cad6beb4dc0803060b841992afc4bc0c6c4261185c805bb1c7289d54030190a578c21e06ab65d8a2473bdc7de0dfcfc8f905aa543d691bff8a4bb07a31bb9d46c648f087a721266a4a1053d35d38eb442a82d0bde46816554dbe7f6ef558bef0cfb7ffc437b96218d8edadf7f1cb13ae54fbb35df66b5c30f75dcee1f4e9c18ad2ced69b4feb9b9659024c12be189dca9c58b3c60bf9c5581ea7e521a60f910f64834d479a97ef3d02fcd6968280cdc7efff0e5ac1fc20611932592f94f1bcf48b45353ab1d5b48f031e7adc1438a18c5660dbc738f99392340a1c9f55e2f4257fe6b2d19bd3b7c9f11f0c88ee9419336b83b4ba423385780bace33c00eb0ceed8e675e78ee63f5deb898a4ff5596266c7ae43ab095867a57a517c15d9aa15f45bed62e65367211679e3271e3c91fd905624465f633755c3ad3513315a220d7887dff6cccf45fce47b8a981a8e4b55137079a604c385b6b8c9db895da7c53bf9edca73d7bf53e1ea126f2b5cc839698aa311b2ff58d55ca1a9e929cb6ede677ca819737791ee94a3792bf2ca9147b5d82be9f8145334502a1dc10b0e740f3a51958c2ffead77723c766db9951bf3d792e56249d0fbff59f918ef3d48d60909796bbe4d9148cd20f2e8b111756fd682a5e6f8f9b74454103083805e5572357e7130729e2b035d2bc41f323ca3e6e34f15ece422832fcd3300e2431197349455e73db40a2e85f86ef631188ec25bcd74ff3527ceb966be796564d0210057b76daaaa416f08bc27716a91898c9e140bc0c4facebbba51bdc8f19d118d3810152d3aea69b6a4505310b06b990158a588ce4222505cd15f10dae30a0b58a8f3933d4f9a61d6b683109d678b6e4f72f6ee3b3a4cf4c24e8a60a5d426d4792d3cca5d9c67fc09cffad941ce25332284d89163f076ecce052e33bf59cc6de95e3d7d4c4c125ea4f7a59585f1a468e2d4abe65572bf219ebfdc4717a4c7804e42cdfdf2358be2c666cc36df4f7fd56e802a6a62083d2ac3ba54ed17b157ad1c47f3a87e4050e085bc0278177d257c6931d7fe60c8139a21f2e21b1b4facb85636df2e149b0316acb71c2d3b2a146f4665c2dc1f0258de81883153be0bd5efc1220ed5ef3f4bedc0c157cd5e3b829c44532b8cf447b21e02235c6e3db0793c544aaea43b9448e153e174357c4640caa69ba315295c2a65e24658cc2db82f4f8f30751120d130c3502182b4df6a436284613e1160e1f2918c4bb971d56eaa1f1d864ff2bef0feb86b29a98818168b3061ede22312b0f40a5aa8a8f7a0da7f89b904f7e1d76fb291a5ea4bc4a77b8d97a87bb5daa18d296c5199ccb3335ba22c52caee3b2ab3bc6d049a92b4b851db69c8cf7d8daf8661f73d651c3a38914098d489bd9d6777979f229da1268b720bb1a7a8df7733d5b78bcc4343ad1c321c239005add14afc08262ea35803e99ff07a5a40568cd686ddea3fb3604cbd6f6870275ca1e14bf98a18c1cd3babf672e762f4e13c6d3c83dfcfd3b97866285f96447640d525c63cd93776b8de3d9c76eea0dd3d710c7443531e0a860b296afd645953ca77b9b855776db1f762fe70a12d199188a05ba3f9be8d4f9a38be95829c93270e92f59d8977f12d0c44e60e4884ecaac7b525146e83e612c198066c4ca2571f950dc917927041dd3693181a6401da1542cf7c92f0809dda56893ee6eca799ff8321e3c1aeb23461ad5bb20613047c5d1f9de258f5fbdbb80e2413eab50ee70121780aaa4a32a817f47a89d066c96cf01967535ee7720dff81f6cb7575bf0abef1c1718ca4c333faf0ad9bcdc33880c2f6fc0be04c30c3fa49a5adc04a4089aa480e4673428e59d63c1560dc1d6079bac79993563d95fb8dc617d589c238feb63be60327cf0e7305ed78ff37f493f18effce1a8ed123e91611b121ab5c38c92263b40d4dd5e514a2b6202535f2de54eedd0504e5081128026c211252d68acd21461da258efd27e801e470b8e7f9ddf70d762839c95dbe247c3b0f17a29020a726139148e7b219f159d9fd38e68175077e5db2870330e1c4ec3c06187d40b3bcd51f3236b265fd416659058d5d74600d0ee52ad4e8b32b36d1d84495c14d418ea12c39fb8ddf4acab378dadeedd99de78a108c1657ba477460f6bb6f03132ab3152a723ed33175f3f4022064c1f9fd733bc7d02366fdb76b77f5fa3ef6e9120a4b8b57384cca6935c3ae21fd0580e1743ec2096d9c6bd5c6e4afa6e83d908a4c7593146b4427cb2d0a014d49f2c60259b12018987f9a79164c6ea7d2120465144eac2cb0b148d1515ea330f206bac484a69397454a2fcb033ab1d661fc5793a8b20bc6fbeb706b8fa0e2b09a44951381c6fed5f63902a338bed00e9708cce0ae411f82560418f1f0728dc9d50d08d0605da55d8000c8bc3ce4596390f03b9e76ae4ce35828a746088c71658675e3983f96a4fecb47b6a93b9d0e77005d863ba303155cda1e06d98fd4590567a994d94a7710823ee656ca60e46f5317ba2d13e582a20b5afe30bb0991734c40c58db546fa479115d5995a8baa5e8803575b83f79105f9ca98134ad8e743a2cf0904098d18c131edcd72faee1d179d6245cc52af8ef3f279e3e16faa6fab3ed6a93bfcdba8a08400cef1332d1a64a30e75c76d241501d0021f92fd22d39f15ad44eaa9fff53f1aef40804a0a8b41d00844d8174c1eb6c6129da3117f0c4b7cf8516fcb04cfb33b18f6b47c676830b18b288db4a18a8cb8d2afbeaf9dbac760a9d48db2be20b9de9c487a18f19ff554317cce3f239edc0e0cade1e217fe1ff9c0321e4a4565525b71e99d7b3dfec693b30755da6c37d71a242b548817d9c1e7733548d97adb613e94f84a4cb72af9177435bbedc537883fc9b02367863346fb34d69100fa85842aa53f29578cf4a4a40ebaa49cd67add48d9420359eae474bf590c95e28b1216ed22981f43eaaf595d68766a40a4bcccfc504f23f673a1458bc30df33ea089bd403a4373bf431a98b8f4b484a3578c64e867364835e7b26795245717e565dc0ec91c104c9203d39c1e3181999c3598f75d8f11996b9b3e91db1d643bb0b4d8258419fc2815652e4ea5fae3b517634c8d5a6c5d5bbbf9612508681759041696aa1654ee3fc94c1e8643af7ac1f2f99d84615711e49c0d62f7a26232ad0e85a7640953239402d24cbae113a8c96474059a6466055e4b7044783e08d422c64b361c67e8aff00214643842d1298b9e1f341968fcdcfb9e4bfa81408e0b5fdeb45852816b72c1a5fbe0b015630ed6273f3d44e7d52fc9c2c4baa45c6dcf84cb726b28fdafa6a10b0099e0d2d89552d9c7a664872edddb601045b999db5d4cfede98f9cd6a0fc30a10eddd34d35ec6beca751afb8a22461a80891a4099b1cb80a397cf960bc900263a0135ddf1dea48b6a614cbce348cc8eb10df6b41b7d0a6e61b229e404550405be31dd86cfe427d334606a1c45b62360a52cb083c7c967a1fec631ed2826305474d8fde87fa4dbf8501f3064b4bbbd550eeafcd411b98655abba207a70f8b90dbe3bb94bd53fb66e4242d4e148df858232e02d69a7ae2fa9f30824ff286777af29ef7ad4a460d74eb72b637bd6be749a3c58086f37d507b30f1c3a2062498c2e371c663d8f2feeef09ba2cedb5a9c565080ee4bfe72e08e09cb659e2198abfe7d7a1696a54207c3c31e664616e8b5aab80a1f267fd94f8730e067c3ff928c909d19d3d6c1f3d2d4ad3c55962ac70ec5784348ebdfd4a206932dffcffbcc498c4e04e55919c3e75c0dadd2ed4790b61679287b66a34f39ee5cb6454f9694c4bf0d6e3b6a02f9851ddef9e81e3ef425717c6cf4c3d6cde5617efd0ac465a1d46369c9ea9af029fb06171d0c335f31644b5d9061eaad993031cb1d09d9690dd4c817ade5fea3515195f9a46a4c1d388e475578340b5e74eae41cf4a8fb75fea50548aa8d7496dd874b33742fd9c9a246d318390a0e3f53cb4b5f77dfa9c4c897dc2f3af33f0c60e1e015349fae770d854e3f40b4077d7bab785cbf711ab5eb7a5c45213c21006fe7f5c9388d517215e8d8e755d462b5ee93d99a88146a8df745dd0aec5a840029b9ad8848e67611224b4296a50ce9c54961f49cbe4a154e1fc394cab3f9d6c3f47a6a6d3b55ecc6c1a8e34da94834b746e63816b7f2e506db961c98de19dbdcd0d2d6c97fed3f1c7583fb3d040381be9557fe91afaa1ca7da79d9dd85fd896605a7fc686860478098fd60e3e96c11a209725cb936f5fb7c28f731b52b5df207a9b120f4621bd8361c9110b960b2bc3155534b373fea9bbc7a265bc572f9cfe8776605565d093faaf39d2d348675ea4200ad2e69bbc8f1447b5534a859201582e7e257a212a60448a9d48dcd64315374e1e96e08ea53c0432d674a82381105f829e4729f4e0886a8951e3d2353d847a8a547cbf640766be9c7c0f05464c4d145093296472333c4b6fd34043fc0bf9b24c01cb10d9a1cd2af460c0d7c1ff9ff26707794bbdae5897e384b0dbdc8e1ae65b89ae411672a7ec48b21e11fe07795996c769a4d20ff4ed260d0d08338e356d65905668bee570011691dbe44fa4d3501e6ad6f5b798fcac60a4d8c247cf2bd5d354d3cf11af1e04f2d913efb871f3f6be309613f49a26d9651a6d986c9a8299b7c94002c1ac85a6a82d636be7947f049fa70409e92801b526da502e96bb8b1a30d5775e3dea4381af8fe1271e6f59f483964b46bd823acb3c6609c22c4454b49991cc7be77b86fb45f541b404214d8f1a3053f848414e6eb1f826fede25992e95753280c81b66a0924ccd0b100ce502eb043fc02411d02de158690919b2e188918ce6f93c782efddbc684ff117025943b1349b5106a0cb6adca5cfd456ac1017c455d549702ca6835924b7b80d9f0c21de8398c9720a35503d73ae7083da95533923ff4f03d8ea990d807fbb86205a667a106c835e73d187c5e5cc0e61346a4c85a73d1a4db7ea2ffc4accf2e5f9d183f56086807215a5e0eeea831f54b0bb14a88705600d1f253f589d41954dfc84e2d2d3f11659635f98a41fb4a05d2d3f68dfade2b8b7a6c52126a2ead85a3ebf30168050425f32811c2deac52149a1a38461a52cd87c95374bc51617adf45cd84b006e970bd1ab789559e965b5579fa5dfb762770757506cb5d5394ffcf729817c987c6a206eaa168b4f6b0b2402ef29c734ca243f259f678d205036b97c921601813b6afcca6ed7a8715e30d3e82108b2f6df6512598d0a8a2f346cad5c28d7daa82deb74deca01e5b5a800ea523bde0b781b25fbcab5416724c103f593d6260fbf8cf324c5c08bfec72ba41e4a27ce5117021646e442526361f8c1c7eda7841b30e02a37debfb9612618f70182ecb6dedce086faffbbdcae0bbd544970601fa21f0c33a013b30d1c2f7dd1725172449ce7726881b52100a38176322431111ad52a449c575ffcf9e64ec3c6c40cfd988d6e94eee978511d667801bf5c580bfe6d22cbe29e37088df9c5aa04995d287f163c1d7da653c2e3de168f737a47d34ba13436ae3f4f5e027c5c8432d01c82a89bc742683ce49a2e196490ee4da812e65562c8bd2d5aac96b1fd39ab7df11388427f42696fb8a7e7cface37f790047a672fa75013aa385eedfb199e7988a0a5834f7382528d64a8c0952610da5e87c02c2abac083aeb8590b163c9f67f061ad07d9a97079cad53e17eebb2830c3633641e01c7216c3e21c579e218704a0854b781cedf9d24d6638ca1354ff19635793346b60d901c581f5235a458d5977bd84c5b26d615a67efa2eec148a21f0011b6924e441b37f8bffabcbbfebf733bf3d15ae2a8b2faede62d9bc1ff0c38e307cd4c692cd58f2f9fefc44aa3ea68b080922f7692cdb92ba1e172783276a11922d5268802c650659ab0ac9882fd5c86e22c5c2361fdf8abf410f6c8598d89df76e83424f44241be435abe430f88a2ec299a52f8ea6426a1982feb484d6bec3b282cafb0963e5e420a8211a0ec0effb667f913408a70ff1fb37f19a946734b3fc19caaf77e679ff8762a2d9e739cb8dbb5a1535d18b7672499161a6231907a32ddbdf4399840448832669a730abb67e2964c979c241b4bd0ed2e8072281a71461a8598faf49ab1c0c460d032a433186553d9fa13773724f3fdfd1215e944bd696f702441812d116d367e9807b90c98db55075802671ec40fa651b5f67278b62a3754bb1a0cdecc0c8b410f85b3585c3eda70fbe28860a347db8106343ad304017265a778dd36f75c7cb2b7dbbb61aad4b2b6ed60d1f1ef7a9cdc34db054cc33adce86322fc935c4a6191dd580f6f3d72f79d054a9a242f7f32792666afc60aeb030f1b2eac505ded1469b8bfa5396b07c76cec218382a05f775943bca4e91cc680223cd882b8f9223728606200e642597185a16e73878aa08080b429dcef388bffdc0afbb5de444257704244fdbbe61d1497f6202d47394200a13f6f417521c9dca2ee05045cd994a78d0d815620accc721287368467ad52eab3f9abe61a4ffb914451d0d32a3f96a4381736d5d23de214cddd208e6fedba2ab69d314691607563e2dbdb9a3535cf306eabcebae2a617b27b95eb891896291165403a39a0459ed937d423862f41fd4d6a167558a9d6fd46c64025c7c4860178e8f1436ab1011eb452dd415c04375e87d26756598048ca8631d9a10f05ecc34f2e8b0c5c84d567472c6e3ff32ce85b330ed5c1447d8f1b8503bcfadd6a196957bea06238f309afaad4078ed5e298aba60233ea758184e3c05e4267031b25676162553e8aa24d75e36328853887c031dc9869c10b1affac42c252a40c395dd1f5c82039ec1d45a402a5366d36b0d3836e727f816850e2e18a0d225a76d24817d46a49a5e5dc45ad838eb346798d23f84f9815190a0f09c4d9906afe9e8d26ec19df2ce43178dc99e2a57493386647f03b21a9ccd170cdb5b272717f9da3cda0b8d5156edd3c69b2ffd1161485ee7a8fb78353d775259c0e6f479d9fb7e8eb49c1b6e948ed47248f5cd3815d3a344d5e0ff0b078ba2af1de5a38d00c87e87d6fc88a88ecf8f9fa7ba2670b7d0281ace18a5b2df305170590e294d2bf065c6839873fe3482487cc5818eee9a4963f002f5808756f82f42612c3c15fdc42c6e9a1fe88bc9dc90469491e414a39c45c6db566f29e51b5d27b27d57e8c885ef3fecdbaabcd3d43b47c808ea6afa7353a4bd27217e194864f878dd8b00b1ef6462b2210ffcc02866db11973c23abfd0aa9ae12b4736c78ae84005e17aac808dedb7de3dabdf89ddfb8b309183c02067798e28e39be0e905f175460af292c3fea19cc8a493f210e21076f9718f437f717c7a697db9975d8f12ee219d1c4249479e73a8c6810ee1b2c5aa57bc87b1798914eae994cba22e7cc58de24719a12d5fb85c40400ae5c9d13557b8f1e2e0ffb68807013f373a9d306062c55caf27a9d1f55dd32bdc0e0f686d7f788bb57b2486e0d60c1c3b6ab3bea9de5ae9419df3d5215e1bbcc493a1efaedcda4fa6bbd42ace6c76b8bff65fe64448f1c806a0f14d383b5c4f4e0b78b3af8bf97eb87d75ed5ddafd4b3e38fbf8206ea6a385c5829ec97f30c3ec6628d16ec84a770d30df8c859f8377e00cc6c746c0912179c62f79874e4cb710981b476aba1604ddb57a1919214a01104e5d895f5cf49d469f3aa57b682f1c62ede398fbe45133edcba4b7ddc05a2df48b18c516a1788b4d9ea3389db5eb28eba99f9943c9c71bdb618d12dca8059df291bdd2cf48498bd070eb6d3afd5a5804fe801166274a28785d5bc320df084282b30c8feb3d7f8565250716c501a0ea4e0c3e96ce644595601ee9101a068cc074373e20707a61aa9dd2515c532d939d96b7fd13b725c4b671d5e455a51bd12b6cd4e711cfd3232396a0b1943f02681b0b5284c08f33f87866255fb1c23623518d018e2acb9e2818ca37fe6d03a5f3c819d3297f9c74a16c6ba9e434474d3aaecb2fb373cdd7e0282c0832bcbdda19a138a6ed8f95355d981e6393699f9a5c1ca68d1a2d2f119268ca28626711c59d9203ee766baf6b2e5fb009309cce72030ea4e3a1ef144c8dfaba9ed6ed1d504df3ae6d5d8f722b616235df83a3e4af16b2eaa88ad0a5029b383a279e17e9ed0cd3153a4974172fe2adc6b5474caf9b401616223c8604df42cdcbb3562b2bbb5a2922ded32e2750516d735f8e6cb2374e3ab6ad920d05ce180db93faba3a65d1a9cd4adb7d40945ba9c40b42beb98137a54e9d641b42914bf61bc6897724fa18998bb4cae5f3ad534fb5e63a2d940cf69ae134786f4daba77ade90c25c43d5f18c10c1ba29b592bb8301b704b851e98e004f4cc485c86acec20363ef8c0714568a50d33eb680bf4c417d0ff9395991fc9a6831befe46f5ec72b6acbcf91082809ca63dd21d1aa951f42c9315e37076de820a41cafca355cfaff7aa51e04ed09e3a980808a17c041f22f01863bd63034aa9f48d87e9a7604c3ecac0232c289413824253d8cb7d84cd33411475b8161deecaade9cb26ec4cd49bc2d5ba4c082aa72acc0c3c91cd32fddbacc83669b0ae8ff4229e130cba0c83f836fe9d89547a0912f1c0f2c144a5cc21466a234b4b57f7119b2b2ef8998ce0857441ed526ac5bc86f6fe5bb4886c1393801d2d6874c7c9e70699b5fa3d0dafdc727b07d49cf0088489f0c7f157d7d0bf6ad71d0407786489ffd0a62dfc3dbdf6367c245ab91fd92ff42b24e9a5de04f20f3acb2a49a3eb5320af5cff210705793d9b688f789b05a30e02164c56fcf4e8b85a718319b4a55f5dcc24a96f0d80df4da09aba4b7b4636d163efac3f5e2d0543b7d6b83d815e2015c49e707539e6adfd47bf6a36b288f34467f91e2f8672f44b001434830fcd04c8831b378fe78c5262d36b7e6b9b2741c3963ef520132be5c973e6fe263a7fe38a4a3701f45924c53cd1d32dfff83242c6e94fd1697626ee526bf5a3071a3ce19f568b5586e0a48f3bd06e783ab93b63b4c85c226a59815444052777f7ee576167fdbe561ef733ed205f27393d2a940d5304444f1a91f952dfd56dd4ab28ac15277a285c6014cca6d9affbdf43158ef965ae72e659dec48d7ce81cbfdaccd94b6fc23278b87683e5732e1b9e00cf1af4395e8836dc2c6798714acd7c4fc1990890e57b93b5936fc8e74b2b335c75c73978b033ed5a0eacd5cfa70109c8b6274318041ef8dd211742762189bf1a7e606614206f30e762aae1e0ef8ddf396a7a48a3fdf12a9370614505de041bbdf348f4b34099425878e41dc7280681f1b77b7272dcb497f6c6311be2564473e8b744778f8e61f7d81edafdcb19388167aeaa49b1ec20164994a712afae38d39a1eca69ca3a23ce1a0b4a8eed3c27c46e076694118fcd912da44f90d4d8c4c49eecd6f2d03ac07ff0db8de26264ce95ca826d5544b7941ed8759a7e959529a02eee263a478ba92c81af873a4703fa13b56d738367be3a273c6abfc5084abac5a8adbc4ce0ef961081f9d6a369cb27c9f5aa9300b32cb78609d4085fd3f73e496c5f9a60bf693afe52e5de03e7ca94e11aa4bba79e33242e27f80b0ae2adc51207d0d12dc871a1ab66f5a07a4b7e3a552353e7595d07a0f835d1e4d58456ad527524595a8c292fec52d9390d2888f73bc86688c70929cc62832f2ee5416993a38d1b75e0c2a80619fb3deb61a2cd9a0fdd1ce7a8ddfaf86730237741ca726f7e84318cc674a598523af4876519af8a09bdcc21a572642ad880c7b563873840954a24649cd37d0c5d49a6cee0c2cb8547186056ac81ac0f41f51fe957568444b308053ba9f05d6f1f465c973aeabff69d37a6a77ebed832864415c0fcb3b7e6b681448b6bc80a37352757f9beb0efd421d155013e8df18249163ad101129bb4d32f6c9becbc441789848bbfc156a835675cae8ebee08920a9457c0ac76bed2e81a605b5da7641fb4363c32d20d43b5bd8dc049043026953a3343656262ee452868d86977eea7551ae2103fcb89bcf3f4bebbe69203089a93297e9ed6646dcdd48b6c05fa24b37d7fe635419e3227d393a5723fa20466795eb1f0ab275c893984880a0c1ccf4305de5b40e76eaecbbb80f4d3ea2ec9f497f2e16d0ff30f7c168acc52f90a47628af3c1c8e4d2d069b208b9e12300166ab1c8a13d8f5297fb2f160a0ac528f966e3739c64ef21f01ba133ae6394c0b12f384020a12c0421ee0cafa14b529c675a434130aa7898822e1135b6f1e9356c4bd88444d1403891b5766f5f97714adcf0fb1d71d2d6bbdf880da843b5fe0d7937389a34d75030fd25c47b8ec82a4dedfb7f3c69c391902d86dd4f835265ca3811fd0629359c1c6de90ccfae0860b2bb292c535d07bf5427335b86e10ff0c1a73da877ffc257c244a9b0d92e7df35b8e6f054d4ea40cc65dea22b5680133db2e42df6889dae2fc9b8bc0c31f967082eeced60ae6f6c790b02beb03c171e3f7e0b3b86e5be22981255d1362ec0fb72f9e4f184cf5e210762d34ab138464ee2593e2919c02abae95e955ad87e9d30296424506a5c8f9e2884d26027c4407f0602564cd1fc6a489d652de72da33186bd96d57d9c3aca0204c0c6017ec0414bb10fdbf0672d22016ad1e1446df5cf8c2e06b686baf8023c89f3426fd70062062e2b207aa926349e24505f190d05eb1fce94983309b487e9681b5aee540da2a85708020a872d8a628c9fef5849d527307bd6f844a5232033005464ca004d9221336e566251f624930e2b49b123dfc9d4f59bbbf8d8e3904d87b8d52b3761d12b11a9b28b7e78a4616d42efb1da60116daaa2dbb5eb92f80f9522dbbfa43909f7d9a474b061b11311dc0e36ec45086c655ecb939f40c8b86032ec0c279d7cf40d40b1f1f20f9c9101e677c447d9951e577c55575e3bdcfbbe87dc6b4d71c671b1048ce45a1cfe412c4b103fdfa62e45822278f071a5cdaae89f401a6db6d4faf4f35c7ddd622bf913dc60b6e0d8130889c50cda4c8d5e0670fa123dbaae01a7ebccc739b939cc068763b7bf2533144738c5a9d8d9b7ba667dd0bf2086ab44eca6e0b19794976e85797625fe3342e347c431d97f7855db247ebc370760c002797276a8e2e05eccb726fd52bdaeea05c5fc6acb7d12a65cae4f7cb041b619086d4a115db8e96804df46e88b89012d2b4033a480bc881bf2e5398d00fb0cf226fba8e7e19de9b0a897d08be2e6cec2347796bb2ca80e6b7861b8863d3ef2a91ed6034b1fe2f1548bcecfef6cc29c26d0aa96cc62c1e7d9824af605773ea8c8e0c8eb59fa31a148e4c0db84a6ddaaaf73c6db5a92046cfc0f25e37459694dd332599f6d26af07f6e277dddbdf71c97d013b7f0395fb504f0d0acc1676a9a2a2aafb345e293730e7ad46012e8c07c8185f8dbfefa7bbc6bb63bec68bfea59dccef5c426b3c0957682ba9082361aaf1412464c1922e26667d92677a488000b897b7881d418bf2d6e0da1e5b6670442d4c4dbece0ff76daf5168f3f7027c2d46b0c68ed8febf84df8ba67cb0158fbb3592304416d9eb52e59b18936a76b0950c9346b681de5b88bb3c5cc056094fc4430cc5acffbf464ccb018a4d88fb52eb84750db19e607781e8d059ca734694407e68e42803b7bad282ac8d2379c655776d2c8b5c31631bdfaaa3273672bec8e6374de3de6697c0f6c7d234846bab4c7d740a99615b1a5675ea7d99d8e55834e9c9dac8a10fe65d26756b39903b1283818521866138a0fd9645b2b321e97315c9fe2ce9a7eb17a75a1ad0549abd633d2e88e2b8966903fc82258378a619b9289649237f95b505c072aad5271b1a635002178c8869941217807ed93f8909f0da7388b38e41125457da3f4fac629e9134edbded7ac4c1cc0b9a817e5160af5c7b861475cc677939179a78c540d94d98bffec7eb513feba3029e451691935b20e45c959126f1dbcd2b2db1ecaace423544ed5d90e59000e09ae37c490aa5489b893a77e7798c3fc5c61cdf4f110a0a0ead9bb46cd41bacdf8e7e9277d4eb8753e480472770e76dac2a7f43a66fd402df5dd8dfbf33826614b7e752a8cdd67b496041df5223d77885495c3126e98f0b2d6d395df5f3c9f3c14baa027009d4088cafea113e8184a171f37c87fee4337b3bcf5c3b505d75b6506b006d43432b93c5a4d12ba7f4a71e181153747f2b18b10432799efee8ba91415ba6654ef524ba92c9d1d3e47af6578fb70e1edb5a99924bedd02a5a643df693335248d9cb8ea954c6b4e896cc2d4ade8b1a5dcd2c6ec7e0cc40f8995efd8eea8b6ed5e1d390d00a33e9d2bcae773d6c9193314fb508321f6cffd2d5869665768a89fe26179329c7b040c6a11dbd6e76b7116c8c00c28d6f1ba8b71d7f6d087fe723933b7754c38b7b798c5da6f5dab038f3f602bc14ad072da3552faaf150fedb23edf3780959cce3637ebc5de156e963fb7b917fab75756cb517de4e00445c024de89b0230511eca3d3b675505bc99ff8eba3dd9975ba13e40c954d59c068ec9aadf3809d0be538d4623d8b85b542117ba506dccd14e450503c65eb29489d9a790408dd9ee3084","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
