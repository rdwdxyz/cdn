<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"845392acaca864336b3293e1abdeb4c3eed400bc33ecc651c2dc5db53b69a0e36b6fc76c4c2835fd4290dd083f994fba823a0fb9031b3665976cd5f20efdad022e50e2d1f35b0773f616965c0ee270dca5fb4fe934b5122541065d2eb80c74b95a0a6c1f0afabf8cea22db472b7f24a5cbf9ed58dee9644fb9f638cc3d7fa72f9a46ef7ed7da68192c4f8ad9653ec27c94c12aaca4cac9772d2258a682d521a8a3d6b52c1edfc21742c9a79e628fb18303460cb86e4f76483927972378458baed1194516cf213072c44fd80ce4d94a8a1ffc02008ab2692bcddce02323cfb36aed5fee323da70fa4a0bdada46d5189f4c8775a64d431d471a99592882b92c9114c58eead58b2e2bbea4cd7a2c8c906189b6b2a07504530907c8d8ddfea31798c979be978f84eb15e43c518e18d7c81c740778985897787992b83c771b584f3405498505289145809f55da519a60b0f9a6693806c751495f1ea27920073b6c2c642d1f5d67858f15c9e54b207896a0ce9ee40f2d8b7621fe10898c24bf614f1ad99d91db0336984c08d0a10ff0f8c7ec5a25364006ecf3f8c87296bac9c6fe3f14f97cd168c3d8cf2211d7da273e08ea5d68f166d4aa093d217b488e148131a8be63edf078a238d2087ee16a4528307c187592e5dc2526c5442f05f60a66e10a375cef66d15e8b273bf130571ff4aee0f994c72ac44df686f815a07888202f73bfa6258be2f73c1550e4d1b9a4563bf902f41cee77375fa06d2d08787bd650141d0f2716e988790eaed12547bd2926d0c550b55f7030f1b526a3188e8d60b993b632571d17332a4fc885a5a0621d9490387733fc57f3610837357ed0083ada9174bf6dbd9273b39b57eb5b64162079584de866055519cd358c6e9e61403b76a9ef2f420cfdf0155a8d811b62ccd42c3020a69855d9ac3ec74b4d9684e3ee4a0acf34e1e2add4fc31a533282fc2bad4ce8542fe607d0261ad10ba78981a1a4cc7d2ea96bd400699705f186a2053736723573a8f3664f186c24939bc62805a537bd0bd06fab6e16775501c11c439061b5a071fd8fee3e7686fa2105f88c247dabd6b01a3cc60a206c5e66f3ef3bee7f8fd748827148c05e29618a780672638375194751d44361f46eadf0ea8c74566e0b71b2a31f3e6fd00211d2b2088b35b6df406bf1df6a4cfa434e823834bb6c7129a503ea5b81e0485e4bb3c184e2bcf3e8046b1a48a7ed6fad485c14b65cf20c4ef1d86a669aee68b92a82535ec61694ddaecc26f9a19dd7dbe58a0ed6ddbc8f3640f866430d5009ae33b99d6afc27377c7949c6bd33cd73abd929bfc51353e4371c36598e50c7061afd416f886dfcded5193d6a954353992459c670728a29477aec74ae98125921d26f48f7941c69aa917e5f36f463db562171a6c9ef29c842b6b61cbdc6a74a95f3d2f26cb952fd61ed075a6f95a94c90e21bc042129bb8f18a5f155c3d1656363dbdd44174204e6a818f3da76bd4f28335d7ff8d37de1a7072e8de2f80bd86cd90d4a293fe43b1694a1b9e59b9a7c289b4a1653d200ef9d4401cbeb06183b32a31aedacbfa5cb920a8f200042b26497e480a00c358d8dde879158ae797871f12a678285962f3f5af162a86d74850d7d03fbd326b3baaca4394de0305b8b981e8429baae70d10a4fba5091d1802627f8312126d0c548d38bdf3e9e57ff43fc7ffbd5dd50173bf03932874fe46c57d926cef4584d6024981d4947580fac133ad5b6323d8795d169b62eafdc256f82d201d6e8d6ebb3166f91b8c4044871c03d6e6b46ac71c788d5fbc1c0970eeadaa43c7a2355b5c4a8da8f1f4cab6838806fdc6386337f9f6086f1163e368fff5acab9528a95a6cfced5efe9222441ada22d2745b9dd69148c1d673420b059fd3aa128033d4209fb95a62c2494a2bb487fcfc94b08568269a13a63e1ae9f44985b0ec1efe018bde23a52a1a5b2e7f233331c8809e0f0b5644ac0653eb5e2e22d03bf99ff1999cd5420eb5371faeced7f3d4dbdaa2b4f3da5e28370559feb0a55fe7d7491eaf25e8c318152e1f3b18dc02f32835aa984a940d215677517c70870741a66eca066a3ba7361962c006bfaae60a2150b94a6b08f148cfdcf76925e0e2d732d29cfc23df89542830bec14047dcf23345ed0cd4f15e488fbb6ad0bd6427a414d5d6c4ddd192b12a7a28f39a3155cec36ea15de2df664d8809c76cf311398da5cec9b9853dd90780947ad2a2dca9cf91965242aefb5a4bd25837bfe02a8cd9ccbed7767268a630e6d65ce4dc73c92e1e88e29262cfe7136398834a0ff5fc830701e561cd3b8671fb3d4ab2aa5bda208ca31bdbeb08753033b9ff760d7fafe56dd94d6f84c56f0a6a2357b86a0a054a94dbd2734851400a12bd06b6c236d3f75d037357a6a874e4bd48ceec4b0e50be808f70b5bcefc618a011474583fe637f64db627ac4f7191c73829253280d7de798b74dc51dface3946d6f3cd00b7e8808d49c68ccae26e8da5d1c13176bc46055320252cd92261ac7a25f3d355d589d2259fe2244b89f2004af36f63f76aec9d0763496404a411f4c225022301834732c337d412155db397e3fdcd896e23e80b252b1f763a66f7faab01e95794aa52ca9ecd1ff633c3dfe22bac1587f4bae77da72ba86a3ccf158063e7c9fdb0e6fe9105c9e7fdf09149ca8c49743eca74c7c3951844711bf10a0800aa72cb1d4b9d65cbbcaeb0d5aa89a3c4d6e08b93b8164ebd4bad69a31e64c4566628705f4bfaecb475da2727813c493b97470982021e2aa11bd84854faf9f936d162018f7cc6b1bd7a59f6194448eb6577f2a740ce5d323cc59d88dfd6b6f647ea1e7c550cb830c6b8490d454627acf496440e56f144717f6cc39eaae173d972350acba4af4ab2eae2eacd5a1182ae1eb811c8fad7853ea7a9f7fc687fd41f666fb184478937d48758c7108628fb0be6bb2256ebd3bb1c043f28536a5dcf42845779869ca5c86f2e5c8e94a2dac5b8f4d79ad6eee77424214d2922c2d88ec0cf703197222e6fc3ae6b90dc94f4fe0756928c3f6fbc2c23fd168732508dbd2521d9fa4e9cd5fc62f8790baa300541423dadf696866428d15120124aa226718783c6a1893c3ace70dac6c98a29fca935a35fe6a902c54fcb14a99c7c9efc56b2ad0aa57ee1a76728257227b3cc255d53fcc968cee163ea617790ad8cbddd74c5270ac3970368484946d5103c152386a4b0b9936d9f6239b1076a4f335953223395d63fae2d28165f6c1db1dd91663d559d84cdd49e6fbe7efb115311f173fe59265805577656800b42b23647caaff2e27e8255301396ae2fc8e2544e05d20d878a747aaee7229927652a1b6db143c8d0ca84116d671580e44758c589a651cc607e08c5a1b66eeb54966df0601947968a6d78a8832d6e0958faede7464a88a6f3f6890679ff81b77c90ad2e94881ab45f296df717085a033d9070a16f24af38d09375e6bbb6bc1b336ddd182a8b7066d9b23d879612aa15177e07064129e94937577ae8838460ae876377cd07cb73170719a6f1f79aada2e14a870fbd3535b37d225c3ef05353b86a2a31153d848429831ec397124460647d386eba97c05de1aa18749e238361a65fba98863d43bd57a890eeffdf90f5b4cea3471c039b8caf7163f1045f576b7d650a65f3ff2dbd26fe442ab71ed6a2309561423b77ba8f641d280ad205ce54b71f2fb370fb9dfd2e3f7a41dc4eb855ce227476ed329453c4df7394fa8999cf378547dcdb5fc4b0d6fce12c714b5ca41b1546e7560edb6134a990bed2651ff923c58b30ac4708ac236621f0912cf5f4b1ab9ba8494ec8517a596540d5ae814bb53544008a18536eca7c8e389259502b5e9ed86985add49b814344ce931576123a29d535ad8a52fc0d9fa3215b92f8cfe6fed37e814b8f447f47a4ae64631eb7dcbdfca90b46391a485b40a66de386dc4e1d62077468a9fea8ffdaaf2a273cf42d5a096c43ecdea80d3823a67b4dd0cd25f5cedecf8e68e21e0bf4a5ab4725efb9dc742100307cfa25c1dd1a582fdec63a95ff822a33a8057ac8af248e4396f29afd6fd3e4aa982742e77ef9b95db952db7b8554c9a0658511fa099c46620b43ce1298da82fb23135f24a44790a281d956c4dd913ce4700a76e9462941ef6b5a92dbc5d6913931094e14b39985a387a929868aedd9ee20352addd50920227fc0bd621e275b683a77dfa0006d1a9b3890076d5931856aacdbf09d06d7aa34c6afeda315e7b2bb285ad6083157d10fd07fed4391c2c48247ae25aca45d433467377966b36feaed849d5870852df9b64f105750c800312bb9c1f50e175c287cc5cb9aeaa4ad489701ba120b3d4299779b6d6f0fb604e79fa71b757f28a1b4c109b519f1d594b6537791b4261f9ec312ac16919fc4b83e6eac248cbaaccfe7f96b5eb43309576f66ca512b5022fbd6bbe8894c3f50a6d307ef6ed57110620c28977bcb31348a688c9691109a4dc89734a00cc3cdf5669ed970b7bb3270dff9531de416b13be83be808f60e4c3283e99b9c092918de93b29901db456fe39f7ca5d2cbb890f414a1dfc22393224b384214076fce6bca9e9abcad68e2ad95b9ec5e310744c0ca612b1fa055e30e4599c615d065e1c040e2257c2e367802f4473a9b801cf350cd82da6f364294645b973d7266b3b9f501cdd85fbdaeb4d20640989a7bf62aab2b3b1b5e62d8bacaaa444a566005dc0ad87548d868d954a4a8a5ed8c256180818fa669931a521798431b9bc30a06b4803fcceebb841bc0d14f7e38490f9ea6ed9241da91721ee2d99c022799a8e2ed7c89f9ec3e7affb4de58d0a3d60af3c32461811980f5a6fa4b8641d9d59a5ff5fb19da03d1ca9d71adbfdd1351404e05d8180ed565934a8b9d022d5b01c04f306d092978c35cf03d3ee97dd46538ab75820619814e520577f636b1aedcc9574b8b6fd445cdf9e496784b35dcc226281e8f6907567aebc337aba334cc10532b3133540c403316ebc3f2e554649a93cd99288943e3eafc9c896fb2f5e65db460d5d456a36e53ca056c4af2fe69ea23c9033270232fc89a55b7341f0c30c83073c48591a6be2b5aec5e35078bab6b4bd4957393e4057bbcb9bfd149e871b535de01bbf14a6252408aef9fa398dbce164cb9394d1329e78706f9cbf4cc0a4b23678ed6761fbcb54a06536f24a9abf88630a0fe2010d7ea27e9d9c073bab3bc0b0704df8ff5c43857d768925f42d4bb9e1e7fb0291cb6ab74a7734dc5c3be456c038fa9a8be7cb5045e32a837f22906c49371f748aa8c200eb3e23c61920b641ff863b5af7b525902f7433df4fb7db6c6529ac64fe343a3a69230ad46c7cdffcd26f8864932a3e60b1c92bad13584d9a750c63acb15e07fb7612d216b3ca03cfb25df9bda69f16fbb1f7fc9fb5f2636d657799624c4f7d719f79e8b206562ceec764bd6b395e60f4470dbf19c08a8b944deaed99f4775a5d8fe1ae3ef0d1351a469e71eb7eb6ed89011cb164b3e9078a4b6aa371ead3ef1c13aa50b54656d1cf5a95d64ffee836b784c8666d24eaba64fd732d57f4ac24db00278819610c6e9658d02a6422c0f121ef714dda38f509227e42d1ed62091112b3e50e9f896e4017555c87a43c0bfae9c9d8c518a67b86c6256d1c9ebe3fb60835d53dc1735d266128786db4502c5fd889b842d17109f51b7add3f134efcaa4abb0cc41ec10acf06c27346a69b6d356bd49e6853b97d55e6fb208d02a4fb13fe3860923c1ba5c7d975951faf4af68ae6381ab551d2e38cf0bbcdc0c1537edfe5a8813bf9e6feaf667fa9904786bee94dece1167fe90132aa9af5e616908660e69d0a075998d8f561980bf5543cab51e260657f61f7749ab39ada914300d48ac01bbd1f335c3e7c7df460836f5a6a442d57d92ae058544244ff494518e584a1696a4bb7dbc5763524ef3814bc6c86897de0f70c60d9d4239d341e5f99c667c0c80594e2f24e85b235f0c2d2515fbf855305b595c360a1402045938e9529d005f7525130642807eed28b2950de42097e81873d27ae6d80b6c94cdc22d953435c65e01434dc0764d756725d91da7a30206ed85996373eb780a5a09e291a30e44bcee443e56bc05472d21567a2c01659862d221f952b6a4fd34aa901ec2912ad8904854f66bd8aa5ef4186eedaaa0f8ac37f629541acc8ea3d0462a738b12665ddcd9cf179f24e87bdb12b2947cf49d70ab99f892a655d679b1c2e10915b16d29dd213407d391bcbcf93df4aceae5b8f7c45e68e7cb41ec7758ca57dad3d6ec869eabad91af51404d7b61a0a1c26f7b3b5e62ad781c5b1e4023fc3b32fa20af74da18da8a575f5dc6953c43169f3272092e89a38f88dc94514174da2692674e9192b636c22a8da7c80ec1348fd2034b25851c050c00f07214149f04e6bca2993b6a05dc32a14637bdc6a5326e2f9b701d23e1677b9080f1489b71cb9b034e59db280a72f10eef6438328a46829b7d400cdbdeb1852e6185580aef201b0629d87207f885bc499abb70245ddb5c5db806ee184866acff01a0f47d4d88f29a29b136e4fdfc3a9c76acdb1321e3d33d5893d9b800398f44d04b7ee58cbda2e4429eae6366c15bd09a8dfeaddc1cfdd44d5a04695328d4b4c5d97602fa5967e2242929c6719a0efe61315506376ba01efd8453cbff2305aa712ff45856f1d0db40f4635ae32059553313a0a48d60b104c24eae2f1701502cc0245cb013c93e763d9e8d3249f8732833498d40d0035dec19de09eac7b2dce55bdbbc9089976ec3040228e95a9c517ef48399ac1333901bb8679fe2509dc45f49de71b0732a50e1448c500481233f3f1b606b293be790fcf7b56ce6aaf1bde418659a7e877fce6cce1d05b760d07008ec8699c3e94da1e071f5f9f5d2e6a34d19097c47ca202d936625dc621863687360c4794806d163d687724e34e0dfde2fc8c6328d7cd08bf72864178af4f0f8122de2b221b17b523d913c947ed98459bbf5168102d68bf988e678891648a93d44d41e1b06bc730ee0409f9715405fb70caf31767569a0442b86cbdc5ee56bb7d232771d47f8ecadf0cb73d4a4acf64b2fbf643f2b5f90b266ec272e1a29c60887997bc8e40a5cbc325fdc2949d12213706a6820b575a49efb2c15841e5a739798b6706307fdd415b7afdf663e43c79d862700698945d8d627409619d0eac775a7e7b54eb15cd9c31d4cf5cf7e00a060ab2b67627256ae99e0dd18e707545cb1b49160b097c99182fba5350864d3970b9d7521e024b59d25fc55451a37c93259b14db7138d15c68b7543cd8cfe2e597258d6b8180e5835ab6c14e42e39b40a143a563c54f015edd2bae31a81e61d15a4c2e27b81c3a3ac716401dffd2a7aabcc03f377dcb9f336514a113350acd2c70974cddd5ccacc17bb99ad7b3499e0e02d8cf37951867523cbcaa07ef5d20f09e1b829a7baf4649e87ec26bb0e688c8e777e763609efc5cab488ea3eb3c6f6734d265cefedf3ff040fe944d18249ea17248e4878b9852af3028bb5f9d51692a0dac2e02c48ef69b4163ec12ce0b49d1d74484af936e2304b23ae34f8efdab1f377e07994f0397aeb901057330806cb6c0c83f2d7d65e2434eec1c7a4de3f5ff832d775d91297b35789e7727719369b6ee9ed35e8e9c1e1c0798fe704e1d97e2fa96dad8c54841ad1ea8ccf048f16bf5d0b7328cbb29c3f9a26bf9992677d2289ae4e52050abfd41c863abb0773a688bb121f1a04ca1de126bc39e626ee4d9e6d6773f18d41e7c230b8604aa67944f0d69fde0568713f2050e5309928a89fbdaeeaa56ee23438dd4a8c3f7cd3384d6b54ef3b8d0497718b83f1814dd3b547933aaf66b8f6c0cc1697170cc361d2124007b1769073801acf97a04580cbb451ea5a8977d4d67465cc89f83f6e15291538f562c0dd50ab938d25a0a2d06223817d7492ca375d080434701a459504d5216c842c3e5a475bdadf30354fb267f92fada4af711a2fd61c616ce374f524ace84c3fcae72945f145bcfc85d9b6b483b8fe86120f350736eee7a8d25c2af597694ef524ae8761f8f56fe81c35b16ce1186fa325b377bff1da828ee043584bced596361ddae1db3241f0c1992c14d857f5b01dd06236dec3413dbe6a801413703bce895e6ecf79aa8f0cd7235f8a3cd8916c1b738260f3d85ef3097b3b780ac108acdcc48396e4d629b6426c9ef443d4337eea7bfd6333b3daf5c4f3fac419978547e129be3dc5fe150595f63380b81716dbce108a5bf806102410dc1aa27e3bc2e61ef568875e15dbc067d43e3718230251392497dd8041739c7a411a186d5146e3f4f8fba1db0c0c0980dfe27924306ebb37d6c4f1df9c5752a85bc55093e900da2e0a9547eef9d13e8beeed5889f75294eb637f4b6a642c32229109172f67db666b5838756b74f9a060b78fa264a2273a82c81818c59ba43778554c60dfbfac23ae57a239ad481f48533b631dd82e091ccd493d0fd98ee0b66436a4d30c2a8272e43c1d53c948ceb6e0db718ee2445258ed2b7063f05d6c5d41d80ff8b36aea101faeb9b25756d0ed6680c4ce579fe2e261dee33edbcaaa9608a540cfcc5a1090eb3133a2d0fdfd95864fa7d859d796c4cc7c668ae76356abbec7039904db5c1eb0536693aa5e1e2bdccc20ab55d7a2929fb76c895ec3a85482c2785257e6b574b081ba625c0ca3eead987d8943fd182b8aefbade05f5661f034420f35c5f0ee68fc1ab13fc4336ff549013cae1de74cb3ef90658c8ec3632f00a107ad2856364ff25af6d2c4b1a9ee438a63ca80a5d06287bf009340e06b2efaeeb1d83cc4b3ee41c798742e3e3341127f76addd234792e22c29a2e80f320cc30920c703bdc7e7a906e446473b3bfde6a3600e51be4e4836ad7c383cb90d1c7cb609bfb625017266d77bab435d55f9c3e3cd03f074079925aeda2d7ceaaf1eb8ea677088577ea2a3849cf15b780289c889a67e364cfc9dab1cd9e9cecdcebd82f3f2789870dae2e22b3e0cf006067d768eaafc9f1242cf617e5770af84f0e0ab2347540075d61afe9d7205c7322765a45fbfec7b260e3511d9e665f1e6a522940a0d6447f47b37ea59600516ac3878837d49612c0c3acc293814078b92a02a90a8f0eaf9fcb4c51c2674a1ad73d9322af6c5d7545baf75c4dfa7f8e769ebe1b3a9cc3edac4fa876d17021324183881b3fb8e721632b8c3dd175b561e1ee1bfe9e0d98754d139203ab926f7537bea18c390fbd4b9670070691a3197c842ceb3bea38f02810e1edb98a156709c14a4657a422b24fc43bb0e30dbc676009ed9c7accc6e1524b4d4abc22f4bea11f8d7d23409db2db11a808e40e4a12ad00f8159ebea95a379bb2ba7335a58cf1925133457e4cfca291e8e89fbaebafd91a120e5988eb1251acd5015644362dad47ca6a27195f95f26bb143ef28ed6711a1d4af1547444a161ae0afd82eee4c71785d97234cb1ba0fa710a95d0e81cca6c5e025100ed9766e2ad7a0973b197c87ffd53925bc42e4b5e8d3c1700d89df01e906180bea5d7d3dd972c6e27199f0848f7285f21195e1c73466f7234e6a1644d80f25f57aed4041b99666df658ec3f67e1cb6ff9c88d6a5cdddcc1084f23ac1224a37841a9e788c6e15987fd3d84750bcaa0b9f41bd274678bf02bfd944635a9a201567c15310cf5127d2c70a0593766aecfcf91031d72972d441fa6475a6609b07929d9ad123d85eb4737e63f53c848e78ba3a984e1650f95d517630132b1bbc026a00dd933f403e72b77f6426a8aa3bf16115e4da71cddaf0dd4e09434b82d877f2fec83fa9e15b4cc4893101d6d8480886883cf2f2ed8d23fae09b4f3da4fd1d7c06e471ffab0e42306d416c074408372e6332f4f985bf0f42ccb6ad0d5b7afb6130a721a27cb3773d966722af19830fc5609da10e3d5d25e976ba289706a0362a8f4d823db9950a07d51e362db3d69d4e0197d21c0df3b47a27075f47ae44ba105917eb6a8f7cd401e35dea9120daba7d4f13429de5c02b23ae057a81e3dc168d4e975f51a97dc2e796c5109d47159c4cf24638564c8942c834bc6b79ae766de9926dfaaa576788be6a1769975f94c95dc362bec30c771586ffde5112f59cf09080edb03f258e1a6f22eb6a48727538b8c83eeb2d8d7e33db98c9bfbe648e7cb80251c73a6cfe64c9131428727de0c33a7c88bec5cab9badb38e92bcf79e13ba4f89a6ec12eccdf0750303748a349cf71f9566ffbfc5af52bbccc3d21a5ac87d0e8fb9b244e4380275f299bb4da8fc2651e8bbf190a68f12cf1be58e4f801eb51cb047002c7f78016c7771393a299feb24840046623bceae9fe46de28048d8e9fb22734dc6ae12fbc2faada928723b1684061aa8eb2d5aa351df73b1b26d142533e623bb93308044882bd6749ee6a66472c8585ca0ff865d173c205b362a99d3d53230d3677da8e7e1ba440b60ea73ea95d51c6aa3a02e64b726b1565008efcb779e8b0728aa884411704f449ad3091da6c0368fc671e54e0eb08681cb5d7f6f0dbf02032dddc7d03db47ef07b4b01099e1e363e0416da8ca333d6270db4631b7f4d8d23d0213d88f11ad80faa4637bb131f3af41934d02c137a37c097bbe2db52c702f868c8e5799858916ed35aaa9802d3ecb8c1bf50ecac5d8c48ca5bf441028f64541c6919da1e35775f8ffbe7546909c67176705b1bd41dd5107a325e2a406612368b8ae7fcbfc5e99b86fedfb77c6aeba471fed1c48863c3bc6e237b273ed7a922c90911786d05c9a65a7dc6f6cd9e0280bb8f364d5ba1ffd1d0960d9c68be45139e97e9c32bafedbe331e85fc3d1ce31879604475f5ace4c017152194f69d4d33b1a7fe19fd17c0cf8792d4789b70129383c8183022afde9432ac96f973ac1edf22e109963a2daa11913f9fedbccc082217b873d376d657f14536ad0691fbbd9ee2d56561f349b17eda04fa829b03a83f2ef91a29494d82c0829b07f6093a705d98b464d9f115014f71f60d135e76f01f2a28d03dc106e905cc3b4d3b1d9f1eed3c84385f3f26b3eda3a9bae7ab6c5e8d458ba57a7a7cdfe003eee22a546a97ab60ff5114c5a439b6afa87a3f3de435035dd842fc3659250804787217a0f4852bfa58eee2dccebd5371a4926eca5e49e93f27733f8d620d2420acd7e4aef212bd893f6c050cc52c126f5ea3f021b2ea30ec9838b31ce4e4f74368491eb7fc3646cf0de75fa6aa5ea7be19a3114d21a0f52639af4ca4305b1f43cd1c33d88a9de24035c965dedeb83ca7ddd2dbe5cd071850eb738a582e3d960e8b25f203b5c01ed8af79c9866b151d74a795572b2f24ce80ccdf7ea836ab6606205ac92209fe9f9b67ccd45e0487415b57ec642de5dae73a97eeabb518bc3fd3d0b65acb9b8dd89c8f6d668e6c4fa8089a3b16880395d575baf9eb7658bf7324cc840305c6b166704d4db7345b56f4fe649a937357475c48395e86016c0b8d8bcf7b5defe30190611b210c634f4a252abecc4192fdb0325c3325a202f792f0f63ce7536e08258bde431adadc0ada1932c11c6922e54e8710f76b87363b9685ce63ee96209b69e5f0492515d3772eaf1e920b2e8b266fda8f5d6f8337d1828f2d832642dc6a5b7ac8cba7b38a30ae577cda3643d6b1b05b4b5a7741729c68f61973a1b9b4f87818204a155e12bb0a18da1085877ca68379e2560ef3ce83d68394193fd8673c815b7c42711ccf9c8e1f840d23943f17e4af67bbfe106701fd246932dd6e515ad4b1c818544f04a4f18f0a48cacb06a78877c6ebf518ce7b8a313f8d734286b37ba13d76def2a0bca056c1649b3fd6362712ce6405b210634caa27e735a47a6579e1e224c1453ed636743c55552b8557da65579917edb446b03f610d4be039b729e83c7b8887e90c341143bcf6e1fae0826fee47c1b509bf704beef3547454f3b0aeb79e49facf64420d2f33ea6aa86f0003ad5951ff5bd88a189669a20d24518297a58521ab151f410464254fd49551d4e2ad8517dd4df88e85114ab8d0fc8f5e9212a980fc711932e38d116b890efd4b115bdf4302ea77f68aa463fe409f062e0187bddfd78716ee0c2a2cb09b48c8d76c2fa6172183edc0d6f595b1996f6bfeab23e6b0e6277cdc95c4bca5ae7aec2f960791a875531c6526ba33a34d3cdcf77e5de7abfae0762e5946758227e2e22321561a768df86dcc40956af6f042408475c20bd0956ee1a989b71eb107768c33815e33de716af4ee15f5560ae5b9eb0ade7c40c34814e70c44b608fea88b31a6f2107467656292987b4f7ddc5af2d8bd97e0b801d98dc3690584612fca54288fb4e919180b14756afd687bf49ee9652b4e9238a0d2f07f829ccddc75b1183bdffe0eca03af1c485494a2f74521c6b14ddd6497db1a6739c7499444f8ffc054f97785c69fcdff5f0aabdbd3789ff00f40fc0515d750d36828467ac91eb3613ac3ae12745e43c795a78e800d61db09ffef9c7e211b5fd4e4f768d3c103abdcdc578141b3fb7d9df92eab0582b3d5218caa8e5fc557b4b11997252c3ab208425c5a455d11ac39f812c4a05eb15f3b997dcdc803893ff422b428a34c5dffd6e210fc8a60c39d20b5397f29ebec7de5220e7886b50a52b97919b494dba5688f3cb68746a0f0e11f0e185a168ec63fb778fff52582fd7f24fd1d770d961549d25749cfb780724b65030e84b4892e031959889dae68add47b768fdb2512676c21f7df1b1d8303e9e83a501976f32e70b664f4d772659d97d1e7ed9226ec6181266ecb0c7ebb51015ca49340ae2a217056739c7a1aa8a97b2d4199bae22b295959b29b8f53ee2b36e5bca871bc5f449310c97c1e525c591516a432e41069b3b8eac821d4d8ce359b31d0ee1078c3cbf10af3efa6b7ee676003f712e5d72cb86fcc7cb7be33d5d127ab5f09b4d8d60cbdde2da5a948f947e6537fc78f61dfd2f99b2eecc1f51db37b6081f5a0d22ba77c4e95c5039dd8de5b69bb8ccc3075c2987428eb08092b25cea712658d31d39b05bcd81a7c71317e4dee50ba73cb9f8e0035d2478711f38a86ac446a1f413493116640a241450032d5f309970bd0c32bef6f0a5c7ff875d3f2b4b4a789b2cbd6ff78ee31b8626d45e3e86b50f0d48bd8cc6c24cff34b796ba07746f44d8052d6b92fd00b94c8ae2c910acbc2e8a9ca20fa3779359cbd3cddc49674c2ffe8cba5416f1db865fb1dac925ce2552098ae1c1e88888ff519516e156874a93cfbfc7ac06b178cc5fdcf1e03cb65fe693869bb330b773cba09f66617e304d0ae0812eafbbd028dff2cad6cc7b34348fa5e20fe7a8f19c48b831fdac53bd4df5d39859b1341186a5337729c60cab10e03d7ccd9434d0719cf2fde890b8959106a68d188516e2426aa52d6c7ac49e0c79921ce7a1deb444d404d3f0e130a9c8e0a8ca4c32faee91fa0b9902f337c29f29069be3b4d52c008d6430745d8d8ff4f43670f702889f2466beb05c37807930558662ababd8afd186ba70885cfa832ccdd7f19f09ca9a29a9a56a1eccfed86983b0b1047c719f666bb44c4050425e667f106ef565ec7ee3d7104c07a41bfc114dab6f8c1c2536e6b3d95e09d193db6a7c1244f55c6319f2653485f03c8cd09030dd36ee1fa45bdecb18ea080009f2499ad5f1d9a51430afb422e910a02ce2cd57fa22b754f99ebbd6d788dbaf6643825720d7eb179711a7b45fe95490b0ed34665bca799bd1ba1474a73e6ace282032926fa91716e81803006508c89dbf3b9117b30e11278ee7a3b492b2e42ad7cae7bfd74349daf5302d3deab6383fab5070c9e048a38ffdb7c87262e5acbcb9c18a834f82a3e98f4335eca80193b377daefb89eb7ca4e142a889cd3a311a2f1f10f591e4a03dbf6e5760ba2964d14aeba9cd51bc5df88c1b1b7476eefd1ffe7e1675837ebe6974d8a66d52864e51a73942ff458b7a3495dc7b6827fb19ebc31dcb96ceb61ce18c74cb453e477cc20cd2ce75101c3be62720cd5e036bcde1f396408bcdc779d2cf662c65ee14c5f5b7d62af5969deadf00a9b59acd5bf1d9fe48b6d677625507dfa11f285773416952f42f1224f194b915c0da76de96c1badd3f8454220b496211106ae7645d7a31b473f8b7c39f1638311ed08639d2b48b4ea701e658c5ecfce9a283efa58aae2681ca611bb72d607902d960f98f6f26209425d45cd1018d8ba97159c996005b22d7958524a81cbc51db81dce81f3e3ff4252c9a5454faf87f8bc518f183327ead82be7685bcf911a63d393ee5669ac3028c8e8f0bcc39e5eb07797d3f76072a4ea617698fb1595dda3f90825ea3405d294882040530baf885c58a69f640de1acc5b1a38f5c351bff6aaac68677662fdc871e2bf85515c99d38161e0f546a5935b04adcf9eacfe33883c17e8aef2d6a969bd5a8119102787978b9316198db9f49f4625d2a82ac0a5852c1eb1b95f7231c1164865601744839d5cff636b7102c07edb725a8dc63fb600cadaf551c9bef7e523bdf3eea74664ddb984c66c860fb6abbf9af65ff39817e42c327a8c66d2a8c8fd7a3326cb74a350bbf54408044d7d33cec78439a12c8cf5c2a46e2669028f550b19e4469cbe99cd53c82ae37dd459ab5da05a2889ae801b26b0509011d9ebea381b502b21cc3565faf1c1f0c0261356c3c614a1dad408515095c3b47f245be8f6bc9f9720174e15901093ecfdec42b74012fc3af855573718c330e4e57a4b5f3e996c24ab0ffb945d44b5ce33d0e104e44d15a8c1c3adc5340a1b50ea6c20647cc0841dad362de2d721fb52faa31de0d3cad287df08be70248578385a5912582ebeacd1362f00d5ce23316188f533ba5a85c6f9866d60ca38d2ee64a274c7750823e598200c77ed7924d39186e0aadb2b8b882d777df71aace127c84a84875da1bc5d2db8bb52ef9c5afca441d023d38efe08060784b6f1135aebd105ed8f519fd53faab99774438ba361f14055e62d887c217c47fd699607fbf735e17606405bfc32f5f0edb2b493c7fe1aec39bba794c5a31a625410c6a9af6bd513cac374c63f28de42d72cd45135bac4068c9a472fc4fb506ad5321a10d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
