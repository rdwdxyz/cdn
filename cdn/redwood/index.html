<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da5fad0505dbd2af3ac208114a770f215c28850d7b68d14a9929b7da06c7e0c703299ec628bfda5266c8008f4376b4c92d01e48aa1df817fc1ae73fe159f00619054b2b6f33e7dd149fb7b868b0b7c3aea0d2887530da4349a362a473758ad3286d831c2c557d7a790eb5beba81781de39d27e6f5192ae8701841aba9ce4a08098b06c15452446f555c5e7d668e5aa77b38b237930d563fb9c20fdc3a98ad4073a2d77c9d57f1fe89a865ce81dd1b162e925d59d1fc3d8cdc1799e0c04420b50b8b32d9b1dbdd6503cdfd12b5cda70fee96df95a8eb049574af769f6cf6c2b83cfaa72c7d68f467052825e27740f0a6b26f01cdd652e2b4232873e530788ff2a76480245956cd3382a40ca94ce41217a739785af40b4fb9240b3da6e27dedb8af85ea29a60d7635ea854b2d2a0c2c6f36d9a37e404b1e8449c26439308a0f37ec24d83fef0e0847f388ce6ce25f59ccb8c2ecb8116bd3efb698f713331b679779161ecbdaa011fbed3993d30adb178b355d917e1944978ac3a2bd4fbd5049edd837ffb02cda0a9408c2053e0b370f784b02fe659595e631563b05b58816ab9b4d51a30ecc84ba7fa557efe5223e8aa409d4be9e58752b7922e3dbe89cbc72e0390b34dffc8bdaf21a3d585b2a0c0f4278806b70ba4160a6e74e59972817c0e115e96a980f6ee652ba760d4de23e1d46c7dab6f0c89a7a23bf331701f434f768e61bcbd89dd4895a001648346ab8b43576910b82f1918d1b0c090acdea2195738ff798d355245cbfa25821ec3bf7afaed61a393ba8a81a324df53846fc4e59ca47581673315b29ca02811dca99bb19f11cae0c6d31362b359fb1cfd555747df7f052bd4c3f2b3d7116837954f61ae3c346350f7d7728105bcedf2c94ec995ed0494eb1c039deeb2a7c4f8ca3b7bf64946909f59d4d57b9e24599f120d63896b948aa7cc86b9498422202fe56789879a7f9da7852bd1787f3d4a398dec5302e4dbb2a88b6955cc47ae1ce50386ee18259b28cdb823cd569b981c6526a6649cecf6400f99d6110dd7dd4cf133066fc194d764ebdc9525d64e9461d254c57d9a7ac9c70cf61f9776513c1b096f42172a332c1ef326b94818d47249155da3f3527fe97ea355f0887cbd547f13df610b862bd45dbe506f3ad8bdf46895d89214a7725d64f827fdcb664b3f3117ccf60c175a4a2b39f1142c7b83e235bb1eec404c020af1cad2bb198b44febb0ca39d3edcb9d07a6e6a746b3a192d8822b8aff1f42ceba347cbc2313bac10c1e718cec7d6edce27d5801bb43c931dd13ef61ee9dbc411faae8e40a7561dae71d3133a825c2ccad4cb95047f7a58b76e9dfe83ac81bf5bc061aa5573f12de7d7f3c1328fa6981271ed9b4eb7d09cb610c41b964e7b4011f027f8faa7a69bb3af94a2aea78688c0a6cfdb30c211be8104a5b48086c3ecdb35c1d26dcd03416ef26e4ce3515dce7ad94414833fa647d584b0a09b18f4bcdb038a7a136f70e04b85daa1be1fa8bd118dc9eb08755e6eda086031042c8c0d174338e8c24f23c24a727e92dba5a58a0b4ce776dcbd927e096fb98a4536a3c415b50e485e39235020ef76fbad0ec1a2eabcada120441eb3014480882937510476537ef167e7925fda30f6d236ebf27123e97f36cb14194bd542ecd2e5776eeae7bc93f847ced3c487c00603561996efa631acdd0e84c8612b8b11b09b62f8373e10b635ff24f173994c70305b4a9f88e64507a487d526ffa4bebd9284e44110fd7a21513a78efd91e4b9f602ec7e7664be08f9050a1e9af312c155245cee5748acf062e492fc38a0e77ffccbb866297e9953fcf1bd982bc7c81e2b2032d347495e9e0a191db34aaa28a34a7ed4f2d4ad637637080eb23daa20c91788cb9370656d6c6e96abf123fa4792f3b7c3de5b331fbe0edc80195d67b3a52fbe01bb99af7471f87d3a6752a310b3b0248594f7c98ebbb6a6c4749411b17844868877d73de533fcf74d2401fbc6efe1cd64ea56a6935d2518443372b23a0abe8b943bef85e70e4ee9ab280b34a6bfd7d375c533ddce2eb30099c59269116b261f3d61c527ed06fc3f011ddcbd2ebaf112a7f4d49b65ff9b67fe1dee86decff6563a7324e42983c08e435543ae01a69a7749246e3f50a0655ef8efb080e777e22d40794ce500d1cd29c5e4d67c8c69b13f12a30964a4c5243ee31104f6f6a8d2ce51aeb8d1f56e57563e7430b19f7ea5577d941709f78fd32494e911d8aae8c1c3cd6dde47d3ae6e2072f3113faf353478fd49a1e64db3ffc74945d61470c246d14f82e96292ebbb30b66afbf250c2a673fa0ae832741cc315f0e1e8749a310084e3f671e7d1fc6d2296d8f86fddae6e2aba608ab051851cd98f93d91038a9443727553aa6210678b706901cf7e71cecc5a2b998511bcb4c3662949151b41f495766ac45fdbaee789ca8a778d400ea8bae0d5e513b4ed320f4373d8f3fe2ed36356afe9deb0386826fa44bf8c91c039739f85b9f166360e1e862ba93f6d2c70b9731c11c39d2ac9b1b82bd434dcb167e78bf5dd39015513f71a9ef977b37313eb96b9db42bd47a2846b2a264456b4728422a822cb1c42d4aa184989ab78139c4a3f3f97e8dab82f3151d41ffa2c01ed14d3135b569b8ef7a8880fb2edca21b6d5d9ff51cfaaf80c398dcddbcbc2e654f39e758a00670f8a08860b282c55eecf50239ba20eee5a782266ee78005001f9d67c4d6420a68c9760bc26c1a93cb773707f00e6396772ae7f6dc56db33e763b8f1e33eda0a2d1478a3af3d136fd5b654865ea0ba9618dfd1de2bb4909e03014f691eeaf6168cd12c4b479f3de386ce61f65e96fb61e9944fb3380697eb77339a71fd083bdc2594c10550b5582c9223467b487e30c28480b3450e0d3d2d50734efe30f99a9837078737565539b894385a64acfca6e3cff890bf14181abf0c51bd5415d0315c83303150b24bf0bbd4287a726ddd194be93c493d3d4ce918a22e75ddf227fb30d4c493c0f57a4f8f5be5f7cca849b93f69175e2792c150abdbc1374300d54382ef7bdf43311b438d7a7e7fe6a63ca4a0787fdd4289ea7a2f25ed3a90866cedc4523157e8f9607b63c493795ca986b03c50b7880a2b4ef1f364dfbc54066bdcf2c5f74cc7f8c6cf9bbf9784b21ead184269a3006c82aad7f1e2217f61f13fb0513cca7c8f7cdc4411bb0320a03a1da621afd69c8dc633931f5264b90c607076e901248184186f1e0468ec3cdff0a880f35c60fce9fc8c14ea1fe04517de4a99faa4875d551a4d09729681024ac3d55f90c3a68d0f28635577f70b06a5b32daf174d1f3429fba37d0ea1cbd6414b422ce77c4d0493ac27d89a5fd66c7efce56855e84d169d8da208352a4d6565552ce263508151df4a1f8d51ce1f1bd4eba08ae63940a155b786897770261afce1c8a15932124909826e58dbc019c63e9e2263cda7dee7b343d0067da93dbcc3db1cd1a77f83af453c141ce5fde13b414d399ca8a11debb1a87380ce43f45a8a72a41bd6c26502451279200c6342080cbd60eb8418da82f99638ff051c688497641a760be20b219fac554282635f1fcd606bfce8d73cb3c3934cf677062dafffff8fa7440e732e80f2899f1672e749ea94ba563a6802996d92dd3118e72e3cc8773ebb3ec8bbe067abe4399a83a72edfa5faff76db044a4a32bb3e6ba2e1f980867f1f5142a3e3c7d6b88ff0dc8abe45e21ecbe61eae12a14650650219b634717f35387eae2a5146f41b7f3ad840de5a5bc96c592368f9a62da130c8d1327a08efabedb91a857916239ddf5b6beb2ece20a2182bd635377b05e1ca0bb105d5712c533ad06c74c6acffbaa66fbba1da6df716e2f8250a77b8ee047b240bef7c663bf0765483466ea69e33ae2db0ee77a97dd9db65b10fb399c7d56927c41e399812289175b22807b9a5c8a1c9498cd1bfe91ebcb38959cbd9fe37464a80bf0d7a2218981f959c468044ea0d66a52d839f36a66cb6f3800efd0afdd065c4dd686a630c6a0c9d88a8b519cbb7be88fc392675d907ffe6216d462ca9a4c6f14b27e64d17cb371a8f826f7e46ea099c3768f72373f7af7b96a690593a183023c97b86b872c66e4f7876b1316582d1c260667846ab4c1b3a3db46569e78757d1da24203167a94a52072cabeff9e226898b3bcd2bb3ba0fdea99303d4df75da23a919634a5394ee9c4e9f6a12ee9968b72bb7c5a1e034d9dcd7d0711f9dd71abacde52276810e13e75afb89a7d02322333f23780a77750dbdfe74c430c03f9381dc401d207f73f5712e6a62b9d6844f32b86b1cbcb10c2ea395de0493092fd0322dd418b57aeec9d6d34680a038d569d024fab84f046a0ea4847be33b682f066969f3ad20c71d030623af0b3011661569f52de0ac3a31d41644557332f59e2a2e58a6207430252805b85cac41dfbe0a7efa27c2ececaf03edcbf6ff66d1798f0d3e73d818097d282fe68314702e72f4872adffce0690fa3d09ef4eddc0b3be65341b9169c6c1d6a9e0f7d9c090a5a18d050737b47d271a1fc316677b6ab844c29f146479e537c598543438628b6e42216867df955b2a26ffe3215a2a65fc11d9c36904bc82aadf1cac788386442d3b57f43ab31fd59e956ca29042229fbaf8ff65fe5da43cd8a1e1ff5b8e51043493f871b3855fb798027d278c905cd84516235614e880a018d0683bd92d7236641e0ff8738a821d4583738e734f191f127c61d2723e868069050836ce98f43a959e856af61ba7786394d25a3a028863035907d5c85ff4a3b2c90ebd9a179b7533b95f8043300f8bf4d6045f16e60c38b61fd20a2acc313300e04cae4ea3de9ac6650267b917fbdcef0bfd9bb08a3cbd507935f5b7c387ba1bd8019e8aff096eae2f59c6c63a2c761af125edbad46f5f163f05869cb588f203c937689e4d2e1875e3189051d08d455188a74909269a6d61f505a43aab93beed78b4fdf6c9f847764423e3fafcb4e198c61fcc433b3260fa515d01f113028864ee0033fd828ed8d558af938d9ad464c2e527eb02f7b4ce5138dbb3e6c610a58b6ba63727f7e0a75a4ff615c103e5ec597a89d84ff9ee92b88bd057f48e4a5b610eb7f0e0f6cd0ff5b392c4b2c5276b0b0478dc4097c8096611633e1d80106aacc4dd07729b7242ac857f997907c15e151da858006db5d1cd03eb74e9b0d7764691a972146a90d075401e3d617e06a97ebc5283dcc569934d2ddd13245e621af65f59312af527235bc5b6cd30486f6a36eb7d9bfd4729c303ad3707a1688850ac9e9438fcb687625bf57be5fdaa2f943dd6c515947027f217e85747e15e9a6002957849235da471683c423aed412e38a7c7f9cd1d4d386e7edd0ad6fac2724e82fa0d97601c2916e1e95f50a4cc0a90c74fb4b9da44b33c8202c932d9945003f2de7676981130cd0743298377786cf241199f11dc41360cc022ef0f26e31770689465a08ee158032c699fcbbbc71d21847abb74f1b79a9257cf577f1b398a952f02418b31263fc196f8794af186461a6db63c47b4d025a2086e4a2606cf9454186f6d71bb568065d29ab6eee51f3aa4075275af78b54f6c3b6569ab6d65aa4de46de7e17f8e4d56726d9a505e6ef76209376a4056b4523e5b036221c2eec54c83719e9b1ff4a30c7ae88fa2ac8e151b69585a5f5da2e91d61603e28bf4d4d32e5d39c67ae8b378b443ee5a52987587de1de0eb95e394fc180e963013bc5f12cfa08fb0e2b9872c723439a5462988791afd0b28e7168764467e0203a4fb8603e269e15f244de2c02c308a75d3dfc8994826e4dc6b8269e3c1c24bbcb83ab6274cd3e6f490c06a6e8dd8132793f5eef7b84e97cbf97d42b54f23c1c930097fe0c2d25fbde8ea5ac3001b81e52ba601fee2498a127e1c9c50d254448345b47bb661239f0a8c0d40fdc65975293cdfd3ef6c87014315d6d44f2a77fe9add177608d51a92794ab8976871f1677b2594ae5ef856007052350bcaaae10f437b8b29207405a63801e28a61940150efcd70699695bd18973abc0a1ce1f725223db9b748148d2771b0cf1c42c29b3058d8f2d583900db9e51f180036651c9af32d7a89487c326e3188670fda4dfcafdb7906821608dc86fc4025aeefba43f5cd489e99ac30c0c3b3a9a732b30a19642c594489475b2506cf1890890ffa0ea5fa38005b3fad74a9ee5349b7ad49d42844ef625316eeabf5ddf1e21e90bccb7bcd0dcdc2bd439a4393dfc000ee2eb19e0c11249d7c4b44ee457c4ac28ece71f43c0278881437744544db2856d72855fa59dc93af29eb05575f44e1dd6f21407b0c4a8355e2714036b5f9b0be137982206df8653a6f14d634bea7275a35caf9f9a3cfa007ca65f85fa80190fd7a73bdc67bf0b9684f8277bd27b6e8f9ae7f3af84b94692c11acddee489f98af8cf44c6335d80bb860c607a7691155036d184f207aa705cb03419c59d1170cc0e8b3cfdd8dff8da76784e3a4ed1eac0a67909f621f846fd0466087bd20800503082e30dd91344636088fd649b71d852e000582e50038251e6492fdea7d6105bbe71833b32302953aee5337c19840fc692e39fb48690ffa360f6b874e01d37c52a514e402a8614bd45ec7e1092d1323f365bbc696bb1b28223480f683b10c1bdd59ca7fcd71751c90e8f33ab4bbbbaff5075021975a1c6d6609b1c1e0ed0aa94d0a768cd4026bd0d3e4654ca66bcf6e80ee3db9a0c2732b6c4e3a00e681787db6a1a9f3842bb3e8eb9b852095a05c97743fb4308b9f4f51c68c9e566fea437897b3d50af1c8e84e132a0ee9555fddd4e6532cb80b7c8c131aeb8b300e034c701f6514f7cdd307f764355867232a2220ee3e1d5d1161ec79647d2ed73148aaf4c07166799760f772f5bf6c744d6b12e79452382561d9f82e547ade4131451e2ebadcf2c016c99df6e19e60001f20d7d194d632e0fe1850b2a07b5b907022bc27f959fcaf41f6f38494795565b94be955823498c1d8129a4d9238e89d565b1c87cc2dd1308ae9f9cc8614097f2f4d224e350a2c5f75ae46c4ebaf177427b004da8f099dc6cbf035baf9a1a7816b853beba0915c1e85c3bcafde0887619469b75d6c9581502223d7fa4afe2b069d6714d3ca3f82f8f823f05fba6e2a92cdb15af67bcbec7f3762c1950e6198f0d323bbffd96ad9550f41fcdd462c2101d1a46ec97ec9186a55171ef6afe0592dee844926a70c175fb49deb0f52e115da906061b99a2726ee8b3c33fcbe4944edd3da5fc4bf9aa84a4355d9ddd2e69906e752ee00aabe99ea7f96be6c6c657c9ab5909d1561304a7eb5814dd12e30ede9faead17c83a8f673b18a743e99880f72dedfc3b9ac9eaa2ba1a607db5bd557a7632ade6927f31196109734dce9ae7c78b71585c930ea0ea7807a5ff156ccc0b9b774fc4b247d5365f4fdbe005df228f10f96ef8fc019bc2f4481c8ee1349b0fc449f124cd69f62cd5d2a0b47748ac2afc0951443cf430f9743b2ac89108f3359aa1fcb2d6aba55ba263c647f699393518af8dadf58ffff4a10b75dbba8aca0d63ed7059e35eec247bb44514a29061655f1f72829990cfb810c1f7d355f0ca4db94d35f04cc131151ec0df4f57dbb4cdadba0c0aa8e8819d510f67d6c9e1b3e010804e921640613ba024ff8663640db1522ebcdabe47304122f5aa88ce3d2aa69bd4848c3451220670bcd5ebad0e08543ce2953b37a63c7b355ca93a3bebfbed9117cd1ddf0ead467fcfa6f2f84335f2686d70330e7a7671bb9d203403dc0a672897ab6f90ce8807afe375c70e354e5e99d22ce00cb2864345f957385d737f36d36e289aaff37606ac6baeb09746df602a4311fdf63a21c6857e1200588e91a4546c9452cc48cec0f17dd83301a33ddfc84bd8a936af8b221c0c0940700d041f4c127ade9097252fb4c8e7e6589c217902418acd18820932808fa79166dac6df5f823fa7e259575fd55997161844ce0bdf6cdf89062d2ad2f520d7850e339480143d22dbd486ad37b9b06456d670201f82923a4c6a899328e18bfa104142fd07feecd944ec56e20ff7f8d11c5b4cd1b7d26e15f37020a09952c1436babf85c15eccde873643799c83a7586d3917082cb74807fbd7de67d123f9d994e96ce4c35ae314dcf214ee05a5c5d97979c1aec47ab418205e27e8aa94554aeeaf3a392fc2711b30876c20f8eb572978c8bd8bcea65a182833afe154cc01c1a6bf19376a22b6e062540cb64a56be01ec910043bdde4a3c82b3e55b7dc05a7f9359d5758c53785ebcd6865dc64d261d0abbd3be0f2d61a2592596563b1932bcc6b8c0ddb7eb899e3f661646af18b6658974ebed42f70afe4c2ed3c49de97f9e4bcd957202f1d1a2b5cd24113163ea894ee1041011257b58c0dd8267162c607cdcb755c1660e3969c57af5ad05fe341a6efa5e3d7544589c00f8118abb55425f82b5f6bc20c113d8f20d5701f60e122bbef3e0a5edc5efc1d8fe0a11993678e20d55342d0523ba23dccffb9c80469da5edbf8b0924c8b66579a2fccfb18dc9b2c322f184dd14f35df3741cfd41babce449d94cbda2161c12d48aaeab98bcd20fa9742fe052ba8713185145e696e6c3f07f582c615edb5ed5f1cf8bb7fc566450c7baa93dbdf4661ba5e236a9a8cdf87c2b409d202384796229d21ab32b1979604319ac5ff0aebd73c126eaf6bb91b76c7d8b308a839e27c99007d46dc699ba46d9fb67284268a5fa6bbd1ca46dbe0a971ffc30d279e9def2ebee07aa22a6621b92e60bdfcbc6520030aa0c897843fd6aebc48c90337698ec6ac6e72504114b3d8d172d9fb8126d0fbb3585bd5d273f679a162256a786502a81147c49d950044c9bbe7579421c1c21a53004c6b89acab7f09be02e14ef26b944e2d1a65a280734ec8358b906e59285d1db44a3a74fa7a6688e44fe6341d45213018926d67df737412e0948bfe1e6c5c8db8cea1c5794d1cd61b14482d9d19bed29cf15b5b09d73da181c164cbb3f3d258a55c9f24517e7f866cbe4e6a06ab1d16772a8f3a8517d2e9fab8e1c12f33d49471bcb8f3112d83584684fea4906352c3993346922332878df06edaca8978e28598b944d62c4d835064f663b8dd9684f01804a677dff4b0ad7303d192eb424f04a8f5a878b9b6deb2cfb740437438f7d2e4744a007b82acaf8e4d0191c8fe503ac623c2ec0dc54da4ecc518a2d3d337a96a6359c1b0863580e49a0c11a93413362a332172105616b7cd0e09adaa9824ebe42cb2356e858cc418a68174a7afb614c6e63968e2e8b8f261c0ea14eb5def3b5a86b34e59598cae7b2466a62f7541905f6a9453543544e869f600c567e7824ba22b9d60b0655b436bded9ab592ad367aef3b4666817053fd32ea9e0bbaafd6e86dd48f352d3975822a6cc75d02687764969fa0cbe4add69066583ed67d88ccd9bc1e760562fb74284fc659553e6a51bbdd3855714b787c6b909e27c82d0ff7af29fa2e2956aff0b7cbb5332aef9a114e462a54eaa2826adb924c8cf730a70aba6585124ebcab898d489300c02747745000341dfaa9825251489fd800f70cdeed1d859e7808e88fbac5b2bf0f6f93aca7f5a1440be33ae2f10672e7ba6e99933b41740afad0b4c39b03a90837e1203dd7d256682a824238c9567dca5994ef0cba7f4556e48793963f1047bb89fcd7cc492ac9ce6e93d003af2a8ca278082b37254e1fdee652253807c089bab7a86401491cc0e1bd3345cfaabff7031d818acf536ff5b517e5d06059e393a0fd7dfb1c36ba064ecd774a745889eba9cdd1352d01d9500cc5d43c2724f367c162e633af963fde8af5cb591066b9a2407b8eb82b32819eafd99f53db9ceaab791977e6ebc1531343617c5ef7acc7171a5a50b9801e1b1fce0a5badcfb77564be71aad40d72e12068875c66c6f6e3d78a5223c94bbce0df7bf8b16405bb728d023f5eb8335447bf8cf43efadf2f262eb247f7c1bcd1ad5ad836defe742ba661157b3632a7987eaba038f8b32730096e49579e1a56153f8c92b9c178c47821bb57ab22fdbf14979e83f3023c6c61f62d06718e3e9db825eb69f62c26769e2668b6680eb1cbaf69af3fa6b2baa1bb68d2ee8e7a318e984a1c464b84678e463972ad3486c91e48e01af312e8487d5e2b40c38ff1ce1ddab2c0fff7966c70a1e40c740c6dd6fbf1f79d34dc3c2a481665d432a5f8cbe662050ab40234df2fdef0e0ded25918dc2bb4ae9a62e2d184795eb7b586ab89fd4a472a50c4e7cf708f95dbaeea767a1246b1f94b83ae14db76a759f1e4b6b7d23b6d747c7de719bdc751516ed2a56f6a636366eabe0370c6484165dcf6a44bd3781b2b38d478eaa6d3ec72bbbe44b06a22065e5d86764fa8593d375a68126ebb8757dacc19343b1f907e5e1ee0c5db481f43ee9ed5d4bfb3c1f9d2d664d085a6e026108b24c00475f59b3222fa3b896b94b112d894f739839489d6ccbc518b2c694655e90c6d9947622bdb95a2717a29c5e6d16adc587ecfccd973a475b7f36d908cd14dfca000b0cc9486e12fe793bada1989034ef183e3cdc87ec0aec18b80922a030cc064bf273cf9d56a3f11abc23f4fe9ba33112f8b2e8281384544ab5b46201d324e9f773b020fd5810383639dd92aa2bde2e42ccb1dbc50c327ac7f1cfc5cf8d00b70cbba99a0a8005688e421be06efb03d34fde2557156acd3bf6669c6f088b7b2fb91d26e3553e92657759c05ed24db61a219f1d78e7e9313b7385410e61e66b5a787aa21f172aad328e595d72defdc6d5c915f32e55401878dc61102656830cfe018b91052ab0d16d9935a004562c290985564fc9a90f440fa37c341a03ce0a47090f98e8c7114882bfb49d03bf6e7ab1ec33f97b368fdeb670272be88147469a5f3ba85462b41d2b323437dcd223ba132743ce9dea6189c237cabf208af57ec330677e55911982864c5e34767db1a4cbaa5a611cff21199e13e9a7ad5734407e83f32deda9d7c830f4ed2580e9b1b385b74dffbe0bca2e61a56de7c6d333a028e62a9517caf9593bd01e22a514ed6632e7ca00eabf1ba2732cfa57c5b53341587d7dd69eb7b56cac3689eb83ba47a4601943f5065095445c38f303b01fc748c8c9bf3af2087fc0480dfbb71edb8b65b9ff80a40a7a2636526269a6b83ebe95dbecbfd8ccb22a07d201c8c33142155efb7b64c374e62f21454d66febc4b45d5156da38b20f10dd154b50cd26048f348b0cc70638f7250d99488935e4bb957cfbc08d39884b7181e04bccc155b9627a19b39a30209c8cc8a2a99eadfb74c5924de172e5e6d0a3ea41950c612732b3ca55f5657e86c738c2bd6ead39e8fcd4d03b88f092e4f69fda7ae429ed838f84eca099640b7b43b6dda6bc3aa663fcd106af6396bb410b8d665d2e1e93daaaf29eef5875afb25fa40f351302471c6c5d706611f1ddbba7d2c054301b225cf72704126fb915f505102a126a183d5db2eaa2b81852146dd3a06d8d3baf7f7dad260c2ed50cda7c414f0cd6ad25885ce61f087302271a9739ca8ea79210f7acb829a40d49c6c195912c7241aa5e6f55b355a765f1a4d2775d9ae56d67f0d028ea90089bf1f88f29432507496248d08162a4af54caa85f4eee791ee585c20b75f4e4f891f672646e327e4158f6801134e71a89bf4ceb1af266fe7eef3b0006e45bc2db3be7206306eae213ee9d23e42c0d32124f7e09963748af5cb650305915e611cb51b9e926e53a463646611ebf8053fcfaab44b797224b2db2b3a30fe910d4e34ee5c3da4ec1993498e68ddc5ce900ff2ccdc10a031cc80384c9b1dff381ede6b4083f0c6197e264e999984b0984419d3a5e9860df45ced88d0b910c361d69efdc564f79b85a5b89077ffdf75b053968a62e3a5920188e8607588d46baec24f9b6fb0efb71b171a2300748731560a1c89dce3779773a1c6e702d1d3c40859b2b936f6b466f082523c7a6041ef1abbf805d5c41268a4d3a5eb809f2aca44a16de1906169911c8c0d4fb9621d3b287a191aa47480746ffa1c4adf1fd095c5f9c80c10df75b3b8ea1ffe7c26df9ec542de71e78584762c32289c3988a19d1014b8de77e8338a35737d0a7c2dd4f74dc2129f85728421fc89d03d0591307ac4816aa6a8220b0289547f992ecd657a29429321a4ae008dd8a564b8269b3346eccd8176d8561c31f7442f332ec97c7e5ee831e704ffa7f31c08ec8c3c54d183896d56ad7db35f58c9239cc10383d038b338dcc5f0e16aa70725ae1f8dad1cc53f8cfc087d456f2f753bf65cc417be3ce5512d1432fd2df0a63fe97af2aacc0cb39a2c1824454f450febaded500abca7fd65bddcfd4640410d1d3ff1be2b7ed62aeae0d3101ca1a8436f2b87ecb315edb08a9741dee30598231e44d3beb620eb885d9335967d2c36ae5b4ec7dd7bde36597a57b1dd42598e64a0e1e083ef56bbe407cbfdf8ca8457bbc240772b3af2d54c4891d37b1fade1ea493f45b056a5b1ab8ca2b40dfb9e6d677bd32a05ee9e833bf91960952c1936f0aac5ce4955b0d5f2f27bd06b97041b442b35ee4a81f91c04e69b107512b1f3824ea19c1c6ef63719ecc73a9f0d1e28a8cd6224e66bcc4765eb3d0ec7340ba8a72d4b1d70c04bc7866d4f47f2b84abfbc0ae9acd80a9a7129470a83fdfb7be6a045a30d2bdfff18f5e22f1a105e9e30fd5ce92a3d5a782dea934381e3adee09f5afbc13335b9a1bae5a3fa9e401d020c31ce8b7d4aa7d3e6f6942955c533e7219f49d74d5774b396fa7f8fe69b4e07699221de8ae724c039b175a0120dade1472eb7acadad434a95d5952230072e05ab161c6d51a4b8e9e68688dd7e9b60ed55d412df9ceac5992dc88a0582379c4327dbbd62059a8e6c0c078bdf8a95840e7dadf88fa12d0acd82834f8d597c9a4430cc71fe081cae4c73dcef1875d1220d54bdc67b2f9c2bd45f91236d790e7a3cfa21e8a44928084103e1f626dbcedd69cf1d57d93634aa261b61c83638be05f407ee503c652b9d2bb3708a67d5b8468e4d5f446ce91d474885922e2c52f79b7f8bb9257f4ef75951cde3e83f2793e0720f9f9190570f7900f6a24d0d764c4b71e7acdf3600db9b10c43f0f6a1fd1fc044dba0054a689a6967a035ec7d2dab4c2c940e1285fc1635634a4dddd56b488ac8b90767f62d618ce5356f3da612a1a093e9dfb39eda0b0bfc8d8d12603b91291ccc1afff6c3bc7cffcda4c06cc4fafe1f61f9e0f44594d5450188f409cbdca3d565d551aaa771db6cd66c646cfb6963b0523b74c1a811a7b2af534834c5721b4389014c8efd9c2f2aab6778f5dcacca7b6ef1c27a3b894f661ca74c707f150eafd8315660768fb06577d4839078f295284285b68eccc6f76d09b917ceb2d5b85410c9649617e02b966e1c63427d20f6bcf115086a6a7d87c8dd83a54c904009b9870874eb9cb6667773d7bd78c0af7a23626c7d9ddbd0bef5f61921230355305cccf27b8f537f2bddb233ec62872bc961de916ac95bcaeff5dfb409057ff731b0dfaf97a172c4dfe4080600b0a1bd1ec95d4a7aea31a78e1b23d3a3169fc6413e3398b1e67f3a4fea876521d678d324e72dacf126555cac460c0d895d33374f32bd924b33ce1460502d1a3572d607c18c09c1b3102296165ac16e5280f764b387fd6cc05e6c45f8528dbff27dddccb7e8f203d70f6ed7c3509b5f69d704669c7f05f7d4177d977801c550a2110d93442fa1392f2c6582594b17c6b0c6c497f6829f625ced2e5b9dab97b371b0ab5123f135bb523720c10491d8316ed1ba2fa96a1a0d9a38410356f33f1603b891befec89583e2efab9ab5f1cc56ede6738217edc9c370de59d872a8df7ecc5b5ecf7b5a2e0bfa0c9619a3ac2c5925506a1d2ff29bbe73ca6f84f430a53b9054d2b9e21b4cdb51cf5c2cdc5640c6e3e45cc81393d7a3dd28ef3a1b27c1e70cea6e1e8cb9a8917894b02674520eb8756a147d50923a1ad4b40b6bbf43718bbf0add66a26561d1b421e356c8e0a98abbc89daf134ce685f8f24bfb89868e2664fa09ac2296bb50778607e498de08dedfa03098e965b91b0d6f53deee22b369461eb2acae07657b65e2eab686748a8212dce978b4cd5bb9b4bd3f16b02154d30b9a402d74066462f59f6fa54f97a0525a14fd8ef141d1f63c92f1a7f158ef9694cfa48ddad68e0031734a1db9c093e4bf7a4adf76a740691139c10553417562d6173ef4349375ae18cc1f7f6bbd6a720cf909699f222ef30c3b906080007148343fd6cfe4c2bd726978806004ec1827dfd7cab9f2b0f3d682b1739f52b669483187417ff50d222a0100939dc4b65f9b0bf32ca6f0eec7de5305e3fa5c3c86e4ff1473e34d9f640466159976a7f967223aa53277fd8b8d55d932c5324620e6e42ac9f246d2316496cf2bb0f6701aad1170281c28c43b54a980fc4c68b08ba9fdfec829ab6b933b234c5e6b24ec10921586dd4bde7dda5d51b01e3134a3b44e52398eef6be2fb07f6f3bd3487f4cbfd58a6ab9ccbf26f81a415086119ba1af9137cf94539e9333940fbe98eaa3ea8e1e31195f34913c82c07cc495c951e597c577bcd3b193559d8b10d91b5a5591de1d6647394fae3cde1cf2cd9c218e3891119ae8109d8a5586cb108693f58a2d52fad3ba0f3404a72355bc0ac74f444e390f8d1024e448e164fc3ee29fc4b4307dcaef38d3f1015844588b35d681d64dce174106aa29f3673f94e0596fa1f78e59a9da0a2cb3da583dc9e4c49ecc9044c328e6d2dd6dbcee2e04bea6662aca70ed77872311ffa6b63bd3e32e966cba1d17993f8609bb51ec3d7e56406fa8e5a3f15cd2e102144b9bb477f8656b5ee2cc2d3d215a6143be3fab2f82c5c1c9f98c205679ab99bddbf6cb744e50101b4629fcaaf1f2469ed831a2fe3b282a38b988eec540ec6b4a7b1c453a5ffc517b9308d9bcb2d6fa166db28919831ccdb1963a5a8cdfb1b042e0b90048be73e0a37aa64602f01a3df6a1a0ca9c702882815a81e766149e9c77c081b786c4aedc562a26a676522f9374e881e1aefbb3ca40819730f6f7c8625becf7a58e1a141f2d753eda8db5998cefc9b93568ae34c42b822fcfc3f236371d428ac7309f9512ff289c972f833d8f3449292f3ffeddc9d57e3512c306ee1e31f4b6457f36fb381911aaadc3073e02f25b3b3c60b8925b2882f18e78f6a7177f1008db77e21db5b58215cce527da577445cdb2e5af268852f6ed8aaa80237c322182936e4d8b8c811cf406788c051bb1c5a5e7c3b1ebcadd42c76868cce571d9ec3b7372634f42b80d63a2368b4d0c98e0bbb913c8ce9856f948ce12c5d8b2420e04274ae4903f66b28117c4c1f807c1d68b3efa9b04b2613f6a7f7267b06554696e8d3d9a1dfe2f75ee9d5c35fb436c3c2e5a8df86c9decfb683d22ac823bbed47534bfb0844584e392eab91c088e752810bee5f39e7c69cba6deca800aa7f219e3066a52fee8d88847126a7aa4b5504621622d1647ab81eebb34a8bf21ddb62e1afdf0284ede6e59f3ab9c5e54b555d42fd21156d2abd5662d9860ac51831066ebaa57c3e2ff13dff9cfd351ddca4808313a9fb452288ed0cc311e8fe068f43c93f1d1abf8be293b2aa9a0900e8d4a2e8cc3068c529f237f3226f964f9e1ad9ab3571ef756a5bc7de3e67ca932fa80c2c262d471c31bda0a4c5c383f6a971fb37e2abf547099e7ab0a4c46090e8d433f591bb08e5b33010b383d24f275f4a89b6e1a9258f987bd896152a409aa1216edf2068ce7b3eb291e8d149daed42c2fa821fa8df7948842431cfa192c13b7a340886e5e9e596ea1d7bf509186d7399b005e060fcf98370b332ba8a1ebc6792660e5a69df7c4087e1395fe4d3baf20b05cb04ab1a80eadddf23df95c06db8569398d75cb0c749d7e836ba01337cfe22f76b5425ae83ef625fcadf35a1d5023e8173dbb11e9628cc14acb622c64def2277192be3e273099b1cf633b03467eeb4903e5b4cfe7a253f1cfcd1551d2659eb8d621329d26ae5849afc97819da79acf2ebd276578ad235d243b368d17461d23f156718d913201e2b8d7b3fdfd1969bb6c8a9f28ffdf0d16d3305fbc1f90f3f75d26e683c8d40bd4a8586a25765e169b8449ba33f8ef57c1b33035d818dfecb5ee1d296ff8fe103e0052588e3f8fd8e8191a3b98bda2ae344e4b1662177aef2a619f1d45d859c5a579474daf5ba336fd08061618fdc3fffee6cb9b1a3bf729c2b2ff33009e361ca84a8cf9b9d0cb9e34d9918389bd59a5ad4c53b7754fc8112980338afa3a2cb94fc320cb7b3c17bf2100c542e878ee6d86c889c1a5e9615a19b08eb3a43e8a31737f46eb295d27529b6ad5201cddbe7725a7e2c795f880fac7d85c148744f8b1a6219cb369c0dc86fccd3d1d38f771b7aaf4f3339d90dc4bd7df9b081b7ea703f84f086ebddeb30b693f8dbc7096cc4ef0edbebecc9d54e31e1e2ec7caf6277dc8757802145ef5e5e4543e26afd80134fd936c7f31563e55fb59f9bcd37fef54d6972076a6dd0d09ca18af8211a3cc65de35bda39759379308db1f9a2351f11ee91bbb2ad5c5ad4542cf61e70ae5db21312c43788c3d0bc8b7f9ccc84df3cb8f2691a112b460ea42262ebd999b40783a5e76061a670c365ad5ccac0bb77dde71bc0a3f6e9beea0c805de2f568b71bcd2f9ffc059276108ec6040b3ef9ce0d27409446372e0241186fbc7c590550f486d61459d67d8fac33e5bebf2dee6e7deb5d817008811ffc4974e6f23dad93906793e4be14c4f53871fd105065fac70c6a1d429a986838f3c3429e7f6bb58ee6cb4a0aabdb2294a92b764b6f195a616b7711f421f6d3a52eb9c45e051733aa33965b3f7795e8e256b00c910ddaaf88ac3127f94580d8894a62f74391b9ffb2ea5cd62dd028256fefca1138d12ea51566410d6739bc5348e9ff9ca595bddf8398b7dcf5de7ca62d2384e7b92eab6a4ee6397cb93f0d7b63ff67f791017bd329b8f3f81fc4900064554d3fc8cc86c9938d7f48b6143508d7e67b561f270c7a56bbd7864c28ce43ae316f0fd9d56470de9a7349739f0e5be138c1828718b62941ce5946f60ec8162ccd519a98cbaa9df8ca132a8a4b53100ddba8579c58661e2fd6f4f376de08708df7d2ac6c08a30c86ba228703f02d9eb113b5ed397fcfe86d8c1a4e445c51af16d98d8f1789ba337ad467f6e2fb64c16b5c701b00233eea9f8f0557db8a8e4df1370744fe832e58116c51a02c3153dcc8ccc676dedd16a071ad089dd2198d7d69e38049593aa772f57b94ec8c4d755498807f07d6b0768493381dde76b73f032b20c461f457cd2c48e8d5c7afc9799f2306a4e6fbc42097e2c2bf3639189423885d4266e6423ae72bc2936b21d77e8f53ceb275e50116ba5bb4e5c1ffdf3da4c3fa40e0b31eb58038e296b16eaf8517d393fd6327e318fe455f8ce8a61925c142b3ac641cd16c1bd03456305e3a2f3ecf82c0027a284e862f92db5437c02fbf770b2b393d520796290601ea695f6254d5b99221dcf57e00bebc6cbbf3f477d27afeda87c88a0160d1a46388e4e0a0d2844a858558f57c1cbd7578cf7f93d0f50d4a1745b56ea0c5a2f53a6c926ac9fe9acb6d14994acf13ab365d9b2864b60df07d2aa297dce90a6728af77f503f01a5f5e9411da8437487ae909fffb3d0cb208d6f20adba061cae9f63509c3b01f7a83f4e0ba39a175a21a13f29e93b00f4fcc720ae86bc5a682feca24974ca32ce997154ff9937a1ef0ec4f74315c7fbb80ed88fc77e3a84e20e8bd01caced084e8c8ea4b76c307c65f69b6e632f4a36a5e54b4f8f67ee41cdeee7625ba17c48fdf32bf38b57fe06159e24da4ba5de89a2358c0ec66aa6bbee85d769ba1409af9be94ef19d7247c73c0b9140a160d1f17cfddf1f5b84fcbb50e8be2b469785bee3c1078744d9669c40e748df821c4410724418bffe6818431da4512d0f4504065a034d3551e9c9ecb275dac7d47be8941c6fce0baa0a0557ea5051cfd1ac9bcf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
