<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ebbaca7683271e5d1553a6f8f66f81ff42771f316c8ac900117e361f47e9d9680938f8eca7bb2218c45ef7f08aaffa0bf31b0a127e1840b24b8aedeec2411d1076c692749e5de1d6433429a57cd86ce4d377ab16c2850075a853c4bb6cbd19e9d963f23b658ab8d78c95abdf712c618b236b22a96cc6f16be0e8b2d0097e1f314e9e7627ba0ff7580396cfa6b3ca71f46b71da4ff3829e900a592e50495978480bd932d29046de0fb167ed6b8d6c81b49d1f76c9fc4f69519e52e965f4c9df42ebc613c0a6d46af6ce70e9421aab020f8f0634af47d596a496e98d27daeae7fee0d2a17b286b94c16d0aa0473426041f74dfdb6617d06e607823b2c223cc0227a4482801f3603e817f972f6c4ea2950d55e7bf52037b8b5d84299a9144f4a21dbea2156a569255bf48806578452a470a3a83fc81b35572f95b75841eea414cb5a864e180163882bf7218a80e51c17ab3eb853ececf1957b4cde831003747346baf58444abd7982bc21e27e7afa4eeaa386af08f11d524129d4813a6ed521c7742060c8f32db4544058964b606aa36d80261159e8ec8fd9acfe479b726bf99744584f331b21653472e438b28c61115d96dc7a81bd994796c0e293d07cd7d8ecdf506f81b5f5a3657535d4e8d84c49f0f4d44ae524e3a6eee256deb8e100a664a34ca1299d939fc37698a81024db13c34007f6106df0a07b632043016e321ea5dda4556403f244ad35c5887ffe6ea377295224ac34f729695de00421256647c1cb140499ca145b547ddc53e4e08f4b69d352cd9f08e0dde81c6d71b66adcbb1e0f88c80437e9b98720b3e0a3348543de44ec82b53dcf0aa35b871e9b3243e7bb7cf7168d57e1e7fd89ea0278fde128bdde7b8bc2d3712e3e1ca833e165c24b4af43331a13f6489adecf205178068e9312e816ff7a312402a2d1ebe87b5bb2761ecc79cd22fc1d4d9950b979eb2c37724cf6e9517cd490f45140f7a8a492f6397890339c9fc9e41a4a3a6000b3e3523f34c48a805f97fe769da35b6ed5e884b28ab0a63c8da6a578307d1a345c381a45fb115a6672b45e07050f0b56915591dd3beba97617ad1e7580922e66c2246b438ae14d660b9ae5d229df8d4cedf6ca9f6df3a01519f7f32beb91a1bb3f42207ccbb677762f59bccba7ca94144283a015954190fd4021af4270bbc1e379f3e46db16e5e410ea8c72e78d6a5dd436a65dbbf1793538dddb053300db87ccc070a155e00cf1f46762d75b5ee235759241577c39e5a238b45e19b70d41320e612e4dfaa2a959dca0579810bb81c2ccc0d4cb453f1888f499351ae8fa9cae1f8710254bee4a515a2ccc4d38806fa54b7e3be6e895f4403ecf08616a14220b6b5498b46e9520ef6f0181c2442da2c3eeab4dc4840df7effe1ab48fe962629eb75ed046587797540c985cf8335197532ab71806b78cdd056988831f125c77157362aa924c3b6a188fd49139a6df91286893a6f103df5ef50181eaf0a7ef8b2d7efc7eef15c605e94aaf174bb9c884b5581665b17d0ba0fae6618c496ea997477e513ff5e4b975a4dfdd068c8cc77ff23627aa2ffb5ef489e7808a31da7546d9f73335faf50520a641de30a6c8121d7e2f575d83a0f0c21e3c60c319027deac2a41ad84320dc0f3eef03e9cfbc7c65b62e564190574284246c84f0f956df4685c4e412925e9bf4bd2e871de998caa345951df9b6a0d5899b2c68fe4fca2357cb9e35b0b907b667a2f3bef0330cf8b750f51dad87eca79ba2ef84e7cde28d4e72c145c12f230861a9aad2d6bc1570f3cd01e423690c127c744f5a2a4535dd67a49c933ea8b58f4317628910d42e16f9c161bbcfc67b8f6f3b05d9296ba2a830b05830b707f301890144b55d094060250dafc1b40c549bf0dca5d1eb37d1ddc008902d0064b640f56a5175fa510725d9452e3ca8f076ed713206f401a5823e78295ae98c5099d1dbc2f443be35416828af5db99c5689b50619140d93ae998512419c32f9c63fa8967d0af33ce83e2b31852d52374b8200a534cf07089e786b7351fda10bf44773642ecbcc85c473d1845d7d55eda4301a69330da55d1b5fa5fab7202f9bd95afd12633a52a64f37cbbea668e08ece9011281545a71857b02d2479df0a832a0c871522499fa06f2c8d94db2a0ca4eac16b04e82988a68eefee6edf6263c7498cd7cce4854552801dd09518b4e6b510b3ab795137b878d20e16f3213cd1efbca7c921521b48fd2e2aad4bd923d8709c9e1c8d8b4a84226beb5579253d2d38e987b7e51a67ac4eab115fe733c00957b534bb658168e5a91eca9834dbcb5e7685e0bb7ffd12cb17fdf9a996528cc17aef519c5dd2634b93c824cdd7148da051d124f6f6a7ddcba1e35ec638752a65e7a3cfdaab60940a246e1c51ee9a313b2febc729316ddcd3044979685b9c4f9ddff15989d66d0dfe19200581fe83e7847727fc23cdb97cefe3daa07e872a431feddf562f1568a0754230d0f410944798f1154c90f8666e1d41ca6c38538a2df2af8cba5d0e2e842343ccfea0bd6fda246dfac748dbe01d16387f6de406e2eafabda3a3bafef08fd8bf64a0ce6bb44084d07aa6f783b79d7a7df0556188bc0d6e798d3fe98722ebe9b0dbea013fb53f167b78fcaa5e9c0533ed07dfbc2c2ddc987551f9a7dbb53b45ebbdbd38f107a29b6d66316539859e4208a055018d5f490fb195c27e8d9277a2d3de54f0e8203da4a553df319b9ebe348760b6384531fe6491ff0d488585429348005313c722f1b3ef1242e4dffd07acdc1c6cf64c1b0dd20eb131a86fd492c9647fbae6a8c9d134843dc404c11d3c1b962e97089da3016270d6bf7fd3b0a849a25395d57fca6fff4b9cbec87637b8b8820049ee9b4277f12e50e8d4c0e1bf5c413bb632f74ad1f940d9513b82aee78604ad224d5295d6390e1457ba9e44057c586b64a7eb520688c0b680f363db8696a0bf82e573158916d9742bdfa95d7c33b42b2dc7155eb5701f0046e409deb86d2b4435a4a1df22194aba900b70adce507525bdb62c67124845a977ef590dbb5ac1f9d9ea8d5ad30ebe6af1725150ff9b13843e5ea32a5012ea88a0e3347992b2e2688ff66dd092df742556a5bb46fbcbc7806a63b77bb721e23477ac601f49f5ded3a83a676702067f7f6bc0b05675d8038aa1be0400d63b563efa3598adffdaf369cb0eae947dfbe07e27bbd81cecd2191939fd9100682460c94d0862f0a0ebf56c827e8e0ae3f201f5bcfdc096993ff9b4c867fe77842901347a1e5e1f8f3b724aeb6991d023c8f9737e52c85e9b4fe44e291a9d088ef54887b26e7192e983a6fd8cfdc94daacdf8e5d4b5e6b54a719ab74aec5e356ab31bb8003ea3250d8e71e8b8b5017d9e191414aab2ecfcfc1e43c3a5783b6f912a8b556804ea6db95554c65fef5165e59212faa1ec37ce9d3c9006b267e75056a623895600c2c35ed5916c58f815193c291980fcb5bd9b33f3add54bb55b0253f0f265cda2e78c3acf66674c4b4aa58a0df11a45bb28e8988af9b2a3dc7255a0cf997d1268f4b4ae17cd4323e893c83e752126bae6367b471f40a5c72d35fd38d009b0275a4daac2c7443de089ff0e2ced9b13ba80497feed2679b18c46d3dd4ff5c2bc15d8c6ee3fcfd40e238ec5cf57f3bc20e3d24ffb6864dceb366f24c39f5652a46c0287d4ececbf4ed5c6a0af3072219da6f7e24a8bb817e7a6459b689767f37e4a6153e304c2c914eaba42729263e715f8f84aa26c1b0d44fd23796f9c4a82f121a39e20221eceac2166d9f993d14ade0c8936ca62e0a244cbdeb3540ea50497ecc70d03fa2e9e3d7189c7a1695def85ad12e365844c5c94bca01e7aaf149011f9ddd405a490463705ade263f6422e1f3445fe61317af6c2f4f75258e895e5d1edccd8654297b302b77ddc82f31d831e57fc97dbdf34cbb764d3c9d3a41e31ee994f953da1033a3c3d8756dadce5161d738905cc2367b13574ad0f54a8abaa97c0d08ab6b0c88ef5f7cbc3ba17e61a74ccbb66b179b00c81fe2b5bdc2c90d0e7f4648c751edc2a55622bcf7eefddb0d89308952a49120d2ad0db4a3855a6111455d174259b28300e5069104f62bec373970dec786248c1fe37b55ee63c4c32265aaf635cd817890b484f1d0932271480ebc96b89648852d7bf65495d3fb4bb7cea2dba2a63faaf89b14b8d5a4e92dd165a1f55de331a8cfafcd9ff5aa153b184ba8c908d66bd72cb470be452814e59ea05aacfb61e7593e84d432d3f32ae7d1834cf8235eff2e35c3064ba77901f539795cb9fa56559b25af4f832fe2a45681a25cd677a41cf06ec9d679f0cc1a59f9b363e57a4cd86053edcbccf1190dc7fb033f8cd9b0d17a3c53a4c50391da4ff0a279e9b8c2e52f4bfd0726c3f7dc9383b513df9c549199df0b661048225e26632d53100f658343bc27f0a97303dbd9409613f36a866ed8f88e2d7f4c7c21c8bbb22dc8a9a3d87785a07076d5bd3cb665132f7076aaefbd3b8495f807b8aa97a4fd084ebd968718957a7f71ca25ef752a773cc1bf113b6141ffeb3f75674673db615e7cbfa973f1ea4314da5ad580ed3e68f8282faec64245bbfc31eede66e0fd24740c1d12619779cc5e9a19aee93e34eae09eb0857d9d87c79cfd9ac3f5ec3b4eed03768b00d044b2b791f287745ef19dd1f46110d2995d8f7fb37f88327953b9f8de8a360ce0533a640cf2a0e41d87adda78eebb56e68adf207c2a91461e5ad288879cdec97966779c1b27fab0956390a29274b364adafa9bd33d8323047245e0ffc4cd3451c8a5fb950ddba562c741c997e30306c0c7603e52eae38c7085160ba27d579ef264daa45c18535aabd2118809692fdf391cc40c92ef4f65bb005ad51bcfbef9ea0150f9487efc98a3a595a28cb24e1d171d8043c1101a8cd83f9c8d06c2746e64605d4bc243e4614586c21cfca891c194f05b84f2a9b1fee4b492e6b1f6828ee9959141b347b5dfe97cb54a04ef78a9d09278a06b3fdc50e8d90268e821a6b7e39120590ff717ff283d3b86768dafa6c27b37f8ff01eeaea277639f6b6e679bb06c2a07a9354a976a88435917066e73d7c8b86007816d35ef8d0a1fb34a6eac4529f48e0f0e7fd57498c1c49ac71b351f7def9cf50ff375d51ac654433cb25f24f20025cffab1eed509a8f9cb223ee2524be84c921da1ab65958483d3856f40f2ad4489175ab59876ab10952fc3ea9457e48329870e1a4bd47b151deb607f74e5accd968a8395733e1d4be163214aa826db6ab1e3049539c1f32810305fa63bdd4458ef745ac4f788ea7730def4755eee088e5f7c1650368180bbd87da3412fd3df2581fe92219f342717f0b4031a969ecd55b9f29bcbc6aaaac6f194c6bb4374b5dbc671f761f4dc76e10f9b20222be69b1b8561509a78c2e559c4c6dd52d7215df8f77ed6462b58b5d7e67d0794cd4005dd17f75bbeae15125cee19f895da43fe633065eb06ddd437aced50575081f293c1e978bcae414cf76a5eba667e38a63b545473d8e8556506508d1b5ea8a8f5f6c334e55e24d55ff0855068eab423df690128b528f4e0be50fbde363ac93dc3c6c857f50cc2d4653d7730d6903fd308e97516f078c1868dd875f023ff1513ed1513cd750dae5e1789cc5d9a974bca174818560ed04b3c7c7f516b384bb61a4c02ab449576e1d6381a386706dbfb9b5a3468d840b1b87e969945c678dcc5c6d199ac9f2cdc6daf974bd40afb5daacd3e2cd0c4447f728d8b3297ddf528d33e61288121f6977c9b0544a0cffa6f3570804b6cb8b26d289ad03160c2be7697cf1b5e5336b55cd5c4831ee3b031db52f9ae9c39b86d8b316b9af01a294413453ae23e00feb2ebf192a1d2a6cb4a06cbb11c4f8d80e208bce34d68e2e11e518e36f53063035515f0fe4de8dbc650b17da4c445c4dd3ef6bfc07718fc07a98809eff03493587bd8761b5684e47380947ddca702ba4440577c371a652a82aa0d899916bd9467955128c3ab4058e62105e6bc771caae83db128edaa9ea464487971803356ba7a1ddc84d1b8640f8562edc4d412202166c59072a831aed7b0b4fca5857c6cd8c2702f4d6c48c41f1e4c7339fb2b588c954f79779b6751ea92299f96f378c34098e7adeab45f087d73170303627c857c4fac87b3adaf02ab6be3de8f4cea5c526a7b0056588a66bec6cba8a7fc83b4c46791b8c45a7d566ba298e0a1cc2589b85b63a80c810445a393dfb16f34e2da559383e4f2d5b69d7f31a6b414497c559700140cf787f5a8a36eb05c4676f30584a2f61801e6be9c61f3d7cb9abb3dd19a0aff0eb8c89ad24b015606cb33fb7eee1f57273f9c7b080f07cb29d500100f331a88bb9bdffc3e509a07a9a99844a9efbce02b50ba21a8242f5f2d81621d6aeb86b35cd6a62c160d53d8e2043d623e75a9f68dd7bbccfbc9118614308ba424bea5c13f6da7f49ad8dacab53ab73570b5b7c56a7b180f8d1b27cf9d3b6cb64bfbbc4e139c4ebacfc94a52b8f668cf93c755fe2a00b4473a05ca25ae8e3b5300d05be23617f9d31850b3cbe29ebdf82fdbbd026038bcfb298995f51defff090d6386a63a5809908af00f820d57ce69faec037a8a083efe9009cf32c39891005424ba1374195a174b61386cd12c6e77cc31a2f78f137bd440a8a9cb9a8d114502681a9cd83cf88f900b606ee2f4b2753c6fbc692f17ae34f02e4d796d4bfe1512bd5fa67f35bd817b9cc0220f53558187d79220a0cf1d9109cae1b58655e76404eb4c1e6565b559f2091a436eebbe9eaae40779e7fe2e9741e46fac649874cb8eeb322be8b3d0dfee35333fba0de8f77b102bb7233454e2c9d95177ef357a212a7918f70d3fa3cc28d76594c705da1e1c2d63b006957b81d48a65ca98fd47ab276edc3b3637ddc21743eedc63077939ebf0ff9aeefded2bf778d5a998d26e3a846ced38aade4fd565be3e58f5e9e48d9cbbd8a88aef0f8634693f9d76021534ad261df95ce23025ab21a310aab7131af4e4bf778831bd851e968dd55182348877512ce9947a6365112057d1763ecf2b491684b248326072e2922a463d11ff72919b7b8eb3fe9af1fbda7845a06b1a6fb36cd5cd1e2058251f2823a842525bfc3ff2ca820fdb981517e0b436a330245c1bb3a17da0015709c09f3dce1f7ba9a7e28bb126f0fa5bfef642a404f092718643ca691cc3a0eb9b7d34ae1146de3066498d79f21bef82c806d24b460c397d7c1e0e0901632a147a045a8c4da607b2487b1437466ad6cbee3935e010a3aa6f3155543af94950dda86c2d8ba336637df1e8c57f01380422705a8b33e3038c501682cf31414f366d13ca9f425ae1c60a3a3812ce4a4d1aca38e5aeac01cddf36128c512d54180d786c8684fa0b9ee8f84bbff8fe934d4e7bff5a65ff4e5a2bee83ba8e3dfc437e2e0248df97f77195a1c6e68012904323dc9aaab03ccbfb143b2bf5620b2d9cd55ba932b8bad7cb79a9afab0dbaf999baf4593bc792b2f8cfde1330643b92b1005e662f79b3a5b804953f7163a1dabde17373f77c797610ec531b95d0edaa806594e347cc363e43172924888c48900d31f08228a0fa1d202c95c3c00906cbff5460ef4748dda8687aae380ac5f37f9e194fd7d5822c941a04d7eedc7381969aeefe6a694320bc0236cfe08b1a074042c699ed6aa24b0f9f7bbc5b6336f36a1020c25a49d82306384e72506aeea108bed83be912001226807d7d6eb126b87ec193d6ac9c1b5dbdfdddf29ec8763c0825c6b086466d3e7f7c0ec5b27ff1edf129cf07b6d084234a0429a4d19497443af86a4a6eda3d3871234af506a6044cd10ec16a31d9aec2e4e8040d9922781551a13888688f8e928942e5acc09de889e85721fc916ed77237e126ea2d12ac420571c8e4c18c3efa7c1a00b7c81534ef46770c8d272a5b2a5ea8accee453e39208dd8f0948d51ecc7b11bb7ecc7e78a65c7fdf06208eb83c6aca6a4fe1fb81f1da59b94924cf139c10ed34fa791c7aa995e5b84f7e965e38ad60601aa515a87f683692e6f65bcfc7ae9c5f6c5943364f3c33511ac1a05965f69e9f479ff86ea8e8aeb006e17275eadb87ff524bb90d008161258cda095046bb2c67c2ef3a09fc251f3b3539314a1172036d2a09cd977c1ccce91ada639f7f726aead7a256899fc7386b488261715181b09b35f5a0bcc3f38a0726a7772b1ba8a50cd580fe9130db7106bf77e379efe0ff3e8c96e358deae30d04f170f8953f76748fb847b553524c501fb44df5d0fb2107dd0a9c8d467f66181afcc70c45ef647f8765348e88b23e334d1a857a58edfeca419028f4683f4a2b5173a079c987a38fe9b4f32ecdf4aa4cc43ed8ecdfaecdb71675714c016061686c366ab39ea3f7366f120fc7b67a9a2a5c02ca16957a6aaf75657aa439b334a6a3559e02f6452b06eb3e8af00bc52a8f14fd16f984c58a9edcfb5a4033d4bc0bdd4924e4697b29be793979b1666807a0824804e9b400252d208515a01cf8d7d76bbef354cb2a16c0c898e222178add435f7812ac4466a5e8400e1cc945c19bcd6508adc4cf9d004c01a6770adf5abae822ff7354e49a0fc7b61beb41a43d9b6d3be01c8cf82f0657e9b5cb8d70a804dc3fec084803c7a5f7115da64474fd83160c3a281c58a096b5ee3b77dff734691a95ffa727b2c9dccd2c824f954a36d95763c0bedfa56e6616d4126141a0a3f92b7d2b28a800a62cf7ce91936185b34b151bb98f533830d0ec936acc5ad520c22bf54443f8ef3253198f922fe3a5c7d82ad464850a9626d62caf28e6e8549b77b1eee8cff6cd89bcd5dc98114eddf89ed4ee5ca9dbe432810b233d90378f3e1182a730e179f539e652af37b3099536af8dc707a2234f8d4b9c1194b13808de8b5844e15d26ba6b3e94627e254384e8fc21246e3dc1dc6be4360909104428d457a9c07620436f1be0bc4014850bf84e550e9d11c1b00f20f36fbe3ad6d4d3a90f614d5d1c76a5235bc0a7272a3a217c791898624d4a148b802c879ee73ec2ba6faf109ac9595937323824becb469537996a1dfb0dc3ad8db66b205d202204cfd79e929e6583a5e196c7004a22d824a0605179f2e2151d5dbef691f8352adbc35570478683e27a3d9d14f821dd1e3665e61534217a8986d13d3032e2008059a4d2014088d98eaa72f04da219856c5e84aefc99d9c7bddda9cf502dba34d654abf4ffedc3058eb77309213440fbbe92e0d30e76eb45e5cc4c4b8b1725844923b98b285ccc6a803e419e77a8eeb37603947a7a95694bcbef6af13e1878af59e236ee783cd7cf299619e5b7d658018ccafc9dd052cd987f523ffc9adabdfa622056bc9405f0543546f8416d70139c97385d13caf868feb2b3550abefa0a7ceb7c4e45ff45a4d8a9d41272e76308848b0925f27d06353a1b6301b3b94a67248ec1330af2c7ce2323c9198f645830912e78952e390856a91a68dcc97fd43c0c1a447dffcf0b8a8e91f25281353925c32a5cfa65c87649497518ad09b6783ce51237ddc37626fcec78e63bc137c6e95eca350878f159bdecf7272ddd0ed734278a244b3c84dc7325b6fe16a75987e2678899810bdff7d1d2f896a5129e3ab462242eb1ee3b8db02685f8d818e21b1ba33f68631c4bdeb79a86d5a3373046141a11d15cb5b7b8b3944b059b2accfede901b88156167ad14352a82c454d99968e11490eba298885565ed942f81a5bc860442c8629b86eb62d3533e5389963bdd995f7c6cf125755c11ecdec6c214d50daa23cd8bc9f65ad89fb0bb750e25997e2ecaa9dc338f54badba2f89f9043b19f515ca20fb72de798d248255576541561ed33da8fc566989bd5e0907fd70969a48ec570e40b1143ca873f2e8056aaca06f52355cc4c095313dbd31dbf8ea97aba153229eb1b97212bc802630e777b886b215b4070a5bdbf3a872c9a2b3540bf05450b7efd89aebe0fc6273abf9ea940d7d3fd075298ce302cb8ea1f6785a2956ffe20e26c0a1316d7dc322d50feda0c5de46ffdffecf048de907c2f1b605da45a575bf50f81a236ff3dd7101faa7db9ddfb6aa1a9d069877a11a2570159d05d8279f43f74d4c873643fd9a140bd1a7e261cae3033b9404e57ba670f2666ce8c9af8547cae1eb8536ff43f0ad9d787f4a7aba642703b7ef9d3e80df08f30dde12882d2da31babccdf739cbac05b9f28ce6c50f2f9864285b35a7da2f179b2847b2a68be49a7c557fb57619c9d760d47fa5ec256362ea077486d2f2cc8910e524168b7b1bd49ef7243334c6729dccec346751b123213d30651c3b9920a7010b67ee663d009045ee10642c31ecb7a5f336f53ab3789f728d4d48791dedfe8bc3c1cdb96a168d8b276f82dd13dc81426d10cd584bab8e824c72ca28b4c2dffc4f3dd7a08fddf5a750b04c8311aef23649f139fc835c71804aad5d321ea6b5399bc7f297838c880a236b4574f070992651ed27c13dd1e36cf58c1d6c8180faa6da7e21f922287616a4f815b4563609ebf1d808aff76e4c008484912767469e696d8a0f0211aa94cbda025d732ccb7705a64e644973417da3c0876c584590fd2a30c119dd2fe105038affdf5e31cf32c97f0d6c4e9c33e9187aeb2ad0cfd7f119fa9b9e741d5f9dcd3e97dd9d26f8e79908c9feebcc29a1546d6c38c65ef4d25a09fa0d79c4cbb72e61bc3e2a66cf595df866b8c69bc1afcaedcc61a06068d5d26d1642a7a8646345e6c3cee4b7c9f43e8a9fb3a749a7409c64be03fe1ffbe3361030bc98879990ebf2a1dbb99c3b7f9bf3886c01081af211430820dfb86588fea591eee4f69b38b4eb4353a879b384cf3469aec3e3e12d60c9d1dea017c4bd89b6ca2760b4167a01b625903d4d615adab9bc6284c0a5352edcb8eb4dfc75b0e89f1c865a823b61e086ff1a0c8eba7333c79df4a92ebfae28b4b7a44cf1daa9207f599db49ff64fe1122b60590dcbce62b925e7f8961250cacb86e74f3b8299304ff6fe008cc21d8faea25f9a62066a96c61d1d046459ab9a5ebae062f01e54fd854aa1765b7d3c7ec1e3974f4f740897df791b56da526ee7b7c9c3e3f8cba572c9ed7cbbf6de28a35d3cfbe2426e4ad6064c107ab5d080584cfcd5cd70e0e879b6ee70c46350235b43f0b1f9f3f54e82e5ffb17f07685d74f1ac76a234c741a47104d0672f940d30cef73822242eb7f53ca13989c423649b666d9dd9c6b60d44615879ece7fce1388877cd76c1372e246dd8f3453a01a4620d0ecdbd2cf1ea3e2c5f65445729b2de86bddbb7cab271675e2e2c33d778eb1d74c25222e809963e552050bc26e52401c478763c9305a41a08236564f1f9fe7a64c8458ee36bda9a9f1b68b8eaac74d8fed7ee6a79f8c233f09402eea4cf101ddd8c76750b41e72be69bcf5c2c3490b73d080eb3dde545a111193cff243e230232edf16664404e3c7984749799e0af9c09a56165a321fa80add1d69e3c01b53779b81bafe35f6e6488263e36ba59190ac71fc434ac25120cd141a06fb8397fa41e90601272362fcf79e42c907a68fb184df296a97bf15c0c5ae3a4326d24834e144fbc9738acb385c67d38fee926bd2f94ffbd3b5241bb1cb5ec5d66eaf9252abe3a58faf462cda8308504fc282168e7f7d6e5073c7aeb83ffd383bef9492972f18d7a8e2dec79ac354152a1b33c25a678683e10263036e678983064ef327a9243eef6dfb4212fbda651ed236d6029aa753bc740e1cf8e9aea24e48956d7154157b5504209c015749c33e5d9774322a07d0ce61d92b43be894cbe21fe311e12234eb97dddf56f011e998dca879bcb15467d917c8d0cb69322855142bc59ea87b308657e531b8c476be9ce5618a0fba3c298b918da88a4cad50f936faf82a59a3bfd0a2cc9fa5229a83e07b671b290c9e1f741a0b4d225976783554974941180138d46d2e5648cb834775cf792c965591b4d511f3ff364a3a86ba8f349b5092d5352b9d7fa1319407c80f640b715d4ffddbb76d96e0cead4c0721981b40228f56ff954bd779d23bec2ffd0c3991ce69cd53b2aadfed5855fb02d3d2c040433b2ed3c8aae43b6d45983f1f3bcdeb7c9d5d64375b5c4a154dac7a39c4739a9bde2530d81c27848fafd2b10cdb03793ab5d36804623ae5b7a8db43480e2fb97cf4c072ffe6ab1403f19f24525bd25e9dc0b1e284fc1b4e32e61bd7679dda7327ea2fa5bbc9a9773157f651c8fe944fbe51d4b3fee2d5ff52098b20c3b2414eb138d930c51d7c5920ba6c7a625bb7d8c88be4d68794147f733e686871b97fa9cbdd03a9d7b42348d5af2d9bf2fcfd3e63197762e0dda40cda3503730883483a82b44d9d13eb90c0d5599af3cfdcadc1b82943629628766fd566ecad89f74cd3407d89eda66ee2b5c6b347fc27619cbf25af7fb080b1b788c68cd511ab2b4e240bd69897eeb63ecc17d5e9ad81c0dff6f1674857a3e2079a92f18825651260baaad770005c428e99662a1609820b537e2bceba9df71dd907fa5a5eab84ebc19b0dee59d5e11d1740004f11b98f6e8ddd987e5d8f6eb24b1f9f88647b9394ef31b969364f58988ce1b666073a4705acf1d97e0acb301e27374766529b6e2f05e0d58f4972a05eca77fc9685b04fcc0492f1cf930ea58f53bbe1e781d88a20c4795f95d47b7ec4ef57863e0c98a318a494faa1f13249732d2b461ebe2f43580ad6a25d8e4aa5a38eb63a3a83fc0cb26ba57ed106fcd9e3581efcd55880495f9b8b4825d0aae8494dce6f614ad87660158413a9a9cf520dc8cb8a610ccf32aab2ddb13aacdf4536c1446b7af730b77f943a53a6e839c5929faadf9417051784d08d032bff5722dd541edc53f5bd5fec7f972cef69af31f4684d6493aa7582aef6a2d3b14f6401d945a4a7d204e8d6827aa5ad09bdbe9b8100063db74aed3d50372ec8ace79bea92586796581bbe5e7e3aff6ae18d6b356dd244a23d24377207b1eebdeda4da142463fe6ef0a6e109f6384e0118082fe722058ae545b062d2ab5e223680b1b1cadb7e5e8fe2aea0079a56148ba07ce94837d1920dd1591ce4bf709fdcb8d02bcb0b83082483b7d8ff7dbd05705d8923a1be5be431b238b4a5dc0a04f055e5e6912b32aef1bf43da14a4e7ef0eb580717ca134a40ca42953ac7d0df87bc79edfb6c36f4edac554530d7d616eab4a014c7f46211dd12365ebb0d8b07d1b73a700a25d1ad21ad341a3f15bd65ca71c84094e710176bb7d892b1a31c64941f7921f5123fedf12b39dbb1505ceb8ec5304570f5406caaaade6122e686bc05b96dc15c3a2281cbe2e8eead25788d8a21282bdd8a105dc94912ccd015722cf6c1ebf9d5154b1abc38d9acdcf9321cd36397c3e4db2a11b61b67df4c53b7e14914a0f2c86e26084c5b1e9236773ac0e7ec9b5ef6a5322f8292049a928f83417b9330eb70f0a0df482e7d0b56d771449b6222f100a7959c84b9566798bb4cceb79a81211c25141f4fde30a93c2d98d6793f137284181990fd484252f61ed5751171575fb4505cd0994df089463338eec4a9b0d4ef56ffe0c8845eee6428603b57403fead15cfdc7fd3c7f6a8784ed2eaf1a239884c43007a19bff3347148fe6029a761895acd9d3118c31239cb1590df48a2f5c5d2b4a5430342cb56f2b7d9c63358c048c183e494725c9faee433b2011a7e1e0fd1f0ef172a524290c05ac040db4048f7caac78f372fbf4349ecd728b14d5394e681bdf1d7399839d5e3df616e2179ca7e7094b927bf7d8ea37ad0aee77aee6af63a6e0a09fb4ba7e36542ef4bce6d5e1c3c24f5a883ccae65f6286bc7de690e3459aea3c66b7849b7e768c5ae67326213e8b48e147e4097118650f4b78d5365782f2f712e1c1fbf2f916415370a3f8fe0b1ced4c654f9bba45590074109411e6300fd06f913fd8cd80b82ed5c28661f59e756ec25242991c2ae04503dbf90666a2e49a7744ee7c2c0116df7a9d33b132df147bb11e4eca6075194494b3459da8df8e19e4067815fe696b2b8ec3042ec0635e1feae05e254322504134f575297699554d2d64ead2af68bcb0b74032d8a377d1f6b662d567afd2a15cd29f54a983661c3cd937911b54e9a5bb9d3b9e1da2a8c2fe9b25f3d8797353ff39c15fd67287293711ec503c24616be873c302d7ea311c11031b4bbb1c3f7e822542e01131a5be2dbc1f3fb335bb753914ff4ec13b7685d752f67e49fd2a8e7acdc042b412db5acfdcdcba8e69d018b16e7cdaa7f91395f75a62f326298ea5a2775078ff78aa1967a2f64bc4af7d8858b9352994951b094e1bc23a1b9f3e004f5e84ee24f1b34af05bc70746a38a614ff19629a7930b7a437758313defd4d5bd5dc7eb43f973cbe005af4e883faa5dacf2750ad6fc0ee3584be3a0423a883f3218ba73954570a2cfb829db502ef6f1db6a6102a7b1afca5635269cfc239a815a17e2c57398a87ceb79dc5a6daac71ec255b505a54f2603b496e4e7b720ecfc1ef9a5e89bbee71b9fa81e1d8b2c08a0c79f78a42cd0d72c6ded29c6d33f2418bbcba840264b7f8687903c9e6f6e2b0a63837992313f06ab0899d0ec12d592f823e4c65774d463a504a2f9e18a5a797c73957c4c2b6d0d8ee7129b50da496dd17d95ae998980e3cff5ef4c887b6c9fed23533c1617aa89ec2b1742fc855d0a0596f810da06b1458f9f23e1ee017e2784831138cd00db4d692b3b5f6e03c31ccb99782b479905485de3db333b8cf35160d1b7157e84c26da6aa7dd9bdd26f1d6da76178e67fd4dd6a9e8512d3a54a847a3760519c2118171bb939c18d00ebc63c9a532d9c6d0984a1b7fbccf3307bfe449891eb333126941bba0b58351963419bfb4d1994671e08342141c25a5507f25a0d63d679c75424195dac4a4e606d4454b54d0c70b3b2bf75c7af9fd1e0fb88cb28db594c13c6a2d3cef105f30b8f442bf66e1c2a3387051ca64e005706e61de3be082b89abfc78464ac02a73206560c1e3bb498cc682d08aa839c1c2ec2dffc17f9c9642813a21c090869fc148712f22077da80be2fc412cc35e355e13656203d051d913f1bbcbe1690a4fafa9eff3a533aac617746eece2af8d277c0c2d2c8c309441cc5e36c336550d769c903e94c9a08c5415036a65d3aa66e92b6bc37705cfc342cf7e708afb798f383bd8d109e8f2df9c84710136fbc2715985b7163bc14ef9d215dbbbe58503c9d28407693a1145cecafcbd51dfa4a7e39847357a194614e3eba6e31865523dc48c104e5bab1be7cdadf565189abe7a185620a350f031d17677d7a0e1b9de586a9599fbbd71ab9d06f90801ad6af229340c0d98930465674704e6b83b0efd4f9ca250b968892d52b59ad3fbcef01ebbc81febd16832ce6e9a589828f58071d32e6ef60b76ad56395378c4eaac18e9a43d08394914ba1f81544e8633927ee9f1c05b30f3ad77ee8d8bb9a7a45ac73bac0cbc9cc397566b87739c6b48c7e0c6ffbcd1657b9b837d7f515a62caca357e71a97f74bc8e67ca2c40a4228e4cf968324c24aa60f5a515e3c98a223b53421f639e0a5cc6365eee4a130859acb5c694d3ad57ed49d829f39600604e1d60ebcc3756b35bab51524ca133499904e6f651bbb2b0b7fd938e3e4d5967744d2d46a6468c9e72936981d2626f21602a8506e5336ef47cfc472a8f2920b59d31687e353ea887217d87d7f08675954c9ba8c30a5615b90a7325a3c78e5d6f278c849a25c0e3dd1719c651c122d2c2f8abc75b0c3ac2491388aac70ad0e8f3a247a3ba37dd95cedf824957144514d873faad40d0d9a47072217973a06aa5123e9d25d81db42571d51aee08a26f2f1005f1681d839ceddbd3fbcbdec8938b88a9c45e08502a302bc1d9ead8e0e01bfa52bf673be6672fa71c1685a311b083e90d75b05a488f6dff4bf0c87f0c0e24e111a02ea2b82e4464f762c303defd95d5ec721c9057ec261d4ead53e470b0e013665d243939d1b1c78d391f3d085a62fea68517fbe61aec99bbb70b50360cf5b0cb0d7cbf616380443cfb1c968eb01bfa4b72495643f2a5f5b1f5337d346f1808df3ba68bae1abc855caddfa17d4836a70b5f0511b22609add292fd8e479a280babdce2e2ff8432a02bb94b0006e18902a29b20ef40d2d9dae2bc43c911f29eab99a15571024b10b8eaa3a3220e88d108251e0909d6271bc8989f3600cdd3672096466d21bccdd32f127855067bfe2dfc9a557123d9bb83ac334b9589dfc089648c860a6bfbfb60fe60857cd663815bf9c78ca9c83c7947051abfcae73bc6f85e6bfff22dff431cd9a0a815b8863f9c84f8a4154590f26e093282cead4abca15263f0cc6d53706c96fd3144e1e6a262a4fedea0d17c010aea274881e9f75f51533c5ad2267abb76e31e4ac8d21854c2e757b35555e3bfcece7d6d8dfc93e12780874c73b55bb7eb38b3606eae520056b6cbaf8c8eb72e27916a4b06d5c91f75f9f99d4781e8ec14405084cbd2050eeadf4d2e664f076ce4ac7ef338db6f512def6049ad190194c5a04e2c20ec70c9292b60871424d64e48f8540076a217d347159ddf6f445d760be727da839053c42f94e3927e37ac7b52cd7d58e2d10b268f5390c854f8811de5983dd8c8a491f21dabf266a338998a9e485aef7201b2277ff99ac047592849609dfaa5769c7bb3aa091b86b55c43b070f16937d66f5dd93c7e00902ec66777821ca7d3769fec53cbba22295daa77576f73c5b1c9395e8995df56e33922b002ecf2c29cb15ed0dafb4237f9b3373d3e2508708dcf7f51fa95540a4d2b474b99974ec3e76f53c29299d92b889cf0656cc4d0fc709a98f5d943dd95fe50f0e540b116e05025458e7fa371fd50f16e222111bf5013e077d4d24f397a82dfc4f7031c7f502b2e733d779e93deb480e1824ad630edd93eaba9d35354f6c0edf2e9dc058065b3f203f65140ab7761b91fb5af834045b3972b1ceeec475f7d107791f90545711e0a6eacd97c9f71bc5d412444326fb8d59b6993420f30468e763f3f5a99de27768a35f1cd1248159c4fbc854366e796182e1437054830b5c5032ab7d1d235c1632353d4325819bce7b2074de006844c9cd6fe6d010ef4f1dc26c0ce1d50447d332f6a1c7d703910eadb4c980402516949d2324045c90d4b5929a842d5de3ce674a201b00b0207f42992dc4e37e99399e3febbaeb5437ff6e26dd6ed2bafa9b854e655bac4ac235a6160fb3bac6c079f83326fac9dd8bbc8cc4c16b42aa4252a97637d63b4eb2fbc0a1336ff8b850e2855bb53082d2cdb4a1d4d9cddd613b15065ead8323f09ba009472734e5de92924adcf05d30e28b5a3c11c45007927bd8090d2eddb7ab82bd8f340445dc69e016284b558d930d13cb7245c65dac146f1f0ab64ce366c38fbdb6dae63b84015c732c09f5da719351987577ec6b12c90d2c3d3054c5c7060276a195b98f520df83f909d879afe38d17eab2af67f150d6db1d145678eca24fc038bda4775a2ade76078d538674fabbc87c106985aa664111e9bbca8796686fd3f540937b61de659baf755297589d1ac75afb48578b2ba35371b7c85a89b0f3f0b93f208294628e2b57675a092dccea2af3329d13f8b99ac93793db3761ca7844eab27b9822f8556cd64622e7afa662a089eaec4792cafc02cb50c061883b0246fbff3bbfa50e198b56e44580926287f30a0cd4ac35ba1d883890e5c17c6287eecb4718066d6c2baa9fe78108a6f8c9a5f522b21065dd5d0ba60cd5961ead2669882cf7cdd338db343a07dea055dfb7e9517e73dd52a1e48ff48534396b30396f92494b1a40108a7daefb4b89c06263a6b39dc9756042b3bb591a225040a651f2e43f5d2953c55f4901a678d834226d6c153c96f862f9fc4f064b0bb4118fee2284ff70499f7ddb11349e97a2b4fced3ccfc98af485b7f143ba830c8335db2300ee054d940129c97660acae891dfa6b8fec4d08985a05b00a824eadc180ebc501926ae6ec6948d6275626c35cdb976dca6a8209af3a26a3eda","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
