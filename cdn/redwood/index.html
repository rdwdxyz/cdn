<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79c2000a0f4bd83652a2fbf02fa800786eb49dd4797ea64be1094598613b49f5ac517065a44f1edabb7ed8a88c8f32109add8e7a16782a03f5808ad9e57a97bd2d57ee880d4679637455e849b34ebf0a95886fdd75b2ab803359de51da2d72b811af7e410e903b9b0a9e41a5d2983783d88bde2bb76bf0509287ddb5dcf9e6d6a488e04aedb130c2544f09dc916ad9991b2eddda46b6318d5e0879a4162919d24ea3516632546b26e66001338561e34794430967c32d66565199a410502fa2fcfda4530ec4edbc1f66db42a72e6a3f496096b678bc2339767f55300e5bf2e339d01af5f41037ba9373acde2be44b0e53e6928197ce40121a66ae63adee354c9e47a4fb65b26e66f04f0276601cc5e255b616d57c16ba0ad82f79e9bdfb94bda5009b2921209d7a4da968a282991bed16bdcc0387928532673c8d7fca52b75717bc938a78de8c5fc092b952154b8369aef4b8ed860a60e84812751b610a55c7201cdc61b91d3a0eabdbfad6fe6752add92bdbf4f5a45e7f00e78618bffe15402d2d6ddcba12c9340564f8f2b03a2cdf69bd60ced54511c40b3158923afd1edf59ce94d268b34e3cd204c011b94f3f99cfb2ca4fd4a45a795f7443b51f3aaf978ae30604ae883b555e75730e3056f013c8ab386dd2c4bc7f2ac81fa967baa0f28b7d4d99e3c3304a055a49063dd1a0f1b254f9ea35e4cfe097e56063091d45be7af4ca5dce47436522cef1913e7e1b88aff095ae5ca9f1def65b59e4773f4ec531c7c519f11b00e58e2b40aa407146dde9aa8aef50874a6c286805d0eb49bfa7eae6bdefadd92e494833493fba1191d66e2316583e8182b704bd4ebe322298d786bbbfcf7ca14e91e0d5c254c81c8fb4571c2876314154e71127d51425818a9407cb97cb844067bb4a99458cbb2083b6edb425db7f3472c1df83d52efe0541eb085c85be93bbb9008a30e6f3d62d5e8d4ba3a4ed105941fc216eefb3525a2d6ff342f128f93622b6e42198994f2ca3765796f64c1db1f554302b6cb32fed603e41b40d939d9c34e217e884eb75ce08039709da2f2215599d6f985b6468eec143aa8135d940106e8063eb6b75a2f974a0d22e154559ea51598ec925ebaa71cd4969a21bddd73fc7b9255d5848473ad27da6bd5e8cf6bcff159c7ade7191560cabb6a615a21bd5393a97b97c9600eb01017852fbe8711a1059632e6390e2aa68388a2a19baaa1524f7bd3906b804ef70d2a23f3896332734b65fede4ca22424427714c6e6ae59d71f27b079d6654f51a8ff02e993704425223e25c227511595cb1825edb21925929df348c9970b8ef0eb6317b021b6ee1aa5334ca81f0df4f381582fd902d5a78936bfa77096f837bcd44a5173e47cd2368fad052c2d1b394b8ef6e527b7ed5695a9e1020648dfad0bac61f0c9d6db2a6e8a9b366d556b9e1a748f0c5dc47849a8845c7f83f10c6861aeae1592929ab7a1b733f72c421ae2fc24b4c2886e58e4b4def4bd7e012d21bd111305b225e4804d6a4a8e86e31172f514dcfe8b695b5cb01fb82381859dda9de16360c7617f925086ac64d172b7966cafae7291d8e10514b3e9a9806c5f6c904a78456971e3bfa179072eb36f4de94f4cc553ccf9dfb56a09f713837cb3f8b2273dc6a5d2696c6082684ff05b95451d2192a6082d7909776265391cf85bfdd2df180783dfed9c97cf0eb5ef3799b986d75bf931fea23180f8d728d37781b24d8c308d8644a4d9eaae13fd0289b83acb9f77e63c15eee714d06cb874b59b6b851acfa3b5e24e1b2eaf973da6e4e14fe49e299b285bc18c78af6f027c86c80ee80d457bf8d3659e937b6a35370e957f6c4d40863057a0b9b3fc1d256079ce66ba479297f1f51145e9100f3f6f2781b2d8ce51fef92a4b01d1850f97ef2e627518a03eddf157e10203190ecf3683a5ae8c840b89a29c165fb5c9d5ff65c99f017b68394cd2e9834803e2160dd8334ae3f0b7cd592967251c68921dfcb8b8d5d43b4d1ccb3690a97dcea9e0210ab029aef22d9755dff0c9defd6446fa036ac8ecbfe562376498d8e35cab1032333d3eea5c9b422723c2fccf5fce431c35044e4ad14a29422b24d870bc4e22e8f96e27796d1875c4fb51f2fb621fc00118e30d8bd22b23e781b8a5847bf7992fee39834c90b441ea94bd635c07df82acf86e1569c0d1ffa15f8f8973b2eff3893275fc2065fe0a723efb98546cb36578579e87292fce6bf432f2440d90c9dcdd225bb972e4dd811cbe77edcc3f423a5c675db721695c8c96b646e71d50283ebbff89856e87c6ff4fa7ed4e6e99e473fd5b104948489210ca13208d5b9f10ff469b186aa37309cd8ecc6087fab37808705d20b8b8771a719c275f8f88a01f4443b2c46cdeb2fabb1089d231449cb21d32e96a103c09e386e0e330d757a5db5af8d1e9f13c45612533d641e458cebc0525dc32332d09ad460bc8e3e836b9e0f2bb050752552741f938a28eb3c9eb7030a62735dac4d8fdb9dac239e9d13327703a9d76a341817cee6ce705c16dc483ddfc067bd005f49d184984f54deec0818b9e7adcee3c75f33bd9a65bd512fb7ba4a280754449b0bb746d85a33b3f6fc2a8c722ccafd0c8bc6dac817f8ec395c3856e164db95de8ae8ba83ffb0c363b14e518f0f0255c2a8d46f51f28e3a99f9e229cc16dded4575676e909d86302a1b0cb012f823824fc01d35bc90549a177d7a34f47c6067db215344fe28854df61cbdf21b5af9dd24ac3e8f3a07347c15f1b836a2d0aa081942c3f3eb775cd56f81e7de470d71e6be89c66887af02e4aafae055ba2cc25ca91a49afc6503e23b5a232b35a3ed4940ebcbdea2cda68d4474eddb27a556effc62cbdc7399c2bb5293bb090f29db49146eb33e8cd8eac1ce1c050eb1644f55cda68535f6687e19880c5dd7cbeb489b4040f48da3f9917617f4038563ad291ef9ae79bb6bd8b79ff4a0927ff0c8ce18b874f3b92c565adbb019dbf5471eb78b24fc331fb27a451b948349c036d04a929d2c19b1c06c2e0ad5f12d73f75ea7a7812a5a4aad9b5939c03745cacb8d127a989a8cc4ec39f50ef05708f1f3e9ed35981c4d86df7d384edc44c8fabef458728b6bbb4a215bd17c9408f38fa2f4088112a4ae6b6f8742dbbd717eec8204e5bd1731124942ef350016bbfcc2934054406f93d392f7630d792f9daf32c552e7e00689c8730f3d07a524125855c99a739a7fb12bf974b51af780a82282334b209c7b634d23bfce5de694665438fb18500f99a4713ffae86aad2416f6583fad006f4baa143f6965b3c43cf51f172e72a5f24ad23a36621051bf6cd9a1fb30e447c2138fbf4b2170ef4dade7c8c44292b383bed30290a9f7c157afa771ff092d7141cc09ad83d16a89f6b285f978f13179879a76948b5bcadcbd7ecc42f0dce43a0080488be9acc56eff5179c4b535941728f38e4fcccde7c9be5b8be1d68d233e617ff89e3272299dc895dd5fd468c7c6f707f78d275afaae73203730f163b543bef2e0c21e9fcd31ebe6d3b4b5f3353391a96fa1fb3bba279058c07c7a00c4518ad633ca4c5cbaf807bfeaea3dfb57676fe1b5ecf8beaa2fe590992b5f6ef3baee8ff06218296011d929ea6b66b4c3cdeb4fadd3fa5bfc11c5634cc65119393b71d456ae1ce4f8be7b1d9025cf11551b9c7c8a44f31cb02908449743c247f328554600da8049a126c8e762de5830567e9163da3e9151fed213c4dbb6e23aa848de5b9e043b86878e247e112b6b50536231c1b7a666dc44514229a88225a00b34019d1a2e38033191a0538e908034cca39d1cfe1be584377b9593bba624730e006cc9090937617e7a7a73d02e4b3e5a09ff2117bb7e194bed8c802d9d6bde6e1794fbfa202dc642c96b30927233b8e9511e54bf8252a6b13abcd85cfcb7c02ace44399a19398061ed105943bac18122ba6c3166b156525bb3d3c57eca2fc558ffa81312dfb52bab43373103e97c5151f7ffbbe614d9fabfcc075e1e0bfc5f608f084aa73dece3abbe576b5e090711cc8b66cbfd607e5a6c03ffc8b6f23713d2a5d79b56df26dbdf36337fdca5d551d0fbfad2e76c23b572c6989d723a86939e922f8bf0dc396f8850cbeb873ac5fac63834d43414209b95c21fbca1d6dd82286858ca6f9df097759b0b2919489ae961d18bd0425237767eb1bf9d27e63f2b615127593b12627a4ceb4604eeb21c11c93e86bd54dae09354f21b4a31451e4b765b1e9fc988cd738ded5ad0b624aaaaf20a47d33b679c4279ead57cde052c99612ef6ba8d62c633ce68743ebac190f33bc7cb5ac9b0d763712a4bb7d44313b520158e8bfa77b4bcf0917876efca0c953a6b57388ccefee2ba5ca90732585316fcb7e8c8d43ce63c0807a7ac0932383150f3992a63b0a4f11f9e59b136a7044add0ce1234539f6836d465678ac475fbe9ab1cb334f54535437c3b54f08a72201da1c862b5f605da1f417339335829ecaff519346fa655b571f23efb20c84ce362c4592e28754a06d598565d3027bb5c2b2b44992ec01d3318d45fe1f1d7c5551ec9635d67c604e4e806fb5e921d937a051a6cd3ee54338ffc8520b8d4a50724e7e7a8e54aa93364b01e718f243884c86c2275fc899bde2c70cc0344032037efa70ee9ed96a6dbe50cb6e3ff41f23657434811bd35380fa892432f99400b5e765f34d9198e2e8a544736e178c2363459251cdc42609f3d8aa599d4bbc10c5677e5673ea0a1412cf321f570bbaa602ad58f9c0d382f115ec50f0fe9671499b718565d902a34dc2e866f71ffb6bdaa6ac78518f602d8b1a263a3f43d5fbde32fa9d714717b383903b799d9a41d3264664bef20321fa0342546a05e7b04f2bc6dfeef4bdbf95af38259db8fb459afe06aa22d54a61005c10ed22f158638399a5dc4d2f5d6446b497dffcb4027d42b2bb765b12831ee30ff4c3039ae4c366355a0e914339ab173b3e2555537667ff4b66ae794fd7f022cd577dd67409ea1c17538fa8be843b069e78f9fb62f5b043184bd0830163220ba4222a37b32bb906045892baf26a40e022e739a9dc80057f63f20f9c0051be7c6673fea9f56002c49c7f361c147fd869f6c6d180f6e9f0ee9c5df90e378bf66b2e7208be0b247f4f8140e0ee9ce3d2e268ddaddf64bd044dacc7db250e7f0d75d3c0454584a94dc38f80c67cd9747b232ed344f9d9641b04611bd161d1e650884b14e633ec5946ca0b6f7e8029420f467a8a9818638d8796ace2f63b22fd2780eb2ef45cdf2ffbe71bca8815e26075af705f3eaf8a76969cd0b72bb69c35733051266682461e24f54dba63d542e27e243f253e9d98f205231899dd39ad3cec9bc3db4cb25d7c80d09d257b68f79b0d2b17175bf97295fc110048b1bbb5465127cd4fa761c02ee1fa47e609358cc9735c4f844f3672ce759b87ed7c48d813b72b0fb889bd7753392adebcdd8023470b9ab8ed25a6e785f0dff5fe0e6965a747c7e5eec000eba7c41393dfbd89fa48035323e141b83a4d052a74b6862e43f2c65dfa355356ad5aceb1ff88b60133ad39dccd53ce5c6738c57aae42f0f809b8b8ad5e81656c077a8b6e986e324cba762651e6677ed242503332b02464ce1e152630fd989c5968833a0191ad76bd80f7eaf901ddebf9fd9d0da198c5ec2e8896776398c54d1e58841b68bb32fcb648d6f066cd5c59da7743eb6a27ffbd8fb4d8bd2ca606e159d603f5bbb380e485311d155b56cadce821243030f6b93818d1147b445445bf5301b71d3e9db61110fb93cf925605d3d679731a5603def164ba0413b742eae956c3bf859f781acd9b376cced03809c341ac42883aefbc9c913dde7a940ff252d218e9deb6a8914fb787b3614daad79431bfffb7f4a9e4872b8a7ef471dbbb1d878a2ed4da2b3595d4f51dad86bd2e771e64d2fbd181baf1c03214037f817e07565cc97db29686fabd3c0bb48d265fdc1b693344fa00d09e57e8a4277bd50392d6de9045fe51847fa1fa764ab760849fb1839bce68f2aeb55b426863809e4896ed4682c9ab1aee40e11eb7f8f81c29525dcc14c53ed1ab78a68acbf0eceaa19e9eec02601869e69dfad97bf573a9efca7e72ca33c1e37957cc7c088b221fa675e8daaaccd251b23aa82b1c00dfe92e25116635dc5e13c6edc33766e28b96875893220ca07b60782c05d0c625ce77e7752e703511cdad79adc461e38e7c21c5f60447a4b6def592af17afe2e80b87873dec3afe14e60cc59b5676c43a881f121932049fc862da1f151b47fa7efe26ca7be222797b1d5783fe991337c97e890993a2fb7df10f2d56938d9e1a02a5a11735036a02df7c91a0fd3fc94a64ab21f681b23619c467e13fc77a6b6b7726def20d8aebbcb4f7388266ea039cf505b629965c0751e7135d5cb4b026a7ff9516cb10b7907cfc12d905036afaf061925b17b5f88ed32f1321435ab44b55ca7367997f3ddf138eab06146cb84de4e2314fd1f4b96d355449ead97a37ac1cbbf722319ba454ab087e85d7e1e1d5e297d49547ef80d875b3c5947f50abd4f65be3fe08514bb317d9b860ec5b9f674d53a29648b4563189d7f2d72bfc18592b75779647c301e14dfd68a023ceed5a1c6854313ddaa718b0a2e16db5e5e331b45dc0db19c04035db631c6fce007a0ac02329a99dcceac2eb68e1ee111a57fce47b4cc641a0e96cae46e7caaa9b7f29de1b007c3f1bd983ed0b3c26643df939cbb52dfd622a3febe967b6c1c9a5e71ae82656dfea15552f086cdde7b558567a11cbe258b94988945d53b6e4e3bef1c53d66e87dab262c64050cdc04a63e51b57d12009c7e647071383efbecd7da4059fb094ea4334ca65f0574d79750bd2e84617856b94a7d69ace9b6cfabb66dff31f81b3f8edb2f7efee18ed2eab0b12ba87e3cd4ab20e8d116f9212ba31d97c385a52933b377d12e4e64961cb32d0b0865c9760aa8e4acab36d8cca57c5517785d7866048c952fe09bb89e1753ed20b6ee349cb905d8ef713e5243e6a3a942f7e8e9da69724512205089d396c9295ac0d9f62859e0158d4d7e831798a1645f741e034728d10b74d6606e94e97a3fb0c7e37e382663f914665396d2ba7f69d3db01d33129a84bce519826b9d76abf6e8ded46170aded2bd10773d331b563c0d371425b12ce9cdf79e213760c731d0a5066349d168247206938d1fcae146b49f63ae277dd266374123e54298ede8223b5c5b97505b374cde8d17a91cbe8cce2ab7c573a7298ace2e17ce9e3c7962d5f99ce4bffe5b30a3525816827845b20b25cfcbac605466a4e8aac6d9eecf529b5bb9d2dc84b0ec4f7e0d480228c0f336029355cc43b7efdbc426798f330f7c5114b7d37d46a310702b9555e69dfa4fe9a626c0427d331e0257337c7cfb100871db8f8636022de08e692c2898a882fe60dfb92b018860eb1731616d92ea4f941f4eef1794b83538a415332b7e5d0b2045f353c3e36ff29a272dee1d4d701eb7a16f90438979648c01ceb67248a05be9bcf1da771e3c8d4bd00c12ff51f3436645f76188fd69240c4cfab48c47261924ca85567b1b0b66383a56673808d901761eae41f07b305dd1f00c904e3f43bbd8ba4e37772a4e425838748f6e031dd5bc3ab311490a2a1b6146d171b986a2cb3f66a628ecb547360350a480b21340d4d898d247b1b7f0ce3898c2630f86bbe08d1d9234d24c685e6c46201fab4dc3bb7dd68766559c0515673004298fcba7c6ab1bd89581caea388d6157f7f84d4d8f545f6bf1e6f74dc987881b4376e8c1730cb86d049c7b716bc11ed4f23d94a861cc19807a04fdb5c1ead5ce6c2214553e4c80bf3f263cde7ed82a8f5d7e9bb22984673888b6b0b49ef7018ca49f08e946c1abe8e1c9c67576be0f6e95f988c5d901d50cb8d0a5c84e5c29e58c50943f0f756ffcf22c5c42ebbef28b8b1d644cf91ba10e03c31b5f88f8550ede5ed71eb8f9fe3b393f1a46c7baa67bb8435cfbda50f6a06af58107becb4298d9566b87ed58a3bc8fbdbc9e3208d3e6f3147a0865a283336394df21168b278626518553f4fedeafa760670df73e9b7a33a1d6689cb6dbd67f82003a2bbfdd2162c2bc2810dd198b242fab39733e399ad18cb2ca1c4fca908bb295c221cab94561a32e29986acf43c34bbc62be392c87ae70a81c7ed9d1f94dbe6be8ab47505cf1098e80f1744790f0168cb88353d5703571a5f162ac7f23c35db452da3a95d8d075dd25f11e4743dd04aa26c8596404af2d5b0e6b122c2b7e5142ac523788fd15bafa91961022b8fa8c736c956851a2390b32411d2cbc72809c72a4ee16a50935999100d12f3e74c71f1a69e6055653f228da2987ab654ef99598df939ba2e9419f315542d97cdcccadf19593ff1156561d8818556f947c57c95d1ee62c01354d3eab917e84633545a912f3d0d576883b520fc8f4a5b46799331c87863a18dd5da1bde573913bea1b9bf845db5a60794cde06690ac9c091d512638e784bb0883a7f4d0e2960aab8241146249903c31b02216ef66d8b5a4728648ab8c8161db56fb77bae1678f35bc4740abd95c7a248c4f8c3bbef2649ea9a947c12947c06cb6b72d9249b2c20e9ded904794453643e790c4955e6e797eb68cbfb3d32d0a4551a5edab5e6881c1f238c7605987dc8210bd77676dab64f1fa0e506d7c4f9428194eed958e0e59199f7a5d353b7aee8513aa6e86da1284773e16c1748d852b49a9b6f129b59fa284fb65e46e1c69f84caa4c23f8d9cc58b5655104143b85bada4fc34822d8ab2acc83b07217667eeee04d915a0bddcdd29d5818942ef4bf4fef257aa70a90f985c718415fa6ab61aafb647e38cf984a0c66f9fbe79efbda27c2e88a587629c1738ff0ec70c776d90d3d29410021abef7b816d56e2f2316587300f30739b9c9cecfb0b867f6b86cf8d07925fb08c7dd080c3ad9378c70e95d6265cd4b0b3caaf73e980158d45632212cacb5495a75bbd1661970cc821e6ffb9d44cbae50515eea0d7377b2fefd41349e5d50a1c3aaba2f6beca2c8225f1c955f98a9e01c8e73e58966a1cbda79017cc5f0a9b391888eddab685b4920fdd10191e3dbc409736a7bc1db5c68d82a3d6e2cc3a6a3b97af406313bd00308deda4f2d9ee0297ab2c71e88ed76eb3946c229183d645ea75c0583805f4ef92576aca1ef6a6ea31cacbca84df5b49085cc7f81462dc4f1f66a37d5d9e1e71560c78e7eff3907099f228fa344ba98429a2115e637488d50fceb655efde31a1917e25f870206db4dbcd97b5089e0c1e954a0bcb87c100508ccf81fe1df5eaecf620062c097cc6ed3c749423dcacff1b51452362ece1454fe5c71682c49a6b6ddc93f35971418eb734bc721153b56063ce727182c2fbf56fcbdb6fe9a443fd890695c55c71a24e61aaa6384aef23870390fdd47e757b4c4377d74d08fed042703c1639409dd6d424a434b16c8d1b973c4beef285c435262fb2e6b8faed61f7686b01639bc7960968c92ca4b126e869a370af5a084e08f900914af3368a9724fbe20297f1268f1321ba5430b8fd7c84274d77b795387d689ae22bf7946659561fb8c6d5d732cb49ed5172f883c4a1726866cc480bf9510ebe80d5f524021a027072655b286852dad72f04367aab18363ece742ba2754ecc6619e9ee8213fbe7552d8460e6bc1b37822ed12bf1c35841dcb288063ba75d33b389e0ca10cea2592aac650ff4006c6bb85ac591323672a0ba5d9a93849e0819a11cab29aefc828ce2d28cb5bc3eac9f8a79e0319532839f07babdb28f0617052e21a2dc117578b4da57123c5d7ddc695d939835c1e79e3c8a690ba925370703cd8ce2052cc373f886a3bb7acdebd96bfd41854433f8b419d1c9238cdeebc79d2b545398d71ec153f5059711cce457dd20c32fb2461372618c8e8626404bc9f205ac999b1195c30c3e49d81bce3bc442e228344ee97d57adddf75c8588899e4f64f462b1e31dfb9ceb915aea704c09a25c494bd054a218232f34f83f81cf405f3e63946038336ec9b87b44fd4050a624a56d18fffd3d8dbf9037cf8b894b44eb884f0637e06f2c5c498b29f409b86e5beeea7796d4c9e853d823fd19246270548a1d34ec3fc3c9633071601ad424d6307ef646d41f24016ddd11d32f084f92fa47a7ae93602b7e431c378dd4db6a7f0af9a30cb9308937629e314f70e68a6bfa824b38fc7c3d8f6a670e817a07eb1a74c304fe142597662f220d5b2050a51a710c605bd6a27762608d5477edd580e1fc36525c6ecf4d3196f91b37364841efecc60bf4dc3f788b0cda11b96e4305c57fb7c96ecd204dee8fe7cea58010435f9128df1376880fe23e3e3a004d9e1dee198e901cba0208533644d3fccb1e749ba0635faa93a00ee1cc203669f344f7f7da784c53422c8c261719c3b0dea236504545adc58e87e332ec3bbce1af57f4911f84b8b9f23299573eec89477daa1030ea570f8eda013e249d28e47ba7ca30b20051de4f764dacf49e761a69f8fe0cfc2dee1f62d46f3ec0ad2e15a601ed62e1e75a51441e929b5eca2aa92b8d395a1b4b567756c694038a6186f0dd671ae4aac0ed93e15624b5aa344c7ede1a8e30a720821d648c8fb36bf4df134caba7a025f86bf322522931cd5b972927d9a2013fbad45037f7d50a521c71969736837aa417bd47f76b13a419388a933bb7de5137d1f85ff29a01a8cdd49826372f3ce88ea243190009f8605873c5f675159bcfc50e36f668c8ff4f2872d36bf77bf85a7dc43975dd4b79a576762b24592f0b3412738b68f322c2c70b1956d8c9e458786bb18f8d4c976be8dc0f3e53226722b615daaf082b83d79070c445c87876da933c81918e2b85df53ce3aec6007dc3ddc648916edb584a55e638c580499e8e4a3bd81482def573e49e4dc5da11770603f4b4a135d2f2c6552f5b6cc7a5b55ba1a7630ba450aaa794ba68e3b2b214cd6a74f8a599b1cc7abf9b9e2ae1ecb2849a5ff70a9ddc590d2b8ad9b0cf8c0bed4b6cb6c8e28ae48ec110871109d03f480d5ae0eb2757840bc4a4feeedbc1307c5832ddcb3ae2e13eb42e8738125eb45b543216040a2ff755f4657c56a8f22360538300b8a4b61abf1c25609d6e5b81bf91b862e7e436497178e231940a3f1e4d1bc110af8b2cdcec2f8df27f07232714a809f47db1234e461986768609fd42bed56ea460804b8ec23f9e153487d4c90cbade1c6c601fed437b35ec47720d677fb8cbfaa8143bd6c3f58122d5cfb5b498e030e29c9e97cc9c08ab95dc21bbff62eb28ef7d21505adc226879c4d823a3ed116d936e800576195db29cd1c8f765d70dcdb02a969dd00ecc116a45c392e02d568e9b821270bbb3dc8dc218a3c2b820d4e28d96cbde7ab844eca16d28f5182fdbf7483485a1667a328f17fcd89f4945f6b219aa7277eaf9a8277f00462d5afa4162211fb6391ef7a5a568fa9172c45703b2a3eab3f356dad7cfbbced3890b78e1c1064ff66ee45d280c41885b00dce4f4736d81edbecb18cdb850c97b7ebca43645a70247f7fcae6439553ee2046000823f845284dc296708fc4d29ff281f0e5996c50cf886b336ed4dd2cae5f6db0b26f0c06ea5058af37e6a555a7e86d02e2b9aaa0337e701b5921c72e16609096136b3b3fbca82fa754c35e843bc1e494be93beaeb328d0ce5870818f9cd4e582f604b8ae4ce8d64cf75d72f5974964cedb45932020231442bb058d328274ceee1e0857c55a468f3a950f767f1eb95fcc19415401315c48be197f21f6f8afc463b662abd2041ce39dd3e53d985949d4065c77c3feb1048676a69b6b721f88546fd3a63ddabce38215754f2612c19ec6aad4de86cccd40e10689f91e6ead09b70466c0bb1a781bef0b21ff1be7f236d3661850ea0d4819f5fb446b40a6ea4b2a8e2507a7e43db0bdcaa8569c675a97113c0851375aa842cf10bcd5c9ed2ac492a4940cc664872798666e427265f8e64426f76a3b2eba2d094447209817a5f286a658fbd273e8b134a7c597a0b755e342eee28b4b6c35b8fda5a1043fe79d03d447d297571d4f35f7e5faf139cfccca3ff6f1d6914f569b4fe7e15dee21dcdc57efc8e605eadb14ef446662110b1794d6dd2aea304ac5f49b78d08015e50fa6c1688c95e748029d211b43b50a33a7e486430d0a6631395c0920e17629d05ae7e2d7a1cda4cc1ead77a2751ff5b48e1aa9810e129649887f6b23f290faf8d7bfc90b1511c2d07389735ec0ccb8051387ee4b75a21acddeb7e5b1947de4fdd1f1afa1715ade4ae64222b223d65302202c1e4cf49f7b3051d7225f95d392176c914f59309d45ee21efce3052b273ef0399c8656bbde803f8af735a25e8f753b7afd275d0b237b396295d9290de410f6de371aef8b3ac77153c4ada8e1a5535531d6e1b43a71517995a33b775580b089fed9ea4023bd3f7b53b9fb39ca438ce969a1e8ec1060213ed81d7dfdb6b2177427349a4dc432964d2eae64236257a87a820fc3256ecface8b8ec4eaca6ad79957f0d44238d63d462e3e182dcfd12cba86f9c4ec7b5b29aa0956679a6ecff18f68863bca81126b3015062e7280b36b66b2e448c35f3f428a63a566a88ecc001045faa540a29275b6a6f54b88e306075afa12c85b4c7f8af924956fa11dd20cb63f228fd1082e98d1df0f4c643768f714b8c73c1add2de057cc596a7f15de6474305fadb929056e98f79d3c7525520066a97240ed7b4e04fe3b7cee2c663c7ecb118d8076de4f409db8bc27b5c8c5cb21d341099c5a9081a89894e65fe7ee20cb1babad446caab54932daafc07dc5e29d602dfc842169a1ef2400aaa51c56933e410a25a257375b437a720d5d91562a8f524cf62f3d078f5c48f62b69d5be88ed01dbf48e27630dff314d77e9eac5c886b98889a279b9023fd02f045d372b850402dbfbdc333757dffd85090a91a833252a8d1254d3b429d4f8d25a18ebfb3dbbdec51927112d4e98305068af8d961230f06e03fecc7f561a3ae61b19c6cc98b3cb58147a498c55ac004b5002ff5060c06f58ecdc553354f550ad17f21cfe761459b093887395d2e92f59ddb093f2618e0474bd4044fcf5e71b1e2e37eec60adba71fc61aaf240693984ad292723d8c6b7a24ebf3e7543688560dd9e2b12ed7ca76824173dae4388e5e842b3b79292b110bf405ded0ce99b3f30711a8847f7d9ac39c691b430807e398b81d9fbb6d5f1f71094f9e905e2e81895a260148e0e649d46d828c64acba2af267456dc142f4783571c177f3710f6c6f120f1735d4a145d2d1f7669004400108db561b56a3e8bbbd27a68f020c1760bfb1e1e3473bf1b015f0628de4c1b115edfcd99b7716d31e107b024b0291394433960c2634788985631094fa69d255501eb2d596d51625b80a8619f88726b7b962b66021fb757484608bf798572e2ae95281f620fefe1cffe02910e4cbf4d1b57088f7aad30e67d0dd155e8a6b764fb773686891e61809aaae37ce323f9c7fe2dbf9eb9bb6b9d0d8cbeac918914c271f544eaa07cf0d12a5d09ce0856996c4037ea2fc81038f7fbc5630a912efc6313147ae6e05d34f0462c1c9640ec3757ba26b2c69d92cf08170a220924397e8e4a88d740c62590fec482384bc88422c796ec9127f6f52de77ef45c6f8060006102483daeb2494427845a343ad06254f8c9bf2dfec3932cb43962f1082ff2bd4bf4711b44ea3d091ffe8a1ea5ca7049e376b00ff0e28462cf1c570a6750752616d140e36a1f851cafd06c99b46981adccac3685b07570385788b21fc3fa2337c82cdd852982e5bf21e9d2f6948d1b5a7ba162a7824e985dfdeed3f23b41c8831e91f6d15ebe9f1774365a1a1862c46575f001e1cb92d922db126a4db50180f0baf4dd5671878e23c86c0bbaade16a103e0c0b0fdc7e76be739d00eae1fae69dd3b5f9fb1b5e47ac2b3e69ad383f49f2d56d41d12e55e58ebd8b69edad18c15089e370e34f33a671cf367b1d6ff60ae57e9c328bb23335dd8595bdacfadda1abdfb3390781dd15acbee643b665ccb9cfad96b0e085ca441bc80a4e4c8e1674d66c26bb3b202e5d682c16c38a57fee302347e60439a20e80f58bbbfae6dac3bbeb5fd486988fddb322b7cffc339d0a80a582d4b6312c107d3a04779646f9aa7dfc94cc371554a6e7991a278debbda74fe5cc689c93197df6dd6b93e2bf0dbb13488a3dd1cd482e5d5015dfd34d793bb9305287f343f7af803a2dac910573ef2833dc1e4e1908df5d9cc1204ce4022249e70153907359657bbed4e2e8a09089ac0287306acd480bbcbbfdb1357ef2c5105fde2e695b8c9cb12555979586f654109133342939565889e7b1510bd147d2e8c2aa6c865f447808289374c50d99eaa9a416de76b451f018331fc9679f72bb07535b57d5737f8a7b044c6fbc30272d99906edad75e6f9d8b793b95bb36ca41f0dd467ecd1df7f500e6266184698d55e00349ecb47edfb20c3f58ca1ad385085de58f3a218ec2a006a9f7fe426555b672d3d81f6e5268c4edda3249cebfafe7d2c64a4447a8b21d80e4de44fe276a050e21a9755dc98fa75d3d05addc97b5bd504b74b3cc6008715310c991c4a5fb08d8ec238139743ea363c6f3c63563f8a62265169b9832c6596b474b7c21693bd35869c6c6e375f0391e64c827ebe961a65b053617386195b10c95a321f345ea8ae4e452a71b6f7295f4dc32436a3b1f76e3834e9a3e30db37aa754415d86169d5a27a5eadd5f0104033c03474edb24de5089abae516bca3844d4f4949eb10d1aedaa46c6e046305910d951d389406016194d135982a325e7486a90c83947b5e718fff93d930c932235c5a73e9911279c75a8ba2b784bee6dd62a1470a1159e095696c712c6a459f9367092c604e4913e8fa028332d4c3ee2f6eb3df0db218637ee45881cd8e9116794e0397885d6880b469112038685442ab88df45504d889fa9b1789fde41e1034725a292374756ee6d9d2dfd373b94fda0300faefe066af199069d8807e942b2f4e82b5b1e7fe91759a656628090acb62a6e0b45e7574c1ae94db3d59223a54d4eb6b6a910249b59d924912f7619be49b950207d387cfb61b47cb6600d1b42fd35f3fd51060506efb77911f26a336662dac13a94d144f9915b978afe5bf083dc1e8b1d173d46a6ce87b23a34a8fb4ed84ffc201fddf385635a564551b3e74c81e371895ee9899cbbb758b7b12af9c122575db3a287799cffee86f56dfeab15ed390a07c1c5dc9fffaf38d96422af54404f50e88e9c0ccd2dfa925ac8ddff34e9c15de229413242f605d376b503d7628897155d0f0bdc429cd9baa1cc85201f80f99d61e49900b7570380400a2ca395d410afc10a3f39a837d8c4aec12ae965993838fdbe1331542142eb110c1a9ad08cdc6c60d62abd2167e013912e5c7e305684dc110783acba9ee19728da836abe0bd3fa583554a1d30396fe201ebb873f40e68caee2fcc9b04f3ca6183a7fc0ab3549cdcb39fbcb92f687b247f079c745d10bee263d455f19acf7c0981e0dbe7443867418e49e14fcad07a474fbd551f90062aa0c93c40c58875da159d9e87f20f4297c1becea9f90200229b97f28bd071e326d592707c8c6031a75968990b1c62f58b3b70722d5e822cfeeaaf6584ecbb05b8c24aa8450b7d5642169f7357160de841219dce0c9dc0dd4b2b120fef81a13284bd141c3e54df006987b15ad19d7bf5a3acc602c935df19ed15d4f6b86799b9ba7679174fb75d0375714b3753d62d8470d7a75c16da435a4f76bafb0e3678467b96167bf13fce1b7320937efad8efc4c827d2efa4e363cd43ce57a950b2a6104ee5ec1f8073d8495039e3391a0dd20ee6b74f7e63ec144eef75d97b026b4702f256ce706c7e96c20440831148165eb8828fcb6e3f208a467461b78bcbc3e18878fcf3cf0d426c149dff4753cbb594f0e9e76fcddb56b5d2caaa40e9eefad1252f24bbdfa25f79c98759a6d46d2445e92ec34c2d613c63c3bf3805cc138eec36d2317f6dade91e1bc109bfa1ca9d793f6b8593d8fa45611e55d3c40f54a8a7154429ee2be8bd4643385e1b9c54793ab730f288e3cfb5da9e7f0d5c249cae76bd98c955ba2213fe3bff61c308d087c3f0abad3a86d64f04ce5afe2e2c2af3be76a45631b05d31cb62c8ff0f7cb2f95dddc7474ff4a8f27949a208f6fe768f472af562e4b442cd3b294625c166971315de328ef70576f33bbdf555bc4f0f4c81d4245d1ff7c8d9905caba4c5f0d845fd1d72d1ba2f4f295fed1d6d9a78cd4f9b15eff1039dab4c6ce4b6ac9ab05da6b227ba8cbe6bb07c4e13bd6c854185bc1be299023889b95fe966bad6e25e9375d9206ea2a5428a22720fd7f0978a7977b7b19d9c977d32e1308b403d758ae638e4b4023e0efeca9338f8fff7d369dfbef677dbe6b15638cc60542edc36b341b3ad9a201e711b0064b42f854c17b4f88f71a0cc2f91187fe7b2ee912444bdf43967e6104dd0315f64c1d8c59f80f2fc428208ee14f0011b1c28f7c85fdcc1b1e21a4827fa5f57b321a77b4267ee04e5f39ec84acbc309708f26f0bdf285abc5cc29466a783f0b76610458f7b97733a976c1d010a5ccd5c4161d5226242414444d2e50ba0f02b5826ff6156c696e7094187a0dbcc4ce9cf144e338ac9df40c916b4fcb968ce10743665220f08baa8bea759edbee32883e18d73521a7ad9e656eeb836cf842b514e90153d77b8bfb0ba6461261440e712201759b0216b94fbc04bb73c43d380c040f276427edf9a2b29ac35f479f34ddbe84c9e6b263e1daf7bfc37ce4ed7888a530d4aaa932e4b55184d5b8711c8abaf8108ea6a0b801e1ae9b28295c04c91a075704e28eada3f5e8b455056afc1c4ab3c6379f6ccd5aced1dc7f7a89fbea1352861ed2be68e7d8c428ccb99566674a2ec697a14f8d57b3a703759cc25c3249c570f5704fce8d25d0b6ca3af376e1cd9488727f8c12ee992e2fbea6d330728e80d8eda00a87949d7f51d99dcfc621deb6bb726eecda159ece8d51f88afaccfce5d5c1587002d9b33059a1b0deded5fec5b2de03b122ca32fd3a2d711785a1315a41e7f09d5040edb370fa3c04ec025be5e55badcc5a6948ecdce5ff5e45f7eff71fe12a3aff1b769fef39c6495f6233af19d929a1cc33a30d0534e87daa5f4ef4ff42a00b7026cffef3791f888e2657e417b1f883a64b22f2ebe40610988fd2778f0ac657a5400ca1e9bfa763ab7a7095f6abbda17229ff5b81dfe50c0d60568b995d6686c92e520b19356f3eae89fde17fe6a57f51be4bf638f29e6c465138abaf2298c4898f29b79b71a2ed711b5608a7093ac4ef14e22fb7e6d7372d4247f54925542cb85938a66210bedb4e0c72c18e2cf62377010bd6d7b57843d0c1a94fff25d16c7b9d7faef3ded51dc9cae2aebc463421566d6267fe35913883bc850384cb2d062f5f59a87c6c1824c604a33fed9ecbb4340a4c32ec893ec2c6a9b590c59ecefd44fd25d1992dc5f94d5901b0e2e8dc1d216e053b1dceea649dc2860c00bde8793042dc0d870389013993c957397c2d2867467a487307e7db3f98d091c444fe6dca79cbf33ebc8e53a6374d031d298dce2c1bd4100261ab9d4ec662e7ebce594e9fd8c13930d6f3447d896d9370a6092a4144dd284cb8befb53f30a11a4eabbf2ee257b819645f038f50c20f12c220cfd9e266f386d22720b0113526f29863970d8b0756d78efa791676391580b38f13dfcbe24e2977bf0fba0b2dbdfdf5068ca6e871f1355d48bf31a9de3fcef7d65587fb5dd8416b5edd780990ebc7be4a7cf5cb4bd97f4090ca41a01c5b8920f4249545e13d401cb3acf09da05a2c4b94464bf85757b9aa2aa05a89ac27e0fe92e79327c5197ec83880ca24ed6ccef67a8f4913be5350241a124d5989bf31ea71da3dc2e5e845a5c2727edae44b81b0a20db47b72910813560d270040b13206f50790c3f0207eadeba46f8ab6c19130e80f2533cdd7d6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
