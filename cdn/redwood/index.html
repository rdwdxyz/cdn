<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d595d8be78be5ac880b4ffed1a7681aa3b5e49b9503328ba67bf7c3eeb4f3f11531821fbd662b2a7aa286c868b4ce889fa27b688cc273a31a147e1526bf6f95c6006fe8b6f26a2a391a35c0dbf239a3e48aaf458fb367f029141e1d72e4d843888c3027f9bdae4bf93e68763b615582db00f0f63dc7f3bbb7b44a07f69a70498908612b69537b1a5b0c41053b89ada949e351dbf64c2a502bd6f02da3cab5534020282fbcf62f31b20b700b8cf01f1414133abf383368d709396573da15b8e6cbd6fddc6489a2789f5a54d6fb59e7c86f7661f29ba9d044c4b891b2e26b7ecfe9ae4beec1d87958f7697f3685d1271bdbc54544127cab3a335cc3bb91a5bda304288df53fee2f2e92e4311dfba8782ce36755e3ce58ba29d3104cfb652137e70148512a3556c03301d0d2c4d208c34354c930ad1d90c7b4431fe25a4a805de10ed6cc070350281f2a80f7abce4f5c0d67ce3a78cd16544f75c55fc8f975610dde9c5eba3aa99f2abcd0af3279c9aa3c7fdc6940b4c2910f273ac45b3aedc4ab9a4998050ea9ec1a4ac5b21f67a849143aabf2a45d2f9c4afedaae85bb7467fe3f5cbff8f1b2785657f51ce2e440044b028940683785d33cf8c59e79093050cb6698a15838c7eecf4c74c6e6269232dee2ca0c922eefd271518914af8ed100f2011da1bcbaae50b22c2d7e85a63a8e1a430c1a3e561e5a698da18a3ede542f1e8e02a1d9d7dca9c967ec94c648cc27342b21d4e5e6a081fa935a15b95f777176b1f67751b526d2f3b176c68b36ddf3826b325162fc10d59e0553da3be6e2c0650f23b7fe1da2f0c483f0ebbecffb2d8bb60197eaac5af7bdc0d27b6c1ca13fb34ce34fac7221c5af2c57ab843e65d00495c0c65f8b6db97c735cfc602f038ff7a5a8d365406c65a38afee6edfc119ef64af3da2b29f3cb591885a4d828b91f46f28d0860fd5189e6b2153c440123aff8ffd291e27360c2b316e839c6a81874aa89fd071c2b12845fc9fd6eea634c63014414853b69038bd7b4a14cf1f9c4b1dda31ee6ae173ca5df25ff9d94b5cf6cc4b76f791dfde01f315f615dcf3aceafa4da79a2b8583c1892f102b9f7d20fd760ada96469213bf31aef2b6b2cc254f73d5b278798d540d66fe9a6922f039d73472760306da0977274899bd5677eba33eb63cb47418a6e4d3571f5a767b57fae620adaad3ae0ae4b34d9004d2b3cb57cca1a503ea803057cb2e271014b9985bce1e77b7423c7ebc8a727672b4b8ad692d0cd1208d2172ff68fb393751f86e4ee99f3e9aa4479dfb9c295b83e8fdd1d821d859fd436e8302f2cb87c1bb8262f895c3ef4833455bc53017211224ba4d09ff21cb701807f325abe0360d4290219b6889d3ad6c1bcb96e3a1389ec38b15ccf179b1a9501ed00125b2083fdccd91bf1b180399db547c1653712b1cf60642bbfb928e69cd1e366c44f59f7d27aacabb5b4885fb6ef1b3009b71d1494c80c36c57a1d44ab05e339edbf1f6aab99bf5b3192f67a72d602fc4bdb56826b4110599b54a814f4c846f8f674d69782716486750440e8b0f6d7a09d7626bad68051a39f7c0a16d14f5d6c5919b545476baae0530ddafdb5b3df3c35909f8d6b755bec0361c4c68fa030c5f851c1ff8c0cb643da24982367f3dfdda04b4ec23353c938d3d82876a4cfeaecaf6b1d671154ab54978a91844d51df04d8a6c99f7c338d55f4d181f2a3f20eabf1c3e09378049fe842e8bba9828080a9dd96c0bbb4101552ce4fdf60878232c5a56d473e33bf242623f6affc2c3b7750fae0f803854f2098d14ff6feec6b845c3a954579d7d3265659c680ad3c606b191fb86161f45bcf3f3af196285f557b3db0e8b73770c065b2db59647b8c37c661528e586a2d43670032f14eabd4e4e81d314a39aff0400a3a2bf71981a03af8526be9d386851394588d4cb87eee21e154b634a5e50f9789c82e5c2ed2d32b23a0c7fa7cddc94131e752e25314bbe4d6e141a9d5b972dd7c95d0e3590c4c16570d4edc93c0f77abce3ddafe131f42a8239ad21aeced91a4dd9e1b2726864e1903ea778e8cd2ff9029b6c03b84e5d7240e42272a62750da99421ad02fec3a918c9cefa482becbe37578c564e38089cccf236e9a55ac5df140a71f4943c03dd8be58947c440aaa4612d6b44c5c04b0944f549ea3152acecec019f51464b873a1510ee70831e22ce1e73a022d6546d566ef15dfa9593b1f92efcb4c0928d0aa5de786a0acdde7cbadad23099b5f239aff347f378e13f53e139989cd8725d6850e05e1a9b4fac74a336f1e4792a53ba62790ac1b800c6cc5ce75bbb31ddf7edd985d210ee70bd76bfb3232ab893ac5fc56dd897f0ee529f7bdf02d0d46ec6a6936dfaaa6758217a95f48e92b175ff9cdc16af6ca9a8880c40fd84e49fd3de1d9f72c6c2f84f7d5272e1d39f0aa33d257023d8431afbf52d56274e34a648cf2c6f3c935bb7a1c8d2a34f3362d537ff13dd626775edfd7ff6db3db4ff6a53c07aa29af1aafdeec2b0b1fb1302ba3e532c3a5dc3f3e1c6b7385c0e9760501a199068be7ecc8df330fda318ea03ebedd1ddb2553cbaf0f9e7bf0f42cbe1c5257e50acb7e73f5af51219a39b5b1ca41ffaf8204e549e5664f96e887ffa58693bb6cf1d372557aea242fcdcac2dbc4241eb91dbb6a23a1417164afe9b1e57e764bd6f2bc398e2735ffa66e0ffb272205eabdd10b08a7df3974fe23a5fc8046c61e381f5a7ec6def78a8929d9bcd4f7cc8210e57a395fc18f39b902122fbad3e44153d5bf83fa7a96610462915b54e0a448fee601ee3a14c160d28dded363e53beb98bab186d5ad8cc061bc6140389bc075178b4c3dfb992009fa83c8d6e03005ccf7c3936ae3baab821009ea3d7af207e7c23b67b2c76fffca90c05fd71c5b5782041b6b418880568d79b3214712f9212c887f790677954a29de73cf87286255a1185cc86f21f04d8f4dd6b3d3403518bef25462a37826e6e23781d0df9309799dd32349860ca7b8399db1a69443a2d517fffc09618e1424ab4e278131198c3c0572e423a40b20a5b001ad009fbee2a967689059641a1c1ec4886b4ad058bbbf30e76ba1edca85cd8e126f713d9970fcb79e8a1249400418b22a64e86c3eca3b813edaff2b0501f762af840535c4be28190aecb542c126f346d799bb938a6f79983c18034584181d98765406d7723d8ace2341ac0f6c6ca379f7b7dfd25cf68686d1a40d17f960ac2f74fbeb7cb6be9aea65afc102b4b0bf33cdaa5c5ca079c913be1775417876ed9d37d43f6198066df6dcace5b1781a31d7aec8b67989ba8080380ce717093a582d697bb0b33574addd1bfcde85aa57528413cb70ffd173900b0b40c28599419e2a5487a46edde44330c1fc0b41182a553297926a00063e08f2d6590b3b0526bdbc984731fe9c62e9587e596a493a3928af0b074a8ffa5632740cb7295e509499314a34629f04ba3df6d61959f301d93264d603d7703d454bb51fd4e66e585c5942cf66d7761c8b0840a207149723c1cc445d46e544a1959ba261e32c1aff3cc0eddc3ad38e13fc01fedd015649ef77d1a15619077bbf5c23244edae01c75834e8eb7c83c5501c6c24f676812529cd64935c3a56f72eda72f9bf88ee0d9645176c6550121bd060f35d8d7076f557cf49089b577030de8fb564622cbe714121b8469c8796ac08e2ff975bfcd930ea85185d543e09722b78af6dd810027512ef9a6b0fef2751722bf0f75bb5e7de782ddb7f95d23d3fdf8ae13f57bea37832a1b9d3f87b3c866049e1f3ad48039fdd291fcae580e77287a2690f35ebdfdca10bf01039fff23f2301bd576723381a7f49a4308eb44df5028b1b21941d98d3050f36988362a88ef5a86dfc8242fe1a3c741e24c97c9f127a38c3b6baae85628e2c8f82ce9e32ac2889cadfaad3614998eb26436f106f93db77c30e0ed45f954d59a10b96f0b3ac4f9a5a9441915ded8cfa890e7121f78b38bf0a8c2bb5acaead644b1617b83e0116bbb4e15cb2f1dab719b08f22fac70af606e15a066c06e24b5c4027e725c4345f8d20d6a243f429d91e96fbdb183aa6661895a875b56b9209e50ad9d3a456b8d1c7159b7c13093d364e40d1b68e650867f3db6b13d5232a8a7ddf5a104d0526cd49048f48d11f24d69333c1a46076f5e5db5ed5851f235f42a96626309b9faa42e76e409599514c3639a8f24095712aa7c740072350a159b7ff74861081e71127dc4cc6a09e19b91598cf5c15f412522ebb86e1dd04180ac38c18ef641fdede06be3384f0e27e08bb34ca38aecb2fc345de73653833217dfd6101edda15c5e0f607b828ec03dadcb89292172db46a2dc7ece9d45492c63b3b6b5ee14437388df27a552e86d878e794a0275c5fa52bb22038f53b777ff99b61a2cecb0f7266536ef7266f0121cd21ec6d3355662aeb723c0fb02fb91799a104431200c5ad95dbe5252361664e5510459cf77c3d48ddcf618e52c6be97a1879a2a4cd7c2bd848b039997fce52750ef4a7dea1cc05870dc6c1508a8bec75c55250f231d15d0050b6b5e1d0a505674c65541bd9b07973c7630059cc6f76646f2847af0fb61b4461057946cf92397bc4ef584f85cf5b01e5632413db2cd9e6867da45574f9fedf5644fd7b692688d044cfd341cf834d56384ce8446822c949ebdc526281f925c5f0b6464037f541756401cccb35031196ba6054fcfc8903948efb219419c9ef5dd6f94db18bb4d10c09af705f7549398c1f56a41a7bb3f7d181651d569163b1c031fd002914e739bd762ad304020b5870bb6636562b56cef083f6b59a3094724084baf6f0cc94a0432b56a603beac0d87a7350f1d1f1c27b4881c6c5fd5d6bc54e0543e85f3132d1b4cbe6c7727d56169e377020291e4222ec01ab1a5442ba88beeee847809f72c686582764489df83c20781c35437ad5354641c66156c2fef73a0059f21eb58f75d0eb152de728acdb5e161c21aa1e664683f48e883ff591cc63c22ff0102be684c980591866119171f518a5df67d5411636e76b8aedea7244e2680e999b94c16ddc9fc6c2179b5ef4f8494a1baccc09177120739019e15f053a14f72c08bb6f0cea991e3771f1aad45b6ce01a3e8cd8c86dc758023118315dfaa1cd14dd7e9a000728aa924b0344344e8d908f6d9ac753f4db1c7ee98c50b37ebdee882e46e9e70348948eeae6e6dfe83356a1346c1980ea82932a4d0666206cd8071022017bbe212360191fbdaa9fdbedd9c7fbb4cdac9042b2d8fcdde64ee25579a1e875eb07e20752bdd096f4150fab4ca75e964ce708d6c225c30dd2ac423163ce1ef33d1bed7ca5cfbbfd6da046c84535d9fc4bbcbc7b1e24152dfb8dd9844dcae08994496383f70ac2acfb7e48609fd95617caf2d0df375ccc6d37213967f43f889285846dd2320a795774ad1dc8e3dd5b5ffc69389affa3ac543747d83abd67d8fb11277a38e67b714b8f3563bc74a7a5d7fca2abe29a87b35cdf8ca7fb8b3bdbcfedb90a50b38f0fcf3b0317fd78cf2419e5a4b02e3b500bbfd90557703bc5a035235b0ea500876cdad607272ffb55bf80d1e6ca061456f104c00d9e00f5ad756681e8fa0eaf5bb51747c8434c5373176d4a4cf463c3957d2f52da3e590a7731951b0a9ce02f1d078d090be846f927fb275fb31989301f1bfa661c5366a05131135ffd3df342980df923ad01a03f4643d87f12987b33c049008509a5c2d78b0b05f746481a9eb180b21e8cc08cfbbf046de77655b9c483b0aad43f7ef3495095e6aa3c5e7103b986b4ddd919956172d34626afd38d605504236439387bed0974b2ef87b85e2633f2143ed1ffd662a33d9559a4a72b91312dddbd6c662941725556f9e868c4d964065e3bef2f935263744866e642ff16edd91c3aae8b39298ed031591447711273e80c7d1049fb977c06e56651482bdb0749b8343b70c327881910c0243d2bddecd6b6470676b0ce28c9f32fa890b1c1dc5f06384f889596a6d8d8d19587587d7d0f361cee3038b9d7e672af556205756bab3a802c4f0a9a1a906d8f2be36eee11b033182d4379f205bff42378e075c721af30a8f0f87c8f9f692b414c1bc19d9815acb6acbe3ee8d58285b4e41afdbe96054a0f4a529342067a4c845413e3ce4d8569f35a41d8d3ae2d373481aee725480eecbe2b0e8e49f927a2b697454670efd26754720de018c2e8ea44db58809428a16e7216a6417e72bd4b15058ec237f8bdd53cc5a59f174f591a0485f64c9fff9c10dbadc5a0f2beeb8746bde1b7dc816d80241b8a3809f50fbda65554b4cee99bb8b43d74e62b23b57565a4d292e9faebde8bc73491c8111fb1eb159beb346e02931781dc41991bcae2b5c4906edee0f8b24ef01b087e8926474e36efc8c0f995adfaa0789cba2ac8dd0932fb89b1d3b5165af947dad316fda063a488846206375bb80fc7166c4d597fe5da4558f6c7c7d2681c6bbfeb4f1ae84019d4971deb43b9576b973c1f3765be397f3e22f10d2617cccf5ab9092b34ddeb028f286754db64cbcd31cb01168b62081e339007f17455d3eb358d4b7aed69f6b94da547a6402426cb31e36a156e032ec56bbeec0a7bff7b302307516e16d0862a7047cdfdd357ae228a98862d4df72d36cc8aa50b20ac085eb17e2c2ce3c5432d074cb5a6349df6d0dabbcb1e9b6601571d01546199cb0189055f649813c2913237caa3e830016db71058a5ce8d6e67bf274a69c860398752722f354fe0917cdfdd931093b7332b7ba7a11a39411adef78efa28b9f9e0c421a1e15388026b98fe78bfffd3bdee7edb2f757a7d6929ef3b02accde3d8b6e2e557bcb438e0f8848a874f7621dd2a61c5ef31d1a6539768305f6d8aa7aad88a75d4f66a00afe2ff9818a28bc47d56cf50ffdf1bfe3c2555b237b26fd2d6bfa61b6376012e43ec29598a620ee971c5daffab01f6ec9d5e011ee22ea52213129cca0f03826479c98f0c20f12bf21674d0e6815e7b7366c874a357f2063ffdfd54844528cb7d51d47cc5767ef2ce1d89a466658692e4a0d7a1f2c42d14fc5a898293dd1545a769ee22300539cef9e8af12b26600ed953a3a2691ff1dafcefda0668a9c94190c6587212203f28774f9e88a6360c9fbe489c27535f7284b753ea6d5ef1afaa7a451a3278b2f15bd07d04556ba84d3fa58b4d29d4b67d545a6e1c63d5403c46dfd661dc988be17ea3fd677ddeab3cd21d455b87ab0c4b13dc31e370c87d7b053f68aa497ac06ec6144f273a085a2a74152abeae8ad2d60c2ef48de16d8159b9b161940b819c93fd8d992b9cb51cbf70d1e0452a5bb010185b0ca2ce314e1324abfe0d3514ccf1726318508a94604f3d53d8bed900865335a8880c369746ac8463beec66c4dfad7cb4f139993b163e30b03e10fa3d6d0292610a327fc9162b884a58fb0651ae40da5be799a52196f9930813a0efd62498e18a2b963caf44237e041d53efd83a6ca4e6eedb8ea5ba730edf5a8303dc37beb51bf7394d692dbd4c9c1ca29b834c8d43f174ea830a8735420b945961a643be312cc917af0d876e8bec9f3aa234369c18d6d225fd93e7f95da489c010b0a6f6993de654134e06cc17aebcf911d021d6052c1d529e7ef4c17e9e8ffeeb9f0d5b998c9acc3e98afc1739588e8eabaf1b80daa347ec7a0a9a0be4c2a40c45a1e606a8891f19c465e2a9d6b1b8155628b5c697c779e76e89200f4c5c94d06db7d9137344c146e3495a8ae26a5db48099cdeaeb167cff461466e3fc0d03d69336767289a4c4fcd669224397ada32e25d113904577a8627ecd5c57fda245e2792b383b94572e6825be2ad9485251b58674f18fed1d469d57e6b20795d8be289404ff5ba6dd2367a49b6c3ef1fa6a88cc7191f1ef2a128d8a549521a62c50db0ead1f6511ebbfe6d0ed6d5815174db57fb900895276a8e64556dee819aa63681d2b162e774cd03c1a902565ab810430df4a20c0cf2fe913aa25c7f62b6422fa99f8bef228331787583b9350eccc254f4243bd9cb1d886629b57a99b0abdf3dd6911eb575582f4608d7874ef924f16dd74d11efa4a61028775b681f0df1e34bb8df3871f7c12d5c5733f2df4984847f3b92eaa7995885189dbf935f49720f34dc6f21fe59e04acb2822eaf59c342998803969be3ad962cf3ab6a0ec015a0856893fd48d460707a1179bb020d4d9a81e975ccd621d1fe7aae4c9b310c0470e8351830cc95a1090bb34bcf4ecbe5534f1db410373e7415c7cc9b1c4aaa6294538e4b2eae63c9a907f9440a225fc16c0d3c45c149215770cc4da8728ff42503b96d2b7d8f8b7cb958f13ae3dc5fd544c3e7484610e6de7e58d971651400e2ea12854fbd10b130a51be1a4a04e6b3ec5c5f3398f9e204093913c5944627e338391bbf9aafe88ec91e13b3f5229669e6df2ef7362e4cecf33e4868463095b518f0fec17abfe0a40bfc873fdeaf59a85668057817792db5cdc69d5242ba2ec6760c34a8c5010329eedde37d47bec410b59af6582e00370b655712af7cad4fa067fbf726f80fc9b9c3615a0445b9a4707e287e1a844417c26d2bc97737dc274fb8f0e7ecef28cc912de8a0c75ebe79b1cd20cec79987194e9ea85deeee372d9ad6aee7dc741076fa158c314e2bf8d7e3d78019632ace5c41a6f03cb6f8a3f78f49b169a4b244e38dd6f3db4ca8d397b47d5db08b05fb8169ea75640d3c84869800a08f95137c2371052edb7a029e4e63cfeee54f5ec1f60c06c59195d9242473dd8e1144f06c9ef3081e01c638afa4963b876dfc43981385e1b2dc2d91116c80040c6282264f04e387a53758dc42b8d4bace28233b38a5260d9706f6daa377c8c3e9c4f38004c6210bf570b1f437a9043f3c785e34339799099295b042afae64a3e08688c55302dc456f80d3e0f55a92d56ee5887c9acd2fe68b0e3ea6a6c127d9b44c10fcef41cd0fe20c0c0cf23103bda826c85ef5a9c89094701f74a3412c5fc6fb1757cc12784112e818c72c6c8bef96e95b76067b7f5a4e53f71382fcdb7461da58b48022115c7e387f8b75c6f8a9fc5e53506941c648a91a955665bbf4304be1d3f5c0c4a48a83e6d48c557d181f95b26ead68966403e017908803608627be0065f5fc18772a703402f892551c31eb1a7a805714f0c7395524a13808c9edf55f2eeb262adf185fceddeb5e042c6d4398bad56b9cdefcaf5c1dc34b893899494b61cc12da89f65aeb16e06c798382b7f1341d0086ec300d980cbb2f802ed5edb89d6f15ebc6ee7e600fccf5a41d50012203029a002dec9679d9c3c5fccfa1b8617c5fae1168f22da5362bf0f474767e3435b85c56dabba0cea4b419d587db9cd5a2f61c3726ba99aefc3282b56bc137e30b39a24b4c0b89704ced51953ce3bdeed8e18aa11c55a483ffedc6f6e079d3829bf2cdf9b2610d25d5be365b7eb91b611833e466ea3af566c699053cd9dcee47806d12ce248184b40e40120ee772f79f4846855a581e2b14871851aa76d15074700f828e8a43000ba5f5a949e80ce8f8833cf9d46b8de3b8f53c2676112a3ff30a8d0877e88dda25ebd9f3e7771f98bb0db7ad7e0efa3d5b9293367e8f50a963d0a08fc0b6dd84db79af137f8d5aab4f5a47f80868ee3bb261fc3adef95853f8c3eaad786fd6b791da078f0807bd3d3180cdc33aa1f3be48bfe35fd032f3ec98a7f23e5010cb9c5492a81a49e17ac8ac872c976bdc1a6eb5a93dc4c54fe56e1a569d44f63c14489a0bafab1d069c2bc719a2a6b2c71e6e993d9d3d3f1896e770049d6560a551c39ce8e7bcfc45541601146acef2b69ca6388482688576f2c367cc797f8e87fde6f70764ed834493fdf46e12a673abe3c8265aa4f69183330bbfd418e7aeda827522fbe91a1928256294cd2bc031540626ae3ce748ce21a2a5e4c8b009e0388206802b2762f715014e025d3b33a0e3444e09e2e15467329c223cbc7abda4f862c914764a1e31244a3b2744bd1e090924f514cbb5474a94e8879b1ff4f9e8c956c82bab6b15ecc3b6594422ca15ffb51b8024684034338b8c156b35bd71e10467751ef64bf825a0a46fb040d0f8356736c85f6b1ce8229646c824a4ed66e7b6a8d10d910f0f4fd416f1460143adbe9532ed8d59d5877461121c92e0e8fd8112f59d3b8f69a677f1dacfd12a6e4b7b570479022ac8a0a139f28acaad3de79bd01794cd726cb2721bb800f722c8dbc4d75a05bbd9a50611d9fbe7f3c30c730e6cf3bfd380a50f1b99aa41ef1f4b00253cced82a14eaf2fe2b43c4fff9e9c1d93447ce21ea3ca439c1a090322c93219eb9e725c5728ac074176dbeb5fefacbc9452ce55f252c4fed3bdb4d0d920a1322bcbf3cb5a913b53e10af2d8280fdb239a7fd70433d77f4b881e3680d27ccf441fef69e73ba2778ee190745f4b0423de37dd4298dae0341eaeeff596c04f9003ac3981e7f1c473a9f9c4b73b36fe73fd978bee0e27e500a4bc477482e5b2096c15c558f05821060b0f7c219683130c2e2bd43fc60e62e2c5cf4c96b77b5df916578649a5d3bf459dd88249ebfc1d5b3a2cb498f3bb8b4eb23de5264e94d2d60db30d3c06d0196411ea12ead4c5037ec7c393ed45a49679b5c061469e93432daa7046ea54889e7817dc21d0879332ac01fbbb33e0542d1e298237e26200734092c48d3c111a97620589c57eb7e60d8a0bb47cd50dd99b4861ed237f55868333ba506ff0b63a886870a78e39dd62f92c9e3c9ff3493bd57de781cd666690166f60776d52418ab00ae42627f8682de2d9dea75c30be532bab710bea6e52ae8347b2bbbb514dee33da9d6e3caf8a4ea3b533b6339f575f4fedb7231fbf0c8733529275f75cf92f8dfe812dfda126c7f3c1cce8137ff7db9a067888e8b8f3e1d7a3b970b4717a142d45038dd406136d88117ca7227591b4fcfc5de7df77d433ab46b832e774bb501f5d05516fbb38870b3962a373431727509745d17f9f323422591aa9fe7ef5b023fd2d28ecc05dc87cf09e257db9a4dbc377363861d536c53709b909d0bf7b52c663d121ffa9182ce47db573e3143c27fd5e11d92cdfa28ce78c30da0159f1de6e989576f45c69078f2efc78fd05a34ca2b3a6b84f9a6f530508d6350b4626aa5bd74ed003137202cf1571602d09b7836b6248c503ed5097fb878e30ab495ded2182aa5a3e66ac099a2a691cd56a9262a83a1f5a96d47d7c842766232b4c64cc9e804d8435bdcaec23d933e99392e3eace09bc12906fed4302d0ab1474acb9b5c92496f3fc63275cd4eeb4f391cf640337cadb0a64d60d511b8501b4f0334d9d3134240e379904911f2a2ceda7658ca39f6bc70f4da2436db021c254e530ca7c1b1d57e0ef85ba8413caeb769e5ef55efa04af25793f19fca55cab4b62ffbb089ae96c9a0a80420d1533dbb490023bc1369a6bf9a0f3d1680c58fa6bbcf99b3be1faec094c50b32dd9b3233ea3a3c0972722e9b07da8c15a20623af8f8cc5001525a275a3bfb7fa6b22c797ace43f084d7bc30ba74f37177402c3ed35bbe0d85d673fa905a111c4629b92a65ecbe2142dfa784022fbfd3d2835fe1853aa3c9c01b1eee7aa86216036280942e9c05202741a927a1297f64568eac5e390df675992a652fd92fc617684091c04446ae3abe0a645b891dc25538803adefd6288a4f50dbea9c6fa39e13de4105641140fd11b7909e06a1ab46b4ad050a7217647905581c62965474b1d5d0a7f035aa90e592fb15e099d01021774bae4da1a51d56a9da9b6b0f4452efe814b1ab4c57fee5c15178b753a52bf29f641558b61114ed96e22f450248ad622be8e59f5262e036d1068954b07186558c5007038d41caa1e5ba3d66b04e59c0ad560d6ccc5cacb18708c4f316b7d20f084da4f12053fda95fea14abf7b8d4e1422c57257b85e27a35bee538c7c40414dff7e0069a14d073253e8ec631c2741630a4a22acb6f2fe72052a11e8a52a2504ec14e52a24bb91ebbeef7e6453518195e8b7be1aeee7e77bfe1a09f2974f990b1700b6edc03e0b3496e348cd7579f1fd7ba630cc56f49d44035a9d61d79bd63e39d7a3ceca97fe5b248897d857c53cf38161ee3243ebe09338204308b20988a682c17aece8a95ec6faf57d799c61d56aa71874a2156da4c587dad0ef9cfa68810a5619ac567f2165743ab5c628ea3315d5b98101ac2a7a51a0b9ce25021a3cc05dc788e1a40725f58897d99065f82f9f1fdb9d0e2ec332dec3d9963d199fab4b52ba6e00b0b0592c21b0c3831f36ea4dbb419c4bf1fe424963328918a4118cef2b4ec649d87df8b4cb21fe07d06d3cae5585847ee8a6fae232b4eb97d8a7fc05393485967e22b94a71aecff3f9d016182303445827ad2407e2fb480e680dd083d406b20482c33bcd53db706af9bc3d9caf47ef4aa6df995037ed3318cd8e728e1950254d8ff7333ecd06f9b240dc92451970d96592bdd9236a07e111a77cc57d11b67013330cf5b3653c029d4b8fc38a95d3eb79eb87db751f3efa33efc5e7280758160afdd3e760240be3f8f5d115b0829d80d148fd7c6753d3f18d62c4841e43d18e4952680de60bf5d8d10a739d133197246051098c6fcfdfb2324b3b7912fa049d3cde4d962117f00d1ae39f4f564cd1d1af712647b6e95095ae67b3a9d8c152bc81df11e582b7cb8bfc83a4bd8cab3643c3a36e705c79b3ad540043b2169d8ace17ca873c3f75f3a93de2646698ead7186af2a1b6a18d0c5f86d32767f930a9dfb9d7a0bb7ee0c18b9cd0903279ae0bc14027cd4e702b57661d895872a697e1483c0b415e317bb5267ce5582b754534b4759fc47365a6824e4fa25599c93453ff4b148c8b72cc9bef6a9f6801fcebffdd69c4491fb69eb2fa5430f9d1a825d3e0cc78f6b7db9b95fcd8f4288cfa0b696372fe498e0a4b70ce56803453b394ca0778227809bfffe92b97968e2e5680a8848086457459e0e6cef5e327886578bb689e36d997e2561aa30b21b78efa1ede0ced434811e4addefcc83694433ecbb0683db19b1f4f217f9eab8c627cf88c27d91626a0c26518f6e798e9061d305bb6661b9bd4f4357840d12b36f8fc0ea32d023f86207265d1c3483b3e0b1ae3d646d8ff26102c51b3b54091e3c63798538904ad78a63b7351a38cc39fe4eb06387c8d4345e4b0d564a522c5c6414b8f74362457f9d72b56565514c813aaea67f6faa28ff68e3093bd4670accd41232825842f7dfe31cbb9a1082518b7bd3cbdc0156fd61ee3dbc5ef4f7b5c00ea083ecdc1df7ae3316f1a31b267e093237861e14b4335b8be92ab44e6f55c2266c69a5504fd80b9ab6924e8ddec8328e2592376e97496691f4c904d1d0e59a63600e59059f7546faef90e420cfaaf473492fb72be4f12fd2936fd0a5e110844fb1a1c94180db11c7af9292fd5e02628c3fed0a89367e4b0ceac463ea201cde1b0f381bb96b9c974e3f053b0196cb5b4bfd841d142ebe879d6f3e5e6d1a577c2d79171e6b047b311a92328f10d67880a1905583a8b5ba9bb3a4441539d99c2b0d71dcb6be84c075e74d347ad95bf7c82c9f1c23b0d9201f3f885d9f64dd78901d28916b0ecadf2f8d6ea7e0a37f6badcf55ce3f438092c728771f12ab4b9b934fb4123f364f7cfc694a173444a29dcec4caff8323e9a0c87000442c68b14c908aaddd7bba87d9f103ac2adf850582d2a6f1b16dff2f5076684b8a09521a127434dd870260f6faddef1a23ba4c9b2f60c21151cd061ffc4c6db5a34550157c0243c5c23279578613c49a757670a0109432241324e43e8d3cb87624bc8d41db0b50920a286636bcd48ec3224e613c5914abb989fb41dad7335862ff576a25b1b5956f4374f6baefb27d99fd1c5133b775eb744581df493107e28b0f2f5eadf3c33be88b6b731345f86e9daf52157e53c219028f4e181637778340b012a63bb0c84e250d2083c460f3f6043cb2ea5c1ce5c2f8a6e98b85c855c404890de7a344ab1318f6c03c8d0bbd09033c2ae46e556ff257ed6fc8381bc0092adac61d6b2791ab757bd3e135f0e92ee6e93257d636b1014fe3ef27bd044a2c048a6edb377d63177f835747779660517b5ad6b9b97c67dad0e5c4217a91fe3d03d73f08532dea6fdadf8f9bb1eedcf6848d71686891b36745500a4b06b8e07e31b6593c66c9fb5b2e273cc98c323998d838b2d155b91299bde55de60e58c592f2248d4e696057c717510628ebf38c71ffc6a0740b3fcd9392e6b6a35ab0deb628f57912075c8012ebdcc4b5e5dc5d12b7ec42d3488ee42d75f864bf567075b81cc6f7deba825c218dfaa05fe8b5f48adbe67a400a514de5d8c41161bfb80364635c5fd4731c463bd903bb170e5426d0a74dc3eac5df46de8b3cb9efe1a19b42dc62deab66582e9877fac6a45671773164515d6874f79fb65482350854c8861b9e5dac8354212909588d52b3a75c8aa745ef858a95369f91657ad1cf0bba80793717ad26b72ef95f3110acb78ac5ddbf1335a6a67b940de52ed96d890537b1cf4a4e6060267bb087eee6878f8760264b2b850e3c81514e810a2f05af66ef3d24b6970c760e3124ba75c3e9a2f1ca8343877fda4b013b88b2e12c1da5662b11c7c9636639271a278020a360b6b25f09c096eb998db261e7605579607fad6a3337dfbc630505f4b05f31b36c4e098f1ab3d0d8c6be82f3d28d1ccc7f0423c40a5cdefceedb88e8e3905e51cd2dc93ee2038574ccfb46a097506948b1ae47f781dfdb104bb953ee014d7638eac130c40867fea39a8955dcc33eb314a1c6d1a07ef08545e5687391490d0fa0a4892f1f9495f9ccca7117cfbbab03346f06a46bf8afc633d84f65a6844e30fb654f81557c2d2a92e60baf5656d04dc43309bed5af25a6517281b6627abf01e09478c39daf50768f41e18695cc6b9a14d5ecb5cf5b22e1eaba8658b58a8ed3a30b8ce9efeec02b69e151a085e854578e46a13877f8aa1169ee2e163339d7aecd0e1595b63c58e9a36ba787625a5a4a5be91c90a60bef5aa91efb84deec14658f23a1eb3f270dde4f6107101f84337780d47bdbebeaf5c9dc8ad8201d12460dac11","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
