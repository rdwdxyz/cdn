<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47357f9f7fc89248e9b2ac3e8e0156248b766c875e9093a5d9da5667ec4043b9a298323194b89535156738926e2e474548ea5c171795fd893a3b670da18de78e778bff32c675b202e079e89a2ce77a5f3f3113e0710c807290b1c7647dc570c96d2000c7f17bfbdb106315cf52cb3e36c6c8754e10154968c119890697309dd5ea53d8b5c50e2ea58152ff6bce311bc847436f89eede90c8f883b06110baf3691ff64271edf23bc85ff7eb77124d557b24ce76a1f14e02f57a40c56b59868453736126fdba06b6f9a6bc561ab1a43947088425380aa1fdcdedd2a1e4bad55b14fd8de82aaf1b2a5b4796f2c795f5209865b6b9a0e988db5df7634135467be30817261e449b3ba8a0b64369fc8a88240a9d45189c2fe1d604e956fced8802a7191d358b84cb0e8c59adebd452c86dc64867a1713688f81a4b0159ab04ea663d5b64d345eec09a6213635d16e7ef54912064bc41f4772ab93014521093425577a79dd13d661aa90d16b42c37a00e27027decfe2640fd84ea6a0797e15fe411de90337ddddf1cbf608cfcdb1452b4c6dee5948b1b778f8ef1008cb1c94072a651c92aae5c734723ec7287885c264a9d67d1d309e9a8766c840d5e641718b54a07ed9476bc351a1bd5cb17241594f864586c316e96ed8dede6dea94eec70e715c2c1215ee8201c26ecd726077179ee90d1008fc2d0b4b76bf652da4fc04dae18d0b953765afffedb3567beca50d45a655a516e0688bb25944ff150bdee4aa7dc4661fd4a21a2cef84ca714a6e6a8c4bd3c6d7245ad7a8aa5f07342c474f8e7ee8cb4ae17504d8ae66ccfa113e2cb421dc88418b35178c3c54840605c5a01535e1946072a773047819b6b1478624a293c8fb4f26beac9cd7de390527856337bddbf74d5f744a24ad81d549c9a6c77707d3561e789072a25ef78ac8d73d3955bdc9190daebcfedde8015b5f7e4b0a4a88000d95bd7a4b55325f3bc2f0f7f723912ba3287881e6a262f9ed6f21469693830df40860425a3160a0a90d4dd319f0c4ed76aabe006810c6eb830bebc7f2f21d37ba2de2b2882b66a2d2d092482d5aa85903f9e2b6b0fe3e37f15c9075b2767deedc482bd9258268c74551085e375b63738d4b2c81cc9c1b04943a319739127f4b9a7e1cc3ca90b7e51fcfc5b638a71d2c3e96fccfef92aa2f9b9bfca9b16a44ae64151d821072bdf4f69a85872cd7e6346bbb157cc2d16ee62398952c37a6605c09ebeea1c0c7374909b6c38d14fabfd53db69dca99e81928a1de26f36c53e15aad12ab3b02a2b11f7de83fbe445c0bfccc0278b7acf602fe8d557631cc97fa3f741047892237cd4c2f15895e8a458e9afea1d5dcfe8a2b0aef5960b0a8c5e90817c84ad35c7f75c9785e75754ae68c5c34211210e1cfcd9a8f671d24a2c4430b46f6b272bb3c7c74e3e627a1c0e8a530f5a30c62b1da5f7dc09e734ab9b06b0eb4cc79c5e4bab9984a5318c009faafc50c178268edb5ea4ec880994ee3ed82fbdddb1868e0cd231d6fd4437ec7dcbdd9cee4c1d22e3e02b04d255e9d65d35c84d853f244a58b3b44fd85034719eb51a18bd69e2a66204cdeeb73516535a2a1e29c5b80a47c57ae215b8324bc17b0d8df5440a47d80ef152ecbdf514eae52961e8efb8ce3b62259b5104d403b62a3b344728480c0d3ce6783377af6d73bd6bbbc31aad92d7569e9a9a8978faf527fc0fcc2c667396d5cd63993addd3d21c75cbc07f92273dd362973f8e5447b9af6ff05bbb7f8a62119d64ad466f4d83ab126187383b22da1be86c23434e24599a465237cc67f1a828f8d963ad180502cf88499510e4218582210accc6e77799b5066d9f586903d06882b4661837ee214f76c76516655c0037cf338b614b67690c7c79024f8603629b6ff914e2c7e03d227eafff694eee2330d0edb14961eba65b51d72e2eb20984e73ff528db27654afc1459ba233faa796a2ce360f775743ed60e372697ffe698b434bad02fcb35fcde7e7ae7a0e916f1ee5637bbad61ce660dbe4472159469f758467b9b3b71fbbbcda6c85d06696344b0ddfa1c678818d3dc6c5fa5b3baa52b0ac95e423724bd885ed4dc9dc53d2c671c9fcf99a9fe8aa5cfb9999880ac40cae2981ada5265e4bf4d3c71743f3b12e4446c5521a73112b6a1e9471097c96352092c6a20b85dd0d62c17098b71319e360c0760f90478fb6ab5f11987f8a052223aaf50ebb22e71e693fafbad16cdbdc48cf7c88b9630ee22637b96765780e22944e591b0d4fa3136bc5ac51e98075a8a96a18836d9e66cd1ace2873cd5099df217fadc71145690b5c583e51e1c024a8dad19b9bdb3cfed658962d817ddb01a4226ca8607d9ad30f6b7bdd3afb46879ac4828d89188a5957b3f0dbd251032ec86828444db44e8e5634192a2f1bc3990a265e79f7ac36d89aaa2f371dafa7d68aba4fb43de54f5c6989d10d2d69b1ecae2add93457994cf9eca4484794056de00f765195edc23771250cd4a14cee3b73d97e9d832494c5c306b2a5be41e166e52551df1a01d43952f6a9f308c904399336a21deafec54421d663ad0801da314be1f5a91ae09758f75e8fce20585d681c6e20acc26802baf89bc919a386f46da676325731603023be19cd93862e580b329d085003b7e3112dc4b547264774fdc7f8f52b8565f1d40dc4a5df9b835d3c86a7e37b7ee516f3430908192d5d18b2a58ae70221850617c57a2b44502d4063c25a51fd835bf17bfa1293fdf74bf23487be77dab375ab50a600e02e7f080742fcce20e5c328d5b634c469b232dba241f5154068c339c64adefb75d0202bd78afed8268ce61ccfb37397e8f9c74f3fc3dc097a3f9ca05576b7f545b74d93203fbf0d11a992d1692a6f7eef87451552d4f605b64bed4a0bf120eeb464bfb1a4667540710648b3c836f979cb7f999c98dd4e0be19f08fcbd1bd1c5fbb998529c767a0ac450f4ec66c180c1042557035c734b7b4e5b5a2af8398c6fc373f4f300b21698bffab5c482b008568e31401d3b8bed48b82603b87567ea3d2d1e76af34003c78a00b7cb4867c614eb83d9b8ba3972a474890aacc5e416e0c0ade4b89b4348474541e8dd26903234d89a02640b326200ec7f5b0006ce7cef4883028fd855e3c72be15bc785cf4dd1a6ef2251afe296601acdbb316c13bbe1e105f6d06b3d6561b3a4859935437c6130d9067d2335e4440c0fa2f80a5526e92789185a706a9c00845c8472bea5ef87cadfbab83d8b0962f7ec37ac79752b2f0a788f7dbeffffd59903a2b6e0a20c5593c4b467e90c36cffa5ad7cd1fdfec6ba6fec839e12d227005ff0af923f430fb946a58fb6a731ee06031e92d1bddbf8a8c1e8c3e6ed5fade1a27aa30f84cece2e990f1c13487a4939daa9a38225893e8fcd365be8bac65d94d1333db57785b07822fd1851f09dc4f6b6810d672a96d663418c7a51b2a86f1947eacf6348bb5b76c5e69aefae62dd8c5d05da0c534d1736d030ff97c139d3c385976fc7499b29acd6369a2e2d86fb0df766a04926e4e0a33b658d96e773199bdefa7a9729dd4493d04bc4ba629c5adef27dca2536bddffc657742ad5039628595132fd58ee6307943c93759832f98b6c8dc8fbcd45cec50fad233d647570974468c0cd0bb96b29c2d4e57c20116ffa118e22ffb1b6ca0256e8d7487c90ca1a74de5674cce28ac580006e4f13052adccc76abd43b4a23fe5c93a34ba373cdde86a05a0f7806d3c97a9f6ad5af475fc686b454b1f9913713e5adc30d422406c6fe86a9f5c4d83c85abe3671248ae7b2427eeea271426f1315dc44a53acde94b53543ec0404976db525704faf8751fa8dda26e50433e5368a22b825847ac38999a67a6ecda41aa511b9b0a7e2f2a576188e4d39108cd8b6065eb1f72309104c746da40fea727934acc3c6273e0c49ea01a4e4f0c2bdab8e7f9375051f4a4d4328ca766b924ae4e5d03f52208bd23ba0cb8dc3d9c4a318aa1eb549019a045549d1ce2077edf83df205ee09523654416ba6da8c1093884348b483edf266e29c27961576ec2f6bbca5e998126771aaa3770f86fdcabe6f77515196e2dd532628f1c2cb9274b4b78a4aab641a1b00e3bb0781d71b3a34888f2f36fced0a31bd280f176bfa43199fdaf054ee6c8f681125599598db3b3681d22a226c269e31fd4347abb63a18f56481bc86632bd86be2e6c27bf53eed46eb2508a90210d0faf673b79e9d60ffbaaed1b36fc0b3684d05f2cbb0d4613034f0f1e05f299c852675f329e19b6b210d4255c009702d065a3a6dff34219f7f8845a43be5353c7ae43d010e8beaf5f3029e54cccbc5f239f14755fcad91c4ed428a759029dd380917d2cc346eb5ac8d822ccb1ef563109267b68b3ad76d60f15b9ca089d5f55e24bd17b7e46fc3800021676811806404949725093f3dfffa21b2fe85c445474e6126abc348dd31a328b4e98a1b72e9c5ff39c8f569b9d9d2ff128d45f3fce679a93c5440bc25f13dc57613d2cfd3ae7dca06307421900251e5dc9b8222c89257acba781588b643243965f8dbe61c718cb12e7f81a93a22b834f1a4caddc406f8203ee8fd5b4d41b36efb4936993a48f05a56d20ef503e558a701da8138ab94994ac743ed615c88d789244234ef2e8f0425cfa8cda3a61384238e42dca1a3b045ea849c26f2b7eda12221dac80d2be7fc14f34383bff1914330fafd24c5d7272915be5ddd2886567d8cd49b04d244d6756a616b0d875c2abd646bc1f167379d2559054ebe628e3f13132c81ad9e65b1d56df008565b594eae66bd165fbd1300f8c1ca749052b14f24ad47e79c7174ce011a5357d1bc7aead4ac769584ccf64c50cb9541d14fa3e3fbb74b879d314b7489a308ca85d4ff56f0bc32df17506f34a078dda78c2388e64a3045cf40cb932acf1bba109d62a2f6a26ebc64830292a41f390f8902a158d299c7873559f8ad14a04727d0667f38747c8abb40749db8532f566c7e96fcc0c28002070d9f7c83338bff702b45dcdf70fd3b4c54470835f3a3cea5ed7aa3bee4cd79be2acaadf55442e57b17f7d6f7eca00c553e40f9995012cb35e2b6c708d3a09810ce54e03bae7fb6e585646dea79d40dc8a6d62f8a60a0aee6c0930752c760a3a17e029e23903897698d599d06785d9a1aaf63176aa42abca69c556d50d71fee9f83439f333b9eaab3a91a9de9c455772f9939899d3ef098e0b6f49f7d12d2664c18d678c75f7cecfd43fc3bcd1c487d6df34a78828b54dd45da4a4dc6228ed064fb1a4678c5faa3c8464d43ccd6fa39dd4f2c8010f1e8d35e482eef4db47d234df4855879b3673f8bcf2c5a997b469dab1fccba90833af73798ec5b283d5c922634ab6b3c7d6d43742f1dbdde031a30fb7962aa8f96da95ed09dae31551462ee9249197a3cd32a4397c6b9f408b77dec5ea875ddb09b44be98931d6bb1c0d9c76c54eaacd4441ce7bb5befc4fe723a319cc7c09dde2a84f6d893d456b0ad5248def4b42bf2d51a82f59a5e141c552c2835a39f7fba368aa2b835577f3110231188be2c1ee76f6569129df9dd3fe5c2b41298ca869b914b4d1d2b041f45086b81e727e3e1e504b0e6d27a55f04164f000d8d2e69bcf88ac64e43e035b4a51932b865bd0fb1f4599253dfbff1c8f62bcdb89f4cc3c4536c51ca750a032535b14c4edb01c9ee166b23a852683f729dbf3ff383fd2b12b8caacb367a4ff7d350d56c9da268793151c633f547dd1d4d8a71f12104704d49d6036dff5d7a409247b78dbbea9efe0041c1490015b2c789fa33e0c598619f31dfcaa2b819807d42d33ab92e3ad9d13ac64690a1dedbd45937c0689362f902e8abed4520c276a553d3ae4a294f7b3a47ec0ba08ef4e88e1bfa25fce37e6eea625073e38bf32ae24639549ff32579a557f224b41004ddfd1bdb0491cab0150d763f77b6aabc2cf6d4a29fda62ec74df02e9e8bef50426d7b919f210af620535d7b66651075703aa3d4b83a765cd7c8975af5d03b2dd1e9463c6d826e8ce81369b964bab955b8fdd14a0e7f3b3cbca9a8ca518197e41846664b9ddf29ba5052bf669758d26a714d53193c2e15ec5b1cd3908b07ee08a5b994bb588d0cbc92fe848cc03f18ac0d1cef70676ff5b0de94d2e9a1b7a4fde4f447d28b6ec23f52f7555d1656b033c4ee17f5f4e2398ac0bc2b962dff02e68834c8ac0f4005ed970baca6e2ba4f174ec85c0088767dbbde4ce88a3ebf139eb8c862856f9bbdad14fb681ef09a7432f126209869d1c5f6332938bd300b666ba8b4ec0868211a1f5aafc0aa3082a0d7fa334f0842c62f9771e9f118534544fcfaccd2c1a8b029ce56c087976c734f5e38d75155a5d984ff15d27c3f855bc78c8b5626b4b7cdf199548198015e8ade53bddc5c56e7fc9fae84494a201e55c34439e52301e13318735ca2cd8664a6093e700c30f1cceba40c9e4cc0ee7d31583e0698c48fd4468b2a72c16cc8139a97582eed6894945163d54389ff0d1127f41ff0b74569576e955aef840add47d1e927484ba0e1b0d8a9cd6a1714bfa46ab3ae54c8172a8c80b8c108cc381b7a9208bdf8f6b9a28f5eabb2d9cea951c026000f90da7e0e92a10bca32c8625680ee380174965bb2af5274c41e95aa3f5988e61f427c12617ceff4a4ca4830ec0944c901834af01ef51db981a6f2c918fb9e8d96ea55720cf06947ef47ad8ae35a135491baba2f06e936b9ca2cea5493ca6639ad084223010d3209cf03afb66c1298920b79fc8804f6698f88796c8896d8359f5778f3b1113b641cf0d8aef87b8fe318b46311b7c1f29bc41eaa7529ae18311dd86aad3496c89e58039a346edee335d14920f53e931658b83baf8c9c51c359b54c825c3c77e2ec93159609c471bdbe155d375bf1630acda2df1ecdf1addd730db607cb491064a51f8b188a20d94b025eedf10d8dc027ad55d4b7e75ee58c56cb7b46f555d3fc72452ff03a0505de6cbc959a119928039afd4b0d7c4f58760e62d2642688044cd196f246a2841a3843972190c4823a35a1674c64b0c4ac9c3b922c1a2bafe453492f340bfc73ae5f81a019714fe0d795355a6eca9c23336fe610c9f21a7a3d54f319082f9f2ce9a074b64ed37c4eb17f74ec0bc51610c4daa97781f34d6db79317de5376619b49335904618eb0186b403c431337e1299e7e6b5a48e49c32ce65ad08037811933f79ef5c4f42fee7fac421cddfd3347d34ee7e465b29cdc7c7a027018c367eb270a00e98e45ffb55f942c0315859d3d814af859744fc0e686ebcd21faf9bbdf57c640daf0e17f6c06de3f21a6ad25410373c85d8c1281fa4addca4f7d840fb01e3c9ad5119169261aeb745bbd0d5ed4a056bc90e675326380d11e81bdf80c47aef499991fad7b37846b93eb757ffd5f7750b039be3604a2cdb45240629459bdc65d5657e0ceeb936c52ad27573db33d6b92826fba5cbce065a353e42159e2b8788c5d995b30cecc19548edcf5d97046b3014ed51c91e8ddc8e309507c150ee4e6c8d9c3cdf24036ad93a3aeca505a78916ed7587d6eba55b199f78bea81a8c16c8c4b21ecb0c6733c1d2115c1df859caba8b264090a296f8d3361f027ff74fc68e2e526694addaa353c894f8746781be57f6da825645a204961f825de6c3b7073317eb4f6657170237c86e77bd8b34fd0ebad5eb9d8c28e4e7a48d080404c77f8cd3c852413b63fc7d2d84088204eea95d90352a47e0b70005662d098e88be3747823545212599e6b5530c21bb2fd2fe4b2a164bd92aab969295ed1bfffe4e06f256a989303caf7c765109682c83a61fe8df278403b6b8339049f84be4e7c3a3ea6192261c542db9908437513c91c6ad0a91f896ff2b3275a4149f6623c29793320f18a0ac750dafcada5debf3b334db159bd1d93d2a9f841e29cc922d53d5876a8d4232273d8d5dafc9fce74ab69bd7a9e8bddeabddf5f5565906ac781b70615e4fbefc5a443c21ed14f6de975acea1ed4550447186c4d3cb174630b9e8c34796b95f4b30b3f572a143da44f143439ffb9afea81e8e64e49e36cd8d9e5278b05ee5f5a808cba0730ef89bd08f5b67b223b96906d57b3401161f407e681ebb587017d43264af7808e95289a1f12161e70328c1e9fb476c02d410e15637fda2a26e82b930d169f2b37566c8e1349066a1a09cadc3b3113b6deb6e40a6ef75bb858757be05bde0fa9ef0152411e152ebf5179a25a4e8492694c276a2d4305502abfe86242c856144dc0677d79fff3cb7496e1592700331cf5a9238752bc4bb37544437e5a72a80b943950d4cbf6c15e73fac0ee8acec61513aba5968bd9efe15672febf3fcf957a18bd81562fc34e994070df86486a21447be98ba180c197847024a56c913f0bd8d977d51d8a43660e6b340dbd52fec8fa3ee3c3b3520109c296f129ec2a83c58b3f16dcf2a8761ac64be7d635caa2f06f94ec681dda68e37a847020e1f302fc0fc89eb256e72025da25a24dfcb42ff695c36457b29ff6702e7c860974cc5f7e4725f8898f78105037918a81208d591ff654e86194e6a51b850bd229836263f42a12a5226e87bf9d903d30a6a03973d1c788c504d42c756604bc9dd6a4f24a59849b9b486ec5decb0f1500e5aecfc884d1fd923c0e102c3785db4bbb8e2874282c483c7b178aa37673d695b9ea0139aa870cbd7933dffaa201d96bd1eafb8dbfae0aec3540497e91dbb11b96b27f5c779afdf57377dcf1442c96bca0308bc516224107712cdeceb97b7bd2c2649c50f3a0c7eae876fe7fbd895f0a6efc90dbbf68f68759cf3326f3f33d12a9c13a3925c9a8e5f2c1195576433750e343db908d47c95d3d0c0f07b90a873457a9d1b599269215781e871c5825e7fa3ee2fa7ff6460df68f8a804679cc45b02c6c52075b2c608ea0ca8686c0563b34ea52a3ba84bc468d61a2c20cba3e402c7eac3d2d98055395f346fe0dbc0466877ca8043a9f0c72fac72d1828e305fc0ba88a59eaea1166c0347771bfbcf8c9c4404eeb368627b5c6668ee1ce5dbe88a0c1c4e3953da5dc7b05b0fb4fa57454b7ecf396908dde24f8ee78e0a686c3664735543d624da0d21519ee97518208a2efce4952921e1be64415b753be6e9a984ea48b52ce37efe24e32f33f2feb9d37f0f987378b4990cb082109150336c8dadec6f4042b8ec16e944ef20178ee3b1d6c86274d828c35b4e5c61a86390a53737f77647a0a45a57be368c34694c89f689970a17fba8aef8e1bba069996862bf6d889df98bf1b63a14c08bc5dee34fa0bbe1877e9908011a7671004afa9a3c0056e509b436f2ca0464627619bea64690ba10b3aabfa757609f931fc645c8b8d7da4e74810a2d0f0aefe37a6a69d9a0099c23864bbe260f29efec9bac1046587ca29c1b6a9521e6fa764476edfea5b6ee00aa1dc331b87ea42fe585ecb14dab3ce141bf3c0338aac32a0fd82f711dcf82e7c9485595153615a4fb4889de3b36b5fd4e8a8e5c5993ce71d121fd9296e38db43f50a1ffc987ef26ebb6b4aa356ee4223ed3a5679149f240fe89dab72777599762b8d989635af5ced8887123184393f8c22a73a73c14c53cdfefa7830b8c8157d5c2263fb7e7a6c8ffb01a04867566a4f75e8a4c4fdb3c5336ad06e10f7e21ef4d67ab558afddba14a7dbe6ff7bb5d443dab874d37942fc44141b699e8b6a3aad2492f4a5aea655a9bf63ded4a0e04a0b2a0a0976c635527343a7df5696daa012f41ab1a2a0767b7e0633e4adacd8eee35448ad4646cacdd152fc4e9e49067ce97e3cc615872506d0536e15d9e7c004190961c557ff06965ab7f3a43aaa008ef13bb322307bd2343bbf0e4d0700d2757605d104fc996f341644bcfd6df8e12fe68fb270714d8d3e1f8fe8cc18f97fe4f8c09ffc82843e80e397c78a4896fb284542ee8b02d27baa6f99da10b4ced69e3339f9d751cb871051826b6a8df2da82b8c8f5e4280917ad0cc47af2d0fa3279f01dbe26cbb1f006fb827d906de0fed3c1d0b4a949d4d275cfc0c5a3d995f84b85bdb26cecedb8cf2815d36cf99c3bb8291fb6731e7d2faa685ee725e208900615b01e61709e6d0a0fe88810c90b3c6f21b259b4a260d7c881ad02d36f89f430e55eb51056e3ea3544e1f9d46b61b1941cb98e55ff6c32acfb880a525c935326822ff24bcb06f9c8ed38b53efe34173038de7247b39157a7d9cfa6502b0a585e84ce472fb2c5a2d57bdd79403d9cf7bba883f50e111fd1ce790ab606501ae9d5654e5c5b41b9470b9671140ea0fd6be85f5f160ad410182ce74a122080ce3f7ac2341c97f5e5657ee44a5c30aa71517e2d6739c9fc0fa307f9905de6376671bb0df59c2c3a343c4ea7fd732bf06da2b2c58202be9323f8de6e617784be217ac290b5080c7523df0b30c0a9b4a2765954a93b540b467124023f34fea80edca4178862a53e78dcfd28cf907657b244112052b609f7596b394ded1cdea6651303edd9b72047e881f2726744b2168e1980beadcec24986fc7b79a7cbbf3ef3d5a54f5fe66258e1306c1a218a68041215e6f7e57b0cc5577e270dfb54bd794e1085d57a1ce45e217a8428bd33efb68c7dbb829cf7f0710a34603dfaa5f89d20e914fa8f0248798871cd87a2d78fe6d5f1457e9041a28f45ca54dab2d72680e43601d576e0a6e0dc12c4c0c381ed24b3ee9b9bdb03353023aaf32d88b71ddefa05accae93df29015da20310560070bf7751744791e48685e55f7038d061578f53a5798dec9642599224996675768df65dbe0db0e574b4db1cb675a72526efdc46e31c672242455e3145c2cd6055fee649bbf808dc65086a1cb3f6a7941111c168168c843882ef03749a3b9faab4e1ca2dcabf23d01d9421192335ee36befabc505e2bf67c03631ffbafafa92ec2faf04029d54003c959f359fbf9221b9b6d34fe850e969b48b7f8e98086b5be07f0f8636f83c8e3c8770dc47d1ee15707537cfc5faf152e8e239407c37cd53bbd7b40facb280cd47577b77d8a892bec3fccce6666c0100d4aedbf3bed6be8f129fab3fc59f0561367c63711ad40de181676fbfd61931c4ad16ef31d1dcd13bd06ff28771aef131deedb418f0adf72df20df91a850553c3d81b5eb220acaf7aaecae55173713cccc9e5e97dfafcb3268ecbe38fbe10ffd75fe96379074ae03f0b035e0ca77d9e769af5320dbd547711e3252a1d063ceef8058a40c855369e6b5dc287f69a3308e3dd3eff34a97d6f010e7ac9c2e0db0075f386ce3cffc7fee5a2f425cfd5f52d84b05735e2c583bc435575f844a5ea5c90b9b917e22e95bd37a8b591320b80cee3ea96a3dcd9eb437380ed961d6021cce2c21f741bfd3e310b823bcdc20ec1cce0e46f252949fc464a5646c7a07be58e2dd4c70910b7c9a668b52a5aff38309605fcbf2493835cd189ad34db70066439c51b7a7be2c87e71144c6b305f1304ba25e5109ba6ba9c9c87dde73568169bd13756d4983eca68dfb851a7a4a764b7693ff5914b1f00e52503f7311b203501ea6d3ded67f3b23e70ebf5b2bc8ad601eeae4ec5fca7310c9419372cefd96065758978387c68acf2c1b721bb4918d6f679a3c88017a20576474009bf1abebe08bc0b97a253daae6a42c2bba973fe1621f09e8bbe04b8eac275fb50bdb07db842ca7d13387a078d90968d27443d2d78ab40baeee0843ad44b5b535e6d0c2ead1b5b4e59ebc417cf44eb47643aed42e86f83e87c14465e5aadae6d9fea7aaf4ab134283bedf7ab2e62033ed5f152d842e713aac69822cb31f9ac965cd983b32d722f41e41ccbe087af63093c030e1253a896934a146920169a0e42b1b3881b0d0a67dc80f98a33d47ba31743a474a4f11502084466543a673d6810a490aa36628d562bc99e58a4025139a858dc28229d0375756f595dc6cf2eae056d665d4eb9974ba86caa39ddb7f73f89b82a8e64072c4e3446428e153e98ca7e0acef95bd0fb9f77f2da9d119e8d437962c19ae1a7cb18665056af9b4a1be7a1506dadcc1f332ad8186fb8bd1b1f5856d7bdf1b044e1fa038188c434a32c2dbca98a21dd71845c1c7d85f205193829d62c5d54a94cad4dc1f57b1f6ef94b15c0448961ff5e8d29414882d1ddcbdedc39b66fc2a1abb44154db1b3ee2c6c7a3ad099b4444e427244ca7346428d8da28cab940a8d820dfca3bf8e156dbdb963ce1630de8c312de5eb594cf55905623c09d9e84ee542b774687c25127c8b0d86c25aec0640bf96c38384b6dc67063cbcdbcaf4fbde499c4c3a8163dec543b4859b0dc093440a79a6398b9e5769644be8959005af48f36f4d7ad7c6267bf0258cc37690d7373a03a5b9d66507bc464dfa86c0212de799b1d0c98949de9a38dd9aa3669bee42bdf43c766e3088d552e06fcffb12aa5ad0b30001f593e173e5e0674ab13ce6e649a84e11626c931caabb74bb52afa80cfe71428264ec60aefb3ff3680740f5050d47f5577257f06d62c040efe79112b71c22842ab10ea5fc79bf1446c5529beaebd0ffb73bf045e03a4c478ea28a9696250edf3fc1098b2afa5315f9e44b32dba66203136ff4db9e7a314e0cf11854db7317873a5832dc639581d8c3e3081b24e092bfb99004230ea8ff39f45663f9752bdf9413b568f8ee7c548921acab873ee402472dd5fbd6c2a35504454591499d1ec8b4db912d1e91ce01dc56cf59795c6fb85bb557fb56ffcd7f72c0fa9cc3d0a3b9e577d31f9862204eed4e01bae8c67425b99c5eb60c1b25f91f6a69846b535cb8b9a7b571c711da3a316a6e2f22a5a8fd7cb5bf4f2c98e86ccc1e24791e5d1215795d200f91f3cecade24cc493a1e0189f4900213f52d1fe2ad75c75b81cfc9786683ba88b81d62a0adff3a368ed14b9ead05d47d3642e224bdb6b12cfa30853ec295b78df200b1d70a1985e77f10fc3c7803ce21ad831a3e495d60927f33c7d18309abc265ae51e1d3534f909a32811e24fdf4ecf966591962df1c175c3382b4e6efbe6751b563f0344f184e8fc4080bb226566d317607d394666e0b8aff7a882d451f60510a46206cee1eed56e99511c7dc9bb908db3f3b4f32720e3a7d1eab2c0736ffcad5ac161896d09ca3668424a5575e25aa8c8f68ade0da9e6a3766227fde8da85866d4d87014e8efaec16050e0652f49e08b3eb7fa1a4ce935b7785d091020f2228e2d78d578c21d255e120aa93c1103f4291a31004c754c78b7d5e3da2702a16be225c6aa08af045e3f82c61c2b2410bb47ef17a637d33f01212cc310accd73b8b28bd835a89778b607a3087ec75ae02a49a662e6c64b6eafdf5a1fff57f2991eb3e96fb7580cdc1b83ce5dfacea940b06f85900b70ef310a8d62059563558b4b0a44a0448683312576db55e49c4090a706328dcea1950435f6eadfaae363eb30c2a5f5fee822bd028be31b4e4e710de455d4f596be0ff9b20f367cc80c70bb36df2e38cb185c48248fec6ecf79ca191c060282838c4ba775a447975824272b2b9492fd6247810d40d7d7230443dcaf24fd397be042913180cbb492f2ae268419978126a64fd45b154d84c9f2d9b60653e4469b92be81f805048bed5e00baede46ccbfbba0397deb60cec9b50ac78de2bce1ee64c0d60f1de31b75f8e0fab7558240078c726783756946b0dce798da9df976f9930709a60be021991bee38f75deec7b9b58ece5223b0a94c117caa8fce44cab4f4f9c6660e70d3165e91bd07592de392c0d1646d7c7ff3a2ac79d6a9ce368f8e45787c56d6d5f9aefdee1eac387f1e90dddf19ecd68cd343bb465d0b31b0a8672267e82fe966e9338669e1807770ed1f495abac0af70309c1bc2ebc6d9bff2c6c2bf94742b7f52569823dab26172be85e81e90b85c21cc83acc0be51e782c2a81cee31577d15ff0e029302a6c66abd956fdc7b3de7764d138efb58e4eb64b3ba9f9cf069a766fadb43ecb1981bb004117ed4d5a0a16fe28d07872934957c82aa45102eed9072d58f48c55f94155357e24f40a1ff30d0af76df9c21938483ea3dd40e30ffcf3ba4976db6ff9477d275a4ee8ec5eb35074edf461ff224723e269829f2152f4b90b1fa4c9ef4ba5e1f9c5556aaf2b3f13525e23a0f0d1bf85b63dc47ebe9069a2945636665b21c128cee2cf01bd2efc2196b01f5044aa4b49ac1e8dec4a99775648a1081c5a1aba89d5909c774a6ebba4415e893abbb16b43d5facd10902019f298664680913ba4667d10da7d4d1f17d951913f0f92050c930b32d659de7a71ad59c8dd1d7f0bc8a6af788b2af57df67e9ce4e4416b7e2c2fb099533877f512ace6f430fd8856c36a2e837b84cf8bf14b194c5fcd42d6a7e64f02c8bbe25f1c8c73f53ab0ba9821f10fd4e43e8d7752d9e6de4739dabb21dad3e35ddf95ef3002af149f406a351db31636f96c132bb7f63c7ef1c5892248edd2ad4d6fe65b062cfb5c4ec28e4714fb79e0fdf7caa39004a4354224ccf87992240ca5dfffb77ffc90b84b484c38c2c3ef26730fbcc9c4dd39a30525ec6d903e3e35488a3e8252651ec52f7df4a3fccc3174522a7307659b8c8360bd8eba7efa352f232f9d927f9b33e5eb87e5bf912f37dcfbe7611652b19c09bd21885f930a39f06f9bfffb10856eb9b28e3000da2e0426484ae8abee6f66f9c2da95ed3de4b7d754da389513151a94e469569276e9c6a21d4d37af9f11c1c333a882adc43bfbbc6e4e1f35343056b9af1de9ec793ae21941483eeb9d12d421a7e45536b7a04cc6f733e50f9e81dcba36c3d88c27525743c9a5cccbb9ec2c7043f63214fb1ecd0e098ab728526dfaa7df7be03d1381cbd1f0c84b395d264111e82374b11250e6f8f02c9db262aae32382d015215a720b621b1b66dd3f388a7999213924a5729d4e6f496e4daccd4cc5151dc782697d00a5fd05fbfccf8ab72ee5b2e9ac8c51a6d8db7d605c4a29efe8b8edf11b54f4f7256bc4178c10e57ab964a55b1f9e8afb26f3c88ae3113f4e11fc2fcb499fc0cebe2d0d5fdfbbb2bac7c4039060e343efc7d7850f0c1479bdeb177e405e522e2539088e447cf8b83f5bb6a3d46c436d7cb5db8ff6e94618cc09d82b1dc46d8db9ec375723b4b13ca07ab1561ddc7f4cbe7ee37b270b072bb41e8ba6f5fc8c8ac15f9f4198d6081b4a2914c40cb5e881cd9097b72c93e98028e392d392766a0903df79ea2d76cfa83972885a287680fab0f59583010e011878b5b4b23441f1003e3d6107cc788d359bcdf19f7702dba963bd27d1e6b98f899e216b3f3d33f99d0cc78c6108ccccf85dbae3cfef504c86f71fa62991c2579ba583e38e33c3e342d6a8ecf1b8b218d7d9ad18f6a45d7a505ddaa3b12fc9e5358942184631def7afba0fba1d4783f93f24186468aec291329d062e70077cb056ccb60eb8b2ec0a9da38c326bdf94d524f3234924bb0c3fa2e9e75e582c9cfac399633fcc850ec89dcf338ca6bc57dd1a127171d71913e959b243d14f64b9d4816ded273df10c542dd138fdfe40b7f35fa08e56e38df5a8c370b5c6a8f6945cecb09ccd7cdbca8d4fe73f18e17a5483b9a705c072c6442588c3d8b0998eff2cbd19edc0540f9b06c7e40fab9757349d3c10ec2ce108cde2416424f72092b426847d8395716cf91330a0d3f3f3227067d56d0cef83bb67789dc5a8cd99fd06f8acec46cbff456501bf1a48fb95b9562758963033572042a03d75dc0ff17ddaf03c09eb25bef5e800032e9e16903e0c45d2b20ecd7a9c7008439db77217be29b56a9a044eb2e1facb0ca6ae458d290eecc7b81f320cca6bdb1c3975354042b6b1d351f3447f4f9716eac361921012e67ce7107503adea4610b257cedd7f24b12a41d6c876afdbd448ce26c623a8a21f7bdf389f482bbebec1029443f088e4c8ea4971d64267b4ef184bbdb41e0099ba190a7e495a890745226b5cdbcd7061f5897c96a14a670ea64943ff2a48afc3ee4d0f2ff900edd97bc9a83e965be37f38eab027f27a7d22a4ede17040d165c3b9d46187cba63e9e955b220d79bd21f702e5451ce4711da7aec66d64e6205876904c98d03a67fdb128f334d7b6dc24c166cca68687cf8a6a207f5084fc8dd42f8ee59ba762ebc46181cbf6054e899fdc01bf45487d0d49a43d91583864b069d2c0faaeea4b6e5060da6119129749bfa0228c1b06a4fdbfb72d2d8a4287ed9745bd5aaee6e497b43df75806d8e159ebde726df403485555a513320d16d920cab7506f0b1a67dcec0d0d3387d94944942271d837dfed200fe40b931985c3c58196de04d6028051538b39bc7ad75a00eb4bbd33d57700fabd0a57901a7a0dec3eca9fa45897a139ed1c40c1460918298901be3668af7a819a34d827faec64abe1bade8513c60801eb0ac60217f2cf05c9e4cb70fc22576a4102d974ede6fd3c552857b4f012b5c1eb10eff0474f79628644b897b30cbe48b1d20fb1c5336998baf7c5c7c97fd3744c346c80588a0ff07ef9d8f4f079a57a22e6f9fb5e63edb812320e54c8d6bd6a11b2af232ef3f90211343f2e8e348661a3e22bf2063e72ee50dfb3d431bd0a0d418a3ebf4bfbcee0d445cb9dd5a38e5115493e3a0a6629fc45358d9b1fc52db54e99563dd008c0efc711d79fbed8b1f467226473b6802612392860b5e41dd71f484e70bd53861ace8376dab97b62d252d8620eac02037d11554396627b307e202f082c84a4caf0afcca9d0a667d2f28e2752e49f01d0a785141fc16eb3a675cd7b3c091e39b71754921a508a335a69ba43c747b2ecb9790732335a4a312d8f4f3fbc1efad01eb449f51e1f14d2dfa1d0e2b4809cd47ea51e3f2fea42f37d80e2b2965c5794b6e4e66a2fe3dc595cbd1ae42da9edaaacbc2bbd8b161c9742712948c16d8f4f0e853343bb78d5a480c9a3071b278134078bb1ac82042f61dc4dd8cfc55ebb85822fc904c181e5734090800d947a7ca35ca682f2ac74496a52e8520e8851a3bd71bf0e7029c519e34254059bf257d2d16979c24c2465cfe36560da0817b7ef5c91ec4d7801b62ce80e7d734ecfdc10b30008daae5e892d387b399046a0e018a51432f442980d3545d798f05617e7cb1c88f7359fa5e240c0cc95541cffc410f1df78a0d11dd389ae7721239c926ca72d05362fa6e9c1671bc2566049d2ea853fb36101727f35dec96ec36200b20620d1cc5af7798c2c4bebb383acb139f0b0fa5e728b8e9bea444426fbcdb71e3ebe47216c90892b78aa78a2f3bcb167d0c3a9508ee73d4713bc13f008199fd726889f88e7f31b57a8660188bbb1d7a45f5b2a8f88007b2a6d854b931ea58fe943cb85a199c3bc46c8d64d5b2b3de8ec96afb213f00c655064b6a69da41d66c279639d4185b28199343ed97055e130201db5a3fb1c105409166f5399a69a85cf9f454ef4b2bd08f0d3128a761f77997f8a2330e793998d8f657e4aec1cf5f0a80f4c2185c62d3c0c1a8a165165ebd4373d62fd826e3a02baf0be734c08bff010fe54aad995b521e479f9b5e07039b0ac618f2bf80fc40d82531470c19f764332a14163b58cdcb00586bf101c98b4d97b3867b786a57c18b5fee078f921eeeb0eff77572cc0dfd207d497ebacaedefea7c023dc36a40f2b65feb944987f3d09b057bc64ae682356c655ebf2d102bf039a03ac3a27dbeb481268087ab90d68f7ae8c2fefa25689fd077ebce730284c64b78a7c136a856fda90975e5ee3c6243d0d8afe6dc333022b26098b36ba9978d856568075214879520ee8688989f67b158201f09a450ecfb6c430ea1f6deb17cb8bb95ce6ec6c6eae4d28f79106434e884fe79ce368a2f50c79ec65862cc1e042b54c0858ee4207b0ddd11262ae8e35bcee0228f5da51ce9a99cbafffdb06fe6d46d0dcb2650169ee768c64931f91689ddf79535619cc74dd6718c79b846516fd3376656f82d396538757ed079248f083fd8a60a3f81b2dc449de7b849a24f7d692c19fe534d0fdfdd10abc46dbe01b0600cd9fae5baad505f1004369adcb47b3ee8a80b9a8ed0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
