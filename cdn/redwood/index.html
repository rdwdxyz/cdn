<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6ac2b5f65796953d8085287fde4c9cbd032c3c618e2bc26a68e50e53eafa02728b31bb45b98945ce9452cc051777abd965727d89cd649976c8fb08dbc1b06ea265fb4abe1605f229ddf295d5f4f25b36a6515ff81e0a3a74129a4fc7bceea2e57fb79a616a8f8d6a0b0ab0c48bea56a2a1560c50d2b192641242eb13fc7d006beed8ca377f728d77201cbaf85308837a48784c70ba8d5d0fb794f9091244c89f05b8e76f795eb58aa4b0aef4a43b52ff4752cff8647f7ef05263526e7facc27d8b3dd12e3bdfe530cccd7c27dd16e8f6a69b4bfdac87224e7a41bd60a6764245e54b67a0db463b91252803f80b94338d91f8e99690e2d5b2ec054a10e8766a651799ee4338eb76c7752c47ae523e414d13605a32098c569955c09a5a4a59630f9784542e3b504dd40b9aaecf30dec0f2985693870e547de9bc54c4ad7328eaeffbcf46b59f788aa6cd5963947e37e2f7bd77678f2f51a9d640f2dc7a9dcde9b4ac5a1466da18f4ee1a2ac53b1690978a06a22c6b52ec88b339458d01166bfbf4a510293f413017aec2c19862e76677d427cceb4e9f4ad9f3d66823dc2b512657cede6ea192376392e0e6663675fa561f46a25aaafc94c270cb9eaa7a6849e5ac054c6013f2a5a753b0f2ba7dbcbab3fc37c07195b4a5c829e968c5a789a189948d4397eb1e58f43b136d8ebf3c87b8c5e6f13020f9f2b45339a0e2df3c2fce87fb162d0bcd6ebf96566351fd67e8c8d1875b1fd9673eb3882524604e2cead462eb6aa63bc64b117a5ac92059fadf164a16b6c3406d74c733b69c7765c12651699866ee5ea12c3801f479a221a9f66a8394f201570d986b1dfe81e866e6c26d9dbde6ab22a2a54fd8ef505d00e9356f5c9394ed76c5ff9055463e4be4785dee9a930ec657a33da1d555e5fb628167b2ca11dca939c0db048abb2cf70e977bbc220a2419181d0406da0df0fc11b2a0c4c5e95cde78db1380741b23753e586cd423351d39570952e83bc88af257bc5927df647bdfb729bfc0bfc33d8386833a402575efbac3eb80c44251f08548749c1532de311ec5b5a6a0bef30ec3b73568ae98fa91d76b1c9260e7aa5e5500f7942986c5ddb64d552f2aa9cc05293e1023752a15c9af1ddde9c4582bba1331fed4ed7ba8c6365952fc63dfb56b2a9ef9d4a8e305809e83928684c61bb8d5b51fc85c43032716436024dd09aca30bcca9f5a9c6bcbd4bfbde7c89b84f17399f28d7e16c663a62c845c81138677b4383c6cb7ea46e725366cd76e1a27ce44eaea7d5585ac0e75720d199bf0a62f60260828fa5a551338fbc3252417d564dd652cb9e1bc17e3217c53919472fb94ef703e6bcde41e5aae130ac0e9ce74458d17187d3cc3f81305cbd24d5012f8784531edb36a5326a0cb358a70ae106db92aa4111d622641a30f939bf66c5f7eaaf5886688cd1b24d23054706137a7f8cd85e686ac6365dcbf520a6ddbbefce38763229a1ed0cd999b3f3f7b00f3888371ce92c1731b00fcb9cb538d2fd90dae1c117816a454299f37782221cf2cedaeb473e3122bd75c31c921bfa7925343b1bc1e86d60566024ad2ac67e2a4f6dc133f8c1fc2369930d0ecb376482fa544d4922d30c01b8856b64896575552dc1e39e08e01aeff53c19e797d6b0337fe031b1a7ac2343697b1012f2e623119c2896449ab2df002c39957f8e68182c7622e95d414ef5bb111f0fee962551d7809b70573738b54d090837de203304c162aacc7a3d4fc0394ba3681ab3e913fc86f9d6a4a4d5a8bac5d7582a2f6da4b610fea5177da57bedf30f348f9dbaee6408c8d6e02299a43a1b5d69e02120b822dc89ee67d113fc3d3aca47545a8d098c3775cafac4771ec54c3e43b3cf3900c835e438e88dc9edc12f9bfbf031d35316ec347ad2a517cb0f5d20bc461ac1981da7ed97f2026d986bdf6d5a118290fb0e83ad986c6839c865437a407b1968cb68d737b197fdb4f01ee5fedfd5000c30c90916bc490b77b56d8d23d3b0f536fc86ca74fbff54ebac72d299a4d6ee2cb82d0fd5125da9e02c18227c4bdfcfe7801b748858d20e91db9b4060446bd41517018e4430ea8f1e55daebc181749ea5cfce966e50abc796b6c086c9357b7b985e28677557c68fc7832142c00f924b7d93119ccd1e30f988c53fae483140f99bc76facae77d9f71dda8372b37bff56805f22ab2a42bdca3ba7601f1d1c697eddc128c99c4cb173b2bf213f7b07534126ed670f9d51de2996d4f53351ad9c40142ba2dcd9014e958b754f473fc3865af31c95d794e24eb359b3960cb9877b86541edc345a76045ceeb56f4d20d247ddf9c2fe7a541e905c9f729044af44ee58ceca705bdafd488dbe8f6b807058383b86b5695d8b67ef37688be236aa37c2d0c4351a0903d25dc35d32a931bb7e61f0deaf85eb093ffba50661ab29a377069d9cde8f478e64798fc215afd2f941b6c749f7139e16a5198357874c3b4fbc978d5b619b851e097fa72cfbaf896f63d5694ab8f14690bffe373b74767de07ca17ad7f6bc4073a37ce27b2b3e6f1e41274d0d2ab21392c91b83cb641a3789f32bb89cb2f74d0eb7a2a7e328cee83d070eb6d3f83bcc6476b9143c2f390ea324c483ab40dd8334dbe3a1934e19bd957730ec16966128a46fdd5a80ce2dcedfb8aec19e58bbdf29bfa3f146b0a80b9de4fb53180a9ccbdd2dc699e14f14802f389f1385b7afa7b77ee83b5c9814ab8ea860ef90d85a2f541a857182bc40c599be22e93055757f5c378e8115ebb0b67e5efd57e822c1012b0a759d18e39ef6693b5b9d52d84ab423f2881a5d196c1c6ddebb1004490574b95e6364e64bc7872c79b5171c235e6428af948fb1812096022e73c197b909ee4a957031f7048cb748a6c4eb847076c3db8da9cb77beff54e092f07b11e0b98ed9dba66f0633378ece87d0e854f02292dc6957540c58f9d14beb6903921b5b5358b102d59fcb7a83613fcfc42475f4708c1f49d67efe97dbf9a05c2f087af7c63735f30e4fd73b31f77a8615672a2ea95901db58272958f6ba10d2bf4a6bd0c6567b604451ecd0cd29cb23a75d2aabc15493aa76315c15926acdfbd8578fffa2bfcb7fbd02ce91c865ae9263bf5d42f91a2cf1cb2caec604c112491946e379ce8d8acc8bfd213c76e695c4edd953b5d6285b8cfc608172cc8599d03c1e160ec44811837171c54450616b628bb231b33ea5001e2958337c94eae7c442fc88de3cf4d11589d08f0f173708d616807d35a458b4509523ba0bb447b7f6f7bbec98aa5316d327bd3a3a7102ae1311ab081edef23a455a495b34378df649f6416084e0fe847bd8c7dff0f61c5b06dbf5294478d983a45d81c359c1fffc6f98efb66dd8321cdb0de533872192152c6a61487dba20095af7fb05bff10839fbe003ba1e221a90ff6caddf408d9526e7bf666be77b4d774584de802d18ce781f6e5ec968d0860b02f1ceeee71358e5398dfea00372ae94411d9bdb3374e276d77e95a8f9d7e03a4d55ceba5f02256be4c3bce1b644bd82c8fc6f6eae06818ca18d285ce0ccfbbf62d0b95cc61a4b3492bfedc14e686e2f31fddc14d71abc1b2e64b1df42319faf797cd58ae0e41f8410d33ac37f3df9e9facb9c2bb44629a7b1c0fe87b72a582f65203298c903fc36036da3055ca7a71654641bc4dca9439c1d2aad8a7148910b10b22862d37eae3fe0bb11de0db7422a569c934130202b8b464a982f36fe434e77960f549c26262dd412ef1bbb4621b0948ad2f3f430ec1421445e8aeda4083a9e6982f2befa4f01a3ee05186a7a38d59e313adc4510e0012f8bbb9bbf777e4999d43a415dd67e40033dbc5a1468d23c9380fb3539f33f808209e8f49f1c08cc83adcd1851674f3a069f91e22ad230588dbf5d8dce9be119271169035ac7af197368c01e7a2086311e99e54bcb20699ef1ce0c2b6a30a726e95868b132e959faf73c0aa03c2c9392ce918d54f481eab57a1113afc2a0f782fb94123ec9e267f0c7f5937752ed44ee217b7d29fb1e30095b053d5271ceeb699dac7c8aa06ace8735cdaff6ff11287a90844d92419fb240cade931b0deb37f9d21d39fedf34e884b8b5aba725cb74ea335aa0fc88ac8c558942ce5766910ad88670e1b900bd127c2b3bae343689335a091f180747c8a098bfb083a7aec39a48fb03bc624386843fd89500ceb828e41ecc67c71a3a7a5775874e262fb1611cf56ceb52993a7ce03c019c1225e5a0a7953c19ae9aa8e506bfa9e5190636fde23e325056ed7aa81a0f557d3bdd41568bbed5820060ec02d1165560fda8e29f0cf4252657248f6d49ef5b3c7066ae9ff69334286a6b6c4b287a595fbc3a241b7b5ef5016bee323d35a1fd687217555488e63322ce2b541fee90c47617b31e9a77fd9920c077d2c72ff02cc519c64d0c5eeaf392ed7b6ce502b3b68c6ebab4959bfc8a66146b5f3f6fbcab003a2dbfbde326eba0603fcd59c06f2f916e8a8df515d7d99ea1e35425ec96e991550dc6ff9b9902d93d053194bda9df23d1b81baa0a6eba3450d1a36b268517ef8b6f88da8b90938956031f7d368b0eee2277e3ca7f36cb4479359d787bc56295f8345061627d70f98ecf6abdc7f49befe0ee0bca11be92421011954a4738d30b6c9bfb9bc741b31b86877e81b90ce573ace269f4eaa3d6719d8c6e91abc197b1a84f3379f746d589c149042652a23b02de4c37cea686f4dcb7ee4cba200afacf394fa1ab8fbd2df9233295442673fa276837714310843b76c598e202c0a28801938c06d0eec08402d6d2c774e9f828b325ab5c2437045f28aee9d4e236e19d2e108ab9b0d6f1ec759b5ef113eafb19fa83140cd743bc01fa94b563360b421b06435c40d003aaaafd2bf11d28e4493738361a48e456055d2e9423baf0b4b2601ca8fe2f50e943ce93cd8f5412a75095922737a1edc2c6c6068bd9a5a65af7956a71c5059e313d85fac40eeae91ebecb1d98c6dc9ed038d9442a5c3ccb0ca22feed61d91193e8c620d9ac6002ae5b933880f4fb1c7a0a14af9c15dda48d4a3ec60c8b2379948ac76bf0c9d3abc2adfba53b3736b534759d8810199564fe79f7f9a0537e379d2028840c6d2e49cc80c773686a1dc236192f4765332b93053ef2f897518e49ec9c4b1fa90a881e3a230fe8bacd533db6c79259c54f7f971a6f52fcc4645a082d179d554de53d42a03d5daf8215f2c5f823c975515a808e511079355f24efc24c13dd54ab90c7d4ad42e2921378ebf9fdef86a448403bdf00ee98c0580ce775568f62e977adf158a646688e18a91eeecd6c569fe15946d0d911829dbd891f553190a5bd9bbc6d9c7dd17fce83bc49ad026784423a94e5f768ba91d090ef8aaabfedb382779a051ea72543f0387d624203b70e8acbc12fb3efb4f168371ef1fcf9414e7e5cbb6b64665e40664e5b23c748fb69e583b8a1558ea8eba4bec9843b9b4328e62353722b62549f0ca0155c9651c003ed033202ce8822037671937e9b61cf2538230bdb2bc9e51532cf1214a4c200824b12690faca37b085c40edcba10402734fee6586d4aa1b08ce6de17d898fcc33975385472b46c9d3fc41ffc0f4ffae4c87bfbb7b3dfdb75f632bd7a06d2f95bbc7ddffede85b41dd0ae93c875dbb2b3eab39ab3b7391636d134f5dc96cb5f6fcacc81e1434603d634fd531fe575f398a905f77bbf5f96d5d3529aac7e7733a206e0583ea0cf78bb653180b969356d65b589d0c98737a62330a8fa7434936fc2f581dc8caec6a7fd965cce111035a6a2d1dff9b22826bd64c3c17457490d02fc2eda75fa91d1a896a9174e844c2cec62fd4165731c37c27eb7153dd5e92ba687aa0c1649d900999e9346d6d80984e35acc74d2205f2b7e4d8a3f2e8d0f56193d6bd091cb860a76c122019781acb68bc8aee54a8c648a9fb4ffbd996a1ab4e5a6eb9dc3ca507329f3c0840d6c7bc8a903f40413fbc027dc4430585d30324e1c3f756ba674fa84420482db53f5332126090d6c8f22dc4cbb8910d8636b9276e765f23409533c02c49f52b8c7eb95ab9bce39ce2d0ab976fe5ccb8325b1efd9565d5a1bf8dea9eb372bdb216612bc659c49586aed79e0d6433f8c3e33e9c1b812587029ff9011e84f921326338ab5908416d3bbb844698ebfb6230ab2f124210ecaf2b2641d33e8b5d7bad835370973c51b2f6a4f0115af32a9085aeacc6cacb0d1db18c6ae90bd3ba75833c77cfd8bc050ee07ca7575a68173cd0f05e6fb91c5a26a077e794c82b9bf0a3e60944ab76389a4022f1e6ea07888bea68f067718c254b37c53a2d8a077991759464acd138add5706a88fea010863f5c31cef3360221eea28f0d9098f0519b889408c3d87293bb6aaf06ede36a3b70d675410b63fe58ba04beaf5cdd67ba98dbf4a5cb4ff41f21dd87ce7aadb53daefebf47fce327db6ec77f9b54a5a5ebc49be69486b0bda0d851c8bc2ee58e50b009cf08c79efc2ac9df60d709047ee68cf1182774639c00f4883c94c75436d0b1ac5e596c3a025eeebaadce10dc1e1b34415cfac9366d31f052abafd1eafa96642fdbf6c5fd92e1c25862c6390b37c79665afbc8703fd1410eb1f21a22bc452f8143340a78524f13d09d4bd4294a4001db09ac16c91a6d9b2c4c1adb9909f55246b967e846be8a33fd84a5330596303a2819f9d1f527ca78514de0314686a5db80756fb3e44dfc18cbed278bc386ddaa3fd62d0aa550a0e1dd27f87322c1f49f5a0c3259012bec975c9161610bf0ebc2c87209289bce35c27445126edec188e5c6eb543ca19abe17b1ecc6ce2107321e2f4327a572e118c805c8dbab0a4b03ce9f9ae0280c05101b812ffe87fe0666eac00bd0c09848b2795fbc2002bba3c54e61d6a82c1602c07c8b2137145c59ff53f8a27b8f1cad0e9f9b8f97a62b7467fd3562f5513d5e68f8f580949452bd003d4964cdd597728be550253f41cbb79f7b6ca150d6fc383f344c471eece7581f176651f34172f0ededdccc007611f687d9475515c7a1627b8e8e52f7a12efcb7d709cc3714a03073bd2a94b5796c85fb021d049f5d5e1619066060e60994b53279ddac89961f4e0014cc7967e4a83612e4a5dd996bb0c424c03c942d660c8e4be3ece4700daf172add4342b1fcf4dc99a4f1551f17f9e658b73e392c7d8a01aaa3fda4ed68d4d76d85bb430ee6678c41bd2facd743e5db9cb3dbff7b52f4f46448f575129c246cc49f8c50ab0aabb896b9bc58af86978efb204233f86314305f659f28a0a33c1f049a34c9d56a6710c658a8af9790784ad0188fac35a534304a6e66f177c9d6276e914a6660b46f0e7230f5cb836627d045463c15676fb515c4cfa851df14f81b7e268b31352d6d299bf69a24f312cbb5e9064d78c5bdc754c63169e248d7849481e301d2ebfead4ca7e6468adbd12b5415451f2c8bcc96222562a871f47c8e83aa8aad4e44ccdd838087db699ee37b8dec523a0fff81eb670b7735ea4aa82886556732b9a757d18df27a4c4cf6dea873166673af8bcf08e01636063baca60d574439970fb3ca4d7a21a9dba7c36c086471887a288e56891c6eb4f9502bedfcc742e2c1bf10fc735c87269defd3b9f5000f1deb572999d5d58d8e0b5fd1ba3c5d52827c8c480a828a4697dfab8ceff1e811fdbb4dc192cc3e2c392303a56727ae6f9e0e9e7e57cc987677fcdc2133c0ba7306fa445fefcc10c77c63be6a66d53fe99d7566834ff8f39a13ebfb4a4da769e2a79b1ee1875bc83e23b969145828ea1e280c4cca3d2f080892cd2aa7c506ff72349f65ed870fa1ac625bd159c5619bdae8301715ad6ab07fab25597d347dfaf69fe23988ae14e30ac8759d79eaadb7884169eb6999c5c439cf70bed751dca5adc8a28970850de04194582e55b51c76c4e62345ef7d4ce47d386eeaea922a4b903ffad0ae0c3e3756620840f63e15424131f5694c06f327a14afba81ac2492d68dc1b786aec656ba3048ecaf236ab0cb7ad41b5ae039c655e7b407f008e89e63065bf4797a7f83fa76c665f3f696ea297e942d6efd5cfbe3a4dcd633fd9a304ff5216d38b131af301524dd6812fb7589e573cba6b483ab43cdca774d7a06da50e0b4d6481f56442194d1216ed94c44d60069cafeb8481a5d6434e76d853e557141098576aced5c10f5f50eebc21a753644bba8eaa8bf6d2c6db0d54b6338663b143bbb302a7f8bcffae36326264981ca8c767ab448e6f92ae33ce538110bfc2a7367ca2702cb054bec5245810aa804b83231d158d0f84f5ea706dc56c669179795353650daec979c6f6580f96792b8ef702f1a38ecfdf040a68553d90dc41c9118c7bc3f4de8f69bfbad7c1add74ab4f30518079d2ed60fb4d5f274dcce585268370561df631869fc6c726c40d6d29e820e365b551d1888420d6895e4f4353760b5e66fbc5413d9bdf9d24c918f71b5700abd8bf642e57413f9ea56fde1f625ec02c28839fdbda1b29e29a6356c4671107e64e2f3e913b8b4c2ee4dc26566fa0e86afa1350b62d8b5830f8284dad8f1a33ef300534dfe8cdb414355ebacd1a3900aba8bbe9139733cec78e0d6a161edcfbcbf220d42584e8789ec08eeaa723f9c802b6e3b9887978f29e108003ae959666923d3f2355b72150f04d732633e4ba7ac0293dc7b65e2f1ab1e10c60036fa2b9e1c0a88c72a063522ff5a9668bc5d490d3cd2cc519429a40bdf289fb377d069b08b86f66adf15c0b9a680412163dbc1df9fa7d19b8466617918b5023bd34d147e7d904598f62d903e8dcdbb1fea3f4c8ff36c751979501d8ca2055f17577185992512544d1f961068d972a79c5d99e07c1da67c7aee8999847118e45a572a3e38d8f5689f6d43ea3d617ad997c719c65e797afe40b423480920b01baf228b5cc5352252e90e4e19012733d3cfa11e025f748841d16cb473d45fc5f9e5f345e210506a15c089f5c8d873c55338a669d483a3f8f71f41ce16432a5f4180a3861fb5c3c93f34f4618848f54dabd4ad5c25e612ab0c871eb00e3beed2536eb1e69f3e45d8f4a65944b7bc8da628ac9936a1375102b24ffc7cf11ccf0365a64a77d1e6338fafd8fab3972cbd95283556a3b45a2482105b30ea7d6d365e9c6e555cebb7edcfd15fd2a73ef544d2c704f93b42ba9d20a8bc887765a27de7ece09fe54a464377f5f73748d60126edcd50f956c252803390d70899502ecf1412b1ac1c5a8f6077f56bec892f9fd2bbb1f1dffdec4aabb0c9ae2158e94c2e1be512c5e4733aef6cea606a358ef06115137c3e02519e2e5e3480c1297ae9364a65e3c8a8af1859b68939db1ce95beb7357490ddcc761e14321d8791f9e8d6cb9634365eff62adb88aacc17435927a4561d04af8044e3fabc40ee6b9760a31a632410a9a3e7ba31f9ff03b1b0cc7e8aa768622c20ad0a3dcadd1d8b8fe4a3bf48a3f6063b574cc2ec9f70e1e1d7aedc112a1cc97b7ab879c1065528c364f44735bc18b2df5afe342b2ca2500d74d0a8aaa70dd706796ecbc793a725ce3bbfaff555ee41b8fc1f9af82dfd89cdf7e62fca16f7c507a2516f1ba7c8293df36cc3bbf9a948744ba581380e310e80fcb78bcf3639ce89e7d5217b292eff623b5c2f2ed083ec5cac72bd0b455ee22a46af889c76e6c08a866fbda540253e118c7e6c5b7d42c3ad3e2feb0e6c1c21f1e8d122a0e22fdb01f36add6c673dedac8a5a4a87eeb8a0ba439e701edff514c3c0aa4ce0bca147cd2c1475199ff868a70805bd7c328f240378d126cb6c74934674337fe8a6fd2c30f48212823d837a4a5e3d5eb93f7475821f3b3938417dca8d3d79d6f41f3edba685102fba2d25a6d8876c8205f3b13e34f51508a71280e9040296bd0c81f3c966b98abafddc0a1517c0507534328066b5b1136c2e1a1bf5643fd6beacb159317d43b04fe7dc93b2ae8b848daf2b623cac692c06241b95117b297a491939730f6a3be4c298162bb4da7ae0f497daf4a82c82109e66eae2fc56b04ba8987644394e5901795e7b71cc2a7ab4e68ccecb9e2b95c827f1be2b5fe97ffe124802f6bed167bc18ab43b3a1e919e7994bcf2280127126e70a248a5b32329546143f50db080a0bc8f41458497f04593115e121eeb999deec11cd620f0fed45081ec04fbc4a92c200d54a7e530b122c7525a6acf203e7499d0de353882575de0ba112c9b49cfeba35508e3080642916b0cacf71b780fe3403e829f8d0aeba95acfefccb82ab2ff1b039e1772f23abd0fb618ebf5cf74f9c033af169a4ea6c2dc41160ee05c7552db88e17c4c39dcec6e2c4798b0c882141e3e19a485edfb7df915a1a2821e76f85a310656a2d91ead01a42e082d49d7ae1ff9e6937db2eb9a7b0707ba7001fe09370ce20a6a533e35571432f35f864e99bb2bac1d537259779848d6d8d2ef4cdd1a97fcc4b3d1032a1b8e878f1f0ac1af2e82de2602124054b61bab3c34eb4b2e987781b8b6129b1b8e81df6ce9593544ec428f810082d0e9609197bfe221383d46225b85bc355e67ed1688c2db4aa6eceb962b03966ef05ae78e6f2287aef6c24d444cd3af7ba698a0ea96608a7993bef76cd68724f23c7bc2a7574f1cc44fe0536553fd453f67ae3c2b067377ae4602e6ce092395dd48d6a37cf62ad7ce2b48f5ddb61f0d442cad57fab017b4dd237261a50d33379848a555e8d6af7d3fed6b2a6db7578959594ae1605e84a9d2de497415b976b3da586423711ee2861c173ee2745e10ba7baa91ac32b7c33be1a5775d20879ee3b8a1efb3bc2b4aa4d48e9dc5384efe8a9f1e8b5411743923f8769c293762724e2b90a8830f47fcf5c6c94a8704b9269fdcb0fd7b04ef5d13b47cdf59d5cd56bf5d386b0af054c1b2510fbca9e042f249f084ec9aecb5a9f1bc42b47db02aa2a977803263ffc12bdf8a868346224cd960282ad83f0ca52533c178f25d9fdca56d245db9866e7fc1c12da458a8257d210d310c2dca2c028379f34be89b05b896098da1c8533deace55bff7419759dbf93b720d030436f12b83c6980a34647e72c928b35e3aab3b620c803581af71efa7045838d6d893a391fb2e2fa5021e53b2415602d996c36f5167ff5b68473aa547f2dab4fc483b6bccc4c1bb8fdf8977f4e296ef1e7751bdc08a0ddd975036fbbedc6390242407faa5f241d454885a5277520b3e75b31720e733e352331281d10c363c05d93eb809f31572b8b5168ee34ecad33d6bff39ea66bffa98177020a2ff50c71d4beec630f29b440e6bab9bff896d9c2ae78077039e5a89b248b855455cbc9a0a25cd78500de55737fe1db62e8b519b80eb4d986d21d857d74f9bd5e86c0cf9b04775be211384efb57bb45cc833c62ba0674d049c7678e930000e274881e8e282fe198f9de65d011c7e04b2c91284df38fea2b97ec65abd2b9cb77ea8d7949647e9c579d44f0f6cc0e2b6d581b987c5d0be23b01653f073a0a72964c7cd20a7d309e97fe1081dc7194548bf343230c430f63f34b43336276d5e05f838c412fcd8a9e64ff2a87a36385d673e38b48b166461258a1f4f4f3cfeaea6454c5b17e0a5e8dfbc23f85424265c9a8ac17785d38d05b0e0f3bf46fca00a912b7bb86cbc142d165ed8ad52e58acbfe5b87906de46692c7048607a1400b3b9e35f5230c63f0fe435b282ba14c20fe2bdccf929b51f2f2326743faa1ce15e4ba1c96c7c4b781a1c0cfd2325d73e5e64eddc74a4cd9976d20f60380fbd92f80c1695bf0105b6e969f3a84585f026285b00acf51283515e197af81a67ecf1fd3203075a8f074c32facb8f95d50b871a8e70764de5544d72b7e4b39eb1c4031c2e4b73b5d193681a97c89c07ffdb176be07e011f9c0846255ec7297d8b72f2d4aba35bb7d6464472e151f2d781ed515ea7a2534e4e12c2553c662925d704aa3e690fc4893f3d0f4a6d5af06c2d40c22db0a2fac09634083eba6c6fb779f8fad6e97ebc957772b74497fee09ff3235acd7501dc16abc0c877b7872417b84541d0b44445654a41e524132d8a00e49caaee6dd8fef9919a866a707fc4fa7b391ce0cb654f5955060e5db161f9e886cef2a71dbb3d1ac19f923f3ee985f561ed4209dee2b97d9b9df1ce12bc1002bfad1bc430cc461782f43c5cd4360ca330db02b0eaeaf82ad8231c2a78d16cb7a90482877a1ffe368f4256d5f31369baf5c92d217963662392226c6733c5063492951f9b0d34021cf77c9749eae84474e4f57eaa13cc222c084aaffa3d4a32e699ac79b118b739bf0484722e3907abdb5c2d0d1e5bdfd3afe56795a574b64b19bed055660b2afbafc99427e44e65a7b983845dde6a035e1edc3aca5c79c780160f1ce8187f6014ca999e40e9b2d45f8e728ab9fcbf393992e39065a33e02bd27d47423f47fe2a9fe2f6ac25277dddd0437f9e2aed4fc4220119df603117b960c0d7f3ca769989e1856a9c687b6751978e6b7d4754d8846de993fde7ffd62c4122aaf138d92b8d54da88c4f58b6dc60f8b458dc758927125ef02cce0370f7ad423518b435744d5443b4035df8fbfa2faa8d5252851f63cad00801534ca229c999fce391bf9e78d08eae9b6d3ebadbefa5c32d651217df121d2ca83d99fac58d2db3230f870a462326eca930a5a6f5abbae5b332304a65000b887b9127409ba6bf892fcd2ea7604da3e1bd05405ddbea64aa926bea64baf679fd72d4cfc40af91d246e640fb7a73ad57849b2db78941cd4051f8f56ec92822430fe9ae83cf39e26e30edc95fa7b438e09f909e8ea90e4d6086e73810057e27ad7ebf051dc5fb05f52c06c81243d5aabd1bbe5634c7f2156f35873ce4fcc74618ceca277f49019cb073916b81b93b98de6856ff935845246a0bc3aa5519631a5e09e61ebe9f66fbc833e9711c2a6a6b6b764fff7dfff0cece482a33caa4c955b7676f9e4a4461154d039643f0253449099f3c7b7a6ea8456449b523aad3b74249bbd01cd0b73868351e23cb17a3c207a3736016a34e9933ce808913ad835893c12343c83bc74d8236c6c9e6fb9256ef6e820f47b766c85f2fe0c29a44d8a71d3acb0a47df3bdbb065be3c4de18ba76ce735a47546be7fe354f3d254650f4654bb6748a5d8d6ea8c6c4ff165c44be36cdcb43dfeef42d95934b3fbd11c090496d719c3cbd37ebe5bdb1506a5cfa873fdbd4161b523f7f581a811d2789f19bb8a2fc3c815ba26290e9add5094e45cf617e648bd2b4cfc9f40ba8504d559209b88bd79de00797082c897ef11ba418a1d7ca251f9d5a54ce7e08b50175b6eb74ca8bc76f51464174ae7f8c7e267032c804e2baa1c94240a7fff3176fe57ba80b8491d5ef2ad79eb18df1ee72f1df9e0f6f9aa74737203c215d228b17885acf695c09e4c1f19c2d9337561ed96c37479e949963ae8576c8d4ae0f9a90ada481529924eaef134cee19fdbe9bb62011ca90f684d09e96b34b235dcb253242b5449b3433c4d1ce124b536d670315987ee9f34f3e59c933b5dc0ea52b45ba629af6bd67f0eab907bab443b8864d66473c596a2b7840c1191822a852671172f24707e929b557c5c2cacd9bf26c9b8d53b04b1d4342065908acc27910e87fb0f06aaa64c697a2892dc16524660de83d88bf76820647048bfedcf42759e17449cb41b4a432d34de921b82b67145aab6208f18acbedfbd07ec65ddbb7d0fe89a85c4365d5d9ecb710717f9fd27571d75d7d1f7ad9c021196ea60a4b15b5adc920a12d4a2c8237e05fd1cf6ee300bc03fc68f9c3f03ef87c4bf3cd81c5e2c45d5ca3f90626cd0dc956014138b017ec9b5c3c438834dcfbc07b7b32a18af364c706d2a98442b0f961122d9c7cc6ae259988e85b8f3b918e1db31004b47b2a5342c0fff13390365267bcdbcebb649c297560176c158056b0bb76f9b6d4839770014db7a5f1102f1bfd4b1127b0a0ad442a046f810e1d7e7c378177d3f0c755699c08a3f1ad7bf867013d106eabfbef4518898141614a01d8b90606bc87f89d99bd7d3b45714755c39aa5b7e52d97bb6650561911581d1950a6e580337fd9ee522c9720434c8a76d470ba120f0118e6a44860143c3a1eea42dcb15b46b495c6f80f5fb270c2b61f3d59d0b0c511506da05014f6e9b66198d39fb980e29e69b4a9a5c930796c66416948c198e0cf586a037931534cfc04bf15fd86e37271ba84994ce254b86b4829058f257baf58a9a20c6d30f9d1ea322d078db7572cc370644eb550e8f1855353b1499545db128edd8a297e9d3dbc888f4f22f881880b66399b7ad7f04224d2bcdc47313902671a28591a8f31b53cc4e65b2c5dd946019df6752bbbb3193ddf7717df9025d4cb2d9a76b4fada34cd7a4237bb3cb1cda481c974e33d6605d49fa6cbb9c5ffedfee718746f2ffb567999548dfcc8d349d6925cc97ce7e820fa1f6de6d7dede0e71b2e2b60a941620e492c8c0582b6fc1e440c2cfd8e9fc03b644c8bd5d9e859739e631a49dace7a8b100916212257abf9f85e861837ca0118a6d47190570fdff3680c6a00ca544ae1cdc8fac8d9bd0ca3aa3382a090837aab9f0686967344f3bf00777ea59c4eb999ff57c51d8d843c324ef37ad53f454b4ec4739664a917def3f7143e22f7b4e80f362a4a51d78217e2c7f8eabb7bb2ff6f6e97ece76b3644cb615769635799f7b2387b38c17bf8c12bbec43e5d1dfc630a6584d5badb0484cc09e18a4e20d03daf930a403067e83a4981fa40fdb2388edf1424e1e90d8003e6167e7dd4b7679a7e05dd2eedea7609143a81af4c5fb61f5585b0006ada0cacaf70208fc2eb384833c3a296b54bfb97d29e344b7f574d04bc28484fdedd2999236dd014f5a42f1b520bf3fab2f28ecdffd24fc0d721da2f18368ae44eef0f81743a686f71928168740cc7d496bc5329c90613e2dcad0ad5daf36d1c7472d8a470ad5ff2d897550e30f8b95e5c31f76e38c7d86fec0df9cd5ee004d5c5526ba413a9f879fc5ad7b6b3f5c893a47442c3dd43676ef0a8f4e79e3fbc118f9f691c396f616153ee3bba6b95144ebc4204cc0b716c697da34760f3b53fdd99793fd5e15341e62afb0aa8e9ec0544125920e580cffe52079de284d9d7098f1a23a83bb9548cadbcff3cc7a8546b0262d5ea33370984cc0c7d901789878d4865ebc2f7ed82772d7f4a262de7a9fd27050811655cdc6d17127351ae26f18a90a75c4911ef9e56eb7a0dc4b8b9a80f9c042d71096bfb7a1aacbe2247b033af9777cb305df93693ce78185a0d0519df5ef4f8c100fcea2e754b9788610adc77532dfe8ad40daedd59d8c9915c09337f8a673c7b43341c4cc18b9a14ffedd612987656e309f26df834f5eec29ab526b82f4c51a7daa8cc954c7afd63beff7b2d0a6cc56e8083f2c0a51104ee7f3f6154a0a00512a9a2cbf0bf7144c4ff4533dac6b72d0a40ff050bc33064c9851ecb7e8670455e726cda23fb21c7c522efaa7f06b8584f298ab732d071ed169a4844681a87a586f40635b50bd070c8c480b734566080acb1c110cfeb4dfc96d020ba852165c2d76f2f1e99ec20ffdb82df03964d3da08699cd6c16eda41adbaecae5eb4d07909253c27e728df25fe7a6f601e049a8f6ac69a7f56ace7954d218f0a2c23ac32ad670538167e1a601c9bc6ac64d8094a7fd659c0d6ee7757841046f8dfd527e31040610178487ef41cf28c94fcd65c8b9441309e007a3539c8be9e1e4e789fb2c9db368581b2c457c9d04cc08dfdbfb7dd8708bc49bd8d8d9a661162889642886d4dae2bd506de8d4f61230e25f661c38a9a4b53abfcd86f925fda0160c4b26e6d86fb900bbb99be561aa9ed0e7504aa8197c9541534f9dc6876f57788bf848419d8805405691327afe225f022bda38c589bb364edac2f6becd9298a1f11d57ef9a50636f6e171c1ab450e4bf66bc9aaafc88f4bea1f57c23fc62b4ffb3daed48b1a3097acebab9b0d1e8924c37ce6e4df5db9292e437a61a0161773a43eb1d6635937573130e2995ed480c15a4b693623fb5089a37d5837a71d226dd8b6b6006de711e8e3ebc89702fc00a2a84921b5eb4f05d0b16b68a52997eac44fa823196a7c79425a2e581ae8093e863da380637c7c5353c09bafb94fb542228fe49bfbb33e7abbfa7ec426e98010ab5b3d6f6b187b74c5da863f8282b69a7b39e028673695f0ccb5aeac62444d121685c616b84b60bb4d85c8447a4322e9e5f541cc5ada0a6ece2715f618f41207892a1aa625c210ad1032bd94e04fbd7b47f41ef5c53d4ae351798896db799ffdd927090161475fc722210a4f3bfebcf0f9c949c6f7446304997337b05149e943e7548b630c1a489761f04429d5f67b7d6262e6e182cf6ac91c25976f7a6679a4e9f8b7bb2066538384e7cb90c374dc001e218a02edc5f617686ded3cff1777545c1bdbabb228e9e0adc17c1d15c1153cf8b25a6c32a071044c3a099aff11bfd3bd89583961ba2b439f0608872fb6dcc81dabefb55f917af012238990346287d4682a49478be2277523a5ffee385541fd74c5db40c032229cd4fec557637352298aee4af3a875c32e066353a6ac08099b66026023d81459fb2431ca04767870fb901a07c52fa9c4aa3dc137e06452401bd3895915abe29a7b356ae5a185e4535ddb33e37993632c8001288182476b67ca73e4a6fe32adce16b2c40da356a7cdafb79626b5195e196178936b04e93a399a749d82d1e791295dd8ddcabb9cb6bdc259ab5040575389e85dda40cb6f7438bb7d16de3230510d4ff8c9e568c75e2c423f9fa9f82ecfec00be110cc6cfe3d2756bd2f918c9797d3ee6827ea250e9423f9306beed461b373d432025536a35f42b92c8ccc938c8bf6993c48a2fe2e0d6741ba67685cb22d41be54748404dfb3b7bfa69d0b17a06d391b511e90fcaa5984ee476da82180a083b074b447ff63b98e86c7b787d3735dd9cff1b0a71a60d87e71985027782bfd8254a096199cb117ce0091289be2b107f74a63552056ae63b573d055b051ec4388a517c072bc50b41ad8ce19132e3ff4f8d8fedffb7698d28639089f83603a367a679b1b1f07a0c53bdde41aa15a36222b39c1a4d0fba9d2696fe830b92d04021e8a280fc44756e6aac4d92e2a56d0202a68c141a83de87d2c2a8a0416a33a8ad812fc8208e7d3a53e3c0ce975d7941801209d0e49634989254872bd8b67fa1c835a96d54f08292816fce9bfbd6835577557a928ace7be8d709d6ccb0902bb09ce4a611a81c1845c3303840ddd517883f744f111f870dd9c7bc382410d1505a0c3126eb8173e6f90fdf4be4552d18008382a5fb6d001578b475e6ebb2582d7d40023db37a99c4075ea14f386b5a37bf33bdb4d4db8f8e344aa99e26fbc91d5f3da554d5c16ec40d83174ed523f7f0cbf6a50f57d8d5e0666738a7a6ae9b6c2474ca7c977303c182deae05977e2cec562cd38d3d85c92d57babf979c7115abc6112d42a8ea5bf1830f06b7f981ddb8a91baa3d1e790cc7b887d30befc4a1d89d2b3e1b15e352b1313a2515a8781ea746300f4f123e33f777cf314bf48b73caba33ec7f33667a869aabeaa9b52ff2435ca21c9a4fc1f64577160c8f271602a2aad0dff2e1adcea165d74a48c83dfaeac25598812f811c8d0bcc770929418a27508dd070110147accbd4e11cdb21d4ba17faebc4de7c4858b291495f14103cd4a536dcb51d9623525e51416b26d617fb6f35b53ed1e6f25d4e437386c9ef02042499b38d528eef89b0a8de0c92c19b4042bbbe913a33115a2ce15ba2f520949fc1d1c7f46b9fbb6924e2112ce6c4fde763c8ab11a42c14ddeaf5327534dea33bf630924a2b0a27b8aed04816a184e08038898ea994ffbe6a0f0e3449d3c2c9e120f828136823164964ea48003ce49092a8dc9024b44f7cd13d62448360ed11a8909b0d62d45c8ce222f5325d73c5170ca94712613b500403a9fa1e5aa3d2cd46e6d0ba43097cbc466371bb224e565571b0b7e87240ac8361f3e6d58a761c0cbde049acc8d1c2f408b984c8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
