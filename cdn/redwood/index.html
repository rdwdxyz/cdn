<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f2fa01f5af5e2d003969b6dc2481af86abe8d9a9024f3a2afeb50a25ffa5d8cad5341b35e7bcbcf52a45f559eacdf9a91989460c14876a1f8c706169835b3c4aedec764bd00cd4bc4afbf3e51abf08c548c7160f1974a8fe3b8f62f883ff7613702a2bdae69710571426275538859d761141c8c351468330fae11e7f34a21c6de26db5f9b66045448f98c7aeb639dbec81ffddd48b3db5029fb18c9968854a30a85528fb31a3d68d3fa03b292f3d8090bb0a4dd6447d12cee75874492322d91e8c06b2a08a1adc6619ecd6f289310873db16b6e26a87357d93d8c264a4a396e34b052ebd916e73929b7afb27ae6742c31e551ab3e66aee96e4a2be178e4b0464ef6ebb90a6f80119668c80a9c50746bd5779dfc99e43e19d38a55cd16e1fb0c15c933322e003b4b12f17958ca1d757f65b0564a9e3bd546f58bcb4318aa595966622c43b9930ad67ebbafab38ae534a3188f43a6cd1b64134bcd0096b91e665eb75eed01a7042d8579f123e103c05d3905a658901b5a328e144b9b6a47666ef35c0c1a64be8d666b3b85c8cc567190067cbeb21402b64c14d1c178fc47d8111dd915d9d66f4c3caea650690ad543ed3f724cb03a2ddf77c67d3f1eb475477a3840766631ec12b4328a83fb9f4ae0654d111a00113cf8d47e83ac22231a61a4eb86e4186f3f28dbb5c1045e9712ffc593eae052df4ffa1c947e39e0b6286126a2869ae7fce019db13edd3c4a9f4449fd6314de5124b3f1c18a42b9cfb22fb085b5993aa5aab13023757a016880e518d02db13b8af897f7fa994644da29c7a1cf1282adcfc0fd8b282717e685dbfe1785969d07ef227ac6f763e7ce7015b470881f40d07ea7d6afd14569f2a606f4f6e6af91d8c6c212999e2bbcf4e832fa10b218982c22fffd3a9b6cbf3fd34edcbcdefec41cab2d483faa885d946919699233382b8485b51ebfcad9291128266f27dfc6289cab77aa431ca20efa21064e3e9db5ee88121fb03f9ab9f2296138930c8b731ffd0835b303e109b67d46f22dcdb5ade090bcbd46ee8f029e393dcb58b56f1643e2585b029345b64792f660447a32fe64e73ebdd8e39fe66b3666b627b4fb89dcea60207f84d962720bf045074a086f8fa12df9f6733b23b2899810e994e36b455ce991da26115bf7cef716d4defeeacda3dd0b39ebf9c70e2aa2baacb3b4f577a93e484b6e66f57d5ba4e8b3dd4df86441d289fec3225d38c6e22583055f76c5fb29fe6de39ded16a147462446b15dad8fc6dbc8e0c04550aeea93e70ff28d4c1571d457349903ee8cbbe9cd4c01e994e879db8f2804f272cf294d0de708dc78fe63c78b3a43d1108e884930ad84fa80c30cf65e2e578e904acf89c2062b3f2e012f3b281ad74c352131916a363c2d73b4f7f0ebd8453efc73e7a8aa1ddc9e05f8a1273995a003a1348d38e2ef8a5e9e5166781dd9c571d2978b906b17c52f8430b7f64a044e9fcf074c1b4062d58faadc6322825b4abdfae6f9f5e18226bd5b15f29874cd64e3ca41343c131ed7556b007c54a2a2067435d03b6b6e0e383765cb60dc89a37aee9fbc2dd7e306c502578b30e0c419aeaa55147141781b74e146e8de338aedc64aeaa0fe27333c86f6749615552689d399d03ddd1815bf05554e5c43a25c86a33049680b73e37c54ca9add825f1e039d3c4c66d685716e47c2d07afc1e0bac1ed95df75b9a396f9e243516dfed193c8721f350fd4fc29e4db7cbcdf1c25c11935a92fdce71c2f5e502713338de9597bdc9a0270d581bf8149bd3bc576c0cb108224381ee0b0bfe21e14c7a561a2e158376e8c9da2faa62f73f6678b5104913766309cde19a07edb75bb197abde021fc831a83587ad0048e816344b20d602133d8878f9a4a45c468c1a3a398b82ca8fb79abd16ac4880c9f8ed4d35a9e6718f8e1b1dc60b0e9ef2ad1e2f4b11382e40a211b663823f87eeb599050aae2bf4ef641dc9b194029b3ddd44081eb25210086a923e5178e06970e4cc4e18635522ca238688f285ea9381345e0512e74a6dfc007c1cbe9e78a758d09f3771a5eb047878cd62a669486d463a2360a3df7c75720fd03a97422d068f96932d6f8949b3f17e454b968d95cb165f3d0a5bfdf4d27cd7a0457f25a2e92c62e752fabd8af5565d63d8c516a7d69bb55bec81b1731a0cf2ee6713f41b8265b95850fa7462734eda030ca604497eb2aa66c8d9b423ec338ea67746ae95876da140d377818349a33bbf5a994f33e0d95cdff589e4b6740ca7385545b19c1d6a4330be1a80f816822c3e5116afa374d4f37135ce3d8771db759d50bc3f59c82d593cd5e3b2eb9a5106d0aa54b7555f2f8c900bb0365c99c772f537e34969258e307f244c12b9a5d559ab6c253a0ce2141e5ddfc8d03090c987da428cd2c26630262f0ed96bcdf1a2ead32dd277fe179bd22b489823636f0b85ff9c83c5c89a14a8aecef91eb18a6c26ec041f96ed0b82b38366e29bdc665652506a9e5c009886a2920c1c536ecf60377d0be3a34ce0025297aa8cfe1e7657f7a14165d5e47dc7179444188d8c046de31976e37083b1b00081c14cd2368d59206ba418f2d3a0adb031f40696c8fc23001312363e6cbc86f3eca5a1c9ccdb8027844d49b1c99845817a865f0e7c99ebd4b3da6e17cc551567ada99166464f519a9fd1f96dcd94085a006dff76ceda97aeb4db3f8feaf3d520d64381e11d3d7d1aa5808bd0786ad77153fecb24998df6176439b5c74d91663e0591bbe95428be3d87408b3a34a16c44a2db3b476f4d55148e731cc46f7b37fea55ad2b33ac3fa71e807735cc772822b90aef5a1a6e20896dd327e40156a3f9c31e7d90d4e2b68ab31dd9c9b72d875fd8f2eebc6a3bde4be29f68b05693e81111cca12b53c7e4681d5936d72e5b66e99d22234df9a906927bdd9d20437d66a2c66823705b7e6770f92ea8ea65aa25171c3cf232b56b8182c131b3411a10d970475cde7a4efce93dd644591160c85c1000030a9a748253a7d8c764ecc49f20517ded036361cff5f844b9fd4cc718a71d3b92026cdaf457674cc95b2dbcc67cc1ffa330888f047c94c5155e5fbd73dec2eb3795f5c46ee2ed169700b8e62185ff26f863d74279a7098e98ab6a1a5c75d28ec9b7baf6227ec5fb2798debc57bae6bb7b56124cb69513d53951eb271ae41db5bb9bc7951e2a9a8375bfd4dc2aa9bd1c128d8a788f5a0f64dd10faee0252c2ff95329e30d55a2b84155aaeaf4d230cc6bf4fc5ee1861211f3ed9205236d0c980b49905383d263651aabd2ad795d28decf403b2975d2b1185c4ebbb1b383e3b0a30a7d7793fb0cf80950fe046a3078f04c02c4e946f073ccff8503da0fab177ab9c77eefbd5fad7ddda6b31ece0db715bdcd0322b9915ac9f568bf352d1b96c3b1960b54666f10721a2b3fa93583fef3a41e6e4ec9ad6eda23253949b11840eed8989694f3a6f9f7f57690258ee5b84aea1924502f357b563f2b140e5f7a97d54dc5ce073a4d04a8f55d723249d2c081773ee0248899aa400a8fda6ed9cb13bf1b1e24397d7b76d43fa80ab0a92a0f1bc97ea89de35134b15331a6d258aa8d1a32ed68629bc373623759f2ac1dffccfb709289709d0eb1deaf000c66ba400e9d9e3471d983cdc2af9c9337cf29dc82e361db5fdd83f2ef67084dc805faee5f32e150f792e9ffca5a012cfc6f4f9f586cff24e693ff62ac7ccce9a12570f76742619e679424e901234ff4dc57d26e042281f63e99dea05c3a5bc30ef09506e35807e72b0bafb2ce757df438208302c9af2cfd8c8203137fe7270afc1dcd92f04cce3e8f97811df3cf396c4a2b093513f88bb7a4f0f413ab5c1e6903c56842f47ae9ad322efa32500661cac6808602a98920a8c228c0f15c7619a73326facf6c4006b32fb8dc89b58271a2f3c50d2d3817a68a01b79d01ca45fcca9b26c2eaa09873e520f8f670516ac7556b2ac400b356e0534f80eedf8a5102e19ce4286cd51e1b2a4344fdd814f7e6d672a3814034988d04331c73b19c1ce59db361413be4718d851556a5734b8ba7173a3b01cedf0375f4b3232cf0a83dac7201c00769a4d43122f23a013bda700c2c4a10b83c293985918118f23785c6852f951175b621d3aaa9bd4431cf9ddea2ae231b03a4f833cf65dea09fa564199832a721ef913ae1b53fe0bc386d46051890f4571a111c077828bf29a3edae59b06ffd369b683e4342cf540abc379ff263fe5988b335954165692d08675701a564312a2fd5264f5d80b906c2e27019464e0bd874ede4d96c49418d847af35c0b84d1b2d1b33763dd84c426f7afb764496a571b41af5648d63f4e66e4612267c6ed2db300e2f9bdafe9e283763d0ef2d383e13849a88c93b1a371a534071890c5dc5de559404fb207d576a34219ce42b8ab3d63270ae60014227f770378508739eb4a0b210296ffb7ae03cc93b44a3a60385cf8090d1a2db765955278f9a645a7e1a6ebb276396208a26e00d81f03e9aa574a608939b9dc6c689477c32de0020c0188dce20939f7fb19af50deb772b92bc77d448bc7d7252547828731f383f8cfde72c2efc0e0a6a577c379917e3a7c205f4ee5ffe01b37a258fd6078dbfa06f1c1eb843337d489cbb9ffd918b15f6e6a05080a825d7f9135b0a1aa62f8db316309ed9ed278ba25cc1c4433e99613006a09225e32a55d0bf18c739678fcbf9aa466f1ba6f22c9f843e5880a6207268d2a3c9ffaf9a9602e741c07ec47bb1b8bce33201068da957457b032e845ebc16e9864b9d6c40e4ca4050626e3412ae82628fe50f76da9f4178b1390a2c42d006652845e24d4054c6ff06fa21e7f24973f48aaf3a3f7fa418e4548a3f536d51a24def7567e0c9efa34abc2df6c0f0874d2e9d172456ee579147c9db32d588099cb197b0f1b31e582928604681104c7c632894298ecb9f88650379aa4c1f07c868d9f87da10046acc68395a86ef07c30d466fb8aded2702aa729cd57735228243fdfe950d112f2f212cb3eb23d100609d13731c077d60630a94ab59a3c161104bec5987db224aa7b394fa9840dd2c7e84519e2ba753b96ad72bdb6837cc5abf0812fe410a04b2d2fab741567a2a340f1d0647aa5b970ca281687d40abd96570ac4e1d07211a67a27a2d8137f4def955afccc882b21f5b9f8e83764c68e77f25a9529092fcc7f1ea5889eb7a169b0bcc8811be24178f6fe8bafdf41ce556ad6b014a9701a78bc423307c69678e111e30e81a62d0e6ab524dea582b34438f3c57b8bbaa5db7c3e8f8f580d3f444d598bc8a7f31db3144eb9414b83a672270879b36641c85f8a116367ce51583b786be80f1ec202cfe2a31cd004c22b08367fe13daad6f6b1f8e30322dceb179a3acc1d91f678f0d5cd530c2c2bc25ced51199a5914ed7738a8f42e91591399ad389788e0520d0c3bbfdef7e9c03aebac7fee96c83babab3b4c66bc6ac7a87de35bdae7ffd20f185e4bc7b0df37c6d2bda31ee1852ae2f9111d3e9efff25fa363673cf6f3a590bf41c6f1a0230a418c635a96bb94c659562f2a74dd459591fe8a26307792416760b646bfcd8f0f37e6e5532673e6a3eb38aa456cdf7ef5b78cc1962a69d4bb5ae2858b9726947fecbefe05a90d5c29c56d69ac29dc130c9f826a9da7cf92effa22ac9a7abea441f6d835c6f9538aefdd7ee79c976473b4feaf88a74f9130d705e5fb101250fc42c9ead66bd74b326f792d993339687bc42f9e02d8c88f185fefb0e656e48bf079846b26e01a21268e452bd5676a586f8e171169bb08b691a3b9c863738839d9d0f449d922f6348ffc7c73482346e62df15bb525e3c65bbfa841b77268591fa5c1424d34df5d5c149cbcd304d9efade51b023ec55092559fb0ef7f44f4729fd17a88732fa02d0709419a524c1b546431e18f7c756e0e2039a21e8e658fe4c024bb6193892292914435b8a9e452af0c228bd4763cf7074c348493b91bb3dcfb99a9ff05eed98d9f7e22a121ee25878995bef45ede6da55e9ab80ae50b1e4451801ab36d3014bec5e41977b58614ac613e40c5b45d5ea393d4990c9c6a29413de9d2d6fb7459127b0576c0249cb8764ffaf87e52ac2f88dfffcc569af78952b6483dbf68aad43d180392751c4306f46f7f2913011dabbdffd492129c8ce6d72fdabb460705580402bbfebf90d26705bd272e5d8d29ea9370a5c5eec7446a0f85492b62fac54304e3617b61b7882e8bf2e6337f16a3f4bdb8eed0d61fc96b849637d251c9a10a4bb25cdcee387310e59f7aae87aa1a17d350ddc3a383cf94e552e643e7c5cdde03cff3fd9fb6784d9bd9c61d102aecfe36f5df420b1fa1136864fac0d9a99dccf951fba32ad8df0e9ecd6ccaa9f2d3ac0b5c7a69252a9f6adb7084ae30158e7177a2943b641c9f9fb74c293b08dab73b0da2ba31135dcaf42c7a502b71b3e3d9fc367187bf2d4f7fbecc9fe3c0035d73b29f7461b001347466f0f680a6ae0a26bd9788ab0135490dde66ec596c3ad1aeec0693c70c05ca4ddc4c9fa8876a5a9584ab25a1636dcdf6cf92becb622fd560c7032706e1907c19fc90f2767fa743f501369e188a92ac3f31374b6d3ab6b38077c7398b162b891b350d0d67c2ae81410fc9e0deafac29e87a5fb1bc510ca7a515a6b44735310935c8a70943e10b687e5af6af953b978359941e7b33bb81f3b9590ea4e0686d96ca32b7dd0e05aa5d66384fe5b3ad914d360907595f6ec8678fcc803248b26310701a9f6c130bdffcffa4c427eff1945eee78b91e2f2414b58f051611300c9531f895effbd74138591be1ec54e8a5df4ab96493d533515829b873e20403dca29d1aa88b85a763e612e41e95ce1b888807d7acf9ace3fc39bef95382f4b0e4f917b4048b620a21ea43746e99477a9597b2787ebee2bb32965b00fe3d6fb40ba1f19c84ba9164f82e0d0721bacd88692ec72777418474d373e31ddf5ef8e4c3bd49d9f1518596caaefb6780be1d3492bca607aa6a7a8909aa3172d192710afaa3b7e99c8cbe364d14bc9809aacfe74a87e8c047e4487d04ce25ca6fbd2375faa3edd0e19c81cee51f19c281ae785c8dc013f1422d0e702c639e71ff7573083164b0d0280758ecf29f678e6c5a4c4f69a04329b487b154d1e52792100e794fdca480fd6c84f97a62bd36ba2b21f3186cd01de554142fd11bac29d7563653e405450f1b18b7153984b7b17f6b70673e17b409280263d8bb94076e5e6aa8722914b2338d5eed22a5ebcff217f3f8deb1340eca6746c594047941719b9883809001330f9c23b526662d0d13f99ff76c4e3798223a9f5997e21848b1180841f3742e36220bf93cffab1d4ce124c42f0f6b11d225777a3156d89415eb5a8f0c661a7e14109728df6231c27340fb0ff027917e9625da3a253ed3b803266ae9abb44fd3e263f7d2f378a846125739175ff21bad38144329ebf5934a01bdd85b0efe3657d0cb9da419d86243f7b1bc062369becccac6672e925d7b0c0f354345a205aa7235a5552a566d7d05c082fa9756fef38190e96f432577729ad16a0410a9e2a406b974d699d2eecf8bace16fbf38f86d546e07ed95b72ae134b379a2ed465298e3172c5bfeb75f63f3a4f168a39c0760d9e3c60716ad2d93b469d43973ca76b3c469c37e9dffa8eea0bb4ae56da210be790fbbf9fa112d00e33b5140861f5bb0a241489a049fead99cc2e6a948b5c9a76d3c089b9c45ee9ae65e97a8cc376bdff1a9499d30ea35bac8dba5ba107a8dce6bf8e3babf441c40ac86d76d962e591d0476bd59aea539ddb5eaaafe8e55a01bfb9100694ef63f5ba603711d0eabac9be23028d9dc8203aae64f6529653df6d424d41fac797bc77a1c32c34bfe0b6a27a337f5d9c81b391f9b36e2271c42e5cd0a49c94a441ce41263be19f574af48f36043db3f7860b41ebb27c81c6b5e624afff42dca35d5dd27b3b40e6596f5117570609b3364bccb136680d1df5776e4bb38899c0dbd268c4d77009d166a6d354c33f8395d8bbddc882e743dbb2984eb78853d402af9e32fe59be95179de5fcf49a87928b62c33dba0ab5e18ca610bd6f9c8a4779af298624e6d98b23485424d4413f25eddcd201a74369f7a6b80c660ea1f5287080206b7c00918f65b55be32bf458078831f29fadfe20b09be630b8ff6bfc640101a8d13c4e6104d268704473209076f1d05bab319eca92fe15d073ab665ad781e95588a018316cdd88c7e1eaa3fb3f8c902c82a43765edd67fef0f148a72599a545ed8805cb7f8170c67e74d21b6ec85a5c97f34c51d76a2b6268b9f6a8dd83ba8d7cbf10234e3276a3a97b0d8b2598c0632ddeb48ab3255dc86f3ec340d0d2813ea2c7e867d63c6154b586a9fc6a304b53f7e95c2fd4720a8abfbd4fabf9fea85843eb64f0797f29292599362b308ce0474d17bdca18240414ec6c5f783893123b65a9e00a2c26de7039762fbd8329ed29afcad6074f15c67b6be8046b08341e8b1f5db11f2be4ebbfd2e1cdff04373d6cea43d86df8e2016c1cbabebed634b6e7297310228e1193b84b568a15f7a8eced1cc0bcae2dd94a8223f385e27d3003f3f51361e674b36ea9c57d15f1275da38d36431872700f0bf7406c6d3efb8477432db681753c31ddf64d626aa6983e34218e7a4d61526aa32f3be071041995731ecfa6cbc1c43c262e0750350dc45b22c9c929ef48bc0e9c02464f451f4a192f6f8c7017b9f0db6e27c7e2e5b63bed8b76dac2a19743dfc367ec6966afb2ed75c5704054311a6154f500cd6829e425db021d7f240f29b4c46488624409439eb6b36938eb5d4beaf63dcae1851922b9f9eec1478245579776c42506154fb6cdc2057641d9ee0b3c653c8381dcb19c27faf7ea56d8979e56b54c9bef5fffdccd9f1c77d1582b9cfd49cefe5d26d161b7fb0211e616b80a04663fb8e45a45088b27d143d3c09fcbf56f56b4751ca7a3ef8aff9749b935546d14ea6f70eec4edfb4fb8fb6a3e863c5fc6f4e992a1efa09f14763fbf5733b1665f99d9013737f6b2d5ded5ac6a8a36e07abbc4244b4e8454d215a25e1ad53041eaabdd52464c0914041dcdc8c75429cd302d92eba94713ac925a4e87222698b1a49885b604866537027c052d52795d2c5223125d2b9c25b2618cac8df5d16898102e8729a702c69ab63d30e7e1afb7a86ca91bab85a2c25d43c8b8a1661ced33d6eb9d0aefb7a206fe14cc06d3d5481f0c233bfc336c59db9ddcca7f67cbc15a4e99a893765fcaad246f27e90dd6166297ff4c48fa0bd10f331e2c4e54051b3f29435205d3d1553fdc27646fc8f5ba86e001bf7446bf8992637ff4f11fd3774f40d9f650bccda91aca543bae92ec7d4b52490cc5423535ab52dc331bf60d3bf0d41ed3ef8d208245ff18dceb99a373287bcede60c410600a1f0ff4e9670172a07443ac52c471774e089c3f47f622b5a5133cd8afbdca33804cf41de2815dd7bdaf6525210a0514067f5f6e2c9fdc4758fc12511a6c889c5337754f4cdfd38c72ce558a21d12f602c21610ef3912a9afc1e5aa03c3d9d359b4668b17067b463585100e9279d4652c8088a7db4866fc8888c6c5233d8605c759f97fd440c9d3726192a44043a3527e5b61c3de7d8b2e30cc8d0b669456dbf1fa1b30049401e3cc8e514cb424ca029a360c3549241b7cc315d63e73940ecc681340c4fab82aa22f3bfb8ab245910f84f5837940106047f8b494a1086150625baed139f79f1419cfd1e53bc80e8727c4081f7cb51462d3d17dcf5f57d9308ec6191cf42f7ce7f45f6f38878b15449e9af769ca3b41a0a5fff9dc303c1b0fb3c41ae3d15c48556d5dae9745057085adf321b74a4f191c0dd9c37ee6093b64980db96d928b51bc48baadc58284899146613d6ae6c39a4f48b77ad79be2095adae615e49b1a2cde7f97f7b8c6a2152fab80f01fcfefa6f0d6b1480d8f12653dbc5351a990ae90c26f35e794d122d111508bdf64f82cc83be1e110db352e1d6a59f74a2b264648a71b7c2b72d4950d3342f0ec1941db74d90c20d9cbc806cfacddcec9106b01ecf34d8571fd9578959fe4ff7ce0b4200440362069c8138c20450d8ecb76794269ff9c93c4e37ebe5d9972d888003a7faa540937d754a5b0477d72877804b1cb8994516434f63fec4bef7a3d141798d8968dfeca49f915959259acb25c7d3801f6357d7000a197e3539d73d527dcd9eedd240b9c2e8b7ff1a845f2bb344815a24cbcec2dbc450b31285dda0f5292f93949696c33781bed04b1c1382a9d084f68c064b0eb594d573ce6c1738a1bbca4531256e2dc954d0e021aa8ce6df3f32ff84f97f8d8bbf16ffd660b7db7728f52fa50b61f57d3d6e9bb2d17415b6faffdf8c51b06a9ec15a4ca85ffa62ba7e528bd9f31cdc06f14cf6a4964cf7f380e60046d31b27e2e1dace481145ecad5275bd7f6aa18a2bfc376382fab03d2a54eb8d3c32da38bee23a5250043843475511adea1e56d082b98b7a1089e8ad640fb07232e4c08be74763c8431ad7e08dca367ae1ef6ce18454816c2e9d4e5efd3a740704753efb3adbed705a115888d5c5782ea609894a81094d3799e26cd79cb8ef40e8f8d4b3577a43eec0ec8ccbb6165e620c0515d9c9b4d78edf8fa92baadb911c2ddfa4b60a111f382aa874250337acebd429a7af7b480d147ba112e494b8f35d13d7d8e763a4877655565f2314c9f5310be0cfed91251f51f9f3834c982dd29bee9398923191e1eb03b6f389e24c309ef7360d56f13215c6ea2eed776a1ab23440d767dcc532be8295f7c1ab616888d9678afe817fd60d8ef4695cb66d0faf40de9cf80fd9db9342f46cac16f5786626bfd55ad1a8aa1b5f17e8143f063fcf3124a3de1900513ba056545c834f3b3001b2c5cbd98aa8627b50829cb53d7e3281332b610fd132c2bab221adea95ec7999515046ebdc99245e86541390a3a3ec2bbaa1e3ef840a28b2523cab8a23d154d7a562a5f7cf6f330c50d79283d3d0646eab386b5e0aaecdd7efd12a211567878c7e3dcb1bf147e269367e1920324148b46ba10b9c66691d476a1b0f324c2fc988227aab3ebf9d287c269984ae675a8aa93bb5729a1ac9ae37bcea4aed6963a72b2950f1739e17dd0c3962fcc16d4c4ea9e5f75ea11ffd0f56dba7efa75258aea8753682c0de7627312e082e88530467d920dbabc40557cf03d27e3609889441f599b32341faf6f844d679c12a4729be496b0e45234781a2e35f185c1b6264cfbef530567057a390e312a77d424069f9afe32fb12ff7d6e4a3c128a91b7e2b1fd9d37232cee990bad3e04a977e6916ac054e8a9ef4da9d24cfb834d0e7eb166dfef797b1bd2d3ef744506fe03b3f7bed2dce74782677d04de3d02efcdbb5fa5fd46aa643a3ff6604830b444c88119a17680b8a3afa2776de66dc8221d81e9f0b0f612cae63f971d83ad4880078230fb0a459ae8d4709b54bb753e81e57b8eb12b8efcc0f4cd1158b3ef9e0688c1274dc7e687c1736a782138ebf9d3331077f5b4978acf18c79742568ef45c501fbab377daa5b1f20dbb4b3f190ffbe8f21fc0b57e73b3a5680d0471d1339fa501d3a7aa16321bbbd6500cc06607b86c4ef376c38bafbe32edd23ae96d7e57631926f25b0b7360427e02c2c39ef0ee36f25ba617febded34f9e8db478e989fa7ffcf74d6ebd93637e3b83ef3ca6210ed7bdb8c8aa4405db3b0c34a40bfe057b745579d4792ff7665f8be3a4f531ff3bb05f1dca575ce1c348d0f5d2d29a895d5278aa3e45889fa0b2ed80b12b8d8b2fb3c06f0441e283f815272dd26f26bd9e8e00c33e2c52699bf01b72de00f5a3d2c915d90eb4bb4d3f0447e3ee01e201f46477e96c137273be09f9885f9434663b2260e1c47e9b1ade7628d653c760bc66fd5bc57bfa5f937c3cab594891d342eedfc156cec8ac979a934d39f61c2e6cc806cc303a1402e0693b1454957c640d9a0c89066a252e544ac8ce3044fae0a9ae0b9569f16c3ea10da42e5e5e48c3c99d1bd783b33397569df394cb1960f4fdbbe7a900343e852284ccba5959111f6cb0a0f50234ae637764d77e4dac8f0859eb260f33a3aa90a8d3248a8266084edbf6623738be718c221f84a05e32f7990adc9677f6bfea47c3329eff3c9ab84f811eb322ab60394a684d8e054fd16da22c5413ba5b0e0996a290d4fa1aa52997593647d2b29c1602545e592a5f096132500c7f9a61c0f8a78de63a69ee987db484f989adaf7392715de35e225d7297436c030ff311eb5a1f9821f725781b0dd257f3e2c5c1c6695b7e90f8d03d20167f15944b54510fa9be85b7cd69afda044825425fbd3db64cc21ea3924e78e042255ff49b074fcd412c8c4da54d08a51fb9092c8903e0ea4f90c2c728f5d6fd1b2a645067cbd17782239bcc2522ab5ebdbb0d53c86a47d698fcebed3c1f2d7db3c7be65fe2f18b78ad2103e19cd60c7c0ca51432ce13933609eda603d662d997e6982c807602a9ab1e1042271f65cfda29dccdc75f14cdc0ac47483cf8b82a0255ca663a816e8ab92d8bf4278aece37f0940127ca75b59d38e9c00726fdde72e852911003a435d5eafce72f81081893363af12d7479a5995ce764188e3faa8c41398f83ef7ecab1d137beed8ff2265454e7f7f558cba3e13891c22c4cb0fe9a4f6b7a243c0603512323eec0b0c4fb80e302108761e3dc6083498883b56e8d005d445c2d9d9bf7be0c8d39d1b320e9d18b2e1de86b52f0895e086514914596e7a7568d61468da649393a959a886d4f43dca13f6fddb532917b6d5cc22ae3edff158748e7c47465b20642287b8041902151c591139e860c971892a15606cda595b2e098a85d67efb20e7dd1541f815a04119d93c3dfad84b80022fcee9d2e5f9e1f7d8483ccfb677ee481c0f1ac48f5f6cb6e5dcf2375f5167a99b2d21d8149b41ad9da39825ccb97e498e9d4af8d7c190e467b67e9ee442ed3ab26803e8e1b90a464ad2625910a32a9614dddd23259dd94e232e9886a2a19009adfd76da86d4920336ab90384eb0264183026e9086fff108f360624f0efa14c60c98cfe653b8aa7e102570f857eef900a7d1a1a2ff287cc2c6e50ced98d496017cf3c8705130413584a1d42266ebe9d89dfa199836be6f6099edcbd7f5ec3a5548dcd096ed9444336a7dfb5ee20af3301f71465edbd2b695a2251ad04b055461dd6d78e790b3f17af7de937c80d1f62b17321fadb6f7faa4de515fbc0f7b6cdb476db932ffdc09489d264f535f6d5ce60f1f34f04dc1cf8654d5e80ffe46b7f8e08de33dbc8d7cde9740ec610406508c7367000c83b197f4d88f7640d95df3b630b3a5b8b035deec7656078cb20c274db8c636f1c287c03c6cc4c88e7cd2e2ad88797c767e4a2603ec9aade1bef2f84c28eb098acfeeb675e0d749cc9f5946a9e0dbcd73f1b8b2e09e74866a2e6e7fa28917b0d6202b66818494066dfc4652ae92e8dfecd2f2a8c6c33693f28d6ae374db65111af5eb7fd4cdfac144c8c6a63b56aa1011be1a62988d3dc8e7fa8dc59d45a872df5a9431e2412168b8150149e01bf5adccd31dabcf55a73118f1f7e1198e41ef279a8ba1bd692484ed153c7c3fe5c10624f2d85fb3a2f8a932dbd91ae05b9f544b64e78d78d64b349fcb31cd25bbd5290eaac9440246ce4d1c35611e64046abaaa202b6e9d60b49d3e0428a5293b0a9308f8684fdde022cd064fa8e9a6328c180e2bba525e1c86c058183bacf2c196f7732bfb9b4fe9068a3a828da04767ab3ef9f9a0ea4825b0b99049f354a2998c09dc1310678ecb034944268a84a7d8ef86519bde5692129fb97c4e291ad0677e6cae8dd335c4ad39a134284b2bbc3f48cf2f34f90282fb1bd978706f48fd30ac0f762f2bec486abfbe4ac21c6326de11bd742a2f005b0c0b4a45c76bd9d7b8bb064135a2111fb69d07288f6f8cd5b6c674c2e5d4f744139cb757383cccadf401aa3233b3517ab997b926379ae3c972c5cb751a86e7914a6bda009ecc3922107dfca22e7599829e7200cc292d9d9946c503cec8530ed9e662d05d7d9a56e44c7316f84cf598edf8590577e35590d1535a1c9b3abc02c429d3c7a91090044480e89c2241df5ee18f7e9a90794a78640ff8221d0bee8d3bdadefeae954092c80576978326a2d76063d92712af1f9a80e733167ee6a58c95a2e2ca02fde934b933a968c5a8eed3ab6417baa6b7dd01589869921126be35cb5f5c6e688f8f434738849b70938dc9a8b5cc14f9888c700242b6cfd0ef505ba87ba60cf129f90b1eeae14c6549ca77324dfea6495483944cab4d97b541a4b1a1a84d2e8cbe78acadc3fe4f5b5d0a22d675814f762001a63a358b5345c287a3e0c8bb52cec2cfdd07b434b75e06a32bb354f96516041d67b5efbc2a3924edee0986adf6cc49fbfc914bb6e88a59a72c83f508573721367a2a04d6d14f2e34e91541b683b71e47f32513e69240f1d73d4cf71b2a3b285ebaff154aca98f21805459fb914364c47d1983a570ba19ebfb996636db719e18040cf232ebc26d21d572240bdb7e8a177eae61500d82efb758f223b0dd64d1fbed6ee1e6301cd5d3b854861cb0ebd09044feac5e8c9e449be0c599f70528cdd2b071011d2a4dd40ee5c733bd9383826c0df8b6ea72879e23eaabd279b0955f41d4434bacf1e1fa7958b88bf0ea93c25c60f27d195dfdaaf58fe99f2414d29c6cb02286a573b1b1d448f12ddc1287248cb66501eb6caa4a8063198acfecb90374c8d18b92099ef43655fadc5bf5b96ede2cd4c5b4d8c2ff840852b1e5b41e6d5afce891bce2997d884fad0fa9666e4a2a54d2affbb0f559f1f1d4c1386bb7694c5a68d837e423ea4e5f58814de43ab48ed99b9fae82d69e562592eb1fcff0119340359d4d2d3e585c5009480497a9e31179b062e8d8587ede02cc175d640f8c1d19a303ba141918f2b1c10aa8ce48f2dc2353cc729089a7304042778444866dc49ceec5c4188fa3392910ca6b69ff8e1adc73ce3a33c7c69b571ecb2095441552a8b0d624f316ec847eb9c5adcd413092994e57a30d41988a83ddcd1beca1aacc2cd4a0017ea227068a8c5df85e64f4d46960583d92f6e499ffa364bef34a4b864f611c0d391588afb32be1e8ed48f3e75221d190741020363c58c4a5c518cf082b59c64b5194e8e07dd77d3862cfec4771a9fd16f123edb9e5b1dd8ba4fc8b0deb1f36a1ea2ac028b9cea57aa40d3084b2897d52b5156689273ca35b1457a12c9d2fcf8fad0aa1009cc0974a630677206533e9b67ae62bf951b811b82fbda3e3d56184457b07131753f0081b3dd44a2b76ef20013d4e9a7be342cbcb38bfecb6a24237c22b18177957688e52457a7f9c979ac9dafbe196739f48763f81de6ccd2b5ae86b2c3f34dcd0c75ce6315e13a844cde7c8abaacf994757785f094ce1cadce36af166b4751787d9beb2d8d7717ec5f1f307c95c6e9fa92a36a980f953c22fa2488500c3627a5aa47de872b0b6f8f37d76096efded968c9397b2c214915fc5b1f0922f28c300994ad28be7ae3cdf9d367e5ad6b1645d3831498e1b0cc3d603154b014cbb2c5f16f72c500bed3f0f0bf5e8368da371bcefd33cc2ccca7a34286dcb738e27ff14fa75c8d71d154679466d95449fa7f0fa659a49ba3fda490fe18dd60475799c702f186cd489af6601a82818fc8d67b7537b7d89011663b3f823b82614df2223a6610fb92afe509badd2de704c66d4592822a5173a03a968b198f4a8e062da7d27c9e270cefb40a5b16ee5a704a5a2d50033ee116d5e191fa198575428f35ab74943ffe10622578e4a86773df8f22c92ca75a6ff9465e6ff83882d2a9d0dcb9dbba35611b345fe573a7a02a48474ff7b34eb1adc213d03761b449e270c70d860ae6702b2221dde622df63060bee7415af048ae74aa16dfdf6d693119685d553154469932a8c991afb2cf679d79310a0ade671ce9dc30ea8b4a10e529c3bb92d143a53cb358a7d445bfb4e27d9b6dd92b4554e4d12fc0025ca6b54dd610548c26da3ce8146a50130b1b2c2b82d71f1d981877b601e60e40b6dbab9fa0abf81d825cae85df61e03f062893892f86d22740586cc5b3829ca7b66a1a632ae5d3f55ab0569a729fe8f1c5c911a8e9f02b6795e35afa9c675159dc5c0b19d34f52954eb910fedec5e2dea49c3a0448bca3f0b22e031ae3203dad694164892adb3c2894ef1fdd648a686b417c41a971712bc024fd6970773baa47072e4b7a90254ad1c6bbd24c5f017f96956f0c55b8c6fb95718455d7b6472f4e7956831898d6e0d72bdbca9853f15e345491ea1a9af9acd314b1d2aa292236112a7b0cc6109b83e3cbbf7825e74abf48423bae3c8c038f9e5a29fd25ad28a0d30eeb52d5834f0facbb1aae3a77b83168758a1405532bfb0e6dee973ba11968e462f92fed6b5318031bb83e5f4152fdb093064e0194b566e49e5fe92a287157472d340e45556cf8446f6f0b57e24e096b398aa5711057d0599ee98d9d5b3f2b450abf67aa0bf3bb121d4237407e3db9cfa8ae57060c56befef72667fb09cfe8d77f325393a313140a6ffc37d74005e3cefe3c4bfdc676b54c4bc60af5b590f0610e301883ba032ac5f1adc52b6bd7ac460de97747bc79235f162993075c2227b5533f589b47110e416c7a80fd17c55529954221e1b8ac144be98ee3231a86e9868a94d2372bea03142e9f54429fb4f419321c48f0d341f9dfe351b2c5e5a24bd099a3f1b5ed21aa558a73157c1e2d52a0cdcc8795c8fc17c9f815d4eb378bdc1037011e6be0527f5a09b756415db6a5213f0edda40ed7dcfe43e0f71ffd09598bcf21f9f862ec27caca5b3410348eb8a4de6a2d99b3f45ce86556a8178e659b5e1ed3757c71eb58e922453f15faf9701dddf339e4ae0a8ec46225c49f9c3078aedf37743acab58d32304baa08183a99ea85583dac78a9643d91d3086c024500ef114ade2e20e6bcdff70d630a8f700a2b6064292c8b1713fad561a4bf84542d12e0b8802482398f61fc2f5bd429e6013375977db7ee60a6529dc586371f6feec8d3acc2597c7e08a115d720b19ba9aaf889c857ed45be0d9d71a08d679b492d10898fccbcfb0637bbc7fab8b24c3b9c1e54ade2c72929091c14b5b446fec83d6136b58acd4952181335f3f82f45d459ae41d896ea49782d0a12bba4f5b0ff5766c39927e49347b68da0d2866a428f00aee384fa28c886b706075f9790a46ddc1d65d042ee6fabb43830448974719e706b6153c9941702753aa6bb7212673ba7bcf63f3118aa79a0732cb000d25185300028b14f8d3fa5c3f0131ac76f31f9d7c777d0e15300cce80ef78d457af91d21fa4cce5391772abca8775888a1e8bb0ae124cdf30b2768bbd980f99b0530d7b7d9ce6177788dcdf3edde8011e021540a81c73f7820acb1ab8ce7edb533540d2ee9657b16ca10c57883fb2919de7d4adbcbd8c1a00dd1f9969586266ba871301439493fdfc9d0582317f947c19de011d6b03417eda5a5d994468d5b7527e687bd6e4bf8526a344104eda5a6f71911c0e4ca3c665322de25a7bb1da29d9127829d3444a3173f0228564867b7cf4a86fb4e56b399fe2801a0f61956b1eb165234fc7b70c33f30f4305b630bc1de1690249b9aac0dc5cc32279a3592563b14780d345c17ee096682f6e5bcb26a4e69dc8ed2a83a682f231fb4f934c0b43b028f70642f8a162beb2e3e614e0fb991ea69058ba3426e3b63acf85750ecaffc293b87fedd67021074a55a723fe8f5054c7d43cb9bf0e5b617806d11c6568e458fc1dd3119c1586a7ce5113e7aecf33a60665b73fad7bba25ce32f12d1fe1b0b692f96fd6656ed9701f1f497e66429c1f82e82e5a216f6653077f07307fa911feee93d4e100fbe044eeb3d620963b17d341c096cd2592f1bf7ab30041241b3d55004cb351c81ded69f33346884e6928e7f78333c1b6ee4e00550bed0babd1fb4aa869c64b71c200f55671e5cf3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
