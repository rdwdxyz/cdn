<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58e286d8b99f4cc55fb3df7378abd390120ed69f1876268e8e1004065450282f4a5460b4076851219489a3a014a2e675242a30aba9a66c1ff687548ddfa38b85e81492ec4425b2b0a048aa78892f1d98fe719a3d49bd296a7e286691c169b10e5685092b2734fabf65235641423bf92a4fad936c27e0bb9e9061b33bc56454a5a02ceaa043858941f9d7c0427afe74931280c100efd3e6d40eea56a9032c6ce05f2a5ed28f7872fe70d7ef1d5cc76c03752250d291e6cdd2efa356a43179839ca0ab5a868f8b11a4919816129b9ec50604df72d8ba0b405821907eead01a499d6177b94a0c13ff206f74bcedb701e30d227f1cc438e8ca262f3e61f7c1179d9caa8c32e42be5fca1d9072f2970747e9ad75ac84f92228701ebf7ee59c7a0223ed841efa73e70e1dfa965735eb7ab016a2dae8a5a6840ac9ab28380cd2d9347f6604074093bbc9bb85434c822b4bc29a585b1403751539b5a28a667c3cab31b4dcf09ab06bf27316401748c56a439e19efb5a396f5966b86f0175382478ed6e9933548ac236a3a98c3e82ee6adefb52dcea171dd3b1360622f990874b1694b27c75268ba27e042d85ed0a37ce97e65489eaf66f33e3bdad441680ba76285726072de0485c3bf00aa8f599ddc32cce048561924fd42ecfcc346f60d6ac693604d2f0c7ef3f8d758cd0c22090435a195a4dc0f2d71e7cd2ae37348d415d1d0a9a16dd75bae9558b14a7398d9f38a8482d022e2025946c2210213a1a8ec95582e7f849bc8e5f63feaba3b36a2f0986b7ca625c7314e174ab52c43e5d085bda85395042aafe8cd7a5fc0b723cdbbc58dad2d21fe158450c8c84ac23d94e85f60d66d49433f5a8d9d7e0981d305b4ac83b5e810de6e79c3f7e9c3dcf1096363cc57244d1c9dd3396546c9110fd993ff237fdae1d6ee858e8cb48ee788eefb02946d0f6e4d4460b252e671b830fd7dd47d1b1e8e441a5c52a524fbc3c2574059017822e0bf186d02f1933c9497bc5f3cc48bab76d4e5c6b392620fac0505396072b7449cfca2fbcd3833570d4023bf085910a8d1936f5ff45f08435da97b9915f68b7e069f58e9cea3a3a4d22587e6a2543bc0028cf2e6c5d07815b06b611ea9723862b11436af9668785aaf6786ca05924c97b5d63795a1e7fb988af4d167aa193bb69d7a64ae2f90068ff8fc78240a5360e65d716332c52a6929c6e7bed96ca9ea423665ca14e97e9744cd3b6cc784ff2259d43271249002e23a62a2459ffa763ecf243b59f1454f8bf1e9e42cef5e07dabaaac944fe7ddda9fbc58d8fe8af81c33074e4ffd0bd57975b7ca62523e5343e0f531797932188117f80e31a38cf2fe4d2dc8320cef95ce4bab670eec9d52ae51556252892eb703001c63f25cba49fbb190c3fb5e4b9eaa34d6c55bec7e1719b4af02eb456f50bf6461e569ecb00cfa08b74561ed937a932d55844efa05f39e4c2c95eef35f43668820860f630108517229983978884816fbf01fe074b3393418d68afe5f8c8cdb8a448d3a12a67aa0a0a130ef17cf149e2a78d60077362664db08c2e21e0ed86fdc9de491a76d701b6c81597b9b9ffd9828606486122e99235e10ad6732668f3d47873a6139b6141e05a9ef190b0e1fc79cb247a3b4cbf6da6d03de77fa2f790b647f31f097ef1b914e8fc2f1d142061e72a9540363b1ff1bd512b2688ebfb63dec893308e8e255871eff1f2b3996c46c89caa48bb30fe4cb640d7f0498a23353131ccf1c58bd92967be2c8c2201b492833e2a770de4191c5899230a169b4e89bdee3ce25cf16120c6f2a0111f1802cb3e153fc8ef8d712f58049a6c0a8842a072fb31ddcb8b493ca9cb75b55f3b832a66d03d0f6ea04b4ac0f663effdff84163130a34d95f41a86053ae8ac65a1b1f9703e6fbbc9ea0f2d81bfc1f2b866401a588965052881931a151f470e39d10e6533ee67e8940a7639589e29dd0aaa2ed22f0b9f69e614159b619b5bdff00b2578260ae321d38c72592441a8b3649f7bd53243802714f3c73e9a098f7ff3aecb0150bd16a6a71ae01e3b387281f5f951e44b5112de0bf84d248fae9a59857136bcf0f75bd6b0a40ad815201fd94652a9ebea8aee9824e4b84a82eebcefa05a113c041d27ddb3f96f9864e5801fed76a1a92297cc6b80973077da33a86c47adf63923277cca35c195b4e75ad02b72945bc6857fee15ffdab43faa7cc2854634bbd55b5f00db382e702123b6359380231af44064e5d003d86639505305809d8283adeba7f480960e804a233e2ffc32868431f61e52c5dbcd4dd52eb207d6cf222e3d46b5a1624778aa08ab55bf2ea15995a438c360c0f9c314d5ce246ee315b7635b121994114abcc006f22e8e8a07a3ea6ea0bc79f3898f593715724ff02069b71a60fd879b7ecec41d81fd1054395bc65cc216c052aae6aaafe09302f750f9507a9516c3293a013a9c96fce3bf05d08cfe495a6b7b87ff0a98a599eacab6d21d3fefe9f16f56c606fbab4b315b623d082ab6c9660e010902983d10cb95253054114f739f929576600f17c809288d44f9d0a0abe9fabe446dff2fbbcb117e089c0f30e88e25a3c6ffd70d18d9073fd2af3998e3068bb623cd2252a327a4119e9daa37fa062c1f35fd3b5125d89c9a435351b4e164313af905772d4e3768f2acae2282a5bdfb902e7ed41bf7eaebca15425a3ed8dec04ce1b3faba3953d784fa06e028bb1ba48603d0fa555656c94fd883f15550e87e3ee12c2ee7f004364c5734d255df394f38237f8f14985b6521128d03a110cff5edd1e18cb626e394308ae67a608362015d82aa7b8aa638f42f929fec7e6ca65c515371da6fa1055367c8c34ec9f3866e23acd49759cf81c422eed4cd6d9c04224555e46b0199ee067253daea9c39b9d97531b9e84a413b6bb0c866ffa6c766fa46516a9b8670c8df7a8b9074e745b384e7ddd89ded4611235d44a82d8b014a9d806e3302a9a470a86b34c794126482344ef77cd7a9e0dac59d24309e2cc369c973c76778e3c8902c34ccc42d9ee77e3ba07ea1540fa7dff164ce71199e31e1b98d75893cd08934125034aa989dddfd21a5bdd440f0baa4861d6bbb416ae1ba40529e57548a21b1d061d9be5a1d3471b655fbfd0a58d3c108ed71634cfd2acc9e08ee3e466f38067321072e61d0d5731646a60d581c40b35a33fc9a63afc3e66747a853e409f3609d83f36acad472450eec134f9e8d8469bb7c7534b5a9e1290736fee3fc813faf901d1d9608a8b7b318cfc715b7fffa56c61269c4203ca78e46f57a1a0985b8b88fa162f574091ea08608fc1ccb25af1d200788b705e3021c4a6f65b2bec0669ab68181f66aaa5c9566ae9d38de6d10bfb14cc111dab51b3dd43fd8ce6708b710089ccfeb72d1c6c312ea99c1ca3777b3c861ec51a561a8ed960511050c2f1d0ec3dae62e8c2094741b99086b81509539c722899a5cb2e85e7d9a49562752d03b787b99bac392b81559ef24d5a0ace82e544383ca492402b125b277f870b5dc5beb34a7f8e4069fa88d02ee001201f9fbaf3d463c99159577400f9111289ce793b517419afbeb4d861a23ba93ef593ad5c2ca653e4be074bb3578011336e9b2dda4dc7a64221745ec4be54e9a4a19e39c84672afa319a1025529df7bddb9a85710692645454fa9cf0bf38948d0552f41d06f1078fdde3345a09820fa8e04309502318ad5f69bda8b1a89a3b3d82cd59cefd86ceb19a907c8c9f024cb602d9372fa0f09aae38ed4a1717aa73bd07d9415411b36da2f88d67b3def4f21f34a3d8ee6949a26f52651887d0fd2b432c13bd1e0a5f09ac4d51ee0190450f63a5ff635d5f8a82e72a79c369d347e8ac4a91f87cbbf550f3f35bd02e0bd2fa39439ad6664df1ce57c4f4d2630118324f2f258d3f32a9c2e7525c31d0cd5ee83dd84a1f0f56968393c93d1a755689e74489b4abc618fa66d0162a0772607799bbeffe5942d01b524ceae2dcbad385696e43cd6a51721d825fb345f19f41cac94b6bdca875d94d904af29ced6d3d2e710e2cb59d4de6cb297cebf2543b17c3169757c9ecb8af49e826174dd345d1dc48d8fa5b803ff8cd8f83223ac0585e2b38f339ed1492baa78ed6cd0a1f6e31dc1b9dd26d4a981ab3f745a09bc71b59cb8c7895a76daf69f1ab9a493ec34c0304c6be27ff5faba11a880686444fade28e8e659c6928f608ee92a5673a735dd28bd0f8b8217b68ab700e235aae10b68c721ca16e54bf5b9d5ad64c962c427dcac3f0acda0526741e2dbcc2835bbf8ffed392a5738e19cc4936da612c1b0aecc3ca28b6a3d0070086f36f327191ca13a0462152427dfe087916ea3c2696a3bbc7e16e3ce4a49d2db3d4f8c711ac82b64b872cb486ed45c257acdde22bf2eb20e3f5d840646cedc4d830aa17bd8b96d522080897e5596a0754569923b2838d1a49f553960843c4a768d6c8a2cb91a57bfbc57ba64f0fca69bb534583f99e199424a01d3c14450e21669c4f95d5a25484b9a6a0b7a690dd59fa4224d039925db27bac4dab5932da702cb73a3ed863a222c51b8be3a9a00b8835ab99d6c6442317897810a2da6c81579b469c2e4870b0d533e6f4a142d74effbc8d1ad262221a5b15bebeacb62e4402104fd4b945be9d7ceccc0fc2019e16864aa94b4542d490a46cbe495ec8dcebe10e62160f6149b28d786c21d464f968c9418b1d00ca40018163b64b0a2f6fa79362fe0675bd6e177cdea9fdca28e6aa8bbd9698992b7b91e1f3a7b0938f7c70dd3d5793573fc2e50f6d9b440a88ba5f93acdc1cb19e5c5391ddd26e09d86e5aa09ec3709bded8a34469fd165aba7b2a72687cd38b6c388b2bdfccfa5a8ed20763c27c77a0d204933abc97a402f99e7c15a8a662b096812ad0babca03d8ddd100a875a9f46743d741d95c0fe2517e3da0eff2b38c25f731985cd30e7f3d6cbd585f7cfee0b2b0f517e9a63b1d99d57156a8373ba753dce16f1f0cdfabe61d2efa3fd1f4b8911fc88075a922503c1b0eeb25c11b9de4eb074e0b475692c006123ebda337edc7302725768048f09deb6b35780971a85a6b2174e2bc7ee9c267140bc16dffd72ad0f08c874b4bb05b2a42e70ec004540ff6b9c9d304c9f7400f474a7c2e1aa1e21d50bee142490ac8dfce2d045c74a46f0fc3c39c4632b6ee298afe1b8ece238440753440109c9967a2d2aaec0bc2c18cf38a58a8743f74c59c64e947b5f9730b3423749a5a6fdf2cc9008ebc57f84cc5a7d02bd241520053dab673455e3ab15f306d476e9507a54fbe13078a856ac6baf1a3606634d1b11d0d8ca83a0ad76499ad346b3d8b087c9507b44325637628ee4b7ac16c59596e4963136a0ab5aea657b76eefeb5c392094495c4b72acca59b446fb4fbfbba23ce582d9c272a49a6e44987d83b5f3828b9d5f2718d84144ad5ff5ddca3734a17a98919c9de44a9fe5a098bff1bab02fbc4484d694362ca05c647202ff1a2ebbdb55669ed595ff0c5c748b70dc4eec7a4031e245749b91b83a3a715fdb562f998c4deee5a5aed269296ec5650d4293fcbdeb10fac45af3afa87243a654e816d86a16d5d609b365e96cd31be348520d6b051e4c37fe2e77ab058957fefd985a07490ae3af608b40374b410c02f3e85083a9cb40c19f47c71c8a1c1f053a92b0a0bf7ab7836032f91d08a802cd0946538cec65a3e96ab8987cf39052200b9e2800be3d417afc6db1df4375f52aa1dc6c3a78bf891c6e4e7c8d3078b677b6c25a541095cae23304e710dabcf6651f4299265bf6737e858858f1479b09d6216a408920b5e688fda5d1ab049f75f3246d577cc4126195f3604aab1752f1bf41fb1da869e3b191e2e8e58fc9da0c2b441ecfdf6bb1df08816c526c45102c13ba931fa51f73e59ee103cc0d1d62605ef1c408801a7fd01d9402b5c8abfb260016b84fe372a20587a394b3f64b9e652435711102106220e25f2c1069abffd1b9ccef1181631a6c995e88bd843902fcffb4b613bc045fdc424da7105a48f942002b2dad3cef4dc80789a4bae8e96057f1977871bf3e5d4cc6dfce08515df234691610ca1766a1c60ed76abfb269a353a3750399debdeec0fecf2d515d0e36e3d5fce8feb305863947218da6f9486c18f23fe94e5183fd742064ff6e7c70d5862f222f1beaf62f84cf0faf1e3067ce1393cfa040e2bfe257c5e1ff2e0bf2c7827d6fd19386b5be20a68bac61cd03d98c2cd95d47032bc9b626d87c42f37c941dd9b2db57a33a6fdd31c908ce6f8dc861d3e389270f84c01e6b94da24f68626df8f0068cea70b9199518908f73950ce25d2989df37f666a9077e58b7b6444b6c9916530ecad3a7411c151d17d0842ffd0f140880fa58ac337b4af63cce66f467639e51d9c02cd2f009df83fd69a99a69a469fb1876df5f35228dd9a537384a49c640657f14b570d495cb55981f5f1ef35b076e5c801845ffe4d282080696094e3ca3a509ad90e45cd5e6c72262c2afa5a8c6da057ac532d362db000c6dd4ecb37714f768df6602e9e448d380e45a7375cc8583236365bd7899963b9af7eaafa0d3bfb55a0d9c64ab42394b2f6dc0947f79ba5602efa162aea5fa1f74b6dcf6d35647deba95a7ba381a2d7305016aff4bf003d06fb781a4d941ebc61c3d855848f5a8a4c0eaa411c0ba3daa9848538c1e614da18dbadd670a33e2c84014504590e4998a4b1521b58f81d77e140fbe01cbae7e94cd30feb9b4b60fdaf58a174c19ef4780025902aa5abc7a21742c52318578c23164e7817000b07310f584b22e15adec67d79e8d0649d7b5253a9abe8a151b3dad9ea0779e291ad19b7961a83f67d219ff4fa7e3d762b2abee4128ca23fe98e7a41a9e0a674088b896ccae5bb6746fbf5a9926e0dc01d6d729df2f0016943f5591372a87fb901528c2986ca8ac95a10ec393dc2ed703e018792c2e776f7661feebd56a9dce2025e566ab4958aeb84a753342a952ea104991171bca2eb0d22d77dfa13f04c948cbde782422e41c895ce584140f28471237bc131879a760b09c1f311e54e268ada6a559b0444cba78611ca4387e66aa64a5eafd3e691a9f80ec7d232669c7f39cc9b57f601835dd18837f188fc9e296162999927e013fd4824d86ce6b431255c8f0958bab834cc5131ef8119197176e6cf90782664ca1dfa03ea4f2fc7f531dcb688d06ad48a346894fbaeb5f99b9b5236fd5cb52c6820fdadd78e3c155bbf739934905e5668273cdeb24b037c621c94125619166b60f817690cdd274b644874454da2e53306daeff4bc236098906cfe92e5065efacde7db4405f05cfb42cdc45ab58102d8541889869e495d605cc52e55a2c2b7e23300237f16b8d5e4a0e53ab943d421f2eeab50516b3cdd45a9c32212c2d6adef14b4a58e2db574ebae81e6370741a6310fed4972b89286f3ae291108d904b9d9ad1aa7e102236b96ff519f16c33929fc77763e772b48455daa87b3265726f1366e5cadc1c04a7898407f5da2ac6ac53d813cc78b2ae7d3a2ba8da134803545f329f755988ce2d0f9f25566ba643cc1b8efc766b9fb6bb4e84e9c1fe9c03db9944de6d5c296288e0af17e51a2f7b80893d9c391280b6ec7671b049d9eca74b76d6405421550bbbd3bea9ff9e0e9ce22cdfeceafd36d54172c045b16cca55a0c3c2733a6c4cb53665d307d7c0e15eeb7827ec8409d65c994db893d1b88b201245206190b7e6fe2383ab22d9e63ff1d3348440086a17cce6b625673fd546447e631d13fca562f158c9cddc7af604a6ceff6df54a2ae500508ab424adf6610bd9a50d46134fe6cfebd3e2c470fdc9a7748c817e849facf65cf5259af7792c56025de1b01292376a265f61c27d36c9dc9b87279556a3973e69652fc9eb1c6f19edee92f7c3271a2cf9898b4cd6caaa7caf5db84cde7528c2c99580ef8d12812e0917f9e43dff8e56b4903046a14f3c448d6d84311270e4541cbb15b4ef6137a4ada2fe8a7f7210e930b85fc3d6fdac77b2892a773b1682d945d02c2c8dbd64b2b9dff426e1b8c9cf7dca7a6173aee8c71d4fb460d1a9b034fdf28db07c18e419d6cc13e251ab20e36a545a2f54c5290859940907d6604a1f8115f516577ff87fe819e06cbf85aaa047f2bd280aae970ad6cdbe30967748ffcaee516743e7993534dd1a4525ab051001fd3584d3523ae0cc8f52e1c83a7332112a19df3c0457e35fff89665d1bd0ccfea363a64e23c8c230cf54fc2686b4a2421329353c3867147918dce286dbfc43160b88bdf0aeaf8652cea0a2fbb9f34afe7ca071a8919fc15cd586f500b82f0fa2bcc94ddf00561cc82d16bcc4c2b1143b9354c90734cf3eed6b1934e57c9049ced6e23d728d5622648bfc03b7bf5c3b660cd22b52807d90ff11b1b3068ebd380de791d695c6d7039a2a250801fb96133df28664a2b8ff30b92df5a340552e3936fc043b724d0687579a4d54fe53af79ef79ba96d283f9b67d0424c3c311e47c552383824da00b338096984f681fd03f7b78124851de95715e317513058075a6f2b1efb49881151aff7cd1cf9dc8c60ee205fd9a31e637f13ffcebefbcd276f4a36d99741f94a71608f7e64fadbd04cbff708be156fcdef786d75ababae2fde4be87dd10ee15e44e42ad54661bc75f3a30a1b314fd43d6c9b16e4196cd1b11782697d03beaa14ebf56995471e3d4910ac0484c78727feec4c45f7195c08552d790631f5a80c16a51d183736ef5d3c4598a48ba7ae0e67d00e39388354c9b37448d1004783f8afac45ed9bd932e9658bfd0b6b975caa4720585af22021b54ded52d64920cff91164f6a8c1131ce333aa68bd7ed7eae8e0d9a1e1135402570e6fda6d502b2614d0281df9fd7ea84ad61f15f38599ccda520855797b495088f27bba977addc793bef8800a19ecec527d1675b5921eb0183eab3b7669b7dbe6164d959deb0d3d6b64293f47cbc3c3d53858cc16b81fdf5dd38b1053a858c0aca87234ad238b7eca25c5ff496f3a44c0335bc936c99bd8f436b57ab8027acb36ff7b59d8f717e39a340c421635378d53b8926214bb35819e1c2071a98aeef14270afbd06737eb978bf367f7e0ac4d3ea42d9e96a7f2f9d97fa8e4055557002795bceb21c4aac69077262447b24c2182499fcdc32b7918c4c2679c19ab1874f70ca39e1d98e31019e398502e2d4f74c499e9c2ef685194becd306a56f42f15bd9a84a230a844aa91458ebcbfb016617c641bb154b886a30deeeee5754bcbde0a7f44ef6c54e763117f8ca3d936cff781641f2452b6a05c40d6c3ff934fed2f8fbfabda1184a9a76fddea4671afb618a2c6f292dbe593e0946b9eae9e2ab9120a8b2b5454f3ae04577c40e31b3836ae155a1c74dc7079bec1f197a1daf3fd21922d31402d5ccc5c7a1702d97a7ed61125988300a136179df649c659d4a360c07331cc4a1bcca57b2dbaa0ddd370211b0a009417774740cfd1ba3d404fae9c31e58cc1437f4ed41f2ba45309cc032d58c7748af52d95bd3cd957f3dea78d112f89bd8b782974daf1f2c843428d10f5ddf89c60ff4175bee737799fa9f27afa267cd82ff765cff43adac3bc0171600be2ae3abf5bdb43e412b5b829166cfd3cc1ec4a453b554aab45c546a48aabaab3c3ff8e1742ef2b383c7eec062a356aad209145097fad86e376d0c70fa96cd8158df024aee6bce233db171f469e2215c3d65fc7f70506c5a6ad0dbc7d4cd8bc94b10f3df23e10fced4dfe99db2f81a769960234897ba65b2329eafcb2461f4c3354e6e6fae8fbf1477ca5f0fca053c7656ee2074370a92793925914162118cfcd4f6fa2eeb47d0aaad8643d61a46e588ec7ff705a3017df619d1bfabf470f78b2966e592131d400684e86c81a8adb5ae78611d4c042f1dda2955c96a3a969f9a4cf6959db1981fff6c2384726635934f0eac7a29f53451d869adbaab7b703a66d26e12175e8e7bd3d06f0863de6124accb7193d8686bdd97ef7c88809ed016fdc5508b34c0efdbe18982b9251e8c713ea478f27d3293c5342ca4018c8e1fc5c03c05acda9b74322f26f2d079b94b037c96e7a7e0b79a08faeaa1e9b7d476a7e04fc81343290c27813306eb38cae9f3c96ee13ad2cbc8c216ecc4880f2f9603609528600c4e078225c301b45250163f522f7995330311b1ef7295def03e47e3645ddb0f15995437de23c745cc4ed5cd17620f49e88792d94f2d4a38cc9e21eed28252dbbf684c27794fe2a8b352039716cc39227ff3b724fc3afef26a6b9f7675e41dc25ac41bc42ac6b7707afe65c787387fb2d2860c72c67d41149483305540c32057bdd9330d17d949d7c28ba2a1571de22b4f3eb5323506daaa3c1f87632559ae16115160ea35ff1101a200f0f8d5d72d65251bd357b7438ad8e5b10e68a08c22cd8285b203b9ba8ea4256cb7832e01440ce62d532e3b40972179d92119582d1a4ea44c2ebc8d5fb8efeafba2591cea3ecb227156809bf742b94ebfee9bbee305bb281e3fe01dad331e051dc28e044cfa3d6c4f3c2f358786e71156576d4d7c959cb469ae355ab9453e692b2d88c995d30a850b1d81bcfcc3054acd4de284975b33a3c8402d7e6d66cd5eeda6d8f9e234cd286eacb18ea91a54c1d50411f2e3496dbcad1ee44d976e97c07273f1a8e7868d114651fea147176904d223a5674d921e78d83ae0eac9750690ce5ba00ff42f1b708b313ffdf860c1cd969131ca33c77a26dbbe3a708937cec6ad75e91231ba5df2b53930b9c7f07c738c64f999289519feab7f14308f86a8cb2e59b4c1313e29ddc69e46895dec3115fbb3ef8d64e74fab2d65940cd9a0aa2882f04e8b3ff8a8803c678830b23f49d38cee46c6cf9d50beb30fc05a00dd4d117a297e51f5b7a4dd235f79609b471fbd9895b8465877da6dc71d4ab2d312ea783603c09deb4ac5b6e4d1604ac0f0f8958cd93e280c168484316bbf4ce64d73da047dc948e4386bc9d428eed7958c252ef61627e98030bf17f642bc6ae8ee329b64121575391740d23555b8196c287b75a6aec5e0ac502351f86dbd8fc6e30d0a0f4fe75b1b7a346013cc5a8d511d77fa8a5886f53cbfb92d7b4ec12d666b3e86ddbccabbe3b95fd88ace4c42b1c149935d39db30f0808f1fe7543cc434d73ffac0aff6fe3c8ab6cee7396bc391250c2a16034c052a6254d3507fecd70a4294aa84c31b1207b61ab157f551ee71e6393db5bdf40805397ffa5ee2129e7c356f83cc957796deff9d07314fa1de7b8cdeb7e22d52f599cf1070532dde2cbc6f0eceb98103da1a3801e87803c9ab38531251cc03aa7b582b7daf62e17aabe0b2c1942623e362e67cbe95561f6ab66ecd62963fbf00b154ce4b79ee70c54ede8494d348ab51ae6d10021de66cd8dbcdac821229e25ac1d650630c515b66b258172244543a8152dee4b29d832321f445556262bdb05d134f511257548efc96b674ee53b5418b244ade8ba6547f5e98985b0c8993a70e6c43c09f2e7de3565c7d6e1f940b4f1a0a4672b33f26f319d958d40e85999b84c1e066df96b748e48fdc2efe2ef0e6ac3dbeba58ac67dd326daac2b443a24cc1f2afac175cd83ce427a1f7f57ca5b0fc1ae690e60336156916437ff8500277b40760c2b11fcaf0b5994c6d9d0a83f4594caa4b8172a3782e461a1921bf014d27cb15f0d7f508a324c17e1fa6c0a963f7d4d568437fc6fb1b7eb3491164349d06770b0636b6cffc6eac531f508c108c79931714daeaf3c8aeeb64c16216d9bf2b5177f9736d1bd2a9a7a474e0cebcd2db4fe344ce1ca75092663a10c5f3c7cffd02c49846e7e9381428a0f5aaaabde312a35f491c22f8d002ebf2f412c2bacfa440b85d6c26a611bb039c8e64d621dc02580e88523964d3152312556a9f5e5d3b6015eb794a46c17b5409243fb7ee6e9b0e3204d3d91edb446f3a80f818abef6ea453f5fea82d27af5e77963940c8e87be7315012df62723f24fb0c26e0423f824d48848af476380e9ca5b58971787459b48aa196c4a228ae423fbe439531d314f0b82217d350b03016609ff70a8a1be494dda02061ea1b1ec44702daee4c038b6c8d483859f5d92258724ad13678772bde191710d8a6bed4bdf83102fb772d41fac91b76b165ca0977dc20f586ba9e3abdc582a3f778e5d7824dfcce79e3c95608755e05f50ee8303c070e57c0200961015bf66a2af724cbb1a00a6281b5df3da57c03614b943458c665e5cd0599c8d7dced506a814c9791fdb4e885bbe379b053e290579f951da09dd5491afc5bbafa47b8a60f116c84450f8ea9872bf3e9cfa2b47f9006a029c355bc9e2a83faf01eee98a3e10d4f4ac0b3e476f54a1119f5f9168ab164a2cf79af9f81d79adef79ea7b212b759a65abf28885cd80b4771f6300ccd47d70cff451f59e812b32ebef5851336520d48acdfa4d36ffd405509c6fbecbf1235a336e3e93445e3af791cc85af83a280d74230ce596c70881d284e380d6804042af14c526ff16aa4ed4763e52f17f34d9ff1a40921f31efef336b40fa75ce1441dbd44336f3bc1bfec1a297f3c9c465dec7fc20fe00db5da89bcc8b1655513b44e3819f4656d620ca07f260a00bf18c2884ca6c0218d06b66899114319309e002343ca7923d7b83f648286cb230c58eb3e1161607e362c004d77b71de26892fcd36e81bed66ecf6bdf69e556cf4ff8c59ac894f152c421403b42f1b453e84187997dc998b22aec1218fbc98615b0bd7f9edf94d9823172ccb096d17a6b7b06f0d29959be1aa1702d729582cebd639ade6171c5d8c70826dd193facef5e4145b988d0fde39e6fa76f70278d3f08205b697f0e2b55e4c0cabae2dd1fb09ec4fd75f44fdc1140376cd8eb98e1380080223ea7a82b2ee348ecd4044a73b714224a393386fae160b51450d6831eaaa8b31f3788f970c1a78adb99dd0cdf276ad6b3470c745ea7120eb4ae3f489f59f4088961c6e893ed549663cacc34d0bf55b121e93a6719456b85ba99629b43a63c595cec8a01c774276ec82f9f5b5b748468fab3346e2fb8b4a45396e07d004898d37e06b99169b2828685cc3a83311f2f9438a68ef0764f3a0ba84d075ffda7c1ba7ddad38c37dc956236371adbaac98296c18586da5728c5914bdf74583f68dac009f61dae4113e06719a20d99459937bdc14e698e22d09fa5e65f307116911c1536892ea2179dbf773fb6d008e42448a79dd94a87f7010981e8898bacbf7bd782a24959cb13dd8a7af19392ac352cf9daf5b75e9e4b9e67181b3048355fa23ce9a9bd2e97b86ec1f1e5bcb9ea492cf603d0aa27696529626f78cb3666b32154e835b16b2705a089811b1d88f9315e77b9d45409f343c2932756d6cf4885fb285f4ff90592e9c8f8b4c0b00c8d3b152186a7e2214192f715023c95b4575312b8516ec4404ad9e5913db844e3ba334252bb62564d03eff6c24bf5fc94e932959eb1279d1180967a391392a3f638665f48dd182f187b6d17aeb025323d7fa93d364c406cf50b8fb8d9f856b1a4374302270ccad43e91cc30210a8a1af2583d9dcd6b3aa00372c56d95c44c90667e4075f0dfc726e097132907c6e706c6e6bfc43436dd06152c12ad088bdbe37d476b7cb6935ad2a5bb6d8477d081adb5a9a54cc6971be8796d63ede9d409733bd1a7411a14c908ecd674f6dbaed47e3c999914157e7e302efcb625fb1c4ff23811c0613cd17dc8effeec9f77f888dfc5b04ac14e208696e3c78caed4728f0aea2c89da1619ff17bca6c7e53a085c09699bd5559bea1ec5d360a876548cee5d5e9b5e37a156b1b2db010e527bb750cffac4f3d54f92b50a53744362ddb12b0829d592753e63bb7c43c33dfb6e9c5041877ec918123baa05a56e0911031ba1713684383f20292bfbfc3e522e9ff7befd4008dab59d0ddbcaa0a0ce53c9fe9ae168cb587440fc6f5faf12d3b8d923608dddca135f0913b37c83a4067000ed0a8aa8dfa8959b5074cde9467aa23626f0191dbc7809f96515664a924c6d449bbcc74696665ed2f3012de68fc7a300a728058419a3a439818c79c375cdc7ed56c7f503fdd59442db5f68a3703c8d9c22447997108268bc4ca9e9ead274d0b7ca424460ad15cfa47d3cea57c01249179948245828c63d0a00ac2278d489e9afa5175f7af5492036fbdb049a6c2ffb31c0d80a3d5febb2ac5a6255bb76a56a9962020676b977639e7e3ee2cbbf0b6c1253b66c682409c136c24b1d81b9f0b04ac5bca092b7cdad1360f77495d3fd4deaea1b1826409faf3b8ba41e92082757663d1d75e846049a2f88e5bf74a999b2fd04725c01319665b1997f9a3a3f0c69d34aeb84281b6e349bf345d13964dc69d71509b8d293edd1d54905846eeceb30c0bd5d1ff6229be2d3c2218dd4d84726c614f941e708426c376cf9a6eb792b162c8a502c26e8befd400ccd0b1a238c422b789adb00bceee901e1d388bfef2ca93bfaf1d0b9162eb42baa63a345508c66b428809132c1db73797976c83481d2898caee2c11b0aa416aee4f6085822067568e49b9a7893fc78c9fb26120b510fbaf78dc9921690b6e3cb823ae419176f3e135ed40b8d8c1ef359d9156d2076c71770ae7643e24af5c4e8c37b23953682c9a9f2a4e37d974fc77e5bca30cf119202355aba09ef866f899f9c96593373947fefbb07999024a9b35f7f16d732084a716b8851412ab02b55f8bcc25795112608f7fa45441f56eb1e832c1501e165dc9c672a946718416fea0e7e617b76d52938f94cf0e0232b0c4b92a846aa8eaa21235a54786cacf911583dcc5323caf3bac461109e4d58d67d31f4613726285ed39a6be0c543a1c2aaf2f5012d6bc31aa1e6975969311737faed19cb5d2428ead45ec028aad0e8ae3e48a84d86747c409684c99a0421a52d2728f8d149324171945e73b70e82b7e8a217cf6a5ed9c38d5611ba5c42d1d300d609999d47790c3e8628d56c40f1035c239f4e5330b9604c8a49bb1ac259099682a742e9c2074bf2c23e2dc3f53deb945f241a2dd554e6f40550d670cca35f2695a31de7757e58152b22c2f2ad5ac727cc9339460cfb9e1b71a17f3508ec0553c4325ae5b886b49b189e712fff74c7086fd70edf62ddc57e9deeffe9b36b1f0b35124b81be9bb29d532696d060f61194a85cff5bae97eaccf4c5338f316b318d20da8a729d80147fc9b73d2aa88f94c6840fcc33936a2e21f3788d1228a5fc8b9b3b8f0bf8e1f53b2347e999b9b80d541bab039bad0e4227448be0455df6e31839176a67f61503b846fd0d53763d7cf033ad5f063a619903a4a20cb4f882cf174049c2e46376dee59331a19334c47904b0b96031576d2c433f36f828ca7b3ff3d904b026869caf04044bd607a71b6ab5a64114002697a835199c1fa515a6fc038aad1b9467634de6d391d3649a2c501a51884f122c1285aaad343ef07680dab99ec3381dc799e17a99f33a17ec16f745cd54a0039e22b06c536fa9c54fccb741720756a2af0e2258ca001726228d52ba21a36f3eabfda1bd4917ae705211f4cd00eb56883def9729238df621f6a10a71f8ab30d06fc5ed8d69e0f12986a56ef05020c7d29bdf2d32b852f429e92b38df060d0853f24950c89ab8b4ebd887a15e7cfd24f405c9c282207f5c35268f8afba048280842e9f0ab2e2983b18bf5054f076b23b48df7e3cf43642eaa1faf1d1623abb8f28095f8891d8afa30f4f5e7e414d608b95f22529260d0fdbb86e2af162c764a0ccc8ba67f3be4610462d21411227d02fd7b7d43164fba0c9b745c000846d9a7a4ff992920ae9f98b7fe582666e5a20a58bf429a7a37f7b2c5df4c54d80f6edc40f16849ce51219bf044282b8e427c503b03f4a5fac4254e2fab7e0642769ff3ec3b581e682ff5ce537d6098cbf3f4ce712174207efc5004d20ba6893c09e98d7baba02c016c61a4b11975dbb9ce90fdea3b6a25fc8d6f7a3c3d5d35bbf285ad53ee226d02ab06bd5a66c86604fb6876448360846487e512590c14ae1d83ef65db86e66793935bf00b51541138736de3e75756b2d7f112f75562eaa25e654c901d8a5376a7ccb557fb1f3fecf672dd3fadf8c579cd2d24d8c2cdf89c2b352d40e34f094bc8c07e640e4b8728f96da7a9eca79fcfaa409f87481535d647339d83c1ff7bcacf4f0631f05a17f23b31fafe8b7aa1d40b74735121435dd321a4b2ae3b619ebc6e6356be1187b2b73a19d8bfd716b360b2ed6766dce07e9d58e49ca3e4ff65250c060a686507b66a68e60bd8bed218ffb5a856fc746a4098c08e4546d8223b1b97dbfcd0f000fa8377c30e7738b8e9e7eb15b039039d4cca238ef41689fa56b09c09291389af58e14a5b21015b7d4d427008325cb1c5506e5d6478b484186ea45006b9fbe7dfbecd01b0f3c39c6ae5473026c85f58648316707e20822f8d62e938bb9f752612c6a2ca2c07e105bf6877d0ff3eee6123a3ef872e691b0f059ce02c8bd19edaf855cb46df8c72831182d9373eb4d7b655fbcd665cc8b15a2161a588ff8fe4794b9ca4f5589ef52a08adbc375b4e41140ad24019999946e463c55274dd695b20e48af9a1bd9cb52ed78fb2b79ea4d4ff8689956f5cc90b3c546001a7a4a69cd04329d4c3889a7d4dac1fc1c0be4bc208d66f2755ad5eae4d4d775ccb1e41d5d5108601e660b4b61bfd8a3765cd0c8e1a1582a2d023f9132cc7cd3d1ac4152b469895641a1cdbec36303f2d4e770943766af522fdc6a1491010a17a3de5b1097e17dce775a93625fd4e7b309bba783a02f32cfbe96511222ec633606938f59226d86315a0377f2625eca3cdb653643c55f252ef60a3b9ba8ee5d27a641a01a4f76e27cc2a23461a8a31361debb25eccd3eba4e8c800de8261468b61fe5d337c5d044508b5789f9f178f85aee475926dead7473e5eb98081ac2f315dfcfb3f9d39b223295b643419fbfceade8aebc5188a0a6e9df238de7f126e7a423f1c846f1dc6beb276bc7a9b6110f6692e5be8a45da7972d45ee96aa8cc70c8b4b91ad548005bfc4805d51baf97fa1210088e98aa15de6d1b2e62183c58d9011d3f8997a78b5a612978377885fcb6de35012f217c6fbf27d8dd847e152f90b097ddab5605d7bc21b9aaf3370461459a5fafd4b8cd2b86677622b8740608f9a8ae3535c4f3e00ee1f1e5afbf024e8603cb2c95dd1973a86dd637f7b17fee63d1abd81d94157038057274c13e2600a20481ec4b104c612c61450e92507f907d39cf188ac8e3977fc214bb6f3de4abb65195a6a74c64dd04502d4cf7d8b6b4548061e9bfd6e10d2b2d1f1c7543e0f183d9b64b00ff0a7d0257236002bcc68a8df9c645a8044d0e28bd30c5472337ee56b374bd861144cbefc99e00b03924af0eb9353feea960d91fd5261d689c63f2b0a67273ee3749872c2295c05cfeb23f133593538664af388f7e4169cd1dca07f1626d29905bd6aeee8d9c583b57c976d8ab8a354b0a37e13ed21183eeddfd67b407ffdcee01b5faf1630a410c073d1653ef6cd7173fe8087f6068485c537f1c52929aef8dcc7f838558e82b616e5f07cee79f28fe5f1c39e08e75e3adac8d864e63852cc9e5d266ce433ef44afd44bd8946d68974c45e0eae4b22e2d29a89b217bdd030e0f61e16d740418cf33d74bcb98de0e3ddce2bf7e9c932ea67b538fcec68987e379d266f50aa2f01c14a358e8b87f83850fb5e9b382fe3f91bb67d9b02f7f0fa97dd9d289cb4c9fafdd36fbd60d106b041cf9157e6ffa1a7040176bc733f08c84e6880fad964eda047eeac249f8bc3f3bf59b63f62790e8a66f279d32314c7628aae4753332c083ae9f67f70483c5b336ef215b230632b5df910f20d113acc2a6924cf1a967da82505654f54ddfdc27c9a4f827aa2356bb4f5be40e7d06f8200b42ebbca84e805e045459f9a04f9cd33faa6b2305d6db62a95a8543c989f3c690379b80269c60f3168033084120a2299a3480ed2eba67f962ab99ab7b70c7f6f9441cbeb86e12832","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
