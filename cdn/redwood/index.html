<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8c868f9860d94b9c34a2dbd1484bde9efae37b6401a2a129b77a0106bd996bd998314b41575df904c15b96639eb6a52541a5e5558d427d3b0361cbe232b38d29c4035f20950fe2e25489f9c09b83133838f0c532aa00f807cc511ecee93c5da0c7e9c8dd6415b9d3b10a52636a66fdfc7514b5aeeba77ff04fd3b68376e012dadd0baa247b3e08f3ef18c6bcdd1f79ee65c0e649dd3d84963a613590bc816f57b03225a267eb05f227539488a51357c21af7ff3625ce6d34fc1e63b44addf1b78f0f8a8ef63a54f72cd84ec8afe8695adad60ee23db92930f1b1b84e3d2366ecb137ff4222087076729591da57971cb918d6cdc4ea4e55a1d4c8c3025f8353b476343a40d94a113b4ddbd5a9a2c99122e492f1d405d8ebe8a72852e38575f7917b2b37f6c44332c0b3167af3c7b7a20c5abe2c1b7fd4576d24de169a923428cd8aa60a8f695bd3998c4bbeff2e1f30472f9175bd7bd10aec790cd98f7b4f46b05356ef42e89ec8ba73b48a7b48f5339887f639ac4d9d1cb3337f94a1da9887d13fa0dfc3d7d3bb02de7ed6cfc49ac27a103df1d755891498d9c93de2c448ad9e56fe1fb2a5620fe136d885b56bccb06f8ce31dd3e3c815170b6c8420a17fb2fd993242be6fb72af70b5b4f30ff0a74f9033ef7129372a086baacd604e42e734a1c4ed884e3f74a2b83a3fe814836334d9294f87fe00a28bd062bf7b486471f7166d7bb9a8799a63a7fc328981e5553ce29d52dcf93e737eba26fc7ed29514feafd52848d18028c7b684ee2c60dba444cecc8ad5d19f254f0a36bf17a1f5efc0f994a48d8516b9469302d9fb1356b975f1072b04fb4539313428f511094152d6df129ff632411de477268ba0b5a73e4ea54a3b68dda1fb905bef92318d917cac1f538f3bda5d139736ea5ca722541ce784e6535b8b0c63d3224e80de89e2f201ae5675d4b850788dae1fd43842bf72a4c2bbb1fa1a5068bfe66320276f4e4eac5f02e52ca81f05c9bbf4f39ac79ae08a71b48a207530f8b9a0d42308659f0c4c624eab776365cd737cb558520164e144b170a4e9a892c3d6f16d753e15a118cd3a27656b83f0601ef87c7e64748b5514bc2cfeb88e34e2314fd531aac5e1b5716992aafdbacd708584b095400f372a6a662fa5de920b93674856ff27c822540338ebee46beacb9885f36444aef084a332e617e73b585c2cf13a417e7a88269a42cfee88d3addd9cfff93246b3767e810e9682b04db5b6c6182ef163c01667418699c6941d80f5cd8c19c18e8f941dcdaa5476626c5380fd2328359f2792c4092df92724722791980a448cddb3a10e6c2675bdc80e64e9f17f5c1bc5781f614e617e792e870fb94557fe26003e48920ee54e253ee1da14b372dbb160a57125d4ea49c687deebc500950a471256c072e855ff992999d28115a3b4fc4b0168014b1abcbeefdc7eb9553dfbde60fa09c856a7c5c60aa6dad301b4f7379607b665d5e536737de9651763aea1176615eeb4c5d28a9dde735ad58d75cdaf94004f89fae420a814b399e2c18ceb082973cf53a8c1c3e1ce4fd68ddbfe4d57838f02f911dc8957a383e6a6177bc4039ef64df0dae5324e6e9b068c7fc761075ca05529a4cad216b8ba326b22553486b20fc2d550cbbd8f8124850b28cc83ada03811c797fc5cdcd178dcc3b2c01200be6b1fdd121d2ee18a224d552adac63084e9d2405bfc84df46979043f724fa263a97fdb7f2d815ba46fb0bbe75a68dd1b7d72b903c4f7205dbea927fc4b4b515f4f846f2a8dcd0a1847b2ddfd68d935832821051a203cee4b4c88e6823ecb568eb7fab20ae575dc30d34561c7b39be36d356066189b23242df2b853dfb2130b5efe9b976ad28ea10fb38b357fd1996d56d68426173c797cbe11909ed986b5a8560477c273158770cc1c474166fa9c2d37a77a73fb799833a521f8945c332cd1791d54e514667b76cd1484569363296494a9de43f654e913947dcd86cb57b719130f5a744224315a3b38af828ba817776a005ff410bc24182d55b87b51248e2774668034cf657d3ce81c633707e9d1ece7d626b62bfa6d1ebe877d15ba46dc834aeecca4035e5ae0193c359ac510e5d585b6ddab0937118b408f24ec6b64b76fe8f7d440f3e33b577ffc839b52af8e0130f92949d5d5b1de0371b82b53f8c4bdb43461d23ca74ef62b43bcc8f937ed924a062759b059a39d10a321ddf33deda7bb76857b7a6e5b3a57af6b794cd524e001e92bb5a1d6d604d40c0369280d5966bf127ca0c45506acd38391f3a15c4c38ba372015731063bfa7b341027e15bdb4220dc5e68665780d3efc4f0af47771f93a91876db01e17b884a12d94a41dd0cd90693f3b7b72d6fa3a943a29836c71678b57f1270169cf276cefeb3aedfd07538826daa760289dc02a314280467bf340c0b5d842414ede58954cc37c968abd25f02f1487940a18d22b4d942b2d119c48836dda6165a6f5218535c21127fc7e3b1da1c9e3f984f75d36615437e91cf01777fe09806d91bf6fed57c27f49cdba009fa245e63b4333f63f1d493d463380be2d7a89506b3f7d04663689b77c329af4b12e9df252f92072ec6e01636a0052b583ae9581d85c1990da01596e92a60ce181d248e771d2b421123b6635d2b5abf0c452525d4eaedbd2d1b5af5278f340b2b2348faeb07272d161418957fb8724f8bccfdb9f59da9014386a55a488845ecc9a88819358af732132fcc0f8c346c60132e113f849a5df7a923d0143886aa9cf547a4461abb505030a535dbe1c1d327800f00d0e9a10a57659092554460f2e6606644733cfcbb6f3a0e7233dc7d4ad1dd4d457ac224962c9cc653a63dc4d8743b1fe21e019af6e2db5463b9f72c2281388419e61fc78be42c47d04f060e25a653de1890a4c07576a5c34fd091904fa0ac67070c14e41021e63af712dcc0d035069be70684eac330e587510100d0c7e7b090296a7511e148daee70f1b668f566e7ad0594d75c4c27073b2dd9aa061c662faa96fc074dc7deb3e30273da7cd5547a04ca76b41afc3322f32d6452e759b02c554feefdd5adc6bd953707c4aa4483cdb9209dc250d751a7cf1e20f6c87f3fdcdd181709f7f4bc63190892c2a59fe8f2dbb80a3bbb5b83715b17dbb2598ed71093e3924e0e1b733cfb257e38d22c46d250557123a888097d54f45f8339044d82f1f047e26b8075d49fcede4c813c82688cab5a6fb519ac46cf527cb50c8e58454f00bf7d209b585fb5d296e60a87e3f622f22dc205fbc358c4826f9239bd6c21bb38eac8fac3dd4bbb0fbdf5de2c6508bdc0a46ca93b1e53fba3d8e3f9c6575c35899af130877e3457daac1d9a0768d40149e57b8a2dcb0fa08edfeac9fdcc443fb1e942d1921770229c8a9c7a1960fb709897a7fc159ab16137b6ff329acb073f76c10feae5fe4b212d7345dd2531f9356964f24c8399bffb60fe449d1cc8c99eca3e1395b9e58130b124b30ea5f1ebfd96257f766b033cc1c02f264a117574c03babce95960c8e61f4ac84b6091bf6e39d29367ac8668c8b8dc6ef11c07bedfb7d3d5bbc3c5f19a4128a13dab25aacdace6995bc8d7e90d7f234267cad3745abefb52cfef14fa389f1f268256c778b87c1545442623f12c64b2cda6387bd66646662219352a7969c9be277ded292533dc50242251be0f1ecf083f1b8d8013b2d8395b13fe7c1ba29a1ff01f786120e9bb590358f46c311b11a12fd6d75b757db5e96a574c01aee2691f922b33742c96e33743f45641693058168d5c8747273dbd1f1b0cb3e286da2e1c0a17993a9da7014a7aa9db4a0afa4697bf6416d42b529e8bb2c0e1bf1a2d76a9169ed4a0e4418935e10b8eb56d93271f327dab900d61b75ee397ab4ac0aaaf0900c97f66b79128bf31ffa21ad362e74cf5fe959b8cd00ead6d413c729180957d938a2cf8a3877c09119dd0b1aa59ebd7cfc66d609c09bdc1dc999f552df2f16f578db546623689f7cfd977e6c323e4f6158cd10bfeebfdca71b484f7f4d67f0d4463a7d3910d5967c3e5d7acc33ec4b76f83707833bdc0288ba2d38d8cc3187185cdbe7f0597a2de60b48a7106a5411f63f6253961deeaf076aefd7cca0b730fc28d5a475df4f45f2332773cff7f4d76ffeb405de19480eb7feee0e2395ae4589c85e3bb39e72cd0e7e9c7c40b7e719af86d8219284e4e4230b57aa98daca6e92915e6b24c6e47313581b738c0e2df0b4fca5db2c201c7bf662b9a15f7951ec983de4bef0339b0f17b40706bd5cae959c6a9cc475025f8ab60d3c84a047b1b795278a4ccde7df564db6b4ff5d61a703be090b1ece7a9884f6e594ffe33aa69782e12b7ce97888258085c1a4cff876872f4102e61e36a4cc6fff08d282c7480d188400cc9a75f258c1e1a4f1facbd36b7828cde13a843bd196be98595cf783fa2b861eed8b40e09d1457a728816aa8e03e3fe3314399298749e6a2c8a4df6a4955da7bb7b2f7385a9f9c579acf0f418b41c409fc08117467c6de11d8fa7ee4b3a3290e365bbdd4d0b3aa543c0e40ba6ea6a933941b8c1526a1f7dc52222cab7141e0bc527cf2d242d5da9610a445c8b111a757716eaf3cbe250eb7e9076cd4dfcd6de063927f4be0d66d09496321c07363413ae574d5f303811d14ab2b9824147f2e77060a3e699b5f4be58199c7195c6b40569f15405d8ca59fa2461b01c95936996f521ac5689dbbea34234e8522f3e3fe676836926f53ed2a6269a23b83cb7d0dcfc1079e8c426a53741bb472253628ecaeda93df437b1296ec3b262f2bd67966bfbf90567d44aa4ed6df6ad0892f7b915bc4afeff2259994236e97ece4d008884fa3450f7769e487db0349f63b442975986fbc0451d64dc8571fbd0bbcfd24c88acb13773b1a72ef96e265c5a50c5d981b98100cefc2a2d134f44921f5394f2a5dbaec59f422058dd4127b5863430fe08684cfee27f564808d175e3c7e5007925507056e177c2f454c8a34fddf3ea5081c1c1d510ac9553b2b75532265c1a84a79eaf9f4e700b92630143665226419f56645f95f1ba9c15048b3bb0859c6a79d05ba603eef196499cd9f89578965ba2bb86af806ead6e6dcb480c868bfc46bc6c912363ce97ff05037edcea428a96608a7c8fcb4f2f3ed4162b78f5b5fdd5f89bf6d6314fd997ea9bb54bc337a82e27aa07f9249486ff2f12deb2d42d00db002b0bf655c3899a6e38460a27e759fa7b12b53f42db97ba4b04a641594a204f7e9b31078ae3ee37cb18fd776d5557cf4c269cba8d5f14d4459102de0077cd697bffef763276bf195f8e34cb6f6fb843fa4bafa1b430d1bc3f4369af99a44e235d3c351d7a47d5d40decdff350acec981701ddb89811ac96ac0acc5ab7de9327768fea96b18e892b90be04e32304f54936cd3517470ad4f9afbaa7c4090fa43a2bda4c746159273c85a02b95efb0c67abe7c7c26fb73574fea587ad0906ed51bdd1f6dbfcfe87da67de97e052d86aefa320d08413b8727b2909348bff743f70de24964c7269a779565b420a649163268968f324877ce7d94a69ef29bdb878254b6a6f205be9cb07e8ea85e034481d41c791581bd7a3f6b21644c460b1e5f2832467047c412566c241d0ca9d41c4c04c41187c68ecb0a18d5f4b30e4c79ed3deaeb8b7a60c7f237bea22562954719aa29cb2a79072c483cbf82438e76288d268fa1d8fbd4e0d97c9744e727037ac2d4de08cce01de4cda9f67f26d192c53c918587a144e36d07ba967c35f83518e8caad31c3f0f1134ee2d82584644e355110fe14dd43672981fa66236188912b62971ab8e2c613e9165fb688af4860fe26453438621dc2acc8a83039fe41c5c8d0277ba6dd67e21e3b6323803fcae840241d98779bc1b2877e8af34dd9b0146b5dca1adb4dd7caab4259ea5d786d02413b7713ef53d048c307367735b34cd08b95abcea97b593ac46bcb8301a08593c7460f610873f07fd40ed839c42d0d97f8d1ae381cb7df690aeb460b3d34320e1eab75dff655679ca423913f0a992c6e4cd8d401674d4f398a8e1553c0ef22e330c4621552a3632a15544479661d3d893d6e13f1b3bdf9245c77d31498495bdf5db56599d240513f64b49f55cdce44d2ba3796182c9ad27010b9ce4393ef18f1f27eb666eb32a48fcac95ba6c0c45b4461cb28157bb597e7a8294bd33257bc4ec07b723c7676e5c5f17fd4acdd43f0a4cc5f13df7bcfdd0e82d1674bacd2d9ea0d9701d0b709bbb9d08eb3c5d636451866d26db1560e9103fc4efcbb9b5351353c9a5f441605d0bd6e9a7241095a1c7d60a0571c1c25175da10398788d522eb452bed69d806d422aa8c8313dd8ac38b5e7221274659c991b49bd4c9e981b22c50b13067e891ec8517a6d92b1acf2e9156d272d4e8d7bdc64d7028cb0117336aff59930fbadd5b3c6f77cf37d6b8ae33b930d01bcff44a75b661bd690385cfe54b417135e0cfc81facddc8c2ef5ba5a247503e24b750403a66189f8fd33ff023e8ba097df33b9ee8b71ea0d02303d6be1c91c8338d39be75b8e5c8000930ff5c08368f5536a38e9df3403695c9fcaa6a21b870af5e4fc1d130f69091f24c39f72c6876438c5e3c3bb1f8c887e138351cd47d2da6fb6fbce8ef8755695c76eb583a289b3ac66c9f067a4a2caff3ca0174fae22af9c80832ed603bb4e4e6d1221bebe5b369d11cca989a6cb0eeb1667a9e600cfa7ebc39a3d27b2de12c91bdebbb4ca7c992c7b80b877af09c2f066680fc3c51e26eae2b13439751af03187da68a8a0dbc4da33f4c2c4d3ae38f22629f43970021cd88e0146bea8ef9104fcc2362df3f2664a4eea6abcc91e1ac8726091e8d4c70762a53e13299b7a2ba5e222ff886c01c54da2dc108c81d495a32c8a64f7fa4b3a5141f0595f2e180f1c21cef6ec1b18006e4beba94a7b29c2b4225ece9074aa8fc4719d3af3c2d8943fcb7606fd17bc65c527551531b0b3ec4fdc06ac385e3a6c66233efc65ff28b513f6f5758ab741eb05cc20c54f634d696056b32b12390b992d9865ddf77e3c729dfe8a0eea5a839a37347973fa52afbaa9a86a3db4974835df82ea0ee4f36a5bb27dbf5ae029c834bba0afd91656713c491ad9369021af5338b667caaf0d61cbe4394d9cc00148f35ca8a57d3c89426c6116e29e2d3d01796d2880b9938f7fa0f826dbd3fa80b711c65760b7ea205b79994b4e79bbeda9b3e3bd2ffce59bffbb4615214a7e9c22ea07b72d9c4928e7f17bc2c1fd8a2a408bb605258bc969bd1d861b0a3b59d6150b813d0edcc8d5484b25a666a45f7a81070c838fbf79affc1c9d6c876ea91e172178bf4e0b8ed7ecfdcf6c75df8b3f5430928c8815327a66d2cda26f5f2b52dec32903227ba0f7659cf212a2e709dea3a5c1edb2ae6874bf077d2d7645e38d44c6dc9efd80e6b1cae938f06e5671c068cbefaa3e17bb69d3f4925a90a827e055bd5e304a3480ffcb89c506a489efc630ad31b426f14c2eb6b5bf185ac732c0eeb6bd5b708efca5681032fc93a0df976ea7aba0d8e10af547fcb8dec755df35751d701e57a8081da2e0faa0cd756f3570c48d34cb35539e135b562a942bcac49a07acceb3c56491c332187485e337cbe850dc2b42f5b2d6e9fd981b7dbd4878e11155c3c3fb5ea84c105d6d3e120fbfdbe8b877de1fd3e68051c57264f37bc79c3e76a39fb409981c67aed9b931e660d88c9d6d50f875891ff5b56c4fee305d507f95cbf9092bfeaeef21b4dcebaa063c81723349abb3f5c999be0dcd39ebd6f528141fcd79dcb049b106837fb744dae96e34b7e586329c152ffa769606592476e5df04a1267d2ec8017f6abfec1ea06f5fdda11c7d71b7244b82c285ebede30139ae4e34fc26cd83bb1ac91820e9960aa9b0cff3eb8fda9d749a8d46a27589a912019b76327dbc2e439a91df4134c700b936e0208ce33c5beb0e5c0c9af4caa88772e979f52fafe4a46b0fc37bb246835be96d6c2fb5ee29a29b06f862a7e0f542a2396c5cf7389c1e21f79b0496dc30194753bae08df9c54b5bc990776a709a031728c6218f5a6bec6ba63bbe67bda51126f0c590c2a15158629811ec22d24422c79b1b4ed7602e677272e076b8860fe92c39528cfeb9c835a6bfcd445e5d619953205b345150d8b97db22381726d740c9b30538ef98ada2f7236ad1a5b4d8c62f807669d36b798809e78071afd9afdc066d1b8aec801f6927a31d815ea5010ae6714c2fbbce9a5ef25755f40b473bf988a5f079c9ccce2c5a0eb8b5c1aeb91eb90464f623cdf604b7f4a3656eb0c8bfa26ad959e089b9832609c4c4d336d67404e546f2bfc72ef53118c555c2c49cd39e04635e77ba10e61c644ce9dad5f4c3faf35dc25b89f35e72c087a1b087f36def6f0e83b16afde12e83899f950db4e46a15ad611e783e909ba9f629f848199361f113a6ec134701cf39090d5c67ac3adc18bcc30d333b7900c439461a1259b360083b016256ab3210e09da50290caaec64abfc2c6112f77177bfc7cacc19f1683244fcd21a1430f478803fdb2d2f39f1f45c9d4f87dce70b5801481002e7348d7280e899ce062e10d73775f9ac3e982d8cb21933e8ac996a528a74e24f7608b58f070333768d486e59c491fdc14ff7b92c267872ffe837439f608afba5d120c7eda6790f36f9d5371c31df6daa5fb2227a6784a70f9bcd054835dc5536646a182f44fb3e3c2c16458c98c04c1bd4449aef1dc8f4af62be81b6eb5306068c8a2c633a378ebf5ffba71bb3191bc49be63c31856737ae137a3955b59bb07d3b042cd0f0956706733a31a044db7d975e69f36f6f230325b3b0d4b1f36347224b2a8f7de4fa3d91b4e06f976de7399f2df6d6fcdc64dbe61b4ff1490fc67471a344beadf2656b85c06433256917c2f81fb68072506b991c44f8db659b7ab3e103c28c9c0e607071f1b6bbce94f3b32e906a9c15fb1647d8c3167b0c1ab0caeca807f9d987376ebeac72e9a33e7e65468fda6d2b409cff32a8b30024d349be75cf1f9ca3309c7706809973d4243ea75d59588a53dd0d2996f0e132595e7aa4bbaa61f96744a6306420aba05558b33d350ab92b4f6347667aac08f1f49dfc1c936da405455d7806de8845513cd9e21a2765af2557663550516273ab839ad477d272e11f878311fadad2b3f0051332dbcb00b1c1f236aed641b4563685bb759e25101ed45b3a149e754c436c32b2213666afeddbf8550278be43c3f85eb4ab41bb500fcb5400db48e8f11e96e19a60d9cc443b3881d55c3afe9ac2a2aaf02581e1bed6695d3cd69f54a18f26bc7a7c9fa0d2b968f619ca1a5df20d51367b8c4cb9b245e49109caf398f62cf7ff612f3d6baba58d11e133b0ffee025f995f7c9edd8c8bfa7c098aed5e31a8d88b0a0822c438328b8a1a30dd63d4bf0501ab82112a7a649ffeb4220cdbb88158c4c9f9c75bd833bb4be6b88bd29bf36fde00b467105fd6f51f619196f4d629ecd177736c116e6d60e0c243ee9f173d0124846e180665344271e70f89199630bb5dca8363c97d7669da1cea1c7d47b191ca7e4ab42cd37e8ef6afbd5c3c46b476ca5b62f0bdefa74685b6458520c0a700a0bcf44026b0b55571eb0e1494ab662cc4cea1c836c65065eaa436a94a3079712f14e1b8652b740284cb9e96e009303da86b93e76affaaead82ad9438fffcdedecbb3a672d54accd639dc4d347fcd685579cd025536847a67a4b53279fd0c870e760d23619d6618b30b30e161a20933e9f60d7bf3afa08dbbd5b8f33d0c2b6b258b91c7f25a587fce9afa364ee931c48d51952e132dc11608befdb2719d735e61b233b366bb93d1cbaee51c621d9bcd6d128b81bb906939e9e1c3e677488cbeac4b4a68be34751d8c103930e647484827cc71048c8558d2a787957b6c6cca59aa2e0f0f22f9dc4f643a9a6c52c926cb487864ca22b986aec127bad46bc16c4a8f371d318598ce3032faaa71e482c5a5e7dd385b5159b2a214435cad20634e00e9a5f7aeb284a372ca9a71fc348e08912e64374e2d9a430f5f857455db4163af8329ba5a1f8d0e2ca4ac6ffbc4d14efe445cc1cf5d6c46bea36a7d80b88febbcf4e24954cc7acc1b7d28e53f3ec325cf0432049cd062b78ddbb616f97c1734d3d15fdfe7015f41cb5f02cc5c96015e1f650fdf7ac182bd7cb8f803cf9f6efb50d86cbde7f971a862acfda632405646e86cd1aa984cb7e6079f925edd201a4d84817fea291327c9a250d63957b074a79ede6ca95ea8c2d98ac204195282d4c0b982048ab77c7566f40d6efa441d5cae305dd3106b831017ef1b52705f76a1dc87379fa28b5d80d3f1a5cc195dfc74720d4074ea8411cf8f6ffc25cf54c4f0f45ee709ba6e4956a7c5d56eaf926fc8f240051f908985c9a711058a6d7c289e6124edbc4512c7b5567e1fd59a025b1419e35eb5418e7d52ef8d4ff0557c0b81156cbd377cb90d4ae6a142581a2a998e39d4e0f5e5012e30c12e02cf45efa1e5ff5a252d552b12844c509e895ceb3007162aba3128aa38b5a0049f8b8849641dc5578e3760ffdbc1021cead7df7226fb0532afb23d1f4ac14cd3c5c2da7e8c5569c0b7a34e2a852c028c0e23f07bbd4b36385ede6ee2db468cc9008fca5362f6d1840e765c410d82501435d46f9ffe14c790b5354f336eb1639005e84ecba5a1288c78bf844a16e1b5a69a58e9bc68320463f030ba691f53bd763ed3468c814b2e89bbc253c4be636fbb400dcabd1d211fbdc58918723307da76397e0d8b9969d3a9fef1c079da56547578ce90c3b492f6b76ad0858947a7b5f8231026d6fc33f78978235e886a43b0bab382fd97d798fd84e966ca8b9b1d1c46bc72dfdadba3072775bb316dbf2b546bcded96994cb1cfd9330aa98507fe97212841df77335d5099b79af3b3f22c07547e20f2fe940c3a9b0fbc8c37ffdcdaeebab12ba18bc9b8c2e2feea48f292c43d5757f5081c31541a93a2b76ab412c4951d383658bb3dc07795a8fc352e2131c6fe79ca28ac9fbe9fc4aca459cc8fb1013df59d95ca016747780ce4d7f82204eea307aa681c9b16033b325b8e42ea98406fd7b75aa5387426c3d4b7b5d5a47936d241422c978ee4903920cbb551f1c2955f2c39425df1f7e0ad6cd9b302a238bc021aad2e81327c56f3ecbd35a85c0226fd7f095dea0f4870bc86a1199e800aa7b439de2590f836c7d162c81aa4195839390023fc3358f5d019f7b38f6ed8c7c446e105afce62c4ab0c9b7b3488a5b833cb325f2046958972382e76dee28a305d79eded9069db80ff4348889a5f639c16277d7c127a5f1bc7503ed0d464b8b7709fb1bd24a046e0577c36a59bca85e92a255543c4bb13a9800af261f1a0bf43873f23b655da358d04974e467d427c0b1c8fa90f0069a7fd3b7eab3676da75f7a8c19e89f587ce3e752b15272c52edc398269e82365bcb1bc4763a57e55dba22aa8b2de0011c69ade7898d8f76b2a912c4fc71d2d336ab2c6468a839c1bbec9fb0e49734e9c32e169fe4742d6abea498d4d626e588e17217d50c04e2a0d8e71ec6fa5aed992b21f53de161cd4e1f2b02e37afbb6f8065d4465e96a76703750c62e7a4b97760885c1970fccf7cd792c7b6134151b9fbc16a7b96a1afb98cc0fc87d8d130463e88201d191f7ad4f2b19b773f803e72734251063799d4b3fe532f8d2687d4efc1777b72000c78307fb3dd349fbab92e0d9846171605e9998daba138f2c52991e475713086d9320802db02f48a2f45c16550b86920f68f8388836e2c7ac791c87a97338e6083c7eeb4616c9870ff17c90b63f62bbb60afabf312ac5495cb0c8c5654578f3d2184f2765efbc00f1bef0b5225d47dae0e8f0d7eadd6e9805f8bc43cc6707f100429ca61590dd31ddb95da17c3e107ecbc6e0612c02cc28b2d2a146b9e00f288a459d4357fdc92360fdc8fdd9ade5841abeeb764769703ce4bcf145cbecbb66715eab2cb6d77b85af850a2bf1f29701d25be1112bbdfb2eb0f9f18f0905f595a663f8f9354bfdffc8f99bd4468e65c64ed521f4926b9841f5919bd153bf63165ff1e420a270a36577c7dd3bf8c4b8411f703e7a42c6a3cc3b9aa3428752a09da278304e7cce2c48f1ed84894ac58819acfce4285323d4c3bd2d4c03ffd2eccdc6874b62fa5db559370e43e1bee997a6272436f79e89122393f71b3dd753e0400e6feb4fc89b1abdce9796135071fff824bb4dabad05c8f573bfb94d99d96a37f3862e6df88fc9316348a8838dc4c1f45912e59fe6bfdf4636c43f2690b90d6a51e5d03b9426bfb773fbb9de751d80c2567b8e5ad57c307cc5ee719b2aa3a99c3c25ae318940e98722852667d34fa0ebb4bd396f03c3cc4c3ed5bc26fcc7ffbcc9735410d7a9e504ba936a0d5f3af8865056be531d7cd2d9c027823ec4d87209266afc453139f9dbf9e8caac6cb9733b237afff5ca5a4f9a3269562be1a5b168b8c0be0b2597f0831e4d3403916943e5c101c1d89261dc0f8656d77de4d57819a81da512cb578ffbbec0be4f80bf16c461ca721be6728d51dc60a260d29c13b75b8d75e38a3b9db9b93cf130bbe2569a3d912fef71f9749ac04687f7822cb501ceef1efb22cea3be1c1e06443bb22e089099a4da11545cde5f2ec1038a306bc1cada2ab6c9bf0bd4aed2c500702b15871db10c43291eb74f998cf55ee53805ff53c46ff878bc2c6abd49c98516320861055713db57fe928f5ff15263f6122101636c1e1a2871b2f597acb79f992bbdeb7aa55ae6206cc66d9a126d380ddfa4378ff392cba286837261d9945d0ea605771dd39b51f8c2585634674151a2141aa85f28adec257793dd530106c26d6b4d5bc4ad76790f38d209f9deda9491175080a7fbe0b3d27a3a02317262bffb555cf8bafdc02ba4c342871374c872a819fd950e15671d46fe766555e3023acddbeab633dd4b66774253682ff205276e85dd68587b2c976793d9d6719b01bfa8eb8b35094a1aa2e54d3699d7a3f208d1776d4cb3c4de2e0a9f1e0ddeb5bce037eaadb4b65100d534737f48471ed691ad484b3acf6986a48bb6249a8ca7d4f2256afa263fe8db89977f33f3a561e77635683ce915c49f5806dc82b363764771e057de92e28f896bccc0b760686b09ac8a0ab5c0de2ce0e4665853432e94380b29116a55e049331fcb9676180a52847e4982a1b3e1ef14146d612280b0400c087e716c21fff770d1ac114ea71a4b79ba9a6dfae230e7dd7869fff0b22352c1a2bba0f099e6c45d932f3d17d1cc62e2d42858182739a2da1945064d8d20104bce19ce403bded34c2705ae1a51f5df66ac49674eab35245e90cbf0c9e3b753195cb27521fcd1d539f44088905954f46ba72d5401394a07ccff9aa6730559f077f476f1783c880e9c2043fe44bb02b9b73098f669b45a49a86dde4d8cac9764c50224d4e8b7ba6d08581692b0cabc61184a3b7a2b68c7e0e342da46568f01910e8aa99f83bcf22f14a298f1fa849ca55f43c16d282180b5e0e778cb76d8327a671fc6ff61b6e4145a9b0df6737005f146990d6e0aa07f57a9d6c258f07aefb06cb55174773fda6f18511f8ebfef7e4547e70e7719f6ff4fda6078adbf72f06f53a06d4a353c3b499ffad503695a34cd16725c822e1f3334eeb9d8d639762ba1fd422e28fcca7abe3f2cf2713e4b567027fa2e6506f07267a177172b140063fd48a8dfd318c6a751e3d6ee84de548be3d49546768bff637d6594560642271c4b2fac0fad4cc860e6ee88d9c41aabc1a51a72363f637402a5b7a1679c8772d28afee4dd8a270de1c8e04856e4786ca6ed4e9438d9008baa723303e65cc3eb4484889f915ba56162a93b9075e02cc32c2ad09cc3a375588dc36c13e039cb992f42e7490f7ff88cb2a1f81ecc55b3740b08056cd806a5769b024ddc1f68106839d5de06a526bf6e2810bb4cb43afb1e6ebf85ad3d186219d7634fb1326adafac7142b5dfe7fb1220a1d3fdbc31fbeea46cfdce5878ceb254f93a00fa807d197b88d564737ed3e5f0f826a38803ce70b42024c776cc0db09370121b8fd69a5dffe3ec24b2248d8f00e1a85e50288b64d23c2f6414b09445ce008db7e1e3375bbba8896ade08d3d7db9b3e1bab8d88acb72a7648847a2b934d2898e4f38d16d9e4296bcfc53da99fb16b349f2a86f1a577e98a0d26702ecd0744ad1b1037e3b21e532bb83cff92c136b708da8f7ed8f2f46875988e9ef0cb068492c6c6c22448a04655f5d2b8c49deeba35d9903a77f28b2e1686e4e80aa5c548fc7da5b014988f7ec927e4bebb20006c96613d6acb3e1a4544987decc05afcfebaac36894fe2a2465683ac847b8581b62d6dd7892c440e2cbfed3e78f3b7c0cc2b26a65591b1d7d48dcea390c5e4b9ce2ebe9b8642c4bbfb91bf349bf0e802b77990921553f9ac8a9c994755d0150cc1486c3f495a4d370a77da0bb33293d0d2f07ec62d0030995fc1298ccfb4721fa55334dba8c5f39a9cd955cccde8fe6f9f97b1bbd51a2b015e6f39799bef99120e378528fd746f797510b754e5907355829efa5aed7c4137ec1b44a2b8671e3696742dbd6f4465ebb68e152c8264cce00b7b0d5487f8228caef87c318d65334c921429f8cd6c28579fcf9f82b761127bcfd3ce2dd712603d87e488891c251fa586868b1771f7c1b90aaf849f3040b604d83be398d0325509f817018b79d321519588059b600ae2f817075f7c45d5375c1845fdee4320089ffa4b6f0ebaee483be7a019461fa810e119f66102990a2b4c32aba91c1bd9cf8a9c490e940e6ee734601e7cf7cc1342d4f420ab04b9ed15058d7da9b946bbc94c8859a52b2b22d74384dd45f3398ff4407594afadf7f4090ec08dcd21856489be3844a3979cc65b82d55a4cf8195b892ee1b9fceda541174a8b702968f4b3d2a0d615d76f00b2fda8856af26cb39389811b2e4f418929346ec8b3a045d60b2d6481ad461fcb3a5730a6c4d7884c556ae730b8f96737a07e3b4bb470e6851c8dd95a67c060bb03209ca0af96c3f94d976d4cd66da1d3cdf3170c8475309f12bd7d6a31319c94be4b50598c78c60a46847770e85e89622620e2e8867ee0168256feb7837c2927c105a1188b80083612797177a913ebcdd50428b2ee17acd14b61b436e15917fbcd13bbb716f18299499dbaca47eb5a6f86804910041d30f54ef52ec8ce97329d3838d9fdc8280188cfaa995aa76b28aa235ab001982bd204985bcaa91d28267bd4227bd9cbc20195f6dea83264369057ed31261d7d898efb5d4dfc50f5bbf1ce4e9a8128ad566d0ce30bffdff0eb958e2aad13db47116d2e6aca6db67479f6b2916390a3201a6580f83409e2bb50d420bef59367e812f607b69d54390113df767da845860972a380e3d29b168d98b6a1debccd2ec84b5dc40ed8cd0d096cd90ed87b5362ba480106630f0ef69fe52dd58a46f698ce369369a66aa97c7c2ccb55b15cf23f1f7b30b22bb8e6a3b26dd465a3d521b502a11a91b91d3bead62a477f0c74494e7d510ea09143f1a9a29a29a24def8a1aa75df3b31bcf323aec922904247d0c9dcbbc74e72b3d218dc823e453852d4994d025aabe144a69037b6cc2ebcc0791732e7f2c7e99130da007a816e6084b5b0d646f0aa86f62bc98fe46f32e6474bbace973d0c87feee553672787bd1b574bdb53fec2c3d9ee513c9a3890d0c0b58442e09d20a72a954b1ea226fbb6029d27be2ecd759fd3c1af362f7ddaf156b3c83ffc8cdfcd1686ba1187e3bdc194ff5780342073caa33b595018ca2c2b4c06d2329a4233e61a8a4487769c39fa16bb23276f2e59a591a63d0e6fbe284318fa1a6b16f6586ecc2d29688d7ed8d2f0afefd6a5204813f56fff7955750b93a978a74826ad5911d606b82a444b769dc378bda88d32ecb5934075fd18bd87a06c01993ed360f9ea2e3e8f408d6d4b0a82b08a2efc79b7419335302aae8b5f3cbb3c56c830f6d010112c9dcf62bba339f5348e9b17dbf04b07355d621d91ba5f533484c657ed75168147043fad67ed1142e668796c249ec99c04a013c07e6dba27fa29ad15828664ad4e375365716b5ac7a76c57ab4faae7e7bf1d50167b782fc60cf29f9ff0650fdf3e7d1e3fcc7e8da25f02c765340235818697469235a64e49b89c0b20dc78b1c7d469354cac2c7e8236b02ea02ab761eecc75a4cfeb78890c08ef1f27033095c7628da51f3d5b711788edef48ed95d6714e78228e9dca165abc5bab9f4cd122041ecfb69fa4bde3ad635cf2064cd6c9bb6898717974fc99f2c9bd3c4c99a452f31c103444050c25e056214745d9a861cf21c1bdacf9f3152a7721aca700e426e8d28064c82de82f1fc4646be20aa89aa67988f6f472ca80cde29a59988f860ea06ad35e31779391dfbaa413888616089b50a76bcd6b742a288c6bd3cdd63723017549ffcca84dca07327172d28ba52d80a17f817753b5d9887b6c43930fd4fcbb5bb279d3eedef0e277888cddf7a7bdab0c2dfc36dcc569d3301997d6d36ae78f52d3d071a6758aac03f17fac1cab3a7eab23678b37a81a5d320b9c6f6b688ff860da85ad3ed7fc12c41eef1fab8a8aa6d486eee6f890b15c78a615e6b078014120062c8e08808d63fdbef41fb2f8f74cab9e66678dab81bc120613e10d06e842e0c4e2d13d3934e76cb7223ac94c19df3034f907093c7648026547d01a30383cd7140e86940e43f10bc5d6cbe866efa498895ae33b668369a92b4f1df8880aa10abc9cfd048a5453e6de9b69f32138b9ca920c8a6ec5471d5655e2b86e7cc86c401ef8a05f13a36c45b53bef200d80ebb96761274b1722eaae24cc4c1cd98f6832947bcf63df24a3a73994fbb81aa6af4303ca8b04958e4a2d579c70416fe449a0451b6cf3b9c67399b799daadc75c8e306d4f0513ebb92a315139949a5db63d1f5ec16751ac95167f6e84c7f4d3c4e93a05c2a359cfb4fdbc0e71d38e785f2fdbfd46dbfcb1127699f9c5201595fda758d3759d2dc0eab3348b4e5e2a081f6ad229b34e2d3a482d777e2f2b69a93c90f74564accea3e4eb51b47cc2ae43460c6a809f16f07c520eb75c8d297f36c164d4828acb9f8b74fe264ec1ea66fc53f54ea097253ad6c972d8bb9edde26616c6c2273d38f58dda853a821349d7188adb603372398d1c29a69ef4d39e3dcc97b2b52bbbce0b3ce0d5c9862cebbffdae6de19c28e8a57145233959e496427c8ab5241417d8b1801ca6275bb6340e33fa2e5a32dfe1910e64f04f0a659e4572b907beb2736a77160bc1c3238c25c95e360b7e490508d52cff30564af81be5ccb3c7086b2a444c8089c1aeba44953696c15c92039e1e417eb1bc71d8f8371b55ffd4c41168930d1a1b0c7d85b3e1b969e4b89ce52957daa83d940549c96728d4be66439407fa2c6e229de6e4d4b8503954eefc3403ed51d283ff7a72283c212a3712f92390fb8d1bf4a8d936e85d0f73e25ffa8dde51949dd2bea7626aaa7f3463823d48368d2d4c115d7659af19ffd3baf9bccae5fe149f9a795452db1f120dd911cd7e3faf8299f58435cd1647f16a7d1811c613548483c9b23db3b35d2c9360e3a329827fa65baf7183c9b2ac7af55218f1595e5a611dda134cec8de33c90ac87420e100db203671c4cccbf9a656dab98649ceaac35462b2a2345c6725362811f61ada34aeb17d70173d3ce330684ca12e1e2875bc1ad604c7c394b4c3af748445cb758c02e7fb6006261621e08650aff09afd9cd05e410b277ec046ee71d6ad62d1a5e2fe093c01b239d36dbf793685fbaa2eed462377b56911adea533027b371fc3ac60b926f895a25c7854dee6af85468419da76ec18a5eb9ad061a864fa055939c5ba0e73255731ddeb0eb219342f972a0e59123caefe9fbfa223a566a656d887cee017cc51f11c39b296cb51126b4c90c26d9345ad41cb8c05382709b249e00a4364e84317aabe043267d00963c8c1db69332eafbddd196c4791ec165","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
