<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec982b09e5b20de31b77c238226807e6adcc0cbf4b37054ab1fc298daae8dffbb9e73f253eededc12a369f6d2efa0952ee1e1ae5b44d400fe21881ca5983b8277f2645ffa814c43404001cd867b750837364fed0ab2ed4907c8f381e7eb64ec4cf755d37d8d3fcd25095b268106c8a61f33c4ef145c9d0c7c5e8926d6308c75f35742397622b37c13585e1e040c016b8e8959f5324b14d9dbdf7189610d5b8de06857810b373b648d48335684163b7d9e3b3e7fad5817f029ae572d7afeee88651bfc08d37b3f3f2ff6ebbee633bcac487e84024c31686beda521c1599cba4a18caea7ea1e67c4d2c2f2a49ef103cee5090b9ab62fe4a6d9995f25a02c7ffae1e62c291c8bc730e664fbb155392c2614a17b82060e4037269c1c50f7673389faeab579ad7e0aa18ecb06b0f666e381163d72ab3441226c793dce13ec0d7d0bdc3a3e617bfd6dd6904100b70cfa27deb5ee1d28162cd6727998d937a7ea18fba3dba69cdf7150ff3efd76b68b7653b12ea14dfdaee889f59ffa05a106d978f445c35aad001adc7ec77a78b64bb5685332a7590049a8526c84852dd5c8a72bfb1821184caa6826927ad15431e398f2e411edeea596ae25510cdd3c1696ca97b75968e9d85f8ef880c57f954b1e842d785c28fb9138fcf3f066af303b91d3ddeba0ba64073ea275576ae2d21ac06c42b4fab7127f663a82a3b747bc0317564f096423635b62ba4102329200bffe8eaf68461646a7edd8ac21bc4279ea5c9bfb73d4ce713045615c28c691d11863112b387ff6c2b770981f94ed549afb08031978545a680ab54190623a7437b0cf379e6136006d101b6e4d0bef0c8183da9863ca88aa53de700230a21af3b1218e53d711ab94b8351606414a079f0b6acba877c971752c6fb9fbff83654d8789268a3c397ad05c0a8f721ef59eaffcac547347bd331b37428d48f9bfb672a4b300aa62c49a2d98be9f565814b31e58663a599864219ba7db69a23e61dd389c04cd86327b15cd22db8480d7d41aaa04aedbaa46289ad3e48190667c3bf22fdbfe752e0e7cf63f75e65ff74587825901baecdad0aaef5cfa607ee2696176273311baaece9b6292dc2da76ff9251938563f6151011132115ab25c76fa7cb9bedabeb46a58ab8805101c05ba5687e560cfe0f6f92f64808e3f17126c9697671bbbcb62b3fff7a050fe0bfde43c772f72b421d75e9b8fa53974c83eacb4520f6299714b8bc0d86260ac9ef5fdff7271613923fac8e07f6dfc54a6be03e1d156a7e5fc86275aa02e6004bdc8e0cc7ee525fc9ec431c7ac15c3a35cb1cb51c795a56af1cc396dc95f06b1d122a604b90d913132b9653c26b42a3543cf0ab07cdd8f488b14c445b0e3141879cfe188c38b8a2a4ae3c9bfa343757ca2a600303d65d8ca0ecff2c887edc5daf7a3d2d147cc28687d40f1a727d57c93d5d55d0cf79f6551ac81bc7a96eb37a1394e1193329680b4ab6cfc245625647f8efe81c3df2602778b3905fe475847310115eeaf4cc6488c6a0ce2d6fbd191e3762b000e90f0befd741482408fc854fcfd7cfd0d8199db13900c1976c770e89bf2ca408759388fcf9a1cbbd422e010ad16dbec412b0245befa180a18930ccbe09467709ce890875a1aee0b182b93980f4858ffa4971b8a397da0c0b53e7b5fe15e7c415fb134192a704fcae315dc97dc76ad2e3d2ab6002cc8b0f357afa1c36562b5de6e18a4a0ae1d681a4afcbe589946f295779f3124a5986461daa92c642b828a9d5e5898154176d2426053c76d67099257efbc28d963c67f40fc22f513fa55ff36760ea40fd8aadaaa379d2dbacd25bd3219891a7cdc8284a8b6b3690f8c5f669a37b066f05e6c4a5a81a363b5bebb7683d58c86f03d94806a23320e589cebc39604af8f76403b0bc44f0c8e89b53c9f2cb616c5c602ab6b5e692a8b7d7c1c2be039249c620c928eec0d59dd79eb85043049e69fed35a20c98de705fe3a6d7d8a959e7f7b7365bf2d068a0cafbe117e59e18f95c30010b05e49ed9e63781d95ea93fa853de2cb5a0e0085736d766190e41bfb069a62bf949e2222efa0838e425302e831e8d019af499c6cab526c7119725c41ed52c5737b0d48cc0f58711e5403673462c2c2f82d10079ce856f8dc8533b1d55123381354afc49e727835c1c9c95699c6d42dbfe93d9124878dda5a46f71072ec3b66229b15e974673a4ed667d91825df502239444fb1c5c6a83a1528be0241e953778477774a134b393d036736a861f8de8bbd132d491dc21cab6cd29ce73a1c76ff3d02d6e9ffea87c177af13cba29195c2c44d83de09c3415a3355af23d57304b1950f5a06bd2111c7a92503e0c7ef996ee842a432a70887ddf4ae2ffadb3af2c6a12c63b192eb9b97cb21025e999c41883d7e2db94874008a2dfe741f1c0db5aec43e6ad048434519239ef2e1389bcdafb568187e6a57cb78fa3e71435d8725d4d32a41a8e9927343e7853735933b765572735b3c5d792a3317d625d89cf7f6ec6e9f98e5427cac39e2169230d87b555925158eb45b8c72c594365a99761115c346c33d109d07c6296637aee90f34ce3976e6b7b14eac43f10311faf006d684690ecc3ef490d3479f10e86e9136e277d6ffd13e0aebad4adf974a18bb8e0a873313a5bce1a0c2f56c9a645bd5898adc02b8fc9ae73d2d38a0e4a56d7a41fbc73ec6e8834cf1574b34b9da325d664a5df535e971c0d3d825146af738636fdfe01d3992043c296c41b45da79d3d228bfd98741524158ac288ecdc49d2ddeed36646a6c713f3e804644aeb57603abe1c62b6adc3ca1923de46410c3bb683030df76d2f0b9c14c4953b08075458796927befb287f6a3f390bfb8d191caf05a311fa42d703982cd4d37963f557aaed8466df5c3a0d7c3c698371f868e3742b2f676203466e1964d2e44bc8a6948902db4525a7d52f980b783dc0d7a42667c023162ca9acf777ffe0934a398f0959186dc23f1e11dea1b46e9bff88373619882e8d3be94623206d877b92547a2a9eb1e48052b2e88f15274ee3c8712ddb371cb62ac98f6ac94e6122d3d8725db2f76e94659e11a26189cfb112814e49d7b1185d268e18ff25eb6fb15a785da9136af471c4a30f4fee9884b43bccd59f1ee72ab3d4fb6b8e3831f4db5545deb20fcdd675cb7429f5d232a59e657b3f2eee8e104a2edb252481a2a6a1b9ddd1a40e9f394d12bfc762cc67addceae1f321bf42c8370889d0ba1ad9d7ed123066bed21839fc6fe4e4e76399de7bfa059468a0c102b4c6b85efec9c7e464f787c766383ec626d650c55271b2fedeb977623e16bcd48e06710d19a26eaf0b3bd0ea3378421b2e4e4ac95c83d137f9664495599dba6182a0dcdae14e3bc25f67b0931f0b3e4a88bdce1c55d065463956989720ffe37c734883a146967c60861c0d273f016189b86b2b4f657efa39784d60ad0f8e2c8b42c06f90965ae3091d61618d33139dc837be3cd77c47632ad016454c8f08c2e45b17fc1b64c3b7d19b7d9adc049b68a0b73d59fc0fd7a2234be508b1d2bfb1cf251a6b1037e7ec2f43dd8b8da0b9f0d43ed59f432a3948e0cd6683bdaef19422895e2577f6e987241683896980bf7180245d7c666671d6c1b121781329dbb19ed9a4822132ced5141963c7dfde1c67f8f30a97db0d66f7e9aea73aa9b831ada6030f5c8a707db1f9e8739b78c22753e1c43d4726c14ee2f5ac860b45c1f254464427d14518bf813212e4bce1fa5c6ba32151e21fd06faa2f91d5ce1c43f5389123506291bbe2d2e3cfeb944f0b0a512d49b87e5888397aa3ec5aa5a78e7164e431e7f747a62047d4a92391b3d1e1236c77ef97112eed90e4f1d989614ecaa1184f02aeb8fb11865cef8d906dc6bea0bae7e5be9d15d677fc38345cc44568ef1f43eaf13ef2f0b4eea99db2e30df505e3e5797b1cd138bf66dc534ba76670fd85042ca2e16c060ab99d52cbc80c59467b341cdebd43c2a7e887639681498e6a1ab57bd991df60394ed1b5d1c3426df8686e6c9ea2990934751011d21bf337a1d61b6f6136454fd450e89216c2dc87f2dc97a257b92d7526980066e1e5b0bf02354eb6a133650c0eb2fdac4942b98dac55693e4203604277cd7ec7ae5bfb91a559d6f09be2a82b929d4e03c6b570ec8cb02956a1c7e8d26ac619b1d8c01003ecc5587d300a77c8983c33f0a2e9df92536facfa293097535556ef9657241a15bc6227e3577850839e8d73f135976956f8d9da7bb5464e7fc795038d3d0ceb61b71e19476fddd7995ae7a075da62126ba0cf89a427a45b0c26b323b37eac7c9cad878fb856aef08ded4df0e8fd1b9813e3ec320f6fe2bf4509a778f477fec3aff16a4724901898718b325b3760da12b1848ca2135c4da7125cc7c659531ddabe3651edb69b1468fdc6eef03a8f9b872b9cda1efc6ed883f941649b6c918702bf344f26ed25e7c2a8c2f7a71f3c5f6d4062c55e287d483ea9b622c46bcbb4b4d30981234c17c75d769021239518c3305bb917f4db5f697648a6e85039fe6a76c998bb0d4a2c34d46306003e24896d2367b4a1972ecea91e800efcc1e14df4d22b7bbb2a8748c28be572b4291a61100fd7548a0482c9c6069e7cd95f5d5f6fd9fff8b8591f0a1ec79564e007e8d98be666280cdb36973777c0146449fd68e1c1328102c052832fc4086a1d0fea561e064b41dc1e8922909fa36c11031843e41d0ae2e64eda0e54b231580d08b8c19420d3cca6f6db5dca997b35f75e233635774548e3d8a7496a45f59b39fe65dcf7273043dc3736cf75aa8272e820701e6c186b94cca8d1425af3764f58d8af5fbbb53eea8588c004bd21dd229cf63bbc559fcd5f7d4001467665501fbab927eda3fec413d5773d9445053987c1a17db0d5e2a57026ed3cd094eb96432cb4fc2a874b0d18bd71be97af144b649624a84e87594f178d8cca9d5aab6fffd843a0ce22f533de1dc85875edddf920194d853c7b3f8c138fd8e438e239cfbc3e5bd060e197244078450a48ab026c2d732f1fd4654183eff5bcc978c3dc6edc2edc90163fce0d56bab30fb163eff689c069ea99aa264041fb0b11e4effdf884851fad516cf4bab5460e2575e96fdfc82e3a498e5231919a05fc77e54d9f9bea576344a2601a0788b3f51d5b2d6d2161ea2494eb09f2d04c44ba4968802cac4a74dab68a6751653a534bf29e0ec447a356d6d1557d477a8dd44bcbb31b65cb7b0db5398b109b02bd9648026ca7f5e02700b8188c78688fec4a55c5004cc42be8ece66104c8066cee121f3ccaff6636366db496bd84f4c79f3304d7e21aed2f62329ad27757f4c55e532925e938d483234482408eb02211c7224a76a2939068df746ebfbdb65b8310f8aca67b742735893f075afe2be601d19fdb476ffb753b6afa864560fc1b5812f46feda3c3abef568ab1b1f3e83d7578deecacb9cb041420da1444ce110cf76b61f850f62e8d6b16697061dacbfe7cabe85cc3a73ca01b6ac8fa5f5daff4f36cdefd3a9dc304b0ce6ef2a0805470af7a4ef3b10ff50449f393ec1d22780ca5a6fc2925c4b263c3db033ee6aa1d77ad562b3c3252f74e4b1be20db3f079e15db04fcf22a4c000e2f38d7821421d24ac24947f2b0dc55914ba94d16fdb257019cf74b5bb6078ec5930bdd5a6712b9630b2f0d3eb6e10fde02bc1826df387b287f05be33b5d8439c59ee334bc245148f1aab1e0f3ae85fe40ef6d264be050a4a9996495f4246e64f6c1b85e79aee0ae5781cbbd120f7cf83fd4a65999833a9f1480c98178b8caea7ff81ccc43a4928f4e705cc79d3c4623b7d29d165407d7ab68f9d15a34480a8454f9885e794e4c23f0729d956a164a404a243cb61d76ec1c63aaff8c042359d9a50315c4b570fb1b0ef28418a94ecbd419bd3f35be2eddcc6f309e7e8b70a3abc991c1e6218121d86b0e8b2aaed8492084fcb8616bd9ef98661dfef9c9eddeff7cae7abdfeb4e053007ebf609f1566f3b2b39bf087ec09ce57f616a6e75d9bdde12640998143b28cdbce66a79f44fb4566c635574417c5df83a2bc0b20d98e6971e98841699ec8e7d9221430348d26357bd8558d520ce90e094ed96a94c937744ff36fdcdcbd001164a2cedb2246a8341d25e508d38149e2799a754b3aaa31c9e1e7faaa6b7a1f1e6557d6355deaeb0840ae6b378816f4ee372a924d331a509835281137070d760f5d3a299ca322e06dd72d1d453998a625c7a7a84ef52b644b05300f5ddfc9bcc3ef465573748b4c91ea0d530893d879cf2d585e0588f9ffc0bfd2ab7174adeedcd0f715c6f75fa49bdb673dac4a66c812975b13e29f70f20b4a3a146bb584571243456d0be58716f6ee53c6a084fb394701808feb2450bccd6d87d0bd592713995670e8ad7ab7c84bac2447ee1859924ffd16d5bda7b797a559062778ca15cf0881cbafc28e8da625aeb931d4c1438124bf5c8551466d647822e59582154a79e53a4139618bb55dcaed8065b24a68bab925db85dd047d9a505aed0d091279774107fbb2e854957a4ddd11e7637fcb54d3d403855cf1d07109fde97458b595b8ffc1a2a6aded37208613fcdf8afdccfb57af513e32be3fabf926a05ec7f174e5d1b1930617a11d31a401e9a44fe854797c2bd9eb3214acfdae87015b17785e5d85981ba40ae8d6caed78b07d4e7d2d60c10f0f70b3998cfae1c319f54fc3abe251bc287726c01d4e83b1402b2ee807f0579f2fd6d0a7eb81ebd250aaf78c7e34b43e2f7922637546a0917a90a86774f8430d3268e01507ddf9b4cef2d25b16e5b811633cc1aacc78029e8410b3482fcccf46a90afafb46af43ac660561cede38347ba65dd82b14d58ab312b65674102692dd3a0d8fd046f1dc453bd474a7351b003c40dd0eb1ce23a487f7f01e1f6ffedb229a0b8f0048f4a986703d89585620d54249908331fe816a39cc0e919165f501afc468c0a96dff0d191e11d4663c182eceddb60c83d6cce7f6197bc713d10b8c59d218c3fc9e951a353e60a16dd5893a7f70886f0cdc2b524a7fd2ac516b15992f8f4c951c302c92fef4bbe3c7e499ac4660c441ae71d2d2b7e41d1492d6c84eaab8e8435c8c90f7cd045d762890ac36442dc1689c6fc14e993ec89d3026257fc74e34b62b5e27b5410d154365d47a255bf970f97577cd59251b0436ef8d8705ba92943b428d4a4c914c38e0f0565bdac0b3936d5ef22fe22f516c590120beb4ba69dba614aebf2ae1a5d2fe1c17ef46157b3e75a49fca77cfa3c355cc0f2d060cb1af193a43aacae520b7404f469935f24bd254924ef602b757fb816d0e6d9d13c8087e940ea0b9361049f61b7e7bda1cac09a22a86b0a444f917598a84b0724759cef10a9a319d84d62d3eae57abfc4cc4c4cd91cc4c87fe72d42440e8ae14b6b7ae9040dc15a61bf30c0e1be340c1baaf0b99e93ff9d9401f29644d4a35e253d320d80ab2f7629fb11b8dfebdd1a70a1e09fd896aad521bcd178d8639f12f1da8f7899076d697409d7086ff969d034eea6c06835b9b87b6e7db0d29eddd9eb3b2d24921d932a886a00ca231d7f8422432a23cf43ee2ef75704f37727a3c3ab109c903e0b53cfe1579118d0ae4dd6b015cfcc9a6f30b4c18068beb466506c8a19e37bb3a17cf3ab1bccf0cacbe8660149ed6735a649efd8c2d66f87136c9cc1f8d4ec92bb4d9bd597cd2c8d26f673ad29d492951518a1cc50f795bfe345a999ef139a5499e0d7bc221dbc0459a879b1a756774258bd4ca1ad544dc1a8d365fa723c4b7824ec64e3c6acacaef52c3a204bd4557039a041dcf07fa97930480d080f32168bfe297383b7eb65af8068284ce9f001f21e49431d51f07321de83d8ce8f8f5f52479048120257b532406c1cf97f5488b2131ac57b5188425837904468b51335db348a6f15ea7283ad7ded984695bf52d4859d1ca1796ded7d7c1f0ea7b0d81a66f16e15fc23526e0e48e30de23f041e574dc129827790d0f6e025e9b383636485c9fe4866c0667d8a25e3f655e35adc0e241c926e11c41e5c13c8f46cd8c8e67193ecb734c96ea7d8568577a857393052e288482036e24083a7a162f176e8bf82e8f06bb5faaf17f3268346d38b88f37e00e449e2de2ba1ac8f26e926d83b8c3f17ff863d9d9a230ac072bfa2607d6fb462ebb0fa68d1d7d634721ccf14c97783003159afbd1c0357198f49bdd385304df5f06886f07928df6a3dc431de28b7598cd3b67ebe7df532ed66aa3a3edab1464cc451f3526185290067bddca29979adc8e856effae917329966228695d84623ab488a813a3aaf80dc63a48ebeff36cdbc797589d7804b0f067c993d8e88bb8a28a788a74675b9a46eadb7b4c5766131e0642340882b88f68c3d1d36ebad19306b76e845c85b0a6c94162accfdc0cdf3706c64bf06490468aeae80206df57db830bcbf98ae701d04f77bda22e6e4039a12ddf9f7d1605e68db7c2b4f1ee5ae7a800b94f23e8e21b97b57be70e0fff44504c487ee9876ed156c20062735b97d4e3ecd69fabc0bb1e09adc170be4cba088882c646e60f793aa6a23d82d1bb1aa901cf09c8a571c210578b03cf782e6e6bd2cfe1e33bdc4322effef50fb84a0bc57a7a1ca55a267641f0d670d07cf8c2abcf4e7492d668e4a365f4f7eeb6f722b53cf24d14dacd1546e63440dc61ba63706395f48f002f55484fd1892ca563012cc2627b05902cd8a96fb9f7de6cc50577973d7f7a434d1454e65a75163777468547f2024c352405e768c9c86f25c34c7c1eea87f4d45af9312e589ff45012dd45f939ace8505c79d777d7936209973370006e7b23651a4de09caa2e9c1c32a6ae23ae9389f96b5b514debd6ea5274c0fea24996b7d0f40ffe3840c1d51fd33bd8ed4489b20dc23991da36fe63cf7aedf84c562d36bf1c6486ad17959165be0960c0897baae8c51f4ef9ef1f076ae4d1f5df63e457a45f8fa1dc01b9b103ada7cf109cf6943edb06b2038327f177c0d52d1ab807076c4c42619fbc93b7627382674bf50adaf7451d88b51d0456814d459b3a5bd3ce6625610322250ea7fc322b28d19966baeb05ebe627a7dd090c4d8672312d2e18903820864b02e6432171ba40a9016a8d1cc757893db88889b1c9872be2e7a629dfd287cacbaa06aae18cea1b0e55696ea305ebdd8d5051b8b6794526c44691f746ff1a2887bb9edf9df883243254b51e6ef2907803d8b8267c562d407e0a331eef1cb0ab441f1e70f287c7354db3096f6dd8739c7298b70e55624b6b800f5a66722dad9213c20e35c4702303338f3a5c45e59ad50acf5ed114a775086d29e11843baaef07bad1879946a1a7ef3ae7b36e35230ea827788379e65b6f20b117edbbf53f4b38b20eb01fe3e09253fe41f86bce820a59bd035f04a527901808f2a508edeb923509a86e35763ca4a38db388d045b479b71a444df3dd598b5bbbf1d1518be038f98e6349fad9b940df92c17fbefac472da150e051516d8e8f3847d0b2dd7f98029a5d1e7cef011eeb73058de4ebacfabec98b8dd56f04f3ea7cf38d95571ddbc9a2eee84d730e0149baa4ac14f12b7f7242a9adc3dd4c80428b708422c44b817095a1401781c71a25ceae3422c3a3f93f0cd5303d2d4779dc9911b6e3692a3131808d45650cb01036b9831ae7b3ee787af6b71ec7db046f95d0359b73c95601e5ba88b8a83b09f2915224243732a8c662e57b2fe6013a680e82833aa986d012bd3f4a01fcdf7b843ce71eaded6c353332dbcf0e03cb1433b50d0d8bd34f5db6a607dbdb6af5e45b51ebff155fb3572406102383e013d7789938e660e31dcb2df2b6b3d0b7828c94207f78a1904a160846f6624b799eaf505412ea31ecc06de4d372ec59350de83a63dd4d008e34fcb8d0f81b84037eafb4276fa2b6209f6f320878534cb0e1c9ab5dcab3e1bbfaa10bcc63d384830572a6e165f8845e0457d4ba4d5eab2a3819f4fa04402222cfb5d94f7066c9eefe61c3f49e8d6e0c4fcdb5f84aab3361c67edd250b219902c2aaa44e0771a5b8f2d4b022021c2344ce780f13dd996530ebb70da2816af55085c1fcc3c638f8408719300ed5e4a2b8c6c5a88e753f877a1248e7459f3fad3e696f779486e5bf2fc2646274796e156e66016e92ee44c20cd0c43912cba3abab80ceef5402c136c05b9a25c4ec8d6a3724d2a3429bcc4c96205ad03176fc7a14d76916acfeea0d5ed204390aec13565ad91f227d7816b2adfb32ec690587d1ef57f53c1c8875f02031b2a624d2cc2af4be255a5373abb157cd1ff05919a0872273149852a34d36c5081fb18211d4968c7516853c42fc9d13c99dc5aec3f95bddb64bc54ad2c18534a3cb21a84f214e3540a8e2df07ebf02603b7e6fc4ec030bc088fd3bf7d563ca82d5bbde82aa26d98bfeb1f29873fa1834f3a6d70a3e5ebf4d18c47cf6118b18f7733335da762fe6ccc1696122c25646e4e666012bc4b4c60e2cf3a802b38515d2cd2c4284f2132f17f7b19863fd7b1d2eeecbb17ce3c8fd8ae5ed954f02a9bb0527d9b7925c93edd6361ca0fb2c1d2fe371de394c0c605b888716a7bad96592b6cc10af18cb9ed9453e8725b6189fa33e6836d9e59ad3559b21652b4041e4cbed3508b0f14d2f49517c27988dc36b47db0833f3ddaf0a4498fef3230674f4b7fc4a192c0e0e5fd7063a350cbf8855cfdb41155f1461019f45b58d61bb8cc1e51fdb17f50b5ea444cf98d260bd75819fcad391c556489ef03dd72fd337fe07ad5a119a652bbca6cc38711da64b5cd2c397f3838595925eb87d90bfd6dec969594110878ba3509d92b8bb5cc26350207e5b997800f3cad311a8a957d5e9466e8d764933bcaaea8e419741075e510367a610659d4c85400a8661e61e04eef1421f7525bff11fd0a2806c4da3b0f331c2884737f36d23cca362b3588c99fcade3b83fc51be2062c41f4ece1b1a9d8f72615a7de5575990ae0c70558358c821895b2d12a45e344d751891b1c5f7182c5cb2b0daa41026e1eca1722f8266547f7d0e1f16e2b5e1ea269ec8105edf02ba460e0c73240f3e3816393daaedffe133d5397fc274acc4d5cb4066588658e6b54737b90817b292ea3335218524b3b1a540e3be29e5aefb5f3a640bbe8ece9bb39e0813fa8c204d64fdd84645af1f36cc7e5dcdc720a8b7955fe107ab26b12737e005c8a0963b2b3b300f230fd4c0afce5887d0bcd74204812862f2fba5ebd9797a4b791eae2fc8691169ff2e5b2025b6424171cb1475109b76d46b2a32f5704c94117f34210b35efa8dab6adc0995d7f431e67c328a029dbbd24e591a1d18563b533885f251bb7880db1372f0ded98f411514bde0cfc045636d99af755ce9a561c0a4b82aaad4d37c096796c8fba8048f8c29e30141576493d05d33e5ee61a074e2507e3e2f70998162440305154d7e2ef0d52c02ab75efb8d3de8c2ccc919d39c7b5885b0677f089104ddf931a523d8aa9082731d141eb21cb1d77113e0e80e3f966e2716c29fb0a74a7d073f1a3f5c8ab5f7337c6522d3c6420bf94cd1b0176dd5e5f60f791a5766fd02b9139c954c5809a5e30f4ce911596dad421a57744fcda51a4ac8e60027bc09bf17d7890795942f0711f9ab659cd2878c6e5ae978a3f9b0bae02fb6924b5f57006beb9ab294ec4f520799e80bba5770065403e4458f632021b18e5d2398a6203a36ac7212029731649bf929027c1430e27a3eb33d18983a92318ad3dae9cf93f008954975947a22df7c19a4998b4dda01736a2123deda0b198ec46a7db95b3c9141254d040d2c96d348e3189f34c02f1bdb4e6bac0a6e4244430113a981d455c4c33bfe216ea3280bfb4e7e19c4bc051fa13698a3189871c01387abc8a7e2b0a2d46b6b3749dea4b94c549a291eccfd5bd736afcc383fc51dfe6c092c66957bff39c5450a5161a5e7daeb1a165b7b3c74498cfb1d8a9caf36f1d20250b7c82c7f0047a5204006f8cde3b64f9ed042ef94169a52043df50dec00b142cbff0dd59f6021004393fd40efbfde63348c3719ad27b4edba4cf8ffd3169ee903513df3c93863d8f7eaea962948fa8e85170b1de02ecca57695a79570253cc15abf0923fa9c339a13876bcebb146baa576c80873857462851efdd61b3c4f7ab0575c823cd784458ba51c36c0143ffbf80ce59403b9c4e9f2ffa7c1940b61811c8941cfde8e15a0e206a350480b6de6bb61144b35281f7d288ed829d1ffddbe75af522b23f5b92032dae1b72d84154c7a2c06953ee648a6276e224e9450bac18167034e93c6f8ab1534e5a4b1beb43ee477241cd472ebf73cb0eb78216161f2357d37637440353e771331d66d6ede929039c81deb48bf3d98621cb6f10e25084b65633dabb187b17151cfe304c66f0ff4b7138449e023a977d1b33964d4a53e7988cb324316ba2a2d163d4a5b056213feafb586ed28ee66978dad8a689b8642f7b02f3d4820ef202543a17a33347eccd7a3d92b01ac530385893a5aec6ec95772988d72d50708cbf72e1de883eb2b2df6c27d3124578e36c863bb3c06eebd53ceecce4343c77e3bc07d98a272ce6428fd9f9a20364c0fe613c78286bfaf4a2ff241df67f7b988ad4edb9bc99010a16d378d306279c19377ef38542918d6a5fcd8eb04f2c6464f30615341188d69941a7cf4c18379e082eade6912d3f6cb00479ac2fb204d161221ca2a7503b2b8bdd7d7662befcaa3ba3855b4ff76bdf5917db24098923003b1c7b47d3ddc36eeb7232732e854d612526e7de8447c75a2581ff54b8626c73772e7bb0949be9e24eaa9b2a2676ce73e5c62a02dca731e5259bbaf139e016f4e1b457ca08fe723907dcabbaf6e6759011c9625ed1b4df2f602025869d0238e07c11b6d53a38680734d423b28dae5de6c033ee74bcfdf1e0988fa7d156ac6f49ddb41d4ad643c30f4e423ae3861d81da7d87d5e8f27b0fc012baa590a2c69be52c90c810ede016d19297899f495402f0b366118ae349a6ab8d15269c6eb271f93685fbeb8cce7341d9487131766a83aae4f932e4141ca343d4ae576e6d8ba8f74f74750dd7b8f8c6fd2d6aa60b73794c29dd1434183e6785db1301448371230aa3cd183496793f176ea5757d712c5cf566e70a6be0c8deec27d9ba9704835ba3ac302f08ff3a8140370951ada71e1792b3410e58a1e15e2eb517935b39297883cc35f89a04168902c7e3842edfef8c65b2ac32d5886e567174178ac8caa4dfe63e257b760aa11c374d0a520091cfeea33f9ee7a9f0140a41dc90fc8e580c4d92e82c952af5cc5f3950bf8329d13f8085b4a71d48166fcb906d24648223e2194276a088e774051cd2ead28057138af1744daa429fc45b536cd59d68a6b3687454226eb82cb6ac1bb372db70d014a70953be3c92c47aa167ed7cfff70799786aff480888b5373dcbb05f0603ced69ecc6d007feffdc944cc5db9c34552f35733f014bfb1031c62956a2577755d53170fe84c33f38e0c6c9e6a618c22c14be649d14326c378e775350136329c5c2ff6cae32b5a09ad76f72e73ce7dc0cb5ee33c4c49946d19207e3d47f9f0183e881e7e50ef4bdd2e9730d91770c4857e6aba355340038be66ccc1f1311342c9d340ee231ded006602da78673c5ae0f374ffac0dc8e959d83469e5be4b9d2304a0ad0205204d7c1b3d570f61946ee3a73fe2232ae06008379c80b5e2ac6aeef494ebfe00d99148871c1bcb782ac6131e7039b2369245a7633fab73902b643dde2a64a04a014bace5c5dbeffc634562b09687a8053497656dfe68db7b2a2c956eaedfafcb43efe5630edc7a1ccd1ab6075337dae8fab7022cf77db80d6c8f2facb8e36b8d8d412efc0e4be2971c002849db3811854c9897d4406283564cee58f7099b080818a2179a786009771eba6158c0ec2227b790275a2af72ca7a5eab87c22d9b6a3a58e7b98479013efd2290db12108d96b38d99f017cfb3d87e8ebef87bd51a9649bfdee9ebf892eb5583ab86839b9b0807c98e184b1f99b01944dc2c8123a5926cd1bf2ffa65dd05e2cef7c63d851b24ed41144c42cff94707cf00bd432324faf539a58c5a6bce21089908b87c0106665ed518a3f1133967de28acdeadecfd9ca7280818e68fb760c72ce4069d4b7035db07457365b9c4ca2d1dc10009313d45cd50cc89e0c980059f72e3739bc4ed9293ee594e909dab5735a557d38ea93357a47db3b23bff023d9b6b9e73dd8ad46664b6cf9c6b4f8a46178fc8475bf7c87cdde3aeaa78a41bd4ffd01ffde95ac5d52d5cbfc388576a53b98ec6724c4357ba3bef613b62728ab6d27f4f6c79037e85c7c3eaa245c927eff7e5d4b3963b137a741c8bac1dab68c7f5847d37599adfb7ad3954202262819e1117f294654a0d85f4dd699940a6dfef70b49de2be8eac7f6c96ab8eb3bf02b45a395acfffe29125a0641b232aba4ec574330fe88f4720180c572424c0e8505b74db6dd40f51d2b4c649c8a568b41bc4e2b8f2f1365dd16d5c91548ca2335fc5140c9b12c48e671a6547119831a8f4ac148c96721cb82ce4c3fa476b68d66cbeef3930b65629fef76ccf5fd9ad61c0bfafd3e602e87da4d34610159e5c41101a97c557f3252824e5a2cff19d79c561dee8aa0f396fc15786ebabbb0f28a06caa7e63d7b92b3996903780398c0dff8eb01536e1f138b73fd9f4e5d171c6f4b07bd12ea8e24814acf51b34bbcf5de537841ebd1bbd268a57632edfc591395aac2bf0fa34dde1b7d0000008298ca817943f03cf3821f5fa6e98024ab7ae60357ce5a396049f2548a7d34a1e6963b6d7c183e8299397c0ec6b961cc8f9e7c02889977d495771326e4e74b39159fe9c1b5793d0f385488c799c6d17afb5530fd18eac9c350e2604012a90a7f9a7faaf0e5c4884fdab5a69ed108672ed63d5280a0228a62ed06dc63d5032001246e4427f5c48d6cdb4de101e4a885a64851b45d8d512b305f77542341ea5b36df2c5e47ac0b082674d9ec16d33a391d70ddc8f17b05baa013266d989603641120c7f82aeb20573185d6add340887f92fbd08d6b72a44a2dbb29336814e1902186dc39c840e0dd18587a2b391dd72961e6bab8d1afcadf1ec1e6bee4e8d31c86b5e130c808c6847cd158deb97575ae5c171f3aed463837dfb1b576362ec8bf7ff7d0b3630ba8018653987ac04c5d748401b066a83ec8c1f50912a810ba575094e3d985c88d8ba62962aabf3794963be8439071f4cc7ce8a9cad30e3e130b3d5362c0b5a9d144861f651eda5afd5233c1d17aa7da36c95ab1fc6ae45a0a4a350dae31f9e4c05ce3a2c5dabf9aa79415d2cecd27bb84aa1af61122a64890e19a318df82f13b43f57beb90d2e38f018862106f49b05a64cf4a7e8f3b5047ee717e0e91544684ac4c5c81f78d5f1f6a4689e9414ac7e9cfdd7101de02694d85ed4266280aad4444546b18b8ad8714e33cd42dd157e0f67c6e8d4f4fab0a7c8396f44d9c08225cfe723e800b6c9d8d332e2b9e3d890f04abfcdb6cb870e681dab972e5e7401af3eee602b0b516ab3c81ceb6cc91cccafa847aa890e43038abb479487f9961dfd9e2b5dcd28e6abbf29c485dca03f25de09a09fb1b9b403a88b17b0c49197494382d16fbb8003293e1521a8aaf6a949759a0e48c764ef98f5fdb947ba42e3d0a78e1de72637c5b001e02e6fabdf8bd7da19e563887428b385fcaaaa26cd66f865ed34b44949fa33553336d59061743d040be7cc7ac9bc9ef033b4a158f90b51e54c9cc435839b9a161bf03fa8be22a9ce151c134fedede1181e16cb5453ef1c8c93e98254addba849da4cdb69ff2f6c4789a3b341843225f89ef7397eafc6226b1e9dd1293c7d4d7e4ba36af0d11f8095e432c9a084bd0eb824f1f73b0c85eb4474b5048d18e5d45411ffb12761d678bc57456f89563b4960ea60aae7de8d12d12c4d29c3bd2cb863066158962f78e7a7e5dc1dce39d2f5bc246a5eb4408c149813324cc541b190217fd61abb146c6aa94cf72ee5b56bc3cc6d507b2bfd0829b1a5c3654fb7e826bb83f95e03d7784785ae8ab2a70f65dc86f2f9b693f0904774ee1af906ca83763f4b80924aa70283e12b7a20c4e4a34768dd6b45b9ea6b4b818262633621ab5963b7e420dbeb9c57d2fb8fcb949f6d391b17b9fa56dab5a553c70099a4febeb178325087a1f359470b6413f0f16eb0854d04e85e4ddac9ada78810988447cb442159e7366f8a1759fe98294622bf81f45e27b34c58ceea09e6d431cd298a600ad3fbf89735cabe29b427f4a58b76b093fbc5addfd883b1626440dba9854886c6067a0cfb6d398baf3ee34dd85021405238a6a42b61944f32faa6ab89c90c01131ddbfe06902a5b8f6cb689580d81308d0ef7d01f97846e7f7a8da6904f9a7847fcac4d5dc0a76b2ffc76507f1c96be0b9fef0dfb55f2e74eef117222b434ad80a86dbf2b183ca35f8fcda7a03a7c8990f0e270ae1a1d17333b125e4208f29aec1ca21c034e9ceed9e31c894a2d6fceb750bd87ede08167636f33834e7316709f2528d41f1b84749bab0fcf7fbe657787e475deec948c92fefe6f4331945fcb5ffe20c5a23462e1459e73796e427f320f62a3e12ed44736471d1c72c2ce0d1dfa3ce86876b883c4d343a84fdbe63a8d5f0b7904f6594113fafbc6d544641b731a349a250d0b49771fdd86962d7ff2e8f21e773972cab3cd654f6b650bf6aff7c52e802c20aac06580e561e4a2278450e014a73f3615162028feca19f05ddb257ae437eb0792c5e8ebdc305e1ff24a304b60b0b3c693ea9b74a82c8f238081ec1581943659f9b7ed3eb0347a84bd8ac853c0cc5cba11d6c3c38b1610f7d924aca80a49d7056bb405a48bfefbd10db66a3a31a8b6d34754a6f483533be3bf12e637edcf04bd82ad529153f2c12230f1d47ec9246ae7649919fc2c313c40d764fa434544f56c8c28e767b6dd8c8e40235c84512d0644c2adb359cd996ecf9a642432c80738f89fa3932342ecfe7222c5138b7126c5d354d9aac0a411aab51ab7de04fc0dbd740007c84391544ad79af6c41f34f1f79f12126ce3d13495f91d1e5abe40cc4a2604e76119c08b7c88412e2f0fb936088e5c7b220bfbac4c505f64d8967a5230ef72f9892c07948886e6668f93ed7d0d12bd92ea1c8d0b03836aef0c16865ce02e3f053a00e2abf95c29581c436c6f2233378f63afc0df216f0f57031a1f66842e15b4dbc1f2962661e9b03b601436140be59829b501de19a5fcb10b5fa1b90e8e7de8a52820e50bde9c593daf9fc6ff096aeca0207b5b5c2ad3f0d32fbc3dc7a654db2058a8733de84ce20b0a1060694169308ef3f68b18924573c896bc99601c7dba9b1fe3e3b82c2ca69ed119696bcc40624ec14cd9eeb7bc41216e3f451c9d4abee00e8522f80d65357e400d1024c0fe9691b747560ca8c8c1f7183260cfbe76d37c5cfe04f15ca5b0e683c0e0c755a3e6b9d166c558203139ed8566104ad6a25accd670901b014c4f2be412b9d73a1265e7ab12d6cce170f93190413d234028b6eaf4389b8193e522b9f5faded6cf29423f339174a60c4a7fc7d68a47e67edc4da5c58e1a02c990de4187f70dce3ef54f71a181a0ee8e6db9a76c5773c1274ca67daae8af8d5ffbc8c4ca1a3a9b8d2815fd65b4914253209561d3518301b28380545384782521de36da61cb5f02ed319475b15d0a1d7d9b5e9eb5d49999dae2a478cc0a24febbecb0d79c59ff9ef6043132337167acacd8630424e7dd3213c7a99ef82bb69d4634ed3bc37069d0b88599c6757825434397039043ae06108bb873849194e538db44767efb7643dfbb6e08dd434b5794a44d2129e09cac628ba5c8089015f6efa2f012f813e71dfbb176b3746a3931d13dd6dbc711671e4a1e623af3606d4a8e6029d8087ea8d1531513a37f91618ef459ab445fda676da9e81ecebf7d97a0d1368415b37faa62b668dab2ee4eefb8ce32ba8cc93b62531865383502e8e4ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
