<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66de7b6c54acaa9a9579483daa617a7aad715172dd970defc66e5f07b9a5f6047ba3e6edc653af28d728ce176867b9bd1a737a70902f16d476b9684a51e5bf9bb160c284f8672f7ed7f114a04c7b35d95a9e658b2ed88a92107f37c4804d16a9b28c9cccb4fcd9e5949794e963f447e5ad80929e842500595010e286853ea95661ffd68346078157552f32e2f1313d41ff39bc32379c4fa5ba3849d6c45049d9ca5d7ab8d3990326cdd2126e494cec9a7f8380c0ac28768d527ca6f907899fe16c1e328de55c4a3314e3b1827105da23c923c459ca6efbf42027422b6ff6f6999ce9004f64f1c8397ce3e1a4ff9e75f56ee3cbdc6b1ee22a017bd6a04a89e98ed97448ceda3d7b0d855733b70334cd528391c5c4f6f163e029862bb24ca0e6b2191b3e9e5bbbcc2ee29dd0818fb8fa6803edfc3ad48538d09c760bfa6d4ec5e9548127f4b4c5ef8aa61718fc4b8021f43f9cdb1630f98538486869b0deaf0d1adc6082acfdd374b8320988468fcef1b4bc4f65b5b4b8af07b0e4916d40b0fae6f326b7a254893673cf63762d9a9db369c5031dabd6596cdcb3a720641250db84a082752a7bc911998d08b126aac4415b0bf9479129c7c73d663a8aac53a0b784ed1969682a9213862b27bd4ce01be86e0c79f817291323bb00892029f94825c38a6768eee8c9088080f0d7e6aea78462131ce68309b03c04582f47def744349e6cabc7f40189b55f965a443972f4755e15cba4bacc4a5243b63ee120885c89696993dfada666736cd35b67f57c76d7842ec3d9f9de17dd3ecbf484703a9d75f5c967237174abb81d752337045b4d6186942def3c7d4ab60858e3812b416326ea179aa288f6c2cfbdfc63a2b918b8ba28cd922bda36ac28b0627834234d90036b69ef774d922f741cd4c77463e4e46d7d58fd52e17aaaf5c8775e665fe744d6e0772d9e4eea66a93b904330a6a2fafd17ece936f8527332c0e38ee72d24165a265f7f7f6de8baab39758c17d2fec3785f3ee8a5cb61b424e80bc06e2c60884f68ed9ee7a3ad17f23fbc59988618fc0416e17bb2aaef231112ecd120f90113c6d3cbb2acc7abcb24f1c33c13f9ece9e4faec6630d6aa6e6888b271da6d780c3539d0d5f9f32c020d9ff14d1d5a460db84ad7bfc073f1956d86b7d6d0f01cf33e13376ee8ff9630c178fd0c50afe877b39180421c43a9c50303accda8a280367355b70ef89ac0025c96cb37e53d99073aabd8bb612c5d85278fe0254cbb9d5dcea0304caff8d2395735581c72cf9ae998d8c9f3db8f75aed3823d3ed973d5c93f9d6c53a758f85109eb42127f7e2d4b8baf1e38fca8862d03c6bdb5a12e8a9b965cc90caa5ed6d822a959f3f10228303d2abb796e85bd28c3a2c068c2095f3e81b5e5997ddb808cbf7b1ed0718a8322f663f0b6da249329e0a2b132d01ef405295aa5c6f3c2c6cb193a0c8fe8760008f49c1d82e50d52c3835dce95e9d5a232a3ee52ab836215b8bfbe078079f0777bae62e6076d36bac47612862c01d587a06c1b4373a093228ab93e1bb39723f022192104f9fd557279168dd9e62a9851837c069c87afea47a77f677e24243e9b4531357528675406c73508ad6f6b426f57402213ab00c016470e61221e2c999ca332d9d7adb35f0e42afc5066ba6e42cc471d75afa61206208a086c703de41c275c74259bcb0c0cf48a4eed2665dda2d59856772fe8a9ad4470f0e4b2141f9bed938a961971cfb40e9343a4b81faf5383037e7ea79500b13b7e4e5394a80bc86c3f7cf8d410fa82884aacb3c2bd593f3f9ad703efdbff41486863d40204de5d4ba5d46c8235db31a0744799d88da96e984b91ac5ee1e45caa1d31e05fee3a2dd38caa69c753ef8a40251363fcfc9531e772736d8568521dde6d69c02a3911cad36e255685aac9eb46d1bd06a5528275914e95cdca2515e694323d81d4bb88783497387ab611cf53891dc40837463d4b3e23d13f11434116957b74d3a8ef54d98cc616cf0954f13c57f977af528b1ec7620a99d35fda4615d6f87b54e1fe0be8ff9bc2c7d1580c6d3b1e558a5ed77f23b3a320321a07029e62019280d2b00e8aa8dbc72cc519b5b1961574fc74f99a8452921c12816cf6653cd970554c46765db6288176d8b01200f57ebf1639a114b42d54c405fa105ac11c3dc3ad7bae944bbd9cb38ce0190825b0f89b6cd8760928b9616356dbe988f7c7e5ff80569fe23d8fe8c86ef36593b096d8f6cbc6757db768e29c4579acb4631872071f81e2ddf5f24cd89de498148dfa7d64e01f72d622606b0f87473e7b0dbb6a59f4c48689516d660f2e7d0b1676f749b4540960f414533b338e027e6ad49a80429298d40cd935fe567b8f37c8c256de547be4e5b286dae56e73446f94197d12eccde8cf6d1d1d05255a264bbf5ca8e276de1f7121da003b2b13d431fa4cedddde7373d8f05720ad5662034813637781f75e812d653d27a4e266072e7e7f575fc24912989d2aa5cda2dc05d6c83f9cdbecb175d6fe1dfc36023486a972dc2442202f16835686d06e0e717fd5c05caccd801d9ec7224c92fd770c5b01cd78b1208c43bea337d085fd4372b0900aaec008a9a6283b3ceb25c4bfef27df8c0f59c57090e44b11c8633f74cfae707b4d2c8c46f7acc3731936e9d8537d6321051c6db0676a0f02bd9f63e062ada84f0cfe2d1dd7f8011da7ca284b073708b972a473201b5532d623ef29d1dd03d475135a16f23b574cadb9ee0ebb15382f0efe3401752d8e85525be9be52a3837278af793fdfc6dd3febd92a3b230f1a20842b35e0d10ac1b92767ea3086f213a0375c5baa67d91fac14c9da15b63acd243421ee5f4d4fcb174e4ae1e520c86ad7b597a5c8a82c5f83c60c3b6f67d16efb8b86f1a7c464f35b2c98a24f4709b5b2c166a474d320f3d2dc4999bddb1487e42d981828964520729f9c79996afd1270463a4f39b715685b39ed23c4981494ce3215ebf8a5741709c99757f934b1f3c5f79667f1305004229fa48369c72ddb828cbc20e3a6532009c08e8454b754216495cbc9784305bea9a89e223141951056a9cb69921ecdedf080cbbe795c469b7e7201185b18312bccca2a298a26da463ee6cd0ca7919aeb2c950a3e22491c88a68ec97e8051aa176ec711cf3fd14883c2b8d0168026e66f6795063f47fc602d30e3abc88c019b83cd9207fb5bcf4c53c835979574ca7956dfd2931b3c3fdf59dae98ee79f574e4a151d6cf4a637559bffec8c2a62f65285542cabaa5d4e01c7011aeb908328c5062c01fe934f71b8f50dad6d38221e2f6e139fc75376de53f5e6d30393e68ff86f21ff9ffaab9dc6d7faab617efb8271223d53a7655040034b281fe10c3b3c72d4431532ae8449387e15cc4707aabd9621466c2b078586c96183bb27582c9bceb971687d487bb1e783e3c4c41b30254fd049d5799dec33e15df2c9483f9799170f74c77b10d4a384bb07233feec1d77d46c3bb9543e441959babbb5544745636a36bf46928a417af156aee091cbeaa10d2774684382f6738b4592bacbf1d764eb57e5d1ab60737b64b1e932c9209dd1e2a62f36e4a29b5660c76bf2f4cd38eed878d48f1482af7380f450d65c43ddb4ab745dba58291de14819e641fcb7313038c9e925206db5f2e545f4394e56624271f05ca55908b396e689797b2092b52e00595468677528b825b1d0265bee52c35cad80342f8d86c3019d0c16cd549a686e26261db7cc51f088c72d7b3f6c79ea66636a38f8f14eba921f20f104f51449d2db375ae0f946c5a7e0865fd7e6c67233aa1b57778d10bc14b5229d019a623c123ccb5a7c5f831ed08a4ec32d7953329dcf169b383781388ec95a231e352d91c82019084d9deb69e44c3382e5dfe4895d82e958c30f8672e700178b44a3eb1d39869cc1d46530334dd354a3ba9e5b33e0af3c5fde1a2824f9653e64bbfa0c8208e4dd4ce4b6e5ae44b7b786c872821670768cd2f2dc9e3bed02cabafee207e95ced678c0c9847507755e5e39d00ce7c4499242a7e747158b8e9842094d66ebad77a27ba066a76ecbe17329f323a32f9fed45694717bd50dff21def15c8ad499df6a655e269ce07fc3ba364402812fb38a533c8e6ef910f5c996f7a2f2e108226639b76f6316729a4e369e1b9696787677c87ec6deb92e39591c3aa7d9e66a227d60ef3492e68a428d3298107891076f4f6941f4dfccf1a164cef341a61929be7ba847f0a3530917260c0362a840852fcd70c982bf8c1a5acb45c39e815a2e39c3e21790461c208b7ad8ee541e6231c11be60838f5cfde18c2941041b5466e399464c0fa637b300a4a7f96197f24cbc25e5c12ed52757edbafe88b84aa62625a27468341ab4cfaf23f98ea7b863454820d7ae70aa405163b00fbd02df6f20701a87226e3f8e0410e97295e2299955040c73f18e7449a88022d8685fe2bf543c6aee5f0248d415e01afda9c9c63a6a7f83605e2d3fcc39b646602060c5d937c4bb9c118eff45206cf5619bb362d36ee6fe03485f6915acfde1fcc092720b48d105c13bf24e5df380db73286aa950c21a9b3a42fdb840f7febfa44bfc4f8ffa5639d590b3e3bb5f9577d51da9c0c447c67e54e3c891a48594af3031189fec64dfde236ea9baaa1322aed2632f0a5ec565e93a41d1abf23c7c696953f4a1078ea253df71e4e2ccf9e24553570df741fa092533a5b7080a6829c8630370e4a627c3601665cca0294fe2836a8aa33ee2cb0dcd42d4e22c94499052fa17d45d2ace3a39061a8b5c0ce3099a874d71eebc630ee2531db0c788415f7a7c6b9d3b9a3c406b66a7dbfa1fd859d48ab95d9f4b46bc1134097bbd0ab61e8719a57b8902e344b738c5e901cc26cfe994650b6ba1fd27ae66e54f22d0ee65842eb49de36bfa297b4b0cbe554da1ed5d3bd36c151f2f31825cf33a087b3cdfd9a449bf4633df5328d0f7762062a1436d88a666e87e75901f4abbdab8462b365b1d05c6bb7bf91ea5078b70cef62ab80b17b857a73fc5c2e7e1af9ca6b8ac83d23174429f27d15858e27427ee0a980d2cd52e38eff1a7ebfacab3566a39ec9b3de462f4cc741b48d59d88dd51389d47c69b2c886b6659b15ae7438fdb0de04d1c5438b1e3a21963817df221b5ea6e245089f3e4cda4a64fecc6a519a59674b3b905f43b01daba1dd1527d158fad3054c658d61eca6739499c95d85ab2ee7ee4a83a9d2ad8ccc151c52c6487341778cf96b655c9a05eca45d36efc54ce2cc8bfa2902c1ae5629a8cc59fa45cba18fd36a03abc7f93cc8a2b1b1dcb02234f8e4efacd8e64135a105bb6650c1199da6eb67a59bceff887b823cc88f49403d7a08ed70fd2287679c7c878960613841b35782bb6f46aeaea8774c140aaf612fb9b2b2869782753092bb0a36fade763c9ec21f292065b851dc7dae33c83b17a94ecd4f47a57d0132c83c2f7941a8eff9b754122b279f546f719b550646e7cfd95abf1263d2e4b4138e1259a6fa425fee85ac77a1721e8091e21d6b0fb42697eb1738875aec5037586065f38a5b05f23b2c16f932c6ee6360aa5d8f0f38b0c28032a190d59fc68218597d759bb3d79a02fab32c6e2ba1ff2705c8b94295409fd8e40714dc9c31a9925631efe7a3ca46a2d92e43de2b2bed5e94d18ea17769c26f328bfcbc4464b75e29b8c5b6859d061d49be05ffbbe7a98ecbf7eb02ef7775d583dafcf9ecd9c7ceac5f13123764b41eff4160b453e66c4087dc88778fb11621eb4d6032e9ca54e87d8895baa301e1c125967475ecc2c308f4777982d5a0d384e13d1372d3e699c196ff6de6349b8260316a2cd38056165094a74483a0b6f77dd4143916ef3141f0fc41e4c4d429c64de0938b46edfdd1c42ebff8d87842b93ab0a63940f5fa2054b8ac62a70db027ef32f98cc5baae4978e0e7c47d06ce6c07adb39a0cb935fac123e8599b692f5ecf9ef07162243f5aea64e39ff3481fb4537cd196cfe2e5aa53176a52dd25bdc22c6b25b64ce2547652848f4e0f75e90c0f5efc007ee43bac0a11b2c0cab0b4829b5d356e16b43023e81463c23fc29136a4e113ced45386d53dea33b0f8c3c5b443ef74cd57cfe67e11da679669cd333eb69d4865f8d363e2ef236e2dd09d331f64015085d6e2c39d7966dbd89af31e94f5721eea99d1e5549392abab479fb138d3b25a988fffc29025023079b0bfd601d8d373cab252947e102d94f17ac6dbadef05ce69d28a18bebc4894cd51274ab63eb07335eeb8a82803831207fbbbdc8bb2d0870de5bdf0f0fa9f7844aefc36cf39864a0791c38195c1120db8d7a62bdf1461334be44c4e90da17fbfa997fb06c9d41ad54251b5aa163d1e3535c8baa78c42fa3e42bbf51efd967d9e3db4339687eb0d063a9350133ce3eb4cafced4c043d29de8125ecaf82844b15f17766f1268763a491fbca4a2121552a65e12d265b5062f1973389abf9232859201b541975c277340aa99feed64fa196c7975b54d04af6e35dfff10c5097981617ce3ad590a56c420ac0baa400d39edf349810b77c8a417b5fb84f2213bb172adac61fa8e92fb2387a9012ba466c0bc6236704216ae95e0f2ca93493d0079f04a366b39ece5f22759f9c49669a71eec62877ed1d100cdc23b6970f19d811b1551ae852531606dd9ae990e1839aeb6634618d77263d9362fe6376cca35a70c2972ea0de26fd6289437c330367d1f7f47d739b34b3ca05083823ee4e92ec05bea066f8b4dfcca01557113d6cc17fbb28bd77639badb6d0780175e84790f1e9cdf4be71b9289ed77a56981797a858fec5bcfd3950c69caacec3f125319de830275c84ea9224b0011781c7b087d547d86110981d9b691ef5cdb75eac86b84995f3cf1b432200cdfbf6387aebcb13a671c3a32e89009437b4298057f832fe8e7f8b83de3e78e80023cb859773acd63491f31479b1ab15055c2887663206d82c182e2ff8d99f7b7aead6545565c0c047421d192e4846289e8404c42e39f508044bf53ab9713191a079ae84768c0737949e33922d5ed1c8a83b41ab7735908808103c87a3fa728b498d95e0a9be13ad69b8abd350c66f88006e024da4972a778143d9fd85399c4ef65566313b78827a3f46eb7b1ab02f5c41ec5e558a0c31d1c9674589a34d9cec3e587587bcceac1793471625ae97c1d57971aab8a935cf9a40c4a1f781c5ba6cc0e0ee4b0151834f364b1a8c9d3090f5bbcae83ce6f84a86f19a19046a6893d83049af34930e8118d92f8802c89026cc6e2ae80c91fb823b8a49b8a711a217c3f4ce7050a3b1de2f7d3fc63cef54f5ccfa5d6a62aeaad9678dfc8becb9a11fcb79995fdd046ff2d61fd93dbf77d237c26275371a4518d5641cc92396fd246885aa444aa21c5d79a28f37dcb599049ef9ef0b9fdf03fd6dca20e13078a48c75c60fb9f89355baf99c0e47df124295b815e04d63338455ed8e334e16eace50dcf3850f823397d7f2556d825365964bf25fe60831ac028bb252d29b9dc8739cc4587e280e3604aa21e2fd01f04c8b7d4e86b0f88c47760566ec9ba771c547b8f29b7a6a189e3d80ccfdcdd605cd60aa61e9f07b12df6e6b49a06f5fecb941ee8dfcba115b06b5b06bcab304af7f74e21f4096c551f36205bf83b2085a3c2b1d10148cd2b99ff4c3f929c12eb0f2f8240337d4fb7f11081568b3bba6e166dd995b7ba3348448a0059cc688ce5893eaa1fcbe2680d5747a7dd88c949e2bf8eb2d68e6e02b4b5d1a738412d58095c241af70f9c1d629e6c2eae659d9a8f2190a607c441f5ad1c77208b094cdebfc375f4818bf0c60b40fcb3b998de433881911321f69ae78c8f8e24273ee3c9ee8157dbd071b561d67941547eb500ce48f4f95414d424ba2e39fbede7b2fcefcb31a5f6e592f61e90ed6abf9970d70b4439ca425b478d510b086b6f27b9ca2cf4b58a585fb506327334baadd11b822882f9303964e37375a2843bde3b1b66bd000369f4192dbb31db5b536b7679237b0e8d0796c5b72345dcc07c1668c7cbe805dfedc52b7f4d4fb166b0b903a6864a6e4f6d7742881d9814276ab5c4899bbd9ff4766704a53e5802f0d2f208c86e6c75af062b867404105325cd0827b45832a747b0b52c38d5a9f973dff21e1341f7333bf9c17621e694f832b16518736ed0686058eb0f34d9e121f091c8ba624cddb8a6d2c47dadb117fbd72d578fa7085f0b87ad4e927da303d662631c39b49f00f420df43dc9a1a5a2410a357129ae8500df5ffc213992eee79101d3cbea842872004b588e63d324b1a706f7a2be10dc2b33afe5bb91796eda70311ac6e43b8805196907111e80b937be748a721e8d1e230107a4343dfa26107f51d9cd343250f25b1c7cf4de6bc6bb58229f8190663696be3f293f736f5bbfedce12636325cff2f23688ca453f02d0fca4665a0a4adb65653c021e695a4b77bbac5ad20a23daba91becb09ded72d70d2e8e90204d2199482537069ebfa2bc94514e307e06bb345dd2197218c171290e13538a33137442eed5c19ff1c614e70496f65207e7ca441f8b4df5b9ebba9ebffb232f777aa3fa3676073c4bfc8f359e999a72bf7dd5df62ba59115d13ce89cff4a75a9646ea992bcf906e263898e116e21865dfc21147fd8601e1ccabf6f1dd07900cc0454434874844db0e0bcf6609dcf5e497422415a2d926327d64bd426b2702488517ad7140abeb9f2610963ccfc09364de07f092f33607b42404a7491b0fac680d5aaa967ed91dad6502ea3925b186f3b607a1c33653fbba94a1b60ad8c5066fa78a5cdb48a1095454b4a6879c29b782932c23c67e736ebda3f96401c90995a0c6fecc344be29cd912153e598d3e6836df34ce210f9097214acfe1197f349c71cd841db1aff9cc3bd04594ddc3c874edfe6d1e4facbbe028db388685b8c618cbb507d03724077aa48dc81ef6faed4a4619669b344df94d0d27eab04cf9d7da70477151023c7c60703ec2ce879a4514c12f4045b5262a1aace0b90a04838740cc74ba617bc3cfd5f82bfbdbc8028369952b1196c213bf6db331aa90927b7fa63fd04645336e66bfc8cbacd8a5168c5189619a5ade55085dccf007a21deb4290a933da17a4d8a4352067245e0b638d14d9df31a6102e7e1a3f6016c749cad94cae2b64a360f46327240537276c3759b9a5350dfa3596f982e2515944480e55351cd0d73187bf655fcda09d7fbe132ddb4dd64cf6532c9978f3abe9300a005f7a663cfa500516281465e19fde630dabc46d9b771d244418b812259a9c81dc9ef4fb88a906517f14d41e022fa8e861f77c6890436d8d630a3c2556b58ca309d3c0c6907a1cb4ad8e4776a045eef777d871a2ea75ee8f4d515258d7604155a3d410ee52b107d4acdf546e6ba80d0c4289dbb32bf2f9fac62ea25d2486c68e1e4390e9f860fb0a5a8fe53e1a22b495ad2b7fef504d52be5f611cb4b20b13a5fee8a8ca14b700ec532432a92213373ec8a190804683d54d4276ee79ae63601a1d740169093d3eb4e6f4d7c958901a5a58dbc4679d720b8af79d64df011e57cd07f58de7f45d1051821bf8b3d26906e09f3c25606901ad52a4ee02b1d2885c90d5d172f3aeb791cbc761d9366ee06a66c31405598a259f511dfee28aa78e8a845438a9bd66e050356ca451e62462b28909882a1e2d5fcbdd53572fe794dd3166b4d14221ac321b547daa80ba0b04026a4d56058c0d3c48335512544c6a58e3923cdc12977cab823ba9099282a6e199b1bdd0efe0c532c6cff6a28240cbe761d679316dae4018caf12043b6a5c5bc09436f7e4b0914f3f50677f446e2e2f134df17099146c7f1fab8545c1a442406b11a5e16ff29c454e81d8c52370ad4efddd178fddf2c26222c54a7706cc78aae244e8e31870ac59f096e90608e0c7e13d352986b256f00a104d33818fb250c6f5b8a85369967dcbdbe3d4016f414fe493c5780d60b45e5a3a02217ab36541b430792105423023826054886f9b4da36312a2da95f1266a467475fc12cb2dc9149a79a157b347fd968cd06e4b774e39bb98db31c8d18df28d195d9b60b9fc8d0f175eee7dac1c0a7c0d5ddefab502bc299a97d4889ae1f9caf081b84a57cbc9fa3153ee104085b955ce5afc6ffe5203c99248aa759b68cb2199d2763783f8b0406c16ce2ad7713ae56d37477f08d322b58c95e83ae427f041bd308290f447694047d544f20982fcdcf2995d23bdbbf9949b420964fb02237d20c940ba511231d04a557b44989d9ed9bbbb9cfdabe722c8dc7eda855449de0290d66901edcde92c16389773984924b1eb7814b390ff95b7a499c6b79651de9339435f2a863e9b19ec775a15e42caa6c4aaf88c39743a13c32b6244137d78bd2d5826d165af3c3ade17db3d8e72ff6c7ae5e5724df4865e0d3b6dd3506759d88963abde4a9bdb13ceea8d3fbdef2a94a7ca79faf30fd2d0c6f4f9f4a0c2818ebe22a3385c4be977b7ba6897f57de5bd4ba1fc7df72fefa83db9a672ab5ee592f4e6dc813baf82a24531e8b8c54a8ec9c6b54b401e2ef11c37ef5c2e9e7879bd83ac855e811085fa3c1f8dcc4a4e391dd8d34832ec0d1f92ae712584fed7c1e8aa1d496a716329da4d3c2b752d53c4c214bdc6e712e8365982a0b38abe66c10ecf4f6fd2c9c44a4c61f096a67b5c528e3aa0ef52cc756d5eeeb8ff1f456b405f46ee673a1827a1c391fc16f7ccaf0bec574ef40f6079e67b46dce8fdc4cec102ed4e1156de8f28ddfd12fabb5100db4301efb399d3fdb2e9411509cc0e4e8813ace518b0b38b16f8cf614405b92cd3653fa91106fec8ddd7f8008d0b65394cece668d8921419bb80c9e1ccaea6bd6d8ccdd39fe1cdd697b3dd82151ec3016f4442e948e5907cface8af236156fee7b3b485f35ab45bf73fe3c281d8a5a059ae83f04a1d9ea72a3ec8bc0a943fda03f403396511cf18b46a09944b052bcdb3fe949892da5d133b770d2b9120444b921d2c6a29ed37165f9401d9b03569e1d7b9c907b38ed9bf9e5085a904ffc36a990800b791b03ffad552f3c79b2c61a4e267f4f8d890190dfd1af864e9e11f2f545dd813d91bed48d8e9688db11d4742eaeff264d4f2966ab6a25b855f4e2832646fefbb9653f84c1e89a40cd5d5bfdfd25c498d6abce78bd16f82dc86ae8aee23ed43f969995e806a33c1800b274944cce30546fa6446de1d03db82efb5ef90acd0d3aa38191dd0e0ffa12b831ce72c5aaf57f1d6dc2bac440adc071f0345e75bc4a79748367c98df614b39a12cbcaf0e3f803829b130406f422b5fceedbbaaf9b7d6f134280767885adba859d74a7b538b3bbf75ec1805a4215c14143db3f2c57bc5d5931867bdf757c7caf249facd73c22f4612951f3bc8da060d13f0d11f125e15c4edb4c6621cf8e948c542728f6ccf03bc61aba25edbe882459bbf43bb1a8294dad53f60e005ed83c5c562832b9b61b854c133139d67cb00e176b34d54661cc589fdf849f26c1eee7ff1c8b9956162bd0ca9bc5823b3ad383bcddf01f99e0980b86106fff5d5ca54a42f297c188fe3d37f220e4e8f295cd85cba0835cd7f741a9d2177232711ed24fa734fc17c3e9cbad3a81da65b97ff5e663dba49ec1e10d3a8fccc7c9ec5ae07503bf5fb89aaad74c8a07e8095c74f1b917cedcf2786a733fc1827ac8a557adfa61aa28a2aaecfc4993b6650e06aeba865163ed12b596f17afd6b9d06923ddd103c53da2c4756133525211129fca51349276f761806026993ec0ecb2dc865018b387a42a8f432930179eabcdd69cb2f337d729b53e919f61603beed449c7b106fb8f1f727f77da97b9a1b3b499257ce38ebf9bda77614a1363f02730604c6de53e9120f0d068dd79736ae4fe0fcfe13505d81186fda55e2e64e00f54fd061cd49a4403205a8b33e3a46a3c15c9041f158d872e4bd62d9ad09b23e7648b97f5d86def3eb25730bb5c9b76fb0914e3725b2e125379c6051a8adedcbabaafc76aefd802af628d5906afc319ab8543c0ea65924406d5bdab89164404e69301e3ddf2bad13ba79a7685d98d0f7212faddb124b6f7f6cb46b3ed04089e80bb9a4f095524272e07148f52779ba6128d0fe62e9d6fb8f0a0053b867a3456968d9647ceeea24b79733fa63a90aff973400aafcfacdc52ec06fd42e6d384f2ebef65682c2a821230474a66528ff7952a19019ae2021c1674ed280bd3a6aa7b6c7302a8aeb1a050f148fee7d0c125094952ade8d82eca0b32d2b2ecf7515bc2f9cc1236a236f742fe288fdda16445ea9d2ebb76096913bd80bc34c906ab783d0eb30ad8d9687ab4c7cc25801230a9a6a92d3b6469294ec4edcca3aee7ac96fdcfd09ef21a6b00c1eb2a04c907c90d18406209cc63fda50e22d2512c27c1835d82979e29c3208585e3182362a0fc4aee924273a85c3450b8783f25d926e4572525d63f96f93405f59b94e8dc9f00b77b779c40cd6b67150503cd597d6c00cd1dc911678e4653672c01a8a145d955f6dbd2194aa868941426dbfb96d9ce02dcf86ed719b79ac2498dfb21336d27990aa3c350c2ad11a26dcdc41bdaf8bb8a5db914526ad1a7e83ef0634c3312435ff08fccd0f15d8edd6ad011b82f75b817dc767b491fda48eb3108fb08cf8cd328114092d945acf69ca9d105673d4db8c56ee826fbedf4c808cfe47e86ec94e0d209c72752ec497c60b5462f3c778e73ddcf0ff9bfd421367eb457b3f86ede89356bf681a49b1743830dc6fc9e5d03df944bcb7a61312e90da72decdbb846c42e983842e083ff8119bff890e5147d315b5b3626e95ed43d4e208edb120bec7303e04b96f1ee756fceee2e356da1f7b3d775b8976937a6fbdf73185d1b813d34f764d2a8b1a30c421074956a95d4249e439569d295080714468395ec16a8c17aeff6a024e7eacba5797655dc00736fb6930a649871bb96ccd83bad9d3215305d0914b06451ead80d405438f53cde466ffcbc55b47f72ca4a1c74e6775fe7b93c1af975dbfbd94b29979b9bf827d34dc4c1b7607bc6c416eccc25b94d5fa395dd08dd70786c7885ba5262081b9830ec5c5af54909a4839b5f9a37af046932364e9870692991ac7eb0d01038b6cac5b8362fa5fc37160c3ec840c2ff543b4a59a6b7f9ebbff7f722c24598ef0b4730935ad1d7ea17d7c8d476f7f4edc95506562698db0ca6e3a3e6537e0887477b4af925296d5ae9fd51e99a9ac563a1a023f0d84194d60f558e5deb01aa68030509fbc9ec61ba0b0b8f5c7c0907c9959759ff752980bee38e5aeac952f22470195ba5285df09ed7500de1dccce37ea85ca407d26daf2494be36fa0bdecc8f62847185b45043695a9a9371efc210e2b99b9b117cf8bd20c366ef17915a0175062a8fbe3bda06eddfdac2ce01439bb9dd72e55bfee4ddf7cfa1ae7f695741d018eca4535a484bc6e41799995518c9498d0acf1cec049e9be8b00dac71089f7c3227eebf8f9a37e860faf45e121a4af7df177251f6cdd766651226127f59869d4c5597c29af85b5806f9557556da2c73fa75a9ac0de892a8eb45ce0250ebc36575af1e8a0f8f67f5f74cc72b67e7dfbf3fa9416d6fbe6c396814387358cbed6ff6274a54d08e2624964aec03ff8bc7bbf3e8294e0c8252488ce5e6b90611e966c6a7710192792b366ffb4517bc957cc188bfb2b87ab63f49796144eb70ec4d0dc32fc0a4fdb5ece027cf20ca61345d6052127cabf553e1d6301ff97cd6b3f88d8bc0aef5ce322ba578e58a9741d7b5f64f13404a508531c88a355d2dfb9f12bb7bfcca10fcf455d4bcd0743e3b6fa1b63d233a8de0d418c700032b6cf142e5f34ff42f186ac57f300258efbbd022803264a3fe7bcebaeca79b42b34a59068f584f4cc7e6b1b87ceb9f5334a5877e2e70c9c3dcca78e5fcaba13f2f9ddcda5edea31df811b58289556e9ff8fae10af86ac32b153883d5264a90f2056e5968db3d8cb723392b127006d08405f0c6d48d13083339802b39555ea8410cc544bf8c71d583f19ec445dbb64908a9ea9eb8be8cf32200e7ad21f81207d0556f4a5875ff407f854d74183ecb59d716e0b21cc12a622f0b89fc0244636b116ce497c9239cfbb0eea18c1b6f38e015b146e2bb94da5bd2fcaa9e850d6f7e71fa9994fffcd40af156e53481ce9a4ed8f7559b931fdf9fb37928690e3e80557a68c7598eaf52714b6babbe46b58ebef796924dea4aae0ac6cb1a5750afc71a421bf59dd43e578d2b13e71b634c785ce49dc28749b9ad8f71477e602e9e2b0c102e893394c702e19229d1ca95c411944e8e783dbc1db027df5e21c6aad6e32f2f192a99d5f3619583a5d1b9caac5415d6ccfa7d02025cc26c77359871faf8f97484cba4175dfe4f6b0001686e638769880005d58fc64dbea687ca86a5cd9d5d53f16537e2b557b3cc896d01b49e17ef731998949e8af287a845a4a168aa6302e621db010775845def8731284d265687888d6847269cb5b3820c890cc3985810e0a3ebf4846b6bc3c0c04b7330956e06296f76846fe7460ac583180d0c02134ca57d7891a6694180a01b7325d498eb771716c678fc1b58c53a432a482d0e9ff56479755b9411a23846caf880d9bb17008e108310a33f51b560764c246d337985aa7d327212778168056f4696eabff001782ff75781e1ee2a87fd002fb66f101ea55f1da61c2ffdcbc5c4f455ad710c3889b57542a12dff04dc7dcdc357fcf6ccc2a14f9b24221483648870f4b8722ef898f535277afc2b251e28077b38c181a627ea3bc5bd089a833de56f427019c75e597f4c263f157f1760facd15a109aba37101411e8aa612c0c08ae8ba55c089e1f06cdc2610c05c64ca498de12907c6d33d337be0dc1a61ce741959d57703565899866bf220358e077ad31833135f9bc9e834fa5108b39822a39e7d26b733615e135bda91fd9762c780757e236cf7254235a01958d52f27fedcf794eb594ba00b69921bb161980b12f2daed48165738af8eb33e825d705509df3af4118ba1a6f00d0d152b73b1bb419b7e69455cbeba3bbf2d3e152302ffaf9c61cb5980acf1511050eb2a6a72979d05c675a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
