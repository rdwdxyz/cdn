<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3bd7a8bb637e5754485e535b4e2be98f1513a670a4fa0290ed1e601e23d50f5209658979744b9bfaef7b8105396746452d3a26fe55c7e8d2c67118c902c459cf20512c9e3053d3635b0430d9c9eb9a497256ac91e8001b5fe48f9bad49f35d17002151a932f9a743f55829d7a4efccdf93c3376c6206d1666913867b44230013bfc588115a23529ef55bd760ec7ab1c999471d6978cc410604e056a2d84767b2a6d41678e4c7169e1395bce8089151a3aaa34e6dc854618682fbb3548ccb9c4c1ed2092d34c286b6b0adc9f787958ef3e40fd072f91be06657bca2456df62b3e2a65cd25bb017a1bc9fd4808d87732184eb432791ede0954e767c7801bb1b0c7c8be85b138f211a4355ea626bc1eaf9e804905ce9e3f1d33b853f16dce07aad53839fe935eaccfbfdd8144abd42b4a39df1638299824f2dd22fbc1e4b0ed8269b50f6436d377da8b21a50b7838d77558d75d502ed294e82370dce6f551443e03788cac6920a3009b3b26f51fc99be5bcbf29984f2bb8bbc326e11a0bce6fcde4092f477c84479458b28f6f8967c927d5061877110f2f2c3821687715f3221c9e1c467335703b6969d2e8e4e862d6718a8d6dc55dd22606b521fa6b1f54a9d08084cf3abfa22460eb584614447f86e269eb4cce1178ae3a20949b7bff393e4c4d9c893a6acc88b53eb18459ab97bfb891325b2dd6d866e36c13f99386a866d5e5b27476c9c76f4df3e9d88e83b0506457f53f04b912f3a6b16992fadc8095e50cd56b90dd4baf3debb676876c21f4ac60805da509640c8e861a00bda11dc60cd0732f2dcf9dce9d76f80c0cb6a322b8dfcac258da2e5a7a5b5810700b3592846771e0fc4bc9b94a17fcf12dce36640ee831b7e98bdd0b9d3f38e5e83687e61149a13a0c7fbe56d8211bda614a7772d169d17d950292dc6fbeabf0e532796ba5c3b66e9b385b394f0a1d8d1c3b5ecf6a91e3eeb66079b8b037164c86cda6bf29c019dd0b86fc2d55749e6a626e8f45225a8fd0b15e9d9a58244ca6f1142c377888a4a9968afcf48b6c970705c16e84d661bbd179fc45930393f7ff68fd3ae266c27abaf22f91faa8be132bc0e756ac491b50991664a3ff614fde15d3c12f448db435997bb43b23634dd645bf87a04953cefa266c9ceafed9cfb2d152b341d26dcbca45d7965eedcec98fd167a4528ea03ced6d1a0d897e40bec2e803e239c7c28643738f3097821fa6b20ed05dd337fc857f6a99e111474d0e8a64dafc7671c5c2cbd770fee396bf44eb9566f36ba013840112f0df9959a06f043e2f13476f1d96f94dc56af1eb32b13d43fc0a814aa5e56e43683d740e49b93a0cebe74bc19ed8d91586fdf08b61e5ab198ebb0af70c23d720c157129f5307e4c84eb365f93a5741d0c6b04fa62076d23eb3a16aa32eff2edad9558f722252094736d4fad0aa2834164e7ff133be19011a773e0d70daa851e4b9a016defbfbdd34865294f2bd3e80393fefeb01cad0f62d6b2b0941b3d1cad7484d849d42253f7952e87027e8c45ea5288b43a9d9be5adcd4b1654b7764afc48b1ddd755459b6a6153bd38bee494c35b6cb6ddfdf3a5aba7f5eb416e2e7d51442b5bf72f27062db7dc60620c848228cc39b283601d3c3a0c528b181b38df586c1d4c75a327039a49045832597b7d228908b82836cb2f2b7ae7afd4f16c1ef736ba007568fa5f4d656894e9416323579881e6d1d03be4ad1ec498ef645b6ae3a86e3c06b8179a96ef3c0d7b8da1b71fc07982f4f2744af5679c400314779daa35b6ff0e75ce26c4d3163ece041c13810194f9ec8986b61519fd06fb5414b833900f4a48723b33913422dcfea83b734421cd94f41a918039305e5d327e3d696fd662f04dff14ed673bf5faac3de05e6e2bed0daa9dbf716568ea51b6b3dde471a32a904307accec43ad87f013a997a2cf7bae4e6ec21e33ee72dd183937e8c40dc6bb918cc31c6ae7564d341bd4e40c4623b903d429faf488d76cf7983d72a68908905e990494301bad38f619f1f697036dc3fcc8b3132129169be3d60e485ff996304f1d5e277db9bc1c60389d1bef8024fa6cccede1fda02b3247293b89ad651dd4a8300caa7f506539b4a4fd70da0198b3aa27e90dcdf55215c3aa3b183d766f3b724f9490d262fa49f681aebdfd82b62485d8d85f73de77e464823a7ed9d4b7b007cfe3666654c3a69fde39bd4ff5e2fc77e1a0ae0c140376210cdc51d00db829626c56bc7e8f644390bc2ad95684bee1c71401b4f0d9653503ce9a5e2d1dfe567dc423489628e73cf05330edcaf770c88eca77c0b3ddc0e826eaa859e8cd8ada2562dde4c25419adc7325bbb6e063535aa6ff9789bc1834f655d4c412571ed18308270bc9a9a5734e868031aafb0bdf11f136b3f701c2b7159017e4ec66a4330c1b20f30b22e24cf3e9dfeee7be470d80b6b96d4142766e23c944671b38210dd2bc742084a71a4b6991a7bb084768a7b18a17b2f491b6619e9a617f493334a10e6aedf60a25d5efb7a699703aed13d4b2f39a2ea9a29f304b3fc1ff3e9dd3e76f93de114fa563650a6c8dd856fe653fc144dce17b4713f0ffc506deff0a244acef4fe095ba48f868974c02a08a9e1771861848b6020b0f68e4ee559db576fd21760dde8d6dbbf6c8336898b28569de1e490b3e7d4971d74cb65b58926d10b28f9911932111210c118dd24c2a9811d2e731907502906e69b2680c2f5b879521e95e04868e940b2502a4b72f3ece7da7f34090ff7358813fdd181489966b453c6e3214ce69b712657e3a39d0c0629d897f60932dec46c939216a0197b4739f9215faf6be97b301ce360c16baba6c27c57293d4e5374ebe82152e3186c034dcb976ac81704e85bd8bb1e0f5ea10e62f40ff7de0da1d8e90d4dad1877556afacffb16cccd1a92a93919e32141ff1dbfaeec6cfcdff21207fe008d32712223f428f722fb524e50e04ff862d1f0bf30bf5794b5942d5baa4535c2549d3bcb3eef5c311357fef6e0f5695c18e20378b858619a8128db4c5d69e258efb1e36eb64959270b139f04ac297e8a77d01c89af060fb47b41b2fe4edf79666b49a6d50477934a915a4efb5616dba078d06efda628d3326a6c65311b31cebb0516f540179a3ed7dbe2902f89e485ee76881977f9ee156d8b189412c31662fd2d4b16ba31c777c4ed6e94b425e1783bd2f757a650d26c37b04623a8491fd3a547e0b37d21ea57fb6cefdd30bbad5211743929475b6f11dab8cc9669598e206f35d841db79e1a6ba5078326eea1495aa6e0e3f9e6cc0b46c62e100ea2e82c54bd46d89263708ab6a2ea829ef2cf5ed9125c8bc16352a6db8af1138b0d5e0c54f4525a9820770966a75c55e09eba78ef18208fc56ca5bf769aba9c52a10ab8eb4d18e0e097db4e64700e46cfe2e9f87c737adb181a0d23938e4bd80661d2b12ebfb3b2c7f8c47bbd0481a464a300cb7d587d80d64bd51d2bd35cdd85d076fb057a130b8daf77d4988f8f91386cf67923e777e486b867578cb519f446d02d31aac0f0a7322f127ff92d7a9da38d5be80adb8602e9c6765e062a1127bc97f0f05506e135851a7d5315b8c23b15647c9e65b151f16fa1edcd8fbde6ca3f1a18f614989048405c46e791ef0fefe10238b3ff5aded911baeffea5205df83f39ae96bdfb970f7b90806e8b09248e975ed68bcfcccbb2485273c167b6812eca03241a86762bb50a9d7cc7e1f0f4bb11df709eb65c1be65d4863fd5899bc63e67aa3e51ffde805a3d1946903dc44e01914ef4b01383167ceedaef4d68141072394081193e7b68f4db37d5678bab48199caa2893a75f40da5ddaf1dbd2dc70d2d93414a26382ef792835b232a9a9a88836efb021d2159808f17bef015c3ad0c7542e448fb4d641ad6fae67ae44b340fcd4cdf77b2bec1b7933f2e131c2ccc959614a25f66262d6b7c9cec4d5466da620050f6041ee8efd2fee599b0b3f5b78bfc4aff134395ae7932438e9601c6572ccf5c99ddda8ae14d9b1ccb1b63b9bdc8c1930a20d6b41ee4955418ea8ff53f9907eade870789109167d7e3843765c14c75f79e2c38575aab77c61ab2d3b444510a71422005081ebf83bc354a87fd4c69aa62f1a3ff9127809a194f2b22b729f5af5de5b98e00b2effebda57a52452cc52f83d0519664677cd64a2f908cf2c125d364f6883c765650b98753cbef34e98fc8f89eac9afb08e0a51b4d39824af34d77830f5edecd35aee9db9990e4af52f1d31439aa570f859d7a4f1170b94707ad20ae8be28908f69520c88c4b868a013c6ad9d0dfe81c23a60fab5cf575ebf956ee6dc437584a111abf7e4fb259f9422bd53e57ece90cc534044cc7c2fa0675f1f79742b470c4f2ded25f56ae0d2d190c54fb0c53bcfffead0a3ec27ed8437dea65825bae5892ee1c321d048b98538c34001ccf20f531470144fe91d267da1c472e2021a9cacb0e0e85c40afc5496c8cd84fe35a84e12d6ff9796b5ffb9bc1eebacd67e6fd5c9233ed9922220bdd6410fe7b603f6725834f857fb1b79392a8d3d633e3988dae6212dfcb67158d758b4ba4d36a45365f90fa167441d99e7fc50951d9e2e875b2596b8e28d79b621c2c8f88d34bb7bddb534559ae4e1fbba1567fdfc7008f434dcf4e0b75bd18f169ff43917494e86f7e13c720ee4d771301a6c6b355791c8c48591d5213884123e93fae1679b15b6b4525f988e842ad1bfc06efc6d6dfff643e08a59bd50fdba0148f66e2dec260ca7eac47ba8b891048a7e9ea5a0e0620bcedfb035b5dc8a9cbcc876c0c4aa9de121d15551586f501b496c6420907fa5465df36cab112a1998860e91b806b9847b3caeea71b1e1ee4476918f1770d8d3b8e9598f9d667531ff887dcfa3fe24036d785a84ccb9a1f65ab851338b19504245e8404e77d2c2d617805f78a4496d183bbdf778731d3f552cb0f1e40e4dab9056fa4ca930994cd3fe0648f4f27ac2b001d247a055542d0b32f17b0422948ddba69c020e6d992a716898b2d13f45e1b248e53d28b3f7f80c5b57a5e610dcb4f299708ce4c3483fc48ca899ca5014982dd0d10ee128183bd458862a88cd274f452037366607aa0c6c70f36aa22f1c6873b6c55cfa213489757ea1226cbf270d9318c5376d42c390d308f4e0dd99b96752c28a5f5c3b5626eae705cfa9ce20230aee42129a6ffb92f82f7167608fa54a09fea8ebc107deca24954e23312b0d113e4755ea6942a289208548b3ecde96a52ccef467c0aa7baf0ddb484cebe310e6296f91f68f70ff5b037a72c8873a5df030bc33b6e23061cdbf9e924f7db34005da30a12b0eb7fe5572737f4a8af468e598de4389583c11727badaeffbe5a3f627b4259db3be0a5e9586fb07d35daef6ad65f0c2248341366b347944128ccdba93a16b7f9615728904ccf35de4f5303ebc8af6419c91acc23915152f0c2daa0e15cd0115ca77961e2ba04007d5f11600e546cfd11e3b85d2a94fd9d948ce8f88ea58e91e34706ad0f1725b8451fe1d7fdf6e5e6fdadc4252e65791a597724f60814ead28f432a09a846a06542cc635538888f5192d3fd9780cd5ff24fda17b84a8f0b99a5eded179c23f70116b8da361289aba7cec7d0364b3a52a351f244550bcc30f96c8e1a29157daa5227ae454cc1894c55dc8f3a337b7bfa18c6aa8851bb5612be7d7c477483efb90a42060b5b8187aafc02f8bf3c96d44d6fcab65ee1cf31bd94c634557b4093aa6854cd41613874fe2cc3d3a9d55f1271bf759589eb754e2b76c3ed8fa2cf0db98f9f8c29074442dd2da5c0847b2398f5825bd98d91c11e4835d2558caaacaa9a7562d62c00c643e40d4daa54cdf1d511c05702507ab37d1346c354eed3a9b8305e84a3f753a72207465b32d5913dd7854100f0f4c201e71dfa1560f16f359529a441b28855c07461ba06683918763b50e4986ca3a5e36eba9f69a9f0e0d3bceb3afb31384e5f44a1e2baaa1d1b4c5771b61fb3e13a3f6b14f884109fe338487caace6f5279ec072b418550493f453c184d1117d5c11964a85df449e7e64f9f379f895606418c4c3e42dd85a8140ac6e6614d5712464ed7bbd650f6642af9a742f7848c579be3e702c57d87d69f9db1f0ba111e1d7b63ae2ed1c216480bbabbdf104ac4fdae3c3438a2ab1546b077f5563566dd63d208a009c416599e747110c9f14c8d685233eed0f395789d5cdcd05b6b5c7a13005091364d65c71a446042db5959ef08f2a97dfc82dc5373cc93edfbffdb1ab4fd797da7a7b4b091798436d311a2e4f464c8afe42b3ede63700f30b23b061b6cd2789f2fbc52278a3ce54093e391679247dc9364811fb83491364e63b89e5954e1f450c5a342a8316c6d707ac1e358adeab16f46b85b47dad5eec89a96e8639b96d974a09316bb424df113e0e7467cd855b4e526778ee482908c15521e71d5f7799a503cfe670edd80bd3dc67592b14713547fc1f01adcbbf51557a74907154b52e417a742cff42b528e0019aa3b73fea948635bf072b2f8985b8365575400ff7a0682ba668fa6f87c03e9b0c8a932d1eb8c340ffa456fdcfe8bda8e7b9d89bb25f055c6bb6317ed8b54af1551526a3b7ba80e5899be3398628ce277fff485a47bd1bcdd7200cb23e30f679912383473caa47fd89c2d32f7fd1c972dd03d82a4399d5760354ab3029e24824f868dfeb45f5afb471c66e86dfab0c299329520b9584fe200f385679abd53ebcc0a05aecf47cabd1ed4cc07af442e4f0573a3e52ddd3e5880eacffb0af9a46fbe425c012f2f7ce4acfdcbb3a5b4887cac52c4ede01c878d79e514dee34c0f893770f545792ddf5fd651bc34381611a9efcb88ec373e93b10af3743f21cca7587dc209713c610d4c1e61af5e34b857a6ab5fb9bada0ff3facab44a12a265e7111f72fb7b5552f0ad60f5c50bc40c4b8ab177a941169dbf3621d72a2f2c10619eb1be23e3dc4ff7f0c4b06e4acf7b51eab786495b4da24c3e487d458e246bbb45d6475123a17f5a6996b3d948ded445415f8d235cb83a663f177db51f1a1e4374d2b5a73a20ef14736ab44af00852145b5f2a27262986a2f96864bb111d010048716682cec6b2ca0a330f32874ba5d06a1f7d18d365d9e1a78357d00eb08641c6a38fc22cf4f7722218ac853ac50084d9081003db173e19b0b0c90858720e7931df4a3bc31930afe838e11ae8b81d5ddd9e482008ab3bec3137234745e92713d087a20aea24ec2fef7c1713e3d320a9f53deaecef39222ba82a36ff4fd727cc39f99998fc1e2af942ff212c154a1686fbb616d3e8c59172b27a7e610e99b9f8018c1dbe9b8042ce79250271e497db341ea3b8f92c7715714f6175b6e89576f4f9e0e3fa0a6985562fbf8035c90b4bffde6b9f94afdefaa35a18d89a7a3388457a1de32eee7a7f22dd335b1cf939efc11d4bed7fd44aaf938de9f19dd576a9bf4d7c60e0fc4b59fa3fe739b4d0183bd991cca5b36f487c1901702052e29a387dc5d46c1bf3b8946b9ef857f48cd35054b70797da5f60a6855e9129019b2590e7db8c9eaf0f7c27df6ac9711d791563a4b538bf74136aa5c4d08de9c277f522f92a373014062c38c411d603c4c82c1b798e5ee45cb46ea2c82c00fc2decf93d9f2ddf894e43566afc6c55158526f1227921f4f8d46cf2c78b416f349331c8aef5a9298cf3603bb6ec8ffd7d9b9d5d6a9f62a70dca6f07e1ef145bceb28b99948546af0cdaef7dd7b327f369fd04c9d3b55014dadc542bd67b6f30a5fe96944bccf6a2e31d8be74a81d2495bd94b9468145009bc763a6e37305807dd0fb817e1ed2dfbb3c73acc0d7aafe1155b07a6bc3e63af783ed3d60e553847cb0bb8b2ae3a7f80fad9a4e3059bb012f775aea567fcbac356a07b2127e3cbe18c1a3dd4e081ee07270f095290889a1cfcf30ee890e3ade908d872f537f91660cd56acfce385135494bcdbeea4b3506a4d76c981ceb926eb9022a2665d4788dff5512800d255ce508fb154deae678f27d2bf780553b53e9a4a3457a4910d0a1143a97f436136b081870b9e1bdcce19b351aadb39954df68566ff44656f1532b66dc7ecb6853de196e5a1a3bdf9acfa799c44e242b0d2fe8db8f87a7c0c096bb123a1c94758fc754d8029a08980a19e667004da2f865c079fe3760179668f2271c9272a7f2aa0dd25e09582e4ced0f6913b8c8975307d961a029afc8741b8f49318acb2cdc18fc89441a878290c4e8a606346567bc3e4a1ccfecfd63b362849cf62da90f23fd5de06553fc8af5b4432c399468db54980058e22f699d2ad9e8d1184a7804ce0fa5236050f4f3868add47810f3470a8cbfa4ba2a8c0e9d1825d596d3e0fa1b6d39a770f6a0c6f6660ed4ba4d707d6ee00bffbcad6083796ef017097c051c6e5a5e9c0bfb9571936a9bd0bcf37d42b0bc4f674fec52caa346399f7f3b27e6f77c01d85cbdde280f9ab2c789b4427863cedfd260ec188cf7e0dd2baf4882a873381e01585295469f7d27c27a69985bacdda1cffd71686a76fb914dd282d11b96e951309d400d6760b96d4b7237156a1e9402eb2398ad550fa0f0063793b9dd1d3a938b27a961798463d847ac5e0d8c5180fb1de8ceca879dd4d252a3917e0739f8e8dc7ae011f43e097c04d582916d3bc2a3825ffca505bf81da88b76455ae2163421da31b4c382938a2b70ce3d6f304b8556a4e634f4ad05a51ca39c69cd4dfb69cfd596d69205bcb80d81c722c1fc406a8b338343776660364d8d3b22cc1118176b9f345ffd2e6d563cff9f096c34e4b2a733a6103fa0d47de2abb63b911ba0a61cf34327326a76a849519c0090247d3e6e0a45bd36a81047898c2c17dc6620f89fd10298b1865dd86534f526cb3d47c25c68756ebe809dd3ea170137539f44bfa9cfe03e17b8c1126ed4364aaf2a07b0f86d410a7299001d3e58e3e181807a2925520a44fc82033136103648e42ff8be8bb2c328664228dd674cf71c65bcc096bf44e626f331532243bb5cee4860396db11a06ffb835d0ce594511548a3eca8461ec74b9ea467c4875bf0e4ae145f3426583ccb11162097d398dd6ed11546280c50dfd5b1f15b524e72d1b9895736ccfe405bcd2a9751ac495480591693898a32f8483ca150cd7196578f2b432b7d9b42431af6781f6fc2d61a81b545c6d7971f658eadc00eda291d875b1612cf1937d4283beb4268c5ae452d10939c4d9d1418672d9b100c00cdac8a4d22f9d403450e4aefacf731936d9787be62e90c57fe7244b796cac119edc6449fb6d0d852d05ffc42c11fa745e617452234fc05084f41746076421821183254e8b1155ae65c997013970969e68873ca3f7eec6dd2c1ad321343b1147cbf6448aa908d7adb43339ec7abfa13bf5bc63af720d337c5882f51cb0c5576f5ef3e68e3fc487f35fba62b3645fa702d682708178369e66174dc43d43cd8bfbe3c25b0999a21f54b99b14b8bace155b3e5b34d48ab611ca948cef2ed933dd6c353e2123a483d0bd43eded4e8dccd26cd1c34341da88465ed4a9b48f49b8d124d8e7944224ec4fd1e8689b18ef40c2a0bffc6ab9b4a8a17fccacf2db959838a71511dc144fa986d712facf46dae66095452937af2b71decb151a1b452b13b9f3b86742a053b1cc6db87c347411f79c66524d3f660e1e9409badfc8c60b59ff190b1f810516a077cedf63661ea0d7ddc31e2a6d047f23bc0bc479e5b32e761862b15bfecfa66dd773125fe4d04ee160f6be679a1698a480208040cc7995778d5ff70436f928321e8d460726e7fe732d324135a068bef7b2687321f0ab3442e5ff3c2dc6ba3cd8a34de7a8e277c222ad00191265e9e367e2e223badead4a2f4e2e541df6377ab2f12afd55cee6a8efb87304a6032c1412808d6507d912e1f72d860e88c3f9e8926bfaf608262bb718bf4885d165815572e2992dc3e1ead4178abd8aa239bfea82161627c4ee677562e3d5a915f8ec482d1cab8dedc81167099d2aee2f844e7164879aa1e52cf40a82b43ed17ca31b0e2de395eb9052dea5e331075b2aed917b4cfc9ed0cbb0601112931fc9337fcfcc89534562f8d0505fae1529934429f0f59dd77739b21c35d7e79f83a01fcf48032155b74cd93fb5e459dac2eb9b5fb0dc614822f1da6d9ed225e4d0e8565604e2ac1b4ed425f18b43fa85e3c7c2471b4e02fc5ae2fee536385a696c42863b9146c3a36e58c8dd2aa291c2e5d87bc91e5d00171439036781a256e11b9084be90bacd12c718b72fca7d845354bb4641218389f424daaa5358709b48734f732d11d581eca448582521aa1072f05ed75b84d31c5faa198b9641dba46c5abbd187fac7d2d0fcf511857e2131286eca03a603a5deb6884575ac5ce12a0a00f885d56e5c6b2aac7ff5faf677f2ce8a744d193b45abd4f8157c196e518adb9cbb9b785c6158d9c7944a9ee703dbbe536d0fb43105f830c3d2a8186a4c07de7bcb7d407bb02cd379c46d07a7f4523af2f3ea93296fa8b537bb8b90b22f134e1994d27966bb7e7c283b57dbec7b073a08782f9ea601a7e0be7db68792e576af6c5decda38c05a75cdad616c7b151ce16a4907b857e91a0cdc86bd296e9479910d57637c933b08510f258143b6b4c8737643fd1e6f8fec73fdd5e1bdd38a0e17901d0b26e8a802603e55b8fd47cc1d92383a14c94999c3744e6e6ad497bd3e56387060120c5a82ec8f3637b71db584fdba9ad742eb308cdcf68bf7ac417ba600c1dcfdc7f407ca5fb664f66d520d9f4930f7666eef9ac4ab28a2fe1ba23b376857da082195bd0d0cc4daffaf7a5fff937c2d98a20c96227267a6e5a0b34db00e433370fd8799cf83fde9b1313b0ab46cd7fdcf6102a199d0fadc3d68887814b59488235f27def60aa116a340c84412c7e562af93726669504f60225dccf59f51be855de6601c5af1914653eb3b77a6b0b6ffbc0581052b743033a9b7ea93ed7f282a874690f0c795d2769912b6d3cb33d61e1fb0ddfda608afcc19f381673c655094cbc58a5341bf821c35f27268904dc5b3d24069994de703cd76d2e5302e3de96bcb543a1812f204de25f05ec8e1ffee9a3ce269a22b39e39024a5e91fb21e5626de7d47845db285b3c7cfe0490a46d33455000772acc52ca6d4f94afd109938d52f9cf86763c5ff1fad4c3e591b8592cc7fda32acb624388926942889337c9d3ae58769ed63c19cb3f5e9ff9b74f917b5db1a964e9894010bae43b370ca4ca89a1242e5370e48c7aa71897c3120db766ace280bf717c277bd9463acf258614c36fc8071f55bd3f86610cac1e6c3011b4fe83b33318d8aff347c237b5650505a3045d40e463450e2c602ce9853ac4bf9638b243798298d437da4160a2f8c74835be55451e885545f7f1ad4b297b850d57fc61520e9941de9ce8b0c5860f29fcd9d037cd071c3258f2f5dfb51097220a8b320b0200aec1d982dfddfd2075dfe8b1b463a36994a31df2cc2a537fa8d2b7010b5b309d5560868d521ee86ec9ec6c5f131b9caef838e947c3183c23cf93f3bb624983a506fe0773710598fb762b945398c8308df98d985db24cb26a6f9f06764c4a277c226160f6bb414860fcfc113d157ee39e9a7bc39652de8911698faacbe9ee6b05eed6c03fdd83325d67faa9377abae0a0fe4089c5f5350f64bcb7f55ce1d0b583fbbcbaecad3cad223cfefe318f62622142cb300f7f301ae1e7938ba0ff70801f39e9540960a6045ff459dde125a80a2a9d2b52bf40c0a88bca4b66aae69f30024757c97f4c53dbc41ee8a42aed7f734e51545051d27d449361a4ded2f2523e6a3d32818005432e0cc72b3e44b808981931a9bb38f15f3362bbeac547b992b8c44cef12784fd5f4cf71015cb9f9203ee66b8a2821a3dac5196873a74ff2fec37070ea6c8bb33f2cf840aa31ec97bea2158bc1cb0df465aaf07f445d7162a5611cfd27c7daa7d459f3ffbd8fdac2d40590b43af010d29442a47dcc1d3c64f035dd4555dae867ac77ac9ea408c9e351c670d84b50205a9055cc9ea0c2d9c092bacaceb685ad946a6905aa215bc591bc2ca17501d1fdda9627f147e29f3e7bb69b3c95fad3eb44e35cdf0500888dc2ccbedd824da0250ce46a2d26349344338ade770770ea24901784cfaa326c0dd7a1b9ba67fa4c5637879720c784cc49fa2eed61596881630aa3c33351f0fe7ad8a4ab09c82e681f8831a7965198644b3bcdb6aa789a69d17092a7aa77b5c6a53cb9fe105ecb579fc8eb2a723966f0b94d5f980f9a27730436dcc7d4533bd792f24d1e4cbd0f2e519b2563d054d80792b76b5aed142c5751f7a89f4e99745c2e117ad8fbf65079ba505c656bdf1b6ecab83d33b1b29eeccc98e40b29e17273a8e43f9d9b467bb6c7d3dd2d4f8c991bd51475706f038d20a570584bc93e747455ce3134375b04b17172be2d092f3659bc8c70a813de0445cec84f4e90bd2864f5433c946fc0c3255cd406513bf4946ea0c274c601c129cd60153173bf89ea6908697063efb7de232443db866a9df59fb508df939da9dc3763685e78a1aa1f9df996bd2f6ae6667b5f0fc0e39adf5e15e44e1c7d7aa64c0a2c099f60f42391325f3b64cc7ba8b1b0b3a4ab73d670fac3f334c2efd6e465a6fff2102e46aacaf2e969b19577efcd4f77fb451d11ad76555d87a1c57518bf8627eb0ababd2dc43664d840e1fb9b03eae32584547d177fd3873784c602efc071f784c2645c595d026eb28650a163cfcad9d18498a5ec3a4275bd5ccf92d340c4de15ced53fb690d6b01dccb12a81f56ae992c4ec71536938f0220f921035ad15acbbcda9c870a3e787cb8c9cac58ad3e23116c46227ef8d188ced1bfb15ce0194a9ba73ea6f108060823c6098a89bcb860ad99c304d73781d6264bab3507b3aaf2d318b374422b609f536ca3f24664f56de8650f1a130fbeca7fee5f8425b9a7fcdb61f7d51f1c8494b271e26d66c4f907c9b87ed9c310b9bcfe2d1e4d0287777f81e4b7a746634b67173402b0f682191e6a85b3a97f9c472065ac0a26b597582ddff7909e0860af9e0854b5bd7b287a030faceab23b4da03a380b4bc12984402e02061ba08b759363d61e75132a30dd0d8a9db5773f1f866c467f864fb5b0eeaa12563b0c8249636b1d7c96eed42d76f04abcb0bdcb801ce195d12d9a835561f6c77a2355406f676f368b7aa61e33dc9565b72604a01a9b7e9c0126d1b1123c9284a8e4ebbf33c1fe1ebf8597237818f13b555ab31185802d19d34b0a506624c91fa1be0a96c60e0f9f48a4e1711d2dd1b19035a9959f0a0d80b3089b86dc10ba322008494bcdad3d0191c5c4251f81de2624e1f9dabc188c14550836ceb4cd6d21029477fa0cdbc62b04ac2866aea1ab91ad1b77d04ed5c07ca566cbbb1920ef8aa72180a94ca881c6402e85cc6f8b3d9435f98363f294a0c70766eef6747bf19597a881d79190c1ab647841b5e3db6138d2156d9f4e30429ee962460e6079621ed0be42da8eab8e9a385ab97de933f8494a60e088cd941f84868289d87cdee6e8cbf577e87340946fef73c9e9bfa21b2766166b45c54273f703b429278da2ce0b04b2fce019355c041f2a752b9b4f886dd91b0adb17c25c03357fcbcecf994fc2333f01f1db44ba82747348447934ac799298fad9dfbd4b604b1de0a765cf26ddd514a4f1806b620d35a5173fdf21c27d5a58c5e9ceb2ecde88963485df7a6564734ca2981a88f69efce6194fdf82f3c5f2987639ca45da67bdd23ca66631e257b9613c22ec9ac28fa6abdad873423686bcb9cf61defcaeda58aba17d71d08b964888f39d0801418b0ba39009b5ca0888614c3ff6c3ed27e187fac3677079d7750ef9cb92307c6aa7f3f007fa3cf89e3803695c6ddde31ab2d3f24fc403783928b8e1e8bae715316c33968510a320fb0d19dd33b880cb4a92b6ef40c7fb44c3634291c162fccdbfe8f7bff00b0d0b6cbcce965a9a90cdd68a8acb4ae0709780ec631f346990bb0b41a80ac1974f45763466d144cdb432a4cbebee6d8a6db992b8fc0a43e0000048c4a52be3310cd4db801db51736a977a9ed2fcddfe06e5634e767e0fa45c5fbea76a2525c79b0a66ec2d6db0ba2c94e263698c197c00cb1e7c613bb6ec590aefd71650661d851d04331f739f327f1496037d22e0105b32e5e4805d76e60691da1196d19e5353e788382f8f718fcc71a168075dea2d3c6ee2f74a51f5766fa71d2bb305f55cfb3ba283b90f829e029c112f858fd028737a0978b4e24ac9ccc9c724b5ed1cb05b05b844a85eb8fea001bcec3e1edb802566020c2702fedc9054aaec39f08fa775a3d0a19ebddd86b87850e50905faab3df92cda619427d0ce8af43be4dd9eff87aa29a8a652c06d999027db125987f4bdc4e186b5f78289b7827fdcaa59e228e655b12aabb912efd3e40e6a7107ae389eb8d5083e3138f4ee3e197c0fccb73bfde563b1546d199cb34e43e67476cb3e598b51f5e92ae06666569dcaebe550834f42acb47e13a4dd88cfe315acd37fe756735439a8b397a7ef2da1fb918f58b6e4df3e55035e0f843cf784273bf04c9547f7dccbb387b846615f624c68d232868766773492baebff2069e121d4aa8cc96567863047be5ecc27e62335f8fc519ebc804a75dccfcb9f7c2ebf75b5c7f48b9e2b4335f6651b7bd4beac6a6b55f2ff441aa48edd1efc38369039185e787df9ad214030e39ff4950af0ab0542660d6dbf3977e24c3f0cf535e4b52b59a54a2ca5d3a18ac8e3c1b563180e75cb8c96b1dec41c6f730c3d396e1ef7e7c6e757a7de8953eb88d65cd7e79823f6d29e81062737a4e7a182fe70f9a35c15f367f7d163f049fd395157fca5c868ab3eeec0b8814bfb30dc763ac2b368f1cd2bedd97b67e28c3e0e82fc0064016eb38dabd8c7f703751d8daebcde1c1345095d0cc77becc6887adab89e1700bc82f184e0e72371874c617c2ef50ddebe30d1b17dd5c967cd3c52cc524690cf9a89a92161a36e3606add7ee9c3800f69c9a06221edfaed5c7222a19c8861f3b437af364fc709e7b6bee5754bac820c2d6d0defd4b1ad337ac4ab286de0196b1c4bdbe2eb79c613f1971a78b509ed6761f3ad947b318849aea8c2016c371800e84d733adba4be049f5e07bb34ef0ebf237d20dbfbad214a5e9e7644527a923746a0ea4123b60bf33328e3e56c498644edba3e73988a3c62905c0d0db0bcadf681055dd7c9e3f59012a7afa398741d9d6b3b7ed38eac73bb93a10cecfef8ef6a23c29743f75f77454a5db5030d0fee7c5d2f3ba4682b656b39541641977210c5c4927a01d57296172581e7978c97ac0b97c1a72d7214c4c282a9181b28d6bfde9e9a8b0165283fffe60ca046907d954f293e7679500484103626e20ff5867909f073fdf957cea14b302f63d8f0a6dfa466a61becaab9a3811dd6cd7ad0cd4e586a3006ed0464017ddf280e986dd5b4003a60cfa8528342ac80ffd763ec5f90f76cabc98fc3a115bb9d3fec2bce7d6a08f0f677cf37f155aa449ba30ac2565d5e3f439f4db12f6375e279bf93e182c800103f9c8a6154e6ba59e903a87f097d85112ec65a198dbf60d6f65b05937272c78cf468ad047c238baa93bbdd820ac898d5b6eca034734d4cc829e57848eec7105a4cadf82ad8add7b97773cd2c13c3a23ec80f6da21d1bb190ea845bfac0805b93928b8779461f9554d368b3ba82e684839667b59a73be9c28d839e52788765469d4a9a59ed8761957ca5b992574bc1d75563403a128e87f54712421f0fe64c9f4f208e86769db360da8252fd6010decca41e4ffefea1f3f8752c030159acd2038b997c6500b90630db1f938a5c7be9f664026fa8fbb4691fbd48b750af3f8e5fc089e5d52352e4297331ec8cd4ef3d67a2c9864750f420f9f72803c9945d4c31f34a22cb9533bb24889fc1909b91a700a6f43555b2676419b2e4d40e6b4fd53ebf65775a38fc61eb98f62b56f859680f5972c422312ca380e302fa86995a4a9ed6091275d072e53ad5bba16daac67b38de198c113f021b548a9effd56aecb880ea7417ba5a75ad50699baeb1ab6ce90362e8fa2a9963583b3b9219852068a407a636ac1e63d2afe7adf41a6385623bbc0d6d2d0986671533aad3035e4e8fb8f9e2ec8ea42fac41dd543b9eacce2ba910fd3325f51b0f17d46c38d9afa6cb589e6f8c2da1bef122aa1ee6b8830f2036d0615812bcec5e1b4a76d789d63bf866ee204fc38183e59b143dc0f85ef20aafe95501e82fa7a46dd4fe26201c85be8cd3af7d2c9ed7b85655780bbecd3936afee6e9abe4b26bf590c1f43ff51c76425625eed608f630b7e06b4887d8ac4a9dce48f4bfb8e357857eda4b181e38dace5d429ea86ceeca3daa9f7c6d3ef9c14d1b830ea1ad5f7afb217def92fa1696cc03e597f616b2e2c67dbfda0b4d974c19f839deb764712d42da79c95496b022efab6fa7aa92a76698d196c457b6e906728e4bd36aac5ddb920513fbd778a6d417dd7f252d0fea56dfd388d40deeb2ba55552c7ecfe005477b1b74b6127837ccf837f58ef3b52738c28a32cafb793745fb8923a1b967da58a12368131aee2330a1535d5a4b8f3d94a7058068647a4820fe02a2bad69aa5a5f38d26cbb0ac1ee18e19bace09d63a10fa915fdff57cd49d6d2d0774a020a37b28f1a8f35cd7a4d51a00bb65dc774bd86628e6b75a88ee4c6cf3cdbce48c788445ee6cb0ea34b755929d907c15a8b9b96e78de9c2e0d3ecbd54cefacf891164ee4e13453610114d5a251e60d97f5ce807c2233deb6e885dba0d3c15fbb5ea482049e53a07293ff09dae91d1a2fd8d983162a8cf019271b85666d4b72917765ef8e2d8e95e2357b17a617b5c5dcde9ec14e3a30de9cbccb0073f8b046d7490d1f9482020f524b5ea5fadd3eca05ac938b668668b4baf2a183b8ec1f88ae9b3d9ca0b63d286596aa57116e37963bf14a768013485cae4a439d72255d60ee19c93c3cc824eb1006681e85fde060b5ac49bb11e2719f4e8cf98d1de4afd5483d2184f261b8f9ace0ae3da3a3e10c95af2dbf2bab6d86057269781efda05230e52049b1f35cb0ef53e782815fd20e6a7906852c360e806d078231de882d4787042cf6eabbacfeb84c536ebf4d0bf9c78996fea01aae79e702bf8af5fb6942bbdfe4a8585e6e586d0452c349c86f96997270c32ed362663c10e38bde56a367f0ad44302511a5ba247e59a4d2f48d7c0940ca7ffe6c2d5f61b571cc02f5d390cde3ec04a1fde76cf9091ce7e55d9e5de3138457953cae7ad12ad7b6e42665849efa5136168d20b6cc5391947124dba82637a129ebb966e875e042b2842a526915613a058d176f519be7cb08d9745c8eb36b03df43d632245c87a79f9fe3a6439d3bd7ac638783bfcc9ea2990470a8be776af409890d0b3a1aacfc5a5c382e970445e37df7cbbcc9ca2d14878aabcbeb4ff4035f022d7b5be48844e0669794947697adcd980069ef8a0f270c8dc324643495b5d7bd5406e2c947837254ab0863c0051c50220b724bd6f142a545b6f32e96857c31d6a174d06657bd938695d3ff16369c2458f80a7b50fb6667967763ef3d0ff828d30577bdae1da46ef6a5b0fa86c6a37f66e78793ae853087c5e2bfbd1232df3e69ac968584ae42d729059195e17027bde4762d2ab8c2a773bc0e1371d165d28b3f6f08df45192ec76b214c58822f705ac77af67342ef1565d738c0072d841d068bdc39eb79606fa63fe14a577d27c64a63ebcc5f38095e24066b0998169c6cc1283b3d3db7d39e56d565c9c0f0bdf9c6c390c795962daad6b895b4fe4d1447e0926cdcfcf6dba82dbd2d9a14ec5872b7d73d9dc30797935714feb65815f5c5c9accf02cf65f05b107244341c9cb24fa8f68f22c24cf1d310a87d9d61af62d23d6a6ba7141dba56f5fda5a6047c0340352d25ea0d3c54c70555c2c8a843837182360284de4808b0f845a79478a36838c203bba6dd5d8c60","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
