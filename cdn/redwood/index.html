<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"244759f9538ad843d8c67e727dc737263915fcf84ff62d52fa31404e9376701423cdd190ce62de088bc3354a83a2e2024efb0f51ceae236bd9e673a9220e87dd1c3fa6e25f37c7089553e9d089821e756ce64f0777401bc3753af3136c3bceccab476ff7eac57e76c78d5e0d7dbb3a6a3556a2d935a5a2112a9da0c0fb0fc018973669c0fc9b3f8baacd68563420c1b477dd1d4c251b5076d308324a868e45870180ea18325be8bd8370bba2fc49693173ad7465bb3414b21ac23231597febda1543b4d31fdac3d1d82827c3257e0ed4e5199767bbc7ca9a91e137501575b0763b72dc3e20a556a001f58cd437a4e0219b1f93065a3f889e1c38ae985a76a85a955fb14a1695bdfc21e2b2db97032ae9068e7423ebfab094c6d6805b6061aa718b723ad36979c913b684ca8e8221c7c7b7d8417559ee3e6df2ab4f2f64cb940b6542ee3c704a26097031dd955032fe42156790a225f96b26dd4659ea1db07b12895a99ae3a8bc672f64397a8f80e4462b00b6284d0853f174ce290b7d6659d43da9c945ee9d9ffddcd0c595e6c600e7e623198e5cd780a385a5e14cdeb7a93ba0f055a28f248108db8962d94930d145a5ff5199a16626590ca322aced0a857410cd46389c641f15b5b8a57ddc66a9e59ec0ff777c8498f07d46fcdf41d86c280a510df3662e581bfa9dd13f43515501061e41ec8c90cb57568dc8bbd0fd66a21f7f221a037fab10313459490ec4c7916a2f287c89e55154857d2ce823318d78a3d2c42b91cb20327d7211fa0a33f0882936f66ef864e0ed3fab28a2fec45b0b82398f217ab45f8fabdc12d8152666f1a8b76d19a8ca532c4a8c89fce60f80944890729be4013328e8b525c2de6ffb2b61bc221a8fa13f82f368cdc00fe4a3addb095c9d8316332f52e3ad818919e7bff099fea2fa595365e1f03e5dc5ba58f2649379bbc48ed2df0cd8f01106ee08545b76c5fb7d2721c7a337be9518adfa744c4da398d9b1929a27b0ffce66de5825c5394ad92a8ef4059711a7577e9fee12c6cf39189ad07470c2d59759d6f2ae9a98ba524c16e2bd31d0a34f2ef02821460bbc79ff7d4fc8d889dd346d2558c6dd1352f66235a8444a517f9d1492dcab59dde9d9856121a560937e78b62c7bf0ab75f502b0a5b949e15d2fe62570bb9b1ad972217a4e4d86e6bb842a98202c8c1038380986d643cfd7a7e205fd9edf467a5142009ad34717590e53d6bcb0a043287101c79bda19668bd2716f4b2af622bc2276f3e85c20fc59d3838595549b49f5b9936e11920d0101aa363eeca3e30689563713672113e77c5fec464ae8aef89ff81262e7a60c9a6a5fecca6b846adef30dd19bfb728fa4498ba5e16601bc1e791046396a4bd0daa9de7479fe05abea87fd6e70bf273563271521be8c7a53a7226e5184747ffd253ab9dfd6c174272298afc1d126c0773f612f17230271e4e4cd1c4972189e1a3a76ddcbee3f6b606afbcd8848d0f75d466e43a47a06f7340375054ef48b17a3e214df908414b7de5f55297b744bf1a7f5691ef180c75a84878bdaa4b411fcd4bcfb28be2b2009a2bda6453c41f84d83e6fdef43a174e3c2e80f35d23fce3f87c708db332a0a4744fcae6b7a0413c9fb429d4b53a75f330fbdf9ad41a8d1fb18f6ebef7239c78d226993208a8af41aabbb2e8271b14d0a9302e982bcb7619406c45cd238c3889ac139546bcc8368ea602695d20dff6013ce516a11d1690107f671c76f8745aca3ec1c4e35292abfa364db2fba8645961288a755e3828ba463eb52aead3f7330bd37cf9fcb6e6bbc5dbecb33fec500811bbb7a1b480fda0094603044945b34de423a9e1e05b1c1784a8466e0222e3806386adb916777d1abc13804b2dbd88c0eddd849950e6da8f9c61669470838fb278dbde0e30e522fbf1e7ffe4108c90027544a7f61c2a41b9a5cf5f3c45514c152a3ff9f0ed6d8c70bf9a29c15d4753ffcef968f974faa9d6927691520c41e0d8ffcb99afeaa5321ed44812d2033002058b3cf260108966f335817b2de9901d8c86f1cde325948b41ecb72683739111625c3dfb118cd1d2fd28245c5eeefe72888cc75c9a465fe3e68eb3a4d37447ee5884e2147c14a6c1be7eef9dc0e870c37e9e8be318a1ec2caebe864af210585cdce3b8677eb389d7b95f14cd2bc48f71ec86cdacf02dd24f28752ab0e0f13d342f3c209b3250cc59a1000228aff3a4698aa5b52bff1a3bcbb229fd8227ba8355c63c3e929fc18043c3fd09d5ed8bdf780d280954b73c99ea97e1fe57a20b437e0575ffe130bcc9470de49883262bcba886286de970a9dec695a9bb415011381e8e3a803a9494efb65931e91bce0fd3dfd07d2f286b6022ce8890bb52a113e25520f3541ded6e53a34fec76e80851ebcfaf5ad051af6423e154beb12c933e438743862ac5dbd4d835cc4b8fc61e6b5fd2f95758793cd3acc50d7984a2a65d01ab7903008017aa0671a84c6c62d483a223a41658c8e04dd456909f06c7b123334c13e3f5f6ea2144740aedad4a4f961e7c29cf2069c75f46b1232d27a5a80530c7c8c43ac1da1004872595ea55015458d413431e8098891566882aa7f5a47df3edc4f41896fd898967636e9913fb3b4b14e7a745f0f44452d5a31cedd348d3ee777f8ef9ea72f9b9c210bc9941d4c9ebf4f147af05fdef358e14065730868c08445b76c049a2380310f026c0fe3bc248a3e167229dee430afeccf27d87bb6d4216d2a3ca02930761c13820a5bf098c904530470780b17d6a2aa8ebeb7cea4b75f7bf7516740c8ff8caa6ceae386bf5047f6b26ebc353ed5490a65be49e9b8d3477e14465eb79a2d005581d694c1f203771014695648adc0fb59251a37e7ed19bc8c8bd422efacb58b4c0d1ded88ca736abd2d97588461217a3467ee52aa9aff0a3454240ac57e54c528fb26bf9713db7c09d4cfb872f7f07af025ba1806af06e45b9a6eb0724913fbfd838e352f96187491c92f5571bf753d400b4fb3ce4a38e9b082e440555bf184674b8bd4571ac99dda96e03ba20240793da812b3bf9a69cc4533970e483fec400763be7cce42bb6c0805b85d5da7d0c39c4517e2a9825e56a2bfc37f8773261bd2a6480cff64b7438521129da959430064c8fcb9e7f9c0338b38999b0748ee14fdd7d918d7d4f17a379a232ba3f93925252a59d88c3d1c2b9becabaaafbf6aa5d0d4a151fc38f93b6bdcd2a784329fa83a0bdc7b0e97fc9c4d5f794db9b8c678252e5852024dfed35632b9208361a7ee75b1d9f8a09512db57e34f194b713f0af328a5fef52e774c58542ca1bac69dfc253f4fb40f67d707d7e19e7b4b11dcc1b5e8893634e3c2055c4fb864c314b39484cbed84c6ba903b6e92a2ce698505886fa18d438e3256849aa9162038264cf1d873c66bc06f5cadcb1748539b31d3c001a771470b1b690bbe2a22a464365f873ad4dba538de65ff633e2b8b73fa0098da08ffc4f0f1e2cc64adb75bcb286c5e90363fbd6883cd2aaeb2a7f672dde7d20109bb5689ed7ab80194894ffe8f5a3cba65b79fb11ac8e56201fb36f26d2e05dbdc882ca8b470c0517f289d59c4bc61ba3242ff3f91dd98867c77b5d1c729095691c9a69e19d103b9347bbe715072422f55174b779f9ff62abdc84b0bd3a2720c359dfe0cb52ad8e440f5525cea1ada64a381520dee75da3b566359bcf99f01327d4c8a6f2bea4812bf5dfc30d217bf3e4c072ee2d8ac9adf504af37b83706cd94481499a513fd4370e263819a666b0d7194e59a6395226a7f02347553a42214309063b6c6cf16d9d1592b526f53be809ba0708a43e48213b7945f0e39bf19cd2c4e073dbd3e039297fca25c66e6efb4891c16dbb175e884f47f3e77a504dbd949fc8943675e24473f682a78945b29fef9a6dc4ace7a0932ce66fefcc87b6f9b6ebe7115345f4162c2ac4cc4566fdbbe6cdb32fef64504d408b3791d5b38ef3b16b1233928a9daac1e9b25941a3a54fe8eb7e1c2956cc9bbaa23740301a651a037e6d478a363277fe96daa5aa65ae5971047ea72b3331919487ee11d364dbef7d704325a6a3a6dc63ef53536a14e69dfdc7e1a52351056cf1a8733dd0c2e31835dd24378c06168e40b38b24de644b03336b81259990a8ab8caf90b647a82e63fbf64985502240a96fc7b169c3e777cc7647dfe7eded1108b4541383e0382c29fa20dfa998ddce462fbcf93bcc3277192aeb7417590d8706094011d1ee0fb4d4b33d2638b630cc10f9ee627484efd017238e1ba53313af394e5b2a1dfae8e00686eee2ff634b29fb604be9bb160f454775750b3bca8d8e8a0d4bb860a51f8ed3d98e5affce607067cb3da3cbab993a53652e64cc6272a48e1010feb816a49331f70a53f06f3ce45d6589c53e7e4191fb06fa68d83ab35ef001a8366c4eb76624f9ec67b67a710cb331493e801ab53e17972fae8b82505feb1cc1f419ccfb99d13aadc56ad9e0c818a976706e3392625ddddbdce08a9c6c9418a775a37d228902bc8070863d6806b3121470e3823406f09d2cb7e844e8f5ae6756675f51268e340c5dcdd0f2c5ab7a595dc5f22c8775b054dbd8ce59b7b3e54a8d2ed2140d5e44245c5273c6a6d7bfe41212718e1ef3b76e25e13b76c40a4e891c5279b3e49af6017916c8dcaabe265d269c42dbbe2b9facbec50093e70d47fdad06c373a42a741d4c76f5625b53e751d17a7cc53084c071913c08c6860075df38016f256aa8c4fdc1376d660f2248a05d56422256be5830adef97daa6d6428c15e85b215b624b28c054dc908b54297c19492e44d2f19da4bc5f3202395554e2d6569e828f2ebaf2d1b1f9d6658d9ae213284f808dcc0e3f3907fb20af445bcba8c096b6a7e80de8e8b3112faf747a0869ff833d43f5a9c020d6beabcc6ffc7ddf469d0aecbf24a4ac5c0b4e439518ecd0a1d3656b51387916aaf9e8eb9d1a89e0610540c5c447d30c9df9c1923735d6723c20cc80b28b8401b4624ebf57bb44a5cc3d67248f18aa97cfdaabe5740f52135a5b57f7fd6342dad41a72e252252ab06341275d23c8a925c114b7afb80e9721a1ead7a7b7747342c40a1dbc8ff00de2683e9a0b1345278308fa0f30c45aa90972ea34343475a49c086c6b11b6cffd5782233b1753455d75aa3270fb72dc848387625697c20317327cd03e0cccb788c99362a84be584923e4134890c40a44e56f8f03eacb5467014e0b28029f3b1ab252b70ed7a4d89800327510e77e52bfa782ef42ae57337d2769d57127f2d0e182fd89a1da6cf46872d4d2bebb953c252d3245e6f98d28ca3c416158863e55705b74fb6bb9a351ffc44775fed42ef1156c3ffd560670ab805408239d90b4a1fcb8067f21fcc71d1a0d79100149f8c598c12d85ecee81a75568c447f0a96e4fa48f481c3a9c4adf9c06b99651f2d06f52ec3d9b1e1001c20bf29665b64a559587f84469c3fe9b25755a5b80f8d1b96f44fe20ee61f265d0596d6fe712e20285cb004e08dbb1e87daaacc1d08c6bd20d1d9bca8e329f4c9b109edf90782a43f28e310d64033b9f8a9272c1b62a430c7f92413d0c2daf96eb13334db33d346428b6bd9120b3be92c63685b0516cb5b4cc132bfc2927aad5413513888d36ea874b68bd583c7957a07ba8aa61150cc32184daf9ac20dd13fb9b6db0bdcc79d67d9163860bcefdb4423bd4abaa51a4198f6dabdb0d661a7552d7fd1ce4812cfc8ed2d1c46443a118d5eb6346f03409083009d7808d5f44908d443b6b4187f51a62569964ca49fd537555a853cbe5c77233b57c7de7dee0147360ebdb40691ebbdfd4098a850d6d00a55dbda583827715605d27eb8f15d95a0bba393c87135f8bdc699038292f3c05950be8b655e4ee2728e61648fa38fec31078e28f316ac67d680a658f8a82b5712f08a741effa42ca0c1d16c826c777d42fc337ed7de64b48844af6cfb6ac08b82c51024a6e3953871513e82b9a3d82a37485be9e95185bd58fd37502e0d53dfe3c3c94d4887c2d4e3cdea017c4cafa38d697afc146d150cc86467697e9c4068ac3968ddd5bd82e606493c108fc53e7b9b5d728cf2c3199a3b6ce39bbc0187be441b1265d84279810a6d30d73da2c542e3e2dd392b643660252993c4c28a23d389f0b1735af344a02fe729441693d0c0e40760b623e21181196bf78a29029d30585d92a63e2f00487584fd97f6b685b9c58f5de9658f97506f869c92e9a7aeaec708125641afa02ffeebd37821b1132c09cba1c7725fa53754200e55b945a773823c2028faa1809a773422fe902e428252b070d5eaa3112f6a55a0be84812143a207aa0a135270d2b390bcef5983220cacc40728ab82af7db1f555389d0cbfed557a6fbaf21d0fc0b3577adaec75084dcb1dbf4d7844c4fc23056d7e2b1ba4d2b2d399c78b039c4855e1555882feeb4f31fb630a80090a278bcff84072568fdb40c954ad9c5fb7e3a1200eb319aec2fa71617f513a133e3e8d9d4ba17a7376e6a784eede2c93cc92fe7ef0ace231d323029ed233219963c2cd800cf9d143e9d5bb12ecf4f4895b96ef0df5cbbb1e5a632358e189c31b829d7241a6841e44fd8a65575da12d98cc1bada0036b8a7c6d9ad648b44b2c701d67644e4847a4995ebc12727ad77d9e94b4be52046e5b2f799f4f02ec76f3cc63416a1ba829dc78afaefecf802dbaad54d7200b007c8f87c6e0883a15a56be4720057fd6a5acbf224f8a98fe9c44ce36b54ff0432d6ebf013dd8c8beb421acd46b954f32df0b3a0e1880eccf17065e57e55dfb6c40df99aac5c1a87536989d8ed8a8b0b8ba9ee3e0e5292935752dd914730f00c75d5cfd98678e9f555b0da0b560dbd00f42fe602988a1b794bc74d891259274b99f0b357b51318aab8d7482d9d61b1a5ce5847db2aaccbefc2045800c98de3fcede4c032793478ec67e49cedfd88fe41c334701a10f03fcd8d8c1e7bd2d480a9f7ffb730fa43efd20af8add6f3c9075d0f7ee86283ed2abf73e3c1ab87cf24a55e385b3626750f5044d88fd0c7629ec0d5f75c2c06a643fdcc1559f02e300c035aa617532a572b6010bfd389e513deb6b3d497ffe2c40052d18c14b8f458df2f2902c64dcddde658d5d8a2abf5a786928d47b9095aff5c35f89ee146db0eaad6062f36232cde5b123a3e1409c032b3ed69dfafdd43c66534764b248672466b102331bdfbe0159e7a733984a7af33a5c3719dbd5e079ad43b6ae0e53b4938783125d199299d9807a6d052caed39f5b6615a94a4495223c5a751e235d57a22e40bc20968a6d78e682ef2cd272620608a21887da4d6ff97d84f3da491608370804572ef338e47d196d9b90025b7f8df1263132c66df83571b42a049e5bb298c2243d72d605520694564f18f52daa054d91f7cf0c693e1428608102fa61cc992be65f5eff79a2a187561cdc462d9cdec5000741a6914a21d9d4ef83de4e89ce899fce1040e8dc300d5def270dc7a37d2f089a26b1b90ad137fe54b2fda1e776f3df41d2e1dff9ee6cded134b22c86097f0b989c984e89c52f95d1560755af1f7197348c35c5ebafcbef021ad619f44404a7f414de27c90918dbc64b1668cbffa62aabdf1b2fd75eec493494153dc98b5317bc1722f777bb1fa9f27c3f94ff6f7134bc6dd29b3a40337ca7bffd33452d9775685a94ccf3fc5998622e178296074d9b6cd1d5650972005a0010c305a4877a290c42e42ad433a2d9f78d3a10c69b381454ef247daa59f0e47931e1ab65259151edd2a6aa7a889304bfc46924a3793a590200e562c0ad5d9d4babed41700651b23656d81741aa675162e87d8e7294a32ec390123e6353ca01922d00560f2fc41bfbf53b66bd18e31b69845afad41e4de3766890724c184c45774f8d23365d0b5a53a581f73e8d61774b0e0ee4f65970854ea0a81dd73ac0c65a70fb8ffcccb6659135450163eaf6debab62aa23a7f596d470a8373a51c95f9a0aaf2360287d652350e31851bb1e29f14f80e4a50dfc0c663330dfb37bd5988846f408cab512eb213bbc169e85f70c89602157edd311fac26eae211d2f2e191b281a0eb3294f323065f65e23d0223d825e38b9e20fec27f2f8eacbcf4aea2aa7ad0e8f4a258260ff6079b14bd92a26e3c40164bb0a2856cd5adecd6da1d48ebf43dca842d195a59a7d94d56b50310678fff880655d0dc6bfc145e1e65144ac83a50bbe35c1ce613678bced53f224e08df23fc30d7189de548f6dfdbfccc3c0b82a8ec1226f9d18a6a3efe5b0c5cda8c89ee433a4be10829a37956661fa1846061c3491c5d9a9587a39a784d0a3ec4f89877938b1306a5849bb19683fbafec7293982b55a8b450333272a692d751f2818307d6d7a2f66697c5f707ecc9ab99e477a2c2311847c65131ce098afc7d26cc532e7fc58e2ba3127f7975ef8876b32e6093784727445dfda1a64bc7216d2b55b517660b30c9a50049c44457380ad1e6fe1366a5d5bc1a84a37bd096198a1563b48570acac2f61ae05287f9a81695a4ba67e333c4ab4b3a466c1103a04ba2fdd353c0dd97744ef96b50181f07c0998dafefb68f359f9b464459b75ad26a4d8e5c35e91f6abd1fda6c7b0d9c32772c20ba3c8f52d659601244520129e4f3335dad04ccba2cb9e962e562c7f12e6311b987a5d29f1d3d4cb997ed94365453135c3686d229f46aea5f040a3e693caf7bece51c5108dbaa67fa46e22ac313ae46a810e1c780f772f7af3730d31278aa61cba839d7db7567fa35a063407d572f19b0f3e5166fe6a2cd0bb82bec764a2298189226e6dd2523147c082f0a30f8873def9231a543bf8075762c903ccf5b9499d019aeca7024c6e3f3100996d367fa1f0c1b0530f0e0b03a4b7fc430e9411a823351ab4e34c8b69b7829ec94d0a5d6dee7d7854073806d3538396364bc2b9a978261479bd53333505e99bfbab9d0493289eddcd3585b50d3b37955bf236d5215976d41125f919ac9d5829a51c44cb73c17b968a734644268d1952cd31a288d5918bc457faa4ced00b7138198a5d0ecdd7bf6d2aaf5c27d534d1505154dbf49e4935a6638e146734e9d2e224d6b8087e05df15f5c5f24ac721ad8ac01ef38d307c6b996027139f5c0919d13c914f0583efc016645250457720e4b3993f1e5a1a9b4034fe21d9f3974ac0c7ab59675ecef5a9e61835948d9c7ad937b4fd534428c77778e16b1f65419d9505e802b2896563051b039b72c479bbc923e45041db38479714b3fbe57d3d12180255b85961945429b5a3f0759c77a577c7f83198296f0108acc80852de327a7f15b17e1ab76b4a68dbe14331c8844d840e58df742017311dd13511e49aa0a4c8407c7d5a9977837dbe75155db60aa96a1eccdd69e0c6db242510ac2b1adfea3859f7058d521861b9d2ab7cbf35ef8fa73fb85dad089b1a65f6e1139b876bd08106d7990ae8e048c278232458039fb132479bd203ad8610edc35fccba1550ffdc4049792664f13fa5445e9a0343e6435ce3d6aac6f75ec640e808498452e75943b4acf41189d36165939ec6590b6d24cc2547b855236935afbf60744b2159c65c9ee2d4cbab37e068ef4568953645a79af94d6b457db98ca7e1d96c67487d804d69e9821d3dca0211656f38408503f29bb746a0c64790b7af3d82ed064c9ecc7b2f1e7444c240ffbc39206fba2dd179328e9849dce308e4167f04d0df708885e0a41e8a2b9cc5aa4bbb106bc44389d529284f2f8f30b760ebcce61eaa71ffebcdd7cdc93315768db1f91150a2344ebfa1032d59b19a470b9dbaa3d523c9e1521f0c23b2f4dcc814e1f9aa663f9dbebd9382bb03b45e53c6dd9dc1ebb066fcb796f7b29538516e8c28f693a86ea2fcb946b8eb2f60073c8473107557439acf6f958241fb128bae99cc2cb64c3aaf4811c45729ec383ba398217da453c1c31b0bc9a62aeb5a4817fef767627400c499a2ce0d5af71c10b0839ac2b54433a641f9073c32635c4616410b5ab3e4fca53db3f30d96a68479ebcb93794d497f47d9474e057d80f7797e6cd699466c2dd71671e0f6704e93850862d338cdb7b7ba60936130f7cf6bf52a0d9532ba3ca75e58589ec4a37fa60d6092f447b1051764290739d4436ad1f1b74e24bd2340af044d79e27777a15cf65d2d1a8f7f90a190f0120cea8c36be935231190984c0a9215957e29b5c20ff8dd761d92e5af094415b52fabcb6c7bef3bd993fdc802f992bcb1387ffd6d63e35b5139702f7b6584da666e6bb4271e29f28bb67e602161d8f8993e422b664451639adbb001815b806fc52d265fdacafacead2a8493a79cbeeb2703785fbfbf80c24009658762ff8be784eb15dd77bcbac970b829ac1c195e36ed6c4e802ee883a591e1ee0fe64de19ff191af3f5729b9e01b38c766a526992b09b9cdc60db277fd3a686eaf6e59f8f9f0d9d300f40897a618f4795ac964c36f5004244c08d69cca96115bb5a924408fb3dac612dafb418c10037de81f6fd0585c05d81e707c0274f2e383602238dd97096175a64dff0b4b557861459ec22e4317a0e2437e023ea7ae6624d18927913e5eeff4da2a6c98e7e912af8e861692c2dd05434f44ed937e89f122cb770124753f1db93198ddbcbf8c26f33cfb34ead9de910dae8074866735c3898a4a5f1b6133fc2d5252e0fe5923557e6c8f075e4dfe3be1c24bd86e88108c19c0d9289ab23c629c6470c0f29106ab14d63e15467e8e89305d6068ae3b089f1b52cb374cf63a695f71a1cfae464518cc422459f574cf4fac1e263aa0f3e15b0c0e20438671c94be2de6b316c5c204f19ce78e7d3ab5b7d6b304df776fdbb5d8fbca9d7b351616affa869847f4921222e20ba9b91746deec93fea3d0db7b9172e93ac293cd9ed0a3e5816724c888a6209454b68ab734131748e541c03defd0d86cd9ecad1a23c765bbacfdd35e435ee103064c80f29f2a10545fab166e87ea800d9a08640998d10790f38ce591af055e6c0b6d02186d012cd41b4a389460ecf1f600df63aa748b7f3403ccb2a52a083e59fe9268cc56061ac80ed03c674cc5978eb403a7ffdd0fcb2bbf5fdced08ee10172476f9921bbb97431c42252c46d5f5b32c3516028e9191f59d462c9a2c52164b3a616516e1ed769dcc5162ca1dd00dbc3f5fec93d5b228625939f182bf6a628857c3e99cc44278332645396c6f351bc728c8bfbad1e0c68e1cbb91eecc2f6474e50624ba878e3836d674e21f67b51b7edd42fbb42ae47707b452918ef720ad60a5dbbe42b7640a40a01c6edbcc4c2abbdafb993019fb81e44f6eb63310576dc32406bb9b26ff07060e41cfacc7f9b9af390ada88dec6ee671af5d7106339200eb30890b980e48fb1c77a160f0ea2ad7d3abbc7ced29422e9b4fdd10eb0b8793d19d42126f9796b46b42587d85f7a180b5756dd0681ea95cd0cb9d9da15912452c4d018cdc5d423c9b0d8ce1357517ed48d6684d0af2175a7cc4f4405d6589b945356c3d9a59dad979ba00997cb394cfc36a93586968e9f610bb3140237071477ad458be8d6984ca7df09374e3c86f3435f202cd04d41b2207925123a8c3e3a5f93ce11462ccdd829d4820f854bdd9ff01ea0bf69d41995f8f2cd95ba1dda66350c405ee362c4c0312f492403019bacdb2ddb127d84813b507b85b755715076f2499838c520dae6e5ee2adc8e9defdbdbb83e7e4e9b5e33f46051acb426065a676d43c25795fb93e5d5f6480cb9a06b0e9abdf5d265bf4c4d3bd8e806d563a22610a06fabf649b689a38c21a26c0bf352f50a5f93d845cd95084b1542d3625b1133b65646b99cdb32ee0bf8a09a2726af657132087d65775396b0a43d83e93023c31f40b811e656ed252ba8cc7b87d6c44aeadbc6cabd0419f133a38808effa87171d946fa93c86dcd8dfa26c06b139b3318cdc6dce30f320cd792618cdf8710a34f69e3dd324f4eef7cd70d2ba6faba22bb58ea2a2648bf12993a6488dffc09b7dd06f8e15f9c3105cde04fa40e32c444a6e99fa658957e52fbb9d3c637387c0fa5953b3c1774d746664de5ca1d5cce053d34c2f0954c98e3ed1796f4e295883ee3fe18e7054fc4a86f593460c1ad78f248fef10028ce29981aa461131db0f7a1d0d7ed9f022fb5e4faa6613f7f3e2631f4c6600b6e5cef92dbdee9617a14b02a80db20b0c8a5d6055851c7ce4a6126ae6f2ce9bee9a548ea8e5f9543ff75aba62bd2a2f130df32797e211be572a0c5332889655c89536602c787e3e0926c4514117b412743fbd9eb2bfde049c7619c46109a937e8923a78fe32ce5cd4a8337dc7dc9a167df5516e8e87deecd7c258517d2e856dfb826e161fcff97cc3ca8de499dcfb1db550a2e5dbe354d24b899ba8f5d5827c171eda0bbd07c728d64b72cfc91e9d4a9565939e39137652a5c32e8d74f4066eb8661d8b9fe4374fbcd3c265da7b4ddd34fdfae90c4d768a7ccef804b45388013f0dd79f5fba13ef03677a0a51f91414702eefcd515db1888680a24c2f7f3962220140f3f2f6e308ae70217624b867b5d85d894bcf1d7f5b4b19fac9bf780478e262b49ef30165024a473054cf2a2925d80a07071c705b2a7634f750db28a5f495ed0f009a737d7dd2d2206d6fe917c0795841ab29a682d94514e251146f9683f651b278f8bbe1d2527945ca86de327ca617b97f59ea0a70c5caabdaaec09c7e3d9e17a31814d268786604f346f805b212590d254692de0df526c1aac01273e8029f26c1db30bad31478fe734e36dd5a71d0b9b856e1154668f00afb4399b948a598d732c36a77ad53cd0cb849d0b1dc3a3e7298f4a356f1f9c56cde11b762dbc14d72fb7a1c290a806e5f7a45d341a7e7ea05866dad843949c7f9dd8d8194e16a8b9866cc4f01c956bc47de3c719b999ac77e76b12999cb1b3ad1522128fab800b170a4d04e54c6ca0074002f44a2a66b6a8b69d1198a3871c34d416b73798f1326c76b540468acf5b3a4ca9d8ca1606b085993192a068f517dde5c0e161fc6a2bf68b402fec0986e9994185ea4cbb399a712be9647d9b1c993047eb084d1d4c142df8912e8c10397a161812df6f93dea54108a1d9b955191903290f0f2e6c5ea8eb113004094ddeb53e296a15079c1308a33ec722abf30f1e78c2ab15dbbeb6b30b55a237e56b08a6b365cf0d2948df606d583bbd48a15395373f81ace536bff0722bbd20e819770662474f4317095866f5f77a2d88f89f0e93a8946835638d3a7c16493a441d1339d6dfc5ed95aa6ae26b93eb2cb6c65d05276ce539c5a45b661eef420756f06cd7a8bd4026a07cbc02384917ac4dc3b46c553cedadccd6cf4ee99f6fed0a584355f5595152e1d138ae3fe64f341b439f108a758691a731c81d9d3fd0140a4570204e294d317bd790406f6e346e87e88c50dddfca7d001c6d329fc42ea323799f47d9968681d486463b6b0df8a3083e1bfbde3ad8e219393f50bc848bb3a5fc1b104d044de5e3870eeaa7e48caa4cd4515f7b105d8c9c9bedf450530951a948be283a4d0b39b48c980ef76420fb8c80fada1629c22cc84644b50a414303f921548f2821ccaefb638c3eaaa3765c77c41457829cedb83910f8066245f018b5da0ba7ad24fc9ee251a4da7453e150632d76da8e1314bbbcdfae80fd0d4059af3d05a53f513b213f43e9c1b3a95cd36880d6c03d9115a98d73d3e29fe9a5b1333b14877cceb0a1c7fb65f1e27116acdb00dee6c166a5f28e95bf4978526868dd0b355e377532969207d10333626a22454dae2650f7af042f782abd61e394796e5a464691d4aecc917413f0a499a533758ee8ec180b3fa5417101cb86709d1d06f86b578ddf5a4b3eed9f10db38ce19a68391605bf24550d1de5ce7a954cca8ce631978ac0c4ccc1b179512d7ac0930e3621d38d7936b6f11aee687f14c4a99884e85a0bc3cabc8c2b7b783ebaad35e82e905a83ca378d023fb83a353cfd05adff1c660a46d5a7a11791e4170d90528db016dbdd03fad9446cfc24c69f1982d04a78dab88137906a7c9f75277caecb243379114919c7268b8614d16c736032b3cfc075fd33e977a89ae48bf6ed8022584a9b9887d4a129c8834a9fc525c5e62dfe8e5fbabb94dc018f3e563f9e0dce04e50d2fe5262c9e91297f0f50281eb0187c7c8474e74dcf448879dcb9eb01fdbd5551cb21562f907bd159afb21d41e0ec91162b00d666e16c95cf6df7cf3239067ad701f7be1a8c098868256fcb493dba5564d56fe2e29e3bad2078da8f3736aa9fc3555a41388bc7447fd9f0eec9deb3d57860d8a9924b55a3b16f91bea91f43cec06e01247293d1ce2fcb5039815dc8e928832bdfe436d9302d27fbf60dd5a797754ae5d4cfb60002a063369ff620b0032a599ac938d5bf3e9db19d3c5aa76606069346dfd3b7b2a6eae948210a86acc4080bb95e05961c21162fbf09484e004ef9e70a783d3e01a80e3f165d764802c3ef893b5c5cc803b8184d83c85c86d79762a3269834bd3375f8778abe7bb85f053ad60856dd4548a38153636714fc940a81dd0281dc9946f47c936066e9a5ab12b9c66537e705b822bbb6248833e0305a2315a41dbd16791ec575a948f9a8bf6c68e8730d27cdc7b0d3da09fb2cab2f010ba883721aa0b3b7c3fc47c15e7d08b5e10f8d29d28c477361a291e84465006c355244bbb506a2f64eb35e6e325147d71e3915854c99be9b949be37b3cbe25b15ee9eb99b2ad0d0c1d2afd70bab34f88d6b0186c7ea7b0704da55bbbc68b745802afeae8f35e8ac30cc6ec23dda6ccfb967063631f21f7a192ce0a650607a598a3f59fae783fe5c57afc950330586c91bb131dedd91ac849c8936357f761430270cae968e7834871770f89186887035e50d1bf3329f78e1bb8cfb0ee25f1bdfb4a01f7b4cf46aabebd29e103a292f981d847f3bfa5215dfbc1048c4e82cee499e4ee6c1bf6d7b6e37ec496cb03c2f9eda3aaf3dd4d1df5a8086ef50017ad78cd165e50da3bc4644a41317dd073a86d95fdf8e829eb796da74a9c62bc7715b5961470a49be3db95db23f9d6d86eaf97270c75bd23161348665bb7058467a4f698df4a49e5a596b24e085a6cd0756a6637dbb51a5cf8fef4c6e03c5e2d3ad638a5316cd9eefa03bf4c42c430a4783a0df4e8b28f2a29492b8b58fe5d30c69abed3da236266d921adbf32c62791f9230b8641e14b8595363a153803280507d79df3754c4559d7efacf3cdcffb4db33e5aa15105e2bef27a6507083993a3de839875a1eaa56ad164d4211245ad558d91b057fca4d370ea98a91ce5048053d3e536680feb276d11bbe6bcf5eb60f186fbcce2c34983bda9d68a4c5f9f89f40bcf90d703556425c221d29f990a3f95137af6cceafe1c3bd1028155b7ef8a7cab1f1bdcec17ab2930da539670b185655e670b3fc8e4cd410034ef13b83030e00be08f2bcd9f0e3dcdf979a745ab0b406cac05136ff2857403a4004195a14126140c9a52d0f88540fa3826fdbfe3e792b958a80135a823ba363e2a829f63c1c53ded4423b43180228232b26d1b546bc2f7181677e333b7ae7b2150a12ee15e4d774afea93b14a5c27bfe7d9540087266edbed3a614cb17ff44acac096361dcad3b05f289a08ef4a05b896409a6f0dc3747656059fac617019591500816f5ae505d6799d2590cecc350263c7b73d2e5a893189c637660c07118d74c2800ae22c1ec3ad26f4a5ff2b386384d506923070b95b187f84df613935ddd817588d8f7b59a1a3b3d429efc0a1f726518a6a7dc154f1e93b56c91dd72c906f656d105f2cfbeaa27dfa83a77c721a2e633e5a5109e97ed12cf1ed661075f6945d23743d920a2d102bd50f9da1e4ee0dc7a59fc3bf42c769b2a3bf3f993c2a53e7330b17793377eb5ea512fb97caa104cb361aefd585c35fe0abcdd99e144cd8d9d992d8d3166ea37b462ac45747ffc1408bd598d0414f9c4e7db552a777663d9dfad96696c7488cc85a2aa8e0ccca9755511822dd12befd56609edabd3aa59f6bb2c2680ca82bc0478444a3557bc9bf0175873dcf486cb2caa6e395fb2a426873d8f391ba589fcc8194067e229532787c10679d9913355e1c2df7884ad4f51b6c90a8d1fd1d1a766f73bc607b39bfcb1c8a6b7eb84f654c1a0f768b0a6587bd96f22d7bd18ed74fde6f57aa7d12c88b9026309faf2bab5678bcc51759493aa951dcb2ec2a0530f0a2bbb1ef97bdc36bacb763b8cffa47217cbedc835822da8160eddec0ccf96b2b43175b5c1b6bcde87949902a7b1b99fe3b4daaf989f1908d6e377c9c7613ecaf89055ad0275845f3176cec12094890cfeb0da9418eb3a9d4500273e8663585d6d6f77c7a39e2944590556825b639b6f148e17b7c69c5e15b2d4bda208fbd64b5b0853d4d6ddb92b581d88b88dbd3fefcb749b2b19290debb2ca7602d9c704bd8a18c4a6bd791745ac43191abbfbf9dd8c907bc197a99bf03547240ed1a05f3a4ad70081143d6e7d775b253c1179429fcfb6a533aaee98485e18232d8437a3067a97afc5123096a25fc64939ca319093bb74af91c4a346935ea21032a8ff6d97074d432cee64d405d5b3fd31288de0cf3f74752a8d982925252f4b03dcd612d848fa4aee065acadc1a8bcdea9c3b13e95a01e97624bfc8adb15bcff8c52efe435176813df22244476e263e2a10b128923b6c67767995596954bcdf5ac651e312dd42064cb35732a878bfe7409908967257123aa914ee5be5da0dac44dc3157e7714e70323efeb3a48624883b423757a381ce36845e5a46784bf41f49f5c983dfbef7b81e79d28169957a28bea31a436a6d3d2a3e209a0fba3ed1fea4e853a94c75187d69c47aed92d28f869809422d95cd333828c71851482063913aadb5af9ad508f25775cdbe42995d2fcd65a0591625ebcd671327ae5d2c5c9b424e84af435e293d83b451b810d150311644f2da16e0f387c82ca8e7e9379a92bba9ca15aa35edf2381e18569da463fc98c3dd3a21dc7ffec433d1b909f19a7475484df084c23ce032a200c41495d099e23cc23144663ae721657761355696a7dae5af198f1b7132a6d90783aca4a53750ba30ccde5d32e8c29f9980a37983f695242f2220fd45cad8ab083af2a83fb90c3c591f24b2dd7daeb7f5eea21779d3d10f59a9e493329778c71ce2b94d06e8b11969f1d55c932fef5a2d317aa6278275efdf0e1c8e917f7ceb7e6417214f9e2aeb4c6e5b0e71f238d2ddbf2e4d2997ae7109ab88de44a033dc9221a82f7024d3146f346f16f5803c07dd0ac44b7bdd9cb7b70ac95b934d2f93a9dcc191d4f69b8b67b37d3aa78d46e8cc72aaa7e818b90f2b976d11f370a53a9af60c57fcfe695da5d81c7e651549367f44e1fb8f757cdcf9dd08b56f25b42ecb3f84a78f0f460918d71c92eda29a7371f940677320f37eb48004326d9408e6787b23b72f78e7f0494034b41e3cc8a2ff682150159b314749599bc37a0c2094fb3b36dd0f1652753ae400fcbb7a8203d736f12abb7ee64c2f079d320cb3db03ec367888a90a31c920a7b5b1c3a23d3ac4c3f5ccce3b266e9781adca4eb695599831e1bebb2b7849918fd999aebbe91d0c357ab4d8a98caf725c0d789f9aa6b37d1bd28fe91a9dc85bb8c8f5ff80ea8b3aff1bb4250252d6bc80f8ad3feaa47091ed0e48996e6b6702aebc173a321d4eb37f9e72576fc6eff25c448c817a0ad2cdfbcf8e6881ddeedd81bafbcf20f18671c70c268ba194cb3778c61bed825cc9478db1e18eee0b0e56c4057caba7f329727274e5c94fde9b0d763f792b21a8866c1db88083f177ed5d41022bbd33d58163568bb9046531800414cbccce4842bb10c2681d000ce8da96dc3bc496be52da404200e875fc16e26f670a397c280849d53c568ed20addda38c7c89622f3bd5b38deea956485f386db5b3b130de6a47cbe5b27a68256d6a67b7f6526d662d6efb20b8beeb2e801c49be7cf72f421ea265f3f9762af4a2fd5402290c6d987aee25b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
