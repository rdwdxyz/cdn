<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d11fc15ddf7008751b0de2a313e7dcc136e7fc3537f9ebfc1c12a5141febf7eee61dc871e4e452a0480b274ddef931eb4532c8ccb1170cdf311884f0376dba8ceeb42a0e8fb61510c97744f0c42d4d3a1589a33ee15afa7e02b14ddf8bf8344f7afc3eaa5190c8d032f48d17c551f4251be8a6fa75ed3722a7150cdcdf294283d2af4c8d515252004327d74a2d079a574c5dbfdbfbe05e42932102c7d58098c63778dedf99c548a83504bfd7136069f5918d8cb1a6cd6830ae51f5e92ad79341a9c5dc954b3806429b6c92babc861074d768e9c82ddbbcff1fae10ac961fe41f3067c683bfef8a39da78f5ccfec4b7d97b086b33b55030e5d2c3ae3759b63ff87aa09d769f6e18210bcf7a191157631f37f9313f74e10cdbfa658861aea9291ff1898f20e495d8ed1998d43f0181b0fc90d2440da11f2232cf7697a6e5eb2bacad2cd76dde311840b24ca929b6487837da271969038479bd13781ed15e8b6a569a3e6a78fe517a0c2693e576585b36cfb8457492899237451d1cd96d9fc3fe9975e1d93231f7f627a1543a7795ddfe324f3236a19c465e803c49df1c4b7e92df6dad697fbbf3c5cc61b7f33fa7c7a44af957b31764a02405e392fa68843a1c5bdf424c550a058b4c2109506780b0d4ad76da3a95715cb109bd1db0d80338952a9f333dad7d8e9acd5b6d09d487353d26a7f9d13d07c08014661d29d5975218dbedb16b5f0af2a38b200da704a9045260d1956c29c4598eaf4ac6814de873127a25446ea0b97d3201e174c47799d8971156767ba7a5a69f983dc8050b067e163f9e43fa0495d3c59978cd4a65ddaeb619ff141a4e0606bead6c2cbb0b9002f04229bb07e4f86680fa25f5af0a048f282e7da6ff0e44cbad94214d0196daaa627687dea59cd4a48bb95b9b5ff998df2ce803bacb186f4757148a56162c30711bf472620e114273208f73cc06ec9e6f9756c54f0bef68e5b0c8f582f5c3007c23011c4fe0b0cee542253790fe16cf2796ac8741fc9d67d735a2dea2bf86d0264b103bf7f5f6d556ce834301750ac3356990ef608481f68175a5e8c818d2e74b88bd0632702bcf3c3606e54c8b034aaba9d96199bf50b315e1ed05ee9c2ab3a9a605fb7af75a7c757346c10bda6bccd1ec9c555d20a88aec3436da5063d9627514379da947cf0fd627abd03424a333b20954928cacde192a1ffebd911a37fd6bbdeea3b74562cd3949f94ece6cd6352992737785147b65c35e8e72dbd702b295e2a623d18d96890061c2c8540059935fb5840e8ebd099f530f8f38877916e2f47e6de768511e74028e2406998eacc8b816bcba95330adda96cb017d6bb2c0b736fdbfcfed193e80f869dcd97a88d171412386eff7ab8cda9fc59379616096b2e95f6668fb7d4d87148857fe33f8af67cc9602ed91a10dd8af13617c9be3b46820104bf80e3eabc62b8ae401c5b2e4d045595b6a5a3909c0291f1e63c5ebf1d509d23abe1db18ab42e421d8166a0d62d7f684df76e1aac61c22fcb8cb12518be4a616ab60b56d72e65e38a76a2468271cc9766ffd5100faf1f97fffd06bd3471b52d637ddf32c2b67e01f9b71ddbe0af80c01a8712238fb2a723ca55dd4a246879f46d8d4c83b64fa94e97206cb05c39f11ca081f2199dfa9eb0ba484e268f3d727dbafb229529a33b5c506ac01d773c6bc5311aaa04bb2a4119672c182e501f91d422fe7d256e8cf1e9740104a39bbb74148b643f8dfc9493eb8d856ece3b884b2a3f2deedfd09b89071bdc1573ed59536d68ff78a2b76412533b5e7483f770a0ca9b17653ac1ac31bd70a1d50eb50a801acacbf5bb066d54dab8c9dd320a1fa6b9e6c1d1c6118cd6bb6a80d7360c6bf4988d634eb39c266c9056cd7ecefea2d5f12b189277a798cf6fca20298326b00848bd5603c58404e3ce99dcd328721824907933f5f64c4aa1e7681969e43e7478b24c7a3e026071b5059994eabcf93c1b7c128ed53b57fedc94198335a277ebe20467eadb03b225ad9aa309846ef041a6bd6ecc247b2b022cf4f39e8053b1f2a6899fd86b46156816b31af8ec5ecc3148824e99173d056f5228da438a42b3663d3e645e17b79e7d68e5f413871aa76c43d84dc9ce0b5fbc22cb4c978a6c4ba5e8eabd12ddc9efd9c2a799cd3bffbb21d236eb4eb030210bff4e861d00abe462c8812eba10cd48e60e354010f8570e139db2a55a7d12da59fc9f751c7c956ce59318bcb532e16b425d06a1629919ce108518904a1ed36eb5a7cabd0b0ddd12524e2c7f4e9140b604f5b730be5b9b73fe23a91de3dcbaba281fb81754a1bf9d2b168bd011b46fe50d775c79b559df392b255a18838570197d02900d495499de6d3ed79f9e1eb80fbc58a661a24e92ecd3b7cd95f6d8fcbb6f9c70cfa06693266d892f7117155c32080607709d799f5c096ccd5043ba7f65aaf4d5fe59384574f91b1e76b8fc4c599232f73970e9ad0c21a72604489dd4388ac2e5203018e6837ea08f8e98f7ffe30d7f318adb6c82701dbe0188c3972c2a05a473794df0107ba8538bf62077e9054c706c162f62c66aa1f6fb60d294d536d478b302d1faa559c4af40ea4020b2cff3721f332484b18ea68853b27fbc934ff80255240cd86bfa67d071c9d0bc8e97ab39f94e3f3f06009bbcd74829ccdde08690eaadad9b2a2ee475e1484aad00815df50065c3d4c7df476719fa8878c928b18542d5ae4a3ab13ef31f15ba2beaf89760edce6966962a324a4e6f13929480e7bf7085fb890fb89681f2d9e07834148a064b56c65927d5fa21efc01eebf0903d419635d128740eb32f9e2dc8df92ac1ed5b2828c8a0afd8da440e20a3270b52dbf480969ad2b0bce815e7567737aefa23a532d02f131b390825570a6084f4983af2d66b26e9732b69c4aaf93b429006c4813093417ad51081b25d9d877effb0201d074ec2499a79b134b45a4af8cbb04779df424b2cf4a38c793fbb2d99ba3e0fd3c301603d11eec506888ce11e7ce27add2642f741e11dc82887de20ae54898e2bf208f2911bff050468fbf187ef0563c79a9d813c169621427285db749c36a016e9fc6ad537948f319a97f267188c03c7f427a8730759b70a61e4724905431a6928b1c4b4214dc0ad172535b0881683145c84c49951a815d66d8b645ac54179f43983b4ecab51f4c1090b196d573809646635713bce95555ef1c9e7cbab0ebd87be57aadecee29820036f045e123896940c41058fb613fa478bc41b64fc01d72b961048476e032e3e086ec43509596adfb598640bc6e5e16b0ac505e09fb009f0883d7e751dd0354b9fbabbe09ef58c1e623da8f7b4911abdd170a4376edf98b7fe1541772fc487e76aadef7ede2655ec61deddc6d4644148e9a81d22d2030f10f8d13a99e9388cc04cae2457953a47e85c509a07fa43dbfa77538fce9cd593b3e538abd5bf41e981b6da38d7e3488e8c2c9fc9efa84a86780ac6673cf41b5feedd95a6bcc225ed14f610f10b0524d563759e3a83a492bb5e1709c83055d70774011d36c93a22e6a03b6386e25dbe808ef86ce3b76db2d4755968b260249c1bdeb7318dbb3b69e264c01658946d383630296e3291ea16d9aea212276c562da807b516efd2ae6b258245ac85911074cca22794a0b20d3029a73ff83371efb275e1dc0a12ec937af7d2b6a5aa95fe9b0e1c7ab75fd0f11baf15c39b6af8d97d21e4951349fb8787607bb108b3622843c18bcd55cc12a4350e4d5e08426e5b56a6d021d9a2e9e7fe39c5434cd4d71e34d6c58af1dcb3c61150bdecfba8f7927e588726155c166388fbc1cef5b039fe7740bbc02145a0ad3f5b8eac6a1f13225174cd67599f60657def68632e70c83663e68fa2ee4039a28e1718174ff09b0ab42c94b17c848787b4cadae4a83d6108c5eb0605e484bb3fbc8accbef17380a69d649f6c21393348c7c2d46e5c09d2684b0ef609e5cc835302ce868899f8e4d91b87cdbb713a3186c62c1db03c778fe6a207cfc225eea7950245e0bdad23143a664948a9bcf3abd431135997193ac05670c67dbc2f8a46e44495e5648e1d13c195d77efbb8aa4f901a31489826a16182c56728d63c3d1053ef0ae39a43fe486f18c7e5928919e3a4f04e111dd5b15ccf86add42788e96c4e3bcd3c184175f0587569f1e58ece8666b8929cb7430734a1e040c3851f72dc4ff2f8dd8033473bbc7a2bbff780c74da452021779472e557dcc91390c98363584b5ece469681b5b32e8d0bb6bdcc7ed14cb32c96d020aae311052c282756f7f6ada5db3b2abbc80e8b98231dfe0c2c5ec1111fb3e5a4a1dd7ba538aafd921b229a713726f10d02b8645625ddda6ed14b65f47416629e7479dc9bf4337ff32497d67f02c22315c7954cc78f2bba76d4dad2430279558370f8a518db6c0ff15f0809b2a4015915256333803a68acf4d8550dd8ff58c02cac10835bdb72631d8616e6342ca5cfef97c02d1a6a777a7dbd11669debace8a1f390ad0d8fb64dec1b54744974f728e745de8b046f4ff0deb1220e69bb38b24262db09edf750f83f029b1e08c7c0a1b77bc39967d4ff2dad8fe22e10109950257e4f7f2409771da628687d8197ca0ac978f50f9e45873274ca5b285e1bd06a464f3c274ae1e80e504c299b09d59aa3f0f2c9ed2262b189901c1853ff70b5a22c3a4dc9ad4b3e978c5f258f792cc8074b7ec55df5dbef35e9fc898b08434c45f7a41711aa9b6e2752a61add69ae625a8b3e795c677026cd24de6f687474f5dea01cc23a6ab667bba66f14bfeb4c67d77cdb8211f1d35b132ea8cf18f4faaf56c502d3d337e57235f4e089db48b52bd7fa602c3b990519a2bc22b881f07c48b690fac4fe34b779ea87a24699bc339d737df9555be84abf79e63a94071de95d90dac8ab3e6f4d507849938f24c39d747d79d4909ea57b33a69f1963cd16e4314ce25b9860aee0e80a05b947881a127484895a8a56ad902dd35ef7a3ce5a7af2ebd1652c4fbb51fd77e49e23cc3780df7211a8016d636987acc7c86ec3c7af49c05aa19ef4005189f0210abb428d8b9692aedeeb7d8709156ed8427ac5378005c33b4f7c47165c3d0e0b93051e837db51dce1d1416bfcd761b0dfeae8514d45916c717006334227b69cc3a2befff3a96a15af1e37f33c220c452f39081a3c2b08be99ec2277ee874ca6eae40e10020a5312dee9794ee1a76753526ead7521077a0bda7fc9c21d80252f876ba2aab87b21ba38fd365d782660cd09fea196747081d5b613e8a57360fc93b42eb4c50099f1cf6d9da2a59b98b0b2f3ed0ecae4193f62969aa2b58f5c5d22229f57f1eb2b3af8482b57a657ec92acb8767442f3186dc884293fb03e55ca948bdad93309fe7e5e95b2aafaee7330e952ef32ec3606c6e8c88ec576ffc82763b8d1c193c2dbc749bd59faf16375004a618fe6a5cad32ed786d2ba530a6b1c6a5c7c806398246ccb530ee5d2354ce47431398e83d8525260fbfd06b94bffe2b4acca7fbe09246338d3a27f1cf98e11469042345ca94f555ae1608154c33c96824465bac45fb6e050443d89b94b58eddd132e90a1bf490660637bb5ab21e38df2b7c548880cf27c17c048022eb7384cfe4eb650a080a14f83c919c874cc5caa0ba1c89d9b68057fd03a0a59661b76f88e4e3744d4ccf991b426fbea409ddacc51703de4cf9606c84ed3c751fb14ca29caa34fef0fae4c76abd0306a4c83e3d037074d985fe923168482f369f834c22fe7573eddcd84ea086170c8cb1c7e2e065b91a8abb35ea8dadbd6c07b74f293b5bae26ba9590e6b5d2ef108f2384756a07ba2e55130e0be65aea4d436693ab53385f46469cf622f6fe2cb0794d0801b3dea32ea0fff2555f70a261b5c78875525be980ebb584a26c6b12cd58d4e959ef5f4eb9ccfcc596d88c76858214ed7c85d62ba09e1580be67e6ac016099db68cd3c44bca804ef82463e62f3e9f2547a25bc95af903ad10cd3d2f4e35a2975d2ffd52e05a8aa50a1f85799d10060c32c481a5cfa22c0c79fd5a2300008ca230592f0e8285f61802063a30756017956f111b83bf24ee57064a537ce0f213a460e2ac7ad5ddf8e00d3d10a970082f441945ffb10aabea097d00f141504580edf9606be13dbdd4570b23f8a0d7416b8201f038a9b91634bd094f9f86d85ba63e8bb3785b8a3abc58cb1979b6ff79b71a099e0d08ccc947f39b27288ba5838df61267263d5d8b5ae5468cc0d18f5c1d3b5e584f8c7d4870b677649a030469989eb24f84d7ab05a4b26626da5619eec1ae9c57c22f2bec59b011792533db696093d26614a4a4f53c7f76688d53978e3370d005931e897143d785a6277b47d10bc6914f171dfe78b56e20b82632e521393e2cc5f0bd6b627d2320325fc3c7d98c06d02a65be32e10fa9d79853737d8e10bfca51d3416b2b6c987c4226aa118f04bf6b7e887de8d8c00a85b623a2b49e55767ef3786e879ea00ac8bd1f8e7ff81f2aeb83b0b1a7e6fc726047ca20a16722cb53feed4270e1fdc32d6fe135c24afd14c6985c0dee50fc7efa6129f9504b6a9c3839dd53cf6472eab02ce461b1e94328d74620026cb80b2dd91018acf553fd622795c5e6a9b8db9631f992d78c9204f3081d9f896494ba2c3edc542b895dd084d0f1b10d8356e7a29a64a2d16e2f05da032892cc7a628a786767c3af7090418ecce32ca017e572fd7b6cd5c0c51e053dbd8a49c166053c1bd6f4ecf06b753d336064e9d07064f7ac7ea655fd7bffe14074858c5758f7bb1dd551b3d7007a882855960ad7075d708198715716919f39c4c61a638fda28d2aea067c0195ff9f9ab5994f3912ab359cb69f84d8b33130d28bbf40df732c014d5baef14eccb684a80c1e9627efdc1430556576126c07017e8605ef9264f4284415cc10f7fd4db253b852f97a1ad0ba5fddebff3c411faa2c1631c67e503322955fdac6455f33ab7ab2a5d4887ba0e99fa398e693f2b8317d06ed1c9624ae283903e4f528318760b2c1ec20bee357b9415b96981b2bcd8cb5a65a5a1e28cf00cdd3b9e6511ad8ac05ec1804f709f82f6ce4ec83f286e587f261fe662ff31331c0abc1238b07bb09e4370d066ea2d026f4da5ca0b78cc6e155f5c64d3489f2953da18e235a0c0d716b4768386a40e1ca8371c33bbb586e45f5362951aaea18e443e357902f8ce9ffb3db9f2ae9e867d3b865272b92af91da0109e26941064c620b74c9a58f52baef96239ec70a4930995c39dc0831e50ff51b536d7c56bba21a2a38c7dd21ac3cfdde350d921bf4d6dfeae1489d6915adc4d6059a5745c04c1e27e7b6a6e2345869e68a5c199f1f538d6298676c6e6890b2c2aef4df1ddfb7d6f9fd21efb1e2a4cb1015e14beae4c8994ba05e96eedc198d5ef06cf499b15455fbc7d294b6d2ee6e8e607151b900484f6f3ebc1facb912112dda75b0da459ff0babaea77ebafc381b000ad697efeaaba4ae7287c8035a96e0406264bececf4bb3cd8daa83c687f1fd8146302c46d23aa0a45e5666d3ea2cba9ae9280772341bee6e92ab56ab315af5d3c482d37cacd57c7faa15d969030a93602b0f6e3625c42184fbd4926e3401cf5c1d3c7b3cce8b70e55047fa3b75aa197843acd4ac3e419e0b27313ca45ef7da4ae30768e2e01fdd88f9a634bf650275ca8e8171c07872eef88cf585f64eb4ed00a52ca33d2c6043ad41350cd31f4f2df7ae7d3386d587a4704c9d4174ac6428daf78f1011f4d16914c3ab7365b30bdb4b36abc37d2d2376de155693a11b6b0e846d79507312311b1f71d6ec032299bce0bc45eea49e67b334944306eac7e9cba824ab59e5dcd53e3f9bdb6f63d8eafc71321b0987a60ee85937cf3f21ac954a66697260837f40c97251e201e33f2935e4dc57d4ad4d3b2102b51e50710b013cc5c693eaf2beef0b3718605dcc9f25e8c67512dc9273c6e1017d52016822457cf825b7464e9da5aea6215ad0873733ff9bf528ad9140652fa55aad7491a30b8c2fbe436eb7d988fe4765b6c29f35375965b3c056393fcfce5c3f4aa8346d36b29fc44b186de7391ed9bf17068801a52c0d77805d428db177ffff0b8c019ebdf39468061d38b16302a67daaa430b40fadd02079dee6822b9e9968dd17b5a76b47dbca358599247ed0e746ae1c12bb66be9a466a839522f33f9c844d28b9920af6466a9e1dbe77f0b5b38ad47f5f81d4dcd3a14f3c0386e77e10fc570ceb9ca16b608720185a0a4e3a76045da49e5eb2b32a728eadf0a56f652226385c9e6070235fc3795e1596a653f2dbf1ea8433a446c65127eede0701c69cb7b7500a10d1b6f166d848bf62f5bd4dae33f16e1207db9e340b84220ae3136b827f6d69a58926f84c9cb91532e0f832883525d49ebdb41ccc71dd83c4769b38cbf2a18a3a4608f177210c2354fea743b04c70104025a6cbc020d936c48ce804ed71d98fee5ba7b688561109dfd7a1b48c6cc51e2ba5957bb162098de417f10ff96c2c64187df1d51bd33ebdba9e06b9deb9c71c693b416c8f6512a92ffef2a15f29db5900d49aa65a052bd4b708eb3dd79202b7fa0d2b34a0844bd894bd859b6ee6ec7bfaae12916eb2137db0a026d8f0506921c50378f0428feab746b7a1a07958da98e71a0e4ebe45cbea32de8aa1318cf8a7868e8b7d09bbbdc744edde3bbc10093adf4680238197d1ad5ace890707af0c21ad53a29fe6e98d3db08059b488738467ba7059b7f17b9c9240627b15b49d82a79546b07cf9be11b57b2e3c8ed4f8958bbb5307cce99718ce4f170e5bd9bf3be24422f454774cca7ef03a7567b21727988879dca9150ed9872f6030ca05e21dcb91af66620ab51a6b7d3cfdf7f5b8877790afd8b67a05b45d57c08989248f129a96b71a9039cb9d030a60b08800cc05743a041dfad89d2176c18f71acc355e61bb6dccf8e62f6c62c898a1c9fa4e53cd345dc2536c5e3460a5ae722c4da6282158dcf699354b182181a68e240ccb95890c66f0429c6e740e38ef1aa504301359be086bf56247ab5a9ea0eb167aab61c8aeb234b238aadc5f4ca6ce29b61fd1b1b222b63b48580c0de813deae23d997f246c6c468f5bbbcf417edeb656431a9440846d4590224cb71a047cb3066ab43be0fb736e544110e9d2e4b2f0ff2ae1eaaea85241d3c3cd57478d90b640df10f1540053ec9db893ea8e07655785fa212bf81c4ddd1a4419ee24de22bd3caaa2a207d1e79f1ad46fd328783ed688377a5440773a131e3486676c324fd080b795532c65276d144f0881c991ff6fc24d1a5ecc5b312a56acbd402a9e34c82fd695b82b3397ad196e27d385247f7a8714948fe408dfbd4c582f50c75b5a010341825085833f2666777ae3deebb5b520fb75702e9fc179e9a8155e43b504ae7998998f79efe061965a5922cd64d49265ca55f655c71caabbe83d6a44bc18194f3b8170df837c41ca3f62f155e02ea4267174cf17c937cce5f006ac8875a1aaf0b904f3c3f7df186dc5eb5cc9645c543caed87b2bc90a4755241c6d26b2fdcc2c07031e8d255f0d9bd725d38d87786cea96ff130a506f195816f5f64112e9a302486704d46eb0d9944e100fa4779e32c6a9e6e7d98b28668134ad26064185778dcb165ffb9193ec6f54d7528c545941aab406e03e165a0a16addd268a72a70156fbe25b60d018bb9af7a005638d2c3ee1a783975908337eee470a6afe6629a386841c1ccd34a8aced51df8f2d98a2ad4cde837fa6e383143109d3f30b5b1f4301ab1f2e81fc30717979a0a5cd87d19a34289498034cceadffcdeed9ce1f28f64004aa8bd805c14e089143c641333e246879d1c08a29b707b26a9b07ad1b39b70d5391721b30590e07f227ee089598aa6e71ca3163dfd93ce9b1f2afaf9f8d136032f25c7669768ef9e6bc57f2ad516d8f9653318bd2ac027e882bc1d7682964e63f2b0e565fdef2be157276e23a637b9b115ba6b19bec9faba35c9049782287d0f4d1688c1be091ff394b8499bd83f9d94b575d43080244a05807f3e05a338920b12ab8461dabb8002d5648ebb98b34a32a82a03e95212c7d9c282b4b34060fd4470d2b2e270afb3eea1a7e4579d6c15e8e3b857f84573cebfbdd5bd2a2ae34a20e38b4d58f72928994657387b7c7f3ed3f25af7cf0f22923d8633c3dc12c47ed393c200840fcb0f0d3edc8827989157aa2da3ed0e775a9d216f6e481e21ea139e15701721322e5de017863b578624794496471b4fab832002cb3b59e1bda5f0a1edd423ac4a20fc57fde7aec0e684f31809a038d369dbd639b4bbe7a93a81dfda635813b36a30b6863483ba8aea82763d763a272acbb6572c1c2c096be19b2a98a72cd9b97f3d2e37528d003ccaaf67b7bf552a36ba5a8d0bd38d23e8732aa3aaaeb3e3a2cc9201b653aa00fbd2ae44647255d9013640fdfb652ade5c0ca736a48c242041e47505b64bb5ea496494a4c000ec30c7b88da94d68dbad71c4049c379c941f7cb67ae614baffd3aef0ab1494f359a7cae4956fa97000e27a56ccc66ba15488f4add33f87d95d3918d89b8e1e373062d460dbcd09174679a908e81d3a9d0f8fbbc4cc206c565bcbda02b00a98967b154770f5c15547986758a77f5e253347533120563b9495abb0f9e2f08b7bc48bfb8be67b1beb86553c464ed05e9eeca8498d31a3ec6f3d983c84c5e55b02557928e32393408a8a12c015f651ca40c4fb29c82d2c635babf8272c418138ef340286000ac6e3c20187d81b8344a5ddc6bbe9debac630263495f27464392215943c98d39032b1986414cb1d1693fd6a7a39012ae479e783cfaee6cefd4e8467634b02c317d732d8dd1aa712d5dc236baf17f0d5fd9d5219d29ebad900382b91fb13fa16bacac73de9cf64cf9fdb2887d06d606cc9cd9132be983098578dad89680690b7e6d398145b13fb837ec67604d12a2650fdd9157fa0aadffb4025d4fd38f7e5224776744f0129cf8751cf84f59832eb3cffd4fe62575a03e52bab025e0a73d8af7751e8d00fc65c8eb4abf242f63e6fc4b4927899304fc95b91516f405a2c2b4080d5520494d65c19d04c3b80e44b1643e3eba1413a587fb158770491eb2459690fb47cc8f8ada879ea4f96dc7afad2fa084cdc4517894d65d0ee7f47a372f11b751364a0d027103e0a5e7b3bfb5211e86a198ff2dfe6fb21822a8cbe9dc522d076fb7f8e3cff8b91b2bfdd6fa4ca0fcc2ff30c3c25802de84952e4fda52ffa4d0962eb32eade10a51395d65033e4cfb71daad8b0852e8ec996a43f6cfc242458735229d5e7f9a502ba72f33d771d39889c24136482881f1e563f8806b78607483fa7b0257b7aa0943853400e990220c66054a753406d5b7fcc0b0310ab71eb474361d2d4a6c2163beaf6843e809fb64db734d11ab1625cab883902cce593134e4325c0049b89919eed0337965e37c334e5850e109d440ae43784577a3e67879676ba58cd322d26f80204f05d58a8482bc0c7704aa2177670d7bd3711b6ac2156926c7b3a2c6e8bdfa0721886146b4e78d09f1fe3d339e48a197543fdf87b8235d3366ca07846c91d6110538dc67fe7472ce2a6a9655435426b0d5b68e1254921f456d0c0c357893cd06899cea8ce073c3316bc0f1449b0602ea252344dc504a6f1b1fdcca55776bdd193f66630dbe261d143960a2b0c4bc295e883e90eaf0a6905aef6df8b79c51805ca8be6173ddc7a2057e3294a37138715f1f9c8d14eafeaf15a3eeb9ec44146535aa321c81643dc8bd2c1ec419069b4bfc9b30b196b1255c64d525c78832b89f9228151ecbe2f2d4d2d17218cb638d59a4856dee4300688dc1ec49f0567bff74ef274838c8f293dcdf295d20c49f953e2e1d5a8dc5d2520eb997074a3cbf5669003fa5856a624fddb6a61123989262462af9c33fe4487c589cadaba6a21f2370d171a633317e69173201550f6345c5ecdd3e50337c9f4b9ba793bb73cb54d042d16da1df7bbeb08d1520db3b647b89537279c2d5942d8eb404f8e1689f84d107e173b130d043081ef58d29f52977ff9cf89062d59c02aa6b43cc25c82bd9790050ef54eee672eb778ecfed015926028887ae3beb042ab02af7d7d00fa5b178681a483a387278f540063a402175b3a46d81a3b73a7b9407c04343b9b2aba9c52c092d20bdc5b71dec22a622791d2a22615d56333f333492ee631f4402adb95c7b68e679d8579dd57f10cb9e5061ccc2456a361bc257d6bc5472e3ad9a5ff47277066490aa139915b514b63b94429f30ba18867dc59a188b275b27a24589279d02310e7ac1cdd879bfcbd4dd490c72f446326dfc564b4ab291b99ac50c7e0528f59db76049f343056e786069398a850a61875218b22c06acb6750f93edb5dc92246eca29299abebd32c819dda715376db9904e803d927d43fba9348ceaa2851f3e9bfcd34988be8c39756a9387d0b32b09f13dd09e4a3d0791b0127b6cbf9c0ce53c47f4d1363fabb26a116c0f1bfa7037989609e6028852c31975a8afdafe24cc7af53745ee2341aa7a1fc6a37ab9baafe5ade509b1ec82f489d11221af67e3355b60f31110e00bb902ab769fb3773fe785386bf6ef063947dafc2eaa5b18d7a876726533fbf7149c47d3eff6900f45b05ec257531f38952437c71171c612e9aef4a0b9bbfba38aef783d1d8c513171ad0cdaf905287af25f880d7a34b21ba0f59250fe5ac9d737424feae76e7f6a9006699e9469e4f7026c4ec7145b6ba695690c449ce9ede8e38bffe131f01f89b7f1b1cff1e3b564b96b3068e2b69f1a7a66b5a9f9e1c6a1bfcaf2a116102519aee284c982737ac17df641232df2563a6a1409f3caa85be12db8f95bf4160b2860ca5f148bd6d9c8edf398b23d17758a11f60f1eb3b74475cb0571df5d7fb97d22923ba6a2b33d189ad240382cc5b6d0a0aba93ace998bfbe618001971db5d8ee418e59f731eff76a478272b0fb1364f572ff60af13b5f612591bb7d9f58737fa0902396898c1cba929a7cc21b949b0e659ac29a4bfa06c8cd3df4fa222425d5716e7836af56f211d271d6bb10498f3f69f86b05272a735ac3f0dcd55996cd34b941c5c99477605552375914b98dc863d2c402150c0ced855a1439d5af5813b0d269801f5d23a44504bb82e75f28a4980cf0b5965c85ce5490b3d039a312464867f2dc7e985246cbf287b94d8f795edd51478aa001ac253eb692d87a632bb772a9b83329191038f3f405c9d37d1d42df57482feecf5a9a0cc05237664ff9ec37f64563977fecc46b946c1051fc05c6723ff9f7ff201813a29620167c0c1c84ed0e87abf6e4c493418bbed52d52f23b8125ce2a1638ede67a02f02943ffb93e7fc49d5f119b399ea609827e768af83780c1dde16b6d6fd350b2cd6751845d3dbea1b695bec68c961e5339490f794b94f967707db955fd7343b0dd52bd31f9b9d7dd05ae7fab24c1b58d7558ac24227a27df1ddbc5dd359e5b008b398b6cd2dad0575ef682792ac4b214e6040f5529a231828ba16b41d16390e2674896fb77a6b02ec082d5ba180ccd28700bfd376ce336fad8eb5c1067aaa5f111c807458dcc2118559a646f79c894317b0c1a4efc402667f8e1c3b775c1b72c3196c12e3fb9a1fed29a28cd94277674e21dbc0265d7b155621106f0c5e88b476f163933d579dfedfe9f3d8b4e98c236ffdf60e4cd8ea9be87975e527f654f5fc391751067176bb27c263bc537d0fb7fb3de573ce62391f35ccd77bc301b184ffdb1660acfa1f0b3fb21d02e875d0a6ba4b762b22cae9c7e543cdfa13001f367d7aeb39dbe5280774398943b7a6eddf864b46fefa7f64faeeae146adfbeaa7761865454a85566df433b2d73298b313beca5238d22e945b050302f6ea9155642ccc300306bb7a1226349f988699b041d1a789cd0ec9273bfdbcebeba8fde5987c6f6c2c56e0189958334dabac90199326c0a4b581d8297d5f24e730187c12f6ac9f30f2920e0e5b709585697cce58f57da71def2e3b21553488458fb5a37168a1c0b2057a85f9c60d37ad6b35fc02ee83baf4eb1a30ebe7aaf99a7441ecd12df80880b4525dd8362979ad232399a2f3371db6d83060e5f719ed80ac9f2c7b1992162c2488167e9124fffea2960451ade2c582e72a9e80003917d79f57012323ebffdffa78be765d817d71ffebf22f5ec8b83ea8bcaf02599c1fdee596573edd3c927666173a3c19688ee78bc81b383cdc5fd277c412808f7d26341df50c5767f5ea31070616d01eb2bd512cefc8cc52700e5e5a026947a28327c02dade49fbf8c1486175fa7540eddb492b82acf04675b3769d7cb5b3d850f29f630b7bedb57599698a5faf5ff3dba1a58d87320150b18033b02c5044d817952ff0651b0c0c2f841cb32a6b0d0f52e37d9e494d1b5d0198aefead6a504f74b05985376260b616be8d0ab8bec1350fad2bf7c83911a15f4cd6be0ef982f34f46e15e751ad14f0131e3c80fa73a15d4881ef3d9766b950ea6c6900f4b7c5060631f70be22072ff298b33af93063f2368c38b5530ad13c553150e0d29812764e8b69318a03d6cbc54797e0357fda2e47b27a80bf11e4fd75f443641aa3befbfe5430525745efe5617fd6be2929c3edc29ed371a952f77a726d5ec82ecc22273476b989fe753cfbe063c52bd179c6ea5564aee44e8bf95e5ff3f302515e70f8f9bcd109c61b889ce81a844a549cbc45e527328e507bc1f12447ee7ec50c058d6ec949a6cff3531d1445348c266e2d639df9e0b0e8bed6d61cdcd72efd9851b2fc79f6f34fc3e13b41b3e4e4e1869451a7e019ed2e796906bea4572258c86e33dd8180f4fdd0151b586516d3c144bcdea2e770614bc59deecaa5b28d02c8b32aa09197e0437446846094eb9e1ecd7617deae95235e86c98deb8f77108986e44149889de9e8795f96bd0326f14f9f71e3c3688910df0f3439cf312060c6507ab0fe0da4e42e90995ac46da3d9396d77c667e45501523c19408b314e4ea8a9652b2caff98fabf48cc0b4f6dccba9dfa1641df6a2cc631fd7c25e0292e41fe1b18af5c089971f0f6b57d532a766c770540b1f89b7f5b467131cb88bcddb8149e53f2f96e1a1d630091c96c30e42d19076ef43df5c89b1e12d1de278cf7bc9d48aa2bb1962fbd56ef9ab887b149096377d55a643a2e05fedfc674cb8786f43a23ebb2a3553c5ab87070613b83b67210e213aa02489321c46d6015559876284042a464967c458422beae81854208f7b05f5461866e9e394561a465954d58c82510c79df04879cb3c881bc93046a67425d2f416856598d925f01f97fb8eaac24a7359f985273354ea2785ba4c42c299e260f753bc7980362a4336e0799b0853ef810120af2c2de4354e65a522930b7ff240b559ebf45c993672228be112276781bca74a001319f2fa1daa92abc14b4bbec13d2c75615c3db8c23fb5a7197f50b4c34a1dc15f8352863dce0aa90ef95aaca102902d5d60a21985159f3c76985eaa36a64077072dc20d9f8ad582eb308bf9a17a3c59c96a76319bc2701b4134ada633da95e6fa63daaf2e669dfdb3bbb1908cc7c59bf3651047b6e20e63d47123197196e361d67f10764f49a6a7ceb798a11907079b7553f96f17e0a837cff8240adb4e3e6d32bd1060de392ec818839209b21df74b0cb5d6b5849bfd51abb5fe7dad6bb535b9ba59285e8ceef59654e9fbfc00f851089cfac2433639e222a57d6541f0adc5b9a822dc6790776569cd360c164c3859680296da60d0fb58489dfae48e83591926b39b01c2e256437ce9c7e691436d762b8a539869013454ecc53314e90abda21a1bd516a980af84e2bebe2303d9e0815453404d83df1250b3d48dcb47c582a5e584ef28933822e1fac5ab22f68d0cd604a908e5824ff0dea437ea6a89643c0609aadc9e13a91573f6d61de308f7a283c3a58e3d212585863209c801ae80cf0d21e1fba7b7f8eb804fd253b64f08982e31eea307b207613c10d926c49cb48f56bc01c46104c64a5f3e7f2ac2f63496b06ec7008a7b609e90c09171bf8f88fd529e0f6a1f217bdd165d7f17ce356858172a34282be6c0ccc4857cf70954f16a873274beca5804f2fde8ec009cf6bc97c26a907b50a8c7f574db0bd64e539862707994f87f3902c60b7b911233f04b85dbe6a0b25612dac060263d85eb0f1d107a7dff068e2759150dd732c51c98beb7a7065bb77393896d4a739c83ef2d0394997b0125094da830d70661e2dc5a17cc1da82f532dd30c5f73738720a23c60a8e4fb546ab59f365deadb0190f4f0c48ee9ec4a68c5e7303dbdd989857f8752c80dfba9b71f12a940769d2650eb9ca919b63b3c89a8b070b95f2f74c85d8be1eb3329ef5e87ec9139a492ecc7a49d6a33fc3d5a3af7d1a56add67409e61b08795e497a3da678e540a76c94da22129313dfe324e34b14b1d1e6788998cac1ecd4dffd9c105745b6e182d8b24e69b01722e0fb69ac21c379a5032fc80ddd589d7d4cf8f18ecd0118ec0627527e1336d7c07da70340efbd50360d7f72579cf693767ff52853bebb7db48d52037747a26cd38f231dcdf0e8dbf622c8ae8dd3e573b381134045df5ae02925c6d03f80d556e11b3c5196fa103a4afb06535fa32eae4a209d3295a1eb31264d7f34157b201e0702517b23c0e2be7bd7055931db7aa6bd1846f8059121890321c5d4948bb31a8adff21ad73cc6c8646f20b3cfb5eddddce58fa84e01068e65cb19eef20ef959558b9ec51782c69b975535e12b11dc487761d631c543d08dae5913696dcc15127c8dc0ea9d3fffcc03075f123cdad3e6bdd46f7c821cb82ab716c91ded66927a6be531ccb7ad6412faa6ea33d347412561632b5d2acf2c4c733243066b2357a319cd8d1e76eee606015957fb18ae551baa24e2de2f31599578818a36e810aea8029e030b9b795966fa2b49e80ba4fb797af4b99efa63e9050480a247faf96acabd5f3dbf69cd29332ee709faf388c1a5d5ff4e5354e65a416ba1192553dbd024282b7facfcf60021b55aac1ddc00b3f8dcf4b24237be9c99364b0ccd7c712105cdfe37690aa8d5ee86e18484cac479f5ecec40ce9b0064dd661d6b3a7404b55cd0332f179b101a225a6806e92446011fe4da84c70b27808b3480bf42dbcb3252f8e6f8ca35dae265d87f20f9aac755ce60ebcc279f809f5efb7292a57da89a511c3c1e1872a1a1fc55b3d406e0a47fcb05575f37cde07c21e5df52a0d24fbe3ecfd97ec4cda604ca0d7b77c11b76db138bbf3abf749864b510cd4dc04a0c6571596e4c10a74e4e4c597b41e09978045771c2579c9e19d13fa698b9c0bd179b2a5f2ae004ef3e05cea4438c39ab54d287bb0922d8ec9f38fe443c7faef4bb1d34b6317ef50c49da4ccb709839e50eac38c681ad6136b50404e9f5a30e3d0403d89a2fca3129b0fec1598785a66e7811ef29ad8cc09299ceb60778b015c753edc1fcc8cdbefe7d485e739701ee982c830fb2f773b0b921e2601bbe4900e9a7fb21689864f34b47d464e1bc3a7e2c9c6b4791a43f276889f0490b2eed517141cee8ac0aec7db27192ca648af60d272c7250c5d8e747c78c2acb7b3da3b21cb6b5bead3fd946fce72297c5deef9510369b49794ac664157ae08dcfb1ac2c19487dc0162b2de3704d3efd1cbac2d2f0062d627738c783b0e3173dd7ef0acf0dc4e915c9db332a48879e4e59b44ca19b106c108f44d79d9953e658591c529ee63fe2c90b6109bf9c8a4a0b8d15d83ac7be285ccbbddf68bccbeb86d8fc0280e6fb76ad8c822d34c0259b13ac4745da735ca5da57930d478f7ddca28dc070c59749966b190f936441aa0937a6c34e0dd5485ec972450a6a3201fc7c3665785e3f07a9989bc38000b8d88d1815e794818a7b494ced0ceb0ec9d562ff5eb23eaf11e070f2818366b977ea238e0b3f7409cc6a0b3aed65a72f069df0831146be35828a1a21c9f95432fba2b7993a426372e83b024e20aee91d83208217cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
