<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a998a5f8d82a718dd11e9e4d0d404c5432b295d58a3abaad95105fe6d2d71db9040cda4698ae64307ab3a7841b3bc3f62f2d05bb7d9042266627267de464a6dc9482a331e43fc7461e6766d426da03a61b7fc24cce460e9314ced1e883d1e9dc99e40cb50f28e871f0794f45f0e4fece6beccd1710668e04b0e6bd221f0531ee78bb425bad39929810614cbcb0e54127e9ccc4182f6931af86dac0b8af162fbf42af4827d96afd4b4417b87df5937e49a2015938e6356f53ef3fa61325828bb386e1ac153f631845fd0f6ebb292af8ab12b56bda83062d43ccfac29ea70797680d3e54a477398bb311097cabf5e50d72ccbf4c176c3b7de8ca7e4779b910e3d57c583b6e23c267bd1ffc867fe73baf6cc8584a01c2e4cb58bfebf5b612565d01746f8ecce84e20ecae60dd3589f9dea11b85d122ba4f9b3ff98c31dcbdf5adcaf379c00db852e3a46551c5b722dd143ed261a77429d0cbdd6a203107e0496df7e41d2d896401ef27705c109997cd9335e23fb6b8c03fc0aeb4ba106809e35763c8ccf451cb9dfad102803df8c9563b2113ff07d30ca7a03f96636ee780227b6ad9455c44b28d97b5afa1e1afe61da6ebd817ece0233c4c69d95d68646eae6618cbad7440a448efbe065f2834d11990609472b448aafbd60b5768af940d8e77b2414002a5e2bfea2bfd51bf2db3b4925f9a952389e69f036a5ecb490ecfbf3b8b467f5d47a476eba61b576e4f5f2e3c09ae08ebce67599d5a55a31efc5e4dc66ddb149071195ee93e7b5a1819664806028154933c79431b1165a59d1e58746a63119c2c784f971ec4e3563f6e3bfcb7ceba4faefa4a74e2fe7d8d2b71f71fc7db4c12eadc748932c5fa42ee77f10c51e2f2fbbc7780153ff10acea053a063386665bba92339374ebaeb042fddd55b061b4fd109fe9b9a858376773b5e74dddeb9b37f4117f4f2ab635341c8ece61bf69fb704efd8eb5fb1e016db56bdf2c6261655dd613dc74dc4335e35e33c755983153e77162a364c87704ebe10861c3850037054e533778a509c1ecdcef889ec9f975826f6fd7eb14f7b3b1ecaef2c66f38adf82dabf1cf5351618993a5c4dddd2ed2ba0102495e17aafe4232699282d6be0cace68fb28c24307f12a107711a0a47da2e1e30f27c23632397ad85cb61e7331b86ffb3b8184166220e929c90684cbffcc6a4e1748559ef7f8685466dbbbb7ad2e0164287b0eb8644730cc69d5c6fc5a0e0451a536e3e5eb8f14867eef269bfe6847778872935159efaf832deceb2620a19909ce57b82ed0fbbd3df8471c178c447ad141682a19f9c843e09a483e96d070987a9c12a552a3843b615cf610ca9fc14531a90b9501fd0fb510a51c84fefbeb94c7e0e64357bc1ba11a93517fcdcd5611feca5a867d615ce7c207728ef64642e4a4729db3ec4f488d06b788a5af6c2afcfc22ae7ebefd29c22c38cae384716a657f828e1d0ce39ff80e320dc86df2c6a9458f08839103211c03894c2998d411584f3634a6ac3510248c8a0841142f809e37fd9f4cd2dc1a3f0855465a48b984b3c23dbe37f94b13491326b040eb33bcdcb38c9b36c4a7760b68081282119c98db3b8233c89d50eb79489afd76708a3bb85c3c0fb5fc71d7b7b34bbaeae13543b7d8bbedccbcabb067198f5af72789e8f64caccd6196025a5c3905623c5b4f6cd7b077b3e9aa4ff89aecc1861db5085817ee2d4531ce04ac6aea073d9cf906a0ce98bc41664fc289e9b377d516a87b65d29b2d28616f9a795bed7fb278bd6bea8160b8e520f1b8ad7b5f3ffa2114e696597adbe1566c5f224b42b38b3566b52add5a48313258dce8d8d0c7bab84016466dbd04a06ec99ac3a1023f1978f22dc53c6c7999e067d9ae024e289e3ee060de50cd04eb7d0b5c9eaac3d372f060e96ac9ffe70d70c5201f4efb9c3c3b54b0779cce8560ae9dd3487249f5a51a55cba93fa64c137bc6376ccd6e6aaa9d9a27003b3bbcff029fa10ab363c35cfb47c0175dc30184f49c16851e50c76d689f1ee823d5d0f1f5bc45cc6f663c232497a9a4a78355ddedcd1d55db8c5ee9c8b5cd647244bac38f8ef5431ede2ca8187f16ec8af6415ff904b26b98169eb1dd42bb6e03e522d8c7e1121a006d0eee631d9c5daf56d6c05f46135fcb62cd0308e1c5b87982a73431125486e0c4b6d2a9a7276b4da0c321be41f960dfe3451c8bce95c5bbd438b85c29410a8d3d538b9ada228ee83e4da2d2a8bd2e07d3b8f3c311514be15ffc1f117f82af78a67fd291040e7966b350ddc95595d3909075af3c39d853708e9de067796b98fb1dfbde0f5f111c14cb912ccf2a7a28b4ecab26387866a49040b9f488b709c108a36117bcde57beaf26bb8cea9bb80c954b35180ccb4dae2797b54a54753125afd70e6cffab9b6d0fe222e1695328b1d0e15c8132ed757cc009bd9c00f325b50c97c1185e09d416ec1170172e78ddde24477a1c9be1c2b4790af9b4d4fdd0e29cbb2ae2ff0c39b917fcd4d5b9dd30e14f3d3efe6c7663152db422ab3c37102ed94a570200e93c4599b278412af51fdb5fce200a873ad19f5cab3795a0c945bcbe360e069a97c05f4de3a4c5438ffda0335917434477509bb3a1c85e0d7c3cd9c1c00ed8b1792d2700bb08faaaef73be4f2fc514cc5e0d6e4a32128d8949584994820b776cc77e5577467be8052660ee09be40244a9751173bbad0d87e0de49284cd448b1699248c67e70e15176dac0e9532063ac6fe3f79beaf705c53e811c4e9d30a4e3a616a5bdd717523f005abc569ac50b582985a59bd77cc74152fd804f77d65a1635d296b04acd83352d5e11e2b0ef6f5c24aa62a2d2db205232fa942da74302eec8b02cad154d9f291c31efee648c52fb6bcf185ff31ebf539deabce25b353372defb7bdab2121ce531184932e8831f10996c0de720f69b6776cd27d5161b00dbc7edbe7e3081ddc102b3248ee672e5ca7f7ecb4a21c9c546cda597a2fb7d2fece1e18f4ad35bdcc76bab1510d31799b272b5d0b77f22d7acfc398576a7c6a31f58ead5835205869fa69bd085694fe63c2b340ee697d7d30530a313c15c3c33155e0170aa345e804bc85d1b82b2c1a2147a1aa8745984a675449bacf5d0ea25aa73fac9d8c1163481001aef831ee80197e9eeea7279ab25ebfab7dee81dac675f9d8e22ae8ca705e3f2d13a9227006b7665858bc7aeb1ecbf324c75dba603018145b1e5c29c2f1faf9dd03682b342283235a779b6f88d4ba4e8f06f2949ca0f4256aabf63ab19ed6d6a9d3ea915b3efc06b0c2a228d88387dd8529222661e2c46af4b1a90b8b5578ddd83a8637000c497ce9377ff25df6622430a7a9fc114959f0e9ba57b1dbb3d4995c46ddbbd99c47c12020ce0c8e6a74f474c91d7aaf3bdb5435d31d4036e03f5302a9f9bc54865cbc4f77b962ab60236f5e39a89dd742a27bf773685cd9dc68c1edd1035cf4c88d31fde2aea1599700140655dae3c30737a791bcef302a0fc854f22808bfe8f208c405c77af92b20f273846a94291cf1452fec4f4a928a1f461c86f0f74aeb42761d9e347a1736014835969accaf26776e3ab1953af987490003b36a33b03b990e3103ff664bb055507b49b268d8ec406058dd2380486618a23f8d76440e735390c87012ef257795077db3834c8a43a9d40fda1fe9b194ec8be320d723880e94b5276a87b706ce994dc810eb60f6bf727a4fe01b6a1ca3cea019c93367f94070dc9609e38e200a9e0935d77627a1f042f51670c877de78aebcce2cb06cb7b4c3ea55b6862961bc8f98473ef512b4f1c6f54beecede29e574bbcd031a2e2f995d1d9f2c2ec518010b225f642d2c377ea4cbdd5d30c23c784e237a7a7efd9bae7a9ffef697c496cbdd6fd94cff6b576ec7ed531b637d6198f522f1cf98e97a2e54509dce00eb269ca90c8f1cd4c36df93844a418cb7ba2782b153dbca4320593edfc89c2bd29c21f9926719b5b3e9a10197a3758b70d58f3d2ab6d798e6863e241eb55ec9af84f4ed164f29ebf0ba8b3432f2005473ca9257c438066cf80bf2ad4cb920d57d399156689fed1dcd6586cdf0dcafef0714a6306348a73624a317d3839bc075611afe63db5c9dd1932606a0c052213baaf508c8857e30ffa279426fde651f7f80f9230b1183269ffe1e970c4e119f6a6013e715b97ab704bede2fecf288c582d9f0d6c6bfc80d1f801a8339456ffd827e45ba8f05ba5a8eada6f8bc9f140c1c57d43c67d137fe576a94034967163b07f93d98c195d213ba1c9ea95267c6ae13ab7742064df52a9154e8c12f0082dabdf898c53c7a3c8c2cc3f1f18ad7fa90d685bce6a8a8d82d869a51cb18aca84134e09a77c8daf4cecb7fd6d08cfd83666e8018303f2380f9a57dcda9c410369477e7a263a507b638324105d2d3f2a1b4395ffba27062e1470b8ed05fff3b2fb89aa546269a03f070eb8e34241f0c5adce49f863506c5123f3f3b0f97efaf9a5d447d69e51dc9df99452a4d41553f70e1de0cb2507aee9fef9ae4df65c1d952721f81e1f4ad9a6f55203c86652bf31460047c19383f2a98584e5948f07e9343db2c5d12d30bd16904d91794d2de937e83eeffed832b0570e5fb96203ff1390bd49ee8b93facd20b468fdbcca6ade10382da129e2ffe23a170f359aa54c37de2530a835d5a186a928204c73c75ed321368f807cc8c4ce9390522bfb800c70689d09fcd021911402bdfe512f9e5d553458654e016591c13d06f812d33bc0b35b450d7f78cf0b0aba97d4291f603d5e22d53bd7bace2b22e4e36543677d4af671955ec966e6ac9f1ecb25ab10c5608d3e8ffbf871f9d87e6849d2d96067c668fd8dd859684c692b1aaf32587d3b0ff27686e8160c7e134c7895aa79f5b254d630af6f3361cfd97cf844c6404bd52c1f7bdbe94ca5413ed012dbb52aa22f787335dd82c1969d2f68b0bacf8152235e6d9fc159a755417c7eee88892a85a5021c8732c6e34f211e91e1a255004dbfcf2cdac9de676c3a6dd3efaaa24b45b96587449af40dc947b05aeda52084535e5a4e4a5dde5ec473c5727d51f9efcdb2d5593dde372023e1f529c2bdf1e98d04903d2346a054b2f093ee4f9b8c86bee4cd2742146e6f1d8b6f2af718c4679d0931146cb9834d2c9d96016c2fedd9d2f55071b617be9a072e3d58469534354ed646f6e3ca93bd9125fc71177beac4253dd131324bdf9e98ecfcec7d33099c0bd487c6db97afb6c5a9c2965ab26e50196bfa4d84b91b6f8a58cff5bc141207da896bdec6a099ce1f8a39a292d95f1583a692707d2ed77fefc5bec8980eca3977713ace1caa96033abd7679e51f7ab06efd87dcab636b647402ca6ac71d5586f1954b6d63c28213050dc5c7d0fba5621b3350ab924730eb88e3d44b1ce75f04392dbe00e66b1d729957425fa4610b65731f1a6fb44680d098a23f0ac21e40c758ac4bc582fdd7bb514bcafb13fd83ee228d79c78a21e2bc0c2b30000b3186ee6b97300fffa77ad8d0a925da7bbe0fc09374316d7f77548252d9873d63fd8780d3884272176bd479b260c44cbab9f91368c4b14bb287ad7aee72953266e4e6631fce6d67edd764f008f912e4b7b6d48635d6f1589334d255c8dc7f51a494d8d9b44edf224682d3cfad0dc3e1a3f01f7e46b6f32c61c720e2ae9d3d2064e6416eecf96438b5400456a325abde9a848cfd07e9873a7c9f54b4a1c5764c268eab1022b49b6bb513bee694c54ae2a699b54453342eea5d3c3350413eb9caa2a442388c70cafc620720d9e7c9bef11101e319b37276bc5fc3ac19ca7479a558ce7104b565aa312e2df8afb83a4af5e8a10869ee5f8af7a82b0c681131ded5553fdfe3e2e2a0fc8566790ba87e79165b4347a5ab4f3e0f81f66920e1986dac9dc64a798d6f6dc4c1f849934ae0df2351db8c58d49ea3ba9d64ca6263160a8781b6e52872719f7286318701a83b8c4d05379a013f707558f4e34d6d5401df92455f33fa93ce01360ca50cc98a29d6c0dba496ea1ff5be4967161cda4cb938c9786320bfdcc58f10bd430e611e32cd17e5acf2ab4caa56f3df375c551d15135818014ec23a87628a73bfaeba51caad0c3bb82cce25777252a0ac9471654ad5d759fc86d0bc6a8d95ded7bf17c32c60f9188baffb48b0a06fd5830cc2a9e8ffba900ea6b2a353b5abfb4a01a38ed936d6f592a7b20a4cb8667f1cd0c8cde45513ef13ec7340448d96582cef8781e23c9340cffbc368f8097fcb08441a099232c6a3a553f584f6c24b987e398404c4ec1d38e3819f05aed6992a688dfc17afc2d0caf7d658520b6ef65d49a631fc4bd837e90fefca49013f7b027426e239a7f124a0471eb8eb7f1ba4dd6f2fb83f7ecb4cf8fd110f482fac329bf79344e0ec85698a7b209d4583b033971bc97d4fa849f669786b7b5113dcd15fd397a68a2844e6b252ab788ca25b1b82fea7508898a63c08fc9b37a76d5aadf2ad53665f08e221f9c8c40d65cecd2570c4f39c76b5c9985698695829c636f390a87caa54f6848a223881e15ed24d279e3f899a9ffbfe9c04e409bc27d824f6a675f21d40982a1c17a710b33f69dde9038b2ddefa26f468ec4a3746c9599e1c8054e8a6955950f2d4b0e4aed4e1cd7e672c5c0bf76add564d4150bde838fb8d2bc4b17d1a8c4c59870df8dbde4c2da8fa226b935d0fd8869826fd093aafbc9622befe8ee3adf07cd8d6884b4312d5425b79d182a6cdda63e3322191d549ec05e81e8adb25815ccc84fa64b6c0a5fb0b729f00577ba58c647139d26bd5e011c95510b0eaec82855067c1faccf692ec9282bc3662206ce2d2e8797fc424c7d50ed58972a9705441541a4657289a87a44857b19e088c61d4ded2b52d1e83172a0fd7c910cbfdac76c7a8b9988a8b63d5345644ad5448aea471b5ad09fe64a2909676361640e3993da80d716d1779afe9a37033eb77fc29b0ec2843163a399f1def803205a612145f1692e558fbb7773c97e9e16882c44bea651d780fe56e49bb6e8f2c5cb5cf577cde9c7f0755fac48891613792340b7257bd4aa865ec8adf73d558d6b3b3010690fe09d0feb4411c08e2ac34edc075f2fe0476d9329f3f492dcfe1fa5c63e508647665071f05d542e7eab05a455fb8233f68a510a107ef98804711f81d85abe6bb841f5553d30970030363a9c6935eec138d51d9e257f8c793455fad7b9b9d904f25f9f588e20b79849c815eefe6c588649d3faaa632a0d512b4d0eb3463f9986c6c9e1dd33197e7bb9ac8f3a3f814b0944d154d7fb056d8f987d0596305259c45d9e90b1c205fce8a2b3b267c390465f65222ca15159872f42fb883f8dbe09d4b155e88cd1718ab52f9f7a57f1bda481708421ab415ab7ddc09d2d0c8062fe8f9747568b681fcbdac1097bd78ce92510b2a35ede4ab29f73478186b18469cf684ac221c4cf3a30b9cfd004870b20f0006a9f5fea9f2e25a57af17e7efcbee42093f743b87f2466e1ef57af678d4d7ca208f3143b196be14b8d347c0b1aa37a534915dd003aeaceeb4f19d166983a442c233e96c9e4a475af247bd49dff3653ff6a4fbfa4e18a2eb001a8fc1dfcfdfcf73230af934f5929d59837df07079d61f0cd48722fb15848800dee373444dfb5a1e7d9b1789707d6ca575f557d29cd9ef79e1e05622dc7cb42c490876afef9c5cf32a12c8df4837658e69e9ff9c5f5ee997519c0ed9f349753bc471c1ece9639978a8ee444b84b0d339cb962937fe03ff23ac722e950ea2d7ca93d187ae95c83486cbdcc222012486f32f086e4adad7ab4b57ece84434aff48f94008ff6fe7e06f28054ad269dd3382e0775a23527224d6fd6dc72641694fcb475cbe8aba942e7bfac0d37665eaf360096479d878f4129c355121136efaf4bc5eaa49e3ac901974bdc9f2cf1be8276b22100ba0e97cf58a66b3419309868e34fe41ebb02ba04bd1b0c2a2967efbc93fe301f18020c17f8a555b639ec6768de5272e1c3615eff3602b77cd0ac77de265c89b281282b364e9d21670219963036f4acb494786c10f67276e2db79590e8baf73e171cd2b9c4b6d99e56538868ceeed1b188dd9fea96a3dca32d5f24a769df9f26e3eb31851f0333905dab52f0440a1fb5d58579c806ea7a731468a9c1ec4bf8dbcc41a5a56fe83f8ad87e664c35f7a3baa186048bd5376aee8815d0788301d765d156d9e28fabeff4b5b2a307f34521bf786523b55c7ff654d4dbc30f107ab1e9749d731b7150d619cb931a7488e064298b955c7338cb97fd9d4d860d1211dc5ff85d36dc0ace7b3c50908e6de96fc579b4f6125ee13637534b688d3a3462c66fe2a8a8a4cf6b6d2955e407df1df1f85584def7f3cae97ecf8819558ec555d4816928cd9ea92c591818641108a6952fccf81a1e8c807da9a32bdb934dd73d993bf3324c8440672c3f67fbd4950bc96d98f17aaaff2886dca113921e3b66e762b7dd97250ab78d4df85256675c2a1706ccf884493ef477fe3e20e27fb56525bd9f625480d7ad620d2aa298b0aaa5da5d68eea2128baaa8d21b0f1d5bc3e082b0c93abe68e4b493d9b22e8f1b7eb248311698aa582175f5562832ec6a8b38973f73a279a33cb63440009d4c3fea95a285f3190ddc4ea5a38a79df546ac0728eaeac8b5d2b10d6db0a41843494d6c762d0d3db356fdd805071c09dc6a8e9ea9c4112fbdc47693c4315b10bdbbc46ccd054b05bedf2df6f8a0b93e07e15c624cbc3d508f6d3fc0f5dcdf949fc2cae052ec2f77934852c676dcb6b8865cbb1a3de5317ecea8bac7e4697aa85880ea0e8b91ed46772abf5ed98d9607ddf0f2dcca8a02abe5df4f514277abc13ca80eaae7c316b33c7d789c5efd41d1e42cf9d5d1094b2c8e1c1fc288ea30d2ff3e3f56e23354d05720fb210793f4718e5db5ed89847f57cff8ec1f07a536ec69950fd9b5597ab0d7688349ee5359da509460570ebc1939121bb195df26f95a6d4776b952cda283dab506afd111694620d58ca8897474ec13c1d75c48c50284eea3e4cc0ac136701400818839f392d8f290d733bfbcbeb77f595c3deb95a0fb3dd132ac970a15a4e3edb94f3166f03224175fe930df4052d6f98297f9e2c6f2d45e9cb8a11a3b7f2fa6c1cee3d88ea49ae92a04f5198f81249239b9d2fa23b00f2a8259fd75c29d08ed6be597ae1aa02131230bce4c1c94840787e41161fd9540061b76bc2a553b19a6ae3b876c11204a638ac02e516b28df0814728ea90f6dbb196ab2679c423a429e2372f19e1793074dea2b82574272e0e9d0fda27c2831f5d2e8e14e55395d54654788090e73f27b0d46d23cc9e5566804926feee30a851990b93836ba350367ab43ad4cb170b6e6f57177e344ca1855c59bc4ffc7081602c88c94ae3eac40d02e6b66c720933921681a23de4dc517c1e348e7b4c2debb552a8bb1810f183cd250c3d260dbbc45b14efc528b28258bff5e87f7a317abb471af5e2cf23e4864c7fb513db8e36d28a372e987851aa62816d5aa30727155882e89ecd1ff1411567ee1157b7e00b1b479e4205b5189cf80669e506902a82a689812fec5266955446dcb177f5c5f718da0a2ac68abb3d8fb1e8c7588c9fa0f6e4ba006836eda650bade7c8c3da40d05368d6adecd3faa510bdb2662ab23fc31b2afd2e46685f3c72b2af7488daccec036ab74a24f4a7bdbf443f49ab113a05d0f76d68d7b02f25f42041d52abdf55e2ec3658ee9ec438457ddc80b21080b52ab66f46e367850bd1ef4980eaba0de3c4335d4fe0644ae117613bc3b1cd0fc9dfb74c2f86a0395fb5f7866a2f2c1e48cbe66d7f0b71a0c278f3c86ff397d3bdb8335feae8b9658fadd73c2b96c8928ec600f16728a4d336e7cec373fcf338070c678b858b2feb9b8320f6778a74e1d1e5504e86575beef18e970fbef7031b2b7bb83c05fcb13dc75d9afb55235369a9ce11907451822f8f231eaeff7bad14019d22f51e0bfb064727f513ff8a471d4003d67c3f83f4bf3f5d680597b557f49d32d8cc6376ced07822ee666794f0264c6247785f26d7b538b6a00da1e9b9f7c934c60c63985ead866cb09037d55f0333ad83c671fe4292d09a0d10d24283f2ab65fb05ed36c845e6818ad651cd75c571d8f9559c15150f5e1757c62048d41759da7f8acd3b908eea3142f6538a8b4ed4d70c3ed00e751303d5599ed87a83549b1ca85a2a6592600d93ed042e408238428342d8080742f32107647c565801c2f851a52d7d5da040ec2c082daefb31233b375e3dfff11285213cb326863a56e57382dd5a4d1f28d761f103511c9dd4d63a73832177996b44db243f92283c11d2b3acb85acdd5e1c1afca0126bca8dc4ae367c07eb1777ca89d67a65af2b343d2aa61699675597c61a8da275b1621e0accd8c664649de9ed27256b1fb4bce8c8f70fc3603bc6bcd4ae9125107dd091fb3c61142ce926834698172a1b2e9e61164966cadbc627836db6016d76442c4f9213159021847ab9bd9ae04046e4efc0dc6110cd3ec1093474649ce0f22a1d186eb54637042a8d29df834204d56aec4964e3e9fdbad7c80d734e14728fb648f76ca9e13a9b8b1c4ba3212fe81b862c57a4c3cbc8228a5ffdb318b946e926e8be55a1ab8bfd18cc3aac6f806b77d610d9f312965f1289ce2974dbb954ab39644bf743c7a3fc17a1d77a9feec1a5fadd8cc0ced8d2a8834a008ab26d0db0bac150bc53e83b4104c71c268ba9328d3ce952ae731c121ffa268d5a6c4c71dc01197d071515b3eb942c2baebbac4daedf59a62d3d72378eb9e339d730f6309f1ef05e6e75869e7d431159c2c9b73bc66f448e6825173d4d376dff4a53c030040de45e941596293be76400bac20be9a6c0a87bcd22113e46fe14d05ad8c0955691800024bca6468f4ea97eff848826473f9774d5a3f8229589d16a945da2cc2909f0593f4e6b29d893b9d10b67027e26f6f603a6e6a8efc083f1d5cc9aec14afc9dccbb221b1a492590d290578b676c31ffab299cf097ed4cf524117a27b2b4a79b876d7531671f5a56ee0c98babf92e20d05e18bbfa8698dc92e5c6ecce8be891c03ac950a7b28b3a0eb1cfb1d08fa713f7062c7ec6d3901acbf71d338d0b6bac02edd0b0829df77d0c10cbba425b3ef910a36d5fad9f35072da3c7c5055235f56875da7ad017eb0d7e9b2c9bb7e03b528b29abafc46068741bfd757de69145901687f7a16668730d3c4f84b52cfa828fed425bba6a56285deca858117db8925207bdf3da06f0e5170fb92d0097f08535d07732cd4e440ed8707151e6c3efa08c13c684ead113cece0da27395b228a6ffcca8c8fb6f49cff455f4a54ca2eb87b377248e76ccde47bef6c80279c376a488c4d81a3b69a089b09ac9d9c9e0abab69554d198f23cc2ad785983329748ebff1caf633defe61efbabffd8182571dc51ff50eeeb5267461115a6426fa0f3e2678bb361f6c5b42dd39b0cec255fe4a401aeffd3458b53de34fc347efc6384ba7cb174f74da170ebcff073f053e11f9ee79d2a807675d5ccc3be1a6b389ccc9f2d21f02c18db35c4d556ea7bb85650a0ea5f421b11a44a64dc329746926753c0034f9d3b74d0f1a339e424da74cd1f80e37485fd816f6c54065148f279fd81a35f0189b7aa5bb7e5211956077de9876d3721cc7f4de2dd9ab5cc30cc9c475f89da3834f4ec803eaa69ed90224ea4e30b2b040ce8214863e8e20a02782a989580405f887a914a4271b6bf1eab145aebc465110237c79cff3e8c267ff23e74ee0a7c029e2b5fd0d3b10f6b2def4fbeb9b3b9a046cfce316e02951bc3e19ad071076b039ca5d46f6a9b3edb456d68f7a659058a0062c7ff1872203a2f5414f39c6ab6ad25b92424fe25a3603ed8c6f6d5defb6ad1ccf079959b1a4771f52fcb2ccc497b7aac2dbeeb3a22deb0469030a2feeb7979f515ec1f0528ee49e804c3f95d4f165e91f664a3cf421c30d84e8cd42ba12b08698212003f326e3f7399ce849b7e436371b1065d9da75b03a7b9f061ac8214312aefc6b21877485cc6b5beab8f700696f1e3558cc7b3a92776c0de8f6d480ea48f7127b822620587915566a2d279d8b138805cbe65344564c58a26e72fc03605788d45a3841f1da68b67189fa6ae6b3b973705f1b8115433eb50156575bbf092c03beae1fc3036ae3961a7cf5aac0d2774e06970d2dd51b1e308d499fcb58c22a9dec2f5146f4fc974cceeecd7549339984cb086c8b2547abe90d70e8bb195e23f1f8f1deaf691cde2447e4ef9299cf3fc5f5d8c50b7b77db552f6157b6cfd97098d883eb8404c428895762a48e704fc66c25db41186fdd67d72e6f0568c2a7e796a7d8cff3e3b25e2ef195fb2687f454b2536930a274fb30a9832680f342ce5d6a9baf366a6f540daa8eb772850bc8449570e9b78ec354a70ed028a7a40d4bdc62a0730aee154928d0df1b1443886cecbbe609ebd209041f58fc23f648aa5b6f553f431b71c7829c4aa1cfa5a03ec13b5a3e4ede90e2fd47e69be5388aac8e440dc6483fa3af48c7e4c85fb92bebd3566fe503554a38ea28b1f31d8ee7e81ff2284e8d3634da180ebce2bb7646919c0455fffb58cc2d7a51dc22636524fba3f3b920a69458ef56f0bead6983167c98a85801bd503b9c4297c1f8247250a983f6fd658f0b3a94cb257d0ad182e42594f73180dd1314aebe6f36d794b45001002fb0d3f91c900dfcf130b934e2277e6fa42efb2d2c42af5b315fccc3d61de4a5db5e1dcc077ffc2117e13969c5871e794d59dfa18df7ad72a90d98210b737e865c587d3a13d347d883a822c9a6b27fbf4ad50122fcb606a13f95f03c2b0f55198251dee7ddec2c630db748e896631dac46a823e8e6000b609b204668d26f91bfe0988415e9afedfc4730adb4b7ec6f3b0317d9b1df63a9f01edc105078ced3065c8c948b3e3c2f43030995a9f183c16dd9233f07632478ba63dbb8479dd09fee8391ecea54ecc496c340e799e7b835d97abea58e81cbf8702b790c06f345629a4db36a6fe62ca3b03154770c81bed4f4103021be9004c8e7a0c3e6d4e06f966f36a63deb26651a47680f2b88dcde004afa053d870461ca8cde124600f7b0c50afe5fe66dec8aacfb3548369c54d8dfacfe68e7abfdf49885fd8b80a48d9a86dd2bc983940587578dba37c6a63d07aa6261cc9a7a3a58184693a4799532fcd6433e5893582f42935a3392bc4e190ad690b151bbc66e3ac9a1e329e40bd45a1c9f56bdab51f2b54a7873dea9ae7baaf4455a5d2b2870b9a7a162a59270fb8791495b200fb372f550e30e1d4edbb24d1b02d217c589f766fd28a64b57baadd31ed9d1b2be35064aa43fc67ad6ae62a94b99e7f488162cc81759270e12ee592d6e931379066db15ca42c84f41614efa279efdd3de81bb939357cc14c814bb027c092d481a9adde0faecec6db0426c3df6cceab6d9e04a85138317519b0a3a9003779a5b184bdb6682c57007a3cfc3ee8090b075a580a968d75f8467cd70eb345c129961ab2f982ee293958f5a91b10ea68195b92aab3dc1b260896b4abf7f9cb02b7262504eb6d00e6dfa214bcc772bdba7c28b987845bacdd07c2202941a2375609c83ebefec41f7e693e981a0bd05da20a0144c5d37fa4a4045c35483a81d7d7615f25aa9c8fc64c65da924d50307e65db6b5d6dac5e2e77c88292bcd117b3eaad09221011956bee7a776b3695fd8d607fc9ed8fe6c890513542bc4b0fc38a1ad884d88fa62c2a82fd65d2baf26f48deecf27c8b13c38268f6c5698dc82a7acf8bdfca28dc2b806671ac1e19126eb07e76bcef7e577c5157b0c56bdc61fac089a0100c933391a32aeabc9dfd4dbbb24259e71a841283f81868e0bb5596f6f2de8303b650dd3d85d3c0d8404814a74f6ef0e6f680eab21a16343af8581b064937e0a67b2e2817d687a0e0a562a80ae83b8d690942871d0da899ed4403838a1d5f4949df98c8d5da55109be231957d34c0a540151e218679302ff8978dbd5f0db56ac70b66cdafbd8d07668be414f7660030a1da7e20aca66e5f5a5df8583d13db0670b3cbc290efd5f016d3f1536be4b0589196b823d11e204039639743fccd44f808f57bb40c9639f00ba149ff53914c21d9f3faeca8f34d497e5a7eda5c74ee652f43fd76cb14eaac21d3820f9adeb704da414fd3866c0de649a805aeab009ec982708a127e95f4cbc5a95431234b1868d69276792b04723af873a925350b4d589dc2d6d750cd694a423f05313eaaf24cc256d7c440b5437c2e98d930a4edcb365d867de9ae9c02e284deb948758021732a0cc9b77e81b2f3ea3d786c2e938183cd9dd746d90cc548a39373010e145ef36986bcec98fe3584d19af3f1bc8d5603d7cc7d59e1c434e1cfa72ede4cfa6fe39172814503fa6b33c8ab984155c3286dd7f915027230395cac5a4ff004c3ab8d1d8954dd9872f2c49cdb0347414a81cc539dd5265f87365e8fcf505b20b022f60dbe7a77f2aba761dc64f554768368ab4ab74574411557e5afdfc4a648aefe5662dbcc7dee84e3e86a73e5442ef8e80e2d7b13272acc44aa1467ded9018b6e447214eb796106bc3d82766ad5ab33589cd9bcb0ea2836aa97f220d92a29c9cc0172471da1e4dc96c8646e0fabaceb6d960cb5beaa367cead5ee49a7a3786fb37e9731d66d0eedf67472b10fd82522bd5dcad0ecbf06c6a4f9e1aa98268a6a8b86e287babfa2dec122125153f5ee9a1ff67eda60eda4ecc95fe35d23b0acc9dae5e5a9e9d1bf4dcacbd3978b4e4022f24eb3deb0b4fa0dbcf4230b62eb2422df16ec43919eb6efc4cf7d9fbf8d0337284f1980cbe4ea0340fb04a8985d29a53a046673a13ea3b220659974f3c56d3885706b10c2cbe33650f284dc641e427ae5624e7e30d17be54ddd8949f3cb23d2a7432ee68223fd66586254b7155fcfacd09942cb611fd8b7c611f4c4c557860dbc439c1e653f084a10a89cb5ccef2cd69b98f21943b2b5b52572363f1ef37b639c2640987b162dc9294452ff016778d96302b0039555559f79873b4afbf34b3121bd69d23c6a2c193e2da6f89a6f795301b0aca8c39bcde072ff8e89e6213d1458d35604539e3e99e8cb11072b21c07a75dc5eedab630e94a21cdbe30cf1d29866d0aba3e681642a7fe60a2e84ddf4f2ac36ed0c6827d0bbdc0cb38fd44fcf4bd018f9d1d8497745add4d6aea59be1dc73b7413c007ad3cbd8d243211754f98a87a54fdf90a328205e8ace41127f63f98d212493f2b3805969f003c9191ca76ecebef596261e1b9d53701c875ab359f983a37baf3ea2a17f215353f83ab999ff3757de741eb37b0d2d367dddc24f395baffae33a67e5f4ef2afff8de5073c30eb3cbb644475fe44f258599fa3402444878c618af18fb2c40d106fdf671230c7118d315afd63ba30f6a0bf3a6d51f443abe73aa797ee6b249fbe292e218754adbb5ace65f58beaae2584bc496e5e739e0787073aa0d798c9d9e85d6945d31d61dab8565ca4802ad6535f53752d959175ce2f117b469ff0e638e0c21f8ee5d1701f50d95c9e1488eab4ed7200c35dac843b2433dd0c4b4d2ba9f9496f21d816b853a2f9a2405fc14e58094cf3ec489c9e79a9ce6742def964323860c6fbf959cdf90161229f471fa5aa2cdd49c281182d6b4ef53694082729e6e04943e91ce9a055e748aa01fc7f20c2277dadda056425d31534be267917e3ea6bee428204ba9d67217f7b34e4eeb5b95c00d970b2b4951a1830b054d16e6882e5ba44f0fa06efc1402e6aea9a916bf72d70baa0ab681b3b422c86265e36c0a89a19bd7811f4fe16a0bbb1d0b10fe7bac418a1d77577a4486212bbce0508cd2ace8776a5d28cd5ae71546337ebfc3b1002d70ff3a1d5085dba21ea72fdec74d4a945573c01c9029d59de7c68584323ccc371ce36e30a14cab2f397a647d7966aff08876975b5956a431edb2ae9c3c2e9989ab545a7dbece1dea541e15cf9e9ba013f5bf7eb73ccfb8daf43d3e6e6289927dacaa112834643b7c926e1841e35b1d0b5ccb23ab7c6adf064caadd1833f5d1c778516210fdd19a789a61f2f29e263c04a128c735ec2ad5f824004ff1091d6df9e54885a422b3ff6c26260e10be751b19fcd359e32059bc8764014696a10c9afb2397beb21638adc7e8f3896ac909c02f00db8ff95528ff0a805d2b2bca73c03e771fa4e29c8acfe1c49f4ae5e184860b65ff58ac4e6a30fe5ad9e2e0966a557d4c913e5ab98be3f24cbd79e220e54fc519b1def67ad2f3c16e41b57f2828712eff30d7ac89bce2ed8b4355068a7301ab225c20221cc884fa2ba56fb74ab6a8e32cc9d62cbebb8e455346f8675a90e16faaf05d3f62f48e005eae0a1bf0f9378079272c78abba83059e740970da007e65ca90f301fe966c9f98b4bae6eb56623dfa503ae859b7a8a5ccb2c6b274d5be674cfab24d180fb31367d205541751fd4bee1d7d0ce4551363746ad61dbc675c25b32df981376261652c8c2e83cf6ca37ae62e6b9b369ab45e761e0065f8423ef8c6af396a80f5ec92d52505692dab70292a07d957e3e754891d11791697f7108701ede224e60c0405523f002fd8dfac38687126bd7b90add0055459d8661456e07b9e3185df31a7f35310f259f638cba8e0b6f10d7cc358567b50e9603d812612c5fede31f9097c6e6bc6f48f38b465031fb287ea049ba382b102dd2f139b6c61d6f2011bf82bbd10804f1b90a9d3bfebb9a06e1f6893b54fe5938fd92c8c5761b5c9f3a46051a83ddc80165b534d16f4a422bd205bbd2021510e337ed7b41c1085a001ee0e548a6e4e1e1105ef8353a21f13683f167ff1ddbb9e408c2c13a47ddf41db164f039abe01c0aa63a0aedb4ed30a6b5f654396fb89f2072661fc2adbcd5f7333082371136eae4c1e68e5099dade6059c944cb244a2b9451a69af4b4b97ea18148e568251f42a4635141a5aad86ab759541b5b3d1e4f22a3ac60e62ac7f4340a1aae8b67d2293153a41ce11ba637416ba578814c278cffe980df14355bfe47142499946f58e0f420d5e2f8e04ea9692f57a889492da5f9cb466a273ac7129f14ac23fcd3f0049d1a6d7fb1a63596fc83cfd90b1872818b2998328195262d78272448a266a1b5eaab6c39ab1cfaa7f16972884b5a06aba86b81f9bfe061b8ee824a3dacc37e12459ed85894e629728800e34a33f6357a80b480ca0d106fa9f0fbce435b7b62edfd4e2558c41579510451bccf1739954ea5ec9730b7a615b3cfbafa837d0909202cd2bf9186831f72d8dc5eeb50aa54ea352eaad344c5b7625085fe39883edc0c24934b01923da6c0065178b48c8bbe8a4449141e6f2c345fe6825935f13699d474482a4d155cae76ecae137186237679073c5802754a6945430b545fefb3e1f67155a5d90fa048d242aae58d18d8acc54b436c8f2d7e1af410b5a86e3776a66f40cbdc57e013fe7e88bc4634d8c952c7902ca513b6a617288d626dd5446a16ae60f2ee8d92374facaa33b016613e8ac9434b513abe9bb659b3824c881099942fe3e069a20c03e55884a5e299d8fd5419399e0c7e4153f6d135cf8eb14f8840ab41d64fec54f89cb8f538d8985b676d52b559efee2d8e472678e7c4a749bf19b1e0c938d41abec4614755000f2693cde7fba8f054db2fdd0207e71556c6c1015ed393f04897fbe221f7bcd61d6c5fe10eb1b13a9dbf1595b035de190b3d09e81ef14569088ef4a46ef7298fd57f20d90d5c523ca6acc628dde42dc78c5d81f477a9e630df47bc7b6a51865ca9b30445a60ea1febf5aaed1b4288acef33bf0527cbb3a8ea6dae462714281f5e26a9f91edf89a87925061cb443b2211ff83ce3d9b26fde58b40fe266e4b540612be4138864ce3a9bbc4e4b4bfc78e076d477ab12c7dbe99ef8a352f8ca0c7f2b0e781c31ab3e3e08438abdeb908e67b2fc019f80cfd6d54f8b9468a4d4ba95277f6632aae307439c8a72c03d557f4052f74cc1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
