<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a935444a481d4c3cd433896f3bc474f469035279b246b51aea00c53e8c06118e5bd0d3e009a1c600b537775e3bed9d662ae7d67b89017b4e68cebad6532c366426741c689486408b209079a089399b96c1ac19401261f898e228e9c78e2c8691240717752d7b632440beab3338d8326381fefa0d36564e41145e4ea5278127ac955832444ab84c2aca775bad81c964d431e79ff604a0eb08345feffff3dff4f4016f380f2f74494da09e46f33a275d7cec338576c2b1799bf697a27223ff88526510154296e2b917e73217d4aab359efe50feb813a39635f484b25f001d2e0403cd91fdaeebfb7b046dfc1ba89738194c382e58cffdec64834653e3146e3980a21699b7431de313f8d459f7fdb4c2bf12bd5c31ecfc76b17072c0e4d4529912f4e36a738d0a40e549b17b246c4082082de150e18cf7a71ff31394723df8d0f91283800ddeeb4f1ffffea9f54ed1666e514af3d567c2111f68bdf6b7e49733852ed40eb5305ff5b3856dc53cf65432482c27eeaab2ca07673c7a94a600c4ac4fd35dc2b4dfc58f1fe6ad4bb009465f5802f4e52cffeba8d6f659df003f023c595f40761aca951c888103c050f94d8ea5bef3477e6d54aea103ed7d4e340fd5b2f3a27d203481065d369fa9e41024c9c696f572c19dd4277f1e56740568763b4cddf111450ae5c989592449dfc60399edf3bd28c615cdb1e06d5d07d02f7124716fbc8251aafb1000c400a1a66503caf0e74618eed2f8f10fb94f422220fd290ea3ec3625c82cae98c19bfa5f11100b9f4834e9ae1b7e8c6630e9d6ecfc57e0c6845b8c6730ba305b82738b5b207db5682f705fd3a8a890e017d3804f34be40457763a040fd3f32f11f82b66fcaf9829b206d700dc14e4fb19bda40510720e5e84e7af5a4dc2a26842a9073c9ac9707ae3a3175e884f57c5cb2466189e8c9188304f371829d8e6fd4d559f76af40db216a172a4e44e8b12deb8e97c558b3479a532a6612aaf09e9666e0e75e4b63fd9beaeed4ce4fc9b223b582b8aa45bc53e16cc42b69eaae11dfbabc61176e7b3ef2700fb8f64b8d27637899293bf221df52867fdec2c1aa50645f44a47b3b035cbe6f836dbd4e71d282d2cd2bf1991c5677712b1c7deaa2276275633932be487e6048ba3548223017dc17d60d0b580e97c75d9d3f39ed16ab6d524a69cf294bed98aba899ad6fefec17a2db1b3c15992ee4eafb0b00afb7e4a75b41264098f821dcc815f22ae7143e5965653e003b8e849326490c1a8aa279e22b60a2b65351845f6cd58612ad5739d41dc055ca5961921e79a079b2204fc08bafbeb083518423b082c9e65ed148e1671c2db7f89a15dc08820a056074e8c6fa6bf882a1b8ef257b59ab9be9843ff7a4e31a8003e3e826764d63a7ace7075fa4c24f919ebdfeda5f3569fd75208d4a878e6d7785875203c97749d21184b13d15f75c184278607f7ed3a1b769dd0aa4828ef8f85ae747589c21e24893a34a4cf170ec1a04e46668581f72afd601d8012f1de667ba35863fb18761a8de81c0c084c867439a6e16b3169afc15c491db7c50c555f57ad1f7d772dc86ee81f2d80a4344349831b973f51f9e8bde0f2c1152e4ee223f844302d5c171415f9e5b04ff2a211321e6e1dead1d530c8d9d287f8ad31dd99ab5beb99f145f73dbfa00c4e40a881e09da5574fd48ef4974cb510cbc5793518781f9dd2ee1ded11696c47309ac34525a1b2102674439f2b35cc09719c3e72b8cfe643bcec2240d8e2388d8b18eba851ff2b23e0d64f215d1f537bf9380d16692b7bb7d2e94456a75bc9594f4b5ecf34225f68cbe27fafc600864665cb98d6eb23b380a6f127a6980bf8aa5ea36c8af0686fb29d207f0d6f581641d6b0da9632a13b463f9a50e8d602f0b18dbf4d0273df6167ec205f91d8bd0f9a0210682d04ee231f27723a2889a74579df427b9fb6c73b586730e84ed3be675408394af633affbb37bea21b46ad2b0e14cb8f76fcd671509ef8e318d2775127103981dcd8c0237ab6b3dd53a36a615cb42e949df6f416339e8463b9b1b83df0bdc2843bd5a5d8937749e0b044607cd63d6807b9eb5532c08afdd470b15c3d29bdd84d10a3323a5c8d77e9925656c93cc3b1d034980bf97a0c16922100d45caa8d08b0100bdb0e7cfc70c3ed2ce2257b8f8d8c2972941e0f61b24e304a0eabc4553c76235930e8dcada869dfd236d4d47dec13da63adaacec89e1f8deb2c6bef2d9ccef19e196633b9f1b88095b41fe17939a5d088766a0888cc073bfe5032cdb69c0db251dcaa03d6243b4dea4909ae719321b724e65eb96e99611c7e1c752c5bf940a03a76da7284b9fa2fa7b1751b2ad3754c57f7cec6d1b6a46bf889a1a02498857b34939e774efdf23e6aa0f011250aa8fa82a1efcb78eeddcc4ce41e50cf77d9208689513bcdc9cff3fc4c12bcaf9a6243f6c9c4c7ae1ddd2568ccd2c38923248b473f8107eb49bd69e3985c0c3704d2ac911ca243448c8fa80dc51da3dd45723295f3db4d7e3228483e3bd237476e0ee658df6abab7e4ca135636d5b2775a5610ecf32f60d61dd858f0a4a9f22c8639cd2fa2dc325932c9b9eca5d1e5f9d45820ba74065fd6da4665acedbaa3a42882cc9d3bdd13503acc1aedab0bfa663a9f988ca5538bb31ce7003254eb6ef58efa4f5f1196b9281ce7cbfef044cac51e984d9c9928f7bec9e42d6b7a2f0f1e853ab18aa22927c1abc93f490e8bd170ee048a57c19fd4b221086ad8e52203f48641b12234d285a38fbfff7a642460a802d654acf2640e59e055b842453fb17de30083a37d6bfb1345a9da67dc80bbb5bab796e14cd4ffdb6638ef62b0653862be3d3a29006a96ff54a74d193f083b1bdf61bd44eaa78e72ce667ff407cd850f481e83080f8690b7154d3b0c57b9ea43dd7a1be41b417a6c391d72de1b4f1d16d597c8b2ca62b9d576e48def301dbc56b30944ea530797288b046d8ea404bd8fcc08ba0e0b973068f18178115648e468f2e63d0591514159d83d9655ff103bb3eb5fac1912cab7dc85f4c60de297ae9f3baa763d87751f914d935c66e51445737c6e2ed45e81296907b23b03f689c7e9374583d3b549ff16b69afda64ce2cd32a52c37246af49961e38fe276f57ebc7e80ef6829bcd095fd93e71a36c83bfa485dd3c9350a4649d76fd82204502ced0ffdf6e23bf106ee2ae14f4e957629292e3bffb40edefadfa8fa1df5a8a63f2cc5bdb36d71622f3c8e21cd226424a98a05c0b31237a6b57dd128f7aa07d1529497ac0fbab85292b541e385586b32ef53af0946b2bf2009e04c02f6c2f63fee99577f36ab34312ec3857b6560f4f2a2295e36f4f84a8502fc11aec71792f87c490bcb39ce1acf35893c2edb25712fb6593f93bb91658e652354face064d5a7215b5165ebed9b1949ae96786e19db988b9a95b52b31eca9a851ea22cf194a22847e26d4910e287dd744ae3fb8beedfebc162897d096b8f7a64c2d5f0d9c008071a61a31e7a04e888baa9e4c3811a4db9d41b1ab82b363f17476b6f2bae0f225fb30fa4d7b58aa3439c975cdcdb6aa72d3ee3bdd9b4053e2470fa6e3e892092ba1802a6ca0bac9eb9458cc23c56ddc2aee75675fc660de3fcaab2230873497121c2748bbe5d8f6428ddcd9eb2d3e82339e0cc254a15aa9e043dfed8915b839447b2f73253d12f1ada0464db380b0f1612594844e2fe233d84a679a9a168e242b290bd1da960f22289e63f7425635519d92da12edefa4eecedece613b0a72de1d11bf2ae7ef34c24d2783d7d3a23a36de9036b3a69c562ed7e1c89acf84281565b511696eae60db4b196d8ec89b8ccc7300d10ba28287d45b8a5910e0436203ca71f94c717da2cd6dc26051526148302bea7dd1a0bc20cfef3ad069ba1180e4f3698da5b842065e478546920afaaf09772d7912b2e763e9e72bd3b7e5552d9273262a017e472a3ef2153f8ccae4c9810aaa70fd3d9fbb6170dc635f69ee80aa1bf8a464fbce5c2346449c28c7332ac35104aa714be934cb4a7a5d78a9d46af318be3b01f6e9d5d394c766176a5a254d0ed68e7815e3bf33268cac0d1f7317adc49f28ebdcdebb3603ed82bb3ded722bba3e354061fea2330158912bb4ec90592e6833cbaa9da2aa759ea2e465d27259e7ef4dc51592fb3adfb7d460b5e41bf831b3b3fc1925b70a8d76263f5ff6be7a8b25e0d9f6e1b96ba876020286373a78f25222230431fa7578e1eb131d3b2ff3dbcbae38dd4e687eee77aa68a88873b8f5618f0f4007ab7307932788ad01c037d79d7edede1e456ea6a99ea3052ea5b4cbf658c3a8f89da655a8572267dcce095c7ff76e0ed354b3686850a728261101f04ad4fdb6d0b1e87438bcb77c243187244bf110d7dfeb6fb0dcf10c02087b63635240d7637e6cf21e05fc35fae4029c330210658efc5c1765f55d27817caf2e84ea751b7fd66dfd7f9ef0a1d4716985ace59a2d4fde2b8b7842dfe4cee88b405a58d41b17354f82edd743e9b077864c2d1b5d3445ca26b5386592fe78cf8357ece16362915960fc34231d4e48f3692099232c3006d070058b535687bf2e55e8747a22efc0c9a1e04c9a4ab3654300f3f51d590a0affd93308d9926e9c500800a8c56a2e07aa074d9f6c04b4165785f3eb9205869ade1786d8d40991e2a90ef8be7800e69a3e877e80d021bcaf3599a210c5b20f55182a9d7baced968f863a8cb4c70d2ecc7ccefa7d96889fe9a0493c057e254c9411a969117381731f2bf4a2f469ddef39a1c44f466da953b6d99345c454bbd94c6a96ff8fa2061cf524b1022401325643b19bfbfdf6c09555efaa5701cb9e95fc1d67502c8f7bfd275983d9f70f45a6b4e19fc6c1df8afdd33c4611963e33a25f7ae13f6592b003d0eab1e8c3027df98eb34a2995b813cc9afbf7404b1b28ec81811f2d2b46cd41f33e75ee280ceeb604f521f427d046319aaf231fc732f7231487746fe55b5b7f29c4cf4d32fe24a7298c1b8460d83be7fb24f9c9bfe0350b7b42e8f819b0ef574c96bed733bc30eb27912662abb284193f9688c86c7ebf36ff145abffe602d31cd6b0083ba135ff9dc2bdbc89ea834653c1cc9c6238b45af3f51f64b75bae90e1bedf568f7c59781492df27c8d8d86b5c8416c8c14b113842864acffd8f9f9685e738ff3a45d07eead23a2fd5dd632a4090b2090e10e067efd0c6b574272bd62ea475ec830fe2b9818f3cf7bffa65c0c5215c94ab30354ea1c16b2920ff3fa506120671ce8e631ca833ab52f1b6d483ebb117580b7e29aeeebda825962ceeb80013b46962357f7c2c498fd73a0b73b7763d7b65057a9f79140a00bcbdf3cc93fa1e7a9b40873b3bc3dc3f11c011b7c4c3fb856998d7f1c7763ccfc1e00f6fe6eb0f19a0ab8e77af212a34b185dd5cf5f96ccedd7045fff1256a5497fcc219bba491446c91688e4a436fcd23b493308c3f51c35e55203380f0c0bb7c4e47fc59e22528da6772d76de27308f6a1381e6adb48969e573591e75ffeb9f7b4de4a8584d9987ccc2b80e29386fc4937f242e76c8e949ed8b6d27d7555802cf26514b94f3caed9f1dac7081301a4fd84ae619b5871965764cab443db8a71258bacf7ae544400b1192a0494b776b8a5111db9157bc8354712c0c952a927517b13037ec40d200684f66c1bce76c91c0ace1f124514357c001fdff5c34dafe57dd45bdbe1aecdc36d7bab8dad2c0f16460f06d77d5b210c137e310aa08adeed9d06e18bff3bef7b832d7ff6e70e3824289c8516c7dcbda61d0cf0fa0a23bc6e631336a665b6d51b923eb3032c9b7442a23a2c59a7081bc52bf45f4da6d5d3293f3ad20e7805c625fd506439e19ad70620c0c3e771e096b3362dcf9979db30b8529309b00b13007c4444ad54be63109387a08c243840bd769d6abc915140d6afe743d31129c9e3ffa99c7ab382f7d3108880a780e362b4cd41c2ab55dde1f5ec9aa6b4adb52ded3e36229b7afdda8377c8aa86a64df410c18b218caf3046319d1cdd9324e6e21c5b24420426581956f28d38cc3ede069ce34745b401f5d60df758569491f5502f0e5a08163f4761c78394c3476046f83a3ea4fdc85a11f2d424cdc0e5385710d930109db855ca429df2afdba5cce1830e605997a31e3a88019ebfec1151561db9056ed77c239925a1790e2455294c1cb6d61e7d3c3677e61870f652849816925fd170faee62855b0a11a2d7af42f79653522c30320160c0c0f743b1fb25b31e33a3890d830f3ec65a5a578b571ea7ee73c6b9509b4f424d4058dd3732b83855a08a5a3189dcede38060552751bcd5fc0525bb84dc71336b8f74afc0e464e589a7cee79d086e8ecc32cab6e24669a41f80c913daadba311d5978b13d0158452c9c1e844fa2a8b282bd8fdc01eb84e9c7f59d671f139bd9b53029754f9cf12aca57f37ea144b4cae92d3c31a4edbd08e24a6344dd91ba7c0bb7e965c6257ab0e10aadf03a4b6c6ca9926fc6df7f0eeff34aa56d54c58696bfc7e776f56085d6938401f7d3c5d50f1de21b453055dd72f34522ed2b98d6620b79c74ceb4915859ba247484685fdf54001452fd093302228b1b7a49ed315af6538813f5c0fff97ed23acb560ea4cd64b454c6d2381624f96d90dfac03204642117251d4f06c3f75210af9fac4dcb23531b04f9c92f0510731e7a3baf274f41ba3935877aee9ad20d049d74f7896d1a1a4b66ea2a855485ae1540489a413151720c8d7079c63edb514d239c659c7ca50d1ae0b5a1fed26ba818b41d489333d4192292fb8c391847ae3169051c9ffe0316ee403b731a17d27c2f9593815356d01b685bb3c8513afb2c509dc551c2443297c5d7ec2200169fc0d2bb5da679f8840c8a21100e981090719a2a9468a3098ca3a9edfd941b9ba692ac8d813cf539c6044843ae7ffed25c330c2bfc816805ac45e3720f9399c2223b601b3cfa46c3a24b5d2732615c7a5459ed4fe9cc92ecd9960f7a4ecb9ac1706a86ce47be79fff008197147120ebf80287d6b4443b009a92347b9d10132c2e893308b4a4127103adfe959432c891dbe38257a32330808d9bfcc8d1265481737b10b4f572d2701a828a6ff8b7d3da5a9ecf813a526497715161709522516a62e679c6eb3f82fc79d29c71bb7982e60e818cc9fc803739438c80b71a818423ff706db401fa6d45a2ef59dcd595e8fa72b78eae3d194d70b841165a2146fd52a7e643e298f63c43a277ed99f4e032412e3eb8e5128cc9fdeb5fcd86df283a71d4e8e45788da5a3d6d995d4ccbd1d23daf50c6300b5397c4a6d8e81196718d1a995dfec5974f1ac35842a00f89cac3bd887c93cc3e0f21df61fd9c399d4f5a59406ec79b02ee66d19dd76cfedabbfc139c3ac68708bff635265c1ed230a5d6f7cbadab4c63ccf42e252e8c0e90a81175d83bd71c5bfc383e5dadc070fb21ea77a71fd6042da6117784e74feec246a49d9059f47eb5d3b4466bbfe81c53e8baf36b496f3b72c80f09f8e220d338380f6d51996d21c96f2fce8cf8957d3b33ee56242890683ee6843df7947f14bc6fba15d9957095d029642c09bf532222aa14a0e551ad258001ac9104f776cb20e73537155e4f418d6a25101617c48b80df260984bd08d0f33a731ae11d04be5250a25ac314e2af1bbb6f3e81549a0edd8fbf6c9ba4e956dfa23e1fdac5a64e966b0333c1cc3262aaacc3cf76f644a363e064b4f16cb6c98de1065fa5c17f75c03ea58e688fd679f5ed952f9297a6a4495ba5b761869355eabd205e250307d3934ecbaa3d7c44fece35a7666fb6b22ad0ca69cc74822d6982dec66ff4212040fa42abfaa889e4bac71fab921f3136de5dce99b82d6bc7255f6161a70b98e94c52ffe898fd26daf115aca1e808f151e257dacad69fe018a6a195a2b4645de6fdc45773c242712d6d136542c7a516a49ba0b144306f0019aadc96b85ed0dba6129d0da398dd3da4cd785846e7b6bfdd0f91b9ac23722daa94818f560c33f2b8cec884a3ebc63b3054082996f2186bccd34fcbf8e9bd17951a3d659f8b721186b5ad4ddc0452eaa2947edd5ffcb93231df83cb48e5706010f79a401c92c7db29ec0a834c03a5ea97d647b8e96e3887f95f6d6bd17cff2020f2c94607ac32f7987660168482d47a51e1c4a6a4038b17348a6c58da42d2819d681bc534a42601a34f190fa86e1667b149146f8d5b7ef2d9d2777d676bf079f97b85779cc93fd86ecb4367f63a4bc068723a42e8f46ff83e61ced40cfc1dd25879497b721a3e91c95754ceb591e96da4c347176e4d160979ea4e142f7fa25c33097f03cfae4e14444bda39b0e324e15cbe8f6b831e45b84ebc3da8d9d1d36fd2eb12ded7ebab9cc32180082a5a3a7dcd3d842291785367dcf7f220089e0c5f2a067f13852674eb6537eacd2a7597ccd4f57422924afe40cb781a8529ae8f1df4285c7c2ac345bdb1cb4d8e2d8c64605a1c8c28ad708a9f7bac40b7a20cad2329494af76e525f2a734ff352f1df2525cd7fa22806739f74232af040d6869960bd9f618edd8cb6fadd543d4287a878e2a571be9d9d13eece2cf4e0dc4f4d2faa027b5a7d9d72ba80b1c8275709ba8a7dfa44e7bd1c38958aa58c53e28e28bd5706d91ad56f469e13ff8406e747b057f7dec33b91d83f3ca45370e57764227295a6c64a94ab4d63a6fdceabb32d0c5694f349f33a9bf247c0dfc740dda925c6466a2939fff998420dc8c3bb6deeaf0b570779512ea01f981bb36d1615e0b60592ce7fdf52c6feeb030ae7ca9f7894c76dcaf1f97348ad82364e2d5a528a07458adbcbed8688e7bf06d1ba5dc07cfa372268869e9efc78856fbf4ea42f3a882cf687b5ef7d9a65b46eabc1fbb9daa76b5885c925f8baa953673e22b05ec7e2630b5cff6384e9157912ee115206526b380c7f1edecccdb57dbb1af93310a031b6521989125dda5f04108bb23e3d68afd859b65d3d2477378cce600a1488eaaa0d2785bc5c44a5e19c6d5a037f4e9d7d8d7a23e3fbe5c198d72a1d0021ec29d7f01dff69ced719a43efc5f44e17c2ff06a84731ee0017bf741e0fc092a5f489bb5f3291ab354b10242a1a2422a2cdd021d83943a9c40e2d2314fd3f5a8516b1e9db3e74159a25abf8bc65bc5575a78b534b32abfeea4e891f04b21aab402826a474aa75688f27ef013961bb36667386c7a37e9917525fc1c5dc4df24d5db8f512958fe1b7dfd0f9484505ef69670a929c5a8530e19f29345f89a0ba88fcc8b88dfe5e55f4cc6f855d7bdb25d46ff83d4ff4f8db92c4cd7aeb23a4ab11ef7d440b0b54471c7ae586b198285f10164b8dddec30f0767cf2b735837b9153c871a7f8ee628602d95419cd1019c50023d234b839a729380f3bf769a76b5b49e4a2f77e249f4aa8e33c2e9a00418f4c0683cf84bcc6da6b8b4a0413ec072294db8bc0b0b17e0ca69a91ee41f2271c2874a0f6690a36cfdf823e1f30a7c238673a1c029c1b928cc512c757788776437059ed89e31b672a77dc796562dc16139a9b2d9a8c1677487e27c142284afd065885df2e9599a2c0c9173f3133f9d78cfecf9124d694e0c6bd24e2c400053bb1d19380d7a8bed338e9263b2800394250f65bdb1f8701a9deeb9192d3ca44ca4acca5ed6ad0c4d55e5fce5d70f8c926523a23fa82fd2995e9eef91dc6586f2ca74c34ddd793ea929dcff6711440669c530ed5e21ad4a8dfb3f52981d5179e3f5f1dfb988646fb6b623861b9fcb4642978c29b4879881e0d7bd51ba0c75a8df3865eff8755bf43d01547873f5992c3931b0caf283e444794848181e88cdc6156cf7cdd50552f60ebb3571bd74be163bc3a535394c921fe11f20ea991ecb1d9fa022b271d7ce116c18812f1dd3a0b25b39bad9c852f4a5b5a914e839236f253434aef45e8290dd7b168dc4102497c947edcb17234491700701407a9ca888c2b73e6da454b2f5c90b19ea001731d53073a24bc42c82c72956383efa65bee203346e72cd36b2373580aac8227eaac2575014f9f70dbab03529cd7b6e703d2fc345d7ebc6330d78e9942b454a17e08a9db4ace8c16eac32c4406463dd4e5528ad981ac661d9ef0c6e8f94605e1e77c7e9994312f6a2aaeb02f5beb4eee43c03956ebde40297fee1f78e8a065200061bf720a97149392b7dc841fd8bf81eae7ce42f2fa9d957104806809e8e1799cfa76f7c050b134808a077b9e42a6772fd607ee8bce43d10976eac898620cf10b0a160926eb4a36606d362d5f84dab24f5fac0aff954c33180c2052bd8875a15721b30e31f0b691a7c14bf368408756f2ea5ae893fdcf3f0a758b49957017dc1c8d1fcfd14b6f003ff29cf71f4285885f0178267bedbe6565c8ec4c7bb00973f5ecf1b47fda3ac189a4d2205069e688d903e20f2e36266c565b10db2a3601ddc4c241651620bee5725c3478d19b499fa609b55a135a09935a2fe351e80ab054fd325efe1ed1ca233d408e67a26b2965e20f963c51c5ca2d69f6cf74049e5858ad399a16f0acaaf0f2d22e5663717aa080d8eb58843af5ab1404f37558bc2f60d3f0e0c3dd29282edd16bac0d8681538ebb08c37e31176dd38d6a5844d717024acd6cf4f016c2443f2ee94f8dc70176ff0e9acdafee73c783d1726d4a22bffe1bee2f9f7adbd6f2a500f97e03948eee5d69b61010925ab66e00c72b0e089da273e232cd1cf784935e5324e6e9ff2ad336452e28f63ebab9da3a28c02e033965fcab4e92a54714ff63cf3221da7e96ca9e3a1c8e4adfb43682f1a3bc64c9b65c09acb10e9a235020ea93c811a699e05d1dd3a79d0b74d84192e4ea12264e63c7ab7522ae561b9820a3cb8c0d0449ce35dcab20aece4f93a447d2007930c90a2406d695031dc187944e0ef8c04953f434c4c6c400aa2393f43b8298f95a795fd8261ccfc921c18d5558886945098f0fdf99a07adc5c379c1d1ece639b5c31e0f7ba7b718bc9723fc12c7d2040913b351352dfbbf7a8d453c55f391d75ebea63159b286f9f2940f0e5e03c91bb7298b2f8d1f05b4c8bf9f7780bfa854f15356d0a95762dc6f05e9b0ccf385bf01392cc43025e3bf40cc946b060dbc498e94adfdd8d648da9deb2099dcc46a2cdf77cc67c19798feab54bb6dc2989c79a343379285df811807cd59c7c59b642c89a8b8a54c4108fb43ba8cb886ab68eb0f37422a9f505fab791b4e4df3d2d054589d6717b39dd1b2af34cc057cd0dcdb32e598680d7af1ac192db133f5a71d80414774d16421431be37ed082ac4bfd32122dbf3a998987d6d0971df9412303a267c65b500b103253979ec62bdcd242ddf4c7e2741d0914b3359c67af2f5e5ecd6fbd18bce90eb593d3a754517a160db8774252b086dd50b0176f3c034e8974927b5d0acd30a0d0cd66f837d42255a38d93eb84cdea03cda59ebe9795a48673e24a876d559a6b7a076f6923cc4e2fc86efe5ea07bfcfd334fd8c14d5c8ccc0675eedc7dd562bd9d5d1f57f6ea62e6aac6864b3be6ba4dc126eb61416b1f839e31946c69f86e3aa052e5e4e9192b930fa7b86f97c3788589ae2c4b15fc50a220816993041ced2514718a681d7f0cfae8869f40bd9eb35724625710459f79107eea69b73cdacd0a756e3febf9c9f4c0d6a76cc3c0a5345b18c1a24e47e96030aa5b35f3564312c8ed6180991b255e560c22b178b85a3c35cde29b9cb17bb2192a2246853f9d275286cc5a2520e01b3da06e6b68270957302e839b39c6392e67c3cae9927d4136ff15b0e415c1a6ccc055c0177c5e1a3f8bb6559025c545bbaebd2c6e478389fadda37700a73b43921d1a769d3ef309314e778496a5d975d3824602becd1dab7a5cc83a49202a2ba67f23ab2b1c731f077fab2b99bd3848f3cdcbe3861332728291170842f2bb39edd1309d9332acb41a9d8e70b076e0ec4050424186a79bba592a9cedeaab9aa89778a6128fe2064a479dedb25f16436677779af2d0bd9e9ca284636418530f5fc89d8f7ccad3af3b7c6da8668308a777d01d9f7723426498545991096dc6f98cba117f9762b7459eafe73317f7caf5366876790befc1c260b73bd64c891fa339a576bd40ee730f9d51141068a971b6803e3414584f39f7a50085fca19c83eaa5a85c3b92d83ffc2bc4c7de222f9b40be9e0055a0f219e27aa0cfe26196f4ab82ceb5b008273d1db308be684016a7ea1e1acb3b2435f12de390fc63ae1a09de592b0f6e60992f45c72377e3ddb6a82330c51a54d5ce44bf94a3de844429d5d81e439c2222b9674a5ae535cff2dce047c0f5d1dda0d417e3b2da625392d984838e7db9d0554525dcc17d38b05865767ff21953b24a16ef8a45020bb41ceef73d315c31a201b4701a5d4ff2a45dc0645382eb12b32d5c6040b5987a7945963ac10e12b2d09e6815491e2e5f7f8da3dd247ab66720020fb7b95c6382db5a918cb615d40e381193d9cb7b8e9128ec0e958ddc2123eb428613911373db7222895b900bd832417835f08167bb6240124212a85fe5b388f0e715ede0749fc08679a2fa5769c716521195949cdfeefe395db57d0e6d6facb436717b68acc4c18e8781295db6d45062c05f4a96d83deb755e893dfa1eea0d45d3cf7f9739269e274ad4470eb855ed5a199f7f54b9832581d2beaead74bde70ca5932d1cfe35916d57463c5273109e217a1a5edab7d5326e01a03830e24adfbeffdca3a88fcc03c1b20a20daf78521ada8e5e0ec52111ae725a0f5664a6161f3fdda01db63148334c220ef33094d5ad20c0b8ba7e4012c207eec2a5a836be2849b217f62e865a5446eb020f6f6260fa3501fd09fc1171b067974cddb4bb2708ce51a88278343fbc8797db434f22ec677dd2c2c05e4d83c617410bf651c1bc7dda719625b6cb9147a37f4df4eafd75c398baa997116618ed44e049daa0157073dc51e01037f7f665ac12651367e6e9e0e33ac18aef4cd619aa97a94031a0c27587cf02949032d5052da22a56236d2e50e4409029091bdfb3957ad69d7341512d03a226c28d2bbcd2f0ac0d882610332bcfe33cc96e2e63f3c21779da0a0d4e5888f629fe7b43e749809a3aa0bb96858cfb35473deebcf778943d11c009b95bc599f0e02ffcda1c3047a98b32bec1dbc6b6bb4826f3571ee39a97388c3ededeeb447d381cdb33a687e60c39f4316f58d0acbd5cd5e71515fb1b71d1bb75e8dc23487f2ae424a2ef261e2ea1a65b6cc1436b3966fb15f47b168af18cbd85a63f902d9dac8be13a3f9e5bcddbe71352dca3bb20dbe2d4f8bcacde9da7f15deae71ca8d616175d674ceb398662ee7b39d590760af5d14def53c29c31ca2e1b3b578b3ce12be05b3fa03f0947228b17b284b3203e6aa32c5efb5547d01fa1fd40f1007206fefc9c81302fdbb3a06ea775e11c0d17cb0f822f10ab1f24cf237e720d08ade195ce75d4fcc1325205bb89c69a5d3f8554178b34ac2c63c3b1e02c61443bf9b2e14de988c6d6d72cab624856531a2876adb9d5b9d1de55f0fbfde8b435bb6ace7c80f41ab89f30145c6c75f099113852364c5ff1b5310fe17934fb277fc8b7369a376bc2cc5fc0a039b33d8b1e78a86ab53a02c6105380a2571f4c1dfbe22e9fb39e81d70ac1c273bfa7bbdd14eb4fd9cd64d37571503f82095ebb460c363ff6bb78f23d7ddb31ad0dd1cb1e8c7f35e72570c3071feaf3449cb299672c481076775cb00b527222bc2a18dcecf923358d85609aaa7f3832743da7db8a201700ceab73894e1cc3397d861ea7e94b818ef440e09f9247ce7779188fb19808821fb1ec6710041e7c50116e0de132f93e174bf25d0a9a7225dacb43d02f3d6fdb9c5903e1259bc58b11984238ea38f2b3d2a3e78ea18adacd95bef5765cb30e33c468d2e128bb4beb3ef34fd5173b4843bd7cbe51b990e19ca5d3696abf7781819be7846fa5aa1848fae0a1abff7796b4e7e204fee7dd501f99002051f0a3fef533dbd49d238e9bb75ac91fe616bfae32644d3dd83a1135ee8b89ee24b01e57153c940618f6ae5e91c78a52aab59034b46f39e9d641cbcc41ffd3117801b88ee16791d81d25eea5fed91c552d1085993c9a300b3ec82ebc5ae5c3ee38dbbfb19bdd1e3f530132441d05e8eaf33eae37b9ca30674d97c2ec639449132ec4f62147d7ad9063b34e72bc31d24d37c721569dc626c7d970e721a58c585695419554b8380856f5f485a9b2ca76a1545f48d96e4397c8c81157dec05092756d42f5a28065d78c34627e035bd6243a9378a9b9ffa5e17189c3297b91675ed09dd922a3a0a8f609fc74958d22effea80162aca4369bd6646464f55b9c362e9c7520f45f92f7890de0ee542b69d32da6d3f4da8c891087d2791eac3165a332b82ec74da821afa00e5a24e110df71357caea3ed6bde1b71548e5e62d8863c77a67ec9521c8374fd69da665b85fbd19b6adb1ad9bb6f350853bb8c06abe98c1b3126b6f48a4a3ca6728d7b494ac405afb52d2906afa3f61957f11a3c341cc645f0c5aefb0e58cddda77e743cf7b46d1efcda54bfb269e23ddc1a82c1af78c40a6cb688c06f2be1472042dd8af7e45a49a2c9a3431a54012247fbe41970062e9de396e168a227b5baa67e77700f4db6d8561f20714f253c38108353ded72d3685f43988f218db28bab2aae1799270ffe012b78517f35eddf1ff3fc936d8564a83dba745d8a58805bbaa1c2f5f9feb00110ba9f084cf4f88925cf080b5e7fc423d6385da94abb6e17c9b20b7b606f7656dc285684110492c6a3c193d79779508e03e9e08ec4b8896737dcfb132a84bc0aa2370c2c4cc07ed64b5b8e6659443915207f3fe21745f04a8aa6edff2973ccfd8117da1772fca8e6dc5ec116de675ccea33dbbcd2223326550c95a7a90c2eb1e5a6e13cc5aa150c380377b8986cee52a16d4a516c37fed43eba728fd7c3e21f6d7ae747fe723cf7ed435442ecfd381aa1d9a51168e4e599a136a8194b4036292f3449f81f2b0092f0314d4f279192bd016c3290f4fc54195b3085d7ecb888e1fe64d5abd262d4ab2d1ef7e212be105ff9388b2a5a4a05d94940205172b1cf85ef0bb6f172d383f90a3f77c76e2e02fa33095e00ba3b882513d6ad85ea4113cb828529b8d2e1c4b4801186713f54f155f1bae82ec69a022e8e260542cca4e46ad1578e1d2d49e46fcea53ba685560d8114063127e44356962f51b637262f2f47345d88938163f2d8a61285e0193f2bef33153fd44bc41afcc83ade2f643397ca25cbb14673eaedd46f66b74ed901acc736a104d74f90f0e68c861019331651d893da7b8285247c87f9f685ef35c041bf5b0e3a94194c5a1fba5380e0fbc82c2b2b1cdcea6de6783d113143a44c421991b50533187081959438803a82dfdf0ab72a23c8e2c2966b7abc389ea2bf89777e78427952272d7f3999725d09d0e258f91371b545142b64d2512d910621bab1e74628b8e1be4fa0e9fe5b63b53857376bad50c4e16e94a6ac9058b773d0d91c327c0c305caa50122155365b0537f339f95cb20e59488a9f5cccfdb00e58add3e0f69fe2c631895079db4fdea97d7be14a468948de7de392e38021f54c4c8fa240f5e20e0d6b76d71caecd4aea7edf1c392427e14bfc76428b51c27fcf7f6515962a2e34ff40023d18f4fce0f127e8e6e2185a1e0b6016d34c2a8f5389cc5f1bf5d22415d1cb7b5b6e4ea8d9031a81a3a246e193b7bf53ffb1e45c23fc2cbb8c8e35b7be6e22533b953ce8299cf2402cdbed1687ca179da7e6eb0215818f3e49c4cb19222b5a69b6a80b0648223ef5d90d8b535128df9defe467d78e51f7bb8ca39a17a33869d7ef59c475b9b6fe954bdac7d7db9238f4913b82ef5605a1bdca8e5c2a5d21e3dae850adc40574446b66eb2f2d4a8032bde0719abdd995f8882c06197c6a08139f3905783bbccdac2a680d0114b1f3b720b58067a87adf95d8a842b7128f4b029098b412095e0b5b2ccaf476b3a5266f29d0c65ed5952a78a1ccd4a190fb7592f87a9b78f31c7991c7b2105712bebe10673cb89006beab6195e1caaa9ed9b64512c29daf3f7ba9944e988c5edc9bcdf373e427abe2e86825da331c10569a0c420d230635a849dae57702faf257be6fac6b318ee7066cb983d204921c767d2f2fd1da20cd545270a59a24968cbda50a5a190a3b3e61e8da3ababca28302fa485909b759c12bfded581c0bb149793e70f92e307a290a56eeac3d164e445ca56a53f5dbb326eea9ed056c06f50f714a5fab17710bf86c915c52d3fc4a7b6e8d6fd64bc0a265d81ea13463fc2ebbda160268917b378900a28a4298febadf840a4657b2fcffd6a68a34ee4db207d071fa8e19671716a51ab19c70a6bf3a40d1b4de602cf187ce118411ef578e406a2a1fc30767cda1ff5c8d0885964d8ad2f8af4a589989a601dc0e93f89a502c60276f54999e666bf717877034c0e2fb6607375c20e2f1f34768d901c602d97ae42ab44b40ba094d018f899c1ddb5f918514859ed6517278a429a8c491b6eb3d20eb7efc6dd4b7ea32618a3364bf67bf9df35c0d712399f05f0928d1096c620bd7832c867b46acc443064421fba381589b058fa6a6d9701e0469d0f0e64177c24be341454b50e1a7e967839daae64f65461b62644f34646a93502d81457b74d78af70a2d9edc63558615825cd0b8d2c8008ed27d9959a56c720684bd12291c97b7b3084e25e82c602a1e6c8adbe2d9d996975221707747bc35d54732581db5d576ac44bee5946527c62c17682ceed6b23cf8639000213aaa4b0215f22ade3b402eca25df388510efcd0630305010fa626ce86680bda1fdd27d9b4b3406bc85a497d9b416f86ea0f1c4115742750a13562debaff8742a353a5144ef36956bdb65099d58c22871924afc69ff4693a4b37d985f37658f7d33a9abaa6dc61e84e08d956ee830e8cb6d6860ebc3df816495ced90aa15962f41e94a6770702ef3947df2be165441907cc790f5c1bd46b88a41d603b58a16f3eb898a491838e8fc28e60a6f3d3df0116eb4b28a533dfe69b2cb31f7abb40a11b9553fcdd5d79811b51a4075ff96ba97b20a42797919cfcbb65b64e5331622e8625fd5ec6565b188b88a0ec58a215d40f4cc0ddf5a5edeb61206b195ba1d42d5dc506251ee5060a5d64d13ea448073ef059de64c729093ae595795c9d571c4df521523cf531c117b83a1c8918c6ef5ea6a3f51c43bba5de8a4a897264bc11d1688c0ff538499eb6b539f5c3835c12d9574835e6ca2db80076f6754dcee2dde9f3e1aebb105b1ca8d2ad411ecce13847e74e053b15c9641ebe0c80b021565b3034b5996e67bb61db0be49163e017288a1033884550709839d413c8458241f14394da7d8a666ef95728dbeffb1c424db25cb93970a4c3810b532274d70e92fefb3c8054f1a25f81fb06da8c7e12aed6dbcd6bdbf8f6d4d069eb0d5346b78ee2470b91023479424b2ba07d787a44b7178ee45bd1844bcb587493c97eb8c4c3cfad415be84459d3a9affc9948b6bf91bd2eba3fd0bd50d33fda13225a775f3d275851f6b01fd60a42e03433440fbfcafb4b588f35805f6229c93e1bb218ade6ec2b9af4db6daf6176aeb3adca5b480b39ea8df0f0d971fa685f3a7c931bc9a411de9f6ebb97c5e2b7b9b967fe323414f3a21abbecde79fb12bfec8745def3d2658c4d31b4fdd0d0dd89129f3eaf9cdcefadc85bcf26eb91272264d1386a8f5f15c1a9a57371791f28af0e8bde52b21ea094294902f31790e0e36a6a4dd3ded3cb02d2597b71f11acf26c9004a210ca6b24f57dc6f41fe14b9a14d28657d238dc3ae30b223d515f04260ff93263dce7994856d1135b62cde9ba9d207448d3ff619089380408e59c78012eda73aee35c789824f04e03025bd9a46d211659835207a5ca38306d26e9c6ab73ca94e6ccdc9b75949e1e2d614e3016af450c35f8e62a10f488903142a940a514202b8a33d23b0a5dd55f583c42e9d33b60d2b222c648f876cba9d5f0bf7c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
