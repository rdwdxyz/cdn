<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8c07f78825cd2a6bcf89b2f570ff81f052cb75361cec6f429f7a39a03b6e116bedcf92797487a26fd750fc09e074a502f82ca1480c9ca327f3f95cc00f694797979b19c8956ac0bb029184ef2c7adafbcefec0828a8e8b81581daf60eedbde1555228bb95d8bc2080d448c2b2cde3429c636e55cafa06b9ab545e0a0f0f8c61572815bbe8e267e7422dacc44d9924bbee68766f47509d84afa7852180f89af4a7daeb066dd88e6b055931417667570840c95a0bbe5f1c195eac7dc767523677aee955111b49d9e9d7d8c871771a3f8a76e1119366604f7f9f72e21af5916414e2efcec4f1044540817bc460948a733d0cb1604244992b32a8cadc38b64ae277583afd296665cdb7403e31210dff980ab06de6bc3d019550607c90f41673e7b780065805d27a921fd252acf0687c493812b5ede72f4507b4f04bddcc3f59198ecd28031401a5024e8bac40ff56422e79beb2c7ddae868533342e855ac6f8afd88701f8b562bab7465d89087a3625583d8505c59f27147d325b3c9928ae50342e518728e50aa36b5a68f395f6648d27d7a1b86739d305becabcf1dfe2c3da119c1998be8cefe058eeaa5db91a42f450f1988e0cb73e30dc8a5b8e0d84ab66a82bad1966f768fb0a8737b4bff22011586903bd8dbff8dc6bf378b0ed25d82903147d7369ecdb8fa5026de73db4a65495d94a146c0b3ebc7232d2fe6c4d34968dbbe027966b1b3550783bf8cd99d6aad559b29aab75df45ba030b9767a2a9416933d566cb09f37141139f1212e8cb3ce898940924d2c569f5741e0570bd4060e495369a461caa228ffc9d8e741809397ac6ed9718c1af580abdcf1cfe212111639c30a67e95a467e806219537d201dd024d51ace780657eb2e8a4f46f82517fe71ae58c37d2862df73d4f4b1eddf7b83c8d61555a59d8071a596e5ba4e0253bf4ef19d3bf719264003f5373cb8a05d245d9980a6349ccb6bdb50f475fc8cf7a8c12f070b010635f59bc3d41a717130fc2193c3e7fdb7b5cc1ba044267d9ea6c2b47493d7f1c9f322cf54696c4376a1657905b9afc05b2be212f4e756036b012079d598d49347acfb3c5b683f10d7576ba78a3ef2b61083f85883783c2caf10d6a1487d39906a545396e526d4a9ad75fb4b6c83f8fb200691091292b3b16a571260c4d5b45849a29b426cb0534e3f349737e52cf19efa6b228b5588fda94a609b99089a8fb1fc0e210bb0020eb7fd835247c4cd8d63f8ea357430d7058b0931a0a2ca26bb937e7a223af52fb83b0b334e9ba5fa2968e5753a8c00edbbb90ea41dba27be61b7b987d77d3df024f0e2fa0a911fcd21caafc1df1a0fba9eeed397570c8504b636a2a5562937882caf0c52d1180a39d5a2feb94e0edd1374e1e353a163414dbfdda85cf7f5ab32fb07442780c9c5a8020b969683e0dd0ebd633271253078199b77cdeee73f01ec525b073ad212016c569351a30dd326afa79b480e12362d76e75ec9d1a1f0fa148ff76b2f32bfdc9590033a580d808b30a09d6f7e2e8512a7c721533ee52ebf6b2e84e08f4d022831f4e9ce8d557fa1bbb7945374180e67e4e84f834cdcfaeca9838662c81d8a6eaef9aee7d4a70f59d2775a745b20eeff7ccdc1856d1544bdeb1e121fe90ae542777d9efa1d825850c3d291b24cb4cf20afb83c408b49b58a3ab5600bab09ac1e8d1c1000a86d4720bfaa70ce4414aa3fed7f370c581ed486a77032438892712b97a52ab2a1a833093705342689067c37fb7e21933ecf44c1f53ffd0aad45c908a71f15cf2f8f1975ef2f6057e91f6fa968917ec6dfd3ecf459eb8876c0a861d3dbb2671da2ed55a5273595618c36061f777569036c67c9f567f118b9dc2300dd0564af3d789755e30b15675620408aa72093fbff3f48563fce4c5dc14178276e6357cc723b35d0df85ea51ef822e0d43108bdfd052e22f95988c3ec503ed2ae771bc623434d794ad780864b3f788e1bf69a524ea646e9fafb630a44436a84d63dbc8d7872c672a2372b82e5a751748ec5a955750588e99088fc7bcf65465b4a1edd5a0948711c91c9e3d487fa4ddfd0a0a511ca411b1b6f0318121c7efcac988497a83b1c2c457242fb3ac3ebf1fbd33fa76c5ed8be810299b5d3ffee53e2e99d1e9e825c55553f69b143de147b4290f51266b07ebf4160799c08a2e0581b49f9dd7686ba55da79b877823e04019efc9d3146003a29ad33350356b5c0f87737b0c5b2b3a2fff8609fa0a79829df4703b576bc4b0ece6422e02fc88065a3266bc676f16b3de86db859b278ebb5ade94b6828f2029f707d2e7289bdd51d732d925e4d9e8eea65546b1bfe26e984270146c721c7833fa3b2876ca17b5f8a9e0e09405cd3395ed001be743425f89bb8989152dcc91151762b27b38cb500e8e09a08efd66aeaedd21b57611d515b96ee88a5d6cb5dd0459da840dfdf459f8a775021347509b0a1edf7d5e4cc798ddb935991a37fa0a2964bbad893a24c4bc4c55a9e777b7d8a7890ae69a3dc28c0a8bc55bee5783fca2f5d3db6babe800e84a3ce0bb83b54630004b6903d7f197259085a6dc14179a5f788a7b859ff596f7f91018e16255deda4386b10929526ecfefa178db023f2e1f317e436afdfe54bc82af7595a850151b7d8f7199e5f8ef5a36e879c74df541cac97447a73a6c241029f475afcc111dbbaedfd198e54647593e6c5207795bfa99cf05c1e28fb119db0f0c28d45f59ad26fa65c2bd4db38d87b7665bd5d35f284c1354ef116122ba78f0dc40606bc9d3462e47c5c8e52a93ad130f6787cae75bc1b7fe43294fe8e049c1d411daefd6f196d50b961329482ecd4f9caf3a9adb803da6ba1f67dad9c37601f2ccdb22ff706e680b1d456cf32b77ca1b2519cdbc1ac3627f5ae5a55d0a471edb85b512c38be900d8f82fca85dc90410ffd1842c8f09cf80363dc94368d2d2a6262aee7d9ad2f6aba88ebc38b61b4af903335dc80aebf8ce6c870990d3d7be6deed5d1bcb4b1d92fa1d1374b467450a34efce0e4fe0a3b77b0cb93e62f3518e6513281601b68892218c20719a0bfaacc47e8361ef8759d34d63353adecf7ff219c91ab30d2ee2475c176bfc0896c3506747de9cae2cc792145595106b74e0166801fe04dd77f748ee9a32fee4ff5476410b10ae62be54ba06bda235596048f38b29e85bd8b9ea7be802080f17fd89b820660a2cde7c0ac307edab21ba0de5be4066b1c10ea1363d029c3065a0a8e9bd918129f67af68edbda411c4e2836cd54ec6295ea9ce63f067fef1a00944b3d316829b8340e0136018bee43d023dffbc442a8c224bea656ee5030a3691e0746891c18f83eacaee10d56b4867c2e8eaf4e2d62c64da98d35c7d32f82e2b99e4023d668a7191c9926b17518ec447bc8a06be422390b691f94a23ca82e734d5ea58e86d14bc16c3393de95fb1300c268b11bfcd71541b2e8ffc78c3da7882dae19f0f4d291f81f7e569080f676931c9149578dd620fe362bd7d94728008884d977187e56e52e3dbd059fe0e83eae8d0c8b5bd6173fc58332df1f1a049e9b0a291e47f35631955fac42c74fe69711a63e6d54739e113347c500e29a6627070a3eb72535599ae3cce04b99613a1a77ca73c4c3e6ecd4a62dc2d7e74ff4f174ed598efc7cae955b37b921883f007bb781766cca267b4a222a5bec48b2ae663a38ae72f9e48b6d5685331609acfa57167163b1e54459f937e90d7f6c2fa609d0c482494848cc1e89751bcbfe7848e5ffa2b69320db8dde2e009c3d14e1f35716e20e25426b69e8ccdbdf4ad4b20b290847db7a2f6885737b13caedd90d2a063dc650a9a9188c0cac92896cf721e76c638cfebf1f3894df763ef8209d4b9efe878c1ba1302bf84b8637b2ea79d4423340ed057f6dd632e92aedbfe54d980ba2d3337548a77e6dff6271bc2321dedcf650af9c327a6d83db7208b9e2943fadb654f0f429e2de671ee82da88cacea72318ca2587c9b503de81d271080fc3ab3061b5d9f7a572b599755b26ab221ae82dad3e6404d324a6d66dfe0c7752610a27aef0206d51c635184c0edd2c531477591e7428ed5e993b23edf45dc1f2fba73380158e3896c8e8984be07f48cf45d85d7d350712496228d6463670fc9ad20d02b38238bda11a673b84c2b6d60c65ae9c40508ed621521cb5dc120637cb1385dd898af4304b922a543174d25a2c4628223ec4947b345d5fc6b9fd3bc09177b15ebb25a2b63573985af97cb83bff1b8d500b5e5263a85f4e9c4e0ee1f19ebac62b1c2cf4c3c794ed299a762b320118674757653d5920cdb872f47085334d99c5e15f5c2be351d1f0008903c976b328965814e0cc6b3216ddddb7e980671a56d52b9f9ec1975b8b5d0777699546b8403595f9c3e7afa945348338ed231d9e810e4db9401dd576558a0f3d1f15f4ac71de7e6e5efda251208d4d14e1cd892a3d9c047e93189d65c75a6151ee24944a2659306270a4d4b8f2da1626c17c9e0cca8c9df7b6b624aa0812d66f806e0b316c1a9499cbf539cf0b8895a5ac550e3e19d5fd44650ccee717d44ace95536c54e93aee24c0bf27a629ccd68c1b380174a163ffd5f25b4126d604987b36d4a6298e6f8ecc90e5784a03a3170e283c2081e3eed9a36fee325e7435442768ac4e2ac9d6d9fffaca282cab05b7636fcec38b2ac627cbb22078d16ffa2dca768042c8c7a2b315e2214261547ea45e763f4010b082b38dabd162083e59b6e2149b82465dd02daad41c02e2d322d0b9d329c9ea2d43283b09d6a9f103c2847d431442a1fba4e1bd8b0a684ce5c2eb1e7fec23e624dc586e452132cd54461141e87b5bf22e71a2ae731f10284f4769eb6f6eeab8cb6a6e6edfc0d9b82b64e2cbc00d67dc66d41af80aa82691377bc83522527c1b6ccd4a9969cac3beae4cab47fea2d1db651a3979df0f1c2ed5a45d33d0da24d78fc33c3a51e2651ac7519affe2b8f0083ee13cf6bd93ed0024941b19b6120b17ebdbf098fcb68201beee1fa2ff26de0a9822c97812523b41312761aa662293c08bbfbd156053d6c58d99dd6a33fb4ce4f8aaeefa67c32a0a48db1ce1646b51be3c0cf4795077e29b0a3aa5389ede350d52d004ef747fe82e47f8f25b77c9e450addfee91c0dcee79823ac27eb3a5345a2d212edeefe052c29c6cde15194ba864c1b8eee16a6c85238a66872527b4a7e9748a0c5f9c4e8e0fb5d99609436e49d446c6f33fc20da4606f1e470ce4f8588411c4c5a4b62750147dcd565214f111ce6ba989350516dfc65ee695e5c1c8eadb5b6cd5e8e1c6ee9ebffc20f5dd9c82c980a31d89cbfa8cfad815fa3f4aaecb24b708dc81a5bb3845f159df97ee544b62bd386747b2d109cabb090162b9b58d624454d0789826c77f0b57a4bc7ef872be68ebc1ec8a7130317258b51b25f24d0cedc472a770980f6b7c0cc8b50b17127fa2afd3bfc79e1d0aa2da12fb5ce83bf453efc1e5b67add77d135a15f5c6db761b3cd272f6f0b26d445ec0d31baf660322a76257e188e1dcac8f73505a10b4fa4610d76bd4e9237094623bbd088affd68af3d0eb4844e4282271e96e551ecec5bb7617d205b1271c55ab271860bac8d4083b8555984cb77a612e3c528e8fbfb5478b5f47f058a7e4f1c5ec3a27b7c7dd4246b2b860ea26ed3c8c4501426a3f42a64165e91eb1a31aeeb03ebb5957854aa9cf67d59a8e020208e0a0affb5b1c2aa1e1a033b8328ccb8f514f7dc296616bba8592c8ac6e2fa7579f06238a153e311ae2f6d9c13b04eaa850acd1f7dcb670c2cd38049af138cfba2207a5890b51b451c1d062c776d7ca12a2c01abf84f484b8e01ededbabb72bb27b88a3a4d6edf3aa48c0acb96051e8c5d4d81c00174b8fdd73da772dc0fc18f1ebd863b5c30930226cf4632fa6603d77ca8c21381a4ebd9f0f399a15a672d820d3923c06831ba4f77c6af403a74d47f848aee7c78669fe7b98a6dac8a2d5f2d3536c654429dbe4688c6075f55718040adf7a2ef50bed277eaa099d0534e5a40706e9b688dfa44863158bfaefb1a14c3730327132c68888f140c2eef8b97ecd084b9d97c4d2be675861ede9efd252877edc661d031990da2ba129f0b95c6b25a651474f156d23dd2047f62af37d1b2892b37d82a62740d0982f85a80ab236d7e2f327d388c3c47c94a77733a77c309972c407b564b39b8dc46d6f1c9c1d8a63849e387c2f70daae38cc40de9bd6850b9ffdee50e4248b30c2fdd2df9767d7e2239b307f89186238a91d3845d8d6577a925c230aa4158e60289434c2758b17af48267f85d0ef2e2c634d0a928d1f7331c4e58c319224b99d264b279f329079d1988918c3ca4ded1442aead0899ce2f8c93e2f3174f921eceb181cc69a033efa7f5db12d8fd8580b01870470691c92adfc9eb9fc194c249d93ca1ef8a424687b4095c576c4ffbca2990b504ff0a3f317a8b82a8facfc47d71c0751df15a5a110373d9d97fc25e4f52008c8f68d662458d1a6f6ac81bde4ca0368a8ade489000c2bee86580f03f307a3292d328400c8af5f37d142467e7c689f30b59fdfe806617888335fb4ffb7cc93a0b9009f4b9d626926ac9864edabf6f8539a2f6390e7a2d9a0905ebe9c57f7f776449a768c66b9d08c83ef10cf35e1db8310dce84c78a35805902dca44886d842909e4a386f60f744685adb41f49534df3edb21b3d547982a03af7160075bb81a9ab7d93ed5b5b6503805948011914065353e474409b8b1510807d970545f45356e2e8bf2fe3abc38f6828b9e47c540345c0a06d4f4654c23f62ae559d4bf800314ef00bae23464717b25ef8fa2dbdd3db292ab1e179506db43da4a9fb0ed2da70e73e6d914c3e794497fc4b39d511ebf2dcab212be5f3c59cadf853ec458fff1e8bb078005d2c113a50d0fa27ac6a6e71f9e029351f966aa3eca5073e4e63c10f6b052dbd117d9611c94126611ed7a0f3e08fea4f60b336019b40c8dad8258d81d649bca58c3cd23c52c2a82cc3b1838cb703d62c6555455567f2e5d6ca3cced63188e5b92ee320aec12f6368a544db9b1d5c72377e17725626d9fdaf2c070d3a4ccb311bc6977baa7410634333d016ddf49efdcbd85a6560ada9d747f58a61c12551c81df13212320efb8c4d6c64d4d360c1d2517fd96534713336225b326c001f085ecdcb818d307196efb554a8958eecea4e54f7fb7698221d75e43c55b09437fdd7dcbb94c9ec1b006bdeb222aefee658fa4792219694e5b4bf438df9788fb48fbd54f5dfb60682b2fc7cb633501d767be2cdcb5d1c089270a04a55149a7f8c81fbf8cae8170158908c08283db2cc556abcdc517170e7147f56f776670e94037e233f922e936e893e83f5ae4022deed964614be615fa7385bfa579cd1b81a9e112c8351f560d6f6b8382311f0dac819ad0a71ea21ccf3489ad45112dd1a1dc698db551ed8af8e0b64ce39ba0f912efe3ea1350cf16c0e6b620a412752c43fdbb20c014821ed4c2a2507d03fc3736b782c31a4695549ee2e56250eda6bf54cba543c3808388e24405fd7a119ad14146f9c035bb2c97099f743b09431c56fccc18708542c51e1661d6f6b253afa3d06d810745bb388e0dea7e7e9a9f34f974af874b65f997ebea5504aa4a05cdea5e31362ec4e3f5e804e6f7eefde0458a02bdbbd85bf95d01114a8558fe2a4669929a7c818690919b6119c25739d1cefa39dfa6d898702a4d2117e0937baeeb5fe51965e4c6e5b9da04b29bbc00e84abcda4d493efd894146564442fbda00cc0c72c0d768874524a06c42e7ce6a0723397f859b5a41e0ec95268b307de9f19d3bc8e09d15e72e419975af2a734c736ec033128cc0150a941f91c9372bbcf707ef4a54cf5326cd3433be8cf56f69f8611c46ad16c120bde501e59087b2f73a61fe67f950d674ba36aee0fd5855baa79aa322b4bc66d44f411e72efdd0d63caf0084b998b5e01988df0e4b35e3a42c200cf65ffe28766a2b925c41a1816ab55f36be6c551639244d1905cf7364423540bbcd5d3c807ba9994e12da4be504a8a52f4103f955ef5c9f29bbe6801439b7d9383cce81b2f8d6970b5d6ab8012479a92809f17291be0711eff5d1b8c1c0935995da88f156c8e4e63d9b06f79778e3fe0aa333c49fee6eb29a22d08689d3b57e77cfcdf3aab05f46444f5eb51d07c19720458d43499f801564d4e1eeac0fd97d88eb454a1c38ca8f672f6ca0b389ceb236c11508f2eec9716c15d390d71cea43097b9cdbfccdd6a611fffffd8d6d378edb925792c9d8a82272c30354c5f17d4ca7c62520fe25a7efe5fff5672064e7d838a7d064cbf2d2193cf086dd2055b58409e984aa4fb202b758b7575bd3f5697a27a37a513acdad28e82a7a84ab8ba5e08bd63ce60b03189de55941f479b7e089ff4795591c1c57b94a13edb52d940b455ef06f56fbf3869da72d16caeef4260f7d8542f0cea0153ae148a4f797e65d8fc785eb31f4c5a04de6e775cbc4b7432d8f7ee33c9808d25e3eba6d4d0522a1294888ad7ea41a981d2d0d89ecbf882286a04bb135f033a429260a5116453dc79679b7fa56485a96e4897aa05809d0f41b110dc6e154057a88eb284b0618f0d4f57ebf2f9a0b49f2deb685b48b0e8ed7662eff4c8bef94c5c8895b90cec127b22646049b12a22cc8b97c57afb639ce873bcc520f9899817b080b6b21dad0a8a5f4fc84a4bc2b7b67b2d23f342910098b03835ab75648a05ddb6f09bc6202275f7321b752458ed72e7f22c51683957eed7fd01c1a11c88a7d583d3992ef6f21f261e1324cb89697bba6caaa9c1823e5ba0b92733909b38d246af51082e474a119391eabe7deda43b0ff6e1e78dfa1839f9f36295eb7c7a414983d7ae7a66ace1eabd8876a18f72e5caf2f45a17590d3cf580a9b43f33806b81ced5290a68e0e4c996b47ac1030a11db9cb2a6078d804225197de4d4c2a47b6c3bc2674fae45de7f20bf45673a9885b26e3a60b82307f0bacca57decd9ca2fb84cfbabece3c355b66db528096e188f32f1b9bdc51feb9d06a50e43676ac7b77fc49fbb489331e6e099d1f09c3e35447dcfaaacef40dd8d31acccd51dea0a2f6fa0a05528716bd6db99ed89243f169a2a33e72bd0dbebc0744fc16584e9baf2e82010684122fbb1dbc4babfe95ceca10d102b6c6021a5d8a9bd7ae5f07cb5f6c9201ab9111df191cf95b12c2a049125cfa630b0656d910a3db30368ccdd5b3a038d837473c71d475e0e226a7e61db24790380232316892c091860fa2207de6048e6f1287dc051b6fb22188fcb3b28966163878a5aef1eb89d0fefa34154369f555ebae8f9a9a78f3c294ed1b2f110d7df0c101c67d19e5dbdf3403892bf626fa183f9ab5d74d6a58317bdfd5ca3d4ec51c28a39989e19d7e80c9c8524efd3b55fd2524be91f929cfc514a648e455d0afdb0291fb9e78c0bf8bab7a305db17d51356e7eec869126602397e6535f8090edc13e659afeb409d02264c3137afa9e7216852d3323decd5bcacb211ba33e418ab9607edec8119700309d199bc4dbc2769165e50f92ae10e6ced6d643e4965106445277cf19d5439c9fac6c4ab398ce4bc2fa818911af0d37d6b3bf2aedb81fdbd841bc185624353f17fdbfa2971336cbd0286ab622d8c315b906ace091f5aa23ef52196fc724513d740de2c23ba1da374c237c58a357e6bf8aea1d4c8249b884ba475000f34927c62cc546884e7922721fee5310fccd54856e6703046d7e99363bf423c03ae184ddb56d3a1494d1f7f5790954b15428658e7f647431e799703e4eac0f67427f51742f0ad58e994259f5b30f2de5b5f6b80eb0666d24fdcc1bdaaf63ada0326ad0f2a43c24d2035187a68bdbbaafbdca7e8b911b87ae74976a8cdb60af3f851e0effec27ce956e63eddd42921a32a23899d26651493b1e48daf223ed8ead3297d081e72d310149279ffd7bc29900dc747a6989cc256786603690b9f42217f7315f63454aa25d1c24eef64643b4ddbce78b9c2bf5e5476c2aa37556ea675153f0307f2b0230f65e72a317e27f94ffcc6e8422c8486583311801e5a5c2918a5a072b73623e16d1eef7edab112eb34e6e7633cfca54fb0a74e5cb08f61a9c9fc54d9823a05e7db131c2da9ee2a7323ac78e3cc116b4a585d83b132768a25ae4927cd02516a531c29a40b5c2c6dee2da9d5e8824cba65eab0ede7c55bd1edd2444e68b7ca363a5a465914ee11f6c0626f23412cd622d2da115140f16b0ab26cb488aacb3f334c27ef1dd0e9c36c549f346423c8d63984c9eca21579d52e2b3625b9bd12ddee6f0958abe44a159cf2d20539a5a0567d82f784302d02089877d5f10db4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
