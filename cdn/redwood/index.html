<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39c20427b82727aae2a2eb8399b40b7e71f99bef189a29c04a0f2cbe377b8962948346a8bec06d4d58b6a972b46fc0f49982b273d8775ece70a9e00b9227961d7ddad6a027dbf57d897ec25749a6de8661c15c55f9620b899ceec28c8defd4033a1d84399ffdaef5f91599f51bda9b8d5a4f1b628a9dd90f1bd93da9d9e7f964e68fdc4e6d213ca7ef97168719ef061d67036ab61e0dc3b441725322d083d9ac95445fd7028523e8aeed7b36a8b842a46375e3aaa5e8271beaf769afa4cc1116c487ca9d1aa43acdf7dc5d0165b7679dd2e41b120aa2995ff94d4b418e595fbe2258d688ca2652cbeec62126f6515ceb4aeb0249dc5dc3f4dc282c951fb1f5cc1fa1a6c8959dad302050f6722594803f09b5f5f5e989dd5a5a795021012498ad738131ac7433642be2231980013c0c0a0ff55080fdc0ba551c464fe75a6ef333e9ec2a0cad951ed2b1763860556107accff79a3c93e4deabc1efa1d5096ca8e880bd83c3da117b6053c99dae2ede6264fcbd118ce0a4cd28ec554f9a690841f5753b203a0aae47290057032a4ccb6153c485ec29ab52eb96a91b95d5587ab9d57d51cbcbae3f4284fac921b514ebaeccc6fa4f52ee693487a1f02c8a0061d616a93d269e79a80d356bbffd9d15ea715f10f0d9665bd99ea18faf16c21f44bb4b63f6b97fa4c294a1c2eb3b82e9430e36dcec299bd908ea5384908bdd112d6f054d7f391e725c87cdc1a14c98e4bf680c624bf56bc41d1e6f8927ccb47713b8e847dd31fd7321b5b02ba1f0a0bc58e7ab851ccb711261b419849239ef09b029db4e1a3a2d6339d14bfe46db7a6404c755211be15d9d1dbdf8a762bb56f8b8a37c9e4e646401e02924e6ccefb6900648a453eee1206c3e551c92eef897448899bba7dc94f2a5024b0a0f837c9b07a5380c7f786dd3ed096b82afaa95d6095ac82cc2f69499c2086871f8f064a778517af6eefa5b9932e31b2084de9d57cb2375f732343966d03d7ca5672528330991ff27e046de3d0f668b2e8cafad796251b0b94ab1e9f23c82572b8c2e7f7010e61f5ffe95fd78b8d54389c7099eceea8b5929f2cfa14d7dd2fb4d25569c12b963a32b24ff0eebb4f8717b234116fdd11885b7ea400fdbe11770dc8f87bbf5166c60afb41730e143d9c32177c2c7f8a2d06074b2d33241937578a363537e38cf40e5a7724f364931ebfc70a56cf044cdb22618fd8122ab12c67b7b8e29e21255a3756cd4ef51628588862073b98daa2852e093d74a5c5b0f8c207ebe61ef9a474cfa172aee98df5b0fbc59e6c6f0a7092266c64302ac7ee654d4a304421a8b8ec5e56723708240ace53afcc92a17cf2d8d94fbe376170a131648b104b06c0109e659ad4083643dfaee1238ae7d9a435bb4ee22991f907500424469001ae65519e1eae38ee197df24269d608c5b269be8fe042a85d77f6d5a0cf821f41f5cee01f9b1e16997967344c18d235f7bafbc62e72f032884e66b0b3110ed78232f2bad208520a280c86d578205e16698afba68a9f9504110c81303feecd54d96e0930dc5a466f77428c0f2b142a67b89a451ee929f794aab1efeb3f693af595fa5a448110b654712fbc18e95b70ec366537cbefab5f6269ae8557229f78e5fc999cf3c15352bfaace70b90db3ada9fe944202b07f7ca2ce80c1d80d0c9c700e0fb2722fde47104cc9abd729d0a5e4e49b4adf795360fa4e5c96fe72b4d53b8b5fd5ce53d6384658c53ff2e5b87e3bab1f33e013b8df1715c55c4b931e9326ff882e6098629a564c48c37ed5940214fcd72942e982e8ff085c3bd27d968900451c9b6292e3d33886421e5c869a07d170bda54643d808a1dfb63802f2f95c6f7c7d5ef51a62aaf04ea9149581f819ebfad59fa6c18847a304b826c4b464df3d18ef64eb5dd94260825ff9f37a953958c931e2d92cecf9dc44594e8629d4e5a8ee3b4407567239b316fefe7052e371ba02f2be417dfe07a52a115a8192083f6619efe9572a085963bc295c1c11eb6fce6f38ab27267c7fc4b576f113bb0ff06289363fa6d896aa0a5d518df6d387dd2ceb268aa8bbc0fa6d4155ffe25150333ea649f95a584c98e44f661f9b8a825ba4c13c7d49a1e34043ee6278002fe5a6e23df1c29edc746ff8dbc74d21d199d398959373de82cfdf4ae7d0f72b4086e260d2dda80efa5a83c0653e1f88c144752735f6ae906481623fae749793578b00bdab4c77f4e6fe35f753e56f28d679b5fcdad44ed88943b347cdb110f239f30b1e4db93f8c35b19b5b970758320bb4094e69522c42b109183a5a524fd1202c71efa22120afb4233192c0b32052ac931184ddafa1a5c395dce11107c9b6bb1d3bef5951c3257ab9e3a95048ba4eaf990d570b52e5ebcc5c60f80fc4108714fb1555c9e2b36bd4a66795a99120a6c09fc93fabf0be8cab23ac473c12a254d1ea064bdcc17bad315e6abcf5e85165b1d793aa76fa034eac8845aff87242456472aa98313652f7a748f9156b76ce97e05171b100eb789571973b21ce720a856b9dd3497719e3555c2e0f1a005c41a7304c4b8958d9fb10190c036c9401bb083101c65a103119d5c4315327e1c90aa7c832679f58d1f1089d2a75eb9841051d6c8b157cbd366df81608bf02821707bd7c9e7976322130cd85525c4d37eda5cb67bd581b5fc1cfabe7595ca14f15ca69671f7a48a5b176d457c97c922e956291682d76fc2f84004cc2259b8fe07a48f36dffb0be38dd7920a985ede0467254267d1eef8c79bd56c5b96ef50f636d638852f5971ed1a91ace2033c7fc841a6b1939b5981670e17b9e76ad2912c28f36d3b79ac466fd1214f4ed82974be8426d215a3b3b2a61d42c66c55a07b2720a86c63f6a12a0794470757aea3f538cf625caef1fdf905f9dfbc608a7409a95bd2c761b2feba3f8effe8b94e247bfd0cf38a8a2eb6b4a58dd01bc03ca2875a98a0cb5184495740c3a5b61670628a4f073978710479898471f20a128e8065f82516c21e291034c55e05664d94c5fdef93224b85edad68d702449ba297602ef39ae21dc74415d138f110bcf248b9b9c11fe8862d8c998d7c0505b5e5bda6974256e52675cd18340e397c3d407ff98c8f328bc116840bac3083adbade53ba8cf79aabec25ceff6cdb972dbecd3fb37d03ae67551936669a738f9cedd2c6450e84ac9dd91e5589ea7f80ed8f7d7831daa2589c9d3a93c7dcf78a7088a541d174bb030614748cf86881bbf2af3c112d0baea2f04ec5b0970806b5f471e65beae79106a2679deb527f12e34aea941bfe7d2778b5749b906ec0a069d633c062e851a34657ad637b6c2ffe4b2c5f8142c923e56beb7ea9dd46093a95288485747e250a709e7dcc4fbd0d55a7e92da75216503d1e1f27920be26e0df419c45e0ed59b5438047b7d5f3e73621141791d7822e7439061c7d78d4f2db41edfcefab4434ffa980392a7f38bdac71ffa4f8339d9c4943b45758219db92c06420d8681b22dae9515228cc153e478a3db2ff35e0f552ed09609f8b663ed85fb3b2c08f13d1c444683b7f1d3b09501b4768b88da37059c16cd5363cdde445a9cf9fce18efbd011e516cdbb300309c71ec0cc54c08052f27bcff28d037eeb232b9d6dcf65e9f69a4438a32922e213e459c09dfa70931f502b92a45d38086dcd59d98c709500762d6e053e4e586164afcda721731fb90bb141b174ad38b48e763ef5ec47b30ee0768d3b5ad37f78643a9a5a5d99321428f1802d986708f80939f6f21399e5f77f03f828947f05cdd3e933d64c814fb1f8299b340f84ec62b33fc1859f5dbf19139aa82cd7a218eef188630232aae49f4746ede294d2aa08bc1d600ad18bb2060122f2f226b3f663218172f2770e4d3129b7f959cf931e6e4aa324b8ebad3f95a11549395a82267d98a40b2920aaac96fc8bbd63321a92e00192671bee992881e0c9e8ae00e721c4954b2159f6af4db4fe67f12b2622b18510a35d4ee12e8b0b6442524d5ad5029837038493def4246f5f4fdfce098c7551558cbdab46bf707d86056f3a46c65406a1dfc6a0830760d8e014e267ec98c0aa999971c8d7eca8451c548c8f9e6bb0e1d61fd622d063fd487214a383f327f163b6be0eb92f88984d19cc0e5138ae326a21478d848451d4d0e45cf7b395dfe961ee4faf1665f7ad075b1f5d5ef8728c54143a713e95f7dbae7554ef21a5b55cce604b72f5a08451a0fb41aeeb1dd82505bd6efb7a67b75dfb8d48e149192359ee98372d687c41f8b2c93162843d88c7e01906292e655dc054bb3d73ccd34f71f445f26c2281b5c28114be5262271aa55528cf4e24b8ca8d19812134113e4d27702f3801d31057db27933f63b2b9771159a69656a95775e72f6d2f9a9766426171a2697f215b607f01ee01d514b5c473e79eec83b60608e78fcb64064d374419805b26a22c6dd79eec2610e13e2f2a2fe5cb29779ba47a4dffb010005b4091155984e91db2f345f45060c4bfc4accf75fcee5e097fe22dd9fae5d79531bb2b2284ef46d6949f54e8b34845b581b74bebb5560cd8139998874e15c6baf548bd3217888a473d14acb4c728da499fc74406700e4b488eff43732f83cea5858a6f15256ef68d6957dd78c23745031a6336344875f118041a377f874c0d5a7f6c2049e407744a711807cdcda302efc5d137ae93b2ff9fc88227159d1b1db16354017cb1c0bff6b044b8e27d4ef7070e85c549f28962cca6c30fd06adfc6fc756c3c54242a98ce26111932386bb34a4735edf4dd0778f89ee1dc9ebfe3c2d934efa3610e1615b2808c089516b80f7e14bfaafc18185b9482a118900656a8bd1053e700a0f227677a5815ee4b99ba75b84140604309f024e870dee44d92ee94c5389ff64883ddc93d288282838e238ee6c94345677ff83015abf136aca9536bf883f403d4a4c001cc581ae8ad062eec3257a95fe522982375e1c509198f848fc5bd095184af428e8d02502d098ebcb14095d7c0621b946b7c26273fe575929b4ee5f409bf5da06ff2dcca939695dc40ea83dc37a15e1afaaf291f008fc0ef29a44d60c2b3c16f11820d23e4988dfc1a2960ec3bb730624cc4a7311e903a9d0705a86976e27508e3583ac7218fed27b6201cc033eaeb1b0143e295247c7083dc5c4594a4a35fd3197e433ed025ce04d543e50aff9aee874dfcac22ccc9736ee7b6667fb78fd6f75711134066886761037dc5efb7c26ee73db2fca41831ee0474762b8d82b5b4b0ad30b717be17bd05c7b0f5ab54056432f1e0d371dca25897ce90c12d82a1aaab6bc5ed2b1dd95bb7b78b1cbec107dab163894d5342eb852a11bfabbc747986f054d27d74335107ab4ef46a1c38280e6c9be9708e542a7343126db2836622a50408f7fca9b393a9470aa76f0135cb656c16b91ac1a743c4965b460ed3f0f0c7215fafea20f65b6a75f8e2683d0413f667085e69db1c9051dc5f0621f96e0d73279140cf08fe5a77e5c488176b834cf78def4a1682375987102db5d12c9bc02660fb53cd7deb34d8d666f63a291b3a3cbe7d7c58a4b8b8400b6b027cd87bf60cd3069aa97b7bffecc0056ad340cdf94331499814c42c2e9e2295267914fe12168d4b8e9daaf06cf7f7de0c1c532707ab68d435b1dc907640a57b576b222246ebd2f60f570a9cfd493920e093d6541255d9970c337d7f828c1ac7d01f92b780fea29a224ff5e4c6fbba4bfd592ca630bcf314aa0200966b431280912750d6f4b76c445cf2ea93c4cdf8a6020ae790a8116bbac993a002df7438d21fefc718cd346a680079ed0b51135a984ee77c8a2e7769399de6fa5573d7c4bc254caab428a7b817fc8164cde4a0ff52c1fcb42d981371ad1f990c568dbbbccf61a4fe6e7f3ac60a5002dbb3b39de2579e741c508c1197c2cb7ce01ca801d276c6f1cefab5abe279d7ef6046fe904a9dd754b65d69372deaef839874012ad82639d8cc147b72933f908b8befbfb3b0cccc728b71a46b0af8876c1f4b380a06c6ab6ecd23603eb74bf03b7ec30e4ca4f010fcd5ad209ff5ccc43d7d722863f5a445651773519f91b9a14238a026cb95b9422011a92779c11b2e91f1e4e2f7881a78d695cc04d2538abc5a855b581d4fed750d9ac5557f50a87d6bab395dc55176e44d8556f9266b7e30d7635d2fe4589c3cc1e42dae27d457fcbe67a3334facd26025d6bb306948dceddd638fd4ca17cd90b26031af2c14fde2ccce106ce8729b7b2c76bb55351786de7e442876ec448ca1ab90e77041053d2df882a7766142a306df8acbc6c3903dd725e09cb04888954b2e7a14abe90843859754ba73104d8bbc7e9722b3dfa352820c9714dc0fd406a42be7d1b512e1c461f582fbec73b20b930ee0165848776a99d737e6f2b60a9fd04e08fd59efc08193787b022c240d5f4a3e3665498c151360acc1ca0c5f32636bdb856c2570aadd123f33593a26cd4a4787a7b655d4d58c1cdb7d14c81fa0540b3127f31a52566bf8735d4773a9e972b4559582eb61d62aa49a929a691aeed0347d063935b32bb5d1a81b0753c07041c23242de7ded018c38aacb76d2d8f327f3716ba8341d0c5af02c18661fd1b4f351c8ae7f8bf7775f1771faa64eb0c07fb5bc88df82092a9553c3ce7446287bc88a86eaafe08c2512b9b72ee4f8bb218ef94b2101c52e4a3181225158239405a10e8535db26c0d001376d0ced5f92376bbe217e51266c80df317aa5de947de3d06d2807c76b52949da69ee37944717afe20e926f53e0f4728fe3f5b29cbf5df02b454e3e86cab3b480d0a4474f8a4865b7d1ca4f13e8f68d8c9defc4452ecb7ddf954fa5708db4f086b5ee888a40e1d5ca29275f9cb1447454c03e79da20367bdda304d25b175366b68c71be4823a38ef0956424ad3911f9c1aa8a8ce2a05e96615702cb1783b01368b7bdf07c5e3fd82cd1cfc50b44ece79bdf760c722608022aa85276503979327f1ceac74463e4be2afdc8296e510dc13095edd72dc18f512b253a958851193eda9280e0d58e63a5e6773506af0abdfc0695609c09e6a567e984fd32e9e35492ccfeeca0ee2d0af559d13f6950798c366af9293c534a17c2458dabff15740a3d26ea019d18f03adb29e2e4def4a3c9f89787057b8a47e2d61d38b8db42c1d28b9fbdbfee554f439e80282c50aaf59ad1139e7aa6062d56dc9a04a56b5cbb394ab9a223e5464d9c4f85c3a38830907a740d219975fed944593c499a40bde8dc8fe480ffb3d20e9324b2e04d868ffe56964574adc261207351ce3ed71d359c5475b1bd27b8e753eec43e9c849112bd658b43c3d1ab85d2ea98d877278a26c8363e0831f2acc0605637f8c49c297c76f02abead29e303fde2f3795baebc8adf3a6014a5d4705b88b1bb4a88391cce302234cd02777221832107e70fc369fbccdfc02a625643c6490007b389c6a8b050aa2b183cb62942afba64438980793c1409c26bc050f03feafe3a56dee7e776299c19f7a14e2fb5cce6d853c6b7347d11acdc018391249e8966d4915af7cb87a8a63f5ff7a6584a88f8196febab8c2defdc0db73a076d259ace8c227998bbc2205e498e0c7e4fc61355a181a60217ec642f93a17eb034a1ad47294423672ec0d27e32577ba51ff11c3aa57a934bf0faf2428073db9d991b465fee38e7759eef1959bb71c33227373da667881a642a73695621f46b28282a872d9a97fce2fcec8202e8a36abd34648cd9b271491595445d3fd055c5b09510042448f6ae6ff3d5c7f672f7d0327260424078f5280701539cccfa9e9402f727818792fb97e93479906989a4dad81a37ce20285fef603a81a9b0b24dc4545487d242d5644acfd0dbd81f0b884a7274a3962f8b0ac4f83a695eaa99206c5181aaeb3d048712721456855577eb98c5e50bd285945f82f5ae4ec2e95639326dfbb88d5a61d574664d3651f11835fc3b252d0dfc2a40db6250e5630067fc8587b7b801920b820932fdbd41f0a32647959238250171141e5ce875b1b4167aa55c2b079ec6158b9c86e2da246426d55caefa02f52700e1afa8146069dae15e63c03048473b61ed53b1e8792e8a2f9f2490bc553e559973892badf4cf0176825fd0bb107a5babbe335ad3dadfd4a27192c8e5f5e6d26732b8b829f978690999b9dc7ca6271027e19ad8244178b25021fdf526267d50609a36cf8b82891cd1f607bd18e48933ebf1615fc1561d60be3c25046ade6ee668cab79bfe1c99aa6be94c199f4c5c00b28aec274f1597e41e018ffc4ed3fac92a4f18d01af00d56fb81054e7a0cabd05fcd576b881c001250835a4058de6d94da5e3908ed1dbe2b645dc4587a117c7d9f6377bc73e2d7b7ba21f13f74c8736e6dabeb59e01744b5710924cd05882dbd6a62e510eb15224570d3345eb23d7e0f5c8bcd2764d355d21bf76d39c29c5f16ade545fe1e932900a9bc07f5d0c723da881f844af6491182db45ba55415178a118f45f81ce3912027a860e34654b4b7065c971f2db9643946158575dfdffb68fa5565a923674643cd37d993953595d19bec7ec6b66bc66b9e0339d3a7f632a791339ef066f46d467249ba85738e039bfa194b1a041d2302a5cb30562d3577e7ad833fa3cc0eef2b9825174386c20154bb7ae5d6ef7037a3c623e83c57433576b15b985e76e2cb5e7ad78db92666c7d5bdcff9d3ed27da8fc62e7040df15091238c1597c0122cfcdd42cb761710b82c7d6ffbda9d78587060f61f266b9f160481f57384226ad55ddda3363ada4cbacaf0f7c30ec33a8fc84bafaac43da8234a687a374d576e568b18b469353631a72dcfd623664bc5ec3ee07f1b8c242f7e9f43da0272ca2dbefd08a2d05cb6f277195a4b6f6c50df15ad62a583e48bdcec39f120f16a25fd582809df4831c7846aef601015ed4b034b08e70d0bf4e93a9d1bf3f81b996a95f0d7392702859bfc924b13454cbb2789700d02667b4e7d40ee0a6ed262c340743be8a21b7349dba1b5de8f93197be128efff429bf66b9b50d854d3d356ad4bc1c16e070c36385335367b78b4d9bab6957e545cd48c42c328d43d4fe8f28d99405dcbb375305c671728904c65e3072c0a60bf5e4d8d7612304570e12bb0566c55692105a2350b64ba9cec33b04adddeafc14eaed988fc1cb9346714d936bbaf84302bf7366a3cf7f6b7758a357b9fd7283c805fc0f171156f4257952bae29a350c65d54acf3be80e116004d37d9cf0cbfe3ecb51c4bcd7fc535a41814ce36c54b868be2f80d00f564dd7b0a89b65e9a629721e8e96cc1095f60adf73c865c8e1caef8208dc6b0a3a355766f2ebc68d5403ef518288bb434edd5d01dcbdc4631fe53b0979b0094aa6bed28f10c9812d845bdb7352f11cbdc83c8a8d76b08143f7b49db9a521c8d2dd9566bbcac08ab37b2797e664d3c154ad1cbb878ed415bd16be5f5f22e4c595bfcd3e981074c5e4da27bb37cd83d0959636fe729e83e25ceeb3ac178282c268f40878d0cdb0790d7101a48eba41079d34769a3a9e9d7e9437881e0194f800ca02ec5989f37987fea315e0be60a687d7681f377840eab0278956edec3b09c6a6ca0797e14efc1cef9eb449342aa723c161d50c94959a74c0da892deae9f8cc4d6c4ecfa93073090816124733040193f97e7142aa2d5a53cf116510ad28cd806470d63e6af2c55038f15fb4d1c85b94e603a66d3a8f083a845044674448f9ff2483ef7768368d4c276972ed0a41fc476db54009c62e0871fad212cd2a1cc24179136ae4752c5085989ba20e9f849a7e38e7c18c762b1c1bdbb2341dfc2ee33c0cd04bbbafedaf4822b30b1aafabc9b32fa72c157620443e02a9b9ef422dee2575c265dd38949ac41b871a9a911fd0db51002b480e84b3c2d87f45234a582d4a2d60db603fddaa38665f72807d458a7facb0bda35136098298f2adf4711e6734f1a310646955d2fc5166fa4e8082fe486ba5db1afd4fa86dc5e041c587de2184123aec31ce14656e67effc01f9dafc57568906d3091340225182d4765c242dcd012edcacf874fd5e4700a774a8be9f88c4ebea11b4b0f1d8760c90e3195d57690e5c4b8d7080783c64f82cadeaa789a336d09becb178cf5d8e5b88edf3080e5fd3853a5606174096a5e89ef13c5d5b614cd187a75779bf5a73cadb0faa8430508afe49a4b2d899167ca2cd7a92b60f866ea7753326796d4123dde90cef1624765252cdcd164b03a6a8dc8074b1107094f7724959874d39477ebdf5dc1139d1415e03d12a6f335589b81dcaa04506c25e9252c0ab995733128de4192695168b571be7fcc73d704c670f353c66357ecd1329726b5916d22ef264b671581b5e787c5e23e43ddb16323bca4ef5b8d5a08f95058e9a7da0e238d3fd71ac661fa9c5c8a6e0fad42dcc81a00dabd071e8bb1de8cc0e5074e49e740090d10e6b8eb557d3cb711b8df9af90bfd4358d2e202e6b7f7d61d0fabeb5e834d6d989166441f8db4b9cbb4e5a1ae9b45e0c478d8e6a1d479d3149807a008df7377ac4eb217cc53624751ad9cdbc45adb7616e841646f0322aa12889a24fb59175940e9af0f0fbf27601fa31bb330b20467de3fc8b02e3497bd12b1a385402de764d512719559d89c525bae4e7a30e7809f80c13c57483c1323631f92171c7d29bf4faa415e46050c2cbea1bbb05090a992a3e09b5dad2128d5fa6dbfa2b7e6ac60436e93e7ae72b5be7be4daec0c0eb2b7c4d0c0da8dd06def866e12a0c17da64c0a400499e1da8ba5d0d1169e94cf452ea4fbfee085ee1db805bc46b0921992111189857db0ebaeab20bc0724101b264896a1c617e89bdd785ae944f3ce03d240442e7a980b7cc2417daf4c8bc609bddfc1ec407bf4bf049452506b0ea2e1ab7f73bfd6f705771931e13e5a2a9d787507422093a4d099fdc98ef6b479fdf9ef1f765e8a0f3c0ceb5d9a200ac6edcadc9dc867e3222064ce58c05a9e47aff821daed1b0a1d318399ee253578e3acb226f0ef4042cfca671fd54831759eb001a378207941ca941e5f2c752038c21c17e6f1e64032fd7046fe992c1ba9f40882831e7ca08b95f9f9dd0c561ec4e4e4063f08314cd40981d87c22f0dd11db90bc19cc95e41dcb015fdf64980562958c24ba6efbadee0441912a861619e2fe4cc9537a176fc268b2a91fc4921cf99b03e6b392a1971bd41a92784b8fcdd57f0b22b7c84b37e16b81643fb71966ad15ac8f476c81845d0c3425969640b5493cc340e6e6b00dbb8a661e7f1228a6ce4f3b1351e1d04ae78d5bf5829ec11f98ec17319c27fe5d0ac76b8a3dccfd0af88ed71d8559a6c15ddc807e010175a7371cbe59ba41fde7102c7d618dea0939498ccecb1f335fc3d89cbcf5e38eda697f155a935adc680add77ba3f55707f57f840201512f38bde46cce97bdf9200d836b6f7b4fba9f234d8265985d0dd2500f61f25326a66a0b1e06bc3245deaf555fc6dc710b7b9dda550b7997bdd19aaa5b624826500c9320db2500142c0afa78f2162ed25fa2bc2c17246d9041e13f42e7064aab9fce3971d29a981c6b1d8876532372145cd88b4f547c9159174963da1ac4602ab6415374757b8d18f477837bc6b2742657fb91a67a61a6d173fa0c8ba6bafea2a1e5ac4a5d8d851cd26f6d8d2face8549ac3e87925a8478fb59b72879e7cb353dcc8fcd729ba03522cb49b0723a098efc1fe1b359914f3d154dbd9c9470b3e15c1b91407e6290298665d7d823ef7c92279509358078fe38c4c90cfc49454df6eb6145c6307b6ba627927ab33ee2171723fd9cc59b4c3a4a058329c9116cfcbd7d5a37474a33b36c9e3cb81dc117b5d5af9d8abb812438cf5bd10ff796ece9047606d2f49a33d7fc624a47e261dd65d2d4c2d11d411677ba9a9a4a3fe31c22d8a17d1ad52b8a10a9037811b49608d6aa4f384c732241f1715bd791d5b5676f8831902d876cb223e63dba427dc0124b5cca7b9710b31dbb60f74d4046f00c40cef4217bd6f2a6598e32b13331775b610bf5227695a6ce77359ba18aaad83a80ef537a6b1e41322e33ca815863b2a0cdca60329082abb65ce903e35758192d9a205f1d33d6c9bd23957a00bb7ba449542d96cac49a52e456afa015e94f699ce76429a0edc60d6ea3b0a4b4d4cf9e537375ccf01f1b2fa3ef8f100b1c455bc2d68974a70ca1dff8493fe54a632dd6110d04a0883785d0cd6ea1b76bd9868da4cb1a22e12e615a6948af3a5d32cb13b5f59e28af868389ea9bd23cf5437af6bc752134027658fec31b53099ee7ca35830cf5300dd2741dde949d2aaf3dd51ac0a1ce99de8e0821a3517709d4923e54046f69bdf7e122b79efb0baea2c8ad116bf59f3ddb1e65d9b004eeb87ca1d79e2cfa124019d36ffcc3f542ede5d11836a75df61ed4e5fa30bce8f68b63d58dec7ac12bc38e292b6e2eb1bc14cb12fd764bf29f3481d48bd4cf8c8a66a630d11b0720e15215e47f5b99a236732d63f7d8feff4cb72176b59409ea2153a97fed7aec2c3af23d31ad120eaebc33523d3b8f75c191dee0abb9ce41eb2938f949132760131158c1b554ee8499799d1af3ba9a6947e76497e8cc87c9d40c2a2bb6cdc6dffb24a857afb9150c7b8e1865851ec4ea8001ac71c253e21d81f016b95b2d0b21245b2ab86da48d89be4cb02e23f32c508aec3e21cf626329104e7385157e8e53d6c2e3fdc140d0b8cc9581c2ba16ceecce3598d88b8bedab029c68e59c316f7b8cf761f7e63bffb74078586df9796cfc09f27b5ef7dcc68812055cdca109bc7daaa7c141f9ba4a0e889c5a396c1c23c6327949522061957691f12471c0d019f9a490e3d4c6c5af1949193cd86f84bdddca9205166f16f7ba09d89959ed2b5e42b103338a2f8482f3af6d67a44f29b41d46d88fd0d5a954e514b315b9589c99828ad87b05e09affd585f8ff7c2029e69f260c16f342170b2f0295d74354e09ac0b4549aab3c3930c3b323a5be535727295bd2dc8f5c9b4c45852fc23bd80d407fc7f570b2f004a02e778a951f082b9d558116a6da8bbbdeda3f4f9dac1a9293eea5e642e0fb9b140e25c79e72bd9b18066e4d9c78890aacd31c6c1714471f7221d1c98edd3ead0dfdaaec3c1b565d819064a587d0fc239658fccc8b8037511dc081f7433d669d62b885be4b75eebd4cfa029b07cfb08df86b5b9e4965be7e6a43621300a00ec0296f2368c894f8e4a6ef78de314c1814024da1ba1fd045bcda982875629223a0fd1efe218d68d01f247df05ae19f78ca7405964bd35819811821e52c12904116c7f9a7acdf8909c0cadbc7af8fca248d946259d9099a2d8a686555dc0f115d2711c0a23cefe1f7c2561a2044f0c27449fd05b1c602c8e9a75d26d0bd3b4b1e80928a7e57a8e6cabf285028363a4cf49f5b51689ba8eb82db058de449ea7b2d8bfb78fee4e0005c6e328b68a10eb62763a70c7b4117254c63c327c4c80542f312b8b6c38d22d06e055a0c9da02044ff322bd1d1df30a9950607984a38fa02035cbb4950dea014076f066eb5e45a07b27973f600e408ffe698de6eaa8afa75af2601091807df4422b9f993ef06bc9c5bb0f7850e0823e82828d06986001e8c818a679b28d5f08bac3557043acbef041c775f821d6e88a9dd4a807ecca7d392d3db44a24cb6751b45d96aae2208344471a46bb6c5871e88dc76cbc5137d9b91c69252d1a830b05906eca8c59fc9e427611829e62fdcd29fbfd2ffad1ccf95a15c732f37183fdf1e9f6206d4a971cdca6915ab2a380d2570c7378c0f6f940a62d81443c7599d315eebcb322f5bd38dfc852fd74f8fba1545d34016d670b14f36fe6df2981485286e72f031991950e6d6e2d88093f1f473cf13e0051d4aa1ac7811588623d080a5ddf9f62e7cdb8910ff41ef86903cff8a67168c9a5a9d659e99c3a65d201daee09db255418b092291a4f4002690fe74909a2f14aeefe2dd33c3751c5901c1cf628940d6fc813ad49a937ae03422c3858e64580e43d6e679713e45c1cd824ed43f1453f92ed7499aa0d4d68ad69c118a6f935175afa4fba941e7c6fce42898d42000444a41a4f3c279c438de2e0e51296d2b2c7980c32656afafd6b85d2954098e35e4701e7f633b74dd87d7399a776626ede4bbb49042b6538ab095704c18b09cc9bca9099e0378bfbc305fc571c2aa50041ea95a443f2da8af47a7d93f95583a917b91c2a0063b62a161c6598a94fc12f4f01d555a5b2c9c1c83f0aeb2b9628779577830733a8e7fbbd1ae6e11d12333d7a42578becdc729a6d4d3f7780fd800591fc34fd299767c91c8edab9939a6d06b22b432b65dbaf0824cc37fe8e06773c938b64806cc2a2008bf6f4462fa705f980db4cf0a73ffd153b5c422d1a6d22bf6c877f51735139af0f0aee16f716d6149c8ca930224f59480855a955f92b3c1300287e34bd96d98ac7643aee28bc20c9b600da5d0206533873c8862013a53413c880305746cd47030d6e9a6f5cc946a38a9590fa8fb9ed833f3ffd7b6690ecb9fa73d3333768836eef6e128deeb81e6e1f3f1f6cf1c06bb9fcb0be4f1531488949e294b1ae41a62cb07c136f9d27c826138b0c402913a50b0337aef75774a52bdacbf62c376f60121cd2b69c4b4f72be2949ecd375a2084c8d1e1ec05760b8bedf6d502765519ebf4f2183cc614f531dc6d7a3b9eec3c6efd1aaf05678ec38a2c9a43dfebc95b85a9b088607128abda9ca50d8e07ce638f90f1c46bbb7f62ed27b233f60b8439dba7877a198c5aa13e4e2f5013c1feaa67c44848fec778a24f9f319aadc555dd978c0a487a611d4e02943b172e528c9ef0b4a940bd1b8dcd186ac337f4742cc406d3911fbbe4175c067598707715c1bf1b154e12124fb2dfbc4ba13625710777122a45e117bade829de2f65d3aeef153f4ef9e417d8160ae56974234edd91fdd958350fb5ec31deb78e9749e086cc81b36e32269a76af3a94533495ac5442061cd931c86495d8adea04c9cccbaf040123b52095b06cf3141b734a57c51f9a640b7d70d47ad2fae6bb02a1f037921e782ba932e1676da10b4f64740b0fca9e57a8dc6030f02ff6b0da546ed2152a5d50af5cfb50da3267a025e8454449c3703c3daf1dfb7b152631193cd36a8a4c28121d11386659c4800637f7eee1314c3f0e1fc9fea5c33ac066bac1e885270a537001780f05293d959104a3061ac911488508cec245013f9a0c5149239bd37d13b6907e090880e161567bccf4c6fbc1b7549c73ae518cc97b7778ab642375d02e74a19acd5254a47ceee8edb391eb2fab480e269f7be096db3d8b1f179c823c9715b50baaeaa7106b7f74248a02f94c3b2ce2062883f8b671a296c9072570837a2a5ed476fab68d3b973e59e70b15b5d488fa2d20b5aac07504ce87af6993683cd9f712b1f178c5bc65ac9a72a807c518ca6b05c77d6f5276daf59d09e065d105c5eafa6db414f02f5edae73e074602930a314946fb6f3ffd3a58453a60022ae774fb1ad79f6c54c095a35d8ebe686e04d05a9d170c9affef5a81b763ea2fbae8091d8ce474a0843a7d9703d351cb0df99b7a6f38b1b137d1615056e88b7f8e7ea8f5c2055477e036d3917b88f331c6f1aab8a44b2ba2830ef9ec0e759f9cfe41a742b3c66d68242a2648e47ec370ad563a1e563f6357c3ea91da10d9889e1a4c62d40b7788e17d9ccc9d74f9afd38c867896127566260a4ed5108b53f4beccae2dc154310e8ec1c4cdf9734f08f1183e0cdaf4c81e8eb7a61bae1711a30ef7cad4b95fbecad340bb7d8d5913ce2ed26e89b7a968af88e75433b61c32d7931dc5c0279e1e8664111660ae4f9814fa5833ff409f3ea3ceaeac8c8533edf409feee7a34ff4ca84c6b73a174d68885df81923e5b3e0ab2b090e7bdd869c832dbe9cefb85c72251446ea3bff597bf622d52b0eb1edb75427292cec4f1da8bcc7e8495f533680031a5c3f1442d42c2ae3d86baa2942d01fe86f185119193680d23019a022ad85499204208e6a875ede18ed3051a272de259b65880e13af4d935cff2e229b92bf56a9726f8fdb8bd596a461ab8a48ef4753f052b378e6c69fc8ee6ac439c6831d3861f0f61a111847317a75301e883eecb69f55ea4ba55b20782ddb549a233fe31b7ad71fab25e7bda39e10c961dfea57a82aae75604897fe0f74a0981073f0c1f9e1fe1aef94ec919d6d69a62494ca65ac3ac7c1b7354e8bbbe80c6b70c689eb6528dba5f981769a9f33d84673705eae32e106b728d9b5f6e8b0ea0e5f05fd70b1b2089baf136a1da85e95c492b60bfbe1fb65b6a814fda688cfcacc576b9332427dfa20b428e797f50c08e1b6aca271af59468970680c7b4fb924cd8c5f3ee6ca16f131b6a7c030516de40c093207e4d58476665aedf09b786c3210c82d35b3f26ceed91e3180fdf6525c59cd45a6048d2faf295da6e02c74227c70e848df3f94475cf3b167817783b72f2581262a5a1fbf7d52271cf1b3244a441583e7ddfd766e338b072329ea618a0535143a1de160591f1ce9cb4ac8529733fcb7daef609e73a79d83b2b7a7515e2e312b9cb314e63a9c1d836d5a613ae71bb9a5217011e0afe7646eb310a570b340d7bb5bac19b563ce3deca2b569e023830b5f220eb2f6ecbb71fd1d21f91158b9feba5ae095b91edafcdda6820ec3c751c2d9c478162d75a10092b1a319663f2f23a9a29947e254e051fa4532ebab10ffaa99ee42a25235aebacd1b1255f3d050a6f2527e193f29fd9ffee100b06e8f792bceb76d82467b176d78c2aeacb4a8f1ea09554b7788e4a7ddd2a2ab5c1d2b35dfbe722c3b528b0bfa095afb362cd8cca45608fbede8471afb37c63df2fcd792a7a5e18ff9634c412ed0dfc21548b67e7608ab5b0f5c2dea5c3244b437b4526d21bbae3e803cb5b003d62115abde437ef74b73ce7ecf3ace77dd7c6450e4cc9cc37d93dd75a0c452d6ea9a0fb002af568031616574f1d97df85f2d951e6fb947ea36a79e28568b464802f8c0f6272e3897197adeb34268d901af7dde6ebcd78783cb3fa83578c9d384769f79c8052627e6a89f8fb78eb1e031b52156970211ca2684d0bcca4f8ed1d414bde88326b550eec3b123ee8555e9a07d2b5a7c658465a7278aa08fc84685ce93fc06ac56972b6f169328a435904d2bd0249c9f58d432e6298a57c98e3f83af5ef02808c3a04e75861e601b15a5447fa3425f2234697c4cd523fea8ff54bb3dc1100fcef6a0b619c925906b20a20ffdab6ee6e11df33eaad612def923158770dc5a48a4f4f02a12ac1f50dc6cea37d27e1805a9c16723a158f7d60f8ca86e3ff240582e273922389e41fdc19645673801b5fcd88df3dcb39e2e95066629739d68fcf0ecbe944e39c70844a8df59722d748af8755881548a0707e5bd6de1a18309b3f5fd0d750a698b15ad482818b1205eb63af3a298f4d8445813bc9e0176f122343e7c6907a040ffa1ec4ba99a5b655a55f459aa75cc3aa8ab88b2ca6010be13bb67441b60f5d9de77520c93e7a89750f3c6466dc95249dd887c3d8ea9e128d9cf2d1881a65ae203d7173ce586477c697603cb6c9cbb01da8f885a4eee4173f37072f683ec894909278f9f3de894adaf8b94593d2c46b0b0caa8361c34f3f412f1bf3c3411f7e71a4e62581f5de0e090962d76975a9d7b2e38a12b2ee63c7e262e54317fa28fa2ac8a30d835b1f20e9097e57f781b460fe3fbb1182b0ea0ef9a2fafe86cafaf787f2754979e09ddc4784e27547d7fd8317e1daea4f619dad0895b44c853a6ec1ecbb8e55014024ccd03fd1287fb511dce36eea9bdb2f8a65733277ab0def60239875345abe24cec29184149d1d661042fbac960b1fa3a73bc6f5ea4d62652deee2bc054009a9cfb183143c9d45e9f734a92d64feff78000657823f31bfc2e2b416659c72a19b13a3520e73e2935936a3a67ee7c5181ca019ded783ca126cfd953f0f0040f0ae1dd8e78927f1d20c58e826a28cb8ea41e62946d46e41a6eed9a4169","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
