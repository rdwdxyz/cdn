<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"142eaa36762072199ece842bcaf79f089150de6f0de45015f17375c65497b6d756390b539acfc0166b3613805a1f6e15768a087fbe198ccd98781efcb27e977c40d7d7c38ab3776654f9903526d745c0aa8a528e80b8917d79dac22366f846d43894ee17f8a8dceeda690e307a3522dfa5ba6fef0e482c73e415d16c4b84190f284b31b19eeae97050a78dfc811bfca6a5c414365e435ed54c3f4c639c3a2fd60d9d6358c7d8b78ae3fb1c4b48aa21fd0cbf9320b77b88cbbea32b8c3e1dfb944ae8ff34402f25406b2870fef1140ad55b85a394778a7e236c21ca027c964341ab274756ac1f76587f805878e8bb11da890316dd652064fa82984cb29b3d542da28023ab9643b1e8814ec34404d6e69d5f4ea54ffbe52cf8986d991c3ffd52cdfbf4995e02c7ad9168b290d789237e1ef7f07d6ac097576c48ba56276e28572689c1833c6f0485281c47bfdf1f61f6475eb9bf82551c4bd6538f15b5c63bf820d0a3020dc7630bd8aaf1a866fc9a3d3d116974e887eb527f9a8eff9f1a0d233f8377af7256fab31b0e598e45d1257d94c1aeccf37515d8335440770319e9079fe27a8ffca23ad53e4496832363a14bd7e839b230c6d1cbeff066c918ceca0c1e1bc019cb354c746a0d0f7de90e219e802b35ee6fd96fba58f1c85151a69d2616594efef733e5160ebf19b2d8f371040b2b226982856cf869dec69db574e2b351c279cd407e3970003cf3195bd3657a1bd2e511316b2b1a77840df418ed3f8fcedbd486f5efe7538238cc59a46514ee049cb58b0b26d552fef0d441e85d865c581436d50f42a495ffccdbb1bae8a044717862a1a251d31375e4ebff94d7c4cc5948bb0e87a5352ca98cdac61b4f6066856cb63a2d24e5fc59ba0b112cd7ee2efc786e5b18b4ea3f01b01e70d105be6bf88b7a4f81404b0fddfa0d65059d1537922ffe6a1bdf9ec7d665894f8e18be99de851d7d75a6a99bdb9bff0d98a8b3ea9673ca1eaaa81aed2f1d1f13c5f9e255bb7bc0ab5c663a0481a7317b1a324a531ce2b39174924cea01cbba05279783d0b14d4818c029127d60a15e6f48fb1b7f2ba3775bb449960877435585f1f5b035bc7263b2ae4ccd2912ce48ebcb5c60d0b2647ce6b34d9f9295f700100a49aa10a3cf9d493a496584d050bca8b21c2a9558969c9c48cc4c79471fa33c50ffe7fba41427eca0728ef0f3ad1552a0b08174bd4e79670e0b7aef2cf218e904dab58414a2b070764859d498e9ee435ddca8841d41c304049db5af0e6623489652c127e9fdc61f3118aa5ae358493bfe5a9997c56a7a189afff488e10c7f4ff3469376d6346ce36ed894aa0bf069c36e0f6caaa0ecbedcab39516a5c8e2b41cdc74148aaef72708a33a6eddd1a1523679db56a2bbc4ad7606d0c97236d56abeb3462e8a6267962d858e56c70b46aae7c28daff99c1d9e83533130dbf3920b15b01b3685ce31696015ab9a93bcb4de95e4cc60c410a3f226cd60fd5c10a1ef5cd15532833fd0fe35e418d0d2b19636eb019013d775c2bf5d2af2a2581d77ebc53bee18ad05e36397573aebf378802e7a410b27f9ac11c41d578c6c20e683043a23e142073f68507e7cfa14ad5dc1a9496feefe6a4eb1e84ff96a15e4b2b4bd6aa87b90e98fde3eb84e271d84d21fa63916567996fea6eb218ab4d9ce82058a62e73435522874993cf68a716194ee6cec7e5d1ee1d757dacbbfccb35ddb2fb3a79f88951732372ef96b49333fd15a7d176df1bc69f00c5248b4a064ab5815cad7944f7117a54adfb89ccb77122458d5d5b62ecf8d46bc94b865b6c03d2e9fd085c43866d5423b448ae844b551f9212dcd0911c54ef8a7907ac47ad026b7c69c8d96c26dcdddd9e98e0dbf54f07be5d504d3872b19579721dbe9215522ccc606e5494cdd72abbf87af1fc6a67d50b5308c5e534ac8b97c4907b4dee1bf16492d843e7edc152c70e3ec483639de184be110e7e08799d540af81d2d73f7fb7733a4fb159321f4859762225aa873c6cbf469aa2b2ff68528a753dbb4771be7a3e8e3ce0ce1b8cccbe7e9ac9e068768e180b227b84cff1d177b0db46f7deec6e8417a1b0611179a695d538d30290498286006251ed98403681446c654947a0b37ddf12ae2d5aff794ab447b6ad9c7b504a52d5552e16041ee5dbe8d64483f9d668bd73b74c4aa2d48d3b70f9fb04a491fc543d7d9332ce395a30a1b0faeaeb0bf0505f90f148467dad720af9eb0aa6e209d864cf2fe5acc58657cded710136747ff97bb3b739ee23745e0db760b12572174cb20f2acedf0d50c221e9589019a30acf38f91509c70b7be6794e0a06e75f03949f213f758e96b02e8c5ffb510926cf4d959724d3ed134e21fb157aaf7634e00f53ea9d62e6610aea1933bab5f2dd8f9820baad62dc9cf6ef27ffc0c0653a21c064ceb3c4ab1a230aebaf29449efd3ee35048a8077d70d4ac0fb8d0e020a07a2e9217fe621bfb8ce3e17bec15c8b436a1c2e8e06e225f6d9b7180f9b202316a5fca7c6e16013e487cd0777a1644c9ac288031aeb1cdbc617e4ce725515a8cea8e3b8ef31f4449f3f5c8bdf76adf19246b3a54c4101f8869a04530e2e691abb754413a1f8531efbe21ebfc7aa782f628e594e8c2f71933587d84cec50a6b8f5b7d47be75a231a05a1af3a8cdfafc0cb1bf770e96c167c6418a5ee71f0bb2e12ce3563069b990f82e1664314b2f01b2d5a18427a618ae4fb60f113daf1d14f064d73b0873e76b13a0155945e7df637f7bead4bc4b0c26e2d149ff40f5c23bdbe02d44ff901d3fb51181ae01dc9db8617ca1404384c0732ba6b3d7d30833e36d89dc1c0f71c1fc7eda005e90aac95983d8ed656f52879a4a1d39bbc8c82ff580173f8d8c17da9ec147bab99d5a5bfb25b6cbe8bb7a903e91dfa3805d701611024acc4c2ad0661e707db4be9a1d8e43ce6bb044e407914c02734c63320981b2193ac49b4e91a4f8387ef22204c68e3d091b50d68ecb4533ab784b450b32a572044593599ae71948daf8d43878319be50be531a432c7aa89e1074c9a30fc80b46cb0226529de39f5d72852a659d98562dfbca91569bcb1114ff89679b9bcae65edc6bc09d71e09b865bbdd566697333946fa030592513f83bcc4d0e080fc87ddb96d5c478ee9d19126de6758069419e21e9a904a796edcb7b4bcae9f3b90e55d901df89aba88762147fbea93e9031b9b4b52b92d652a9f8d90e90bfef4358841b0f72e2fd10a59290ef5d6241bad46439c83015577a1d07af8081e620a949fcc5bdb86a3f8245dda65bfee0fedc4234bb82bbaed16eb813aed62369dbb1dda229387f64a917a421e5cf3ab9afa0db35b4010758294b37b70ff423100baacbdd8f2ea518028bc421278327c0da7b58524826b4c92612403a6a43d1a4520c39176d6d0fd648147177477612f87c697d95bbd67b34d2dd7c76b2dc8b96fec01b4cc5b633eaf5e88dbc63755b423d1a0f89926c92c9d760a4b98ebf21dd9032b64a60ab308fb663a7a6b75dc25b6032d27282798fd14e4e86cb040196abd6c6ff3784f3e3626d14cd4b57ff929aeeb7192d07c36b0b7ddc81d260f1b025ce662ec0f68db504c854038a4f8f7039cb8669d8a534c9bc48cf77b909b9f0c6dd4a057a8576952cb08acf2cb56be64648feba1fde8b460400ed4588e19a62d549a8d5f4d733639b61acf49b4c29c8bc8489785cbe9b031846bd1508b85d89e49dd8dfb00e325d308a08fe063ee98830dce8326b70a6fce27559483e8a749a5a31b49705404c6653741bc7e917bec91b6afa6ee0ab95a5b356a9ed80d562225a98013534746bfa425ea2a10914d636c1c0011761af7ce1b9b05f54a448126000c89cf906a5e95e204c700164d8097d6d2fd03ca48bc3e0362acfa701b67f116731eae7e6569c0c387db23365795004f043eba86577b6c5c9f75973c910a031f9d48d6cfb8be67d5025640e05ab1a19954fc1e9c4e224946ab97cae32b96c88d321f3c71168aa39cb2cdbc19239fc69da95daaba8cda226421609ec12f88ed60f1667a1575123a240304f3565c1b7a7a95e49bfb49b096352b58fcc2dd0c2a56fe9437c604cb686864ff3661f3041754c29f40333675622feb4ebfab18901adcf37259b3016d7a1c4259cd2599f52e17468e9e1a8ab2a1970ee9f8a246d0b5c1baece84d9fd52b5f1000f193197d36d9a0037e89ec8e870b5a24ce2a87761d7a00d6f35d330f10f0da72bbbf5746a53e9000d92990c33340e2e4834253628b76001cacc3e68798b9fe5fbd9efce3041dc1dee23749a192cd55efb70159820f1929367c1de67c2bfb47c00abb12297ca47f3a05872fc64136222ea0d81e5027d88e81f3d4756621a8758b236676321c7276f4543d9a4bf4c5b33fa796da0b3c0a673affec0092c00249aef9264c6d0b202d8fcd5cf15b9f974f5e3a7f2b6ecc3b1f806fc7abedd949c22e7a86b455455ba0ea3cda5b0a81d6dc773c61306bd77ea5b2b9d75ae4368c209ab20731d4abb0c566e21b3aad34fb0bbd8b3cbcfd5b7fa03032ca7c6d2a352be7356652583ca89da82c9683de48296641f2fc3676ed6f07335784dc588937485650feb007700a60f56ce35abc6ffebf9710a2f3074030901d8c7a6da666f536f895e89dbdb7f9de9124f0fc6b798620123da1c3da401290858a4c10dd2b9d2de121503be9dcdfda6df29d3ea38eb2d0c950633dce0c99dd0f7e4845909cb24993f548050ce88c18fb92bbdb012bb0335d298b096123ec5e1e0c0ffaf54530f314eeb3340f27ad1dc318b7e0e6dd8be97a922777410132b2db0462d575d81de9704f16f06d21844e65cc1486b46dd4df6b70ce3f9751b35f97db1d80de24936518fc12a68fb2d6b7ae4f67cd02ba7287dbcd2fe485ca219f1de05156b7e9eeb6af9ec9b1e2cf902d75103877ce75bd8e799d18ca8fe6efc26e1137824610ef84552551f51818472ebe272b5efa2702e4f810d3173645ecd1de6af15d10a8f024dee0ef8de7f38f5f1a83b60471dfd90c1a5ef69df4188b12306c03513445a05fda1a483feae50cfdbfb38a5a1eab6c10b125e0e2a639c723828d0fd3b60b19d40eb7ddef91ac653ae4913021698be55fd9d0e85d25fa2a37d8c14707f05e8a7296f135d75e325c63c4bfbe42bd117ecb6bec6cac2bd2ce306bae20ae3e3224601850915e2d8098d03dfdf685584d63315286e85c84e7288a893c24e73de34de7e350c1b68eed99c3bce59a18883a14d4981be0e9c296745754a44182222f584594bb2479dfb3b16903feed77881634778b8d19f2d50cf7be06162c026b62df92867ba322f86432a36e10a14d6ddba4989154100fee31f7e2dc51053975ed812ada3ea7cc056292c99560d818bab08f1cb2543e03621d916ac9bc4c4e1fd14dd55a622cb222991c3a59a6a3b9bdd02df7c2d4f1285eeb0bfe1a1c5db4603cef2768dd363100835b53aa6351cc24ab13b436414d0ac5d3d707e77a27544ef68175bcad174b95ba91e83eb5d3c29a3caf58a8afd5815ee0a3af8392c0d3f696a92bbf0d18e4b2a25bf1c3802b3d7fcdabdfa8e276c80e66e2a26b01d768745bc7e30dd797f37723831fa6518531ebf14f60b08a98362f6ce32e09df6f0f1f9ae3246f6ba56e5aa7be5046903e8e6c977d0407e6c1725d51d41ad014e9423602721775fb2d7b14de2c8d8ec1560f649ed17818a0080e0902d3125095a7fba47c1e7ee91ff4e815a08b9bb2044164a4192d88f6cdb07a52bd9ed5e14145c9c205d3317ead41ff94274cfe29723d020acc792b780bce1055ad54da956aa386e96794ac737290c22124bf0dd552dada52750b7f80d529408ce6810ddec4c49e944791a89b04c533f31ee8e481e82f811d2ec8c2a06ce6bd6be13e26a052dd9abdfb6637d36ad07bc97542058b02068df83eb9070da77e9610895720c66fc752861262084ab10003c090ee45ad9390528fde798adf3def0757e25bdd56c49e48a479059f76d2ab1b3a1d7eb4c647b1765c19557d670d04184108a615d015fea16e434bff55ed89dcbe3de73d2a46a439c9120d0389550f9b99d8d0992d31aa7fbf3a566401e755227e4ff5032d29de3f9f3cee35fe8b6eb414cd2cadbc29b6c548bc8745da53ed4d84d8df70f7ff3058d9d60eed8d60fbb7206ae4430fa42182572ac86f3f889d051c4063fc390d62507ce25fb175e0aabaef8e442135eb0e587eb7526887a25d72d2ce824c49b034f064b7c07db4469c3c5ef79183a5c3ca333b298f22d04d3999b829dbeec56021d8251363d5ad342df7a566ee03759c314381d17992ec2f971f7c408fc22a7a84e1e5f6189e251cb12e66ccb666b337888faeb468e4ac760c578e889f1503a4998aac45386e66537d93e7ed287cdf69fb8a0d779fbf2db6d9e45d6d213329e46bf60c86b9019de03dea15180e7fb124ac212fbf2e8b1678255513eaa2932fa4de1c31c5041a16a7d2649b511d002a80f83f95a9f5e31edc478422d9df1faf8d9ce969f161158658de9a29017fdfab0318b06d7d27ecb6bde850e3751de7a5abe77460ed009ca4016de244da0db1628313748c0058b9ecb01b4335a74226a52e6029003af2c547b88bbfd609b1af4085dad6345516fb001004b6ba8ca31548263db884d533c5a15d90bb45f9493d15c3e5661e4cf11a93e690be17367145ed8a7d97b7bda96001e682c3516c760c4b7f40279e4a7661949d2b6123e17775712cac0dbb5b55b469cbb069ad8813fde1130874e1958c82516fe1ffb969ecdbfa6caaa226de76d021fbd48b7038a7bc14633898c847d7293dba58f7bca5fa3fbee7b6ee8ea961db21b76f2e41f603ea5bc03bf9f80862ee3c2552fba5621906cac09c007c22a1cf5fd66cf76c0d496423cd63233d863aa936708179e289c8c855a4dd4e899b0298b96d013fefa014266564a14a485db302ff5d9367250fdbdc912f32bfd1f6f2fb4c7002553fa775c875fa3f116bf805d3f1d0d982a99bf442b1078e75a899e7582615f83186ce5379bc71da4ec9db08bd6566d3142200448d79453ba8c6b4f2eccd3aa8ad64237301f15594c1655632be22ec25de628855882bdf683a51b2d6a37c009d72ac11d1cd41b25d517eb11d6ae1571c5f70f7e54b592190545cf0ab41bccbba5e1ab273021c3483a0fd40d388664d00725400e3505c86f292703a89a27ab02124e94faaba6199da378322177256cfaed02cc55e02e843d19d911fb906bae6646a0db077a2f1193920d92564cedec0916b4856c5dd096acb6b04545078927729c266d4ed9cc3b90b07e3d39188b53460281fd3c4a7e1887252ce076c3599aa11a28e7f987673eb8e5559ae9b393f802a2bd0b424e9eea9cb98a780345e503062de216c2de9d868254a69cbcc2226a7152eb8747fac9f859d3cf12257f6089a24805732f7dacaf211661fa662ccbdd343a12981d2f60bd3fb3df6a584efbfa117bde8b77343b1e227c072cf3c6856fd4ba0c23c3828bcd6aab507dd6c38d70cc770c9f6b2a58663f0dadab96a744cbe6681a51366cfa2d19711bc0da830d4689e6fb454c15da5d820241953281a5e18d60923cbcc3ab12f8140033b53ac2ea658dbbced26ec4923b6225f412b132d4494dc84c7796fec5058867228006ba7df8d1279d1ac09fbb612deb9accd59a3387ea1d64edec6fe1e3d292dd9e6f8bcd7e6513ae92c6f737ac3db795edacc258abeca3b60e41673b502c97d18db7d2f9714ca204676b6442dfedb4e53398a1feef69e9c508389de1889bc02ab09a633609feb929eecd88f9b32d3cc9e55677267b5099d2a6a5b9619e8bf4981462be555415cd599cd6a6773f3846f310744216030144a8a3a8f999dc9f305d61938ce9a72e1f908c621ebe19e939b8b8914405adbb48d9477ae3a810bb8440e87a431d3db05f9f44b6b98c2f4d5593c067cde43d5e2dc459fed255c0fa3f0787c40c4dad87875860f23247bca62ff80ee7e0acc5ff902ba201d48e69643cc5d9f3f4517a294fbe44c4a6dc72bf7272540bd039fca3dfee3120da70174cadd0354347f5768ff679ffed778f170847a9b7049c503186231bacd85a598ce3abc8c6875abbc77337599a8f2aa8fb738f3860349f2d84c8640a2e3307407b8525120a8187d235b11026e0a9ed2a72a12289d6f5e1661b21c453ffe76e0797dbf7fa1500e98c274e63bf2ece0406fa782cda4138baf7ad938c239feaa005f15a8e2b46a731af2659c9271af48146c33237153a21aa895fd5d2ff3267e64937f24094349931d8190b5a24b71c003dd522f84d0d72d1b2f5614c4abd9e2369422cfcb8813690ac6a8bc02891e91c99208c426bc25769d878743b97259c6f4866ba968f8ba875d96b2f2944ce4065138f2711556b34ebb384a689796e4703025a62eb111d4b6b47f10ea9da84e3ae462d043f5861cd4d35ae08cd796467bf1f01c9bfce8356bead800935ae9ad1a3827b719316370a828587bba95008d2a28441cbfcbf469a6d93650174ab129175a15483151c7567f934e15c97754881223e579b7b457e4358fdc3205b8d3fbb19942805911f2085829a26240fb64a7c89a64860815fd2ac2cad841648db19dbbd09857c021e6ccca9dd81f8fbd37137dac2bc1a07bcb695983f3fd3540c2e5edbfecf8f3ea1e49136badfa33cca71db15949560f6641fa090b89f01579f5b56b0741ea0652304c8ac6fd424d601733197dc25d14d3b54cd2a7287b1f5eb22864c08afa9a4ffbb9055272aa34a5f31cbbb23d34d734e0f63d0ef7fb037bd464ec51ffa3153cb1cfbaa69b76bb74518ecdf9922f8aaa0feeb2a51e66af4ef2914ff817e8ae3ce03113bb0354072c2d700761a4b653e6027b1cf600c78550ac25d91dd8cf0d8c9e346fb8901be8cd6ec093c7c76467ddf305a0f3f869c57928c10bbc7ceeea94995593bfecc9b09d6afe698169b3b6b261e947f3907b820eb63b396c93a09d5339c50df8539c1b3b21cfdd0c2441f4f9fc927d5b5b62cbd912295597d43f59c169627acbbf757e321afc9b314338c1f7e0d1ac2a1e819a62c4231c2909f5836829e793d6e0c8c562a3d63fddb025691c01a0046aeb3d7e08993c2fc1faa9dc4bde876c5ff5bea78acdcc2c911a335d1b2ddfc7cf2345b14765e33acb720bb6ac3416afa2da52e2130e42703bd03825f3aa146cef815b2c7fce25c83952b17a98991508408223b32c115fba0d7edda7a717262d1eba7d7d6f2b68a0af5b311f7c34bdb4ed47ce343cff318a9b9379915a978b9fd7dde02a9cee65dcd3cc676f7ceec949e7448afd8e0463c5f0404982388147304408e0bd871427ca8dded43f28e8dbdaba6413a5a917c87846e4e7505b33c8483111b47fd01f92caf9defe85241d6b39a907771ca92ef7a536a4a904662dc9f49b2efe17257333b5451ae53bcee5d53bddbef4b628014ea8059fa0dd9d8ac4d1761002385cf71cae78b3a79ef8efb1cfc876ba553d0bccde3091afece51b230222201dbab19098e164b401cd7d3a398d30ba5abeefc0c9ec1e1c3d659e2670ab51cbdf2a21906ccd9a41bc7595943158c837ebac8f419d67b77935262d5e88a30eeee068874024e19698d1abda77248ef5ccbec5a23b3781959b4512343d4f4baed558d525af0c520a12c14d1facb97be60dd3d47e1e4f3cd3853291f7fa9da7b949a3f9a784075c673ab08bab954f7c5a2b1c91b26c6fd23d2b21f81c22c41fbd6942fc7239592390dec1253cc4030c8399aadefed3b6ce51f86dfda0c441413ee2f8d09942c6cb4733fae8a86b218bf66d42c66cee8097058453012ba69667eb4059854efaab53f583cca697522315be89e06cb7dc4fe0779d020de7443ddeec28b74763bdaf6f2106d716ad492cd7aaa08b2cabd27aad612f9a0b44aead0aa010707e0f6bb71f37ec451dd5f263f6b0c36227528913e169a0389068d54e6b4e2001a0f321ef29b8d48d9e7023f08bb26b6e602d257a80c52fbc4d46c87107965b6ff87739096a13d3b21ff30403a31bdc2cc285a4a2e4cafafc363054986ffc730d8f5494c71a77474baa736cdb85cd03536dfa8e91338c4d469312d4abf454317b88d2e0ba68ab0aba4c115d8f737a7df35dfb525fe8952efa3744e1518084c6d8f81ef4d3256d5122a12fdf59868e8ef05156fe6c392ab299fe8fb63ad6b05da36c4b206c3fe69c9d005a1c760ac47ea3564a5382814e3e3296196667403d4ac55d2c3d7f47d7b82641e64d086ff962696e32325fb5617a3123d5bebef416627b01d56c75ac748abd311c44e3657a242a341ce01b67c521ccbfc07880622078bffa4733f818c78131792d65344bd4b12b381330cd05fc92045bd20f65b26200364f6079b4ec8f3aae2bdd149b72ddf8d80e62ef6d4ec0242c60f200720d59f5a659335cb2c12410e6322dd29933d31d4ce93a9ca11d0289a772ce32d132ab5de868a35ab6ed775b0250e40385c946745a01e2ca7a861b331ce82331a4bec6d3490d6e6526c0165f7d98a9ee0b10cfbbc4a862ef22b50e114895223888f146866bbcf1dc2482bf3049ce7b80ad4891040ab305d73956788c49d71a38df357841b939d3226f591593fd1154016eaf7bbef7e03e5ff6547e4ce5ebdebad9eb95842acce45214d66a1ca9c5b5e415fbfed9e025183a1ea500f4d8871ca3547f6cd2060fa88542b48b93956440fecac50919dc6d443a4922a360c63b35945681b89ad04f1e1fcec4d3e470fb54fe2d0f932f14f0be133db46bf1883740ff96a845dfa937e028d4eff40dab39a8340734559214588a220828e9714d19721fe264fc667dd1921970e80abc2606d5e10b4b375b0480d89a641c8e2a4fdf670724fc612dff0755aaa63e265cd574e3445dae5a2e978e158c6335f4b2948100b907257c07e2603e33c088f64d0b1d8d097f17c3438b752b6634e160d69b91e5ac8cd4cd78414c366c7ca2e08c1ef797af1b331066ba09a15238845566eaa9e3ce806fc89e16d2862a8b53833972efa0d70d2f32ab94d51bfd24832aac67b98780f804bb62c0c41d9e595032d36288bdaa913de86aab6f8361db4b1a217c8ed06a08af6a72e858f72fe9c640e584abce4d84902ea8ae8ff70c9ef275c9adc6ee3fa90e4506dd1321605b3df98da05371fa53f7bd1dbca25ca35b96f0832040e07fd607b2ba26246101a3a15f6c813f682eeeb302348c0378224ec15ee41c97d629a842850913121a75cfb30a9570e12f6fd956ff0287f85721f13b245a46c8b6ed051a2eb0b52d9dac91363b3e12af0c2a98e5f4f2f49692d16a68c75cec071d13bd84f51eb03c740ff991246b41e0c2b67955da0a25f95c25c1ddfd24520800849d710fd78703a5789b29a22108dee082330518dc6f4ea659a92f9914fd1d8d7a3cdeddeb8c7df208482250e9ebe31edbf1bd6eb4e1c16ce1d89e71fd33e62795dd529bbcde5adba3081f445cb443e20df6d8b41f15b6f149d782f12d0fce972909074f3e833ee062711ac6ff77e6ef97d86ca66bd71ae7596898a26edef354cdc0f2a5ee6fc16a1c690a0e4f17d06c85ff621b71f2e175617e0292a517f1aed200297615f1e0a90d781c0bda8877f7e585a5d21c4000b27fe1147775ccd5fcbe46b5460173399ddfcd2e1549a5655cf621955d3d4635f2f182c09731eab7e96ed303d19c894c89906e0cfdd97d04944f6c723b97940b3ece37b7deb789ee0122564fb00afb273da354ef2e00b630de735a85aa48ef13d3f0acb944cd39a1b26c0e2ccd420f30612a41f7b7a8b46e956229c917ceee8f5c21a80a2582991984daa09c320bd99dc56557df80bfe7823cf34903176a5278bbff4d9f654b53525bd1628ee4fa4dd2b830f72cc7ff2eecf73535f3e755a1581e12ec1b931cb217d0bf176b1a577993d1582e3c7a245306f6e6b704a09a0d53336e2dc09db2dadbfe66ae968eb7759e940be45a714475a2c4316d41bf9d7936b977731de882355e62fbeedcb5d5ba7e590aef0004c205576b71e1f6f5418cba886e769e933e8dcf4b1221cf49cb6fc439a6b5a013965b0463a1333a420a6a38e12dd7a234abdaf2264f90cc4b67d75c88a473f892201530ceea3004004de82d10145c494e169d7ed3be7f60422c359d4bbcae57475d68b7f9578214ae1c399390be884f71a329c1373d0ff8b9ff7b07aa18fd4d79997e0619ea13b30f3709e14d11062a1542c8898fc169672ddb4f950c8a12958dc24d3e97b8280ad97b874552fa772fca4d6b96fcff6cbe32a6a7b0025421d42c80160e119bbd0a36ed96852f3e44539a92617f15469834e7f0aaf7b5ac7012dd6906a2c1242569dae335c6ffc9a7ee56b81ebf509482995d9c62fe0d0979bb5a99323bac094bf84e2dccfe36ca4b47b231ca0577681faa4dd47f763f0e2f3965de9a6e20daa1c17911bbb046c2647915ad36c2018a2cc7158754a01e43a1d245e8b77aa70c64e03d9622b0d1ba6e8cc5ecd81dbd8211c27d2bbc5195c4cd7b9b3dbe7d3165d279ba594b78e4dcaac2060ac2f2b85e81d24143d215caf3468a40df775166d077644e924a11e63dabeb89db5eff360dc70b18399ae9732894e451c2d60579612951d5589810ff4ad65f04350555e2e0289165a834717fd708b9f85eaac2a8511ef5a5287a70b3ab5a934dc6291f6765b0c82b627316a1ca5bb54d6bf5a4601be246cc70e8f34bf4ae0d4e5890ee6e0b4ee2671c0b8ff0e587c969c4461fa8d7b5231268570d8fb88ad21f5da757b77384d29498a4606d5cc792bedab50b5ed57959df28cf4aa799e27961b5fbbfe505c0c588d5f3e05ee1e6601be960676c08f715a75aacec375b2aa5d0bc2b3e88dbd4835a5dad5ec167c5f191ed07101727a71df35c98fecd73c419ca1e083b01be69a9904176db5ac70d3e2ff468b4fab52fd643f7b1fefdce51015df8723a8a322cc506bb0a12a2d5fb6945d7f5f280e8503d3dc9c3146e6f1228cf86191c544870d14883a124f5d8085197305d910519ea33a829341ae92ddd617e97b31881b6d61accbcc0d1793b5cefe4fe3ca91c007d9052f5d8f3a1ac8211e798b0488718d44e0b9c248efca44c41dc3f269cdf17efbc41c9a4176263d0cf546d7d489bd8141554a7cb76bc52f5990cac7c979d41a21c9cf044340868de1509a66918bca501b92ea33a7f9ac7db23a9ee927d8775139897b3502daad4efa992ce92bb56f66a70abb52fe2526e3550fed25000dec9e9ad050748d993049a253355b7be2a875a9f1418b9425c2b30adade0e9ad44a9d02af6c40db85ec8e8a546a9d3c47a2f01a5044e6097d204c0f76f1e4c73796290aca1b413fc4040f2456cd347557dbdc0fc942e9d0494d467fffda9c3b7c9e61d84c111a492131efeb7ee03ade388bcd28809f314c08eaa90881cd6065bb997642cb00c41d56f80cb33a3febe8904f2688a518c7c873d9804b8991dc85fcabd432e525768f08cd8a87014458a346397a67a760afb073685abc04e686d234380c86f468a4f94455eab6415026c09930e38d8ae5e991635a693356d15e353a1906eca3c1ebe4660b3d6433765d7076f1e467a14140786a92f173ee83511deec39a1c28c835f1bb4db99077efe060b6e31332d9718095a66fcb86b04e51f9cc8e305dcce090ccd901c9bd812830395e87ae3eb6d43e05a2ec88374981dd1619bab7b9ae74f5d4830282df09c44124929d74a76f49951ba3c48a511f08448789bef30b6658f9760865422bd8fc8d43f5f2fbf89c7484148376e0eceef07746e4c44d47ec6c45c2d728358f4ae95a0d3d9d6c6b4106ed4f226bdfc1b964d22537d188942da0dcab9d8563705ea4bb0ed3b77c9dd9cbc44be07fb71adceaef5188024a806d6323099b40aff8f54ef84be0f8dc7d41909ff480a93b294db29b25de304032b19ef806bfff571511440c49cf5d03aed7ccff722ac346c0779d6c51454a0cf96041e25cca2d4fe5285d082c37a485b3cbaf69e869d571d582721b770791a12a87f85c022266f18b9458523bcf7684a4676315a00026f52c1e5e929ddee8627fdae53543b29135f54e443b5ddbb7c71cd193d02619c83b1202fe63415107b8d855b0bf1a3b280a71009c9f9535013c2f350e5fed382a3e027e31885b81bbbcd37facab61804f8bf79d8305eefce3ff8ed3ecb131a18d58928c13dca0acde99da3aeecc9423d28718e8c7c3ac9c8c3e4e0d5a0c6644b3306b8ef39e50edb2b704f7d7aa8ca78848270bd37dbe07ec9853ac8514aff7a97b3696d928a87da0809ef3802934c7ddcbf0a1d8acd249a7a780f2172c27e573f174b48d9345bdfe7d7f47862df6c31c21ea8aa7e521e7f344179c5aed86e87aa2feb97bd1be31decb6f05e074fb9c95461eb6688f688e1a4f53f390756e7bf2012203efbcaa32902cc11c8bb292110814aca864f912aec4ca058bb225eb5f71d691bc3099afb8a9b93047b731be6794418beec90f820d460bb4abf2a2cae6b18c22beb70ee23c97e24b7072c2c791d8d7f3b43d78035f78d3b9abfa49563e9c92cfb1b1e45c66f944634001d2529a8db682e7100d25783d78b8c5fbfd37cba036f8fc5ba0f14976355f1e028b3c403fc24a0d087487e53825fcaf53a1be0f7c1e6084fd619894aa65634e7bc6b62d32f3e9edfa4b9c227b7c433739659993ea55386f7555327ba07b37621d7b0adec5a99581e0dcbb32f5293871a28f0fbd8f773938d0a4f21a148830d11c9642292d29ca41e9849775087e66d90442cb364b4d04a2d945e0b4c66329c5267af38d8845d92c98baf488c224722cc1eaa2e0248a6fb0b45ac4bd5b3a976d97992eaeeed59d8743ab636df526b1e38c6496800d3a90f6f20c997375f7c714a0e89d9885ed6582a163c2e8610e108f8cff1eccb1bb92f51240b76f9136eab139a6ca9e5e63f697a9da23cca30644851d16f5c18cb22ab4a7c76b48df92560f598f6ec407b8a7445c217de6623fa6d7274580454c42f11eddf4bca9908c70aed63252428203df635692752417eb714914902b9dc7bbce0bceba96b6721147af954176651cd95e0454d4c23d22dd036d84dad1e64c1a28829c6703fa94ef6af046dc7e2ed6b482998c8b4a45e60e56fd5bb3916895e8be81f63c81685712757e6010c2ca84f50b09175f9ca26f8eb2af6f3e901115a8bd0701babdbdc0521f28a2ee104282692cb9064fea7fbf1f44f3bfb9a439805a505f6444e5b2417c7b0f21153de9edc1fc15e81ff2ad7b3d625437a28b55ae56c013e988e7738a7c35f37d07ffc7ba29566ce4e60e263cd66ed711e21e7e309e97a39fe00448a499e27629fab1c60c79bf211d24232800e3c450019f486981f2ea16dcb9e6fbc88babf8313df91d757f25cb5758d889ec1450a932275c13e017d34aa343094458fb5c3b6d94170cdc8d0f909dfca9dde5dcd53e75d14d43243573c126df73468587b3f04b0a554131ff9996e7c94ec9767f0c35b74e91a63472dfcf4065e41508d8a8213852496bdacf4c82b5a3609e538f699b59d590ace74f7c5235e6d20ef3f0f9a36d2dd91f607bafdf6815ed41d01219ce7bd28ed45ee4a6af76ce8a6786aa2f4681b61094637a7d0cc869a350651e8aa3d785ec06b9e1729b29d57adb2b1b38d33c6e226a011615b514abc9062d43acb9889ca8e2a5f183a7f3f6b88abe75d293750b13e25801a1e06a5dbf6ac16c5bcc78be1d0fc1570b8e9bb1a97e1652eb86f4816e2a0da36647a30307bd43fc411cc8817c462261ddddf24fc0b6462ea933d168c16b9199d1d919f0b54bbdd577740b4d56eed67f1c787e64c1e3ed2e909c1f1af646630e127e6c019eb1677bf86a2cedb2541e46f1ab93ff4247a81c9aa1173189b9a881d7140ccad3cf3fbe8f6a4f802afe1f929bbddab1311fc6560778fc6badc7859f81978466b667440adca749ae9f1bea48c565088032fb18fe067d6aa3869529a747773ac92935f9ad0828870a6244a052eafdc33c0eb38af1c6abf998133a35db0a36eafd8985b50d4790a946e53a9b5c23f6f863c972c1a8bfde52af6b6251f158d8f28bc7e0988527800fba49556a18a2e9fbb6813abb89dd0af79593451dd94cdf2c22912b7c5a13d4f049385c5fd9f5f6baff4d099334bd84974607ecf1b8c49de4eafae0c8475c08a7e8e7f6478d48010c4fc5c6765eed9d085806b461af81d16a876129392ae03de36bc567c34ab050df54d78c54cda4694683f87722acc6e17686d9b2ed206b1acedb941528ee01a3e6dfa58620e22e91778b554c924effec36a1a3546ac69cf588351580d5a976b61f8c7a7c20108bd09daebce6fce2d862964382aca733b2c24b2855fafd54afe7292f332babf5305f97d966621d99afee46bfc5e93affd3dd709bb960b532a139e53d3b26ac047ba9aad17652666366d8b1c9000d08e18395e626313ab6774dc00bfa4d1d175498d88412ac60e90649919f3ec159492ccb1d742b536045235f5b278c9b32d36b2d7e4898f61cbeafc78d133e53d6d118b34e5d31d37e8f3a0411a5859d145b328460a694fcc34ff7dd3d1215fee82b82bb14c5ff3b2f2b8961c3ca2a469d2f9a477336571c52f43931462d69f235e0bd3c3eb20c963103689cc44b1f5fef1e2784635566d09566c27f203877d2a474bd83c64187e373ae8a98eb591bbb4c6ac8443c042c603f7b55a864224619b643b3b11d31e844e9b68364c8b1e3b54b86a1e5a957d0463d561b5c2a59d0e31bc3d248768d113f4b617c90a0df916813201196b21af36fe980de6015a83481cee538cb7f358f04e38824994d00824d470d61b3bed34218592fca8cc1cee8b38872f9f4c0182ef4049ecebf82f4862b365993cec01524570f29edcf74a5a0485877faed4d4d48323c27ee20e3551de17c565da3e9b8499847846b6eb2eec2c12662baafc4d2712d5e69369f836461bfcad18c04abb1cde690b2f6239e94e29d7bc9d5461e1f2c6ffa8f2738dea1258aedc85a16aeddbbe4d1e4f4df087145ec535bcaa8c4388551bbc00822628e1012b8bb92c41f7fe8ac539e41d75f02b331c728ca370016a3426a7a540314f97a79e07c5f9e942eecda45a3331524da66c5c3e72c7afa570c23b1c834dd3d793e4d5b47fb7dc1283ffab9879652391029e4bc642e4d22a50566a70ef75246e4b64d102f5774ea73d7031d061f78cc3780c5e8f7a68f929f97f53d28ef8ce7f2ff805895104d60b573543d8cc2ebfc03a54be10c51cf24153692e78ff171452a0ef40959d91671737917a55bb645d70c2a4febe1b25aeba0d399d998ed81e7179c077503d8193e36282ecc16c98185953e712c44ccd2cce10bbba732b4245e5f65e53ca3b68f4bef35db2bdaf8f87fe5ec66d77d84329e8c9ef7d1247ef5e9ce536acb90e53c20f3ae2a592c53cca155202d2cbfe03d699983663e4618ce39c4b5e9fa94cc65c272ccbe2835f47aca8ae4be77d7985753edc9f5782793c00ed8c45ee14f3411db279add23d4c6e623f47c7ee7afb5a774beeb9adc82a9d1dbd356e3164f40b2ed01b6411abdb85efd1852ea6f149e3759d9f23513bfedcdd92a6286c138f846933e87c18065894dc03e91c440cd03bb332101adb952725d400a391c3e6ccbe36ad23065b1561dfa9295a9d9b10e67751a6fec6e1e174a8944eeb9bff681cc302607610721478aadc76b312f5bf58b2d496a96bdd1473e0989e1c9870a41ab40a6f0a5064e65dec0522ffe62c8c94d06166dbe1e7a55e5ba4f196f20742d86e8c9889327ccd5cc1043d064321e7e42292b4c602a45a36940b54e92933049864605c54f900ae1ffe2ca36d56ae0c5c46bf60814e5b4aeb8540f575faacb4f796286fc82241938b84bcc6d26f96d5746add280e72997517c5ecbb8e0a1f95a15f90e8605b717ec937ed588e73859ede2deda4228f98bc5b704211a3c521a35a82fb85e4f2f5265c40574bda46f2e23016f7ff96f60121c532059b96d2e574ffa3f55805d11fc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
