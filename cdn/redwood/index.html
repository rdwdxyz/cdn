<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e143d1158140d40f724498de19112c54ffe014a768828dcf30dc9597201f8a3af8e524e0ce75c1e1353848ca8fad20cad1ec08cdbe93b0af48c595e232c333c7859388eca78c8f12551311f54dd76036dd3c4a3e4beb11f80db3cc369e2a9c6f5207e47620f95a1e9ae01d5f9073a2af2554f20b1dc9f2a5ff83c879da8a31b3d98469b6ff37e678a2a8a80e8f309d20ee02b5f7a9f8a07e83ae555517a002fee7bc7163fe9564c9c24590b447ef1bd71a881ff6450a2feb9d672ea090b5e16e8e9453acdc5853c79bf39bb92025d46f82f6ec45b0a834fccb89f83604d0a0b03efce1c288f80ddde0e7920db3f2dde117958224e787309b97eab2d52f8448dacd3606c4c6a075cc6625dc453bf58e4ab52e3b1c81819a25e762026fb34a94326c5cb56869eedc29dc2e27799054cffbdb0f0f455dfbc2a2b2bd5123d782393ce8404cbd01ad6dd898972277d5b05e5ca0496108553fc3726646c87c4216c4034fa1aa6daff33c874a4ae18abc98dbedc3e7a6ab563a014d8db92cae9968808fdb93807707ff150e67be6a782b10d79816fbf8e56c22700de951a23963c3a35e7c2d979f83f1fd6b41d791026ff04cc41fd503bb07be24e51f97af15fa06c0ba6723cb646123795510e30d49e6a0edc1be39edd6ac632b25d55636355cca96749a42e025da0495cf1bc82a915bd0d5004d650c7a8aa6103fa2c4f1b6205a999b2b5489d5f961fc0c49af68e60c17e47843275ecb5b8870dd3b504389033ccadf6a27a983a5e4330f94d158701ff2718f79b3fd42ab5eff6cb731e3fd4d9e52039a947a02d5f38a3126f77defadde67caa9c65adb0e172fa5c6f8c1f83b0e5ae32bd079a38411aea38ebb1b448723fa6cbddf61e81b90de3e87320e082d1b1d7f855ade1d51086389543e087513d0aa8938b65442817620506a12571e537a977295524cf4e1347cb9424c29f2f1527d3a14b4d9156faca2395b83de4fec5e8df3bd3ef5404d57ec2ad2a2e55a1e45edde208d258741ac2c41580537a9178182fe1585cc3d213b2fa45200a54abd4363ec4342fea6d53fff4c77af7ee859025644c2f0fd916e930f8f292cec4011d8760057557f569e96e4d879198896e2bf5ef5154e80faf0a3db95b28e51b588b281103877a17af4da4971d65cc4dcd2b2956f1a15cab5b674db444284feff9d5fde4c160ab62e499704ec5adba470eec1533e3255c10fd53fdcc12e112a28beede1e29c76d6bc3d7bb2e12611983c61e249a2f1c215589950412db2c4e75d9a7ce8b161dae7d92a69dea6fdd9d9f2c0e81faa318d26d9fc6928dad7d2054d847958111825e767bdfe4e4f77741c0bafd276603df09b8101b3ed21b65e5874f802894c36e44d919bde7c7472c3fe996e53cb944e55cfad0a3b80b576203fa07071e4d030fe9e4467f64a0be90a19693ff660ecd8998e666c46b01dfc428de604e14660dcea16535b54d417aa88f72dca9a6aabb65ab32157500e6690aef946da895bf6be9b3feec06e9c1d16b2065df6e5b43a72d59a1891364ff0d433a8303c7ba27d12416771016025e3a614cd423d570ea745a6523c288f6887cb2f71e423db14ca6da3c2121d81c3ec9cd3b7a6ed34025e76c1d4e831e366228041f5e7668f55d752c476cff607619f99466d52741504c5dfcf536faaf3391ba15604b013d5b1c6c7c035400b5182e233efa14ed29cf061cc69ee2dbadc83650573f51ef6ae5cc58bfa78ea7d3eb770df90a814bdbfdc074e9005879c9fe5391d797048ff1b23c9cb41a3d496cde37157d541810d3670bc779f552f6033b4c8a992b77ac9a415306ce8e660fa017abdf2321e397dd0029f94e6994aa76ae3a3647105aec4c07e100adc20f026c38f2978d7a4c6c59cb3db7c5e084f398fae4fa4fd0381ff7cec66d9903a6c13dac86f13aa40ec798e76186f6d7595d2ec320c6ecb395da6def31267facb4d82f42ffb7ff2fe88a8151e198ffeff0b46af112572963a500e290e4b4920196ff95324aa5bdf6ae0cbd4231eeec0e532bd9e9e4e312923c68b7b027c92b76c73eaaaf21f0630d7e29500f08da64b597f60e72796eeed6b36049cb490933ec2a1c5a74a0184b1bf4a61ae66d07f5d6e03234e899705d4f3d2ec4a86298e42ca92dbbc63feb863930a0817f51a33e099d5de1b2d491340660b1df19955106f8d2037ced32e3680e30c96219af57c0cc7d3af393fc942c33eb109bd859d24bfcd948ec5bbd799a8f8f2a4008e6ae826deae59e76d5c31335b343eab0593e7e950724411232de08cd73135fc1a20d912c79ebeccfa9d1a6cf09ed76e4d86f2c93218d906cee98b8b2b9841f30f9e7ecd9c06f746ea60195cacba13ae8a4da27501073986754525015e7edaedbd7ab17f106fc5dd723393f25abcda7eb940072654dd31c6b79fbd63c1fdd62c53ab64aec91b79ef2179a4979a6562b051ed32335df75db75f55d07c2aeb1819e083e3fcb9c3cf8990eea94b4e62135a367fc2ec9015a6dacd30df5df19bcd41781b7e3fb26b25a0b49225dfc27f3a678ea6111f58b025cd2c70a31b69d78d3dde59a1f0d0ca8b61d7691e2f30c84e2ef5b7bc826636e81cc486a8580563b089fff788be109bbae6d87485c652fdfbcb3c018480432e9736619bcb18bfe621cdb1db95ab19063544793e475bea849ac977b3b0bc6fdfb9655c66ac89a3fe7126c91f6621907a777ea2616cbf56cdb5c7a89f2dda81aaf86f482c578bffc10e43e9e1a81483864302509546d90081eafb980b9896dda8cc64b37a0255c85c5bf7fc74a3797a739c0917790cd026dcd9e12cc6c978fc2a0866ef952db7b76af861900e06d3a39b4bd60670bf99fce97ef4871c60ac344565e4af7897c37dcbaa322c833d0f408e624fc2cf5828903ca72144d6b9c65691195de45ade3e20620836fb049a0db3617c55b1e32b357a7b278b2f4f6b950dc0e8f0919f01f9deecc4a31d578d704b9ce6f9595973b84ce5a4fe080a113e1f95540b410a5835a2dabad4a4c0c05a5ad0d8ebbc21292b949a87a65c9d00d27f0c04daaa3736e7697a4ee96e0ddba8383bcdbfb934129ce96fa3425953107eca4d81e76689229e25f349c9b2e01c340713bb6ed468cc0e0c9937a8d8132d114004cdf8cb16a0384dd76c51d7394e21f05c16a2d618e2527681990036fdd79b2378681efb687ce9766ec06f22aa0ca5963a06ee7754320f0967e1f9941fbd44ad0c422baa5f0dd51a80da99b78840a5f59bb6b70ccb665c476be54067a4edbeac7fc2ded273b8079338bcc3329fce749d0df635f73de0fec9281e75c740b219cacaba53365896f0514f991dde4ab4296e04a014c3609760563419918c4f9aad7195c69a9a84f557f7fb51aec8bfbe48015306cc24aa2bb2dc345f3d747129ef6bfeb4abc7cd4f228ed4048be9ae5d6cd550a6cfd8391becd7ee51b79564c2a2e425a4163cc44648a1048e9f1299f8ae5adb8c8230b6f7672b3f49e32607f86434560773744fab9f8b61e2fa542bd896603b9fde3902b5b90d73e25f8a35af8de6120c0c1ae0584f3221785da88a42b46a1bcde9fa9aa8b9f6e0b62784ba8c673cb530c8809ea277e61d643df0d3c91cd9590c2f78a9f373ea37bcaa53ee27d684d29b28a54758fea1d7d7dbf3e8db070c1576ffb2cb12bd63a768ffa6c5f445d5e5fc7b235a44ca83468dc019ae5c8a2f29ff57c88327f66c721342054329daee52f6a802172b903419910fc40c308fc28f9e6325b2796cf058f34e7e0909b22f78c3903c7dde998f0551632915dfa81ad37c0d7fc33019c78cf360cb1d55b44252ffedb96f0b51ac17fb8117965871e943ec3a3f0e63453ae6316de16445678e1b02526afa65774a339429b4adba8c7b5299cb9d678006796055d367bb4b0772fda80db0e430d98c82eb47fb492cc148019ac017d5cd4a63e251b1bb8aa5b2754e0c4907e553cfbeb2db40c4bc057ca4158405533ae7d8aabb1a704f71a41c3b79a1cd40cdb0f8262520d19c653f1f4d493a9590ac49b2cfbbe934a67d7b11b6fc8e610fbac89019704f2b1987a3646d460fcc1331bcbdcc7eef886a35b5e43da5db06fe5ee68d1de5e9c4f444ce38852fa0d3a868834b32841f05f67b02077c860495115f7cd4f53b86c77f1b2113296da940a620495157ae1e5b48f190a0d3a1e9c161bc65fe82c27cd3a5d7028d9fd748c548dd795f797884ec1a7aa20b846d96173bbe3fbf20c4ef2acc514715b2eab0863a6d182230d2496b8b0e00be89996a75f7cc00fc2a6d412f18b98f77c53be660e82c65c6be8f0ba498c7e5645bf09708edfeb9fc48e95957ea586c2df7355f2c0ef44bcf8be09508ccd7ab1248f63c1fc4c20a0e84880019c1bef33e9419602d4e3cf9a2b0babc8d00da523dc7eb762786063bc9a36051546d7c1d1e6718dd5ece95639347c79e23a2c5107a3ce8af8b41c7037dbebb41708ea82057565b909b5a9fb38148b263678198ce0bc3376d3121be2be4072e758d471725976fe1559be6d17d6827ce2ebbcb9eae201ae13d3675a04801a8d556b66346f5b1ff82a1e5bc8bb6309fb4f68559c07ed2140c2c28de8b034efec6c555338ff9763863dbf00f6185aa6d0ab062062946ce5d474bef07bcc48a097ebfe7525a7cf27bb91d059ac23af7de3cb553bf45d2569feb3f161ded92d7c023a094816c27c6a81ff1bbc24ef5a5a0fb65a6a6b79194c3864afd0c97d5431aeef58a1b849b7d91d811617ec0c20bc4ee20b4057f7fec4865c5403280e9bfc5f7eaee32afeb222c11914d4fdc4b81254e9e420c9cdb00a572890ebcb8aed3c8a0ed888787aee9819580afbd6237b79e2327c8e3cf2d42808f7d53060d21607b6782d2793b606432198cde2950f9843bfdf9de3000ae65d8aeadf034c10453522970381793bf98e2abd20d90ef78ec597becdc6ca83acd1ed9865f957f6460904906e44c0928fbbcc9b2cdce69e921a3167ef318e0a05fd2e1a921fe117a999e44045609366b101cff3856417dd77fca483f183d39453198b9dc05a8d4a3daea552bae433b8ea0340c231561b0e683b9837e1e586047cfa83d0b891aa860e53c40b811d265465787ea8d43db895d3260c6b22ed6b320bd88bf3a59879b8448380cd6cbdd03ecef85a2049d38c30422e3ed991c669fd4bc82ba7efcb69a42afc92176e8a611ec8528e11baed54e78a07d4419909bb8c2ca344b948a8615f7d60d8a864c2f15097bdbcd8f0006774d3464006957be04dcb473e478835285478762c048d3cd6a827995c9b5eb2b6761516bea847ae9338884c9f2e29b922a4c05e722909ef18a18d9971c94a82ca94cceb77727e4c45721c36bb5f1f2978b8127d187510bb5a5d911a06b82375a4b6251e0c0a6be55f83ead65bef4792d4e78571e2c038ce99c4bf73c9bfcfe2bf0a9c89f96ce847898f75f3efb163b560c811ef43add924b0c7b012a836710d348a350f6406e0ea61964fb1d473773200a200e50424d54c4bc57a85547727c35bfbf362ed4d4a20743993fd3f361c122929559aa5efadec0a9aeaa7ba57c146f19b852642a405212a8f16723d32191819a36c26e5fb8f6387a31154cf0ed2fd9d177ca127377aa4585ddfd4046a628896d10e7d7d0701a609b3c6efc24aa5b8be231b9ea86bdf2376406fd709adb5cf74aaf23505b6ff50dc82cba5739ae48461edfc916a4e0eb2755d32e63ce7c78f6ae0a9c9df38fd75dd3267b25fcea6c3a887e7eb0a3a5e0f73da6fb765592b1b1725f73a9b745d8116ebd3895837295e5d6a3c1585f40dc91f2f462cae954199edd1df81747eed1f49fb944dbd0a697d09e3ab8b249e42457d75e5ab789b2c8b685c993b031908c378193914e5627a202166089df233684af526c4484d1f3fa2fa3a449eb30bc45cafd0d5d979121d91ef50461921961045069ed768eded089441e5ab4334d37c57f91dd756afc74be4f437cb4168faf8fcc6f2d64e36d8cafa3d024c908a3c1cfac8ebd200ad1ddd0d7bd96102d1188d112c2f1be4680e4eb798a471d931d0cd692a7ad79636af8923f55b892331ac29be1ea0cc53b5c7d8e8e5c2a6cdf57c3c6da9539e01e9a2a3d48e064e7befd204fb2cde15d9deaa071b1ebbb696f534006f57fd78b8d172d85f05f258c600fe609e59dd3e71d2ae88dfbb032a4f4e5fcb6266424ebef2c454647898ad836a6fbb13cae0f309397be2827f890988274433b9e59af664c2613c0dbbdbc7c68c4c252025f0aa309ddd3b4558978dfa3a03c37da7e8cf8c492467b9ca6746a81fb7fe25fd4f3b05ee993e46bcbd5e8bacd49e8ba61a426eb7679185e3b36c5bf87ce631651cd545fab07f8c2f1e35dabc310b64441ca311a16c57596b57c27a8e0de81351621077d3f047ddf5e23b5f58e95c4212abb14ee87a1e0ad902b06aced537f8f7ae1d7737a7ce2fdd093145cf6b0520d42af285bac55b15621aad4b059e24ed2d5143808558da699b26ff7ba056a01a17f6dcb56f2665e92c6321cc4bd2f68426ebab72ec9ed65176fd232c8fa211ee1d53d24c46ebf83bf241840a727fe146527c8fcc3cb40e900de4d1eb6b59f0b8b469abcbedfd0010e31ccc073af26f93e023a57ea0c10e273746d21e12855338e51acb4cc49cd09f3e85b12c63d37814ef9b786b622f31dc0c4fcfab57b10dd1ef094d4b77d12501b8d771ab03cbe1b9aa419045fcc0aa0f73ea6d4b09f62af361f36f0e3b2bc8c190e34329a6304daf2bcf898710c48a6567f72645fe2af35cb59f900bb41892f92bb26314b4bbfc727d48889579195abc375891b8e8b767f778f0680a06ba6fbca7a05a7a26434f49a03eb848ed25dcb92334eac932526458f371a4c7746469a016be5f7adabd781719d7544c44a16b02e3a0463a64a379e847ecefa720f54b5147fcb880a377c0ee7d29f229f9242244dbb9d3fc025c1cc1848bbde8114bd57afeeefc2bb63545226290585ca952023b10e4def8546edb043013a28ff031bb55f24cda1d9c2dd97923afe5528462db6b0e38ad2322f25b112a4a96baa95c0c200fe2cb6afbb5eb5c257201203fd693216ee69b73102ab7ca490b10d801d47083b870dda3c34f858111c852d4ec907cab8039e9467c16daf9ea10ce52f36cfa18a3ff78f898914affb21132b6cae1491a0816ef33461a70b9be6ddb0c2a189dd2cee3a25d2e1a35df6041f508a95278ed9aa9e75d16a48961b09ccf05da714c01bdf1766b806bd56c471354807f8e6ef6dfb16c9be1aa36ce43db2dde18ffbc8350c438f80de35aa579385e26d39538bfff1e4a635e70ac53f024258fb1e9b5ee2160effa9f69a8e78cee34de26be446141fa57de528d4913fb91ba31485edd86b5c2f7252c7c25ea9e559d440e728176b1c9d467ac17c88b038459a0be3a7f4f7b7600da6fca717eb465e3350b851624fb8d6db50936602e980947d85efa601eb58f6be25e3c166bded40af1047a484848e7f90b66b051b1486b8a3aee48c249c700a796d1fededa99623c122908a4920d2e5685fe25bb6709b378f6d4b43e6ad3e75f0dc7e66ec2f9a756c991068b51e0fc9a36a3399d51e17cea9e3a633534d144a8c83686139c152241ba3c3387d84d6d6a1a4c046d194ccbc7d22251cf8e5a737fc86a4b93413e76a34ea83a7e10a46b684cdb0bead3816fee1076ee7827202921873f1d18c59cacdc1cb667f81c9ec5f1d3d98605aeba366ab996402c197e83310d010654fab0cca01d1ff9e9432ded674ee2aa6f6ca2c16f1f9d62915c1322bb0137f752a3c400aa51c9bdd58ed3dc8100b70671841050382f281bdd40bce04495ba8f4f2417720bce98269af353ecc12efdd74671a7d291df933418ae0c03038ffb96daf003bd89172125eb4651b1b4aeadabf7ba219e9b66f6aa2a191450f36a94c8492c451d60dee17a7e78a7545c1992aee13c2ea56eb9e175d6873157671f0f6ea227ac4c77bfd5d4cbaa002e270f42e9c9b43cb3ffcff948f7b17bc7a7d1c8be5a4c27026d2133864e040194f101d8757d7aa5f3a78adb6949d1e880e00d67f337a26dfc22a6c4c4328d8a0235b455818e8687d085e29015fca68efc5e253cbe54b5d2b633507d5ee3e08b94049eae6d2f2e1fe5a3b5ba74c290c4c35ac3c76d9aca25891de4605086fac95af5a8b8c795843ab37e2489d3e1a2565a34986438b5f5ab679f7679284b9ddaf3f1c87b27e41109d243e8b3a6530a79f30d60928f9f89a51ce76a3db9b44243045ba507135ffc12767d76dbc59dbb11f51278188d48ede924f2d25e2d2c57dd883ecdbc9c2d0ba7782db434f0b765bf54aeb101b364fcea6a68cf309f5afeb7da347eb25c3ae76cdbc7eda30cc4c4c63a5a93f305ac925b988dc553f545ee74069504eeb40e730e70c948475cb91a543af5d16efe506d831029028f07a5de984349de3d88724dd1a9368fc60b85eacc9dbbf7326c70d5aefb29da0c57a78ab3e21b86bdd96fba2546e7ddd13735f6aed2c58728311015efb9eeb14c7fd3cfe1e388e3b1042b2aaf385af674778f42219720494973f6b808a407887004f09df0056625db16e3b672e47198bfcf0ad0e351a4172aa065b1777808d4d4e897c3c8e0f4a7e9301d58163fc7cff64e9b06a54d148037f0a05c45fd7c4b8f39837ca84b0f2cf96c4dc7821aa2b529e84b66b476c901142d78159dedcf92ae59834db17286e65f2909aa461d3c4c5fa04efc3d46450ebd16cefa81f82670ead073e9649e50fe14407f77b4a5ecba85be9f019084dd404a090ac54f3e2e8158f6d9793c24b8903d2bdd8f5d0a4c93cdcf8037f029feb58990f4d2d4ed602960faad6eca51ae1da6316a6513fe033766f7cc7b03e986e8139662d55f1197b6208d46001e14ff4ac4d16a6bbba270eccb11130b75e93332813255fa47df07cc86d4424987f3ba3d92ea0183a7c0e70d61eec8bb1c42499020420689adc671d3539cbe895cc03b48491aa55144ceb6ecb7c30a4850e8c0bf59da23fa64fcc379d13a5071434f975109845818f2bcd07c6dc0d94928bda9925fed5562f5234028e009bbbf73607e5ee3e20ddfbde5b63c138f3157a235dc88342243dff5393a3be689d8735226c3bdd77a23d2b2ea9d84bf38f04fc2ef7b6d76751174297aca360171026606bc99489f5dad35b19eda9758a4430ca6b8233713a46d754183b6c84321b62aa90f0b139afc6c1552c09da5b1beef0d9131112ea27d0098da1365f02df0762f6034819cbead8b84543ae0cfbe8f89bd7e5e9697724f773998cc622153c8882f7bcdd9631b349dc1559a80d54002cfb33bf269e211b8bbb5581620b12eb02db5a8b70da036255ed95dd90d5b4aeab79763fcd05fae8ebc475c3e252fd6e1a21aa2645c98f63232a74c7c43a57a4b23ee69be576fa5b551591042db4a7fedd8cb7e75a8aaface935d1474a3a9a70c9f1d19507630e0eb9a26ae40a0a5b6a50e5988e100db8328df1009de6822f9e0b053366fc1fd910a27293302aa5ccf94c9a6b8cd3d537d809ca60f67d2632f048ed777f963bf05814c4e1c64d44be4f4b582bc5c5baaf88ee3919d25217d9283db666db4fd4da44bd6647e51c7ec34978105f075c09abf1c4899eb63b8489e864cefa193de8096efbe4b52b70ebfa91c4b275b9bcf892f911f244a31835690ccf8b356fe4430a41e1d26b2f91a9e13184ee1e74164e776ba0258b99d8d999c96575b097a394a96c714124cc8f2db6cb293133e24e32afc533722986b26a5e94246eebb87e41efba65a4da1d27edc2d37d288f87ffabee6cb7451a87d3cb44e767614e7018c04c3d69a95821d88f4619b8d5711e1af26b74b2fe9b3bbd9ebf7093bcc1a72fbf957b2d3e16850ddd0177b10dc9b91ef9c2557c1d2d9fa1c41e94645beb5b4211299b532657ed03b6912d1f52f288fee4c772a6197a2396fa53c357e9aa8b030d4fc260101c837a92e686060696b2fb8f6af8af19fe49d16e72da0c17c37e5ee0c2b282316651151877186bdefe778255c7c1c953d1c40e707c260ab1e9756993be2b1035df13c1089d97ab7005e9a23982b0ae9d777a3d8ea2b6ef1ab8128cd890e0c07ba6a0f0a62e0b42b467d6f2d6f3348aea93597b5ee6171cc3a4dad0cd22ffdc65ebe570a3900d1ef3f733b82ab69870cd95e43947253c397a31b835ec150b5db34b07b9f9afc68b46b21dba6ca4301e2f2eca62d046071da8c63c35eca87c57c3b4b6e2f7897f5249f3c7d57b4f7e0892a77f02fe4e1cf7273ab21518baad0bb7487c92922538f3ce73001ecc4fcbd8595c1dbfbc9f315033bd2ce8f6018fb4760f404a54cfb39d40432d315f33e23a3d446d7b11f439833582f97e95ae1eeb644f8968dd5957c919420521eda567cc81f68c5169345a76e9bc8922ff215b9a81e6bfdc57e0a3b49b74fc8e2aca810d98e41796610f0bebffb8a019131b29608d6087fb5c322c8f6d06c65cafc874930387dd1bfd1f85a383e579fdda0fa2a4fcc7535232a814c8d5f5d1ba327119e77a1b9c0c51147144230ac252b9f32513ab83bc5a095e2ade25c337a4a8d418e9c02a912c7d08f46df740a64fea2c7f824eb61e1747b526d5b272f8c8dea34c877d0cdef2cfcc342528dceb2e0a0e32eb6e4496fa7a096ae09ea5697080eee479af6864fad18ff7042b4f6f759cceec639c6dd2779a86a6be47c7657bc643bbf877e4c8af6632b542105a3de2a865e716b5a3e25df341abec29a54a28616086b291f82188ccf507a41023b956aee592b8550771ff278de098d6ea69fc47cba38eab06fb79888fdcce1ad53ccf7d5f99e64041456b2aa9d5e66eb3405bf434f7ea0c9a9dcb1d393ec133b8cc402fa83a7725e0e42f846c2ac6a0bf877966cfe0bfbf35e3dcc192b02ca8cba331641f225c9ac02f7968c10847e2768055fecb8ba71352858e147e2516f0482c5a937e116d4baf81134b0077d348b54897d048b897ae888aeec1906403c67132639ffa86f7ca960347e4898114d03d67646a135cf29e1f33f47602a7cf4652b411803a32ec390dab8bfdc36c93d83df463d234fee4506145cd11c809d3984afe933fd8da2c6a7d9aa6659687b8448fff45aa872f29b19da15dc5e836f27dafed5435a894467de0bb02f80cbe83ca15a30a1bd4c998ce1deb8347032016dc48378b8f3859de2e26b851908defae361e9fe83b986e9987bf25a6365c8be3ec5890b3016de9978119a8993c35070ffd324ad1bb8f62e46f96df91fdcfb6c98c4f018b12532d4c54492369ab89450bab0289475fe260dce2084517027f18c0e4b0722f96bbdb24a65e502be9cf2c02e451f82307baf405f68a4f59d7b04ecee5288f37408594d07a24fdde04b7dceb6421a40e94938337966beab555f93d793ecf9d1ee772053d204b842c7ee629792e917e4e9aacb1ffaddd7d5c5da50f71640cda9901d4b215f04f7f4f6b0d7cdc6d01acad011f5100340c9a618656153fd66c10299985b3add73ec4f62d30f40caee35f3642e342fff96ab5801cf8be9db889548dc1ddbb5f41778299b54c59c9338cbdf35d767690100fde6e7fb8ffa0b2573d93c4fd86f9a41ffda512444f188412085cc75b9ba7f195e6e7f51ed67dc5e85236946e7de75e8695f3fc13e5afc2112e41102d3bbb2d9c371f6ebb69d7a1d9d8839a2be54fc430fb17edf2cfd8632d968f10a62ad0f79b264016d63dca50e5dce45d1821ce737dd7f2843fe5fd704f1351496a2ab419b0bb6b3b4c9472504eca917a40ec1e46ed7f7b3714c81967fc01ac50417a1200bb9bf4e1a8e3f971d1da5a67b48c20d1828a639a99be8b92706f04b0a1f2d39228174585dbdac7924e6ea6f7b2293f3842dcae53c0808218a5f5c0ca2b5f921fb1ea2798a278a2c2c795988d2a40a702df73adb1eea73116a170f1c1ad1373c70f07d62fdbec526123d0e609e66ed367b733c5609db9f05c59165c281832474b8ab199f4c341fca223bfb6e2bc58b5e27d092512db4b4010021f730a708be62d1248fa5b9400fdd917dd2dcea9a1b64ae04a57d6a58da274977f2d4f15f9afe623e769df2a11472251c1f7ae25c751fa4737715b0242ad181fb26297107b334ceb2dcb4c9419ad3d495bd4237cb9c1dd2b64b3422e2109c7a0843accab42626af5cfefc401ef001a69b300e09fddde8a02f0f2a30ab36911e8b2a6070404b62f023d49c6e0073473309ad0a937c9469185a67e5ff5766c37c48bbbbf7076d7a83f3a53c4bc90708194b803a8157260563a60400bbf6a19d78880004fd48a33fc2f93dee4a6a958f1dfaa2ba2f6719fecf65fc2ede3106eb2fd37308975ebc9c072b3a271570febcea1c4b1f1e9e7996b2ccfac7d0781782aacd9ca130e9bd8fd894c8f5fe2a736e5e56865991c3e93d0ea2243c494b00d74cf51a2de4bff08730c173627e9ff392ddd0244ac906930112425698e25f3522b008218f5bc54af61467c240812ff33c62cc83ae1f3d9d0ba0a5ec518706e085c5fb63e3a2ea35849c3554e8bd6adf181041c38d86133ad810eb72f388a377e08f871305321723425283cec5bac119b192b1bdc1dd57bb0c4e40f6ac78e1daee01fd4678386997414097ac20746d9cd9e6910dc46a6992875af21e3a6921cc42442f627c69e4d447cf2df280ff827904951dc162c4e53aa6d1ab8591b40fcd4374d4e7d65bfa5d3ee66dbbc5bbe295dabb0d4a54d08770a225e012dd54e15185ec4e4540f1efde920b2211c46f53ed7a82d47f303995c163ec6af614c34ac413719c143cb52ca04ba2dc08f6a02c3a27d67584bcb17897eca2cb0e9d13150abb74da68c92d491ea6f999cdc99e35bd7a10bcd8e4c3fc588f4610ed853c61d440b843a0249ff8b03536c906675e3d9c7e2ebd58bf69bb30fb244bb37f6889704328f35cdff17f57d3f922b20fea80f9b2095bbecbaa7d3d36fb7b693ac8dec0162912e442b79e466b214c6645f03570054757a84a484eb2a9cbc8555d76a9b981c2acb70dd2d5f5739e6e210a97b1df31b6f1c6de74ebf8e8206a9eabc57c73519150614f0abfdbff6ed92d362cc9b7acc9edaeb96e1a08488b35424f2bd229016fdca26fc090a194cf0fa8c772e98dfe9a1eb57b28ca768e7c6bb1a0f8f9d33adf3f85860cd2f2a341c66c9aeec109de13fdb33c74760c71773fbb88a17a632bec2b469b49621b3f9c83944f5ab10f79c305fd48c172827866ffc524dae942c56cc1fa3cac36b846ba08088d50cdb3f133823fec295ee8f1ee6f91544c6cc3cd7212d0f0b0fe7c141197f08617941c45bea31994d0ccc6c651cb6bfbcd706fb3ecea52b365880875d9d3f307ce376f9986f7d7670f9d09808294f45467c8d65c725734b807e5d8f574f8f5559c7274a8abf87c75d02447d26f3a79c2e1d708bb8d98c8b0bf88c168df84a03633bf76fc472645f25a7045b65cc94f2617c5b3c5c33d02d783bb28b6126f04819767b0179a5b80a19dd5c8b345faa45c2aba7cd0e74d9a72cc59e9768e88cb2d85db79b27788f3cff53096b9256cdbe1f7c233eb3146563142d6b106956e7cd1c4f769436cccac485c3f71a1cda6b784798ea841442f4a2bf6f9ccd1dfeed6a9efea2ef271f05b4366d1ecfe2ee3c17479c8f149fcefe1d9385fd538558a0437d88da2d2207a237224d3f81c835b665d345d9cc2ed8f6e41629eb16c106522222b09d712c264e4e21d200d2f3e18807210b24452507918561ae58488e0efd4defa24fad96ca11f6da71e6dfcb5db67145da2564b60f31ea8263093b425389354a01da50a156f13354afcacb10eedf172f5d50aca883350bb0f9ad67add6231a0c77b5e16db27eec95a91d30207519263df9ac856d14e1421d775892cf09f68448e777c0eaa1ea03933f380d6311539189ad3be785a3f4553b23b7e3cc5deebac4f59c10f61a73b22231fa7d24ac75fe4edca991f1d1a633b0544186fd5cb704691c2b05591b0d5cc18a0aafd8f605daabf2eb4bd704cc0a7adae88fb88af7fd0697bad528adae87dd1fd6d3ddf1e7dbb7dfbfc09765e5ca27d1ec7281a5f7f8487f7804534c4226a921826cc1068afe617fb74f02e06b5d6d94b1b28669057689f8e2b0948faf6889946ee480a341af86b0343c8475a6c474dfb3f333c4ee52d020b1dd40bd8aae134d7668878d171312170e9720c473371e8e01cef9f40d6f526cf3f57f3a19186065e68f5a2edbd12f3beae84a2b29df8e7eaf3b9106633ba77a101c9996e033721212abca2acc6398c214b1c644822017931a473b0b4b949d23a23165d764856745a98b2bc43f4f131861f8c9516ce5a44a8b49e16025e2e3377641f8eefca4a05dbe827f264cf58d708d3cf862f2615bbe9e78b3efaa5c004ec7cf2ddb48d9c2e617e43d3d7e7266003b35fe9630baa272efcd263ab863062ebfc0cff1b710dc6a6c6de907037cfdd1e872f038caca5f4496f0914335d38f23b1815290bd38509fd25fafadafd46a293b22a1ee979ccd3bea430d20f66b5043cd4f2a1a36208ce60f65bd41f6343b858bd6ade455a8743b3da1302a4d00f12929961496d9de152c4dfc7f9dbc762516b751d09f9b7b1a45a53bdfb3df8ee8ce67e3d8be311b36ab5dab36218fba23b4e0c13f467beba251ddb145349ca3d3e81832e535692da2a5ff966f51ff138a0ca4238c3a41dfea663cdfe425073ee86a68107307cc74a4063d63bed9a17f601e088a4ed64a8eeb79d02bd9be87771333a7a9978e82a31bce8ab819f9710168b65fb5021ea2b32b4e12f34f164d9ea18158a56940345876d5b0b09fdc3019fea1a8159f558a1c30df2baaf7546bce0f7937bda50feea3685047fcbd65d67235185a80fef86980b1581cead541738223fd570dbd079b59f47604e784b0800e5b7f4a5a5966092373305d5227ac0361160ae250c6490fd95aced05cec8691a4ea6688a923b0adf4e40058bc697d275b51e9b7b5279647f9bd97e7f5583488202c5957773eb7d6a9c107af1ec4572f4894c56b8a8ef6f01e7fe48733d51c30eb7529b7462d5ecf980ff2b0eaa67ff070c276b5548351cee531521aaa1e53f2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
