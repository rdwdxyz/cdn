<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae762f37085d4d96eb4300b63ded165e80d15e738699be4dd50d9603efb187904f96fca99c0e2261fa7c7268028d545bb456e2258167a979a384c3ba380e4b6ba8ad15043d3d31e3c703f5d9b2708347605b4de5666168df453e707aaf685de0f3cd88ed56a618470b6738219332041e2466caeb033ddb06b0e7fc346a368aaae0b223d585f7721123ba082070f15a3d0c6f592d3dbdf45af0d3b3be3174aec0358e375827ac390407dea2ace65556f7d90b5af7d08829490211031520ea2a9d8a45032b3262a035da217fc891b1855ee5ad0805084ea621c55df070f3a7b66201ce668a94660072ce6e01fb2b64af53dbfa3850a1775617c5dca0fabfb6637636befaadbdc6cf49e9fb19dfe2a9b3f071a967f5be7e1f9f0c212b5ad20420e4e51d8883f4869c95371d9976b6b0b01299e48f9a377570a626abf7a934d3c30f7650a18ca9303f8b5aae920da2dc8378d1b53f436262b425bd229ddeb65a957a0576cb75e4c8b82f0278e0d70dcc061d374df231b9f664dca38669c28f2b6f78b3daa68f8e74e02de9ed8f1679e46f480bfbc34aa6a1b6fcef814278e251905bd00874577f60a2786bcedb1be881d2adee19f5f6b6e0e56d35a6f9cdf1a71241083c35a979ae7212e5f19fc76e4df2eee19e3c5d2a7513337cd59518cab57713006c3eac592af501bb03416e72e7cf86019a3a0d818fce49901aac21d474ae79139f7aed6af06272d9b6907b1bed19916d6850a406f53056928f25a38747de7ee2717067813bc0105319a0ea6de715d6c9e62c2b61251a7822efefa0dbc1ae8567ebaa470ef6fc983b8e833372278b0d2c5715562f4050b33b0087bfb9b673502ac56c31c87b0ad85f84663d8acaaa95cd2202d751589bfc4691f153e75d1a782a4fd9d34e113fe2224f8157d8f02d645d26292e7eee7d91cb95d294fb5bf0e553609d2b4f7b1dfab101e37cdf27747ac3d04ecd82fbfa03ecd2f9e905023a1de77ef1b439e531142ad3981d991628e38e761f3d6d22291e0a7ee84a78ddef837a993a2824299325d51c9fffb419e3d993b2e36c75b1db0aa76ea4d2a2d6cf01373e6711b5388c6128c453e3c8b3e74e72bf80a610e76b88f782064f0712259ac17bad9b53c4537341074c78e6454b5eee38673e715dac8fe109d7ded7d59be7e829db693423c9ee5a61978100bf84a9cd1578f7538c79fb1e9641f661d6a364a748f0c41dc71249c9747371016332e87b57470a8fb49dd148ebf5a9b2750139908f1713fc388110e1e1e7456f58bbe0977e85d314fa7cf392fdc544cf3c235957550fd628158780ed17f1ef626ecdc8da56dcb5b635b8bb54618fce42d9c12a101d25be0cad5954d19bca4bf7763c071301b288961116e591aeb6591626a0029a3bc2f04aa61caada72b8e6499a9c24bf100922f443ea59c712841bddc6698a8f32ed0fc1d061d293ebc52718c76783656341e705801fe03ebbec0f22dd2ed48faa2b44b6fd6ba9e137d20c8d43dbce81e6f64d485e23d162b758d682284f03e60557b31a4cedede0c72579dde5e036be1854316f2c97dcc70772010fc0a8715788617d2fc19cf313f90cc84df3b22aaca9a65d55a5dca281e52868259c5bf110764a6b0da118fc0b7391346c44a4e76170d7c64f20cd104b94149993ec5735d1d4e3dc4973e8be3ceb49f9f85deea0bce6dd0aa21df8199992ffb8ee0c5068f606e80dd268c5e0a68562b63ba0c0c096bb783bac187129463bb560676164887f9c5dbdc0a2add16b407b5aad7ed8d5c4a4348f69b3ca774f48f6b551ef5cc85046f56bd6a6724793c1a7283aac473389999153ae372b4381176c23e82aad93a58cc05bbb731570a61c8285f82ba4a2431a337c8ed8ae615d754be7333757002722786246e71d55a2d4df123abe4197081560a77124676c298e8d9ae7e3a2878bdb5317c5e59bbb8f8f237451b8137a112dc1b9313278a5b2399ba5b003e3ce8a71d355c2f2c915e61a7b912dcda335d0afaae2b83473fb4edfb620f93e8a9defd643c3d780e03620ee80dd2624168ec5af3c5f5c4729ed9c1427294d9ad9c601693b995f8e37c4b2bf78fa9a118b81131478530e274f8bed7fe63901a4ff5530fd9ce8b234df9df11984c971187178df8097f784fe9c83e77989e0bfccb2ae7ac8b7259a1a655352573aa743519279a9b0e76cfb435c14157b795b6e4ef3434eec49a74046ae088c26ccd5270a36d9fdfa5e743261496918782139f6b5c01c476e286fd1a2194c9f5007208b2556d27b28c0e46c95573504033592050d85b583d29e932aea0a8e4aca40a72eb19b44463d93ca5fb5ab26fbd2912e8a9dda2c93c23654af9aa7f7e9614ea4065712337708cace5986d344fa479241a990aaab8adccbd10f247c1db8a5e6deef578716881564f3c63bf31451e534908d08acf5e831c94e9429e4f80a2b6ef3634f0adca791d4bf87fc3944d0783de42430d13bedf9230f692f5fa0e4c36cd920e01cae50a8ad66e1f73e1b4479793cfab0b36f343a866290b79191d48cea34766352ff85a2bb8c8ab414dc60f51da4700b6754ba3cc25ff8ba9b1d4407ded3ef84c192f5a7a20bc353963ebc8841ada2a079e3cb9883eb70b5f7f9967bea50028a84e23adb07486a10504d59a532e7d16eb789d94fb1b0df61c70ae1e084eb8f3d863a7a958337cef5886454dfea9c160fe6c55b7e842706578563a199b664e2193d2f113b8269fcda86bd828800db2bf2bcfa6553aa0a765d4176ded9bc1840fa9605a9bfd1601c2aca58dc2b8614114c749710b39e22abcbb87271bbf86b7b6168a7643b7da7a68a1a9e1038ebf405b02598a3fc314b63f948b02097728db73ab01c49aa0b35a7c4bdd55b082bcd213c330d282e48b43e3b6324b59e77257e829620f07dfe70ed3777d89d95d09853fed1bc16098abb5a422f9f9f5c77557e9eebc60e9c9b1afaecb2e8b0b20032da7ddf1c22ad4bdfd8632ba1e20fae1d9c0017d0ecf5a0b6b47db7ae267ae2ea468f25b3ed64becdd2f523dd4722372e934a23064dc3db4ada2f725bd8a8bc17a9e847c42d36dc3ada8024b97abcf75df67bb17bfbd0a4f74c94c47fc243352aad7521c04b3f5db801782663f0e5217912bd7b4b7bee4c1da76eedd986fd5674629d11f3ba75fc3c7e0a9f541e34cb24f4290872af4cd248245e9b0b42d5468f28f8c71d0ec7f77e738fda7d049d69e1c81a0779c4bb91d017a5110e628642d066a5402e46e830e97e4a9745633b3d81a8995701f465dea60973ec31bda63f823d4ba075cdd94d191c515fbe042209c19089550230ad498be82073352c09b44447a40a349b7e303af7350ce4cda29a65de696f4689771724fdc3867e7c73daa57313186af1241a80635f6b00b36974c2f969df5ae10bbb60469bafb8da5f14db333d889a90a15da8b2dee5fa73a1c37797a7e531e0993549c3748dd05ebefec03b3c4553370c68bf5ba7f1a983b09641ad0de4354f0c6d8d5ed3803a4fbc77a0c51030a037e666b422b9ad06945513b1c6d35b1742e183177682abb054b31783417ae53b2fed723bbe0db1579f65dc56c9023a4c8f5d606e98a30617013a19fba06e67089e232ecc6c8434cba89884bc2ea0044e6f47bca3b834ab256ebd4c9a97a4ab0b6515247567532fbbacbab24385de0140c0a4b8b293ee8ae3dd87bc86b70326cb234000f697f3f8fa5e1d111d6f6621027f60195ff6a648f7ad469dbaf0a29b0a7e27cc0071fbee4d9de3bcc8ffe7931db8a1ff434d9be38a5d40f3b7d3fd705b4555d5bfecd8e4340cc8f860f8e5c0e43bca10ec351ea5821ce2a68393fdc99e3978f1cf84518fd8c6c93b5faaf3ae05a1d8ede8711863d53583a404dbb5275b87099e809535e2d3f7eaa8463149edc6e930cf8b254efe82d25b08c660149c494253e8aa91e11c30d01b79e9a3b64185e71a3c04395149adb856f3578473dd0a3c801c477f17b82d358d4a343f876ccd58f41f2fd7208138a5ea284b44301f9557b71d856a304e273f9f391d542de0a77aaeda082bc5ea7b62f440643da2c4b7a3925b2336d1e477dcd35a79909c5351cf17077735e2081bbb5c37bbccb1b148d406f4b087362692b4658930d5ef93402b8c2fd85047a3af5da27e99db2aa225634f341838f991a55faaaeeaaf7b3a0228c97973a337c041f2bcc6422d648cd3c012b77a456fe43fc3c16c23c6606a70917f3273148bc7aa013c6507c77ca1aa3414e0ee1d17925a38aefacef009ef10c456b20ce50707719b22d4a1effdb3f3f3dab50b4b0ed740cabd6e8e7db4c900414656b5c55e26f6e18639a3d261b9ea48c9021356501836a31b1f86a3fedab2658eeca6d28d005177481f819d1c4f97cee4293ee86cb83130cc54fe67bb22764cb5ca0acac447c7aa3c2f970efcb5df3c01a9e03f96e754943db9295e81d5b934494b628e811cf6a8aa76ba7bd11e03a2c11e08f16b777d344f84ed187b370ffedae09c5c02e85b66c17e6cfcf55f23ae0f979f5b4c294b0852fe2f1ce1d3f5b1cec3ce0d5ed0efc15c69eff032796c54435e940fd519c4f142f98c47d430bf8b73aeda6538b461897d1bbf4678f59557077a4ad177a8f8d42ab2e6d80c88adacabc3bbebcda3ed7c3d7334c7d141b8630867ec151429398c47874498cbbb51300432f77a5e125602f10940b601595a985053dce668bcf5d20bf4c8ba3712cdb2c33518c90dfea0134f5c9da426b2d91c8b3d8a7c0713a99fe0dfda27d6a29d81810888c9bf4c1ec0e433921827c3026591b755261dc5e7b296b2ea2ef59241d090461655138321c2823fb016d69108523fad3f555d73762b347f673c4715e1dde9b71c840bde8a10cc204ccf85493007f783cc85bb98414a63f18107476dc88ebc05bdced9e23f74fb6390a3ff829d88a62294d2ef8487a46cd0a750f05434ed94bf697c473b69ff9e04a4ef132aad02be68d02eb83633c0edbdaaa40b402f1d27def90cef97c590a3d6a1b6ee41ace9d977da8867880c6408f3c8b0aa371c42ba78be5e04dacc5c8c6254a72e69634dc7d9801de365c2ca64692e2fb78fbbf53b774992bad9769e284a647eeb629cb6032a902bc8342cc9984981bccbd92adb7aab8381f862829720aecc95066156f21a2e77e90659414316c26cb3ef7b7a9efd4c19f7ddb8c747c7fa8e1834bfb2bd8b254801e380e469609014d87196b3408a8fad18bde8471e6939886c7b3b473fd8bdd248c7d9583311bf12b710019f3b361aff87b7d789a3aef7ef0532fc0ecd711ed71403c378a3b97da04a9da1010ff388380736664a0dbb34174e69f12af73db464e0a35ba58b46b703a50fa5336efe988d6325abcd288938b64e4248a613c06c237f39331c12fb5d3857a01a2b66bf5a3cb5e15bf7b0b62b296ab6a41f2158c32708cd3364a97bfdf02ebf2211919a35fdd1e38484db9ecf37886e85504ae47b079ebca6535eaa0bbb3ec416be8a1c34fa06aa584b468283cfe9eb648d167b92d482f93ed290632d48009be057ba20b2ebb76bdb34f869e920fd57efe9f7a1ac7365360ad7d1ffcc2c5f082d429c3dc3834ddbbeba87e75a81849399f0494fea6eae1f157f03fb0273d9226f1433c27930a69bcdb15777f0f694e74084d2a200ddccb954498f17a4f99981b45405237a5f996fde67666ffe625336a7e04179de870d0e1305ea908184086e72c42ee56ab9e13ce95a967d44df29d2bf840be09f752c81139338d482a8c92d73627ed78877ba88fd42b285a233478083e38af5f2943d6e6898db29cd3b07feb96a81621813bc69848d4cb16e897f2864256f7e15a94afa2b756e4cda9f184136d6177782125ea0b4531dc3cfd6363201b65e7918a87debbdb8f2e90a494cb6d58d1ddfafc1f1446acc8d6387a010ccebfba8d9051a264281e2954300f9678bfd300a22686a434ff8dd97d02f74fe1b895dca17bc9bb32423662ccf476930c9f851339f6c1ce0c38351bb0e8d45e11d4d34234d8c68b8286f54349be87c472bfbecab9db3a765cac27a2d013e7a161858c5292482e285e72715d9f5bec48a4a7df848052b1f147fadf66fe7191c91f9840ffded6e4351f00a6b22eb7d548c124eef5e8279a56cff6eed5c557dcdf4e710caced29a6da515cdf0640917ac8224eb1b1335658d161352e3d83e6bd0174b22c6e096dae5495f4c60441fe01f10f455a61c8a32e36a92d49dc2456f94087b7814a08a9c12affb5058db4392dab0f8e01791a8ac13ef2c89ce69a8b634487eaded1e7747a15799194bd8f0770435c92848167728fe558a7b8ef565b461ee19be8d37124cfd3f0915ff5b560cd2420c248adf50db5554200f58f64d9f48e4efd2588b0498ff1145e04d29a45d4b6bd47ddd4be290b63e0fa739b9dcaf14147348c4c527ccd242daa84f6bdba71375f96133c35debae96670d968ea4d0aef7d6359111ba79a706a1cb6146dde33d4067a963957dedca8347d205350df23249b778a99d21601a0a026567e07f133d5a6131ff006fb82c6cc69011e9e549ce24b93992cea474c4929a6703a6cf3d5d393fd25b100328e86e1698e92a708408ad698d4fe5e747c897aa31ae8e5db9aae66c02c631dcfacba70ecd72baaafa57b41abdb96a63272e78b0c769b4c7aad998cdbd327f3668a740987c48e9c4f3d605c3850e170d34429aca241e8a44d9ad1b78705ce9d4e1f58eae16b152b97b0c0ae22d1b205f42005ffcfb1f54130acd5e066387e11a77f854cf34df05aa9bd112ce773d3b16c5b8c0d40945bf588f93fda0054fc1e66eeb2f1ec3368701ab18218480a0f2449645bd371a6cdbec895ac2f1e3e6a6d915913eedb631508a3306dd865467e21042bc07f5f742ac5b9b6ac5c8a1e74864a0b60f0668a071a4979bea8c5abb312541faf2daceb4f0206d1054a399487ca63b5e457e900eade319985442138e1d84864c30a9b1d74f9e1829cd8325770bf210acfd961dcddb8bcf34198385fd62fad311fe927cf0921546399a1993651c0915b8eca962e2be03de316041c593600a086b66bf1a56fb3c5aac0128dd53295ee4fbcb606cc507c0dce1d49ec5300f35b3ab3b5093f5e65403595bf15e9e82f413ca0cdd36bc24ffed1e794c5bb69d7e25950b131764e12e37ed2ce6eed2c4bb0bcee43421d44267129d50646328d5ca82d1f6f53dc6087c5a761473a9dafb2b46086c91c199278dbebd903fd51a4e8dd8aa754ee218b6d408d1d1bbb07ac2c43179dd5feae01de1ec90f81c8161954a8a5112252c5eb68f43e12ae7144e10c172cf9ba21795e9ab204e4857f29e191b2814499e071d2451c47f2a7890df581188aa729df1bdec73fcc4f34c4a2ca90bb3cb569ddc79f6ad59004352c87bc4c571cb4ab8f13a033203e5dff77a95ff802462f7307c4faa8ecacb47b8c99b0a38074bfce035117d22d82deb4a1f857ad25aae0a8a66468717cc0cb4ad18e8b7a6684fb4bd33586912292f9d0188d508013cac500bd05453bad17a811e224df6bcff87fe419e5a4e8d0c1ca033416e7d0f371b25e3c3894ac3cbe1a46a2aa763565b8317e1a30365b7666317ad543765148086cc5430cf22da7ef3db5c56a7c2f9ba30c451590b5893667366c28f94433f874f54dbee7b0c11add25686c3b5c737e57355e2273fc41e4073739de620b719d195271dc034907b81a9babc5c95fe66d6ccc914f6a6eefb4a59033ac2c7dd339c810aa04b6e7695a905a15dee508cd9ceddc8ca56a1f85a689800538d5c269a4585fb305a452e154b2bd5f4962bbc4d25c6bfeba8f42c73598cdeff35a46cb7d45648197e103887fae01dfaf21e356ae4e3de55df3502ea80c5488d709b3b71b643d18ded884826360adabe27bfa7c6320f01f15dfb04137b350a23836dd82ab160540c2f22c6f2e0da8ddd43fc6c1169539639618082cd3e7ffb7e0a3ad7fc1c28a6da93678ee92e473a0c833a1a58218cabe83f0e862dfc6ef8ff3cc886c4bfdb8fc1a24984d93b9e272967e70f7f73207855c9de0b733431ef2b5c79a94dd5a1d952517ad26ce993de42b2bad48c768ba67008ac3fd1317c6f8054ede465256adb04edb18f84b9d68528f02403aa76f090f9c00cfdf5170a917511b0ae13ded574c35f47c992108403f409ad5d67edc8e1420cf5e969255392d52812448828b8220c6f6ad9399db37bfe51ddf608db012710ce05f9192e37a6cf90b90118f97183f1947e9ae4645e2468e731ded52e298152a7c69352d69c60ed51ade2afc8a6b79a9c765331a193f17e0ba3235ea623fce7e2b4a019d23c7cb131a097bf0892ff98a63577aac75931fdf586f89e0903f8641887a2f2ddfa24849429d144fdcd1564167d85a29fa93005174dce4464bbc7cc7c64bad463974c14e37c2436654ae33640526ec4594dc085dab5a625d8868976c110e15521e739001e447e85d4d07bfc5740fe48209300dd97c4843b1fcb32409797969ca33161f11c0b97178d5574075b72bc43ecb3321140ca7a1b1cabfc597c46ae53a51f3669e51588e7d83fb27f4555f4d4a82709630accc320235f1e508bfadcbf44a4d19b661987b81a8483217d4298b0ef813d4a68b16c87e5ea35a420bcdeb65be98df6c03141436daed24315a33da2a9f83e9be6b8e3d1115eb11438d2aa0f73b08cea727ad88b8abd0deaa25cdb7d89e5150dde14db73e428cd2d75779d3c55fd0840ac977ad7c348e4d6b72905187dd72ea12d53c6a4e9af07dac186baf4d836346fe0324fcfd8e129c4ac4f58ebdf5f313409f50baef70e22d3041b8a7436c611f304255527bd4d143bee02e71b6f370db171d4c78237fa59866dd62a5613ba586c183e2a78abe4ca837fdbb2a7f4fada7a7b418f534eb6fd00d2deca2cbde1293af12095ed1ea278b31e4f6442a14bc91354cba645bcf6540c2e50eb829f998fe037567778d8926ff69b075ef71eee996c8b1793e44a7f29a19e57e98344b91174074bb30bbb0fb6ed1720a023466dc34c0e74db7b5c4e5a3fe692fcf3ee07d579af6d4f1b495a9e33c4f805b0ad9c4de4643521bb342ee44489dbfbb7e3a1c7b6579caf00abffa6ec9479fea501425a4309556a19e4136e1d1ffb10a7ee25d2e341178651adf79c36c8520e9c3bfecc5f07c537173b47b7cbf0989fa4e1ecd520798a430b21031267196bf2033a7b5b7f9934aec2ce364018f3ec7465002cddb97f8bf2c2694e68458b1928ec62f2b3bc86da611beea8d06f2ae2ccfbdd1d0204b2ffccef15ef687d93a8325a132ed20ad5352c43a057b7ff8bcc1dc0262b64f547ed41320758e4fbda92aea5b1c69bad9bcd6ed2abf9fa9486a8648980ed1839654567b8136c468e4647de5de751598e22deda47c758a270289995465ef5b596cefdb3536db95e81153e278818552ead4c795c38b4a9027d95626ab3442d4a12d82d7ac1d34f8efe4aad60292e69a864da8829eb76181c10243af4f16eddb1b27fafc69c97e0ce500db8bef376f795d8c6742676770c0008c31b66af4e0807de67c75545d24c1068a7ee3d45a9829794391c2491097cf6bf5b484aecf9497ee7de91a9ade8dbdc1359bc62f44979e0c2634d815d24ae4404dda243c0259304d9efaeb7fbfcc1b62398515db91d331587790f1a3c1a6ced7351b19d3132e748c64027dfb3bf52a61ae1344edbf98fb4b9e79e46b18a6d9ccab7319a3fc386cf4e7e59fce069c6e67202e4f14b7c9c006733ccdac10b104c519216143cb2cde037c7aa6f378ece86b0e704eda25dac8be984039e05f88c8bc06a9b94ff6c67bc4b5fa6d44f46354af47912b0039f1ec5ad2d9b58251d39f694bb4783d3d1d929a2431242395164b064d607494d67b79b8999749218c81183e9f37c20002152be5004e2e696c62230c8a74769aedcf22fe58a22a33c3feff617aa2e7ed9604d9a0cc67a91806cfe10708ec278f71942ab99a8f3577e07f3f76e56a88d59a9e0f2954e074dec836fb6041a5f8ca10142fb37b8030381ee7c4a15775a865eb7bf7e375d57bd5996a7c0b296f6837329903f9b2d7379fc54e4d03ba8a4bb7486d9cccb1884bd9126584e54d2712df919fa4d23c3aaef6e5ca6ed005bb83323011d4d39b3bc3eccc066aa27b94c9c57f0db1edc307cdb0ed6c840a61723b6d91a8e53813cd347600a955d40a69bd10e5388c9a7adde75834b4dd161d01dd0fbc6ef98dd7086df4a804df75fe3e8b4b993f099c02f6cbc79b3674a044b54bbc3760b3d66b4f3349c814bf20359baa7e86102b16833fc72437a983075281fbf913e12d8a7482377bab06a8876ac85596bc9c1ac3b6d992685d694520dfe1aee62f55f8fcfe4b51e785d5e972313f5becaf4be57ee3854b0b93cc54d48efadecff826b97dafeadb40eb159c6e0a05d1baf84dde673293e34db52f05e5e0410daeb292ca5df1f32a9e5b984fef46a071c68d0fb80397fd03731f708ce29844036102e3fb9db9ec221ef8250c1e223c94aa3ad27990d896f68631900fc2d40faeebf8bf7014b5366af61d0c61906ade75715afeb42efe9f830db79b0c5fa544279c570ca999eba0e72a338fe6625b525a96916215308137157f2be300999824d63a49b3c68dff7a9fd173b0f557d43c32611963ffe7579d99c9fd6ee7e4999d1057e4731a6062836c052e8d15b1cc8033cb0b57e1114c1ff013326344d0fde7862fa5aa34463734b5c2a13e946843a27724fc59b992ce8307a1346bc807037aec99d8fdadf5a113f4bd5eff5620f922d35c72cad65c922797a40163968351c452fa68b2bd5ec1bae54d6140d44b849a6d1f5f2fc6454686d867191c2c8a9519c85f60f031e3ce32f10782623c38b63edef6763a061f21678f4b209b19e7469e2cd208032f881eea40dc4c8e58bca981f461082fe490aaf3d7ac3869a3f7092a6bd1d2c98448246611d50e7d199383554d54a5afb07b9edc3e5e2c31051fd45ea144ec544568661387f9eb170246049dadde9e8a57461e5d4de63deed0c1f04ff472c741f64f950ca75fff8d6bdee1b3c412c32b9ff131187fe18f45fb53f920c9dbff8bf3a963bfd618a687644336c14f4885180cda2833dd9aba0765ebd93a51113b13964dfe667651f07bb65f683ae3e83b9efba61d5fd9dd7cd30d3b43c542506d0318abc953c28bdcfb395420f721bbdda3391bc1134d33381eebf5cc7b7fef86159f1f3132891b95e5888848c860595177c4a2cfbc6f323aa33508d314d2dee5623dda8d782f313dd1f0e46514b6ce4f1069b5284572ea26d88d2c4b53156aa04920a73585ab3095ecc790b9fff5c484952f9d965a369d02cf43af27f8ce7eb36240d46bd035ea3fe5c339ae3298e65cf294003d47bf8c5d1e06c47e0665e823640f9ea1479adc9887282d1e4fbb7e132e6bd70d2f5324ab422b81d33256d636b7dde6558e1c5bb607a3b89edcbae98c7b0d41dc9ab8ce1c76411ecf2688c2a2b8e85876445dd8d2e6251980b1dfc9018d264f263b486eb040c09ab4a77096a8077b8966a14189e97a3b20a00ebdfada53a979a47a9ebcaf041194bc3b3784d70034437f85698ea8a61665bd9ea17e0b1bbc995ffe4fbbad8efc3896c14ef49a30af3fb0f8b239a5b0153b8de8b848283d70684faae72f5b80ff93489c8f6141e608adf55562e9a01c1e545828b2cdfa57d4ff989a604908094a9ce3a78945bb927a3f83544c537c388f9235c7c9a500eff913c2fc173765be8b18bb3e0ae352b831ca2e51b34740415dd98f6493b351cd908d2c670105bbb55cb598bb9d26ffbb9112cb9dd54937795dbec6c4d3cd3e9ad597b3f44526b23f5a8af5318d3d9c0151d56b6e97ab0bd37b79e8384e3a9b898b3abe30d923767f0e486e4369f76892f297969ad1da85d415cecf5ce616197f40d68c2a08bc80b291885c05327ed815d91cf1a1a07c467cda1cced1921890be15c1c646bb73dba8ad855c0d8c69483eed778b3600f3aafcfaa3b16e5c04a8e50ba0ca1e50c4d0edd32264af5c194505761e5b24e9f357c277185049f2ed114330a4409ae3919e868291a5f7f7da1618fa0505e26f201cbe539a0b0a0ac4d97f4f1b369ee37405c5699a65f6993827889d11c3531120f2a3a5de997861c0bfeed439aaa7c50842654d6e99585f39162f3da49e05f5b956175f6e528493317cf2483cad1fc0d2a59f82e4aa91446316fc7474bf5a17a8dfc5bd2259712ab6ef4437e7e427d8bbf672820fa321a47207ba67ca5c8a28380ed8c799e42f368496b07ed77c7d5d5c7db760a8b2a85720561a1c16ff2a35e49393e88907d6d9dfabdfb679d5946a4200a888df2423308fc926555f5f8a62f56ba2568ac0bc38e452b1eba8a37ab36d92b6fd5b0787555d75b4f3ca0be10ed281e1429b81099ca040ea0c409eb265cb473bd9289e90e4711ef1a260f222658c7882dd1928ef9f90ba3ac7852d69811aecee316e0ebd2c23fe1f96e1ebed1ab2d0a2d2b498e20bfad98874e1aadd7680c68afba93792814e76335f62577164d381676f0665912828439ef8c605382cdb2a13eb17f385cf74fd945fa79d25d029aa96d65aef86d31125d791890142adea7f36a8ff65df94ac32adebf8323d221568105c658bdee890e642a4b17379f3e2603e6595f5f7b0f24d254cbe30f8df134c3356a28258df230f590474d959236903b7fd86c9610831371e827a61ef2b796f0eeb189957cb1d65d05956aba162abbde4cc58e6acb0262e0684ab6b516b66a6cfc172d31f58a27e9f3fcf44af7ba6b96a88f0814fd0305f0cfc417e3bc7572b949d679f4e824aa498ef7bc2ec54239189741e2f602cf5ad3f4fce071503edfc30859ebdb52e311d5ceb9bfa9fb41ed40e178a2ec2a5db402ced1a3a1155601a6571aa3c95899d48a4b593e99458190a0744ab21a0d61653c3ce630f307438a5351fe32346d0be04b2ba74cbe332ba326f9a59357e4a17cd587704f4f667b7d417f37d64f5a258dec3f616471f54af4b29606faad14d0123d8f47fc13f83bfb62c70e3642ce309b09e44362e73f6ede480237a3cd891cedd037f5523784b7b06f137ed0c7182a53a22cddfb420204fdd02f20a00237157e86df307d10877083ebbcdb5b38458d03a7530e8cd98630c1fadc170948b258739909dac0bfaee6b949abb28ced43cf24d37132e67ccf20c51370e6b120695e5ad4622ee38414cd0697fac830d21c430e170870cfed7e051fd061a585cc763409ef4572418556b8335f65cf72f6a2013438dc75de3724d53269757d014d1dc1ec9d4a8e374557d14b14c18a54d7f6ddf316fac4f253f3868570a28cdb6446b363f3aa5cb9262fdf275f5cb81ca1a04d7b5742b9f115ed8a2771d16e996230c84809f1bd7ee2e444b9d7ab9a40cef7e2e3b148834bb3f4e3c21a2a9130163a729c098ee4faf478a62df8e5311e501066215aa583f1109410dc1c0f385906c412291154048f89bc3fd7d4172f71322b348a79b570f021e74b2c650884373fdb87a48329a24a022a4e81e28bca4ece92a09c51122c541cb9b3ca3a476a4f6b54c5c8f4ba4e43a171526c862e530a1984e56d44bcac8f1bdef46e594d716507bcf1ddbd502134a8f7e0c6e8928497c883de90e241f11c40f3c2d842dd1a689a7e122b07246713326a0a2958a4bc635733417443611e3be227b916822056f8aaff981c61a69bd4108eb4da90b9446e73459b7f6fae24ada0d0038b62fb400bda296eb4db836d742665ed182bf65da783248b0f808fcebee3393a2371c381f9362ee02ae39980cb87fa306782a66d2fe83c40648dc886c37c51ad4d6a113f1e5e2d89f58b28d7223abd2fa78607947781f12d1ebdd213b0f55bb7e759042d35eeeac03b8394b3f2c005df1db29872dae1fa795d764028cc8e8eef9c26f1a9a4d30b69c09ad8a09e0c47488cfbd4305b2fe196dac0f340682317be36133ebbc8cdf8ae322b0a89a09d01e900f60699a9916b9c78e6f9a90401aae409bb4423345243fc81d0730430c4dda2d767a6549a4098d5c91eef879157702c906d245b21047ae4bd92d8c3e799ed8174211a3e1ebfaa0e47323613d1186fa84b4bb3c48fb540231265d7be9edaf8541ee85b57586840b0ce68156ce7bc264d17c8db60b23f4ae46c9cd266dee071065d38774a543684e12d7229b644a912d0c4bc44a092187b3aa05d75e5d0d37dc95a6c6fec069000cd4ad7723d93ee0c1e145378f343ec031e5815e7f7cba7435df46516d679e3d926c684f5a1d09a4dad6a43c06b566430cd6de79233318dee97739748c5b66ef7c73349b8cdfbf1332904114b52f7c366cab201873c11359a60988513f02c37521791b05e6e3220284248f1f19c56e3b2909cb5a8d05534c0db34d7b38c89b64d1ccd610ac297bdf151a67f8aa88c9fe6b8f5011be534cfcf68766e369e7f3b581febf11ecf77855e1a131202b1e262639ffca4c7199d5be58638620e4442a1978adb8f14bf799dc418b7eb91c674e74dafd6ee81218fe875e43b4b07f67415041d19aaded526f2af1d6e314fba0303e2c629b7252a583f5b971320874b3916bb56a2f51114670b40aa993d7f9a271bf44a2cf79197b7aa3709f94c4c79820858f2c5ecba82cd3ed75b6d12fbfed098a6ae8f7d83e5ee20b01178686854d83fa7af314198887672c6ca2cd2bf1655de2567d9aa40332c2a519eba4cb96aa90a5d29c324ef3a765d15ac319f283af8b39edf8c1b02f03c064ff27b1cdf81db6edcbcd18b146b2660563374848a362e575d19125958cc68b1ac72a576896e8b9f4003343a812a0a87b3e8798105a485f99774337f84115879dea4beb2b8192d3b8129d54511021b2dfa501d45cdd5a0f5a462a29044f95d54dc81a05561181c90eefb53e9dca494e0143023a15774bffbd5ec977b1f569b5e3cad8dde97d6095049591a51ac59566779e40d3945278e2e757c5f396010953cf3666335b14c720908dc9419e5a6e4c7775bba0d47007669f1fcd3c10b91a109c15ce4f4d531ab4c508d8edfed6ea519d72eab64d3b963c5e6cded08e8ca711ba7adf6bfb14b16ff81dd2979c22a9083716a5fd044d170a88b70d746ad812c05967143df5117c4c7390d78bf8b46da27e4d76872d44cf6796d89574421a508b6ba77f33c5d6ad91b6339027bf1b6e71bfefbfe9963fb3d8d46ccb48a9b9cc8359d2c5f7bc164bfc8b54108ae3095cadc3c17338a2f3312329be392b7f51c908e4d5796ee5c9e29786bca0d3d5b9a2ef085de85e7403425b83c21f079eef0fff35e992f7f1cfc62be963fc31400f5ad2d57313a26590e78f84f6d8fb9ec644dabadd205564763d30d3770e04e755bf211ded6bfcb08a4adfd595e1faa379518f8045dbae505170e274b62187af4126a8e138d8d635dd81dfab66f68eecde366457c245d7da52598dbd91ede15e8f8200f4901a033a03182b76c5809ec880dccb948c54b7a4b8095fcb0b58c13953b563c06a6fac11211f9d199c052d7b9494498f5ab2ca943da52f323009321b3f17f2f9335f9f153d54323c8c1a504d72c8217ade1734ee765db5fae9fecfdf2a228f0f65cc0ddc28f106a2ac652ecd1331265d4bb25fbe3914b4299a613018290901f64b881cd7f47d3084ed73925242e4658faf9ac73fbe809809746c17ad492a0a6d34153a90ed0c34b87482ab20a98f583383ce9d6ec40b5bb9b6d972532b61d4aaf3720f9333b1290a1bdf1801a57a798ada5856f4652e2c54a2ae23c0e124f2584fb4fbeff134a27446598bb25d73a635b894b7dfb950c69d3841f6cfd0e49ed36a5e80c473c5d637ecaea2f4f13f816c304c0f4eea5460664f9a7ec2475f483d54dea16b966fb3412c8b6ce86ae458feb3a84e3ce3fcf65d25ddef571507f4ea25a954bd8dd080a33ae18837bc873780e4b39a3b8dc1afcd8ada5d3c32e155dc1af979e1225b84488c9cc7b962b62fc8256cb333fa74459b6a0a2e1498215b0e813b63783a2c6f0a0b40e498437b68be229df3be3e92f218de74b195321cf90a3bc32e9a0aa7cbb0deb604ee4f3ef1df12aa2063352e9a80518d8ab36b7c7e230b09fffa40b5458490a3fc813177940bf52e150407820d23599d688fd1481765cb9ea2b1de4549cd4637d98caaaf53657d9c416eb9d59708e863f8f4af332e1dbda12ba882b3e3c90464f62f82b6b3e9ce8cb998ea5d546d57b242658acba1fb802a7999fae3c679bd116d132aaa2d5c4c421f07ad51880c3da8c8444ac7aaf1801d216bd3c184af7de94736afa1e22ca08801bceb65b977dfc9ae630fc5be057480be55e633a0535311fd30bf3570e9a6408f93ab085f467d46141811b2f602bb4d52e7aa498e64495da2c52c9014908643ce0f36ae440915c1e832098c804a3443142f2855f7b3a68aa04a8d8dc47d8cfdaf76cc97a07fab7dd7ef818f036802af2bffd9e208a2faa253eb9b1907f40eb4c6fb6a5295f7e4451acd615546b214083ac5370f57fa8a51991c1b5702b740035770c04335a78703fc5e590bdae5e25d6291214dd7626936a0b92e31cceca6440a79250e6641122216a8999ec04045555c2549a2f4753a5f1986e44b16fa8630228d6178cd8b80b10b0921bd75f4fa3bd326a8ec513937500e7841f3fd47a314a825436e074981ee2677a8a3f3665e59b945c3b4491d4eb9eec7f0ea98d34debf1fdc2a32f944074108826902f768658c7ed548054fde4e130f73a7bd187589a315644ce38eb5f4d54b6a5a06c226fc63184883d866cbd6b11e6e51d22319df2e759dad805cd9dc4184c8c5a12fa0c0313e18d672545cea6eb2922d6136fa39c344db985e01cea9e425b6ec46873a34453ca5a6f3c7646b61b7ee5115cb25a7c69c1711408d6731f7a47edd1d28e9cee2fef22840571dd1711f39fe3027ee60c6f973ef3da23f31d62a00e8cfdf1162bc477daad5b65fb337ec450828c8d071c4cb65f000943f71e5122bb6bff1973e4c8834de210122538d87d90a33f07e30faeb7e4f6296bfc6684b39f728367304c7097be8cb0018296ba95e9d8ec70370b6cc069858f2c05edb5c85e519d12fe8d89a77addaa9072044e7b8a00879b019910a1ccd4b588dd6d538a18fa189d5c0f68707d2e848c5cb5973b76f06a64ac7286ef25261103bd0cc5eb3e61d81f46b90f5832bf1bcee5c6dbf54d52a5d30c706f70b07bb64f4b99d9494c198133545ddb512e31eaf4afa7612fa7832672508899e8439203301f01c00ee77a42bfed9d7537667bfb53c409a724681f9bd7db589c022d57a954904a3dea30c26ddb78989bcac04e49ad555ac0a6cc0fe58692c211384bff44cc9d726a1643c9d54438b186ba3302e46a8af1225e012a440a4d3875c6b43f4accbf7b8625dc0fe405507a3f7d103f9586a1ed832c81ea2ad677f5f8d8bb0969dbef30ed5c2d376e5fcead6ee82197d8236c51ad3f63f78d3275f7459cfdc18338f680f876b6dbac07cd9d092f793e10ea3b6bad9c1fe5c77e685306695bd4df7daae69ea213897311a5a4f04aa7c12e4140bb9b2fc6d8d03b0b629bf6d4977e18f554dfe540d503576910239f2526b861bf55c1edcea758e51e2bee512c9083ed30fa8fd7329faeecaec093c7c2bd59bf2a51d17bfca946b9039d1220b391d36b22cac04c84009dd78ac14a31a682aa5804bf63d0b7fcddd836c995ee60b8bc2e2bc7e5c366a018bc464a73618b46274dac9df36fd459ec6c8f881e3f29c5bfecc5013ee3535ae1e58196da4cecb015a50def10d707ebb83e3de151c289d4b45f2755ea3c6b6ff3a745378b28b62b5f29decbc845348bef632e7bf060e1a91bfe169b1d9751665e1c4b4ed43cb35f6e23e03a68c04b267c5669a75a2ae85de648c0e5834316497f54a9f83488ee004657278bf0d960077a4313751d5e98dddf24fba154162102b95027a746cfa941625f11ab386ce2ad6c353a6e4f715e590fb43efc9a72e1ae10adab22aa8c74e0baf65228903b0822a8402","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
