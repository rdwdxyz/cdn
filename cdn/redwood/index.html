<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f92dbbc8be3bdcda6ecc5b80f8bb4923ca3f3f36d183ed1d7805ee96a32eef9cace7476ec98516219496d449724a93b9ae6278f96bcf67984d57df9f3e2c8e75ce013e374b0d177754972df08bf682673521202b8685aff3d4ed4ffaefb7fc16375684610b92f69e9596ef783ba81d5b049614224afa6f533ff9e35643f584b4c57218966c1bbc5e06fb062b3eb41e876ff36c31bc91701c18828612af1964652f8364926f8e1482e398af2d71f497924014bf36b611932e59c480fd5535b8dbd36e9e50e94a9099ff9946c9804aeba4d8b814f7332c461fa7f9fcb06df97b30442cd10c3011f5ff1389c40d1e7fb366f5a20dfd954e77cf8c6355cfb87de6eaf718f6ed1bf93bf6544eadaf88bb9549e087dcec32ca641bac112432650d11581441cc152271a97353700fd25267cc0152baacf71640038d9e496b20ca0fa51f803c83a6705b1ff972dfbf37eee1ab42c1973919ab62760f4ea8109b440e007790d44f2e91fecdc8f7ad59e3cbc1fdaef0fee5b95919184fed53ca491b61a864bf166cc7897cf38f26609b41b029493394094721473345e0d54f3afd03199bdad2234813290ec4f62402ac9a956780f82525bf9ace56b16317ce9b8e2a36d472ae2fa3e1a608007556f8b2ad2853d8a26b21e938b51d22650043c97c7a45de1d7f958051b5a46db886c4445e52924b06f9036a2261823de970f889cc6350372bb99f13f416b0d67e26d633dcb8d3bfc81db214684a9f3425dd70233744c99525098dd247f86aad8589e048d4004dad4836d652e0f30fc75594e4a4caafc316dee54390a9b21120b60fc67a75a6cc020b1be6ea0b3e759886c8abd5be561b383c7252a9082ba49511b92a402a7431d609ecfd3742639e0bc5143ded3f5602a01e7e28e2379fe106c61e87378accfdffdb83bc743cc928c4271eb35dd3de2d174c4b13e29d3296621dda24e484206e3a8a9b9c5ce807d2bb7ff01d9a95fd282f1315fe6e4bfb2cd5889be23b87fb36313aeb50dd65a143792ffded007789761638c36db2b6a90a91146c541c75ca850b6f766d10e815c707d0be271a1dbff9cbe88376ebc9fda3a08bdd70dd4f91df7dc209f9d4c9f7a9870a4910295f57b462ad1b2d6cf62e137d2f9cff469cabacc9cea927b1cd0585a2e875a64ff332f4373321d94e611bce0c498449e18c76fa444e6a170510a5f698d64b1d6c816981812461a46ce17aaa1eb4d2fa326b3884f35a7833801d4336697a2a9b4b10fc8ecdd02d4ab24d2d522750c0849a6309e7f8a0dfa10aad0e59607874eb1e53cc79e4b5dd1acb2926e28c21f4538eaabd9eb1c6bff01c0cee612bc719fdd45203a52330cf974f57d80442e7eeab99d21294281687d2cc3e7dd232454f3f60e7eb047380fdde42d0e1c185cf1e1a36d687939c8bc29bd3e61513197f9f42c1e3d02f5e74d1fea36498953d7645524daf36362f0bc8cf3c3e778902f18c5a664d33910025df116bf88b5adbd2fe0904ff8ebcf9d863abf11e718701e3f74db7688156d59fb908110754981f7e848fbe6b220747e267d84db50c6ee974559903e0ff95ca14993a3ccbefecb543acce43668ebbd6d0e8fa7e89ad4e6aa7d0ac8128722fbf703413e615bd20410bb09cc7e1116b09b70f49e171045e03e5d4298300f8a1bead0baa164f3c6b724842f77f8a5b3b42cf5803f7b74c9fea1824839fe3e370534307735795016c046302c3ec6b609695cffe254cc6241678d2af84bea43507090b1be6f7ba06c9e0711d17e34a68575e623a07fbb3c655363dde77a4d9b9c30f294490b8a1031f2e962874038f9915a78b6fb57f1d3b6fd901bf2b7d78f9e6ddc566547a1fa2f87fede506ac2b926b1675bc6b0da99c25a9d2a27cbcd54ca13cc679ed53440c36cf22270d723e364bd2f1b69ee40b1521c8e28008e6e4c6ed9fbacf4bbb826b5ff47185f5497f3f93dc73d66313ec6b530d85ce7ce77b93ee31ced9edd68a1568351f500078b5db70a585b41b971b79b18163598b4eefd0088b66bd5bab65db13c5e5b55eb2c1a46acc62e8b4b8d034e8d3d6724dac18aae4864a8b0cf3b6d5cc8a0aaf5b7fb033cb0e8359593ed238751ebf6c652d304f4baeec5036d26d5c4d00d87e5535cd0fafa949a7c649ca8b1abc8b9859fc262be67cf96b870174e99af920d37acd246fc8c1d36029975fa27f9547f0fcad4e382f2ee589952015b0d81bc1f96013640f8d209a68f7a4c773678072d2060838168f2e5ec9d2c058f212a0b860e05145600c7b2a8d134a998a71dfb64982f4a76eb81e78ffaf3fb175564f977040a8986d2a8966890a01fe4d157867110cdb22a058f9bc3a2e370df8caf3e47b219b6a42a945bdaf765457a04d7355c0f21bb72203751540b50c6d22a2c707f24695491ea43de4313acddc1fc173d3a64ae940b7695b915bb8418108b5c458314e9c495da7ce9e8e3ea8711d522effde8d42de754ab35ad59f4b54e7eb002e53e58e8fdd7347fc0a57e407f3afd57b12cdca9b00cd99a3c10c11e2db883d9fc2b3301b360ca1cf5bca2072527e0a83ce8e1ac24995d9aaec91f345d8ee730419c2ee66a3dbdf1fde4d54964ccf97ea8707a9e35cf3e06790c1807100234337bb79d34b70ad3722bef6b41d3d31bebad85cbfce1cb882586e728888953857c0ca48b3739f765acb25fa7902ae9ef8e1258268509acc34afcd4eb2d1b7c60de7f545f3fd1c20d07e794ca7341508a3aa207e63b8537ee57e45f6b4d4ce05ffbcaf4db154c2d9409f0e80eb5e36a9c7079c46d9d7d84fc5faa843b1edb3e11e1c6e6dbe9fa00c84b6adc39eb5184c5199d204ea956e77cd34149d5dad54809702b804134464c9fe6fa80cb765f2f4278f3c7dd175d7fe7f14c38b727132b84a582a8edcf8fcbdf484441a25477d98900dace754d2d1bb400b3f04363cd04d651a37a8aa88a36247e4385929bfb6bdd148eb3f2c531cfa3fcfc58417864265bebb07b54939347f6e9d4f522dd53773eb2fa8fc43a2065f5be10d2f36cb28121475534240e89192e3925259d19fda259b0968e7129c249d8920712bf3995021ee994a286d4bc72309cb2b0807764125879a36b823a3cefed45589c3ff7ae8f4c883c920bc633cdbe5d9aeb5f39fafd3b5dbedc00902bd683423bd68a76178528bf928fa04ea393f0a3ad9af7eb18416630c740aa45df2ae7973a788e34f4f27b6863d85a12992aeb601394d46ad9755647a5096f80da6ec1f8fc2bc1755595c21c879cc8bf2cf529bf05462d7a3d36965062f8e4ae111f469432f866b925d89ee9a238d342d53a3339e2a7d8160ccaecea016aec9990e775cb5c897cb7769b6358ab5bc4f56f231bd636170a98ba8df1605b7c1f84114f882460c018ec6c3715bbd4ecbf137b2530614b61c4c05631d7d1bcf29a88793e5b5b8d3c76bedadf600c96cb7be42f90824c82d4aaa714d51d4913c5717ddaacdd3c82db3537e6347fd11fa1cf6ebbf0d805033d727869f046de082f1a766d6b561c68e195260e20848bd65a4d2e59bb0c5597167153e24e6dbfba702fe9e7eb64043e91254b0611e0cfe7c9e573174a229fb0345135ef55a1015d2d7e57c0efa8645f56acc3fe8e6bc2d6678f52d19726a8a63adafeb871b1b42283f7978d6156fe660293910d82ac2b82d4c3f15e542b5a91785f915e773045002331d10179aeb89f0361637d19b267e09fe6c85b8dee6a4eafcdaa71f4ed04a699930427f53443018e95142b0f199d7ab7a5d6cda77cf3390c60f6a6c9dd48e52ac978059289581fdb7f8b14a21ae69dfd44e59b1f95d05b8d01d06cacc857477815ac9db44f49e67dd5c84442e94554f71b6c64da78a464f675c9d06e1003a84a1cfd82be3e607d419572b73ac70aedabd3ca66dc0a2fc4ffd4eb1f64fa64a42e2dd642d7f9b880e4449d416f98366ec737e36845b23487964b7a0cf9d7f9388f05b35f1c08a0d0a773cc9af3e1b505b6d95da96930956c00c603137ebbf0b5a441399cfb609e67f721224d1ffa9f957ceb7432083051fa0c254b5dd5903ab543cd8d831ea2680d1e98466fe2b959d27e68ef17d564fb4127a2863710a783bdcffdc4aa2185c765c2975309beff6866d1fcaadfbb07f142efa5c6f784b9515dd4cec2f408ea6c0062f9b6dabd85c9d1e3218472137abe93cf5fba31c9a9e28c1fcf5a35bb418b3c3aebfb19854c5b7da12b6867a22f0d7129b5a637280f719b9b864367689217a8caae548c612b089ff62b2e4cfacea0f8aa8e3cd46e3271281eb2972e3ade5533a16d796e7bb6d121b92b569b58a8128aa3574d62c85a0612a4aeb6f9d9c38e3b4aae57ddaba7976a5eedcaa8b5748f69c935edca296a7924f0435438c3e847e6a93d2246ff56f8f1a76ae0d66809936d15646d8a7488fc0babc1d092c6efeced36f6b93c232f5096ec5463607b3a224b2899fc00c804d741d0994390edbf4c387293dbc835791f6218c0d0c945f8a89eca9d3ca4f3799065ab9c2e62d540d87d0cf7de4ad450cd9e8ae9fdeebf03dd4bab4bf32e2bf8705fe12684d09cffe98ea31b66fbb6d1a683fd9c1931a378f7fccc87814d72e8cf6e4509e912bb1cf1eb8e54c96e8fc6f5d68dddae0739bbd5e3311ebeb66ce8da7d235423cac0b2a1ccfd8b64aad3280e54d9b46b97cf3846ca3706bd12776d4966f90c6542a038393df8b47175311f04bd3ed0fb5ea8d362fd9748c2b9b5536f86564b3d017f0e74411431407204547652284bb1e2f7f42111e63bb9baa2bf9f2cf6d3a01ab130a30f35b277e02454c10f84f5d33ca06331fdf77426d4ae217d56970bbd5679a90b5b6782ea1580eebf9be47bbaba1a0b6204c0892d4c0c9ecd3d804672c6d25dfe862ddb5ec0c7cb3d7ca20605e055c181dc7c21cfee73850dcf669fdb0d660d2e33438c64d9e8af15ac2462bdf4cd7aca0830ef9adb00c542fc1a051c5e44b0e9925d23ae4e5c10186161702bab54b66eba9277862e95f05834292a8f449ce19de994f73f5e075b202ab84ca1dc3652c3ff9ec0a542547961f9038c497547daaa39868724e478bf7202f93b61c457c717d35619cfa6a3edde2a495ad5eb38292953b09be580f09f9faaf9585634fea34e43ca0d0371cfc167555e297f009c2c56e75b0ade6dc26b7da13c41d73b83355cd456b5c14949bb290537e6ae7c96c297b38244ac8642db6eb729a985e67b0f413834b08489bd6f4fb23de4352830798360a289db49398a78562243c9c1035365c92a1386f3616ca2e70f9c2b9770636e9c078ff4e2ffdd3fb113f027f1c35563445d79d78cba4e6a253d2399259aa3b088d93eb3df9b9ede7925f12dc9bb598ea53d2867dfbb519ed704e9a76ce9fd23b2ad3b1bef941148f6a5e6915d32daa280f95f7b2e1b47c5d7a2566bea188c1c7bd25a015aed8f21b7a19de627aa6ce7919bb099ea4a379b0513a6791797be2b2a90ee8f457f1470f4aba5f372504b5abe15c6a3cf4d475e199b9af4fb61efce122b83451524807c69e59671523c48c7cc1e0d9f347b181a0c592a0849542c2ac0b0a051ff43bd7826939aa6f414bf64d4bbe0b68f4ac24e69b89e88bda1a9486ab8681c10fce242ddfdd69b4c7093b987c246702f132ad42edb3150af9403a8ba6d43e6ccbd5ddae267a3b61666615874a6472a5c52fbf974581c8cd8e2bb4fbe60a516cf805d45bf62286f13d78d62b128e05544c5127fc4131259ca054a10ffe3a1ed4d3d4bb11c3fba2cf7792f63e9116f4031a1348fde7453bcb90d081408f641344d6ccb444bb60e0ec32e27de4e2f6b21c4a97c1f1bc41eea99b9554c2baabaf139dca6b5726122ba3e1fa361e436e5ecbc1422e649b1e5414f8e15ba30b75ce5ce5cc2b992c70063abd4c6fbe8805b01fe4b84ccf4ee4ce033e90a8cc1b06afc8f58b853ed49488163e2c5248173b32d96224452114d44b7816ad125a6794e7c5c14de25eb155a04e7e526ff0fcb6721ab7ad0b38e24e66adfdbbc15ed1e10afa7be25f11e65ed8cb15159ac161813013cafe6122cc47fb152b45a0a22fd9e1ce5bb27cce11b7f99825fa33a4b99b2f01fe5124b7c541d9a25ad1a44ad66f2b37440ae2901156a4383171894cccaa833e9e59bf042556a78f4fb3fba6dbb1a339c48a44b88d4c704bc05e93b015f00eb67ee621aaabcb313b7f9bace110ac95f9752f762c600daa87b2ba4254e9a7e00a30930054deb5fa6b6fc8cc4e0c95164eae40a1933f326e1ec3fdfd670f3d224644ba0e14f15ab60059e8cfae794f7c3cee44e8cde979c2d2366891da3b979bb9c926bad0d63b93ac9fa8a4cfb9f9001deb711e70ac1c833c6adfa5c70ccd0095756572cd35b318e44305854fd21ffefff41ec31b0e00ae4287c43b359e1b711ea785c9e2724ba36063c65384ff322e3d5d5165d563c38c10758442e8056228410f5080e8595c52df978d6df330656495198f92d808837a82f72af9391340b39f9f270531a4fb1127c69dd25a1c730b040b8f53048d42d78de87d796ce906eb93a6c9b366c2eedd1f02cc530bfc442c30898fb0feb305dd0dbdcb1ecb796bccf8330438c14b585cc025f695cc1ce555c92950fa217e0713516f65394f138bc57202432b54f0c7e0defea4856adf58cacad096cfa34c610e44a279cf4a395de8d2c35e02ea6359e44e9ec4b1fa01714583b5b804a426f546adab07684f0b2fa76d60905e7788f23db3bb9242c920ddd8f42c5f7553d2083a128802f5c3c8c1c46b88af6631eea3ca23cd5a6050ed1aac9d8ea0086584f54386928d1507e2ff8e13f2f7166b43b3985c6a4525fc2e395aaaa258d5541250400f96afa07eef1439891d5f73dbd6c84961f14a951ba0d84a3162c588eca89415e9c0e370ed37e4d8d80c679b48ac6d79b3049395bdf90442dd0e04223edf796396f8e78ec65ff556af2306d6dc1353fc0a4e4b28844d1686f5cf22d5022bd456a09f839c60eabf9f31af86063ed71c0ab059143b3b5eace29e96e90e143ef519628d39e8ee9033b25e0e9aee4dcd8926995fee8f4d4cbf1912ea1d5df60c2ad6820354d6a1ef7552f91017911fb47c889e9fc9741062ccf135f1b017702668694c6e2bae25dd5e5f64f5cd54e8ac393633a13cc5a1002b1f062488f57b8f03dd83d17bbcf70d0326c25a3f85f2634b6a97b196ab0640e3b8e7fdb246522748f767795fc38ed013c918725ccfaa56af9ee51f50210dd6f7980d818cc1b6c921f36cea06ccc75ee13e37f71d24a3c16d9af3bfad271081108e03dba6f515e7368d88a88d87761b66bcfc9f1b3d8387a16a2063fc0cc78b64816efb1df807f7d484c721d5f5405f59f1b89e183dbf55df92be958c5f484bcfb8709d2eb7672aa08ddd035fd68c54514a312cafc7f843c6caff2bc4b0ac271639f10e9261f30bb9c01836a4143c756a1a6063e40150abce5128263505c314ccd0465fe00819bd616b26b5b403da336f682fe8a9b5c150162c3f5eb4a45d274e1532f140ab58e603faded016654a02d01acf69186b68407bf77c8f1f0b97896faf67f89ca25ee30ab3da873a9a8ced32b2db4b640389ad6b6b786202739fea30e353c8374086ab1ef21090985ae9e864ff50336d588dd370c1b618fdd3665fcd8fb1bd1c4221dd1086c2ec7545cd3403fb818f9ca6900fe45c91d01d2f8ec3490d3971c46cc9b15cf9315756b52623534bf2b00d7b05cf97c74e420dc565096f63437d3748122ec6224130d0c744bd8ca88c9a857f7df15c772f89d02c8aaa91af8923c93f6e52225f97c1d433c709e2eeaf7fd2829672bd2bdee2cc4c9d225e9c44588edc91ee8172bd0ad9ceec3e67bcd04750f084a9dae8d1ee4e9e01e0275b7f0d5c5e7e097138c05ec9e7c23099976d9390f013230c8ce464011b9a93c8ba45309a4fd9ce31687442ed7d7f353244c324261d364bc3b1249d3dc11ab8c03fb0ad67fc7c0a1c083738f4d0e83017075a74b425803a337ed704675c47f5fc59e5d761094f6391ccd9f7cbc2bb37b40a9aecffafb11ff28c99e2926d82a71fba074129544e38b9c6054930ffd575c774e2b76e1fa1446af04eeef8e1420c140c5d4320e9fa10273f0257019103c181c5751858b73a1d1ebde68098d62c51338d45f1f7abfc3887848d428daa1b3dafb24afb0762140733edb1467ddb3412a5a78ec5d97fa22b0cea3b66e0203e086477d2a5d144ecd97c462cab0e584f9c55e1fe4ad518e88039d5a8526245a784775e8d061ab4fbe708b1546aaa7788884d2ec5aa99e464a3d6662592a91ca2d5633d0f06d7182811d552a221da180a46fd8736be4e731cc7230f5edf136cc08dbec6116e28c738fe5a77cf285e01aa8909c842a48b60aaae710627be7cfe1e588250575eef03b35016a1ab4b02a5954f8ec5a26d536d75d3756519ab26129e77b170fd30f7e94a043706ea417db0b03a7acb675c55a5b6f2a7c65865ebb6c3c36de28977a44995ea0938073980fbed85db6619ab7ca7a73ab984f70a71565cbd75af11e62a2eec0077131edf1e4c955fa681676a45c0984aab0ba251dba9b36db8b14d36141fc536a38f269317b0639f797257d469863e692fdf6ff970f61ccc02cd0c8d6921794db149321db677169824ddf1d4ba38029c0102bb06e32dc69bead65fd2d5f78988f125cd79b134d3f11885068926e889d4644fae7906951c27490f81586936ffdb3f6cde05fd65002f07060f823419f42935f7f46be0dc190d0c5205770c50f38f686307ea995960b69d4cb5b480e3432e1671c19310994b33a180e0db3f84be9f0aaed87b9ae3e38c87e9a605b8bac008b9c124ec8f054adae9a9b28a72c2be8fe21759e3f5c15644dac4df232c23efb5e130cae40d7277bbf00ae24edb49835479b75ac603edce7becdb2bf6a881274afbd8f7265b9f21ab9446b3fcc2b5d6b8fd4d267bc8151f1add2ce06262446440783625cb7533055fb84fa83b8061af59312b9fd63d0ffda9831e9707c4147104d1374afcbbe83611ce4c6db2dcfb6c01e1ceb668b77cd5a22b05cc9db868e865334faa6cb3ce8423388b36602ecd972887c1b801b398be3519e34b85c9aef6f0b134922fc99f7aa451f3294e81c63e2af3f14a40b0c76faa6f007cba15fe47cb2ddaa4c40727ce915eb7fd14b143928f7fe8146c78f9c9c1f5dae1274b88214e6ce8fc7a776dedac29a272a9e39461867293c5156fc54cd15b53af392489bac4bbfd831027b98d8bb6387892122d590b12f7e441d465ef9b055098b5e0dd3313c9be0d6e7b5511f8e838bcc9c27b4c40cbc02c43311c5ce2de3914358cc2afbb0fdf1afc56aa998dcb2dea9edcf8c1f24a7861254ed342eac0efa1693767c4165ad6531ab73d2d1c6cd132805bbd23322ae4de423ef81efe0035390152c813bb7c88e44eee8df9ba084238cacf1758a19804483ca383b1ac5d001a4158720481da2ad44d8308fd5bf8b4b1abb30c77aac8c8d0549bab68bdec4bbe113e6ad704faa2c5bbbc26f72b73a20217572b7babc692f2bb377322e57810f1cfe169ed09a0facf67a52f469783ad24958fa171a8f55c37759e508be745f4d9ec051589c35f2ef3959fde95980d09372b002c6f6585506e5929ef0572ace5ddeacc7966c3050df5e4898056ae63eb194bc5186a0de18e494f77fd975cb20b1922a8172c4981249d1dd286b5da25f4e5b4ba1e964cc769c9c862e9377341d2e34ed2bedf415269aeacf25eabc3d255b1fbc567dd58ba93335ebc28ac241c15482ae918def17f9205a700d2121198dccd8e6994021a0c104976dabaa4a2df1e0b51154620727a0dc26e69da9c35bebac35d75270a8087ef39282e0a97168a9186c9e483c296f0c6b29cb3aca8610d81f92f73185d771c17d22b27b24fec67a719fb64eadf5b6709bbdc72dfa3f1b8a28bbf5dcf3376151ed2244ce29b9a540f7bcaff0a00bb2c8d881fde21ca9a3de6da1b78de75af1ceb954bab2fbe3fc2b455aff3a15e45aba60ad6c94e2911a3306a4b915c84eae798582201b0f64656a31d19f98c6d75bf2aadcc591c0425e22261de4a0fff17994776700142fefe1412d0ac54eff3995668a819fdffc4e11481e3c1474acbdd1e631adad4707b85968ce0368c3eda38e63ce1b912fd9c8177982e78c155eeb653939b08f77346edced2cf46587f20666d90a89f5e98fb1b1da9d20e87a7972042b493a563f9ef1b97955ea3a5f75a0fcce8c6a61d47b268f55b159f36a54258f7d9bac00cb2dd8135510450d39e421c95fce17514d9cd8c11829741d7ed7a6bce446b099b8d537b4cdd8c0eeb39d83ee4b403f3fbff8f25eaa31a654d88c75c803fc417ef246d36e9fc01aa314fb4ee84a761c1611a460487c1d920a29353ea0753769f1edc8a7d44e3ef8149b7036ac9d431608ccda5b2560a2ebe04ebc260e8eeac7f3362c3b880dcfd154e165c94119862a1d03d7cff448aa379f71f0e52f5736347e89538a826d51ea9d6a2fc5a0a5ab7e83f3700541fdcb4e2bed8af90c3fa40d07e7634486df6a51d65555c3fc7d38ced6b012f42bab0c8dfc1c9d83ced6beadd31aed3626bda5677b700141df752e0dc591459367c4bda9a1c3964ca818ca76365d58facfd7cc2d0fe016823535e1b5b37c76e7e254eb2f63a449c9c9ccf83fd7619bd9c548b116c978408e5676ce3de1ef9913db3e1d8a677701c75225139938703497feb5d54cb86c00ea623916af38c790f0aaa590ee2732f7535c0d4f607ffba37a06e07be7806998faf396cb689bdc539e0ff9fce3489d904bc618543b05b2b29739525ddd14630f38b036737cf277f51f7806781894405942af9b7cba6e489b4621317ad1e241681ecb08d7700efa85f292cc7675c2aedc12fd0c07c0ec1dad04e94f5e0ac2d0851072ca339f9ff565cba63ccc6993a658cf7aa6e32ecbea9bd4a3ccb017d825d86976aecfa73541f8b378fc01967434c8f763c48c4e0ee42b7d7829e276bb4370e28ace087dfb15a03c183d16f4fceecbd5c6b5277ceec3ec12818a739b924757008a360578b0e6ceb600b8096892d4b0ea558a194076e4503186562096a7033b00c7f1f9866fef94631601f6afe5ab1b22adf9f7920eb2c3a8f28a09cfa4de7d0d75d755d6b6d3bebfc21ad71980470ba840f9ade6b4e964249c2388817c7f415099ae00ca5d0c3f5e2e54e9813697ab3dd6da95199d5b0438477840f52f7eb11ec1c3187ae20df6ee00dcc9d87489ce737180fa84c4268a4d83b8043c3a83bf096a215d239faabcabc7e2911a5d37c3aa8d58e89aed885a5ddda6ddfb79dd33947a50e9ce9bb1880c2de8a2db134e11a4681845bb035331f6f9053fdf06b646375f57a54c4c1a89122fc91cec829d946b3c5d4c59f6369770075e4b62fec70759e512db290e07da4461fde8384cff8bad42b0a599f945ed460b2f08a2c95d4c2486ff85a5bb1c43a91d19fa15d258d463b807724c37f6f80c0187e6851a8904ede266b886df8cf8193025e2af971ae1aa1b96862ce867adfa8430afc0cc747cfc3b1386199bcf5b46fb3ba5be04761aa0bd78d982a7230dacdfc3f3fe567b2003c3c32f7b6b77577aeba547303826c890374b98c1347d68223dc4f4862c28a488b1a48e772882a487bf164daff20cb0f7d8d82429be625ba4eff34f11d606b7f4497cf0319e0769a3752d6d97dc1d014e754ada402d04a5b347b46183d8f5697cd74547fbbb02abbea35df4dd583a51f249079591a23de4f603a15ae5fcad6dcde957530b57d9836be949cb6e47ca94394fbb7098fbe4c66401e8fba4d902be9b76717727921e0ed2d7319998985a68a58c864634586a131a8dc1ecc4741d23f306cfa745a8602c096fcdc8e8cdc2059e2d1ada99d2e9eb9734b66041145f90baceaa29c7677f5c69726c83b64064c5e83a5143567c632b83ac33ba166dcebe1f305ed739a50b286648c319f7a104f37300daf6c2bba4b8b0aee9a3ab2720131e17bbcf7b8d68f314416b2ad0c67ddd7b698e1da1607b91de573f225ac55b4f8ffb5030e025b167fd0396df9b2590c5d8384f6d1be303a0e0f9e2dd48ed7508adb3909f8213d014755f156737aabba147869f037eaefd255b5ec22c1a55b097d0010d42fb98bccfc4cabeefd44233b05fc37cc51ed48765fac15b898147084f316461216e644bb0989a9d53e293ef3be26c5e37ac32d3948df391b54c087d0bf8e1315cc1045f71abe2322d8241208893a9e69a3e19cdff9c0b53ac06c9bdb615b9ee67d3acd075c4f143dc5b7ecf965a188b1d6754ab53bfe71016ad81e33356a4948d8ab5b12e619d55bfd2506becfe9ecbe16b24d7b8ea63989c83353f77aefc1505f02fada6dc2feb4e245bb9ba18b6a46465927034a03f732f1a24bc6fbb4f1cfe4912a135d05d894da4d889414ae5782ee7247ba40722185f1d20bb9b896a2bcc79a5d3c1b914d2170a645d760b3c959b050032a1dc9e8c4c4ed06ddedb8dd844a791816b7be304c60841759af077176628e98150af74df9a05a37c1ca087cdc91c8dc51a39a28d35f962830848e397a0db3a8f91f5c17215df7974c4d58f09935f488ccc90ee7e44629638caa6409a206996b27712d50962b17b8998fd76a74d899df3ef24b19a2892698fec1144b39912cd745860f17bfb7407a4f085488a0c0bf8fcc8c926a3129484bcf78b98a002f2863746f71e58b46884493b339157b0d1fad2b54f31157b14eb1ee6316abd7e246495e5fe1c1cd11f30b34f2d7725724f86d605b81188cdda08c2b21cdb2b83181405b9d4e4f7adff539e3091e85873bb24bd8c7a3368164e00c7e6c0f1c15e3809f74c76b415e0e80ceda2bde8c8b8e1c639142bcf6b23f324f77816477871b894898074d511433a8a238de44d1f9d28b4b81dda3874d18e9ff6d87086fdd47e1aaf2facc006e8c924a53be6bd85f5e6e69e06908bc63198c0905e33da95e07c9e89e7f84aec10198377d11315b623b7d06eb99828d48b12c831441547fd968fae6b0c540d30306986debdb8a641ab502077f630570eefb22b080a4db5e59eeb214d938dafa65f192a708eb329a3f51f4fe2164a82283a22a2ed2be4a4f2fb90994e46ab598ee4c6c2d03ac216c5f74a6e4542a15d1e188e9a91103e806eafd09eb887dfbacd32fe5646886d9f7a85f82036bbe477b4217d63d59bf937eee75d2cca3b734993e2dd2b70e8573520e80e59ec355fcdf9e365f164a66928464f94fac9d814ee2654398a4f148556104c4ed70ac0064788e4570a87ad0687f58bf9a5ddeeee5d87bd8e8a881b15a787d29ba20b6dd38ad11c8fb2db8bfe69946636fe1ac5ac6226690fd3e71c3e14b272994b2bd732c0a33cc7eac88266055f453f3dcb15e4811344c933d819df0d33e2e1bd77bf3db0cc604b26cd8a15b3ec72cb9cddd172cf434eb35496eb6ac89ca1e48f8fec3c2f9cafdf028555890688ddd58cc0a8982f1d237fcbd6269222f987f0890611cc2a80db88bd7dc8b135512c7197b47254cdef4ad470240431d5594a06b87da856ec30c5c49d747c6f7c8fd655f9140c50bdfa52f1418386cb2eeb94f3650916a5876c6b9494e0d0fd90950a615d5756cf7b7c50a142203d4b4bb7ea39d91f0ae40d381d45091053d0992c624ab437075208c070fbd82bc29a197983c752beb4e2010d133f79e1d7b6b641192c329993969126dfd86e6078c36fa86a49f6592f8ef8038cffed880591c94ce60c947d779dfd4e115447cf287073ffe50da5bb46450b7e47d8d092f46a32eed9f2f106ecc8441147587285b2a0a87457d40759ee37e28d21a2fae47dab2917723d1db65a34beb3b80c04772725fc1ddf90983ab857ade280ba1c83405f4392639a050d47603818669659ec9a7ec3eb4330ef3ce0f400644b6c7f84d8bddb2c90eaaa4c102157be57ace1051b34d3328ef9aeb03edb109d1f1e225c215aab3503e68da6502332eb63b758414855f549ed3bb504e64838f50ce55c1920703628d71b7a3d50fb668e2ecbb7dbc8f2c4e40d7f447efbe46411ceb558a82d88c8e08f20c289218d7c176ee6ac990a85e5dceff06a9f810eebd3f9109b1bda12d6d21d5aff7a80d9f095db7104ebb8af654ac79ac1ca3989f6eb94f9f9781e73872841cbb1635de679731fee50009532e7a08e5c6a767f39273028d6e020cf67f10da8831439fd36e4b93f0093185129d4da21913dad8771ca38bfdddd403b792a5ccfdd06e8998d43354eec1b3e12e0f64a6312472b1927313d5c84657b49de97ad91ab60bc7bfabe45c8478171ddcdb29cfc7d69d651d89a79ae65614836367645b269ee58d5a208bfc14e2b7968490f732c50c4a13f05b478367794fb8f663b546213f6a2c015736a8f477d6383f868e7a0407589354855a92d0ee5272d21d1688216377095691cc6a5f0f27ededf5da4a059f60a4a8f454fc42704231476cd3c42a1d0c8410d15ec370f7cfcf71c84e3863066d0c4609d3317c838f0739310b3c1d4e0c06bac3a0053bc04d61f86de75468fc6c3eebb22fb56c8513f0da5e761939ec50415bec706796e866b41bf5d4336d3106a7ea190c2ed30d093b6ce7c898bc2f974a74f17e265647ef85ee6c8a43f4fdbcc2d25ba041fa83365604e76e6bfa3856da1bd6a283dbb97101a0007975e3c6ceaeafab47d88156c3defaa1936d1019599b47ee606da51d212393d221d01b2b09b0bd902766bed31665c4364af5444eb8fc2eda72b5526ed097848806687efaba4e40a96c010d6c8d9c156b0d5c84a155134cdeb8866a00026f1803149fe30e30b86408bcefc83f43f9ec0ee345068fbdcbb4561791ffb12d4af936de5bfa1afcc394847442fa6688f1bce1c6a589566e3c829e4b59435709c75ad6a8063c82212a5995398ad8e7d40c0ec9d3553c372b96c01722c26ef9d4c67ddf54e965dac27a48257e1395622a7f1569405525e37c801d8031f6aee3ef084d4538b7828199d6992a310207a58807a30670454285c8e4c23819139e328afbc700a745fb877344be3c8a554ec37d1a280d059069c075025210481653ca9fce82b1f3c6bc69970919ab8ebe71feea9dd5ff563c6de1bca49312d7cede7108dc12899195301ab9481ed30191bb014c20e8f376c3c5f11310f4791d74f6e80cdb53d956ca2148fb08abac8422d65e55434b22493e0516eab8e388fe40872920a9139da7d5779c800a6f775d6f159252524f4570133dbc00de868f281dd6361d8290f013be03ec2c56a9bb96bbfc00065d8b998b2063ce7500833d3d17585db78012885ab7cd8355bcc628b0d493c912caf1cddbdc58c76b72c138f11d74c0e4cbd8a6711c5799ad0a7e6fec9bf0aba2a047f63a0a38bd0be6b129d0521b825054bdae821b96e87587b111cc84554d002f79c784415c1db40aaca2a68054ddaf97c8a22d15a5e2eed9baf28e339841d1d0ea57a1e7778041c8c2103691657625badf5826c434be82e12f5069fbded61279da1700805e2864127f6e800fa188ba44dddb3b9fa061d8569081934bda8a9b03d5603cd111b4cc75c7538223a303484a0d3ddf261658cd47609c18a627acf70edcc5014b452f8b9a198217943a7012c5b9887c97de9d9ebc94a8122751b847e282e492b54a1d0a5cec9c36f32ea908fcc0eb71e9851ca2e95856c5cd9fc8a05bb52999123e12d663cc2c778fcb46a4cfabdc0ce4007412b26ade51d70ecc22e5c4e139741b9b460a3804104a02b4228e166251ddcd5b14de3666f8774c1b36a01870ee0f1da7fe864042dfde090b8c22fdc75ea83832de3ee2da86f925c760e8a99215afd5adab9e5b0a6b9b11b5ec27a4e15a643ac806586e68b538d9f30e255649f06d09d09bc3612709afe443984cde93141a51354d3ffe939bdde552a4c3cce58d79c47d80dcb7b9f946c1a3751caa8d8ba92035f9c52fe143e70f187973679339fbf231c7afd26d4d11751169d8f6e3f399eef13ab2101a313a09a5f4c56662eff9f51000ace16e1711337e7acf4c552beb03445972cfe7f49d2326e831006238b78b34030d6b3a5d934965dcbd4a4bfc3e0a6e4ee40be31a41bc5a41ada57c8232e313e8f1931903a3bd511a21fc905608375f75d9b85e0335a78e803ec43f26ca96c7bf7970a1ce4d5822fe2f9f22f1ddbae7e8f17caaf6b1c2938067dfc48c2b39cd63d30dfec25c67d2ea74f92cf1fefe8ead958f294712ebff953705e598e5ffe564f040f64c83249343ffe39f5de5054c547cfa66e92739bc69e002f69469108c8855ad64de9370aed2d2285f60b3814bc9aef4c30728a36a5cd8cd0e32faa5ae097030fcdb35007621259f3eb6c55833bab954ab96369c169f53b37e66615c6d9a96c03df7564351592f10ea3a449442ad7eea913b5c22685616f10f218f9fc3220705d3a73e7dad87d2450b6e6e5ef6f53a163252335534009cbae590443be887292461c69745364f4e4fb30cde21a86eb93f4d8f50f41d7fc88781ca2b5320d12a7007ce22c2f70fa79c8f09c788355652ab2eb842463f3d20cc27a3cd1c6638edf01fbb2efa6546f85a31a9632e65ba79dc9f3b6df2f7e39e7dd912531df6d83d01651844cf2c8a7493acdedeb1d5e4faf841e7dd7a7ec7a2e6dcd5237557243524bf2118754d70579a76b78656f56f820c1d2f290b85bcd007d3c1cfb9b154385f5da37c5332f87c887ccfe0b8db6f2737498e8918479b90e36a0466387506c613b36cebe68e46e448c4206c208b9a45f09001f09f73a4355d7446896438d1a474038e133d2208f5f0eebc3132320d6619fbb513821342ec3e77def3395a148cd6ef1fde55bfad2059c206931c2b8dc87a619b78b75c978306933e838a3759c7f1e3e89176f24fadff0fdb98c2e94ae8a6c37646540d18cbb48047cc4a64764f96848fa7edecdcc66427f76ccc49c56169b5ff2ac931739a6f9ba38c5f58522a1dc012aa0324f7f3b34518333bb944d115f57942f7301292ec1c60d1ced359c8c36b92db6dfb4c6b3c79a03c186b239a0569dba1faf6cdca894b8a96dc06298d5c7f1493d4a2d266110602cdef9ccb1499ae77114dc745c155e5c67749b732ab170971cbd8dbdbf884de96a8745f6ba49f57234f7b995e2f5dee73aa8022f530a58995b8802f1b4901ade28815ef197d6590a29e0801eef912f29a896c4958202629b07175018a9091b02a78475957162878428badaa0ca3f3d19fc2a45f94c0017886bcdde767f8c9f8bb6a25780c4f5b99991ea129c8c11db94b7902b8377bce32f5ec4c1eb85b599798af1f480b7aff0c7247b8a9e4837d967477e8142a78acf3879eb361b8db0fd77e0dee46fa5eae79ad05580b92cff9a92ed13ffe7aae7325edfb03f3cb086921a64fbdcd6cb64d84de2cfde80ffeff71ec31570e7945ac964c79f5f018e16a0194315199723de2083f2cba05eda494651f9992c4deaad79a08bbb21d2452ac0934de7a8ac3a9782367f6263b287c0652a63bd63ff8eebe190449976f5192d9881db131fd81983ad7a0adec8635aadb45dfc9004bd0ea10d8c382c8fde9f80f10c735764775a5cf1b9c229fa8417085fdc9864024d4de3f54e5736cef454e5f1d5bfa01c956886c39f8f5b2fef43cf18f268a49ecd7aa378463268ad421f9656c767c9372f14b31b3b02f6057a9218082d04e68689fc43134fe892e41b0b68faa6a99ba40866e841f958b803106a8a1dc6caf133ebbb001202e6ccbc15b369d12d0ce69cc7c703674d1c2f6f46504d1c86d15ea19335b76269e5b7b7f7d8eb3a7db3165cef572cd32aeab8f31641bc93b2e39bc0846aa0b6c5ae385a1a2b440b766a5d9089781bc3f2ba485011e1044e14cee940f6a08418cb7bb261f24d0bdcc94553d366e89c5b5615338487b6578679bfd361e04493b74d72831eb9b22897b4a8872c765e836bf3c5e4300dd3adcb9b518c227f50c2d23aaf0ab96a0ac5c6d47d6e2313c889a875aa283ca9a64aea64c37fa48671fe4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
