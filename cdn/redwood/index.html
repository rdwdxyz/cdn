<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df7c14dcef6c757faa981a973b585d00a2d51350dfbef31097fb8b41fc02eed8f166dc12f398b1f1b8ef228dd9fe3ae26335def237d70ab5f0e2c23546f76f3fe87e16c8fe93e45bd4ce7e07fb23aebd83dbca96355d186f81fc1706f01717c57ffcd772bae7d036fcf420feaf86b768555a6fa5e76b333addff8ef79b0a5c68df82065e6cbd5c79a2bdec564a94bd8b0175100f0e0316a23f9a38f1fa1c16274199f4b3413b1c98c624ab108f3d2a801a838a30a4eb5c5852858f67412985bd7e184404f26ea49ae9355c67db5abefbd6b6dce82a83e3287fd4b828fc3e9d442a522198cd12f58c82d097c04360577eb4832bc582f01d3ba8ceddef9a0db802c9d368e35763a70fca40cf56f8ea6e65d156ea967857391a6d21f912208559add1ee941ebd33df7447e2c553c857dec51d6f3fe21e5ee5975a182b937657f77e2b80aa26ce9e217636e65386c0964b834ce44dc6e45cd4a8981a8901393a00c610570d077166059fd98627b638d94c026d477bdddc3758e36d60c7f6def8c6ac9c76bb027efa4e1420540460c1aa9921ddc7853da403251b56222467dba74ac011886d6cc26d11da506f19b51c6731ed3579ad692cb94033d35351d3fe282ac643c68093e5f769de735c8546a55bfa4ebcee49398efa1e2ae4d7f67c8c993379408a99e5b33a56e6613e7959f2548f7b872fc7f5d7924aaafdb4d819beee20b931c0798a709adff3b1db65bbf5b7508311955953b29f4bdfa6218a512333f16eb8ccca8d9958a7067e90fb69b28e9ecb3c1323fa6172cd424dc234295ed806a3bd2dc26e2886e0fe8e2368e6c511856e58652d60870fe5fb7722e9f9011e27e4cb1340d5d0b8de1cc95ad08f7dc80576d36f8d4ec08e4328e68ee96a370a3e8d6ace7fec130a6bdcc163cf7ccff3479106ad4d42aeb6cce4b2e9f25912c33d8794c71f910badf118f422607a19894405832d0835e2abb1510ad1e14e8969532e170a0cfde2056236415adb928ef281228b66a98463e120cd8779b38974524896fdb09b2963d04c2892ad3aad81cc85295547c4565bca42f1098ac74901e895259ed7b3318e47b60eeb335ad67cd78fd92c30b44d85c2dfe4d3db9871a1344848630255aadbc73eb28fe51d1ec5e3966bfeff4847c4f8beb593f1af30f9a090a7a765cc177f18837cc57c9a7c94b1730e649976881080eb3ec5ee4fa5a2fa152182806d3617588e4733a25c3c5fafba75c4ffeb0d28569a28c6ca174a3e20443dc3852be53097d611d07a8861cddbe260f049b2d65123ce48a3586cb8e8e6b2465ae9355182fc31833f65a6a31ddde57eae07eceb2bb1aa6f9fa7614d41b2981de3605f1e24889793ef09dd91448dc116703800c87538869b85602c96719548dae0a8d4fa37c63e4b33fc3f94fa5d49e6fdb18c2ee8b964026e36fb1dc9b6253f7a0f5bf246c45b436a597217d09c80156328c257bc9ac9a358b4fb0f66fe2cf56c24cc3673d07d8c83408c4249a6d4b1756ebd099dd7c8effc336fe9318d66c242767f9a9c04267f41af669eff24e7db453dcdb4ea4277c0f88420010d43ff83b05531f00c40fbcd44d0a155318ce1bcb202d9994d97c33ed8659baaa90729a7e5aa04b919c0fd30cd49e5dd3d704601f39c7ec1dd592a389170d825482edc47aa6ed6d7a6323340d871101e655227f2b48ee3ddcf514dede243af238c8427a67d340358646135287811894e4c10b1a905caebb18c2571d52bcc522e443f6fa92432854c3f89549c940d175080ae5df02c861d6f8dad11945326b4172f8e2c7db53103e7dd5a55f684789fae9aca2a79f29d8946fd6588e7b50c0aa1e559794eff6770efc2f35e1ea4a624fc856c8fdfd4b7b6f470db661a1c7ff0c08077571bd8142dcac26db004abe8bd5dd2221a8c21baef08fb1e9c57e8dd222608275938cbd75437b1c04776d227e1afbcbb16c2d60b1752935dedc720c76b66c7132668537cc44b479a601c9fa142f19d6e961e506eff31627f4b1bea847fecc65e4ba151bccc6bdfe7a058ca70b7257061e2a51ff32dbdd30a3fd8fae256c989c244b4608f4f7a0493bde987f3acc17102800ef714bb66258be9097fa5e6625584a37e56ed8de29bce4a32b78632d5b740c37091e2dea54aceeb358450caec70a4db822dedc8e212b8be60a2ea73e64dcdc036bdd9eb69151fa620f7862613430d050dd6877f03f402357f24bc5334c4fb804d456fbd1881a85bd7a05401510dcb7d05154f0a17e25785c21196c050ffefd93d922363b9efc88a70f1cd3c7133c557cac88b2c6a5963c7ffa125ff2afb54ddd578881a3829f04cc9fda7cfee0917ed6f4783ac952771cb82781046384ca9cc3bf5e27bf616c24c77c8bb9a93637e4e77f72828089246479330834946f3bfe79159d4f3e4bc552f9b86c76a13f1577733f6c87ea7484c1ab01368d7447cbc4e8d9b6860e5fc60059634226f35fd26857899144b7e88d2a3214b5addbf73d8b0375bbeb5a48ecf84dceafb30ee05a8fa550e5b17bc991f3deef4d2aba0af62d43fdff061db10efc677849cbe72a0432394a94a41a83fe5de763280cdb726fe4c5cea239f0e245c01df92422d21d61acd919a6934c295af9478bc1ac81b5596df1c532692a211bfc7723fa88cffa8e8edcc0879ecb97c06688a170920365f5011686c65c14143007acbb87a9dc90074512ba4ff78ad9ab9de055f01f7533492b49dfe84bc28c9fde3a6ad34c0418b2ef2bd28baef633bc18d815b100b48337d94124c00bcf7bcf6f6887e976c91c2cb1c3255ced9e06b34947ae50949c4766aa4299d55f29b191d9ca4677f1930682fe0127d2f82782d3a6085760922ede5c785820fa221d5d9ac0083ebbdbf6b3dd8901c13741ae5b0995455ff9b91014bf9616310f2b5e0052669861f076a9ac46a8e7f19378ade2b24c688955b7a6360d982684d0ff6ea0ffaa3e3896729eba365f62a1ae12023fdf0e2aa9513b2717987543c28a9ad9a9c9dbb12f716c130c7566cec530d488e70dcd026ee8d2716e781707e99ab41cea6d4066ee0a5e656a93ffc9eec161af80cda8e0e7ab06a337d4abd4a9e81de56cefc7510cab67302b31b1dd33f51e5f0132f643ea33383446fef05163d25c0655f7487fef9ab8d413f0a40c671a29a867d9e694edf9c42862a51bbc0de53537fdfe7d087e07eb7f65a006a69883f710c9dc3f1ebe9ef7af20c16f9a21e689a9f72752d0f720dda35f910bda4dbc3a9bbcd65b04db66df4923450ccf91030d22bc8c61c48eaf89c7013db7a1325cd08817d33fb3ea42e24b99a3459194511fcc4fb717c377a4bc5d1d08af3238735caace8024362b8d9cfc4286beb49515188938ca6366428ab5585235573d262bd8aec01c877b7e412383a88895820ace9c8a5f6c390fc55f440b5125e6af73600d0c0ee221478980600f546c5d64f3cd002baf31fa05f334c1f928735037256ba1e14f8215d1dd68a4a506c1701bcb101c0abd2e8165bcc01edaa14f2e3cc931074e7f239554e586cc4fd5a5cbc00bd1293237a45ecc5717cacdbac5562bff39a24980a37b01a9de31628415b4e2420f5e5c1d9e214eb305d694c516b857bb92a1183d303c1f19a42f716928bbbc4a22e75c7d250f96f263b58b79027e498d9764072b89385fee294055d53d8c927fa9540c48aa2c51e7e5c49ac04380ab020e95a3b7cdfe4363185a3c52a3e98f95452b6dddc2eecde0bf49a5664740b7a1488d4a3b007a18e2348761b39397cc36d82270ace75367422b246e46e6041cc3342fc0fde66a9a7e7f948ebf469d252c0f02e6162c6995993dd6e97d21b8b8f4c88a72ad6afaa159898750c5d4e63f2bb84d5141199be55f8e2b91ab21cacca613721f475a70ab57a121906d643d28221b7ed01a662a7bc544ae71011c8d78ec6e77b20bed3ab57817e7bd566c1e394b3932f9ea35bc30c374f41dce0255ba1a5f8663cf31ea5bc7baa53bf4902d67da3f60ec256ae0c9b12e4d4c9af23cdbb1605e9b77cf13d834f9f2d281513c73f71edf879addcdf97823b4be8e56baaeab9c9cff04207358558028b6d35cdb622a398de9c456c0a2196d227accbe050a0ca2fcfc92339706392ed4e12ed3eaf13f841e1715e6b3869074488ec7d1a8c251e28e9013727085c13da02b38da29f4de039713cd2e0eb2320dd2a7856912efa8a936eda18447ae7efd74e0d9bfb363db62ed74c35ef90ab6d4b0c3742c81abcc5f56389ffe7ba8850486783f3c365cb4e4c0e32724632b49c64f3b8067795b5dd9a8a62325b3c9f5f1f2fef6c6613a9a8ccaa8520d51dc14f4f1dadc7fc7bff24c9a0cfa08c440da76ece6999f5e2d0bce7229e5d7ce3d0415dc3c444a3b6378875b60d7c1d14abc71ee81be7431c9654dc684162780414c2045ce24e50f80764483a1ffa3cfb4d6d51d6082d760801c02b3a3edac185d530324e3db3c3dced0011d02e2c89d76c3d8da24ee20c2dd255103e2d8ca495602f89621ae8021c5e9c89aa808f856e7851e05039a24511ef2a0bfcea20908144ca1fccefd116675d7352acc34699225f1e8bc179c9293f42fc228b1a97ab542857fc82985e60a897cccb7c62dce8f0ecfa1c2e08c54585bd1b22851510343f4eb17a3c4bbecacec1b21a55b8892f247ac99256dad4f5d384336dfcde774e7336baa78f61a00e56bb8c748143013295cd9ec8655df477c1e4f518292c299927fca0c1444829c72db2f4e2d03f3e77ea4a04d63e196de633972236d54f14edec18bfc041b2ae3ad534861aee5f05fde5c3a198f68439c6d82040884a43d4a99743240bff3caf16902272033ee6cce4e9a082127e4f7c12c583edbcdbd45fddb21f0be96e997ce0948f1d553cbe053515937b282e3b245efbc05a1a632616b75cb40621448bf7caf9b2568d9a3e7830dff37383c247db301ae5b954dac6e706a59ac68bfde30bddf62bc7066739259c9b55fe58d058c14609914a488a7fecc570f90adb8b6873fe54660c42104960450725acf69da9acc0aad8e0658980026d74a5085b796fa5cae92004f874d32b9727b00e436acfcfb507a96630a214e2122b5b01331d2d2f9ac53b0c19955954647aae30c0fce8bca26de5714c21f3c49a196a3ac865ea56beea60bd965e9c8554adefe6eee61b729672925a3b181ec286812084834a911cd41e93ddcd70e40426b7cb48907d765ffc10e17af17e73c96afda1fddc88cb11837a4d607f4561cc58907cd8f5308364ccfdceed006a14bb10c7b5068dac550b2d85f873a8eae8d8fe157f3c823c6b6a3daf1a16247d84b6d630c99e0986712e835b6cf3ea23b4b0986c2664b349297b99a2e1b065bd76306fdf0acc0c1377d8d10695631995152df0a9703f95c9a9774fb71aa18bfa2bb5a23bc9b7cff5400533e92dc7294c0d7f0c5c1674ee7562b9b0964e45fe72d8b3fcdabc8ef17efd7d76b2dbd9c5480e2d30e1af802bfaa9b073a660094a39dd13a92ede7021b0266f3341f5924399bd0b1cb3185f8cade74044fbfdb10df16a40926df2cfa12edcc407e5ebf0e12e4f8769708e943fe0e56ec3e2c7fe2409c142372b12b252893061278738fd7d19f647b389607ea467d5d60cbbf80e92f9f128eb0fea0296ed15f814c8446ee76d3bb2ea6151a7eb07dda28dbc487bbe4e27c3cdc717a774ce72e10dc71532a13a86710aba8c02dbe4686eda74a7c52e7fd84ea84e0d95d52e9067139605e317086809f991c5f8865e86965c8a45118fac7798633465f35c6651496cdb1dcb19817e08b2d535b829f28dcada43cfbbd88f40f7626220c53fa5491c169d5ca86cbad7049c06534d96e2b9cde4a0ae433fb970a6c31e1596cb777453170eaebec13ef13aa979169eacc56a0606bdcde0ce87420920c0b45fbe702ced14b444d1bb80a146aef0358aef5567d5e15a062af9e1efc45b465b6c00ec8406a7bfcb6a955f9fbbf6b67bc9f9ca591d97345bf7a2cbdc2c7fd72943eac2c4bb4010f57eb99697bcdba8e617789ccb033843ddbf68946878c13b620585d9f9ce20f8c015633bbda361826c8faf43738c4a67d5a3dd796fb6f8d47ba484ce8d44e0ab1fcc77d3e1bd807e564a3809a565dbc27a677fac0df309b22967a62be5c4b3aa327014f03e8dd6ce82b2c9623e0c6f3b1d2b0b8cab260e15869fe8c5d87a06696c3c3f2a0ce2b057611ea7d4a466f685f65eec872a69e1ed724564224b41bc78b1c1ee4303952b3bbd0d6a67d0abb80bf37a745d162a0ec68688895020afb08f0219c17bb3d18383daf1000238ea3b3e02e51405f0ff9f6a84058bffd34754793c3010b58d29b13570e20d9599c452eac2c5d866d0e48701b70afdc97eb93d237b22581e7f21c42fdef08cd638a62b22822845d1f7a0718654527630ba1acc5f870b188f73e8d3147335acfccc279ecb8f794b0cfc96eb03f820b200cf693ae21eadd25b07b4b303471407830ae7721d6f0c7f83a2d0f80319869f72c6f871341caccb9b1ad00fea80993f5c41415d30af775be2e904d1c13f9c4630698db58fe31e3eb9e3b851e6678a3d930a1df7f70ab42096d2e12e2b7634cad30d1e0177e6ca8766b7c2015372668e6723e03a1691897373b35eb2531e2666d03c2e5ddcfe8537ff58874a546e88fc386a1bcefcee0472ee241ac8f657e9a2c2b06ad453560941857548af2b92a0aec765eec9592534e46ece982abb939a11c44b4b7e33fedd542b60c6980168576d993e13c1245404ec563e4261a55271a3a89cd7de5cac28b29f7587df8710c4beb7a68cedb1e26306a84a07e562818092048bb42d790ba8dc230229bd0120f49c2dcf417193691c6d28c83427720dc07c8397e0cc27cd8bdcc3985d87753c6267f997f60a00f340d94bf754b30855618b64f0678c190d7407240e052dbaabb354736530c1ff520b9dfaa6bb2e301c6b0682431def59410da696fdcca18d0e18a2922042a41d667bf72dd5f1dbcd6988d235e913ec3112e02512e9fa3579c44cc7049482d8bcac8b51ef44be9b3ca9d7c5300767182fafb082aee2295cacf929b200242b8ccad225a20f91fb03db02be1b0bfd5aa7413efa8baa2b5ee80904313c7c2ceb41655ef3719146a6675aa556a47b3adc70e5fa37e5e7bbd68793f2105e6b6e8e3bdfbfacc32d78bde19a6365074181160dfdbade8714e51b73ec130c2eecda2e362e9319125c4f80572c8bf6b66869ad9ceb9c08ff2f5a6fc9dda4f3b67fcb8ddfafee48e67880b2052c8e396994294286f85029f8ef57b53994b8a9c53f00cb539cdd33d33d25be90b5bc0a56046860f8088673e7fe0d0ddc7290c9a98210e1d379ad45abd56cfd2ee31405e1b6a77dffe7e3ee4041dd4ec446e23a9c30ad00c9d7d019a35384d013e352d2896dd521e212067af13fc15bdde898fed3accf89d022db8e7c9d10740ed21aacaa041c383f52cea6d7973102d1e4b84a602f1e47c895ab7ea60c3f1bc00a599c208574b2fba4b477ff3c118036d85c2e3eb691f914889dc0117df63b4655a9f711a8a7a55edf89c8234ef73920fbcd3380bb628c0485503df0c38c8a0eef20011033478acf0b72cfbc60d4802b4adc988a05eddc01be43da91007b6bad12ae469b1746b015b378ef854d08b2b3f6e20a58f83aaa5047940fbdde0ffe8f2a973b93d1385018d21fbfa000ba1829fe3bcca5161d9ec4f7aeafd81b22ae6f343821fe8f2fc4b0ce37e97b76a4fa59f31c0b3cf4dce02b8236d9a336edb666a392ae6e8ad755651b6c673c0fba23849e07c3c9d95a624ecb07894131b6f111398a3ec198ee67f70d850c7a7db8c0a8ee037378e895d553d114f561864dc74ce0b09661033f6734dd1985ac0c1829971ae9ce189fe9332ed3d808e4b170170af98c92c6c04a6ab91336933bcce5bac9a5fadff6d4b0ee684f49126bf76071f7dff0b2f3c52e60a2518aceaf09e3a62aeea35f2f5d318d4f7e65f7ed2e65f3e5acc0e16a11eb972ed8febe93345cb29ada4f268f008cae68a9b7790093543f0962187cb489be1bcd3dd4e4e6822c7bd5f69ae77d0842070352b5281afc7043d9bf769e24d7a01f19c9e7abec2c4a99b97796daa60a8e2b7e54673541240eda807e6e3dbbbde6c287b38ee55c113917a9161a31a39891f070172b3088551b4038f02c16224f35c387992162a91c8e6b7a791430a9a13dd0d6b77685599593ee998a357763aa45d6de27493e8a3f8d39a64c1afd56e598d34622793e331491906e6ed637ff470d5e2c8e203642c07e1c38471fb811f749dbb286118e2863e5d1a1be85872961d1ce302f6009955f35bfe5bbc401c95fe9c55247fd25112f9a00662169ad2e9f8b03f6e82aecca1359853d6ada1ea76fff588dc5af872dddf2fd6184afd7bdf8146ecbcf0d88bc73c57ade2991141b42eca4c5bf3a5f97df0b74ec80c6563d33f50f8f56288c4960093abce35d9b8da93b1519fb1c06d8c12a9f58884a8aa35004c87b1c940ae2b9fcf963020296b91e994e318240d02da0b9dc43653beb4ab1383f75ba291c2a57c49d2ce21dc4db0c005407160548a6c7d39f8b15c44c0795a4d8046c931753129b707d65521c61966321e0ccadd64115b3b7c1b859ec1adafacb847ed7484173a84e098aef23409b9dd15301cfb4810fb2d0ce8399dd9edb17c6ed4c06bf6fe174a0913ced71cd3034d2fc976cc25cbdaefc717efee1de83024e186790b7b627bb1dcc146ca72950a31f6dead8ad2ced2fb1a3135a39e9cac7c083b0ab46b429bb9757fe067963abc0bc7816402d905d9618f2230d2e51a147f898b6438981cf4d32abb5a0e4a8e310c0e0969eef53fecc4499a2b9bcbf14b9d50d32c0a85c9fce5b6461e0cfe3c9dad0204868688b026defc9fe9784118fc17a0b06d7600332675a144d221480a1c33250caf446162cf7f9ca6fe7a395e314ce46f65be7382631dc3413039de3d67e9c181d069c7c29f78d938c76b5a2a6d7c15491fde8cd5b2be2780108bab924db03c4ca68b7f4e28259d90509fc9c56a95a240a836d284f7bc949d1d2ae95f9607b0a13249858cd11f5571e9277862bac7c9687d185466a297f1d3d229ed353b9ac73a6ef2fcf296cfb2d042f34e25381014c3fb4dfa784fad0121f7376049e76cffbc92b50219c8c8f4ca6660e11fc915a9d77c5d1a084436b26ba63c57310ba894aaf96e514d54088af0c642596c4f9ccbb36080bbcaecba3f0394720c0668fcbb0fc6e0f87e7152f5b79afb870a0c4a798261d2c08306cb339440872e5512e8a213f013cd0cc533af77912dbea30f48c9e715104f01cd89fd955fd784cd73a6ddbfb1fcb993e0bc82285dac093d7e90efb6107bc5314b69a2e936dcb23cdc70a9e746224b046ce3c6e46624970c3c2df566efb3821034c9d56bb4bb7fc07dbec7428f7e90fcda1aec5c4b9ca22548a28a57383d0e16c3b95c1b8cbb542bfccf8b66d32e2c769b113e35623dc5f5ad369dcc9e664b4331e2cbcb66ad05392ad239a718f3e2721b291cebe04eeeb40ae9eb85a06c72996b55a4d2902393b531a4796b7bd5c8c738b993ef36a6cdc0bd6d6f215f884d3f11e53eed5ca793625efc0b8f64ca12bee935cdff67c4eaf7b3d351555843540b8d8cd6251283dc68441e92415611d225f9ad0647f914f714a47b01a2b6d55c7a3bee3fcc856f60a318e7990310b812049b7b3b0785ba1850005a9d359d4dd12222d65a9ae9c9f3cc2cdb40d2fa58ce0097ee981fe1209af0d3f16fe0373a1d0ae434e0f7f1a1aaf5adee8568f3073377df1f9b9241de868ef6cb6415b80121cf4a6cce10d235bd59be02e5ac867823556fe33adb6b7f1fe65eb7151b07a37972312d24bbc48ecd49faf8aa1ebecdd493fa9688ee3a89485b65efa330660a81d6ab6b8f9b7745a853b3c9dbbba1c5884af3f79898f5d8b4f7e55ef6fb996fc96340e0db5852db8aeded5d17fb9e41e5112e1d7419ff2c17f84577d1a5f7122431250d08ab87888146aa6482de36a24064d007ccc1f5ec693493e220bd692c5d8574d4687383702aac94e94299dac394cac775beaf4e76e544305296c30df8c3374e742e24b1c91ab7cee6fff9aa8cbd4e25f6f7bdc396fbbdb5d8315947f679f40d44e1156e88bb2b4b21ab6d03ad956f1c6433fb6d808c52a407e6a280ad0a6271b1b3387dc0793aaa7efb5b056b7df169d206a8d61e5076d72c1a02c2f8def49a2fd29160098c5e9c94112f2b84b0fca1b1fb671b40f07f92763de5b1564fcadf42480bbbaf736ef31d696724d9c36f96ac56f6d50b78c883e3ab55d9c6514d5ae8a418d49f15a3610e55d3cd10419bc8e608dcdd3d252d8bb7c77fc313b9fe2b0f368e88041716393544320e6d1c50dd3f8d02870ba4748204bea71683a0a8c13d283cec5343f54506115aec23e1502f18c0cf1627a06a15d83bca28a1c9de8d493eea907c6e3b8d9571cd36040de69077f0226fdd6d7f2009f19ec56990fd580cdf36c771353e370733149415e2d5f99e8886cfaa933d180e9af368219619a4fb84ed267eb9f8ae6423db2705f34130face9fa3645b5955281ad4068cf22cf69e5976ed6f66af48ef008ff45693113451390b231e1c1379e9e23345da6fc8258b8ddb35f62d97add3395cd07e5f7a14f374fb65682ad44503357dd082b98da95e1698efcaca850a06d69fa75520796580befa0f9948b06838faff563225ff92a664901162eb55a81ec84741af1cc2f85d4febe722dfba4cf71b51a65d75102e52e34f8a85210f566053f9966c1e62522ed99eae051af452667671df99dfb6bdd593a5000a450e3f5285e3352278a1aaf2e9437d19b59775f510f83c6ccd16ffbafb7915a8fb07844de48ae36aa1a28c70963c28c9ed5870c3d8694b0e1326e26d11bc8a3660c189c772fd857826db9c9bdb11f689cd1c6aea18b19a4d1a18ce344d9567a59ea1554fda86bf8dce569994a56e2fe2799297d1fde497f0cc78caa4db341f3a9f24a0792b4917f6309985ae4752406c22333689c3866b37368993d291efa268790fb874096f1eac2cf1b45c562eed75c02f11375b58c9b73b8f9b1a78e871269e826aad9b47e5b8de3a181a40b8be4c14a4d9985d4653a0021e3cd0796490d8560f31e861b697d3a071f0c7c0d1a0ac847ff33bc743899a5c6f3a4a18dbabccf6754ae601feadca206b355f921bcd0eb2571cbff8ce8f2972faab674aceab9680735e26b86b9fa4e5611b9d2e44dc2e4f54434b4d8bc776a2f18bb5f05bac80ce691b0259c3d3d98c5e5f3bbc302d4cc9f6b8a39cdc1b4f775a351c4acc680bd6d78b01f115a18c80585f45ff9b61a044bbb8454e658ae9e43750eebba8118d5b7952539cbcee8862a10429d7920e033db61d5ed41f2bbc81c00868633d4b8aab3b388d41ae1d784423675e71b9135f53437e3023bb04778a2bb130fe4875bbbcc39b0cc292118846da45e1caf6a6d3aea489fd900e47cbb82b1f094086cc5981d730bdb3880f5c370d8adba0ace38bdb1183e1f8b85d809af382f566b43e2954141336f1b37df4ef36576e56918333f127b5ad5a1999113a8b383c080fdf9d4af1fb58bbdb47c60c1856af0ac439320b78e47d42226171a3fe77cf0b7ed0a146fbbe93199daf3071324928b888c66058a3a5bf1da326819ca84c1cb078c24e58e7ecc8a16d0fbffc8dcd75f0347b5e706715830a791c30215982f3ff38826a5141dbe241c49da3771fd9e9a72828033cc99d21702132c52ba48480c081ec08aa9676859d724cfb52d20b4ae1f30fe8baacacd94154641a9530320ab2996a74e902b113a33b00133514331c326f97213c67e79f67f4d9a806029b67064c7112b6579ab9ce6e5702f67be23ca3b4434a63ac54b567c925998edd0c547fd9f92b2ee580862a144c09f1a8dcca8c6d2e120c0828ad8245e3bd82bdb14ccee1c6b2bc09eb65d8922c49859dfa9d00f2aafe80a98bac93633264bd9e713d9def9e9a29b9eea324696254967c17082ddd3c66c5b877834f7c91c327e68e6438d3bc4491d1dc482343fb7b61417a79d755fac82f936f00855b6054413a506ba2039813c5734ca20ef56bfa5e3aaa17aa79255238622755a41fbb4ddf53342e21be7a8ea336fab0677825bcac55996caa37255721057fbd86486e12c26e404a459c442e815a46d6e2d84a7bac76b2b773b3637b10312a11740e6cc0a0813eb8d2ba51e9b37b0e88d307c8883ce50faf828a2506084b92ea9c29dd3de809d10e36b5cf970f277e66b984f17f58773a58b862bb6e0cc005fd0416f39101650a19484776b2f27251ad4ab8f8f329a222c6c01b3b76d85797dd00f92c089f9ea9e6f2b04bca32439cd6551bb9973ffae3c023a8217375c4fc5a842bc347bfc247f4b98cfa9c070dcfcdec74511c5f2016cf67956519fdb298ea08a9f465e68546b3525c1a18fae84afdf61a5765c7882bb2544622212570a6485e1f94a872419bb3b7c653bf51ab93585cca1e8d7b3d3242ac4343d31abde6940f6dd6aae47df444dd7fbf11f46548a4e5a23736fca13cdc06f56b5603bba03329087c48d5459bc68eb5097dd79dc6485fefa44741d94764b41672ebac75f60cbc5d94987a77b2c5a121cd6cf5b4f70aa1758b857ba9b5e3b345e2a6fb3dc87e218968b5186c8bb278ec77a9b6bcdf952199906de9347a1ba1360e34e9f9438a150bd98a9d3ebf9272aea1b550adf51169cbc62862577ec6df58c29a2eebfe51a5675b7c192188b2b2d722845d9b0e658b337a6eec2fd379251e5fad83448c96e9d607a19b7058c8447bcd7291987d747bc1395b2183d6e4f1e689d54bd2048c524b6d1c9e94264b403698bb53dcd8e76065e83c0321c03f4e32b1ecb7df399c2c951e0629c2e5a949839a1287efa2f73a4211dc1750814172b36e80ec26e8dd16bbeca2c2fa72b019d808deedeac3d3f4aafe2f70c42014238312b8508f46b8e6ecdc0e85dcadc34aa03dc54aafb0b40e8ac0540a5f50269190dd1fc5f84762532e1939947c99ea21b4c42c3c617cdc6f1ee55d4ca7012529159c2d2e068d0204cd8e4a424e1746a4de851b55129f85461f511d0bb3cb6328e006fe8c15f1311e9b3e95d2ed5a679f0f20454ee38a200da397d6890ba99befa71f3e8d81c81178725faa29f2bd1aa64fe553c5684c3e2aa91128bd4fd402049b1939dab43ea1f88f648d86e19410fa464ce70110af0769a5571c12941ce896bd5ef026dd781166d5858bc295880162202529cf1385d65dde5e2603e362f6306e8da88a8f399e32610c217f9c576e0a05a3e79d0cff8e29c48fbaf01b4cab00b203afe6ce9ee54e772e12097ec4f9dfc6f7e340b93610d359ec30c1c52e66bb864939b638d79468696be9c31ef4208a521a3815c4f9c0bd07e331edd420644257b4cd1b31441ead4c6e01ee203f0d14259596c698d0e1f964e6ebad1b126ab139da0a038f4af4dd1930343d8c554cdb1a693a35755f983cd61c0847458fe803dee71ffe4765631915f95ceb88933d24d8bddecf74e820906b1f1066214f7823154becd6da8e37743ff22df2946ad14c9e55a76d283b9da940ed6f50177e207a442acdda5d2d7a82e13ed5b9e8805c4c62d57183d33610230f8fcf1e03a6ba43d54a47e256636831a622a611f0222568af8650538d2310b97fd28219b9736feabae1621c0a9ee09f4dd86464e3b58c87ce8043174579bbed93a8d9041ee7e6a48008be951224815ae7ce7d11f5c18b8c208e5af6f70570e38cbda8606e852b00b7c1cdacf60467214671cbd03b2ff087a67bcd24bf539e5a81e41d7ab7971c375e560263b7c56d9cd0863ee07af521e8ea586b2ee51fc37af2f8a411c48aa738b9be519fcf18f7ed4986197b159b9c9ff555efa994c3cd81f03fba014e7669a4e12e5a86a4c71ce13f2010b4325d4736a158f13cf865569aed7c95cb8b082a6f7cbe2a93bd73349abc5a2e77692d33ddba9b5e469c763a10f23c727bf68ea7416062a5ce0cf51175acb0119b922d5b3d6a4b0c0c801b2d9dc97b4d27f07f2a18e81b5f4e83b42b19e1ef526bc33717a1f6b769cfe524d65952ba5ecd153d92c9c3faf9ba33539c166a2c9bdd1e800d31751e6bba8d2f88253a796abd3b2cd5a1f1e9160c3c2b6f7b0e98782dcd7999f730cf2c30bd5bbfbcc2180582a1066b7b51f4f68ac4f949b6c3278d51da18f9ca9b7d9dbdc7d46c361cf70d6dc18b6a146afa3dd0356a4dc171bdc634986a15e0151291e8ebaf985140792d166e6abb508cb8edfeccdfa26f240352f8b3d0e7a02d73d1fb6537370234362279417d40b91cd39461107757c35950f374185d2a1e267e13b22f0118bd02fc4f4249501a5ae9b4e3fb421b8df1bfec3207ad21c3f94d6879b1dd240e673e6d899ddd8a67ffe0f035b964e99e3b9eea7482d00ac9f98518e6f3dc0832fe68012ccebc40accebdf32f7eaa2f0e44848bc0c6488323ccb2c192eb9634a2c58d74a21c76ada71b2c804f06abd75f2343d5205f528648c7356462016083938d19a903a62818277bd72193806cdd2df06302138b4d08d48a9ce94969edf707bfec6ac282edff20dcd60c55ac7d909c9ceda56625f2332ac022332db167a33436c95c2d813b832b263ab0660dc4fd3a64392a476988f17f703dbcf18975ff0ce8a146d17685e2600b162ab42080c74c2d0187089edc01fd0b5ee201fe9ca98d389d919e22d81155924fa777052bebd8bb2caa65626f97bdb9de9458bfd02fecb9e60340c4e33ae4e6da8839ba8f53683455671bdbedac46f80f8b01d44b65511adfd9d531c12d324570f49ad2a872f534ef6f06cfc2b1406e7856aa7fb997572bbad08381d7e3dae1e64d50b306f8cd590aac809d6e0468368cc476faea17fb9c640f912c7b6a1eeabc2e957b655013536c8c31af2f0278358a5d286b044f108e48cdac91232ebf6d40347943c19a3b3b61498fb46c608e2cef2a108e64e073195425228efefceaa249e5388b9a100116650adf2ed046c458bbf124b68133ee790db0ea08e808f854a05d5c287fa8b3ff529846c53d15638cf626fef06b13ec4621f2a4bc61153c23bd5bf876f3a8aee359096f73c320b976233de4dd7bb09629cb05a692d876eb3a841b0958455fa41e2b669c1e43666511ebdea57480b72db50aef8f5599247375a3805b5b561890bd868873badf0ddc9f4d5cd66711bede8ac5642f4c2f6754500416c7566b31a8734d176396d07fc1a7b7e31e41d9f825f07fed6cf8092a0892f96fc044ca1450f6dfb5d14f276ea9126c5e9ea4a42efbc97838710615ca350ca775bfa2fc632c66eaad1bf9c7eac0e9264cb47dd27941bbb7b2e1eac03b29f9b8c84f4c23378ca09094d8ce0828164bc554394dc1e2c793bda249cff138442ba773d09a941db93511049ff452fc664aed2266a3c13a0fdd70241db202110217511bd653bc07ad9fb02852d021b2d04ec34a1e5aaa2a615cf0d24145468dba9d00d058d08bcd83cdb4889ddfadc396b7ed3a63a6a45d85cfa0285179a9257338f28d936ca252895f3d3fdcd5edd11fb19174f556c1fbaac1aba786e548b429ad4988e692b9906e8eeadb18d3e2d2dfa1ebb3bab05d1e7eb07af9b6f695a1913ccd4348b294681fe9cf257e5cfe5fba48632b8e9d6d1f9554b5fea7c968655240de241de00a6204dec5068f75f600a2b4ee790eba8e1f0b2119d07e6af65d8cc355e13e0bbd1aa59ef09e215e3b1d0b2265e3a8eec3625b12419742ed633a8c895fb88e7f98f3eec6438172fca4ed33800684e11901a5fdb9076a68ada834569eebb1e9a9c72c5640a212dffd5b2211b72d5de751e7f0099ba12ca07d9fc18da8cebb1ae2c1551a57b1b3c6182d4765441b99c65f92da49356d51f3865765f6c9208c581359ffe06a9914b029a75683aa82492691375192f3c4d12bd41c3a957d938fa43d3fc08563023f58df3ebe52b26ad90bb8ed6045e672b554c9dae61509388daa4852c3f2f44e9240acad14a0e82bea7ac89aca28110b878f3bb7137171107ae5727ea59b2fb8e9835e529efd3f735eed9287d9fa2208afe62f1f5dcf120b0d36e5bb61bcb7f81fda3b8ebddfa6c63075c858f6552f2ba6454b9ac6b8ac95ce0eec078dd2be1fdb518282f6aa82d10de33e1b9c0e2698c4274c32c14b7ec40538a19cd7e688a54f095a7464f7b341be2bb6d524e065999abc106ab0621bf7c5575b285925c0c9d2431bd625396ce0120e92011effb6180b6deb9a239c4b8bd0b00edbb394269e699d381c06879d630c82cd0e91748cbca0f600e0ea3d6544f3cc0bcaa830857df2ed27882c938d23f14e0b7a8ac60525a055639821ae2c7b4fdeccb69f003235a636a16b1d24ad653a4c0ea06d3046ae1d66de67fdd8440159d70dc967a60ba56adc224022df857d4f3fa6b53db2c6fd96378f55534614801c4500c10c7bc708cb949848d750c490d7b8fb726b34b3d9ec7ef763ecc73286742b6b17e465089045529e6fb6b7c88b7181cdfdcd55daf66c2b7d0861265c7a0bb3904b4cff45741bd7828f64f3b980c8d69de9d27988ac6c9ad9bfe6b8b5526ca5b00496f24242a224b212f6d1f8f970c1294d6de9d571629c3ffdfc77cfeadf553213849c57f8860b86646ab44502f80c5fac3ce139bcb808935286d9ec697cd43a5ff32e97f04e6012541580f21ec91754f18331e3dfe8bced161b7ba7debf13bfdfd6e1a03c91abdad7dee45c5e23ae56f71a66819715c211bab81e3299e03c639fdd42abf46b6c6af1e3804b81ff3039bbadcc9384553b3e04404cecf046be00b88e56460c4f78c13241d952e03bbeebf3adc488daa1eb3ed5eedf1b2f61cc934b7dbdb1f03482f1fd2b61c6806b65471011129688f6b99aca0feebee05c9ed843bd62cf4ef0f6898f6fa5a9b2924d2ef91b261b1b71b8c60d3d3f846fff1d3458074471761b711d7ac74f8834e67e1c3a94709d0837421dc1addeb41e3705072d2386a7dd9b2cdca2ec9ba046ae90a940a7c190fc27709f9e80aaff9ab9a4cb48416c916c594ca1d96b76b3af694ec65cc4917ba80ebf8b88fbdd108200d9a7e99ba2d7445d8cd7e5e3f73f7c2051ff3063813fe85c33cde326f17f1ccf3920b932f1652eacfbf60abb158e208270ca1c85764c9aff29cec06592bcc2acf0d2591ace6e2fc6645bc9dc5faad459e9e04f9eb801babdb4378918e3278ae3f714b889c31440fb640ca0b0a6e002c1bee0e05e60ae4d5e8a0f9dd1852717224b87bcb683a4ee361ec3b0f3aff8e0d69da873cf9d989354e031ed69fa0b4ac836154c12b735128bb4351600ff13a3f6f3086a7ef6960f9c7bfb9c81a7a89193a37f9af55282bb630fcb5e36aaefd989d4f7b24f91bd63746d4f02335e91b197692609999f174e2889608cc234ac05083bffb3fae0b763b7b03ccb301157f9c4fbcac3d23075386e9992a6dc3b7509e29d55ca0f3fdfdfdc08892331f50426a727931fa18466287a44402cc62e75d6d2a06b483810e2e82ac42da495338898281216c16899a72fa3ef363b60c7ea1cd7bc726e6cbd4507a03cfafc8de42fbcb91a6ef081e99e7430c4b8a5145b8899b854e692aa09a4db41120a75113da27b02523a86cbe3c5e3b37b9d126bf76c518a543eefc6a18eba882a13003f6f4885bf8bf0488b2c17b2ff6e23f60208c7f300c4526dbc00c220452241e48ff97207b2c194099259c4561f0f5b97042233e0b485a84982b4a704bcc0a435285f176c30cbbf01b65854a43896a41e7d889c350170ad6b4828c3ffabd6bd2075cd1a30701f518694bdf503d68bd02ef135196a8f283fe7650666387143f19ed2dcd546b8a8fff9724b40b0766732dcffcc6a44260fe9354c74806b440489d141cd234d3ece7df0501a8effecbb0846dc0c7146badabdf8b7a2d57b64ddd2c9d5f80561d9d0ce9c3f602ace3b22cad10d23be259c3d29799a4372d36631d20e4d3649c301c4d7d01c871b20f92","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
