<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9711e84134380809509fe24651f39533555427501c7ae3e73420aa7cb31fbe7fc96fa8b6cdc59b9c3b6f99eb0fa729af058d6c62779b29b81c7905c9fc036478d888010f3687f8cda7369b3c66c9abd35cd0b37d91bc1cc164d5611ecd7f0b5827fe45866b49c25344c8fb23b9a5169b7a88b8c9b6392571851f33a1108960f8f2c08c5533ea71d359b52d663f8ffb573f36bd60b21a53c22ca3ab3017757387030485f9c02fe854988cfcd624d41c4565c89e69cda2aa0d9d35daa29121e20e16f49e1cd5d3b8e61dcf161e9a457552e260528162af48ca8ade98ef371907c9866fccbd6ba56f068e3ddd5513b12acfafc4b11095e5d8950e0aafa67b282cec18cf918612ddafb115067164c3aa432c639db99980023844d4603df475de52a855c4c260ef7208b51f52d8d288bc5ce70a12d6a1f06329215c07ddc2f1b8cbc46492fa3145a8d99b74cd390c5134132d57710a673f7607e66ff4813f8833cacccd76b06e169b618a1ce5bc2808a0f0fda1c9f0f4cd7ebcb31d321367a2a78f0ee90c126ee8a82524039398e53511b16c04fb7e6023c9e10a98ca651e715e4deeca6dff2991232c47fd0014bcf4e06eb7a579b02be9d54b3683acbb1d6298156c559f9129e508a63cbd201118f7e6f8c309e64c3d2fe2c8d0385e580665938fc3218fab5eae0dcfebe32e62bb4226857328028c09aeb58079fb5024cb165203ca41735339b4a8a6e5079c16ad387ce2651f1808e70cebc90daf9c7513abb964484788c41d74ac6100d7f7e8ff222ccc3192afd00c46b24f65736ad63cca604640e014a7bdeaffa883798c0d3bc37a2c9ac921bb5326a5c53454fcd9e53868b6ba2236086d6be2e8b350b8f8eb5916faa6c82d20fe4febd26325840322d6abbea1a633cd61828ae20b1a51e9ce02d9aea2ba2f1c9608c83b0e9f7e9a30d0524de31fbebd5e16b6a864885e6273691490c160c4683c6495f7f2e8a91c315247cbe549bc76f1141639c1b286c5e5c0aebfbf64d541a09983535d6a83b783784cff84801f666848c579b10d9ae8c69f46a72b54bd78694dfa6b63f5b44f4a1b057c52362cdff3009787c81d05630fbfa3010d915b9ea843f68d9456b794e205e823b47680479bc73151f464781329e3caa8f6e9240258afd9e4ca59fefbd210a476ec80637b217f6c74a81d3958e0b6b896e52a06403e5166d2d3e60bc4d504e823b6ee0655d3bd971c2f8e7a42662fd1ecd77b0b7a56dba7bf2caf4cf18740d3b76e3749d5673c5343cf881a05e3d3056cccafd1f7dc9828cdaea55a74854cafd4d355500e54365868f20638fc80c013d5a8815b339ca52bed23820a6022b0c5f5a5754022fb8bd2fafb777c34f3134ac4a65c24b71fb91b7dca6f55a898dafce24f39dad3c2e14ec9314557736b76a107c0d7498be48f3a550a20965dab89fa55e0fdad3cdd9a7bdaaee7b42d31e852aa840af5812f9468af1a64707109a1e5d48833a51ad4b95898a4cefdbd6eead3ce30672ec5b71bf7d05b94a24bb84efc0532aa7a17b4a429ada53bbada6b85d6076c99770818d83e3a05ce732a388ee3b2bfccd2384a444bfd182aefdb0edad7057c6039cd54fc6dd517c6e7aa7791b0276a1d071b5c18e97f7bb5ecdd408a07db11e8fbb7ef224cc08d174c6164839ca06d2c3fd92b5e9938e7f395ede27b93f4f65987a50355815f2e8395f44dc3f952f13dcf65818de04748f18f059f5835bc922c888ceab59bd4041346f15bc93c628ff080bc664c2ccfa983038f13126a12957e28f2299b5bfae4c3524a648461f9a6a011ba100c77d357617de5e3493e4947af56592d4b4720a15e7650248c8027c0b2063a533c6ec48438b788c117d987dc9b54a1aa9aee5eafd3c27c173153092197802d7a2142d23219da3879c07004b47cf08e34bd15d5fab830349878d87212c02bb768791f06a59b586ff6adbcc332dbad6a9181a31c6b1b04dac45e45ee8ef9906128de87327b39c19dde0d330d614719b145fb9237890d8ea11b406afa797dcada26506fc02ee6728867786e1c288560f49396795f7078de5d921b82b4812cfc6eba490a6336658b499990a8f7c21010a05d1f8cb6b97d1decf6feb1e6e90ae455051c91c2cf17b707ffd2850101ebbea82fa74762f5d9b40ba6f77326563b45850ec0d6f88cf3e9aeb07a901f194d883b68eb932539ce37c94e588766a8796e47756e0845130ec34a801c6dfbe184e268e1b5a50b348a078f68d683a9c78dd8aaaf443e817e1792fde5a009d3e6bfe189106bd2778acfab83b2ba7228d2c74299264439db44d36771a2266023fe12645dc4b63fe18a6e46abcf7764f8cb1ae07e2f85129e90346f6627a3205670b80f4a23a9b23888cd4924ae2a13d6b37ae9c16a99cbadecacfbd7f812b9d9338e51e652f2d3f0ea04b5a31a7802bce3cdf28c8f8d2dd44f560e86f827dbacad1c85e5e23c6672647082488df02e6d1b3fe28046cd0e4288bd7c3da80ee06658ad73d8df000785ea79590a329ad2e4d219bb57dc4c160e528bc941967f6e4f8cef6ebd5e11bb5351bc2069188b5ab2fa09b3343bee783cd26aef59335176241d5a998b9d39118e1000a0417f4f3e0251a94d1d356d7e4cce2f627f9ea4ec74d6bde80b9f80e7917e1fee70fddfce3bc9380e79118348c6789abc71d52546231c59e638ab7c4b5f5ebd37d1f27e3c2236aefe8e696eaced2fea273864b7a22c555d12a2e541ccc510b645e8d917b01d0c8ca39311c44e9092bebccd7b05ba645224aa49e95ca316a3b0b58c7ae2a4b0cf09c28cb3b6a9775c169cf7e7bd52cf3a85013339837defa90acefe06a91a0fbfe42720f8145089af41fb38525dc89798ec2d2af3ef0d805a003769ece27ae40bb781db1a83483ceb8024a59b9f9c481364752e5919e1ac799b1572c9a05bdd2bf2c18bf417672aa74258f15b5a123f082d5fa8e6979c66bb04e86f6226563b0bdec1dfc19e28cff988bc9609d8e7ad0e85b1e3bb75222bf801caa60a0998c7e795b084e7fdf8f80dc447a438ca28c1c1a0eddb387990c7c201f2759fb89841c831784340b2b3ec8a0bcc97b451d44dad8c1d04039857e9ca8491541931a9c5f2172221c2600b0de3116bb096ce5a491c749338e09ec79d73b21c4ccc7dbcffc02c451a103c3bc2b7040b0e212e0f02c612fb755feea738adb91ca9890389cf2ad1003487df989c636c11342e73278776dcb746fe9463caa1ff21abeea3d2278539ec4c32bb4e589e6353c7ba6d9bc3b56a0897048804bd2425ab403c3573f023c7200863ab40a3b2260b93b7a604b1d937f398cf83cd88d22144eeb32f033fde15ea4a69978214120029469312b71e1b8bfd26d1ffbd60aac19e13fd071ddcba21310cb6110cf4e757cabe1fed7e00a5899538a94f142b69a566d459ded9e5e335c0830009db2f7a2c00fe79405a5cdca6a17034d77a67324737561122687217db42f6327c4c4a3b261dc7e4904bcca30edde0457f65cf045d2d74888a8c8150701e320f7eb35cc7f4f59c1e0128a70698c68e48f352e922f0e55a6c0b9f60f099f483194c7ceae7b4e59c9ba4217832b9115238c5c542564687a5d065aff472734ab6da56f63ea03a39dcf06712e63979184127dab4f63241e12932523bf2301ad4daa73033912027efbcabdea435b1fe427ef81c94c396042d31c6357dafe9460ed2702a09ac639034e4bf55b8c7200263863ccf8799a2670ce68060bb74eb8cf63df4680942f6c012386518023975e7696dc6bdc53cc2d4fcd9703c469ca40b6c7b42ad3919fd4d6d608140a2f49eaa5e475d117b950a282328d48e0448d50c4014b13f16ca2efb744d37767debd90c13323370fa52fe40211cdae64b706309c2082bbdf2a9ebbe9064d3ee598017985b1c3a342c98e51bfc08056bbb6f8ae600f1263494a1ceb1c769e9f867943998818d05986a4c29c7467a1167e8330e0c363f9feb4b4d6d79045bacf63a2516df93336374b2558ce0c95ff8558453f399b7fbd0d7bbdfb2e86d3e608a6441d32a78d58abacadd64b6875ce2a342078a08584abe94faec49eff6158a4c099d825c576f7451f2fef288107cfb61eab8c12e9bb4a7c418b6740f446b9eabd1bc3e8917e4306f39b628c141639b5099976b04551447446092fa15e2beb7e65f406099607218fb9d41575a9585edaeae4c90d9170845bf22c81dd76209c9111a2d5c428be1004e5c9ec000fdf554928c4313b69248946da3f7606e0386d1bd60f27e5f7edaeb394a537cc1885c9eaecb3411c641d1c5d04599a911550ee79b27d83379962139aac55e20862eb063fac0d6d7163aa8ced2f9fc1ce79b3fd9bf0c8ca18464928e5ff6ef2750747ca19d49880fc5891e81cea647668acd76d22894b72f2f32787fb7b54eed321dd1784b0e4d8831cc4d4da43ce78a44923a473f9640a3ebc6755fe4b158cdef4c3f3ad1994d18e24196bd7323b357c1726ca1554df6a65ccbba163d184d770dba6adcdc78181c82870244bd8903eb040a4cd53a99fe5ed1914b528410ffad13ba5a3ccf83f409e9460bf7b09ced612179642b2fae82cb6be36db30d59fa8dbd2ae2e9ea912bcdb4e39411508fb01b7be6163058e7dc400e819698f35152682336664c2d77ce1c94e4ef076e357e2fbf68519659422f310add5981797cd018d808877b5936dd8b63a39c51c7b6722f8f61dc4beca1b9d72a31e6e9d71869137e66cffd902d0c5b89d17c32f4a659b5fa3e904332d8ae85318254c1f33d69d5a56d6e72dc3c8f3ccaec13185bde48343e188a47672c2aed27de86917e5e3220438a790a03af8e959e8a139e600e90a57f525e47c20ff0175e6bbbdecdbf62514a442f56a04cfc40c97f96b26d790203cd832d6e446dc2a8e90b52110bdb530251b4b8c2403cc9baea204469acd55e28e40cb7f91d73e1e40302512cd423ecd5a0d423a58eb11ed76eaaadbf3fefbfa813f40bacd4213c93eb3b0f44bfb067925c99f11833f3cacce37aadb8712eda4d260799a65f5ae9ddf8427a861f2820a0d9ccec61fa54f5613630d6bf6e1a044e2722c6caa7ef5d5bc2b13e65365470956313f6ecaa9291985f96b57b79177be16bd61b25edbe503c5c678cee5e06906f3a47e8019d38933e0efd94ff079e4a5e415f9a013d19a627cb95499ed2822961d01a57bf424ebeac255232a29217e3c0674e809d9952ac17ca84e0b619cdab68024edcfc02079198490facd41335fa7b2b614ad97b9135aa72fb938dfd953d32afe9eab37d4342c41ca288bdaba69b62afcb03d992da739cd8fb9a15f95fd69dcc7356c26242e8926fadf69678f8fbdccc6c02f2385f68906ce4374d8f3f7c0d484e67a3d2704163b6337162963b9f8379f1ef2dafb8c4d68ceca8a7c41aacb25390c396b87bfdb44a8f9c8781da42402901e5ed12a0b64dc3ba386cc997cf777f41cce8910480368ed4397675eb9fbb4879f110ab6f7a3536992bd3e618e4fa5a6e87e3330fa9682452121c13ea8d4b941c4e6a78973de5e986becaf4f5d7b26080819a77e0461319f7d4ed7cc72b9eccdd9de57e766ba77e6cad0951ed01f41edeff055ee819d72c40c66f5bf09bccff609ec31765fe47bc0c20807846fb2a51da908fb44f145d165ddae7737cfb7993ae9dcb297e951dfc54f42ebf345174364fb5461b77cfdff58d5e2efd0f84dbdad48149cb9504e34a927565583a277c469a28db07829fc7203a8d133f3e0657e468ac52090fa2152b3ec9399b3da04f28b0fa47e9d0b6cac5fb957ddf570db08bb0bf493d6d026d36d3faad0dd94607e729ba8c5a8698f5a7c2fd76a848ca269e3ff3bc3a6f81c513a60bb1d0cb7d836d1cfaf53cafcc24aece6166ba75b8cb12fdfb65ec79544e6375eccc599d9f036cf2db18d283233389c15aecfc85858b74fd51dc2397583aab1aa1245d8a61c328b3f71a63582d5e9e888f913dac24aaeedce3398aee540fbc41a5cf18f05246f24f9ee46fc67b14871129d485c9cb26dc5e1271301c3fb7bec49e1b19927f74e87dc692857b2a1c38e07888e916835752430e6962b31dbcbcec389060aea19b369bbc3c1653aaa7ec5872d0fe46da07fc7725dcfcf3b612bc0cae64f70b3785fc6eace03121100f81fa7c820c3da5e0ef54ef5a0d467fc06fd230df92c686dde0f199b6ff68cd2f95e54d1d80f6928c98bf73100a083c1553c04d88a771abeeeebfb2f1100b781475ff567508008aa7af45577f252d3f7c04313bb80a6adca6c7ae9737fb3d1ce156f9a5b902a1707e951c412ca7f2a8a3a58d21a031e4b63405afa2efc9bb9bd7e79863ec5c9f7201db51a4c3ab907fa18e0583aede971d9dd65ca4e28c3d9ebf574d25cdcb293daeeb778d5cc1d41543f288fca790f750b19c9501891e27e1f5d9c2c3b6ba5b5aa98397edd4ab1cc489d24e0dab020ad877f252f4550e8655390d6ba392a5dc28e34b6eee0f246320c0adcd518c2880d13d552751d2bf1f4728bb3b6da76a099ea4a1ed9b58ce17c48672af72c6568818742bb28689617da8ef682dd37683d23f4479fb7afda823e07d0278f9b35b9eebaf81705ff95488b65522629764da907be13ab1559e6ff2b03751ba4b21a89ca0b97f836ec9434ec3d0b2fef711280ffea38bf0f49312cfb790bd74f4b60c23ec88c8fc270fb519a880e5648afe92e51d369a548f94bfd132969f539ab7f599bf43017bdde8fd5f0315439ce25ef93b88cbd41bc0b423ba3741077c7abac3ac31f2a20a43569b6cd160256043b7e34c9137f4dc110e6a16ec82b14e949fdb0011585cc82bfd68f40a353c24b01b188ab1162d645f090bcf149fea445411bdaa8d82b6dc1a4a4df329d28b7b75a6ea3d8c9df8e998deee8f8264ce205084f58cc89c371a160740065bad00dfe6df5639f9aa9c00e8c5f23a36b97fd326d4142356ac9e1723843efc657f5df850e4d74d778bfbc59b4372a964a8398b59eb230f9474f88e8c98527896320d947d1f666738c95b364f74407fa0ad138e86ef72e2428d92f67d4c0e9d29b2ad2fccb01cff5e0add0e7de4e6c860462617eb2036f3db7fcb60b7133d9741d8d778ec363782d4baa0ca3220a76b68bbba811e13d5788daf109fa29a58d89c6f27e6cbc4bbcc84cf79eea296e5cbdea74c1c0224b6248cf141f81f3ab22baf4c0c5b3269d1c949505dc4929c255df340a24f9db9cd1bdbf12e3c9191dbcc5b2caeb7ba0070e5713a5e237dea351405c18fbae95851fe866c03c9347f8a122a0f2e78d706cf978f2215d638b0912aebad80b06967b7ea274901b41ff9d266f57662e328b0410b1630114ce8e9147d12803eef4627ae922a557f3872174ab144e0c080192d3a5e554cec126293f944c6b13e63a7803433b3b6871dbd879777155d67d30142d71d906c4cf41cf43d803b782cecccf8ee95f7aedbc1ca267fb0d7d22962ad402b917051f9825c1af91cbc0d35b55b6d75b3f890de58dc7788bdb6546014d402ed06f92d2da7bd0d09e41f743903d622b2e003e4f98d9afc992450f4ecf323e2bf077e6e09c9f9ebd59beeb3132d3fdcfa280b4a7e228af89ca492c167aa0d42f059b1dfd1207ad2ab10e5c012515d36dc22250d655081b03cc9032be7a14b1e9dfbcbfeb12798d3ea958d35ed614af6a93648d7e5b99f1489ec8aea0531661725db42b0aa4c4d54840b197153c2e09a053381183b47b5a9aa371748ae0c36ac4a013e9a549f4c08d203c206cd737e63ecb323089daaa23a73d2362e4318a80218e1e5283744eab799715b2d6463ce9cc6dbcd3650742fd9026fb856547c90956c2e36ba83deb8c0ce6b4a0475c6e7d71ac3c1d6adf4605bb5ed9ed0ecb5a997eefdfceb71bc4780dccdfed99b8cf9701b0db2115399b6baba14d9b449f7e5c401c88546707bbbf702af3fe83db439f28fe31fd1a971abe9389057b01b429ce7ba8c6403db7eeb39dc21099b1a4f707d84977969ca50c50458658a030484169e05ed36fd9ba86c9a21ea0e59e9b859e10101b2182368b95e797b5127f09d67c87abde86ceb4350d901b0d3c8044de24eb5e8a288eac374f1131e37ab9d2a777124d3533dda044813611641161e94bc5032c44e76f3bd1049aa53033a6af3bb7f45eb70c398471ef2a545eb2335e07e3a6d95ac933774b9ef30472616e7138539149ab48f9d6a6cfa44e159ae1ebb8efd6f88357ccab5f3c5862f1b4c4a5dde7b5360f76ac4fd896a1239cd1bb0c2506deb1c52f7c18c2695a3d9507e564bb79e8da6cc3f2cf4452f12fa9c6f1d922f37af11372da42c4580040a8fa41edb800c4a0e75f724912a754fe165068057953e76deea6236d344e7311fdd34fe0cff8a74252f0df66175d6fc7a95421158c5e9df7fc9c8908fd3cdc71a74a939067d6dafd0e637beefe6438bac0040c080b8a1f7a92776096bbb24ba72cf946d14f8ed64751717fc49aaf514df3c41b8d7fd302989cce3d46b87fcd92924771deda9463c2b6be2d8610a9e27a6f1822f5d99399144560f713cfc72ee69fb4cee86a14e5bdb5e37119c9895fb452873b076dc7a6fcbfcca0e982c20b4d84390ca6e26c11e4767478c0c0c5410ead8f40edda8a8fb170a72350a3bed567407be1671e127559cf73ccfc83ae5955b65dacae19b174bd65792f9031c0066d12762b5d7a29041b32cf46c3cac58b56af456dc2c779067668f15a2778634855402f03e65602eeedadef668677535ce03ce8b9441e13946c1d577d5575713f46a650bcbeeadbbab2f731753e14f17ba44be061d47974228309cca1aa681182224dd918beb0e39153876d395b58e9fec869737c4d3384c2bfc3515f1595e1cad67d4a55d9c74c9977bb047dec3f9b7e0a3cd6e2e53d07545343ca161f006098dfbce686496a7e8ffb39d7b943c5536daca5cd8f6bf00e9fcf3b07e00e2ef5d0fcc3a40363a056f4ee35c9674bd1b62891f782d73cda8c455c480cdb0b5ea712e6f540c18218e0c63f5d71718cd9984d827a4f76a31a6fd8b3f4ca0ae1a59fdc88dfb929f1f61767b416b191fce8b44369e1189d39ac3b769783b9dfb399b9cdc6f780feb7eee3100b880430b2fca86d75e2e89cd98582a848de74d4142e018bb97dcbdd2f6be9eb20cd71eab454f7e6700ac956246ebfe9afe02801c1e6139d1a4a4c7f7c66bc6a03df6963735f1e80d71ff9846e8010697c27cbdb5f09d37213074fd24d80764617c0c271b45bc78e293e78638d270345f76f5a2ac4692ecb2d9928622e8fba630203b12e4a3f5a00f638b27ca089d7ad32f797a023bbcd7faa144aca29b9ae2b0aa1ac37ac2614e0d4f2dabc2f22e76359262c5c37f8bc7b37fe78c5297699b8b20f298ca868ffdfb175ce605046b0d8e5582fcb9886af49744bdce837075ea1f306bda2b72e8d1b4b76380e33e4d466935c3001cdd3bf6ba79fdb2e16453eb5d19cbb7babfc31f7feaf8bde8c2fffd2900f58302aebf91cac0023b780996ff58993d6b4c3fc79ef2c70a0a0153251f91b3b51f07276806d4a4ef39788f4173d038d7e685a40c4c23146e3f527f957bb30cf324c4634bf0f530f48dd99d755bb3394a1936e4c895abdf4d577d5db7271904b16003bf25d38e6b44f87d6ec8acc44355b51c512efcd2108b30dd3bd1bb2546dd63c8db8c8306a3e5bc240b3258455cab62bb4cee98c9cbaef6f094cd0b872b4b0657b1d6fe76347704ccc96059246c5084df3e636bf5d90e5c9c85cf09ff51f3d4ec96e08991b46b940cb7b97554003b9a630d98cb99d526dfa76bafaa20dabf3283296f5116d895a1fe133095d509670f2370e1c19e7085ac603caef2604bcfc6827d257cf9642c9bbd8f34d1026e351f433441a1d90e5e75185234e69906111d10fc369a796505b8a565ab6b55b4d4c6676868dbaaf3a8c087d820ca2ad0b7305ddf6dbae5aee75617a6efa11b08838a42306dbca9cd6b017fc361648c7be267a6a21a33cd1b3391bbbee24faa7761c8964fad6d70ae01bfdbaf08d26115f557b7d735d098814b4ea7fa2b796749579bdc1dc906d52299a7960ec77d727ba5f3b9b43cdf6530dcaab68b68fdcc4d7295bf4232cf07116f91d4c555944a3dc9d65e641f07ac5f8870a07ee40b903fd6ae151324328924e05cdf18d946400d3b847d58f39894144e1d0eb633c28b34a59b4f21f9d1244a90b06a4a5b9841b1dbec9bad7baabc7c68654b6d88329c21f9f92498b9e63c75941b2ded3b23cf668cef9a56d6e419e45417e040fd61cfe6ebb7d94ada13f9d6af77036604c47a6785a351667f7a7633153ae2280b8b7aa949370e3111da7b4d1e30ace23ad28ec0c44f386c3fbc6bc85090b613a8c330a5cc829fd2bb9f49bf852774da85410f769c401a9cd309044c117ec0c4f722614f1fcd0b4d45afc131e5df587857795ec33e5562d8167d03f157724a79dc8fd16848758b154c61144c181d7023c4b352a17356abf058f0361b845291e805e5f0b93dd7e755a8375d4b824eeede0b87b5f2e8fbc6c0a32558e2fb3edfc055f5c624edfe60dc7a523cd206407d6155544ca1e54deb0d1fce7eb56872a8535638b0d546a4a272b7482a91b2309ef2c6af79f10831c4ca239c67d322e5aec143e8b79a2af0b5622213f379bf4afe5197039dfdd53263ad5b8759cf924c75da9a0b0924d9f1f6ffb5f947f0af8a9e664f00800cdfd652a13f7d7ed93b0b151f93a35eddc82265c868b655d20ebe37b5e267833802cb1198622bef2af9b8a748b1efcb6f29c309e0866a95c3cb36913efecc5c081e07095fd0cbe0a1d102a73f81deb415c14d1c69db291eeb6ec537527276f6a882939fff1eaf36c2c866605c0e3391d1d306a852a82965ab78a1ff5c4fd54cb44b9dc7ca63324299e070b6f8e6b654d7b36aaf23a60ff73905893efd2a810bfe3b48552c2188fa642eaca1a3a9fc1862e1f420ab9c41ff35863411d80ede5e5e1a204b6200cf6395ec27783af4f31cef09df1156423b1e16c3f0834a6a32ce09d40723f6551922d973be220c301fe03d7e0f1ce0eb443fa2bdb5e681ad317052ce5d7853ec358e1ca6209f6aaed4b08c5474aa0f9276ad80a035ebe684f08fe0bd912f550b7b45736fbe366c923122b9131a5ced8089e54c4a3a8af71888c770e9b1493b1c926762eb8886d726726873cd1efa3f13f0831df550b3964f1f7e7f6f62765d342a706174f9575a6eb43f3caee6ba48e6ef6af5ac0860f87ec9980ab035c1fd6a365f8c5c3203f721df71d619d06aabf3972c1240a98d56bc3e5431b41d1ae481f52b72d8b512d6a4b9ad248467f60a8391fd2a7b271b6ed870c3d54c4d276d5ae5af1ff08b40d094d268d2cad8cb72c12fc64bc3f95621a9b11ac58c5b5f1670011b59cec568b20df3b93bb23b6b0d8bf1e970e9e32f5b7297861032de2dedda4ba898bd22658133db754fd23c3fd2360d85192c99b2ae8648fdf0b947e47a7a23ad1629de8c665519cbb49dc4c79e96af733a4f4783dceada0a356ad1d90737b362bc2f32a342bd833da94add97f09faa861fe012a4ce6c5805bba2dde9662c35dd4cfabd5f955853038fc10ed6d509434a234525dd3f7d62f35f28cf858fbef6f0e66799ef678fded44258dfe29243a0908249282cfe586cf088bd4b73cf4ae2951d8d411e54d8eb16f03ec4221e3d042139a2b383668fb22a0f42eae7232dc9eeacaa516bedf7cd0a89e6fab70872a5b243109a4e2c044cf934ce7c218f51341c3a825e391f730c67219abef2603286cdb7c9dbaffaca7b7fcd8a9d3245e04c5cc0f4c853e602d7c9e336e4085c583dee83469ea004758a3de0dd4ffe23c235af2908fea11fabefe1e9409b6c748f601627a5be289e27cc4721048dcfbe46d1c93533cdc98a0d443fe260146d579cb3885d431f31aa099ef2f24de60fa09d18ecda439145df0d5668b9a2f02d145e524459f8384e94a5e1d11c6db0d1415fa00599c80cc541b31e3c3b06079e4f9384ece2297fed5be89fb001d4df764e2b2dc0c19d827ed8a6c08e8e75c2f209c0b5b769fd26496c45fb79d0d75803873744881e1fdb2652051a2f1f9d2e2fb986c395489d9c3ba9475fba5ac68f4c6f97fb44675dc1ead88519c2d8fdb1495a0c9a0c68afb392a5295e53506284658ba8032dcbf61a67ce5dd0c1173dbc6189e04017571034f0ce294f6710b979dadd8bc51df05b4959cbe7274359657f53bbc285407947dd9b510cecf09f538a7265edf9b3c2db8e7ab51e27bea1725a7aa9c48cd04ce05318ac694588a7bd8cef26ac5258e614a59a62c9c31135d296a3d284ab79b9d92d7e18d629adbd37414b74e4b5564e97d3064bd6a1c8aa0297d6b55285f0ecad1f283bad7aa1d28b4a5cade1bb51b99dbae5f402c1469c6f85a7d99098da43def46822ddfc82ac4ebb14ce08e8537dd63202469f72460d521ff32503149312e32a88af444dca731295e7431822494162542a7f0a8ffd2f3b732a75d89a39e76c33d4bc2df4a60f23013b43127e7aa7da07b11ae071300d34489227c74de80fe315f712d90595a91852f10b833a384b5f21795131d7d0a1d31404beabe51bbd9a4234b6a23d85d62281dac284f76c642e2b2c02252ac1595f180a1ec089547e58d0d75a6ff079f9b3107cc63deda0d46dd8f2ec0a7cfd2c41f2b77825a34f84a194610d0680634f1e5e4d2d0362d2064ba390a9ed1bab70c80021638ebadaf87bca15f0cd23095b44abed549538d0941dbf6b0543b8c89a431ffece3be80d7bbaa33c74d749c4cfb219169d052ea67489eb7abb14c516a5472f93a3ec61e62468094ea709cf56fa7674d02f331c57bfd50947d6a93c156ea94d86f4776dad0b7d9320afbcdf9629e7cefb6f098117da7adb50c459bebcfc00c7782402cd9b4950c2eefa719d80bd9ad1fb6d4a7816a0606de038a6472b9403e15f64cd9f70ad561bdb0b98cdefb72c1473e42b7aad8b18aed9c09b1b85687b39b807364ef49b7758a1fa2f8fe02ab6d0ad8ebc9f4bbeabe9502cf1d7ba5eb2e4a3904cef84436ce3533f7d03b3140e38ae42840a08a9b497d69f68f5f1f0a5e2876f951bd4b40060079a00b684be44c973071416360d87853014165edd3ea22e94b03f4580fdc61b9427948b5ab5e4406f80ab0ab7781d258bb8bab32b56d1077b6e43309fb162f3fdd6fc6e913a05b153832174c7a9bb38a6cda76b07c5593153cedb88d5e90c018f2e3fc35fbf15da1e750b1c3aca258e2e3ee4b9b229b12e664a9f56307902a027329030e4ccb47b545a25bf232b18c4c155b4ccbbba85da492ca9ffb4a8c0f547738d6c22c8c72696d5f09c74fdddaa980fc0222377c930e4f1e49ec6919ef87431bff446f68689941102f96c2c400504883e86d1eccdeefaab8708dff2526700c27538e1b0ab8f917b75da208e28cbd2174c516533a4344f1830ec6faa2566f241bc6587a4ba0783db8c04111205577c21b349d8ba267cfa1faabe6fd22ef4d53c042c02f64d91f3a1aff1f36e231b2bc27c295872e4d353cf2c8d79a1249a2b646164921e60ca6241f1bd8126fa81371cb85694227d764d309ab9fb65ff63a0af6380b80aab587275909b3dc29e88821dbad9bc59838f579a8a6d139c84194f804ba59f142699969d8f0b43b820942273c7b1d05501c1b16caf917b32b5d8033894b16170da367e548bb1ff58fa5994c749218e2d044115637f33736b575f02b3386225e666cba523228628fe33f826af8ac20eb61d2b47f6a151569a84568f3af11576ac4409c634a3dd46ef55008c699e0747da54758c1f8506bfa3dc55685adac7ddeec94da851f4eee049c1ead2e3ae434066a480f419256c03483a2f9989394bf058b7194b6799b88ddba890f2620877df02e574504d9ab2bc317134ab515d6f4ea776d5a6c72b9dbe8aa84b55ac5887871c19f40b80d5f48c42a7be04531988dab4690057319d1da4d0e9433cf9313b85bf22d0bbdb23dbdb492ad47dd0d21b7146cc72269f9e9a7a3e52e64e3c79835c095d22217548cbb019a645c236cffcd1a49045666c823690cf1697ddae80c4122318f0479dfd3dcdb403d52b1397afcc87a96eaa5c092318c249f9f01a381ac1000caa7357b94c4d58f0fd24b1e03f47f26b693aecdd52340b86a6481404e8f73f52c7f4040cb457573167c7b68905bc4cbe78c75f699e6bab9928a60b2203c6f699b3d328430bde7bfb6776fb8aeedbcbd6dc126b3ea24a324139e08e52b04ccb9a4f848da0d8291452375892cb5bbf1c37d26067632800d4f6348e00c653f73637f5e92f51def73f16cbab006e255daa9d007bdd52e966aa77f16a916e211ff07b2c4264d52ec3807dd2ea2efd6c7a5836078066a7baea892cb88f43272ad066a09170265330eb779c0ddd9ea4a60f4e5d27231d47f8deb3ac20a940cd4f23201b281c040196d3ac10ecdae5b18323132d2382238446b7d55321b578a1415a8fa2346c8c93acb2d39cf60f3b5dfd39f1b63052113eba8ad8e072a56764c6d4c6d690ff66a530628b67e34c7a735a213265511ac1ab59b56f97cfcbf58f0aa706f70d67c7e4f3b31a3b0e6046f0375675f7f0d3f6cde7571fd7db44efdfc27c0a85f4c96c4867dca5622198698e221c4aae7c32d2f22d86802efab8769978bf4d0158f98f83c769e0a761314fa5c64578b12a96aee421578ffbed8df7dc1d5e668acd822cd6d5f6e0cd60c3bfd92086588d9601be9def7a4bc9aa5d10309acaf31bf63b16a2a3d162bbad45ea6b2334c261eaa347e31af84c9197ff80c8e6547c5032cdaf7316433ae75ed851434d58998f68c7564908740e109cc5a1309260a00951d02576345abd936737e566f3ddf90bd75e7fc830ea84d5dcc55efc77349aa0203c6c7553221bfd8ed39f0af0c3d908c775211d20b02cf9f91bd2c8157231130a08075f24fd09051d548dfe39ad5a082a8765b2f589f4e8144cd8d99fcb501b72bd5329eed745bf9b2c3afaff6ac97954687754433626d93d14d22d6bea87fd4efaa8d14f91fbaf1a506986e48e169ddcc5e5ea2a80f2cd7bb94278985b6ee25e380a9d41799da3e5c52cce1a44914a1af4327011724ba2fc3646c211324d03ada3c6876808f5e3eb1f921475eb8cadfd3a9776377775afbc20dc68cf82e9d475d0163c3a1b4b36f41b38ea868b9ab3ff41101b5b28f4d39a51070dcbce0887a8514d35787142d5094144e75931d5dc5afd3dca3ecd9fc4a1154fef143264bbffc373437c414398ea9d17c29649806b70efd1535a3f97a6a47dab17598be707b413e61b8033f35279007914d1d7d31b5619f7d195a7dd07997b11e9db84e04248da2b69fdf868256490eca2b1ed64793628fba0c06cd3ca598572bca4f3e2e7809095021d7500b6992853b74f4ca177cd9551274ee43d9ac516a6388167d2add316944ca4743250a4949597a4ab1d7348580241c693ba9c971acb92cebc7af42a830f3aa3913a06a3c033958c97dd986a8d056e53b36f93bf736410527c9f4164a769f6362484c84f967c5f93a2c3ad174ea70ba8555381280952977d401a2096fc20c464964e5b55a2fd9426bc034f3be4f6ab3ca6bd180eaf837308576ccd6d455fb5e0796e5aa414630d616dfb6662ce31c332d1e1b2052d085ec2b8d85326c5a8a0a1ca70bafcd2909588ceb9c8fef22ef5ceb17c1db8e8a53b66c7b91e1ce3c10a23053881e5be54e90547f8303979fb2e95228e439628e7ce7cedab8a26a6d0dadbf57c83a0542f25ad63e561a0eebc5071b904b500ebfe3ba78ca6cf8af001fc1b310240b5a6fb9364183345b18ff6e89f9a23714a825b59769f5a90b053fe0881524df07b985ae16c8cda8f6076d1cd35db8f9fc0a598489dd6068d8a2d5e9405e7783774ac32f05c8bdc352cf9be086e951e5b68e7a82a413c232a18ca3317e956be13e474608a7ab7eb52fba30f1d6c5bac4e3a93b3979b3515d0cc42b382879bb7ea3c799811e629ed4bc5562180f8c4ca87aa109a9a32f9d2b772c219e6f4f826b653595e0845dac1aef038f0997e9a4105a102606b838080f5e116e2adce247262da3dc99805fc17357ed69df1615b9f3ad44bc6843b5a43eeaf1d449b4dfd1984791bc9b769768ce73d743ca571697180bb381745f3749ba848a66ca27b26acb4fcce3f432d34cb6dd0771e1b2b4400f3312aef69c99df3521694feb24c21e6a2ed1554245ca03c50d8486dc0246d17fa2583bb026a63414c8e9c5b16eb2656504e5c8fd5ddbf92f025265ccb84918a874aecda6858708fa98393b23f36204945b0f41f1162ea2de9dfc304a4d3f9636de1d630c8e0a987033247bf8b6dba89f7c4cd432b83f3101a203d42af0005dfd5ced7f71b504e67e940da779e716c7547520f98fda630d1a1636041fbceabb24229f322f928ad0c71c47d2e49838264768279b08f359d2888b71b193ff9b410173c3299082cd363161c1eff43a58d012ddd54a27051e9d0268a343e6d872d49bb0912e64787635f3e92c52dff5d503118baa2cb7af936bac7af421276ae098c2ab1ac52d0fac45708cdf415436ce1b9abd69f6f258c5296b47fd831516ddb4836edaa3bcfd2beda677c17e8d5bab0ecfd96973694eb23bc51214a30b6c97c571df519ebe1e2319a74be2166956f85a90f9e13ae01cf045778dc815615a20fe6fb6071c93248bcdaef29368593ede68804c012f0550f44d0cb99ab1cef09cdee8cf9518c8f4cea8b72b6e637ed1fa35420678441f0638ebea47aa4f889cf68b5cf1e1314708d2c01e518fbf876bbade7152100c7dd37cb54e6a3867a719b3aafaab8f5de4b22dd56ac4fa74c22b1977635c3c9d15bc112d767943dc0e5c19d6452cd119b25dc6114e141fc6ec8c2c0d972e5bb14a6fd4bdea75b35a41718900320d3746c883e80bd13caffe7ee452bba7d68e9966f5c79e5668a3d51c529e4101898cdff1cc4e2ac0a12efc11e5248f74dcdb523ff2ee425f4a3fcc082b257f6658e3901a8da84cb060bf85179ceed00434be1e4cc0f69e369448804f887688b5b8374ff56971ad1916de068cd15a8dd49e2ef2bbcfcc14ec9f1cb33f9ff765a35e8df42ebd40b769df80352ca78dad4f739500a9834e442a2917214f171c1bc316e9f2c69d63b0bdfd3b489af006336b5253a84db15dcd9101bd581a8fbebe0bd6833a12df669a9b9432c02268d56840397840a690b339720f440b506dd52a95507d16481cf98f91d346cd1cebd8683fadf0f7d1bc8a95349ebc32dafea9befc6230369ebd5e8097c68dfa57665bf55a9b2a7e449e7cfb3fdeb62beeb9d4db1ccfbd247f34559d3f2ee79c6eb09bd5ce274b7ca2c45696f260e04e3950b435c9d5f976681e3e3b76f67328ce7b30b65be76733abf7281821dcd13a05e709d061bfe844d4202c1e55f9bfbe2189c72a0d1205181013c2cd39a1498b78bcffb6b6ce056245ce560d63ee956c014cef6f6dd9799469753052f4af3245580817816c5f509e32643e2dd777bf2bf8d2bb07c068e409583985f0ec5af0dd69539b1fb62627daaea637e57d3652021fd8e736f0fa66df61d34f6dc2353e73ada25acf7aea5fa00557b39240037c90f83e0bf981f3b7606d8334fb5026734d6e6939b88d43daf4466b3c9cd1c599939ee6fe9d5bd16a389aedf05d62681660438e383cab180c60e3e3968ee771c4a79920c3e4b23a77e07a57d312e4c3b9ba28e9b26aa3aa9f19402c4c67121ce30b62821e9e677012b7c0b76341d5c29d2fe9c14929059b6f9c2a54d2e6ef04ad8a1e983f3cbb3fe2710de31dbb3a4ff2b19b5e24704cd3e1e3d8284f361d9e01baf39c29bfc869bea3d2b44c3499d1e490a57b0e7fa74ed85e5c5395674df4e3d514c0aa5c35fdda0ad495f08274135d4440ecfd9ee796b4e94cf0fbc88fa08f617eacaa5d0d39f731091be38b86b57a60ee48f84a878a7b4b74d18b33a06f2e4958263ed18cc2b46b134cb6d12932c042454644a9eeb3a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
