<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0486edff1f0dee0477bfcb1d87e4f555d92f181f7e74f171aafa3ac243e79a208e2f274e68e1043cf3b644032aee5f845d75bb8d2dab5b2b930d179556e4c71e5b2daa2c2997b7bfef1b5a54786c54fed687e0490405345cbeeaa8eb5fecfe1cce386407c920efc65d3b425f138e9b7467df8e9f18a81130367629bed1d3ae2db04d80653b857a8b1fce95ba3fcb3a5f2495095b3c3d9b3892327d66c206485c5ef4ba91509b930e602c9ff972882886c49e346797cfc510ca206ba100b9f9e346adf21ce5560d8f2b1b30efcb7c681c2e579b32d2b67757dcfd797aca4851f08f6443af0329fcec5717d0e89dec14fe7190062b403eebbb3871123c861c7433389781acde5aed7c8e247f3cf0e166c1dda3c172f53ce50d635f04d670a441f60c509017f122ed91b637e0886148e3e6cc666e7f84dbd806c8f988c2d0b56150edbefc00ed2dbcf5dd69e50b680f57aa15aa6efb3a3ff81c285482dc953ee511541c3c7f9ea7ba238d7d3aa21181344aa5c880023cfc326dd631df469743aaeff32956c41634b89506052d26b0d522a29945efa924965a50a0c803cdadcfcbb493e5d4d171f68408793176742f91e3d4cb9bdd04c8544246df9db3147d93456acdde002b478fd7fda832e350b23ee84005defd1774db47e384840c9159872c9512635bf7f8864533ec82fa105df9071fdd31e6c6012116b70e6c613ce3ac60c61428a8f6ae2e5f9b24f1018df0e8b48637074a330aebd60087745458ccbb207001d954f17145aca10719b4f60429a50da94fc1544efad73f17bef171d8541cf0d3f41421d6a5896a771a13d30e1e188f467d10ec98ff88b3e66d547b875944941b10418647ff215937195e69aee2ffaff43638e3c2cbc26ea0b2dff9ce38403f648b297b269dafda8358fa1803d3d2c91339c2a28493aea954a240a00e111cec669716efd5d54800483a41f2428791dd00b279f8aa0cdacf801d255ea26a112e4cf2b1d95f3bc8c85206e48b4d7d3ebafae6830f25ccb00aea63c4438cb1b9d2b3d78d35bdd9da0e28ea18638ccd2a71581d670fe2219a1728e30a8128cefdb6974f066dd0b907b5c058b71e7090f2aecfdc19ccffb0d6fb5aaea75bbaa03a83a70880611b3b3d62e8788d36906903a05a52255fa228968dfb9cad73c62858b66e893b7d79710f55046a19267b02b9ca2b9b8e344049e408b8523503d5a6b3a325d18b17525e3d7fb779529a62e41269f5118be4f892d7f2fbc1e1d5275ecf1dbd3b78ea200ed3dea84322ee462f141a1a2f525871f9ce358f1fa82c69259a5051f605d9f69e7d24648d5506874534df9fe4efa4e17ddf37b20e1ecb525e75ba70c7c42526a82e636b4f925fc68dea9b60933499d1b59ccbe208b34edebd7e30fa2ef4ccc9e660aff73dd6e5b6ff5953f24ee5e1267b772b8d47bfc3ea58daad1b791a5eb01966e4ca2ba4ef2a727bcf1f5ca156300588a0d3475731181e7b683d79922e1a02987afd5366ae086e5991590742a76317591cc33d4e1dfbacff99ce589815869213638d29738af6345871486cfb1b733aee97b6673d6c7003080a76b49da843561b22c331a82deb90d4253b31bc846e2c6162cc9aaaa62d446632130ab7e6d91ed987b76fee6f72b9de1661b1942330497e7318acbf884089651adeb52cfa7332a08563ee29823fb44020a744094a33ebd1e8b1180e66b6ee9bbc24b34cb91f58991793dec298eee6d47f8caf62d335fe7fdcd0383632729ebaa9a223bc6b232ec953c3d2ceedc932663324c7b64d4826a431ec27469018e5e6032ef8c4ce1bdfb2d133f3b4155c4cfe4ea862a859e3ad11c4d806afbaf9309a1540e4cdc0d801aba11bc7dc885a832ad00fcc2bf3c09317642437b1df4ef1cd3d2c077c5ef9fbe4fd68a99b6efe6a3cf4aa1a7c1111940c8330bbaea1ec52e8c663f2acbd4e5d690c4a617ea59d7d4f66f1080e483e780e3977c3c85e3ecf6bb45b15efa446a7ac4d92aae52fd1ace2bd485ac50104d49a976170ab9d574de14b9e7d7b6814331cdb79d3445574377d93c6f5f78c3e4f752d705fe23c8594b8f6ad616c4317435e6336504f775c84805e63e96c879ec87f6a1a7b9b429a2eb40d296d5c5575e9fa8db23cf8556f51a841c9b2106e0012c7f47aa5a91674f196e052d751bb6d1e345820a5154eccb79387a762ab950fec1ebb1f98002bc88f1cdbe69cce05f1d962a87552fdde8189033b461ef9c65db0d6be05158cb15eca77c06a5a40f9ae96e19b6a11f47c22a78729888235f19051b18c5571203d6cf1baf39428f20d5e57b2353107a727ea3fd4dbebc140cb001c8445f1f974c7432fdfbb4b0d04478aff398c0e7b8f4bef3d68b6fc98abd8166c94a2ca37b60293bb9c5f61932a980b8d97b1c727e0f617ac243860d34b3261d4b28d3f10077b3e56f55721d7cbb8f6fedb66acc9c40ff2b9b5ca2b9b9287e5784d1e913f196c339d583def611f95155490eded92f709b0d90bf8931f5c86813b0047b94b5336059de771bb1022dfcba87ac44696c1420949d2af85fb91ab87aedbfdeba2e557f56e6e3a716c2a64a6e003c24d08feda9c76a1af936726f60a28de694ec0ec7696612ddbfa2afffc7b25973b8e489eea51b4a3b0f4732d956760d874865bc4fbdf60abc06ebaa8db4f166558dd1d2c73014e2f2bb232e62797a3ff712d151184695e51d19b1eb27d96499396aa74be49344d371f63ef031d516a6e5caddd5343dd91774880651426db2b0bd5e7917d79e96cb7095d6333be62842084692f07579ff6438906988d8c8e171f1731b3218cff1ef7eac6b31cebd0c02544bb4e0a8936c65633199ac429a299913f177661a27227ac9e9073bd18f0961f09383833e0eb0c576771116a8725cc233ad1bb4572239c0410ca151bb20328d80b46cd794d8ebea020bcc756fb729d6e964f32a1478ba10e690372f546c5a4d76f86d17af2724b14a932cdcb7f4c271ecba272255425bdfe0441dc3bbd5f51982633a61e8171b677837ffb5a9fa88592ad05f0822632416d2b11b3cadfc0f64a476d3e123d1e377497ade4bc7e3c3854598525d3820768b4dc78d83d650fe9cf715b815c1404a931c438ddfce5b271d1cf861cc1bb59bd0f921f935a5dbf894658aa80236d5245c2d14ad9b19ba550c7234b85ebe70de0cd5f4ac1c552e67d901786147abd86b89367bb16e8ee7a60588f8efebc57b1bb4acad4c1ddec1481b226bee305fe952777bdc07298f3811b1a26c29971e6923e3833b00a9d95f470b73252f293c24e2db1f2ab6f9403b3d1b81f452b0a999e21bb7eba7630d8590e9e25351e191b06e68336483e34208ebce9387586ba195122aad3ff975384cca75db83a6f38e17c3d8a86d705ec4b31d527c84e7295f2754466fedff7a6c6b5e4b21b466918c62d55f40691e6901a8f56425d1ecd472967a0811b2ee106881edd8fd3af25a6f616069399f7b8afe3702b1b270361f75b6d016dce328d37ceff151688a48b11f5b97eedb48d1e2f2fad2b4f470bf8be063c1134e24845e2842f35ce636298567cc396a06bde8c6a6beddc759bee203a4bda8d19929b2799c1cfa71f9ca04d5bb2af82dedfd8e3492bbe278b6cc2a35b5280b0293b9b41e569efa920ca2e62e855d0e0f87eb0bec6bb03dace1ffb33859c151e2d982b96eba1c6c404b967f640a7a4f0ec5aeaf4ee4ecad1096a11eaa41969f802b9ec4a82be85cae68a9aa0cc8177caafa49223322972fac15d61d0da4668f9cd09856d9a3f8b5c511d274182327f327fa5c13e1cfe127622164df906fe4fd5a34e62ec8c524468e8461dda23f46eefd28e9d5c575f8a507580b3050cc551ec758e2b3ed4c72cc6557d5156eb2d3679f5547d47d172d5394fc0bd0a8e593e042976bf79153b7a7c5894af0fdfc3f3e44366b735a12577a6970a7678aa93b322f1d9b01f86171b706aac3fcd3cdae3f87d84699b2f5268374f37ab6b944538bb8425e2cb166aecf46a9489f5d73650e5d7606b57b7702a5b6f129a49f4fc7d134bb218236410479df43e7bccc674e127473dd75a4d55732419749143ac1599067f4bc6b7559dcac5b4e23e3076cb18c5827a2797be3410548ab44c75cdef6642ef217c03edc96b2e2bc2eb254e3ea749cdd4eb78416644890bdd6a7eb7a05a3b7e71097b666767dffdc88832d324453c7bbb72bcf102ec5fc7af4ac0b78f1da66774561927f5281ca0f04917005ed3da8a97f9c6e2c55577a34afd606e844f483ab544fb2ea6d1cfe2428b5ebe9f5181520c8111ca0073f840c772f260ae55201fce568a6933282cc1288dbcdce082274aa296c01884484a94577c44f819b0fa3b3a1de3367acc4ef167d7437a07cd1910bb2144a52bff94d217d942ee7f789317e97733b89f2c0ef455c2e3e2ffa26494ead49b6d2c5b6284da33118fcdc455102773098154b9fc20db65940a3b0239228bd84ef2c9826093c81c2813c631a31896e61d375c12db57f0a77e1bb01644a8544b436cc7d0f5e17accadb452afec244a7ef4728dd95e5d9822655161bb284f6d5b5f1294ebe77d976799ad7ba64fa589d115890e1b05a3b44f1eddd7032549fe1a67c17293af350d87a6c67b77f6ad82bde0707de1f540ce9deec98f8c37e2724b457580d6efd85b13d30df7670ae47abebf732d710281f9660283d8325fd790dc48608ca28072431e37b54acef75b503ec4e41db22cb6d568488e6a0e75faad15f391d7c724cf8adb72eec727a20db868450d7be0106d48e50072c8e4b5dc70bc5cead88633c7c21e6a9d41f67c675320342ceb648d80cd07d7aaeb145022a1db5ebe257f31a05928ed87a8fe590f2fd5b66e496cd05642042302edcf80b51446e4ee0cfa899a3fe8066ddf34a78ccc37a747a4446189f0d33cc927e2f456b628336a2b66e7a058696d5be04be159b1c347f689f636f34700c91913887d7932016537cba1ea0547670e800b3bd215f56951d7d20dbf2e199e5c5d34e663f0b78800a4fc3fdf7c621d714843fb59a06275ddb006996c75b08b8012f876e96aed8606f76d3b81d1ea071072f6cbe5496899ee5cfb0363d055045534e009ff29be7aab2b84feab7dca02ee77a77487f746d29776c73c1afb2d093899a3173a15b9fa5d774f6faca18fffd027ca30236d0318c9e8b7ff10e79373f94d11b949967ef3e3b677b0ec2130a0263036c579a855d8e7f7bc5e130f1befdded38b0e53f333a6f3d4749dbe6e40454ada97a83ae908c78b2b10f378a62b58acd310657e466a95e33c05fc5ab4201615784ce5a381ec7238680cd542c9d70325a8389777bb48513bd04f6fba506cc83623b0f3f9836d3c5eb5dab4610ec0eb8b5773022b9712275eef6a02fdb94ee87d0b0375c5bbc09bfa8695c8a8c49b09315ed6c59ca3e88f3c4e4d2c3f8da96adc87f2bea352a16b84c8e287a13e54d04d220228fbda02ed541535c669eab0d5aeae3dfe77b4eb0da548d3c08279134f6229bc14277ae490ceebf4e6218ae9a67f7b6c9751ffa9ac4b4be127b0ed30aa5e4ae5476dc1cc6e8259bf38e31020944854f3d52e835d3aad851166fe336ffc1002748b3f533de0571bb3f6e0cdf87a911191b63bbc427be42401ebd388a5c0748596f30bfdc7c13bac447a286e723774bc8d2ca04cb72484ea3c4979ab1fead66d41d1eade1cb05090b84d675f3458d0a26fe6b1d99efbd766c716dcff74806eea6fb5deaa0dfa8977a23d9511a556bbae6e35e4ee68c9a74bdc0dbd14059e7adaded7be8ca6dc192518754c69f4c5a1ccd1b1c44fb887b02e0d96f3c12bbf964b3641cc12e3bd924ea6091f156e2fd3d8cdd55c24f216cefcf05030099a8983bc2a5a88c872756172ff7cbabaee2eea405df682e9e5cd7c6369f6f9506c018e23c9ffebb9cac23b9704f9e9fb03dc0831ae3cd05c5f51e5591a8b79dce9342ef80f54b016a41667645a633043daed00a999a83aa3b7c4f626183726850215f778cb649d4039b2cf7f6f4ffe59af0cf07782d0d2d05d11fea4ffedbf4dc5cfed4786d37a38178de77ed2e288bbb10607881929bdd0599405c5861193d396a4c5f7a47cf898733865a0a83ee4259eb6b4931c3cfe2d04c4c1d49704c9613de8e01b86271b8eb0ed4aa9c49a4e1e4b5eb723a8ab2293cd536c87c1e60751621b58e74620511ec22ed7a9b394f45ff2a96a2fa353575a90600e76721f3214e88cc42e18b07310beb68de3f655deaad71f78b88354313e3f96f3e1becb5d860eabb16e3c92245233e1c3fbcebd6de335c756b0c8e1f8186db0fd8e30eec4a92adec98b5e9ae1f0d1fd49516c632b3cf3b665c604c6502d797edc661661164eaae2b0881a0f011dc0fe82fbd3356274d6ae6934468b0b71b2d977a5602b1d4ff0c81e8b469234ce982b44792549f697d26dfe92ddefdccb5d222ecc4947b8005fd3ae7ce869aeeebec631feceb258926235433a54045527d5fa66e4add417e2c7b9ffe3a656ab2656d43593fb991242a298f9993545375c9422f5b19e4ff4687b8164968037a6288eaf75a256c889b6a1ab0680dfe916f8782108fbc46eed65974ea93974c865d64d9381c38fa44847a242721b7abd6e11c10565ae9e30e4f56f709a936fc42be70e783ef89b7bf690240b90d8613a8b05f9d7af1acaa65ab1c6fa2a8244e3446bb9a881cbd53aee67fd5319df4a200a8c4173d7a1ffca6e48cc5ad96c7dffd056bb183db826771aa6f3a2ff5f65fc885fd44ac84f1368d50e625bf4c9bff75f1615143f48a876ef695a2bd34edffe2433d41487d79f302511a25fb255720060bdff05e78836fc3f2479c7c3771f066ce84d243261f472bd31e7036d0a5fade724da131a9026ae41968cbd0a5aaabcbf2988b9c165c4c34c0b6f451d7fed99ace0a4163aa38ddba55dda53407432ed811d7825207ed3aed509cc6d8bba1b861e014935d485d68bd58ac120ed4f3485910884bed358c35898e57ea8cc81ec68210922fe78bb52e1db0a8b9cb1f5efb6f855bc1b0d2fbf8be3800140eaa12b25ebc6db006bda92215d2d5f8afbcf5acebf9ea15d8af29c5ecc8a29fdd75d14e4ec2cbb59d1e99680b10d19395a6bc6efcd58af9a6af667a0f6b2372014bd45788623513a0efddc0d630acbb9ab8b8931f251722320977c6de61f4bb0197eebf74903091c39fa2220bedd804e1111ca2c1ab71f56955a9a5029016146885afb83550b94bc2e36dcdc43334670e1edee8a4cec2475b327ac6a6beadad763be080c6ac765b9081649c1df5a1b2f6eeb84b4e4cc9904dd07d783b37dad067a156d19d1dfd9c7b6987a3035c2fd630ce2507d1377913776ff8bd4b1288189c949740c968f2cbd8d471e0faf91aac49bf531b0b6bc49d0483af1757614fbdadab67343969e7f29360ddba4db85b72398ee0cf2f5a07dbd4f2c83ba661ea61c985cd2c771f13aecfe7e50d44e6792e9cbfc3189bb761605319e5270010a187f37044af9cddde10df21b0d78778b05c4d74f7afb3d43e1dc4092ccc7ab8eda555dc379de77aef205887e0617675438f3cbc4fa6ded548307f02c000a99d2776a8a7d9b4aa89a0cd386258fe4f4822ad29d0eb0946f71b01cbb005d6c3a3fa97cc05ec1bb8200700486caee22582e1763ac4fb1d47b29a1b60fed7ba2c15ad3881066da8fc186ab8fb95d72d3340c68e62d86f9fbd3b31177fa1e8c3fc759162118dc4f1a66ea2be258f661a0305c13d0d283644c48876a1ae7eb65df37499a69d8822c942b71c94fbf22a8150f537606e7319c548d076aebc128623fbc9101098498c1f7962f07bbf0f1de2e73a289fbb38e7a619f37c06aa836d694411d24e1d082443b728d0939e6d45b17f2b6108ced322b52ccdce252a88a12234a4c17c623454a5978f509f0f9cbcd5b7be00b97c14c5408343fcad40941f77bf29b7fecdeca0ca7b5cc894c9a856174b123f9be36db3373fc71272283654a0e724494a3dd2783915f403fcb22d850cdca39e7e7f862046cecd3cec1c6b3215465da0b39d31c300f7a71e0027b81d1abd0f0660c24bd28d75009a1173f73001f74a9b3b980225f65b1281553e4ab5df2f4b1efc94c61444fb0a561eb4217de0c93326d4a262bd0d924e10955b9541a15be93309e0b4bfd97f22d2a90f8c9d6b0661eadb76209d41ad2473900559b351dd591248ec645e92516ce39568337273d7c01bfde0b8acb32643394719fce85780dca5d717ffa85bb93dd4fbe51cc5efd186e0ed50af8e06db1c3a44b4da686a613119cb811b4ebbc30c25a4edf0ba1726cdd9d4764aa19a80dc1f9ef536d6a57576a741e628bc283e7d7bfef0121cf5e43a49b2ea53e1bcc643b3ba010598322f66b2545a08a40ccd38dfb0c4f242629cdba9c98073fee011191fe5924bf78854af33b656abc2b3554f3f63c640bf9d168c55827945683e18c997c5b0d1a435c44a165dcb3695ca73562c2907303e98dde2b4cb8ff5ac8767ce0b27aa9fec26564cd3eb5b2397cfea54a868439544e5ef189b922bf64681327cfb744a786bb2a520fee86a3faaca28645d6b7627fc3ca6f6af736b6b63e5f628523dd9fa58cc6c88609abc724bd58d906232b89c74eb899f4f45cdab4290461fe3474d0d3be9d7c102a4f34c380fe44a052f111b085b5d07915f1f7d493a559d0dadddb38aa0fcd735e50b641d7c76e8d93ac32066ea3062a1e902da7204f91d4ee8f3638d0b0167ec05f7f3cca0d14ab3052b6e2536e23d226a39d2cd6585b3af8b63bd29d45cc1327e5ecc7629e636e8ad4d275a50c925421e77008bebaedb5a34140d54a35744ce1480d6961d35f2661c7acb02f5457f8733af55c05547a6f8af269ef84af059f5cf8644634c7b628998378d8204d046abb7b6512e7a529c553903c86fc00c1f671f81d004e04a7f05f23dc61fc8d1c471c192989a835c10e800d55e0f89fabb771530f78686834693626effeb81f7ce6bb179da7ba0fd5deaf6cdafa4550e124a1039764229212819a9ee2dff25db0e61b10f6d9b55583e38575c451fd143e010ddf95169560118fa9adf78ff36b64023a045853f12c092819d891e7a38ef921504ee8278a3466328e03544ed13977018f992cdb95654b3cc9d2c95922455546fba1d6fb0cbb7357e368711155abf1c1c8a0618d573304b2bc2c26dba67e5f3dda9b66a278caac0574402ce08e5d0ca3e9efd426908ae130948d65ea8ee20da515ef72354a50179ebb52727ec315398f59fd454d33c982d697f0c147488145e73ebace742e802e93cb92e9dcaa91b186c04698887e825ad5b1a20e940bdce8d32cb77eca7b67c116cd2680c0ec918c73b16fa77af74a4b3a84bd237566c94281b274e34e444c44788408bf1115904189753f7c2083d8a3bda0eda09359a74395130b86294b60ef7779ea9e1386521f18d76279e3592b5007dbf7416778aa81fb660959b1b9bce8ac6228d4a985f0a7dea127a30ee0db5046597552c3ef99d9af0dfa934dff14dff962413657db1faaaa61ba29e43432e2fa9bf22758587b31d3bc84d50bb8cfcc31e81065f4e52fde77e31aaaedbd3bc94a136bab5a4249f8a6c9c1edd475f7d5e146f0800ec702470f488c3d7fbaac3aa51dd326ddc7aa525f221224372ee35f49e58e398e5cbd4d45fd1d25bf5b1026586757b91c062674c01be39d08c077ae61155087cd0af376b170b00616f5a4e60b8586eb1ca370f714cee8f8acb4c214a4c654721f6516edaa093c586546f0c328fc5dbb3679c428de4ae3a07463f21e4aca710fd24d090f33e57d2529b9f3ea22ceff54744f9e3fdead4a5d234add274657025dc34f7236968407aec593d8b52b1cb69e2403649fe2fb20aff11d216d161c8d6e4ba761da07aa64b7bab3c5bc725edbd9677b9d0c5fc9ac8ad22e7af25155794dfe956f5b85342634964c428dd1410dfeab64f79376adbc3beb3b9d30dcd2440e87c7f6131760be163efdf4091e736ce89f271e9e94a6385a81150ad7533dd3e5bb11279f44bda6eb0438e71cbc0fdea9ea3f6c2e104485c0d27330f12a2ba3d2f94a69aa7b0c8c9cf21af6cae6a8ecb9a4e92cf081f1b6945298be8a310e4b72419a7fb21928e00d5b1d846ababe903b6b35588c1ab845ea3288a118185a88f7c51d6a5680d6d352aa0e75a0780fe40f653bc628c128bdaf08b53159afa39aef555c04efe38570bfb7465fe9096286e29350e831f62adb2f7bd6a593a92d69da86e8acfd14cd1325ed4305e6490cd07c632a666d9b64b5471741f241d0c681fd0f79bdd8a6ed634e3f522ddd0f4908e695135eb1f9a471683bb618c07c7b1f03f04b4a1254df32a168eca19485c4d32115c0e2624488ef80af08e44cd0fa1332cd3840895b8dcb0bfb7881d84bfdf6e5345db5c4b19cbfd486fa40b068da5801dd77c679eb73f612ca55d8c451357d4dbb9af31a4ec2bb0980a6dd9e4bba2642ec7a8c735ce23fddb6143f71fd813f7528474a0a874a3156e5cc944d90bb48218c3db3542add8a228a78c8c6fb2694e0651b55874afb0e306765287689098ba4a074a56f4265ec3519b1240a94c03465c4faa8488d336150d749f125ca6f3da0210f6764ade0fa037657b107777d9dbf1ffacf63073b5492779798f431995bd61f1b2cce65b1e62478fccd96b3e0bd2366606e6b3144227a0d71d952208b5dc0c323084a8860648a481573e896b9bb8b2c20cab5ee01590ae757cb8d50287041fe2c244bdc8c7423d536ce0cd001a9ce0fe30ab7f2638d40f9c9d329bf32f06b50ab28e98bf3c8db10330486b9bd14a83b1159e7a3b6026f2b7965c49496446e0e203d5201c73239c2e77c60a871f0a828cecf5f8c5a1f0f64daccb20f4c7ba69847ed26a3914bf28aace8c7b1eed3995eb83e56038f53c9f6e6e658a48f892602aedee4760434cee1378e770692ab3a8e8be8c24f2b7f1994ea4d6ec6187428a2e5956669afb114f81000c8466836fafa75d2173960cf450a9d45337c1004a0a716db1f1fb4c85a04ef71bcc3efb44f8866e76595df4a08b9fa4d26825964ac9a3881551035151275689f99f542cad9ff14b3a1ba335de1be94b6409c534bd4ee6d284c9cd9d6ed15325d061bde73d53058a426a8455644fbc808d56750b2a2bed4933968f667588988588847e2330894fae5cb1e38fbf849f3b1acbccf869e3c8f08cdb8cb808071edd0f5d4b0a9f4a161a18ebac254bd3421c61e5ef4a25e0d59fb4264b26750188949ae53cc5e68bbf99bf2187bbfbae71a0d09c311d6dd34678a1a4f084fabcda8350842fde341d728616447e9a096c9184d7176463878576fd5d2717ab48384e2777cd40ca7cbe073a074d345b5ff4397dcfd8c9b4db5d9c7fd6e1032c45a5905b96052227a0d90b5ba4356285c506f6f1111c6fa5a4cfcc564c3563378c81ec11799c81a9511f5a7b2a0bbea12b12a3297ddc4429c0ffe9f2cf12bb285bd586c27149f38a9f443a7802c1c040312a17255f8cde1caba2d136eb8ac94b358434813f37b30ade72e91257221da042f588d6aa28fae8e36a68a9f85ac901e596a95d064bfa1e6aeddf3df19d2c307a77cb9a5ed51ce09c230b2100bbfdbbef193edae38a0ac27e0e282a80075eaf8ec45f921c736f86f17fab2985d3242c49b4fb55df400996b3beb077de81fa472a50d933f0c9a3760e4e3243d2ddb57f75f6349ae254f7f28a2e25d8cf6ee45256dcdbc4ba12762d91c797486f68a122eaa4f075a3a0863f8db47b8a30c64027be6514cb77acd3f91b9bcc1a1aa90be32d6eb8dd89752efc436b3c59f7732ed685252995147ec68b832250537a06e053a17e8e3bc057b6fa602ce21c442ad6ab9f4bc5fdabd6bed9e03a3becf28fc9ebe7ecf5ca292dd5d1810a8a374fa82f5ea75a97015f0965cbd7ee30ef536ed15fd2f1661d586151c9caf4dfc67c34ca255f78ce4a8ebb69d5168ef5b6a0f7569718a754e13e0c913ff837e36afa4a59ebf267011d77fe3f8bae31613f82c5deb3bda3cb337c276e6276da89c4c1eb292305fb72fbe39b97049cee50040f34c18e826d2500f7712a0813b9c945945af6a1c5127c33b66db1106dd26cf1952ccb11e6990b46196b9557cd7c1dea60e824f7be7added62b683173578627d5a3f7fcbc55d7b2c46577fc4a1a896aa30e38c1e36f681f216cd2b5fb52a522d5639e29743ad85d1e6c3eda7f8bd148d8182e395547662b942635fc9d0529912f2c328aac3724e63671fb97302b416107323b366178a0794d6adbb42a5798ce398cb7cfe15ef5ba1bcb6bea0bbc17eece7f26a8be5b284189d4671af7462f31aca870ef12c83b515bb3cb6b11088331de35f496511120e36ac6321120dcc99b1c860b32183cef06aac6c04427682c41a54714b9aa853740a74d70fa6cb582f24cc78e8dd9e9e5ce0ffe444514d9ee5ba681d117a7e73c0d0808b29be8ce60aa3f80b7d37ebb87f98c5c22778cec4c40e961ff2a5e7df93fecd712a9787d0b144adfd6c46ccc3349377628a4f11dd910c026d15c4191001a4c672cbb768f19737e457e0c19ad4e1e4d9587a519d41b52ea3650591aade3438425e6cde0453dbfa54dbf3cdd551a1b44d8c7e611fb54587779d1d23196d7de6448016195a65de0e52c7d3656d2630fefcf3ad026199cc1ced4b22788169525c2e221be4a40188808a9702b07fe833789aed33eb22a1b3a19a0bb4ecb2e309b398c6cdc0ef54569762b6f03154bf571ff7ec5833274d1779d9114ee620c56bf64d8e5ed7283b1b30b4201bba84e4008e1a8458b1238638dfd3b46292228d613938c2dd7d6e1079f848a80d0d2f3ae2cc2d7bb8366e53e6d0c00a26251710a891ed94c9125d7294e672aaecd0969feff008bcbc91f1dc5a681885f44e517c5502f086b24e8c94d186595af56f6d077f748ba56ad5ca2645373a6bd1f29ae361eb09251e591aeeb8557cc130e54563f3c26892235245160d025a642f846ccd29d7160d4f5dbd013788d14cb4ac16bb4596bb92f146f1436d2f1dcaa0a2538a67b29472acb0666276ea869cf2866d94c35adfb8a49fd1ae9d2b1f513ba52aa630467e24fa5ec3b17a3dee4473d204cfbaf3a7ec2e722a2e33cd758971d39f71d18fb5504a194d1c302234a6400b637b1d927b0e2c81f147fa9ad0777592ead772c903205dceb59ef465db837988eff44e9f56cf4f51c65ba41ead7e8082b60838fdd77fb3da7fe5533d8dcc02302601a0b3ab4b7697eb24d67ed809dfb8ed7f93562e9f0bcd298e38587913d8044844dcd4cdb53e8192294c0694b3a31615ab1e36d937d5bd90a463a6bcf4a398b832d9bf9ca8214af8a96cfbc77ac39f97993d07be25eb3d400623061d96dd3e66c9cff10a18eb3163dd1b0ea2337711e886d6810ed6d351dc2fa48aa9ab062551ad2ba718e9bcb73d795327245b0ba675b6a64381065530a4ee8afaa7dc0f957b8e75bb561ea63c8029d33c4a775c6d250141b9bd7364d143f3a215e83a7738950ed4c902f078d7f360500c0467c489312e6eb3938f1ff836bc6f1f437b136ae6de5e203941c760c0fef00c83b240712e761fa2805f225700ff230976be65fc83c53b68bd942b51532ac910d01eaf95ed7471deb32892330f88cfa062580f8588aca5ed9f63652e204aa9157b19278e5674da9a3cfc1425fb68a9881641f33265ae8ace5096b5e9fecc5150f50f34cb7756b323c255913bd1275d32869016ae881cb7a467507cfe634d562a4d67bf62b6bac1d054df06459e8020d9f8358f912e81cbc8db3066a03fd9726d8f7d120dc0d171ea99225c7b8a2a3ce3ccaa3412c47111ba7164d2d6d427c196ffe3c4488733422f6ab750171ff963c0f9d698698ccc24d4d92460965a57e7adfa1d62a3e8f8bb12fe2bef25cdb50d6f98b572f0022f71cc697f4e08a59706a9015eda26bdcf463125f7e9ee728d49d2e8764c2f740b6a09889b9558467559001c7f82db78ec3698d48ec2ed77bdc087e38b470adac26872783a5cbcfc734a992808037d9f576830faf44bdaaaaca3b8753caac8147f221531a2060488b37f10a7e506941e34b0215c3de026ce21a039dc351674ea0a5916fbacfe43e06f0fdbeb3128140639080c5a8ee6924dfeea933f59ce09e175a1da369fc6d8acba4c6a4d56b9457ba8c85a91a51808f350085324da5ab8b57d3d5c3a9cb591e04830251ea2d61185cfea8c0d5988073fdba3fd62722d6fcf5d0cebac56608fac9b76f803acd1cf2e0420c20a4c44c71258c9e05e63497715ee06576b7703c9061ac0e4e1364fd93ef7b40d2c82cfee3e251954b6f8e6c9b87968ff42ec00427569319f3acfd8860dbb8826551255b0d91f722485de8239f7edf6a1e7b147f904b4de15f899a0860f4fce7588aa8b7f412a6f9c7f33bb94c28bb96a65e98c82f7e6319913a7ed74c54ac30cce5ffab307ef7d45170210bcb25eccb17f06bbda59041ae77f94cfa21f159f21ae36732184b02f03f66bad8813829762386ea4e5f6c4854a71206194ec92d12a6f8e935b3eb68f6b8a7d707d875cd714ec17b33582edc68cb10e776bca897734202da78e07674ca435bf1775bd12a688e938672a831222ed8f892e6b209242012ca729a7cc2900bf3688abf3185a74c6bf92e7447eee1d1dd5290a3c69eb1fdf58b9c5cbb9d6ba2797df596842dd4d8aaa5aa5ef264f8823bb94d0dd4c904e997a98318d9c8283c9f743e75b77e6ad1cafcf996e9091fb96b05d6e11eda389067c57d7fe2edd9d90986fcbe7e20caf5ed47ad44c658b517e147d8798dc7cec9fbfade3877bc58da23f275c6474254bcaf3f7e4c9a3e08ed342b2ee79b0bb7cbfa2127a38a60e37f1d19bba317fa85e2e03dcc362d9ae62fdf5927c98f60b851b61a55516c799dd81c33c14ff769457de3102e671e974579ab5146dfa2e4cf30eac4872f37eb4656ba9b0f00bcf5b7d13b3668135daf0a56a7e813af23eda7af1334ec72efb0aeeda41254d0652420a2428182b16dcd3ccbc66dc0a9c12311dab96cd51f6753d78572905861c7e6e2f7aaa2d6bf62874885f0ce707ca8ad2d3edc6afce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
