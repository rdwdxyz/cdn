<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75aedf945969be1bcb615b6e8c7c5330c59c287c8c2ac3847a93c3d57eb8edba73b6b744d0880a3a4071771dbb31b3132e5d3931d6c7ae2dea8d35eaa395ce3829009e725b813d6d4a7580e023c74d88e3f827f0cbdc97b312ffb64b3bf8a7b823fb92a0f60f30fd541250734ecd0773c6bfd654ec540ee06093ef3a1040bd66100c8ac9778d54a36e77a4a38915a4ec3a344cf40ac61a48d4330af85a56d5b710f0330f624354bb33bc32e0a0e89fa27a6da49cfae839ab29d0d9859d2c109734fb652961a6b9516b0d33bab68d9c25456c28c8e473b6424c6d52a8a96b51c30d6a6779a93a217eafbf6ceffd4d7b402c2abba72cd596e593e9cfe912c0e62ff33aae4a347588cc4065d9b90867cb4d2a52cfaa94e4fcacf6a5da0c6a48579bf31e8f3b9f76935b7fea59a7db129014f0e9a9fd9be03982e5012f0b39503042e84d990c04a58a16d43aa35e95c8be3193c7fae81130cfe0ccbfb473718169e6b0f3850b785e4bfaf877a63ad82dc1b01a0d0707375e7f891f11df3527cd158f5cdca2e392b666409933bbe69ce24312b6eb4dd4b936b99bfda3617dbcef34d8cfa40493fe98f940a50a8507131e1ee5a8fe5a3c1cbaaf422657040ad91d33c4a3f88637fb37440f8967c15739a489c6a129e622828c12cb8ced2fb354da47cd4b9580866fe7cc90e63a42a85faef7b06ca8bd8b7b8aff52f18ac70d3174bab4e5394af2f5ee24384adcbabea2fb8cb66b29e6680e324e11cb951dc77e1dba1ea1d43b5074502aa2947e6cbb4a141a50780ff055e0155445cb69b09b735876b756ad87da64a3f24310bf2ce5a682a33f47819c921e496d45e4430de4b027a6e4d54950ff843dea7ba7fe16603930a578f5a7d99c544e9e7eed80ba6052a48c16d57eaefd55bfde76adf76cdbf48a58e785d43eb5a19efb019f0175425b02aa47459090034e2bedf1b4f8e33751def88bbba4c6f25420d8712214e4abeceb8f57d3530c66fc82d0e1ab9aea3da4c287f24a23374eefd343dcb16ae76d73fd39a295eebd50fad51f6382d7273dda7d2f9e5ce140bc1d79c898df9e232fce8b21f390e99d630cbb0a0f21c1b5fcb991bdda6b6530277e7b20d183a652d7549724b66c4ace3895f75c09ab70c74be3095bdc0f4e94c28b1c2ded7d67c3ac35155fd9b128be5696a055749b69555ae68b8d15ee888a89b85ae7a9963db37dea21941907bddc577f0445e23eb84d18a7ebf3ae9e74fb79e5e0e481f4e616d4b1ff1b8c232bca72fe593294ff2087664d58e5ea9c93c7d787af5fa9b83ca91f89eb0b5bf5574f95cdfeeee451be2d4094f64c4008387af78defd915ffdb92566a013248546acdd5aef9e6ea4837f02d12d119b5d827af5f33054597890e7a26cbfc7fe0ef7f7193bd8b17531cebf191cd99476d98cbf4e0bb6b097b91614beaa2f8e4895e4e30f6eac28f3e517d7b3c199c3c09fb109d5d3bc852c5eaaa2dcae528737a7764bd43f69bc839e84f31dab411ef6ce641330c74182f9247dbc4cc17c1cf8b6b9e3a25e5841ecdc692bdd9c1402d394d15a25a42a2296ff4148dd7219bb7bdb78efa4e8a6fcf0fb643f46f6975bb65c09b238ea8cf1c808aefa510ebd3bbbeecea532ab87c9ac9ca97e8a08f82b93ce0ca7be2df602b69227a304a3a694ccb0fc09b72f9d12e587305f39857cee80d24f58001fc921bf98eb02f3cc13e9633091161cf76d1224ac4b6371e17045b972ab4c91386f5b6ab2f77523ea63b0dcd2bf3db45b35598c19ff2a65d6588a06754a67624f011ddf9d085e61fd4738fe826aec60d442ca2c22761c743f0abed55d9bc3d600c22362c7a1a2183a904e98ff38e585e73d199adb08c5f2557a45f0ab7904c9ec851060c268d16264dafeeda4822d8ffb2d4cb5227f7fd06507fd65d7d982d9927d1154dde7978aeb7b467b6e8128d3b03739488c2dc2981814c29f3a2f96459e5cbecbb9c09387ea2a4b030850fa6859376e94407e68fb3e37bfa8bb2bbbb78aac826c416b77c144f2967d2fdb865c216a3e73a176a77ff4dfd802bcf12b8085f14a0b830879cd06f7367e936cf45d05e18b9b20b70bdc64f5fbaec349cb54fa225c23dfbda21fbf2d35cee2b97728b660d638a1cfc2d84bf48c4b8a864670080f562a013ecbf9c5aa29dd8baea22958c8a0524f8d9e0648e2c664f6fcf802301fd4c80031e3b0ff86fcb134e0411aa56bdb1b4620750251290886710d285a0951f646ca851a9f8712a2404b9db90d36463fd09ca0cd027c9b6baeb4020e059d2cdf8925a0b967ca45b50ceb917f2c8106c2c9eb60ff56f550a5cd0b801dca40ae71fe52d33da7499919450c02ae5f173cca789d8c74a0fb2a84a38fe89edae8b4392263a58421b7dc4d7a7469eba91121ba98d187478bc763258ff624b8eadcfaee23063724878716d0a0f0443c3504416b108aedbc807704b79394c4394e4ba32a8e66cb4e98e4eeebe32807666ce9f9d057eba835d6a15803701558f000d7d856590e7599645e118a357c4a31761ff5ee556273bd947bec18f4f58982b2fd4dfaf38cc2319a3aa31afc13c6b6280d927cf18dee05b49691c1b5cd51e28537b8239b33ae69ff204193e8278ee08ad579155b696382984e14be619f3eaef3ce97d4d289708f1c0079cf3302789701854ba3224be9368f3ccce55f3bf1ff862ccef46f97381f82fa78235d138cfdecf5f083aede64f892914eb5b8804fb60d48acb940a6b597ed61f7501b7c22f4b257b601e39fe7203ce4d4a11b6984110523ec06662a4f63aedf0e034440434830fcfa143544cfb09e0ffbde89b5e5533996c5edd0aca4d5b688c044e38aa6f134399871b1e7c97abffb7a7d647fbacb992f5f96cb42f0a18ae52c407c0bd9bbb36ab9ac5b0d3a86c2f6c21cf02b39e7691c9eb0aaa19a367155f31cdf7627a766aa508999244961634d56910c4aa8d0c022e4522e141384e9be68711f082ce3e2a7ea149b3da3169c043282be9e6fe9cf519b7833731e0b9365225030362be5eff3f1996890ea79898f5c3eb4443d974b1f9983515d3a925f4a7faa0cb879e82fd38289c93f29d40c447659517aa7f474cb31ee58e2ee7a568d3b2bf56fcaefe47f3d8bfee5e2c8fef518ed54e8ac3d3eb0f9ba9807b193c17e39aab31ec15b5e1d998216317f278250a0d77a2c8e461a21a868c2fbda9521fb0aff0cc73a8f25b69c260e01412dd9250a034697cf9ed60c5fa49a45a0594f8db4214c634144b551532ea2eb42ba18700b4e724ab11a1ee907b84c131f3a7697603dfcc2761a009ef9e00902a9a27709e6e7439d18bb3a0577bd0163a5a8a5a24f7acba0c05a930e185e4de8fc0bb4cdb8b6b2943d1558e8286c87325357cf46ed50bf763ab75ba179e8bc2b1e140125a6a482ecf1d1a75954c396b1901208360d91dd4a6b9d1d61933e6e8e4143febf7e6224da9ae57e74c6155d4f43224e2305a2c40bc48f69702acce267afc26afd9d485c1c35fad72346dd66ef5d1d1b5f693309c03094d86ecabf18dfd527b81bf3f077bfcf3ac5266dc5082b72428fe009c61cb04683229a99d50c0baabd1c63008618503dff35198e6ee8f771f05f1ec762947497e971d6365b5790e5ba003027a499f5b0b91a5049e748802b12ffb47183b285c8a294198c506452337deb179c724d45405068790027c4d21f76bb35b59858c306c09314fc60ec2b74f867b1706658c670d5851c71ef6aeceea2222c121c460b71a4d90e45d44c3f921050828def6aedf65bfda71352e6fddeb459fb67ef8be190fa13a503c35a582b1536b642605ee313094e9ab44e28f9c6b1398310cf1f0140f929fa7693401c09e134962634f1538c36fce0b4300e7542840dc24b5de9f711ffaff41147630ff258ca03140e4f9009a5bcca59df319a5217fb5c8bb33aab2ad29ee5c22bb7fc9bfbcb5a2eed11be46a6e75494a144de109152c07bb45e1d80e58fbec6761daa06de50a98c570164eedfcfdf15d55ea528d3a776aea3c6535cd5307a412206a5d55efdf72854670b2156c0ac50e283e1c851f5427bf435beeceb3e56681c6675d8986bfcfd17140ed4cf60521750128b7a0d2737fc7b024b2d061e1fa1779d9704f8f177a501d8636ce38fc8f792a95af82c759814ab09794aa8d0dab8d92df5e6562d07dbc036f1d959779ac34a5d928dba0cc650549714d2736d03fc3957e9329902b5f6d7e886467c3509b94af461817e89cb1c0c3e8da112e59503b6ba5a371cf0b1bf5d9373603330d954c693f14eb0861930c4b676e9e20b66a47ad5ed3dbfcd7d42cbe292a23696559c5d624f7dd3d20142fe954ee72b5dcbad0b0fcf7b79ceeb5eb827790ee136051c8004b61af68d4fbf01621c6186247d49edd8ace32f2f086080633b0b52ce713a4d7d73bc8b79dd99787e89a1c2052af7731f2df8276595a71b31c116eabdea255afaf3914f9ed8421e915b4ce908c65f399b96d8ef795475ef6d69c8f1b081852eee827c86e3812a69e1c91862d06fd09a0a2265b4cf80a010e8a05ae2b494da97130f142764bd27cf6e9a79607f22418d9cea68f8f83ad1d0f6a000b94e10573a4a8822e9137fda8dc3a65cdd0e419f3dcdfdb2868d3fe695eed3992bc2e5e89e11b05e2c689937980f1863cb664379354bf3807eebd7d813fb0d786bfa4bf7abe3a376af0e3b5e4c87c06813233af648046670292004061490087fb8f234e122d8e3782c197515d67e6a321ad3e351b31745df0671411e88432848f3c18ed2b20f120df8a305bdcdda4cfb4b539e2d7b18cba8625a7cc8d97761e4ea11003c8d924a595b59f7fe34c7aa78104f4e26eceb618d9069006c5d1fc0fa5356f75d21d91c5fc8775fe52b3ab3b47f1dab5bac7855196a743ba5fb3701ad27c61af976409db507cdd9aaa4870310c4b45b75a4b921c6870047cab7465c4006a8a7a46ade4a526f8fe73b4c553e84baef3c293b464100a8070af3ffeee7c2a6bff44593ad339e537ccc7524b6b9776361fc2fb18e52f182cc5820971843f01e8fb43cbb28cfe6081f289e3b2f66b87b52df2980ce22ef58f1e37ce7d738b09c66f596c4f4e47b536dd549167fc5c7ceaa77a80529bf44343ee6d5d943eb0a87c4158d5bbb7e81329f1db0bdfef1cf74139c0fa1de8767b10028578ccae71962bfd4997ef653be4a7de89d37a0f33704a81703b7db0479c7987e5c74a2aff6f5e83f39aa935e609dcc35c4db491a55349b8c3839c9a05ec7ac47df9c1c750351dbfe52cb7c29c4a9df40afb9fe2c36ed87f45a0ead2817ea373421c1750e25c36f9e4745339a3284c64531635de881b4d48e1f03a166610acebbeb6413110b5bbe19c20672a584432c8f0d2dc95d1e09e4756db104f4af4105f799b40b0b66a3f0365df2db0db872f61296ddfbb77ab129544a5e98a0cddc289eb64c6bce732db784305edb1f236705d7fa2c5d5da3ea064f1546c5d4fa36985fc23c1f92d517b3dbb765e367c16b80b5852686df9df8fe86a4bb3254b7af145ccaa618872c997ddc2a48a11871fd31312693f2d4505c30c2223f2c0a7226398b7c4cddd14964bd1dcb1dbf3ed78f5c0d19d36ff06fd5cafae4eb37ca39849634dcaae186219009fac677fadec86a755c06cbb9d3e89550fbb286e5dd3208dd66c04031f832d861a0b2a08cc8f1d1e4e6da4a4557cc859a7fcfdc2989b0b79d6ee407b5d7f5465408afde20b22f702d42039a6c7b50ee1844a23a6e2c1199e39a421a54b648073aefc5b4ab5754a33602c38d3c2c28dd2e6abd23d70b6f68e37e05f218fabd09b9ba38cce469233b6a22bdecc9be5a085460d0e63f4206ebf248aae0b491b8bd74b99c124c8d804cb6887c761934bff23b54c6ebb65331890d07ff242233ffccf78395e3ae3cbebe1da3b68378bfb90f341a06a7777c0f2351043d5c2fe39edf7e02ff9086d7193b1b2011345cfd36ef19ded847904f9cb3fdaafe122dbf46d4de8bc037c2679919514d4272095558c5da4ff498ff681224929ab7e5588b9d91262fcb46753621441a5ed946dbb89432ef1f8cd360c860a877853bd3faad651ad4510c6182f4515820335d47c162e70bfcfa41e7853f0aad458cfb7031e08c1d77718fc5fcb40de8294fae6533fd29046e779ee7625ade08a987df15e88855b0c16815c93f9c73ed743bb401bec1cc7bf37ae73fecdde5753b362395f69938f3bc58100fc496c9fd345772aaebcbed5c85125fe63fa5eff3de4d32b86cf7bc3562d86e6d4f15fbf565f6bff74b7a6a5259858cbe1a6893d0fd7ce397719caf720a764a571d375ed85a748635c39aab8b0b050195737ec9f67bbf7ac301ad3ec4ce9b30db095f317975c092fd071217966c92224186cc567e2d8a9fcc1fa5967ef8b469f27cf837ade8578b48ba8388d4cef8b5a63a971d034455bd71c5cba0ef401e7cd1314a094454294efb61f5734b4604d9066bd14b1ccaf51f195dd2c5ace700e7509fd576393b5b0be3c5faf35f920eccb3b333005ebc3a91ca416b98a8810dd4125b3cd8ab0c3e1f1c9daf5120c82595feed103c127a5ba559c0088e55d2db6bbbfb796506766eef4f358e67f9c97b319f0f061899277076e2ef8440911c283b0544ad6478e2169cbe00f5c53702448a9e4db63d3c108520a3d6e7dff3e0f6cf309364bb457e8623c684ccc63b60ae26541e32deaea918fa2382cf1ccf3311d80afba4faca5d1cfc119eb3350e5c965c4311abdb722e00c421c29b8a35c169426a44ecc31a7d900afdb65532708d7ea417822dabf64ab38339b3930dc4a96be214f258eba59f0fc4e00c8fa789b2fe6f9646bc6c187912eaac87a546ed97ead53b28516d04e14038c9aa4d0d73ad3930426643100620a8d5eadb62e0cc63ebff0d638656c074dd2601933b10c2c556d830a255eb8c33b89f3f557c8f199a500d91eeafcbff8ef36c3e4a2bec9667769d16266ddbe980aa1520df4feba9dc89c0867b1052329b85d2c13b769962ba27486c90046d83be0c0ef578296ac244b1c41c0b5d80280999d2d8495935e4773998519b152e5e47de6b50d33aca5e6c26f1bc127b28537bd693a36db227a7a730244a0fdd6808bb367bdb4d757543534a82f8fa6975e3cf45ca2ae1246e0292789edbfe068f450202b7f9b72c360d366baf1f38aceee515700fd66be3ba819068a056765cb47964a68c37f78f4a1439bdb47f9af8f44c841a4c49b5253bab6d1db94576bc3f5506ab85885008a316d7374ca53f7cfa697a6c2375e2098b2c961427bb4f3dd55cad5e4753a6b567593c01833b5d931b9250c723216cffdbefc1d44c64ff2053f4a9c83004fe9cb09d5a336b6a83072cfc3ad187cfa1339a612207e49060d141c2639526db3c285bfb650eebe979b1dbc2ed1e53c598ee156fcf076f101cd42ccc2647c25746a94568d12dede05a8b7311e25a00e702b508a769a60dc578f5e1487f8656d3725ecf8ed16b9d4492efcb886e1db8d8133b4b0a701faae7d9b321e51d1df4c4f2cb72d600ee3a3d403daecc3fbdbb355c2bdae46df97cd77a2e9417a5fe6ba10868486391a05b06051d93267c54b86081109b74b49884267c4504023301c72307ba84c3f96f9c8d7d4431edb2fb756dc3a1846c6363cd1748e3ffefc5af9311dab4d28d9399348e04762e580cfba803e8207f3a4852cacf498a7a43ff6a04cd5174083262aba4f99de16352849649a6e96d6d3e3256c6b8288a2e5e66906c771aa0b34da318153e62ad9b093c47d6f134c07018f15b00c4f504822de40362f4642eadde1ca9b6ea823ddcd8caa1890b9f5e504fc1d5f0c3c0037cf49c5458be42699c43953f49c64a6c75aec586d578f707e0943c613049ea3916ba34a7ca6ed364d5a4dc713857402b860770bb8147f3e25227e4957fb501619a5725c329a4b9b8598ee0c819208ef87608b67e092b2e0c9a04c954a76684bc7b8ebfb1e53070bbccbd49cf53b8c2fa089e87a59e4b579167c03dca0ea6cc30419bca0bc42cf1251ce3a56159c47eb88926bd680cd2b159188c14ecdba14d962d323a5eadf432d60f202d41516e0ee2312c04dddda9d5705ab56f4d631367ccb7faea00f198d537f895304558ff4fbba086c6800adb2a205b521b29b7389f1594de20599905231f361f9901cef19a247d57512e59b83fec7bc5d35d8399dfd97a9e521dc9f5830dca43081c8a7efc8e01edb37187a233b9b5b7ce2e48d4934fb8dd77b2b8b5efd276f03d23d2c882122f76c243e0f37976133073aecdb37da3025a66769561fad41975b7bb6e90cff2929650329d2d3bbdc4f8d7c2558d351f269b5e4de01321df9d6d431416c9e6d1ed3df0d5d624e5f5df604a76ccbdbb7fdf2eb881da5d84f0a713ea7be37b5e6bd839b3e63f680155a75df7c8b0e8e5b5c6bdb67ab728e0ff2ffce5ef0d7bc5d77dd4a14269559229089abd00c5e0767e605553384296e92338be7d1585a902530cec0dea31bb26c956386c85d3c5479d3b2ce2269e96b4f2a94c48cc022a679acc39102fac92146639696942d0b19107c33e85b2fec62b8faab68afa033939881955a71928a467219f75e5003efe2a516c87a468ce20a4d396bb00764e9b66203de475367d920e3c30d3590e046de073f30804dbb0a5072d49b833c23e70625af94e9d4eef452b6d00e363611e3d54739271700ccf09c4ed4a608327de3510f35d802f978f9b876fe361c407e7992601968bd677a44dd0f8600b97038c7c3803e4f5c936c625e5463cd72f2d17ebcd6abd3e4a999483b37d705982775f9331c644bb79fc610de322034185ab589c89a3589d3fa15a28004324a1feebf024985e8075d2e7afcb644d6871563b23d4fe6f81fba0cce6020badf043992658fc8bba9584c1d501e48e0713e67fc0b2dab32fcce7130ae004043484691948e710dd381dcd85f5caaededdb3b0005c90830c795b6830fb029241cf9eec4abe40c04541a39bd42bdf2b659ebfe6cc7b8b4179e5f02a3457b34d0cb1205e4d06ab7a6d9536613500b3d65732f272da81a3a84fd3b7df3e107c2d9bb577df05547a5986186f5587850c5b1b53412975d387229971cb288e9df92438816ec0074f155a6e4f2a3ec0a26cfe96183f286537b5c2de221c2671fd7230d196d37ffe416dbf0e4b12c7c619d0d5aaa8d3f2d6e9225582151160fe9860a666b3cf49ade60752db6b31de7ef8e271717e1f615b189d791055dcc3ec6674d9f8d7901af4b2b075563bc9b4236527aea941a01712a7df5d2208fd8a34b6be2d277090534514f3478cb08461a7f71dd2e37e88e8aa43bc37517ff8bf3bd68012c4ff795e0ace2a795468eec4e6ddd36b5b388f707b85a9457a4424482e5d04d183a12692b9e45e4cb8d33b24edb40917c3a8e670817d8048258d846caf3bdf3184868965cbc4c8647fc47328617adb5b812dd3e5e824ae78f6de7e480098055b298b4065e4038b984c500b72edfac2af0438b1548d6313c8210a477198fa198f47fefadf7635786699f39dab3963f75085300bc094c044d6ab7ce3c3895c6b12404d445302b8ed42322779bfcd997d5fa30cded31c0ecc42e9235849763f4bb910b6b3f309a4d5173405c518935b33eeb8c8b165f8ecbf36a8dd8352172057d3a6f20b759e149d3cdbbf13d33864ff7785bc04ad3aa907b6f0c7cb63a44134c2ffdff593c905ca335db596b86ced8f42a1624edfcb72f20822fc2a592bf7681ba41e68a7ad8ea60f6becc6ad9aaf5c460f8ccb3f43b944498a0512ac09873bc83e23a3f9b38f457914c1a6c49f18013c9022f2d47057953cf2034c4dd14af92084c92062e2727f107acc159b87cc0718c961ddac3c87240e497dc78a60083afaa54fa095c6c5da82b0256ad747a728c73d22d4ac017f492f914a61ca5c23936e7f83234b84eabcfbf009e2dcc5ff30197e9ff4f6f155919dde4bffa9fe7901801fe9b9ef7f62f13083546a1905787c5e3cd9b9a1022f5c2e2cb4957a828956371dc4e32dea2386c0e1ec9a48f640830e4d11d106565c031d8ce87b998812f84ec08a37f47af3f9fabc590842cca3d018fbac68231e53361d6862d8b4f988f01cda37c3101c8ae0e763581114c8a8254fad50b938593759474031b0400a78a4d79b051f0af908f36ef963e325a80cc457a1899a33073e3ca2c807d5b406e4b623f6aa0c36f8a89f57d8362248a20340c0855dc9664326dff160198951c747bd03f73602622fd9c8f0b040c002766e1b14b95841f982d0e44ab3cdf24e50e10e4fcd378f4e2297fa4bba046e1fa418426909a2621fb01a72cf7734b218e52f93238f9be43efb68d56097b7b051b64774bdc86cc8ffea9ffa54ca38bb6bd3fcaa3889f9897860163501daa5b62c7014d268bbed7cbdb00f772e1bce4f4e6aefbb2f805e2a165bbf47a3b92b6b4896e8c343fd21894958cb830f92442157de61538a3b9ae441be910aeaf14d2ba55d7accf3c1c9379ffa4faf79310b07c759bf727d1187e9ec5e5c52e30dc1548734da3144b87aa9763e12bec37ae7454617bd43de2a10b93c73134330e565d9f5a713dcb046a26f0ffa7de0f41b630dda47b48c4a9ea7a543f0b8324d3684fa44a91c9b9f60f00086563ed05bceb58f167d07a4f2c1283b2880fd6a7f8b5cd1c19cf535f52926cbc1b229b5ad9484b9b64c3ef0e16ab275acd42727ea23f4b651730c9fd01709a7bc159829266156628921fc8371f25dd366301cc864bb9519926809c215f56f03317f5af5cfe8e63ae350bde284c619ba46a00bd344f5f545ed83bab27b5d19fa873bf01049b7bc9fe733d4e19cbf74ac101360d2c8601748af64a912ad24be96e40d8fb58c01616b2e552af3d941bfef08722ea4da4ac1e63bcc47b9afca0ff97fd1514570c052a9ec50dd166a5fdb7852355c8aa3803e8da3ed2d97a77e434553df29547a4ed911d2f9199142f75d3326ac604652313ebdeda947560c0e65aa1b6d7ee4a543c377449aa7a8c146713ce1e5988022db53a740816ccc4323ff372b6d0480cf21b2160a0836d89fbdb8c0d526e1fb1daf32b43633298549402bd09744f8b8aad6fcb70ff7c64c38b6f9a85f672a2f1ee02ad61fd96a40c3f09423aff3a6685e25a6e8323d95d39a196d9c6e55625ecb656c029d36021ee019c5bc09df1b2fb8f4d198f846116a86b24dd0cc2c9c262168f4b8bfd0fcc74fa81b2ad8c2193701984196f938bb77917d6db56525e48cac31eabbb560f6853e497aade1fe77536a845ec2c617d672c43feb201d4b80e165ca99da469d51704bc312443513a57f3c8a6d2efa639f8742a32b0178f30a0982f42628e1dc03e5683dd686c4d1bf251d63e6ba7372366d0e579067a3ed39b3cbf6fec9955058e8423d55b2d393ed9e8406557efa0d2f0d0f0938a6cdfe9e892366e4528aea1347dbe661cdb30bd218b9e342c97de7f196632e05006f914fa2cab96f7f2d0dee62e86de134d3eb37138d519de3af9f434de8402ca44851a21a27dc4e7d0fb05582710115fedf2bdbc2e83b720ad90d196b414ff7052de22e5664356e89fd70533e523c04d97277a4cb93ffaa138b02e27ec32b2d0edace937ae4f942c6342f2e6b60fe0b31511f39b5f83a1490ec08bb1d5ed5c94a08dcbf2bf98e6d8b726bf2fad6432ea5faafea7f70e7bba0fe0ae460fcad1e0d9278bd4d6d10bc91c2a2412661d6364af6d4cc186d09ab8616eb67edd93c495abfabc6790aa0833703d907345f2e69b407dbad915ce7704437d257996d9785410b3949a0f7b7738075d70de2d2bc3ad1d1e26139cb5a2d5e10e3ebb20433f4b6718e83b7cbe16a60e8c6f8b855783da6fc2df8679628f202f1dcd35533200a7bf2e117959983fd9f0b9068fb8388ac9e6eea903ccee7c62ff5df6549a2c6009a0fd394a4af32711a03bba1636808f5d159f261fd577e3dcdef574e4f668fedcd7bf6bdd5f238e1ca2d4fd7420e85fd48bf1ebaabd65c6ab90e4906e04a4ab2dfd6e772fbec72d8c3172ea6322b689d8e108a550238d54edfa659d20dd3237d460d4f948bebfbc150f8be1a1eebbbd76dbe9d2951e1ddce2cb09809ef7eb6f1783212a5064d6c399c066804a10b5dcb7c8c368d107707d049b51eb5bdd0a79cf4a3350d96078e0b543ae0e9874b512957cc9fb837214470525cf302d728fd9051c1a889c6c36e0b7f8608629db9c4c2d70e8276f8c1469270ecb9cbee7c602477ac8bdc7b4d661e4eb73f540cdb885a77f7f4c7b0083444fa0af6fba4fb335c5148f0312c003457fa0a8a13210b221dc31a0455af6b97ae424e397e6d3c51a7341998de7532d0f0059a7c90fae0ce52511b4f30c47a9d20a6ab57e8d16654c8a1a0baf423f79b6cc2951839335efb28b7bc423f554f4060676b7034fc6a1ea41e83fa8d595645cbf1afcd79c5e78624699f6742673630964e2545f094f11429b63100e76db5acd287fc7f5e78a16b64c3fd4b969cd3f2a1eaba3cb2ec598225453643ecc57494d137172bc74152be8aff297db0ae8290f97ad2597c07b9e197d3ce8dbbd76b76657e2774a533f4feaf2a95e0867cfe6404880391bc7c6fbf111e68092d7ed6fa48501082975851b58a140aa681069189f75e72b21592ed6bf09c78ac56fadfc463441745b38f5a8f4ee1f54b99826b027a0167ec9f104fdf677baaab3a1fee7681497ce52a8e5c7e1a11085c473f8fde8e20e7a74f87165d77b67823db7af7f9237acb6dcb80f63188582f39810bdf72ef98a70334c22f9b4400faed9a90633415858c9f6a3e3f272e0ba939a261ed90e8cbe3943555d1fbc98f79eb6ade61d56bdec4c698c3c810880d55c91db6c95d4214f023c8b922d1be9c1084de77f59034f9f35b2fa866061c9ff71668d758446158af25bb5e00a8afd5714aedfcaf0dce64dc76cfbdfd23d3ea6cdc590a7e6782c7c359fa4fd3a19556bf67cabb7c0d5ab4ac6ed5df4a6e4158cce662fb3fde9aaa7b76b42b5ef08f04b7904f36ac8308ca514341f71f6e4dd116c7c569a1b5632a86dcfd6e59a96141bf385b5492cd10341bfe46e21064d9466441da9faf5494b4682706282643339d916709ef32891f0d6df9ccf2e190df2abfccc8390f4a7f8b818fe2878e08ea757edf9e9c121578f7f60428f9c0b3db4d3f4371603cd6569131298b64070999b10a1cefd7ec418ae4e12873b3c43f8e295d149fcd4fee431edc815a121cad2d9de224052564c8c0d2be36a71ddd6c0591367425fd644f866e25a8e9b0d351bf4edcb0b18487ad6149055632750faf6ac47b625cc31f0f070ff3f6b893f6cbbbe46617be93c71b329c7a0fe4be88c8fd5424669eb0d0e8039903c60085406f205c9b96e12d2afedbb7dcbfac88f10f35a342e838ee124a13fe788208eed2dd0db658eef98333665842e9fcf4b1ddbb1c6432b7f62e04ce798b765c04c26cc1ff6b6167412ffe9795f2f6be4afea3edcc380ad280a2e6c5bccbbbfeaf02906f4c3546a307f72951abe0b9144714fc82bf0a3c54ecd6cfb3ee9b299643e178c98b6bfcd5926a6219c0353edc886fa0da4b1caafb2368d97b3a78d5d0d79ec26e3a196d99ba8309619f346f2eefc0a560480cd743fac8347827af49a7fcdb4402b6b4f29f6bbdbba4c2ffd501cb95c59fc335ea98fc61ab5fb3202bb97eb73193370a80451b624237658a4426b68817b57b44b31dfde0fb28620da56ad556a626abae45c07fb438e8d3046067d1b8b661ac4d4c9fc84e06ad0f998de31be6d29520efc6d7f37ec4cc530e4e78a98c1aef84a56cc8d443d59c5a984d4528e7fecced1a70f3a75f1d6820e5b9c6d2e86a1c894a21269f52d02ed416580981dd49065c678624222f55140d031848b121f286d1bfd4d04597e2a4b2a96d805578665729402d2e2821cc1622929af0e982dbff465f1c640b051f7f7a0448316593a9c1add07b2b1bdf7d9c116b9ecd3756fb9f9ef8ad5af2668caa7af8a1c5f88593ea72a888859e036171ecc7e5f495f86f99d3ea3f3160a8621f28cb07dd0ca438cd6ff964944d849a62f2c274773e840950fc6759aadc29e4f081be232a87fd21ec8641d3efe6d4d5df2c4cec19eb031c4c616563e43ccfe93ef7f7a2d2e07936dce5da128ccc02958a520876d51acd6f975144c43eb48000b4f68bd563efac275b916a3e294af12ca2301db2f205f4829ac0965ff31a238029fa80bf8f584c6e0cba0939315af134a4c97906ba65a8a75adba67b3b345c53a171acec97de1b2fca90df0bcb1a5df17fcf4a83ba1bc05662a0cb0a202bf0ed055ec393edd027ecb5bebadfe3b2f15823f171428afd31fe3534c767efce69919a4ee40e276afd9bc4a6e07baa1ec00eb1edbcbd58be28028ad19b446218e85cbcd5d3dcbc7106b9a59c61e74bee30ca316db837d9959f949298f40b5cdb0654e5b1f861c6caa71b5b85aa894a8a5bb0f78b2cdddfb358e46d304920c4666dfa3957f8ad57691eac46700f0ec35763a640e38d80d98911bc2291214b250821aa3525b1c8c9df0428ef4b6a0536cd93ac22da37f4bf8cbfc4f583e1287ed23bb0223c9d4a077c44a4523e4d97e40695223942e9bd0e19242fb3427861cdd2951e63f2586e7164276b060e0acdd441d8ab767607665599da3cbdc262d025c809038f34ab6b88f63a137fe799e930d9fe2c51b5884d7dbf7c2162c5f62730a6857319814ef89ffe032a11c0a3575430cfe14c8909e22c26ee2ab0a453ec40225a24216f91738177c9adddd6b87ee793ea49ffde5faa123edeb9f7a4e90f908ecb47af390f0b020f3b702103459398dfc875c284f9b73551d345be870e183dda5d226f9fadc564e4ca47397b21c75e2fa40cd2969b69992ba1bb073179781221b14834b6a97040fa607fdd6043b3b98291e215673847fee723f948670cecc7f324dda911751abd50683776527d0a40e965ccca0f974e622fa5daaccfb47749dbb05bf4e4191fe1699f8405c061cf83f7c8eed86bda6ab72438a07c6b11c9e501958c972e2724c5c73f4312bfe1999750f461dbcaf306d3bbaa4177a891164d1b2839f885668a99f2eef8c5b3a6f8c1877129d7dfb97260d16110ca8b1580a7e6ceccc65b7aebf35bbf7f9cddc074653cc1f36a739f32b92733c2579c23e3fd2fb1ed06c77eecc3222912429e9b0e80356b806db1f993ee85e66369540f5ea8287e1ec12a2ef2a5a331cdfa128b4e120606f7cdba8956a14a5059c992490620457684cc7a5c1e24dc9e36d07af4b616b752e97c91d313a2ab6b3a49af00bbbabc0da543523f1a5981efd42ac02affed3887b639949365eae640b091cc3f91e75d5c784b87d55ac1da37ccff5d44fb75f16351101a38207ccf4fa68baab21c8728a884d4578abc2990df12524a4251e961bb27de04973e3893c1f626fd7a36f260dffa387a84a0ccf439b86c5e7b90f2871d4b11e5ed26a72594a08de7842b092becf795894c0d13535f102d0e63cea09234379a61c12a373a2d707e983d615ffc8b1b1fcd43a37fd6463660e5cf393a5ab1b0d04917abb3e0c18f9a5436c56e635555b1c0d76c092498b13de59953229d459f1e56d3c030d9ac894ac59a5a59ef61826b161c7eb649ad591b75cdeefcac307803d3890039fffa2f41350138f2309469de909316cf00b2f1d88810df667ac166462d9d5ac9618ab8af4d0fb96ded8d74303be9539ecf2a5d2d9260b1e666a4f38954d038e0499c5db46f0cca3028c439a807a10244c66b29dc2ace6575006f1fecd7537d7d1e487e59eb0e7a73ccc8076c409e524dddca79ba045ec2f2a5ce6a3f4862636617165fc71699475d36942c01796219a4d91ba329a5386ed684382b8afee7eb2a2fd8c6257e3ad2009299a5ef97c632b3dfe7d77e3a6d08e43350a6fecfbce2cb2de7daa38956b32eefd7371d84fd669fbd683553d20d5a3f73c4d4825ccb379016b2df19e1af05996971cc48d91f45f6ef72ee60f42b1f14e6d648302630a1703a0a32f6e34a207f85e8de6d10d0fc4b385a3588844762f9ae1220e3fa75c49a6aaf1644b290ba872a446a787f2b6a01643e1ca9695db391008a04c03174b173139481c7eabc03f7527f2dee7121144841e022a4706a41615de4bc434be4c54ba42289adb0ff0f1081415e5dd08b816f87b2163bfcbdec588a8d3da1cdba049040e2be55670f72d97954952da2293354796774a2f770c68ae6dd00d5447bdcc9e41d0e6884694e5e7b4ea329ff209ce8017cd67abca53d0b08f834f90b2c72dcb51a3a10c61d943e6beb7f92a24f69d31c9102faa4a3db98937a8d239da92fb4f3248235b704c93560be8a73499abc6909885891313888441f8fb212bc3c527579dce742f6df7999d86656758a10010d81032d9c4412891f1712a7efc962eba7cac74458cd054eac1d033e1df9573588f550e80a7bde2ebddab9ce369765b85fe071152744b76094e56a7ec28dc5bd16387ce1516f08b3450866dc0b5b71429f0dec7d1c809195fc59df438500ed618b804b0aba408b239a33a3ed8e2a8c329fdef544c2ad0e7da3a658e145dda1bb0b0141943ee882ff931257b7fa40804aef39010f5146fd0592f4fb1ad18ddc7827c8404a025a6de32452eac443fd5042c3037edac76960676fb167717a5b25628d5085d64f90afb6c0f746dcb5e47f34d838c15d39b972a6176b8cf31264e42db18eea8287f556a97fb35b67d3513d6e968704cd960edafe5673d29d32b1eaa91567e50450ee62c2597e833c22037276fd8e9a1a9a881689102a7f3ebc4c93bce887d1abc5771d993592a02e229912aec7918bb89b35a4bd57ff7942380d3c1a229e5b0cd106e9e5b1aabf926ddc46af7819fadbf0baf1f6f2a0fa7bda9497c2f9903e8738f96d2555974478c302d0f37615d19223719808ef2942a9e6a58771824b1df04b6623c087fccc45a13630887f19a0ca620d67e3c70940fd9340c148e9a86547523fa7b4125da66079a865fcb3d3669941f41e9c6718c3e83f725b00f00de7804debddebfffcb98c9050f405e734dfb6202236e383b25a605e3c53d2bc86fbd805598d5d3cee4ef9ed5bcf6997f4371e65895d551cae87a0bb1786f3a609ba0c1ae42d8cbd675c9679cd53804579271a427ef8a4ff3c44523277f7c143174a826f4b858fd590df8d1651401203d3533eb1ff9900e8802d3f6564993369afa53a79c52fe30fafa65abf6ea64f390e52f60f6060e91ae913d4c156a3c3835cd1420e0301dbf49b9a5aab58e114f44491f9df2e561000a23ee6934064c406127f0087aa22442163d9dcd99d07c015bc900db2b54ca199d998ebb2d4ca1c9daa74b5d5ddb7c57b0641449332e9718fd56ec44c596ec3437268ff3332fae71b1c48c5a0f83c0dbbc67a58058d42021448619ae535c7d4ec244f08749265003735ae9cbae59d56c5e6933b8062bb9f6175d442d9b120cfb12c947117ccfc400ba1649c7da6c15e94a8af09618c069a8dc79f2d8f20eb5d762ac857ecf2026812929c89742b2637cc347e057c58d1753ccd7417df55c1d56e0eebb8750e15dafd04170dd3ad6c99db2eebbf38c63f5ec90ee159634b76896648f11fa81b592980d993419af0c7f548eda8601685de5fb233e6428a002aeed5081b606c831fa54592a4261106ef7c0842861204a20f1150816663689c0a499aeadf3ea0880315e8b05315d21faa6d14910f3ddd0e2a970efb0613ba651941c34ceb4bc89df4c68a0764d9425f346358469f8765926c06192547635d773b352ff44a5dd6577ffdf5ee98867cd1a3253ec57e7bc479565e6ea8a3c16d5eca73fa4c9e7282fba6fd0282545dda581a4ba67cbae07c5cd8559739481a9bb16fa968910cec4a53f1d276746b9ae6a774685f8b795d794fd23de871d10a620556385ff87fcb472065ec06da67285fb7c96873e842b2b45d9178b95fc9a06b8deb8f759448f17f38d1fcb9256ee27f592459cea3b3f13bbd2b20b3cd1718c49","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
