<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"21581932d056b69cf39bd1062f78e605eb6964e8172a78b90ca4108104d872b36a9401c6e13fcae11819215ac1768ca8ca97043a958fa4ca5d53f2671593e114bf5ea1d4f17e6f76054ad6858c53447b323e012e2c7b5d901a26a2e16e2a79b76ccf0372141a7b64e919dd451a563901df559becdffdd36440e632976a2ed6d8d60f0c9c317c3a204ee7365051f3fd1a3a1bdf8bbf87878e9d6d23b7b5bd6ae1c2d7f3963536ae6fd022d764d937f94eb42fb1f8682263dd8bb33e157aa41c4a90a21fee0e78c633324e0f7289aeba7ffb6a63ff2ea1f2ab81bbbb6041f8e7f6ab9cc1585cb381779ae0183272755c816cdc90ab9aec859a42fab9cb1a79d7bfedb426c55eb8dc1e02250f99d278fb93ec3ed7d52c652324de830228ec80825717fdc3a4d011e49c1fc3907dd1233acb4b83198d4d7e5e7212168ac0d8635db9631053e5da9d709535d690eac2e7d80cf590fc40faee99453d2d6c5ceef1de54cb056bac98e578a88be80448d8334834bc6d434e16e9459ebe04467bef7bcea46d2e5df9cc6383977b8029ddb0aa7480481bd3a091d780573fe6809488e3b480617509c79065650fed4126683eb4385789dbdf14eeb5b5961d7999d2f61caa5463f590c01497c7369b65e0c4c1a9e3fddb9916fda54c07213496d3d62ba736a3f5b2f40601d1abc5eb5385da7c22e3e94ad5c198f3fe54496a628b0133b3fd3d5c33e2b49319c96766c95ac86e8e3c21a5ec95907ce05075c05c116c6a8b28707205ad6c633987037b0a200be98daca2d83b4bafb5a4a07008504591fde4cc5c4f5d47b933ecc81de2f73fdd5a7814600ef8a52758f3341c583b5f73ea8c312a63dfc5659ddd5a32ef6948817d219492af8236dbdbbc8cd380d3b8d25a15462bccb9a3bbfe64df9570edeb0cbdee3357fa1e74a9bdee4f5cdc1952afae20e531a6acddf9b02d115f15bff110c45b6be5dc1aefd5d276ff5dccd47dd8513c42b118927006f6ab405e03ef0d4dad0da5438d1ac0489f9fa8021007ab0fd5a149a2ad010db70f94a8c2ff911c5f4c6d9d51413d08149c44ccc2317008c1f6f9d1b26bcb9ec46a004448d993809d2ee1be08e1ba55028a325bfff414398cd9a57fffc92f3a1badf49fa31c8e71e1c9eb0db6aa4ccfdeae52750836e1bc86345936aa49fa320cfdeb30daa861d77492953b5dcf7269a241c9540487b25b8648efb6f455129d5e3d8b95adfed9f83d95fbc853d3135338f5ecb160d54e7ec67ac209d1d27037884560533649ca0e54c30c2860d865933caa9fa05c6f3bdaea325b0d620e4fb1653e0b8a1b86aeaa9cb33d67493b961e5d107c9228ef2e3c11cb416f93492ee3d22edec441288bf0b5ea246d0fac401ac3c1470dccc313460859d6fbba7d3af6ab2f9c85fd0e7ab15d80e988b9ad65914dd02bd85c000474b078c2aaa9bdd46688c7d31379578eba1320f5b4e374e6808483d9d21ea0e62dca9aea0515bf04f35111aa4466226a35ddfea5962f6d766fae60f86f3da0f39f15ee8224e3416f930ed1a115141f02c33eade9fd78e6c6fc84678d98e6fbffb4cb5b613795aa640120487ed13d912b512833e80ac0d85ecc7dd7a6f7b927354effb4f03dc286b2fc40e90673f70d71e7d56db89b6f77bf7e9099ee95667b4ec9ee63671007f6ba4530e4590a873649cf829313addaec0a3b7e90440948f694b5826417ea5cbc5320ac857a49055299fcfa108aca999b2c3098323de378d2236b5c2047d09a024692dc5e27ec0a6c713662012ba7b8aeb9b3caee71797194765cca20c94cf4f3e1757ad9e49bdfc2b5ef42195d758072fac7210e2ec29f871a786e30969cbfd2d19e230481ba897ba2a2c9e222dc41879ddd4d5370e3d9800c63f8d7eece1bd04dcf7730b3f2d926e246fed2e66cab3031528933b0d654afa8506811df0779f04a372d922f4b390f5e710e367b942bd25a01f2661c04779a434f39a736e046f61cf7731693a0f1b88ae1926193083bc3f328e6d78be3e9f362e355bb2712cad3bf6ab3745c16cf993c3f15809f0a8ea0bde1ae1aaf4fb8c3cd2993b2ab82a68f3fc094c2aec45eca070160de654cd70e6847206c9d246cffb1801bbda5503d794f288dd77378a8871ef1e2b4b7327222034875419de7a3e83d75c17bac02ed8a3bcdcb957133a88b4b2bc444a05c02c3d390dc51f25b70dc6b72dfcb0c3181e05af2251b8481d2eed44174c66180531d5cdd6f4cce6b2e9508c1163dbc33976c7b11a7ffa35af4a02e25e11b5713765bb67c129cc6f115ef0409dd20b46f74d8539bc466a45d12f82d53364d469268bd694114d3e88d83c2dd4e48fbfef23babfa164b37652d92a3d1b66d5e1a19220bb943f21fe4bc982b7076e13cd2b3551428cd3369b745f72dee2a4a6ac365ad26149ee7eb1580cbc1ed2f4f311439ae5564082d1a03ce2df19c7d9a549f31e476d62e0dbd839d314f86cb5f60fb6f37d6d0b074c77e7d27ebefa96388b9e93aecc2fbb516c4f0db4779278102fc56675428a391b5bed1880c440bf9508159da8e94a6ac109c2b8171826ed1647af64b6759e27508f183ab01cf05fed72fd6859bd24cb99923689807c6e2b513f37c519a63992b4ee2f1e7f17e0fdca4abfeeadd31754d1c785ee1337321e23bb16dec0645f57e3f783d6c22c1cc73e0a61daa8b30bf42a90ba78fc4706545630af9ea72d04820c55281d7b8a03498b84f45383c1152b8107f028ae77744ab765b08d53cb54695a558cadfab397f812f29a09cc155d423e6eb0e1ffeba95fafa1d4f3b1d2025f0fac5c9a8bbeed9ea89c2111c92da9a2c6425491a49403dee783c5c236dd93bbe47ef5a3b714e3c0e63fa369f29ce68789eb016cac5c6070cd1b4b49e9504968f368badd50b7af410786b3c42952a4fdf6016a809d1ebd987dd236db309e2824891a04234d4700ec17f84d0343b3388a98c12ba5470ccffb37ce0165db64eeb8b316059d422cb3e3c614502a1d40387e1cc10d99d12cc649629cd5dee39de97682c57bc7f8439496d69c3b7427b22edbb5b9b00949b9d0684319b115beba0f65d1655af96202b969f0d0852a5a596063ac7b796200fdf6997a2d4b0640c3c2fd18406cce73f330d48cde159de8621392adb3e073e7372bc84b23a6179b5634a18974954d8d7c10e8e204a3a72233a748768ea08de1034ae60e7d358e77f912c1674f0a1fca1b7e119e7de174beaf5140dda2c010bde5fcad249995032c61320e5a227bdf4042d346e9c218ca1d5dc5eb1c898aacbe712a8f26beda1775dcd16bc35f88bf841d4b1ec0f4a29638dade5ab0e653bf3c12ceed545aeb9a2c095caf347f8ae642a804c0b060658377f5683462c538e0d46d062c258d007b9caea4215713ad1bf23bdbaa412866cd17b193f18e300e060f3b6026932e17c090de3222398af9a514d866f391c832e8f18a9350d68d9ea1e60f6cbcdf5a1fae24e32964df71c539f90ddf003fca46429a196cba17206470ffc14da391078b7a0e2fefff8d15352a9b2af44de6ffdf5d4ae3de928e5e3004bed7309cb77398a66a9c2e5e229a3d1cb6f9a2090b70c03fc7d8700bd9a7eb0c72d83e000daadb25178ab477eef312fbc7d7b0d9c8cda7752fc6cce1a0d92c8f645c423826e333efecc23bf987f723fc84dbe760c3919048072a3fa8ac53a527f4b71c7b7221623c1f43194055b9c518ab38fa0f9236bd233ac89e1f2a02dc21345f7db8d70556a63977daaf296dd549678183192a4efda2efa7e7d53f61f5268e4c9f29ed32b75d9973570653e1fb8007de1f480c12bc00a2b3bd7f5fd3184ea966a1db23f67ac3c8dbaa84f819e6ad3028a342c776febe85a5589a4a36e72ca3961b8576aa62d70e1187687b538df7928e61d16a609b9c284e57e0652e7d573a847c343cd161558d395aea5e0b1acb117283df7ba78ebf9ae4ad2ca2efa0a5d5060dfab02012933d7ee5d4e93de5567acaa887e7809b4538ba63d50a3309ec6253678b9bf7506ae5d9d48322cba7b91a70489e87a165b5c39804fcd8d5b1c6cf41ef5e68754524d5b45c236f571fa1496835768562a8c841e849ee6ed0692ad39b423f7bde2b3fced5029ef1e1c9d2aa8c2fd5d0e37c685382f3f3b550b69f05e1fc25644cdeb603e74ea218395d684e18a5e362a633d9914ea6e0333da00f1ab4ec45be61c64c46822e1b830340bd975c3208887c11db86fb3778c50f3094c6a2d15ff9406336180aa9b2d3c2d0a64e56560da5afa4cc4ba01801613172952350e9135f2557a859759831dab183a3d03fd988824a93218ea3377379b14ff66438f70860e091319ad1f9880df51c41f00b18dee090994db56a206573c65810534105c21f02e8812c97532ffd2917ed065ed5e15905fd105e79be77ed93afc45c361ad0cc5b1a5579b26c658fdb6e367461571b72cc78da08b6719f62d7b473137b3eb6dc108a8a3f19229f1e5959bf27ec09d0d933917e47454799053d31a5b7b74f485de026aeaec108cdb9b553381f7325e53f9f5828b04c6f84f784e8eb27992d644a393d9d25668a16e2efbf0962bc6da6e7cdf3e3224b5d462e2ba8ea26a06ca9a4571ec48806ce01b9252ec2cda41b8834ddd6450da7f871bbd0bae5847146162d1cdee6c65bd68340c0eef5e458a104977a50d91888f6f9d7330acd194d477b33871b7a19a423638e0cf6bcb15e22d64b0c00667be1ba3a20ac3bb8eeb5d8abfc396a5abcbb46042d79cbbc5a3684860affb5e5064dd5fba5ed93aa37d35fd217ed10b6f4fcb37a08c1c46f8f3a65d802e0cb3e672a63d66ddcd6cac868c6d50aac305d9380de046486557607ccce10804aa229cc35fbceb6fd7c61992e468dea68a1f56712611490b08be4e71de4119bb3fde73355a9e011821844af729f2bf56b1f91e1c0e5c0de6acdb8ffaef1fd7f31a6711f6296588b5e13080dd8ee69397ceb05a88d2ed76f37e00c99fb1f2a183b01e3b2f878b319bfd440740c37062984f3522a8402b8ee7a85f6cfd6480bae1f7c9639d819cc6d4f8b9db8bb8566188922455632a9245a098e2ab013a7f3425b5c25f9c05b11ad75861a7e9c828a82a189fd43612a18aaf2a64b18049a15ea54c588fd56adb280b2ee77267716634ea4d12b43b991741f3e0f8b97b467fcf26cfffe1f50bb3f2ea21229af027ff60f5116026d4123c8f1af6701c7c1c5db49af7023e46f032b3a458a6c080b2fbabe4b994c48c095ca45324e5ae8b3979b8539a0807650d27a24f89e91330cbb39e27f60c8dd6aef5b379ddefea4086a0bdd568110752a53f1f4e8b0ca64a76f7aa9f4966f627e3eef6b3c65cdbdd03118aeb0c3794c52a868df574b8f19e81275227c40e2099111af8825122798552bd4e5d24ad35d0f7dbfa0e1d6843b4152503089775847f53b17356caa80fbabbabdcce6614d3cd1be530d65abc41825b1bab1fb9e0913c98a47d1fdd932f669c936cfea2eee5f02c82734fd1d6938d742d85e6255663026870e1c28f70d55efbc7c1abe9db5491b461bea8d409be1fb5235659a842b0d915f1e4ada7743551fcdf6c5a1fb621772dd6319cdbd92e0b2c67e3f9bfd7389a8a75e3cdde7068ed6b993552d0c05debf24741238e3c05dcd9d2bac01e2315445279fe1d7db4a84d26ab19ad7882e1d0f673537ba18ae5488e8b502e63d1be28551e2a5b0bb71bc6946f19d3da424db75aaa76036e684ce06fdcd3e261c7041f91290ece97a805f60f908f8477697b877a7236fd619be0f72c2ecb67316f21f519a694182b5864908c96cde7196912fd140175fe1ccab36f1b3fb3380c100be3033c960b561c3ecc4a7738100167cf9c08adf5e7bc80c3435ddfef632af283d8fb122e3180c74b1c5af9158e82e96fc47729d324b93a8a19ac0cbcb63c873bab77422b9ebae84eb99e9637aa28997712a1953f43fe9191b3171f4ba2e44d0ab154c175b9fddd0408a0652940c1de42d11997528f1b382daa6470258fdf6dbb2571aceb04be7875f856784358d0e746f8c95bb71ff1b8a169414dcaf20dd561d399e27de150d9d27018ed00398f9df602aa3843c9f52bbc1f88caf63f00e010674e17ba46ce2ffafd7d100174fba5f62893ebc2c23a4edbb58e124a6c2bba1faccd04834a1c76b843b9be753b0ebf8977f54c70883967fa9631d83a373c2a564859f4b27570b63d91f1a58c09eeab3f220a9b516af1b4398da841a49a5e517f9b7ed0540197b4842eebd55e4283c43d65bf4ad11877937ee46d421f060b998744768202dba9a016eab87a966a1a753c82d91c5ee76c420455be5c0e7204f5d82f2c869f400dc779d11dcb20ea2ea3396e10eb563a4e54325984656bcce822e32faa85ce1d3567c8d86db19d30ffb25d39c93def5c18c4723850c3c0ff19fd96d12aa040d165418155035012299712fa8430445c2ec5b94d1e8a6d2ad538ba29bd07eef9c51e897d02897480d5e91fe624026ee3770c62433bb7a4ceee624a5815964cebbf4c384905fe135205bc9f1ef0a578e186b41801d728e5fab0aac41deffaf2635dc3b99f8bdc9cd19559c3ce8bde29c7a196fe36161876f56e53a9e26d13dbb4f8516b953cb58af5e45d678da97710c95bad9d2461d7880eca332f64940081c50e3aff1ffe50a6991d732fbdedfb75db3674422b4771f8b4df684c1924b55a69c124b496845c1e1191422eb389926afd6ee33b1ced926a59b6ea873ee5ec97e435e32da6785e74166eab5158ff0730878e91347ffcab6d18e981baa2282933409f073dd32e06df56ee2151255af439a1174606ff036bea16671096abb239a2c2e676d06daa8e426870564034468615a8268fa400ea77525edcdc468d2e060fe3fce1840088cd91f91cf4278a0b9a71e6bf4ae21f3726d6a2e644f6f968413c62bf71ae4cea4a8c9b0c3560afc08e11d3e2c3eb756d52e5fb80df8acbafa18e30807e84ebd82a1d1da453edba21d303e7e1e3d66dd4a6db07c8a3e3b530ca6447693512364bffb499bd56141b6c93d61ac3169d87211eb1f59322d184261f968464300a09a049e1ed36a8e5574635e795547af9ded822b04086ff5d20f2c706059a777b3838fcfc347d9a4cf85f4b9893727c985172d5d445ae6964fd6013e454f9100bec28fafd7f3168862c9b6a8f1a886c79fa0fca3c221f606eea3cdf31cc82cd652f0d4d7839a00d436c24e642afa51039734ffcff8e8e3eba6ede51992d69c75eab38a4a3e2a69dfc848942dac452fd273b16a498bb95e91d346f61b027e495526d367751df396bb5dd9f443cd29fafddf8f59802aa2f9bd2cf45ae086c21a434af7aafed0784726249c1560a5d83a44d22a75985fa1a83063d52172e0e67f5a7018ad1b59954339dd7ffd974b3de221f2ceb8ff3091236d5d58ebb58e43cdffdc62f8c4537c75ae219397ff5b86f7cb5988a1ce7ac9c60228df1e01cd7a6f6721c5efd17b4795446fa410252ec52b61e776575563c1ac6b223fcd296ffd3550141f60e17e76c705428137b6c0869a998d7ff9077a120269866fcbceb4defa638ed493394e4a3201322e1ea5dc826922d80d10a8bedd79aa3e4a4afc41a430ee4c11a1c92364c5a4b5316401ee415ec9dd669fb92158143fd6f957edf0e740da32d929a9c34dbb154f5de795a5bae717459d75cee5da6f2bc438b11a9183202164d81aecf5b034ccce4f0ef68856675dadb99477ba4c7f0b2708dec3754e7ab990fa3d09a0d2c14861af22464431f944501396d1378ef875ee95b3314b0d25bfa69e31852d01958c006ae7a84628982e48590b84d28c8c40988e2335b2249ce69219da6010d7ae47747574080dbaf1ca3b1e81c767c69b0009f4649c10a5aad688c95bc52ad8194d25de98d58dadf7a5e98082d132cfddb52a3bbfcb1e2ecea6437d42ecfb55501b9dee3df8fede6f43f907ae633f3ddb0787ba5614e5291d5cb04d3d5d14ffdc668a6f266fa38061ce984419ccd0557318d5da5aa4d8e6205999de1713d51798b2817651ce1ff579c713fa7e6c4f270349100f8c94e9c33c1a047e65b3fcdd8d8dc536999a60d94485baae802b255d006d32d668035d8ef65ccf015a9d5ece8f32841a0e3428500dcd5ae8fbae4cac5c57fd176383015dd998bab53903bd50861cee235300637c96d7f450edf768e983351e915ccfc5b378ea0cd1c9b2691577b83ac4acd7011ad268a2c2f9ccd37f979fdad330e237963e1773c6447c3b88d2479f8dc34595dd6edf29604d05188d48a91f0ee5d8fa8f1a2aec52172a52326d7b42066eaf921ca665e1bc9c19a8a55c094903b5a08bcdfc40117bc83a2477239146eea5056f86e90936964f04b54e5b5b78e0e39e9efc07d138ebb221936282af508771975d5a32300c19ca52bcf16967c0932b652c7f28ead13982ac8309117ff5d29fdc20b4d30effadd47de08d3988832952a86ba6540b6449c7cec3d8e868997c585b226b7e622cfd08bab6462ab5b6c96414a52069418cb3b9adab4ed582f4cf07da0fd2e1e460e5233fbfce7a6451a10d2caecbe056853683376ac525f408aaf7e9ebb90c9e94e521c4b6d9b3c297c9a40a2a47959ae740adfb38fc1c1792a37e49d9363f7a5bcc4fc0035d64a23e18d25b0af4d1826755969923eeefd2867d246eadd353c9a80ce70f9e916f1680b734bc41d7c7b3695f0be39d83d419dd93dbf18830c9d4a45bb18cb70223205d56c446da299f1e85ffaf41ba7d3ba751006e80d5436f7526ea13a0c9a82e835124c1a06c79bbe3f2ea66a7a224e33415d11ed9e873e719a7ef10c358eb02aaa1d59645510c2f1fc9749d59eeb479763ee776cbfdb99c9b98746bf3c03c3d1284bab6ebd4e4040ad2b8bfa6e70ac71ec959989ff285ce217fb34355588c3479a9389c160291eb0062467b265eeda1d8b707e1255fcad6c771cb7bc6610931f1577b3770ec92a949a16034846d39e4726b06e185edcf30a8847e6f22b08040621f3986c1208d1b53d2abcb318ffdfb74c52e5d88de9094a7f3684555249a78d62c157915e4d28226b00a0517de14249e232caea841d03c0f40ad43b1ecd26dd8aeb628ae6488bd157b0c2748a7fa0f614531ed2e25f13c6eb138ea8ecbb556b845f3f915495c7176ee79ca15fc3c4acd7c9f1afa9e06e756245af77cc6dc66f9fc5d7d06c6940c8dc7a316a2806c7d5e4c1582211f088a94d1ea99349312dfda0f7cad1338e8d38439730cd32f4128f8ca314df59661a32096740734c35f43865dc55b53ae785906eba990a87501d06777bc5f38f9b38f4209a0575a08424c20d2f37848fd057aa954b802af3631e555f4e08f04dc7104be9aebcbc91769558cbcd5c0e4cce9354e5ddc48ac7a366d1a79cda078c70ac916dd700228fb377ba7b6465f8f6c8227adc2927c88c7e0fe6457508f109c077a7ba2dcfeb0ef9725cee1dea2fad7b5eb30b22e14e9367664fcb69612fd5410579bb073d55b3b36bb6b36e2f6e88a3ce14cf7a5cdd45423e12c2c1d3382a8c69a9d643a98950935fa1a2683aa529fdfcf2b4480b7e97fede84760d1f13d25a04328399d782bcc0aaab96237438f2457f0a59a369d0b4b6550dd871a38618bb79037fb8eda7b874a4ffb3f92d9ead224538475c243a5951e2e0298cf575403d740bc7ed32e18e114413eed842fec02aaa0cc1aed7b169902fdebe28bf79a73bcf33f82beffb713c40afe67c4bbb338574705e7cd34496b4b5ca739556824b4c640341343b684c411eaba3ff8126f4a8cdc283356e1f35e047d1749d45a0f6851407e8e90c3d1f6d20ebe8cb66600d2534b2d842ae0827cb90dd05db199a56df0f9d2ed28bf2aaa1effffe42312cef891e23b3a4fd42a3587ee65d7a37da115f4fcc485166ee8a33a9bc5be6ba52fa0d88a45ac95ccc6488d2603d092cdc60fe5404e2e717d51ad6c2e1eb5e09b6e267c06444a652f23280bcf8232bc2cce38a4a1a92891aabe2b44e03e747fb723975820c84dcf883c12e6bc7d1e81eec1c3c9863e6c09eb51b3583939c4bc6cdc99a2a4e34ae82615cf609a431032f40ff6093ccee3bbea1db60a7854a2a33c4a75d41df84558d841e4cc324103e440e4d9b27585845f2f409006825b27fe62da0dc2e3961c6fb9fc55be5dcbecb7c3aec89a12ba6af1dc5620649abd852b7b055b35b4f7f7aa3c130cb0e2866e9794093557a2b95b6946c1d8748f74e084991d0d2d99a4962792ff252180890b211695679ac0fb9368e0b332b540cac5338f869e0abe588b1cf3a18798f0bd710abbb23e12a7436858381a363a3afd9f222bc01712f774497379d857f97583e650f260b16facbbf97c684b3101887deb7a8f78df4a1b759087d2bdcbe0fd6668453440b1da5aeb8ec64678e02396688bbb2bdf84787c58507cfbfa2c58e25b888008e0822d526c664d91fa462396bdbc3013f38c5daeab216e400693ef25ca9a2ae8cabe8fbc76aa5f24f52448ca3b8b9c0ddb7cc60b2b31e41f3904dd9784906172b6fa1eaf46a10beaf60c524e3fed8335ea8fb8241495da75979f65fec5a6d30640277ec04d33855014f5090009af06c1579700d45a3e02f40563e96d7cc9be225de8f3def65bcf0359ca01c9a1b5fb780e3c92869154410ca2c4de4cf9a1b2ba7f90b138883edc51ca93b666351a9116abfae19072cc49fcd74ac08326a268d9ff94d33895a26956df2905d56b617b8ecbb349fdff0cab222ea191ce8c9043e3864ee4fa899e820a4a761be086a123bcaa53c009fe3c897561c15691acf7d89b2afc43ed34ba0f1d7675ab70ae8628788a0a78a29e68e91eaed71599ccb3348c19700e1ec45230be19079bde5f669ec5f1690e8d9e3e28f8cb7d2a743cdbbcb30341ac2f9143a836d902f246808dc1438a502b1e14036127c99cbcc4ccce5c8c0d146b2167bde26236b3ecc76ffd98f55d41222b6c05467a19eba232d11d5fd5b851f84114aae1b4a048a4dbb631287f0cb1442bf016f56f30e366be39529eb895b6c2bded5c87b9e0b105f9b8c988c53dfc964dc7f1741d395830a6cc0211f57b9ee7658a22e62475020808822c3bfbe54e228a19395273c73db7458326e685ed0fd77b5cd3090c04dcd59661fdcd031bda6b26fda85e29b12762e79dfbf00caf65574b6cb65be673faffca2a0c59a1f8e9535f5e5c62821c6d5db6098a58c82ea076f5d2398287c2504f8796ff0db1b4f02605f14930edc366c79effca475f2616c30aa34a30651060d28b5acf2c57701366492211f096c200744a5564919e52afb205aacb8776f63572e98a3efe7152275aca2c02c51d140d17648393e02113eb26ffb73145165149083bfdb5b5eacba8ad17907ddde5fc0f4aa31e7a15e7e9e12432fa3074f48b6aa1e173f7a8758560c610b87f0dc24776ae7e481f463a849c46d95efaf94ebb1482556cc20a41aa305da434ee9ce7e6f693722f06e66f5d7023c8ad574688269a61949631b5718402ba9fabb9394e01f217a32fbe874ca5560726e7d56aec1bea7ebcff0692863d91290a9d1bc3ba5c0c55ce66c0a87774ca6b7c54be37243d0d07fd3862b0c83f445183938e87275e683c4c66cb883a3b26cd917dff976ecf320fec98df9d63b3dc2feb4b2f0aaf9f78bf0d9923daee3f71ddbf0557a87d84d3beb5fb0213dee9686ce37220f81e43e0db6580e7181922856a72c6bffc4802f0db5e9deafd91260ffd7d2311b6da6f703817df6e4e0253f6fad49ed3870acbd0de7f9016bd052bf403f7854fd172afef73edbca985d7e0ebeef806a7c9f64dfc2840c08c2bcca467c15c5fa1f1272b99764a8991f7b081a917f35eba6194386e346765cb34d0771bfcdff505ac8232db8ef6ee9d7756bc7f0d3c910334d7f44dc31df9f1e25729127d8b9146e8ecc2d1b679d7246cc0489571d10c9dd76d4f0a29fab9d8d6790c5e049b91780a24bb08e9395d8c007b96ce922d61d3f8188b7cd006cc171e5a0168d4dea1d27e53008a72f0a5f91a663535c871187c3bfe2d602e7fcc58cd9dd937f2cb0c3c36be87b153c8bddda5b4dd4674519fa3a039f61d5ea505961d5d3fdc83570fbc07997cd9ee9092f2c97fca878a9213b2886f1a33668fa2b606c42f8bf3b8af7bbbe46a2ffab4dcbb722335f9b3bfb355b778c7e2c87642518cc264281b54a4c9bd2570e264a1c0638741ecaf5e71cae16545762c94d408d489e593230103651a58d65760a5d724d384e01a5c985f795eb2e52e259090769b52f851f99fc7170724e007adb0f4148e7929bdc55e9edcc81281fda2bccaa19d9a81fc16d3feed46957b54f2d9c5ca0ca60a6ac255449fa3906ab62c6ba1a57e1af695461f2300c5a9dc54808fae7528ae72ae3f6049b7eece11465a0055f31694c685b74f06d229362b82539020c886d8a31cd7293ff375f9b5afd836c1db96771c227a257f03b365e3e011aaa27878ae15db6d730204d59246765fb2f151549560aca1c825d63340b5e45255cedf999b1f8d391a969af042f9af9ece5698ded7d438c87cabd5ede82b01628ac077db8e9ed6d5a8376f9c21aa64396d248f44f454f97bf5620756e76f37404a10b0d2ab2a220168414b32fc5b0c6be1bc0e621314a803b65078021bf5c2fd12207fae91cf205e7eeff1a98f52b2069e690821d832c344157226a1a47bf358ccfea060448d0fdfa6d3e76429ba635f04c4c4ea84eb37089cc8abd8fc6e2050b1cf78957f3b8c3f56ff516fb83e7d44d5f3b2bd991631501b08daad6dd99a74cfdd859de713197dab4fbb24554f7df1cb1e4aa60f0c559fe733cbd279dbbcc755fce009f8f37110e70915dd8ea43afaaf6fe704f783f504ed90b2514f5a5906d0e9e2405ae44a12e326c4ef94c263db6654e9ccef2d9cbd75612c64394da9d89ff0db90d54d1f592b8dfa4df76239debc1f5e71d3ceae8b624610463a08715116ff4be381b2f0a9eba6f0a496135735145561d65f345dc6a01c4e5144cbe4548341fbcbdd5a27b1956f65445942504100893c245b8f413e71b38fc0c14198eaf31a1b2a1456257e6119586b1f7783373e52932cd4d55570a9cbb7084d63a92fde1e50d2d2df1ec10bb1de4143ab4889fe75d61c2a1a06aebd61b100abaa0422905189e6b7a103ad11d83134f670c1e71b67d23b286177b5ef39e4d317e6372fcddafd395f45b9e43f45bd5e71da0f5ad6f10d391864774030bd7d7e19bb67262847a3be862b551a7de095472fea3f2ca86c7c496cbd928f5ae8a3e5269d45b23b817bf402c1a07bbdf15edfeb5b6d91f75db878085f8110caf0712aadf8c250d554f48f046e7bc88ba172dc5b9a38914a0e92900a13c2ebfb6888057af2c427bac3cef4bc9dd066ce14e3c47f6e70754e4dfd3d939d1626b9624d8c039830c8c4ab8b2955f263be06f770e5816363cb687044c9e4cae2ecceab05511f0e0f68526937deaddf43486645937ff65afc0c42fba1b2d4ed77c85b402a89f39498bdbd39d259e73424634f90c6cf920e492430a7c0abacbec0a7f7a5efd2e8356ee01c79318a00e98827eead4c7d9ae3ef52f1191f0e181c3a59ee9d0ac6d3a0586cf66cbca3769a98197e1dfe22681d16b5b4bb57dd8a1f70cc0a2084bb49030a917cb0f623d7388923364e528ae00bb00cb8f229037c0e57f45d81c10f3d60f29ac15073dd1dbae95d84904f3ee90a35c5d2cf9072eb44251f2245a5b546aac0b3b2c9908aac19b87a34998140aae6eb59fc0304a7794226774a7afe915a360032a1b02c58bc20d8c177cf946451d416a3786c82db63b44cd4cfe8f6ee397cb7f7787fbd792983367baa23eb0d0d18cb6f95cc202b0f7b6f12d1a46440e0de933038d5af1300d9cdd01c57c31216fbfc9bdfcd0450f53a76b15b01b0bd24f7c844c64064d2716def74998161861f6886949f2287ea3307f1d508d21592d76e093f8c7a5f4238bd21457bf2e2b50f80f8f9dd110323fd30a7262ce99b6cafb4752449849c0433c4c690d037edb9c0750462b888db5be61e61e719c4128d770dea99ea2da5a34c88be8e67aeb136750d797fe5d76ce85e7f29b7fd7a5f6a754b04b2bfb66c4d4828888e8f24965fa4a5bdbc9f186d6841b756d36d690da16d8219a9b2923d5ef9bd8ad63d7528e72cfd44c3060c4fb232c51f0518ec19ab4e5be35192b69aafa36f5f237627e6cc3fb6f8269387b6fac2f51202896f9d67894b0776a1eafc5b57800405b5a69d80f8df9e159aac1c9590ab5a2ceaa39293c511a94ab2caebbddd52b87bb65797632f7e7d0fb2a0956f0641201281c0a5be98524064e9ae8b5e8ab021b3b3df20e0b85ae136fec43254eccec1dd29cebd36931f44b8b89594f6f12d991ed03aabc1d44bbf25aeabf95699fb95bda9637194ff64c6220391d4b2929563f83806d677ab9cfdf9e7edb78e309811e1d7c3ac962f21e92f38b300b8ce2c20b18273df4957a1b5c91467e470d40ba0a785c503ae0a728fd6fe54da932c17fe457eb6cfbe1c5783c243c9d2643cabb46c508b6723324af8a5f61876d2d62ed2e14a9fe711bc41adc7a1ff4a42974c7cdf23ff3a11abe83eb0177f414026736bb57d8807dcd350bcfa6df03626ca4fe793e6388f8d05b668fd7b4e996c1df618f3d36395debc4cf4f20bc6b03f6b7404c4a3266d63693a2bb8ea3b9fdc9058e5eb61215a8dc5228887c0288de600a6aba776f525896f89f60ebf9c459111c9058111faf2347ec0ea5ce04f41dec9196e14e0c3e34bbd89f94085bda8809fdf63c69e957f7cc88790b3f32b4463116418aadb32f06e04cc0cc9bb800b67046bc45eba6025aa11b966a9fbb4c393dd059bc10b588bd8c0294fd0554e56c6f32d55de5c418cedb6b8e189e399113eac4702ffa5d6d164fcf92c7f99e1c7fccd1012639f8b88adfa75f4ae1405d93a02a6da8bbb843574b8fbd014477d5dc2f4e5e4bb59e808b4623b80ed05d98de4e22e97536f2b8a28b4a1807c0c5b79504f422e163e266709dd4cb819c725cc7520508ac916a2bba9fc15801922b63376a36d647c6eda5fc86c91a7d50a6f4657ffca3d45659ae4008569fd0d468d8ee4e8466588787ef640c7911a9e09512f3b6d9bb9b4b35eeeead8621f8f68311bbc2411466fa077eeda9330d5d5dbbdbf9886d61cb35dccae3690e47cd8c859a8b21bbcf26951ce74945023a1c2efbb60ba4165725a349770f4214d4bb3712a14c96e3258735b6e37b5505d31bed8ce1e1ae66f3d820801e8d35da96c48af4daaf346d1f5582c4b7fda7de7849bea5b5e5253889078601a76bb8f78fc6f3d377f6ff8af7b2506905c70f535cc0956bb56352b34a52e84c905a87f3e41c9530789be22db6e879c98cb9669f565d50a41ad0f56dbcaa01781051618a5d1988ff85197206d93843d608aa777de5c7547b92514187402fbba9bbf1f419e87475080df70861aa1c5ad10cc06153ab342f7f03764ccde4de1117e30072c968a04ef1633a09e80518602cb02ecff535becf60cca2ff66406bf57bca72c76c31e0ea55adad30719b984c4dd5422c62db4810a4d56597406446bc494b23fba049b9346e152764632c4435e69468b494f3e65e0c5333ed8162e4725a7a1ae617c4f8c6a121019be002b271af617d8ad39b0817c624f16b08010d95f0d5eb30f2b0f233ec7fe44952d908e5eb8668e49a1b17d708dac8ee367fb8f756775ca5e9fa282b094796acf2e3ae5915863c59a9f193c91c2ca0fe8fe676269b521020c8a37de72bcd0ba53bcb5b0130d00122badafe5f97b47b1b3d8dd46901530ef668bcde2aa4c339c0c8362dc53f41f9a7c9a946c9e8ebe7a3533360e8d26368529ca82cbff69f20f227261348dd9fd69280811454e1dba66e02c59ced0fd48b6054356c9ec4b0a62bf3a0c35a0186b6176dbb35a21179ea5c6c6aa4a025d6abdfe407212fe80d85aaff8fd5d7ee16173a59bab3ee27dd5a4be26072c259f188dfd9d6edd529780751ec0443ca3e80c281ec663e28d016f770db6ad4663e00889a7369f5fe59480279b55492ed3d1502df2bb58686cd0ca6d50b46871bf513586b2fbf0c7ffc8da6d92d663773b20f309a4f21778886c9b4fcbf1ce4cbe232641884e9099f29c3c08adad7a54be1c3f38439ebd9740480cb8abc6a238e0d56e2d658ac63a3dd1c2bc51a1fd57dac283117a7d6ec6c4cf68f24a0895f8b536b0f398863e9d81f9089b5ab874003d0eb6e8f7f81c75de1827e8b16cfafdfeb0dca5c73116743c4438b819a2f9a4aba4c82abb3f24e12e34891382f28c6a796780d9eea2b5fca874208de12c975852a22a7125e9616ac4fbece0de412f9d1145cd8f154669eaf64088539fb27537d72a24d1b19927cd71891e0e5b8b76d57c4de362355b62c4e5d13f6c67ade54821c3519be0daae7050efd488414ee1662eb5fbb371df0e821cfcc18fe7c1eb661f767d65db3da3e762c71a6be93460e27897fe2837e9b9ef94c1bbf851ea87bb10baa9a7e13d2bdedf55aaa658ed3c1ed7ad81aa298f248acf15a7156cd424e3169c6e2187974769c076aa839059c89fcc54951fc00749f74235fea9dc55e206ceccc9b02c037a2b474ed46d352c73b27ccc74f350018d056d694a508e564502c0ae1a2ff101d50660aa01de62afb1861583de16695293ff2eff6c343e8ed03da19fc8085199008b3e56aefb1a4887e5c4d5bf326e2582b099757eca8e2f448dd7145f6e4c5fa5f115304dc2db4896d12474da5ec134672044d8816f32324d869b1f7b0f2e7521aaf0134dfcb287de9263cc8150ae7833452ebd8eafec5fd3dfbcfbb61e59c84d6d6dda0fa98692f871b6bafc59e2d63d79ca901a543c8330d1682e87d334894bd17faa64b7339b6b37a3187713d4ac1e39f2bfe9c216c42c9be2ed9f48f6887ddae1ec39b527961c09e13419c61a06cef7b9cb7a53649a399fc2dd39c5e4ae14f1f03719acc31792ae2a1b4ea952e6c38020f90c621928f187585fa359c6b7fe2b847045b3aaf1300f912c4dce1a7dff46a173ecc5c2f301f913a141ed5e77cda9296f2b7b72482f91e2871b5667f2215ad7c41fd9de68302c8c6af9b5aed904ec20cf67770a590c6bf9ef2f492e76acc1a5981a7efe3db5d05ff07a42cb98f27e0365a7e7f0132061d5b98d5b8ebd7de23be5cb40d602d0bbd7e0ac0ac7dd602c77370078a708f093e5d5624e163979580578cb003f0a24ffb861c6f22b5a4347c219e34570828dc1ccd89b7c5433a41b33bfa1ae3a19a2e792f0420685e7ce1dcb5824c8a39c10f4c107200dc1e91d5c988472e2f29ae66edbb833c239898d9d98a01ccc548020dd8ca1764a0ca595e059e31598c506acd3271af518072597dc56c4941a3d1ebf7a20be9b9aa736cd4ee593b72586abc96b477b23c29f54546ca9ef2938ab89f52a18b80ed030cb176981f5b44bcf54b13fbc0757ebbe4a630382eadda5eb185c5a9f974d152e0f0feb000ba417f5519309fd830f2bcc11df76d29ab66272262bcbb05fd6620c2015e89b39b4df40eb431837e876a86876108c17b6c8b5fc8b57b2cd99a39515700498ae8e55c47c682bb1f1067e89b2437e92a696ce5bc2c25074aba6f1d492db7c2f9525b1ac574c288d19cd724ad831425b54343a7d7cfa4db57f9b3fb4ce65136e2098cefba39f40023aa51efecde6f5723c4791b5b6d800f939a782ca1fd49d5d24b73c5687d044fd4d29aa15f3ff405aa437ebba2adf3590f6c2ff0a5d413f2ac271974e70b5db3f7120d6d80ef4f0f5a561bd19ab9abd4ed1b252ce03dc5d9f5d243a0673f8a15d103a0664f4b0e716108c28df776444004470e43b81f7c255c9edf100df7006e4b7687cc1e7c8436e20a8664c8f0a931b96c5fd9cf836dd6f6440603ff4eb73d1fbce572ed1be9332d7932b8c082ac962dcf0485db4d943cc7faa4173009e518c45c6feef41078f327cc65bbee19970a4d8f0f177252a45a046a84faa645b42cda96aa603f61a5bb6250bd096b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
