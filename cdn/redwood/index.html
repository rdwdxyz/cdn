<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b921aec828ed1fbc9d588e157c9caadc372c0405cca29ba5e1769d37123966bcfcd4ddf0036c5cb99d958e32ce2d666e0824f636f4d83ead90acd60a6d2ae9e18afa0f8e8677b0c9b6d055eb00e8090f2adad1b1cd556a57642f031432fdce25d78c9da01263730b09a44c349087039cce38cc3b5c22eb214dd031b4e2b628b5025bc127aa5c35499f8ad684f61f4c5e9eccb8f71d3dd97eb41418f33c4b73a8557eae2e3f79ff57f93d2aa48fae2d9b0b8071c7ec7a8e384e371d8ea960e6ddf322abb45738e09f82c7d0cf0ca56a9123b69fe43f745a33ad4f977cebfbf8fa880586dab7b7486fe36ffa14dcd59fe80b28d4f1904cfa34664c1da2ec7c5387b3eb6bc2eef85b6129ca731276d127f2ab6272bf7163a9be6d0eb39db275e3551fccffa13900a879f8a7a5e97ee8981207bcc9323f923780f4244db15699f6da293f602e2602c6ba373bc26e59ea157b2f78129bf92f707c6b0b9fb34b22d3c332d4ed42e8db612eb1ee4de19f8831bbc013e27855b37b93a0c2bde02f2ef1c258b416a38bdf9b373eef219a845c4e29943b752c431d7e7f03a1b65ef9b338bf204970874b4db4af59c1173e1ae4dafe7baf567fec587fdd74267a014675d4ea9501eab50b6f1057968303168d6fe018eb34e9bb8a5398f4c7dea510c5d0f3c5f8666d82fea637f29ee3ffcaff66aeadac489bb66f768e0f1c3cfc5de8a39fb5e43177a70ad7b7d1731b1ae02ee48b57683d45db1f8218c57c0178122eb38d1dad5eb7cd6eb94e1ff0918ee0d0d6b6960f72ae7809428eb609921ef4e2f05fd90145123fe2f581c0cc025298e05c4be40770e83fd0c70828f6f8161593984bf0a263251ed8e0ab78a70007908e00e125829f700ab24edddd1e9d4e5d3e57c95aa750df7d0b39a32a0f93aa28bc94ad8f88328d3ede525c72e5c53212b054ef1d226aa312a1de0a28ddcc1a8db26d0cee5976d2b56e577af90de0fbc3d48a2bb2f46170be58086f06d9c6ec1bfd89ed23942d775a48c2cfa6652e7fe1311814647eb8a8f3fa553d3b3e6872a556cdc9574b4009c19e38560e949674f96cb563a2b409f3dfcc35206544832e0fa1aef9a293369afdff8667b8b6ec9199115a2d0682f10ef72b78f6b06b3316beec7bcce374abf9aa76faecfdcc31328ee17287dce38c4c32b5880359fdbc947afb0d82f02443ed3521a71d4af6c49a4c16b142c8d8ea885126ce0ef5e67a6dd6405c88de950888321b28a9fdd0baf1539d4b83507fe9fbc07508100b59be1958d96c02493c97f0e8b3958857ac56c2c5897928647f1e29e0add0ade8cd4fd705f258377fab481444b62abafc460774d5146917cd8dfaaf5f75efe9f0aba467fcd58bfecc0e6ba9e358c8c8a5ddff017c557fed61a2a1785eb595f404824c3a71ade1fbda553f64d8f2c4cfcea295683d8ff3b32519863465a588bc90a96bd9604bffc49633761bff47d8a1c6a5d4f334275c1d3217a930f3a05ce1bc9273b3fe4d160374f2d3611df135e0aca3d2d79cbef517c030377965a412b0dbe5e6a0c4beae89e8b8748525a47cbde70c55967f13f7ffaca6500ab3f54bb6b999f4347debfed53108e909784e7d9e9d01a9008d0596147b555fb75193196641a13b64bc27536db5213bd9204c7bbd76a2d0b29bb4a785c537aab2f2c7705e268cab23113a020841a083b69560b67f29851c3ea1fa0b0ba831a5824064250b1dd131347d54a6a31075240706580a322ce560462e0f8f82ad58d3ea9dc3ff93bc2137f8d6cdcfaad20cf2f743930ae307ab7e4feeb1d9604515a94e0fe89f9fce455b494061883b2f61c82500846030b84de34b99a02d22834eb6d05f4df2bc6031d2cb10ddca133b6aef93b2c5d7cf6a78b3860f26e3be6946b10f67905fdd175eb43c4625762f1dc67ff465a101acfae22fd38f1dba3dabf7c57425865936b4e72ad5761269d05cc82704de3b2f9f0b5b69336bccf80572ec628bb9d7636ddc5ba16f024298e19375e42ceb119e26dd4f147d1b4710599311ad0aa25236fc225038d3f3f088d9b2a9cd8b5bd85172f70895482796f71aed0faa9194f652206b7b73e1db5bde991938e956709ec5a9a481078e0c4a191697d5a5bc6958ff8346da86ff7ff9faaee09eec8752a829e46588877781b4e9d1cff861c0800ce525cf6f01ccc95866b5d9a012bccfbf608bf717132062beb0eaae6e54c578469666c7c328f6ad9cb38c4545be161ece1c716bdf96933431a50040d8b76b6ae4b6ae68ee8d26994152fb028cfb30c5b6d82672fcc989a1f91022f447641bc78648a422efc254aa96f4e3158e71ca5936c6eae181ddfb13dd7f2d3a60a48295ce7d4b7ed45ac8573479176c93285b04741497cd3ecd9e1a9ad99284ee6e05df09766750fbdd9c6fcadfbaca537524fb4ff44f6fac30ace2026b85301534279179e4f698ab2d51bcfc6bc235534eeeff856de276b740f856fa70b4315402d0b5700daef546919600de5414a54949798fe25f88be802fba4c06f07a96bb84aced87a8a205e76a2ebe3a8f087092c36f8bb694ba6230516cde748e1845e3f081ae58f2b55037731afcb90c2a01b8d735fa2084e7ae4a3fed33d40cd5adc445762029569a9f71cbf47bba4c91484ef8d41a230cb85b0fd288a8e1871b0bd2bb7cd97591284be295778ad1f586248fcadfd7acb152839b7a75a32d43da9d132364e537269e5f4bc5442c15df852391a5dcc418d5aa3a7ab2ff994c69b5f7ad840ff2c86dcfba9fa6acf2c5c8af76810df3e25ebabdf6796c713c95f8d16973844a77e8f54aeca2a0c6973e973fe1522b033fb9c8a38450ce2c919449df6f34f334b188c7ac26663688fa29c3df8d34f676c84a8009cafce2c34e27cbbca8b885a6cdd692932fc56df2bdab80ed80009ee62029d8a85375869d0ca381ab83b945750ab0dd7f9d328009e316a40257670b5c3655b4346037d1fd3d0a71d73c3f294de780ecf1f8d3219d57060b9c9aca31bf9aef49bdb6cf47606ce3e54ed6470883afb4eb2c9fcf8a891c769d20027939d33139d43f7247ac004b3a4368d018b0fb5ae43df8a4f173ebbbd3fb096b14b4129cb5ca159e38f788c07b03a9ed2c1af1d4710b42b4ae40cbc2ecf57753436bca984172b7e0792cbb9542adb42bbb187489e6cf1400e48d212dc98dc1a0e306f4bb69dde5f4dd2e2aae66ac2664d1f33c14e99486e6fd80d4c3e493c3c735952cc253e76254ac6058cd397b1c4d3da9e00885eb56a430354d69e692ebb3bcb1e22a7e347fb5c40f894356d28201ebd9f44d1d54c99f93a18eac3285740fe26c798b5fd52c93801d5ab2e98b217aa87fc523875338282b4a417352a5a9c2ee663d13db5fd2074c22b5e84b22611ea3a1f20b160628ae9296e6a740902e7e5632082b2c6c898dd790282ebc6d1de383743bb343f8949b84c33dddc68e584ecddb724cf08afdc8f4f41df8513e17143330a438cbd15253396b315e645109627052e0cafdc72a188afd2216d41ece70c4359aceb3ed0bb231ea84fe6f15552a7b187ca7b3067dd0296b958ade60680fdbcb2e654fbfd67d15ef030f6a03d7abb574e49594226622d8352e91359029022f64ac6bc338696707c255966e8220756d4916171ddbbc6bed56127bed5da085a8f365864021cb3e25511a6e335ffdc3d61aa3e07665a7661aa1fd59f1e16f5974f1eb24ecafd9955b6afb9b2f306a4522323014d84e773de54881cf9a44e0c85b1cdc0209dedc93bedc7fc965d9a986ceee611da0fd71fc43443ead64a88c32ac9652ceced86209b82bcf407fb0e3d20aff839b2050ab9ef11cbc74c90b2e0624085cc618cf40e98b816e2d0443d9042203e6e239a9702146ee99aa08932c455ea6c07d2882286cc436592652dad30aa407675b1325f53cad3172858058316875b3904bfa3b63b4d1ee35a8444721aa067ec6325a51148b18b1026def7c6fc5addaf32721e102ba9e6e974e070cdfdccebc902775fdecd10a950de6b3c28454623db732f06af2a7b667baec9daf126e827f3e6d97a5ea3f1bdc172afd401af608cf9a1001b9722635ffa44ce2feebfad23a9c1eae4a5af1783539f635ce8bad852b522ab5e79334aea16a78540ab314cd2d47d5f9cafe573b784c5e870b375a2715e56d6bfaad7dfffb342515c41f95560f7a139548c5e884fc16f77669c27a4e3c13e842d5ae848fc64271e54e6711470edbaed9f42ed00080a3ad0aa6de13e9268f2cc31e935e4bbd31a95b8bfa4ef068a08db32bdc0aa3f01872c562c9b5c2e3c79cc3668cc6b2b83f81f1ba6388e7149deee9d30014442e873d3423ae6e8c73c52abb19b75e07409f886e061483de3ca2dc97fc1c15636f7e5b543ea10d30284243a108344073b33aad89cdeab83900e5d5de7015d67239fb6c99ec432fb2d7dc6907d9ff8efdf6bbe7a6d8e38f173fde76cdc37d5fda5529e3fe371c64e4f3d1097c23cc5fb2901de754139c5ce2fabd9b64a13341289aeb012374cb94539722bbde67e47d68f4f79f54b9b54728192ae1e392c9f6d5d691fc64eec930238d377efa37b287741d0772c0aedfe2e59db552e54549f55e14c01164b283c20e906df179c8bda26e5e29bc1b61eef4e89d274c5d3612c1076ef93369621ac7966478684d6d23db70386e6135ac0b2bc58ba0176a2b6d306434731f40f1d1ddd609ef33bff8b1af70af68805aa65c851a64f04cc8b12ba2111c5328a5af30becc39b21d17692c21a36fcccdb02d9f6d3acc32933ed05654895c125020a9311ce3535d48c48621e800d1a21fe7051a95d98f0ce4dd5a53c09eb40d73a64e8631429058cbea4a98623b974b4253c2db3f8105e5321c1246c111cf3fc03481c202e8dd73ce5a65a3b9428c9868fd1525581572a55c9e3221e134ff3529d7655a55315c312a5c3b50056d1e7147b38d88a54502913f13d1f8e2674b326ee01dc90ddb85abdc13df848da5fc4a6bfaa4c91617d838cd6c73947161af1042364f672d64616351802e880aad41be05a0524edc1f3de945820083f7ff555a03d500134f9e8240fbd0fb163e6b6444e80d2b4c5ac747cb2c5b897be2a100ab3fc23ac799f94fd0565d029b2228f38fa6ab133cd51f8e0f06ea21b2a87ec8112efa27e5c46709cd9be07f89587fc8fd499bb704e577bf82b1a95121a73395c55adb4da5b64872b329c41081a89d7b1824bc5839eb693776b44a62f4776910e65a5408cb77f6479ca689841b76b9ee68357cb53885ff3c81049500956879c9f0c6ec8a52cd376e286f6c8c269eb4fafd8d83d8617d2395540f9584b0bef9fccb217a9d4e6d7a55fe0048ac552c5910b978eccb52dac8a9fce089a324daca6316b87ed45ce3d5a0730ef4887606a7975901fd187b6aad265a2470f54b87d6aa79da719fb1fe65bcc83197a5015cc1daea41763d3c6cc26e58339bcf5c1b8a6c30b595ceee804d5592c65c018d4021fec24175e400409b3719f0b8f9b6e8929c99eea5c4c1456432108c1dd5934928f81f973a0c3b6daa7759d8192f268dd75dc10f4a78353f448b05c6fc78abc9838de785a02f18838d0507f8e0c0d72204afcb1d2ebae60919ddc60cec428e52a96184c37ca45b9721ef64492d478d2434211593822fbf019463d187f1a127bc2f5d2049ec38960d0eea1ffeb24fd021a43458e6a9d784d6fb60b88843ae9d1e7e42b60fcf63735c400b62eb23a34d8b5d4efcce0bbcbf69093756839307b3630fcc9222cca93ed12424a639898c18386fc54f7b3812d602eaadf81eb973170fbaaff0d1d140db699da7ca8a342b2095e11ce1c0f868fcc1f828d5d2520437aed43da45f9aeec50d8e74403818f0b2b2cb07ff779e632eaceae68f0e4f65242855e15ecee6b7be0e8bee41286d43eeb8e84090165b9da9e85018559727c2910b9b218fc14acbbbc28499425ff8e176a57a550c9a87266dbe1d6377df9cb4316d917bdd75817370d0332839492e9997afe53a2ef48670b0431aa815ab7b4a16d4865701d82743b0c46f22a1f9ae852e1a52631f78753b3cb161b861edfe958532e7abd4f278cb521ae131bb22a5440c6056eaee14e524b76acdf48181be3b68c0828dc33f50005d64e5faaeb3229a72f70954cfa8efd1d80902ad60bf20c99f155a0fd63b4b936f51eba60e986f9d435142da827f8fe201b5b1e28b702cf76fe51bea8ad73ddad41311a0dc7b3bfecd992e5315c215a9c302957aada3c1f2e09588a51c21871249178501ab236f09489a052cffd25fae216d5923bb8e42cdc9c168a72efbd523453097a8b45a898e40f17fbcf07c696b08f41725a5793ff49c034163df725045184170a8aa72728f6ebbd181c3507459c25935c43007c1a7fc26f20b2ca1ac17c6266b3e6b1dbac085410295302f6f81249d9fba657d1dcb49458d2c0d683ea9919b22ed3b97c1fb720fb0cbc2248f87dddd32898e011cb4c89a7a45c28fc1a460312f2df86061ae34cdfcff4489a82a29ae51286713b2047727efe62f43dcfe5349b65409b35a2510f4b26f65cf0c16c86d284b15baf8efa2bdcc610fa76aa714177028feba83605a6abe3cfd2a02a225c50c0cd54a23e5d2a54c5046d09b5e485864827199b119d4b8e09bec30ab000bffaabc13b12a80d40c58f10d386fc6730fa57f67462ffd713f4e24c66867c94f9e0fd7b1beb5038ed840d433dc2147ec2e63900a869647256c6fea14a85a635be19b5001b2c9bd62817c5d4eac5dd9a5a5dd202e3898f7dd45785fd214d2570a502e93ad165e93f770e1751db53611b0a7091cca5596551c867fb31dc50579cfe1b362de56288043f8d1b1e396d3f9c53c4eb32b5e5bff1efec1306b4b36fac11bd7a281dba7799146a74c15e646d395623e54a35d0b322d5a7ff9e77aef37ed0c96f36be72e0fb7250f7145cd1d9ab098a609294028b7727b634a776e93512c5e9c012c7b680cc82eea1cd4ad4eff8d40b16c7999bd519193c139bf038792227479ececad918d4fc1382b2a13ef876912555754b06e3dcde12f79ca3dcff635b9d1df4f0cdc283c3d33fb233ee21493ee88306e3ec994e913d8ebd265b6c0ed5f9d89cf53cb3534244509a00a4e61138a9205ca92617883bd39967b286db1bdfa1b99d00bc7f7a0b6123195430c35d1de8a73a3f2a9a5b96f969d71e177949346ec8650e0eb54e592258e126c43575eb1d82d6dce88e93825414d1b29bbf27db736d2a4b0a339090ba092e757becf29a7dd28efa1c69381ee7617c5ee8080fa01fee48f3c535798b4f391289774fcd85fa81c29a21cc76cd06339fe56e198b4ef1e15ce4fae15ec60489c46e301f7ba4274e7acc6df511996e1c408737db9bb96992621a2f93a47d44a906aed4f905e5a2ee85bd1b772d7f7eaec5f56d84b008761d1ee4c817504f8cf5328e5d197aad6d755fa6c91e26ac3c57dee948fd5a65e08c666d26c5d6c7b2d093a0ae7fe5b872af84cb2275fe8786fff4183d04904977f5fba5a15afdacd20a77d63d84fa16554d31575c69bc43eec2748c7c9cb0d12950b7c30dda5e6984072d3327ed9f6804492e00986ceb8dd9aca43f79b72e4fb2afdf312730bdca2310d422da2352e08b2b01693615b854674dbff17b007d3a96a718058ad58324bd41a2e1b1cff82e3f8974a71f0efd79efa187be0b4e8b151138697f6debd3008a44f2718b20fdfda9d3ce93821a55d9b29bd24bf9ab313b94c574d90f1f0ec55d9cf375dbdd020f88b6dd1aca45de8baf077239af24606d0c1750954e5fa3350809c32cddf87bdc210dd658c066313d0236ff92755d960767d74b0f6b50b46b04946f894f09ba7173a7a519d22ea7c8e3f6007a23b4f9274c2eaf2d8f2ff822e7225d2af67424b3f3880fe61f9302e6921337d4fffac428ef3734882398dec0952d5a5796ce20bc919fb164bc8b9225b26c015a48b8132230055aa78ebb3578f665485a5b2af6cc2dd7fbe0de8e21e326e6fff108d08084fe3f3492408ad158c6f812394628211aba39dfc0297eb01039b38433f2041e0001aaf850922461722f5c19d6c9811f91993185318a25c61a90429d4e8c7f207bb427a24fe00dd5a28a7119923ac1da3d152e956cfb53561ac914118c51590b4547d44dfb9b728603e26b1c68b07dadab1b42926f8145222da5cedf95ba3cc9cc83aea02a8ef15dcb1b9c59ad9ab887ae4354d9dd2c554c0be7e9a7fd8576672dd19603d6c65c278a17f6d238837a05fbd7b6a30fb2c220694fdc467d1b85cd22c652892d53cdcb49e125ce28f5863670ae3cf68cfd68183bd0cb5fb32660f01d69ce6c55ef68d15fb490bef7762c80f5b64da26aaa8a867c2578cc26896d3db1b61ad8f0e24bf35cdcb898e11ebba161beae69df433f16d150547f38b640640325da854b87236b7b86b094a04876e53f7362194e83017410597e66c634afab6f0cfb54f11442426f0d6945821f4139e268b1623e54e7f237576c4a7bd2865759a55e01521be5caf50fa8456799619e2bf4c73b7fdf21e2e3ac9ca0013b8d09c4bdfe75a12da194d5e60c396bce48d141f90af1f7308471c0672edac6011c994900b9352b5f068068df8135b532b12c9ddcda19971946015f2a814cd7638defbddd7000072e78bc3df57e2d88437c71187b239b4aa7168f7d859831051af859e4d350158b5d43a320601ae7cd8c67d263e5529e8dd84987b1cc49b57293d4fa2452e4e6ee915d429589cb9002dd6d524539c5df584737b8fca874af9f2368a73bed8574b726053636982c784449c83c283e7e24a241e2539032a21245dd54d9ea6f042e1cdc60ffc2cbcaa16a4b216041a0adf0cb69e3765cb6f7c66060ece779abcfabe712d2384c1b5c2426071f17a68a85858bdf4286329d5e8a7b654aff8c1d1897b43ea53b67ca2e0e7691ac26455e1f0b2900b198112f5acdc05aedcd83759b2e25234af49e268e38dc7e5adf1d71d511d7e73cfbdcd0bf04b782b69176bd3e16502d4af2a2364eafd2c1e7364207371a569a839c6ad6b2960d06ede21b6543288028c152d36cc4ebd1df058df66ba2cdff9cb81ed51f892783559de383d865ee342fcf5d8d25cfd4c376b7fcec466947051e575f9f8beff3611f6f872d8ce135a37f49aca351d05636af6e8c8e22d34c13bf88fa27fce8e2600efa228e2aac05c5b0146d845c87b2b6aa46c92e37ecbb1a20623a5551d7f1aa73e1724b2048255828ed873db7ff6675d6b12a7b969ee31dd7ef98bd810a7ff30963e7874c83adbbc41f0d0676cd3e5d62545823e5918e2fdc474a008451947685bc67c48dbfc5ad2f43e00578221ee2358e56dbc0beeb8392004583940b248f94b80d1bde4b8d2037d5d3ef148014626c1e5012540a95b1110105439745f159b6d6bd089e968171ea0e855a4ad6e004a55bcbfdf4a6cdb6103df34cdde1c96600d1d994cb0fdebf57681b562620c5e5815592248fa4afbf6fab95ba7f693f5ea7c32360ad8880d57fe1219cbf683e7008eb1c1409a5bcfb32f02dbf823a882f8de864a4958f43e1901a2b57dbb4bcb3feb1845a87b1b9395122ac32924aa6644c293dd3cbf7cc1ee4e180554ad82edf6e073d1bace561e32c190a551a2b080b15fce8098bf363a6474315bd00fa9d09a79d356379d5702866675a3ef4ce9fd686d0c5bcfcb31e7da44bf29a930eebfc50df3b14d601ad27041b910aa26ffc45b659942447ce59695dfae4168d25e497dcec1c76c9036f0f540bc1a24c9aa3e57415131dbd30ec659ae5a7c43e60d17565ddde66b26aa5db6c908bfd9ae2286ecf6d3dee92391764e8e50b47a65850ebfce53b22af062234691d9ecfa386656965f85b2ff2259dde3258a0fd52aab3b887144264b9e5c18a24559c444e128b54c7ec8a90376655c30e800e48e51b8380a47559572251f59fed7af5125f91e416d7300538f79a8d12a8a742e09b9540d5f130893ec926db714418eefa2859668f83523372a58bd0ed794724cd6deddcf3fb293b74fdcc504a0ad238cc9f6ed89669405bdd8ab0ceacf5fc3c68379006f2c8c317e057177a75e6bc841333295c38982ccb80a5a7f829ab8e0f01de8114afb77f096b0787a6cc9849f0d3cca8c8d405e82ecb3f6c2eaafcd3cbfe68e78f624bb62413842b2d54438010a7df844288aeb87de4f510e5e86da15c6e32ef468ba2429edf9bb7d8d935340edfda1682b02b9f8af829a2e6abcc5b551f218040d84f6bbf428afe8c06ac07e936be5173191887695037f27a1815e7aa177ffb3129ecd9547605642998a41c8d46d45bf0c6883c43a9017bf4a1743d07fba0d1215b8cd4753458215a569e327927f53014ab427afcc2ec52778355572e28eb52f1db0bd53b323d0e121b9166034babd8a8ffd7408e2e029dbe402674155ec95776a84104c086c392b3f7d00e13600fbd20640267eb2b47c82b12e3bb8eee6257e3296906a4e8cc9bc7179fd0d194faaca0f9aa2e5cde733b7de09b0b49c99e34d0823a7189aaa7274e55341863d1b4ce7458463a8225cf3c3111ee174281cc25472cd2cb2c3fcbe0888a36e8ed9a4fbe76bac58251d2a406f5b983e61211a0402672407da0b11f4a93cab3ff3baa227653a7c9d36ff8789d948fad93065b0c22f58f6e7d43308277246d66aa3169101b2dc221bd4ec5ca828e449b320a856c8864813fc2b910b5850a5210c1c6820a66465140aea6e2f6ebae9664f71a69e125b464fa4d533479a48e8036d8eee6066dcd9c2ab46275cc561159556e02974fa375a3676929b4153426e44e18360273150f08a54a72ac6a253ce4769d651a55a1885a000990a3471a35caf5e3c45933a11095d9d4c4a3c93b3327d9ba26247da59a8d13de795dcd387d78d654a6e3e42b02811cc88e38c8ac102826f49ddab1d70096f2d1775db674e7334b045d8d965e6a05325bf9b3db91cd6fa77d430ee16aebb7b91d99b4a41149d95731fac7e807c0613322c3f43d45898bcd3215b1f4a82b29468c813996fdf2df2c83ffb4eb4d444e02b763acc63434ebdbec39b6560c3ac5a5ce45a8669579039b762060b72b40421dd10d7f7072f1dc869b5129ff38528f91f41946490381441d6bf6cf1f733b3200834138c9eefbf7f77e191099434770a29fdf6bb04d348377f19abd0935a995ba84dd709d902e9b96505ea6db7cf8127e1d6be3046de88717f2d614e1aee31ff72f7a41f99f032c8b02f3a06a7d578cc328afca7f1a9884161079b1617d68894f29f4b3e5111fc4ffbaa6f340a2bd1cc69642cac5410e9572ffea642be6e0fda5da266be475b751aca578bedeb99b86bc851f8a8b763ca92c7fe809902b4efc509d8d18287f9fa656d71c56faa9716eeacf8627a2ea82a5fa7462f43d60ac0df38f96ff6af664c74c75badae08408ab8ba6a80296381d337be72c2c7ed72f06bd817fc0fc575f1ebf2507b0b4b31cab6eb42fcf01809db51027e6fdb98593c208701e155ea8d95776def148ec649ec97b9f74ef5a426244f40ecfdf896cb0e2f4a8603295a8fece04645c1ce8e8690c958d67783ba0bdfed802700917e9f9b137a2bbb18330550cd786788a92e6adb848b5d742c8ae4b5bf42d887b1697a25590306459255306e4de3a63c12cc019d1d28b49d3672273ca5ae1e32ae0801f29edd514a597f1856632e9460354f5ee31febee15795475facac7954168b21c467a53c8006e48a3df1e060d4a06d1c6e1b9406ce628c172b5e462f6b8fca1bce3b6a3097f22c1e27b8c920cb1f44a0200b398e7d267ed1e5d2ff5d3cdd1524f0b72ae42473e218d5d38c7cac3a6a3b081635221f1408eb74fa96c9d499430dff2dc6389f5109038ffeadaa40c8c832d7cfeea0e0a00f30955d217ec03468a4a8b14c02c106bddde197a5a8a5cb0f52594df562c7997bc4ca429fa483a5236e1f0c60fc7c61c8d7901316ecb8052ae91f2a90bebffd0388928900abd296de6f0202db4da3cbfffab2ec4b85d74b284472c8fbf27f4e181f67b6012f38f5ca948f6a091898e6da4653b251074a1bbf481949f5b1acc1bcd530d807f929b663209122eae6e72dfdad7a745fd2a57e6fb458fc9722bc78006d145efb8b47d8d6cb484ff47b8b0a2df2fe055cd465002eed7bf86d99e1e0f063cb3f0658649c1b82c1763d7a746c5b15f11606741ab7d30fb94bdf9608744a407abea219e611748b5bfe529d6f571efefe971c5495276991ac927b05765cfccdd271ac5c3dcf408572a44d14cc58d82d5adb9aad997734a9dd82992b966169f7dfa468ab51c6f765c5579788e1c61cf9a34f59d029b94615cb43fd2416ea4b1eee40df31b1613471cd21f47b7e7585fc676c488ce2b6f3fe5acc001558a7561087a3ffcf736ef42b57eef12b9d2772ee29ea840280cd61602039bea438bf10dd2decd811fa9dffa8cf710ba0bf0260fb104d1e026321914987a2e3c9e3d2f91cb0c4b0b9b699d303e28edbba9d9b60de3d086ee12bdbfa6783813bdc1c23ae46276343d86945ef23a9e9e0028ead4cbdbb7c082d62c84adec0fcf9a759114cb32c128fe25ba138f0b74a0e72954f8db9f1431ae1a284e7fb61c942231ebfb43b730bfdf9a5de90484c58a58a70515728f6755297047a1d47c7e38ebc07816eb66246924aaf862fd932c6d4a0b0d804ac30157c72bcd3dd24f238424523cf4bda86a734db9be8f5dbf0e26ac8b414c2977b1d89e0291c8ff2036b381294acd3b2592382b5c3b270a276cead43406ee05704cf9b83a7d096a7da746c5c6bbfbc6daba526b6478857a9ffeaad013808450fd79a5ea53283d8f91e62c7a3ce37ea0c7c9eb8d16a243de4fa0dfedd3a04b88ee71863fff806da181d4c5e7a73a299ba17ed736265c9a848982d57ce69a50fb66766e2677c3629c693e6baff4b81b7c54336fc74cfb07e6ed66b325784bd667a33c94df3ed6ba142ccfc9925c7811432564a09413bb2a1244c6e28248c3267cd415911954fa00db38960c078120fef04dc265985159c482c790e1ea934826a82081600d6f1df34f072e001259ccfae4c816fcc5af3730ae30af7bdb217d5859a7178caf5e82951eb7b8d86fe227d00118013afaa690cd346d8d0cf6bbaa093837efbb08971c84665868f9b7442fd59abc42a8a77803a6dbbaf6bf2bf7b298f321f6973f96bb943209ae0521ebab8ac8fc069c37ccb31dc2b56aca4a9b3395cdcf04a9dbf64ced897997d74aa4ca23020f187b1bbd458de08499a28f0763e46a9aaea6b4618669ed284f56a0d1ad841c2b3352651cefed7e8e4d028292553626c8c7d781875e64940a2ddd8b28e75cd8a4b69857cc559d2be59658a2c964f7509e201aaad4edff69f2e3b0163d94e0e7e248d55f1a5ca493faa8c02e17a688c963f5f09a5c15c12d4c86cd6a4391d8d2e1f91b3dde1e4af9a27a512461e446daaf28b6659b20de4c1be6feb8a759ac1daad6f525f44223dec0aa4c11c55574fec7cab3806015b74778f169a4cf96db9bc150913531b9e3e275dd966e60009c34d7ef77f09c2294dc90cd246aa27a4c458f36098173433d73e544e3d2687d864d714bd2779114802cc6bd6cf31c7ed30f7362f6b5c5963041a57633af61830c091bb9544bd7fc6e97e4785a93f853281c59925a5fe76b2840df61bd1353817a4ed1b43c3d4c566fa53561bd5b6daf40406a405dac0805a28cd91144804726f30ee9ae648ebf3e44f402804b2ad47df79bdd65e4fae3db68b65841b2edd9f43ae324704f92c4fe2a300833e04bc83daa3b966c87418fcdcce5928a33b7fb97cb4fbe028a14ae9bf57e80c611b9ba70a5220e45f3bf16580114684ddb0e67a2457e5e68fa2fbe4312a43b71947398f28345db64f08117c149f9a460b6eec13003de7d16f1e5ae07af448bc2c5bf99029cc7e1a6757c09755eb3e6234e7b8f4aac159212a4d4e873fd1c9d89cc609479102219293b7598db3d1aa49e5f563229ac06613113b2953e169c7460877019439b8ddf1528e6aa00fa044050a896fba55fa8e8ebb818ce9f29c06d1a186f4635437bfa7864227e10e3b2481142d743c764b0f83e962affe919336757e238e14ab31a07f2ca8a85b8b4b72a6265ceaa521092ee09d61793ff317f46fb2cfc9298d07fbf87d1e05216b911c17b8e52b302e197d7623de2ab63c4319dffdf6b9dee599e7329d4d12dbf8067f3fb011bde74bc79ead6cf178ccd0f662d3cad936b54bd71245dddbcc627d4f14b5838fa817cb21846331d505df4f7806ac3844588a09cd3e499769641ea4e3348b0098927d3f9c44b4880621824ab8f2d0cd40d84d4ff737ea52931998c105fe993b6d0a05d5e0047e7156b9cd9348f9c6a84a0eb77cac2fc69414c5902d98c64b7587f5b8277c2d36646743163d2501585518773042cce8ef662fe865511be946cf595ff27674e2f0dc066110c5d0df8417cd155dfcf0a07386ab13829f18cba8eb1a3210ea99bdd56b6096bbe5ea308a2e226040b7feaaca3ec8775de57a6e376e6332ea915bb51d95ff4855d4c3b931f809d6ac0029c472b4a66dd14d9cb9eb220babd00269593480ba84030f811711072defee85902489f569f2384b5bdc90c6a1897960a0c2c70a316e04883391e97ef3f59a4c3f2c809ad14247ef85d31033f3f3da463a617f6fea8997855876db0f625ea719787919bb168c068bf88c06c2a00fb06d18af34b0c81d6d9898a57d0ac3d4e4b8e4356c842eb9fb468cfd2c7dcd1ef40851931f9f6b58dda502753de1dea09a14301b612914995725be37dcaa6aeeca273e1546a105960d2fcc15b401427e86a64feebbce111253fa820615a5c080fb3b43fb771104edd6586da94a394df253a66c4c5cf910a5cef14445205ab0c6892d26f4a609f63af69877cd275df36e4ce03eb00e04f5c1ceeb6b673253177d6d42affe82c8a9d74c8b1306b818ead48182a6b917bf071276e2aebae6dcf35afd47a3bb0a054b85093a7dd70b562f2b9fbfbfdd94a5613df5919bd60ee8656e13a7370d0e727c9ee38dca2f88967540f1c7345dc6fdb37f16a7a1de832c185015d1f40209fbf41f72c63da1d4ba0417f66f9d7893ab9c01631ffc2dea92f78091ee7faa156d17f66e776d981f8c55ba0d14bc953e913c625e4ed0c497103f1dca0da1cef771254396c3306fc9b47db56cbdf466ebf644e90bd2054920fd81b0371fc77e34ac27c55c149b57c5ffd62ddecb9d78a6fadc620d42dcd5503d0df4a6c687378f1c3dca9935d0d994c7b0281512354c3f2a34a78ad9bbc28b8728c3b62285faaaa5f94320053cccd3c8e78ec5f2c1abb389a9b2e8b4b0b1fb0fb2c2f084b1a171a4f0388af2f23b595c41fca669702a3439b97faa6555caf700437b196a9a5ee9f1b0ecd1aec9f3e7c3e44c5b0c162dad2fb81a22d5a5b1ab3d2a3ef468b4710ea0c5a6791a39403dfd17e0f1aa3cc9c1a4d13d73bc7928219509be5dfb47642e567ecc2d21cbbcfd4f571fa7f7061a6762fba05d229264ad02ceb724ae20c62de47977c3d9ceb46b954c16ac258a94406fa9ae3f6bd8322ffac40c0b7aeb47e8d178abc75d571a348fab698009e7bf53f053b2dff04db4b98b730fc02fa0dbea04f5e4d3a244a16dded606af1d97a67fb986addf01639058d94d469248ecacb61ab2988906d052cbff3613d08daa5826feac089cab7a53ca90c035cfcc3e291563a308ab6150d570e270cd430cc72eedc85137b3581f6a1e2910b010b74ce30ca0b43964ac60ad0754d8730e6fa93c86c95e4f1acad6c59c9620bb3391610c1f3ef366ededf14c1d4022de9a61e2e70610f847804cd4ba27be19c172a0b8a447041305e12e485e7830caf9a856f41c48a7d644671f2287548a0482ea67e9f0cc330951d01c27ce3f611242fa801b604b8259cac8c286495686cc3611b31c241f3d50a22b6a2d2131f60ac837c4562932080194269f52c5434982fbb7fdffad31bc3dddb360cb0730238145a4215c2e3448bc47ab3d57c1025177a8f48e962b54347d401cfb28a9f39e1b4501462442cf3171464cb6df16965235765cb86bd7071cda41a645e354a0bd39469a70b011739fc267be871191017fa9b8a5e26e7ad43f690610085406f2864608889d08b899b84c3ef99e17008147b65ce5d2e9612afd5ce7a0740d7bd08dc6409d14307ec54a5103efc00d0cbcf343080c0f94bb39fecf7b3a8addbd1e4aa51cbe0743a4f73eb8403402f2fc4c217b1e515f9591f223933ab9735dc3ee01da5a9b13b93548a3876a46789519c80413d7bc13d1b30447d948617479499a8b5af665e08c1a215d713ea6d9d54d3333a0efc61b5982993f419db771933fb5e971e8590f6a745ea37ffad6a23e15afb7897e59b99b3616641ab53b8dd7cef161bdb855d60e7b70dd1c5456f83d44ea7834224ff0f0ce36826455e7fa1d780fcef5861ad7f95a92076ae19ed134b83c42d5029dde1e5b5517c557a48383ab377c572762cc0b10aaa57ef3be1d5cfae1101c2bd7cccf6231325640e997956b34e12acbf21f16b8a062305a96a3daff2de1707d5c68ccf8e84efad1b81a85840cac70373cb9d3b988b6c31b8ff3a216b28d3f284e50cdb06554e8e558b3cbe9376989189e1a59d2ab9da4589a52c4cc242059f708e906ca39deb5faa08f999e5b9ba59480c258b36416aafada754c9d7f560cac70c49fef5d896220c0f3c7cb83b159b8f942aa350ab6ff7ac7f6bca90a0f343d245eaeb94f0cd964bb593de65df6596802d2eb05b37ab0c3cea1796d9938cdd3db3bb93cda651017457e8b58760bcc285734fb9741e370e6e268aa09c5457f2654d5536f989306448b8bc28aa20ff376fd914461c1f023c24a588e3ea4f9d8e0302ae70a2e3014ef71e8d6cf3faf8441ebe22ae8434ebdcb6e29afda0bf9a599474af10cf9562646b548da779463dab1cdfdde49d20cd2ef6f2239c1b99cb723b5031752795a9ad942b9444c96992df7ab0737f5c11c240a585e59f5faa2c4a50df8d610cdcc1bb050c691b9b4457b463e92ddedc05d4641bac186535b5f2dc717acf54b8a71c74890b995272f6bcb0af36e6423521c0e78cc552e78b92e550fd424471d4656d363e422de5c12f3b92492c6e02ba94de929e646efadbc798cf9455dccb2b3ed522fbd35e6fe248611ee04999864054c264e1cbd70b20dcef8467ba230c68d81d5baafb66d6cd43d3395bb0c7585b294dfba736560fccd88d63e0aa3b1395b4002e036a2c1b5a7273acbd19c8d1059548985c97476539d306c1c843cbd1e873fb811d379ae4949e8646bb7b719462133d09e8497050ae75bfda89a1d12a34197c7e68f95c44888d6be6f9496706dc23e87256bec4c5acab97b3bf1d48a8a621a8b5570da03c29e9c320a341360fffba6c515dfeca2bbdc9b73e56244d899aa39ff04f81f9dcfe4463fcb956cdba326af16b2d74d06757a062204e42dc45539839ddd4cd61abb74f605ab0fe426c25546419174c31a58143e87762cddf8c867129ee73289a06b84015c2c2a1ae1e0d8ab6d9ebf9df33845238d7f73b46dd2f7ad74706dc75ef1398fa1506d228f0d3508c1765db9d229f44348f629679a1ddb4a2a84800be8312851fb88a99cadd130b77cd7c5035f9c222ddb29f7eaac0143b2abe050c6110c5a8c90308a8ddb509e5be9c28adb09607986018e4ba8e8097d445f02c65ad8dd3504d4d942cd6682b78d91ed23164bb7e98ee9712ea5b2e498a1ac8f6be978013f30998e82b73fb9bf53ed53a2e8562a4544b081ac01c5245d5d5cffb19bf29ad8a9cdc9ab798358c0fdbb2b6ebce336f57822075690dd50df3c4865b21b63807b4af5cccdaf2f0119556168bc07fdf77d5b0c8e16f00ceb177a809cb5d0ec3178016f07ca4894e8dacef25544dad639f0239a506bc9780319433a182b11e21c942a785750a86251d103a8464b298be2ec7e9c15083d80650050584afb331436ef4978754a49f15070b25bb5e41ed9c4f3833bc5693e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
