<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dbb939ca983e46822708da30090ed49dcd17353aa9d975b387fc8fc30d06fdb2ddc53f38f9b1ea8b6a1a9fe4550324ef1c4fba5e26ae98f97e5557fc9d6186cfe0e5cc326aceee5e9204c535b1e06ff25e6cba85349d1f729164ce6ab1c01c273cd966da8830f90f7dd06431ebfedb6051db24095d13f6ecf87dff6cba42f8ef7c0671710dc9b0ed378494fb375f255da7c998d9db4b8e969e8ebce65987ac5609d5a916f6f93c307b1a9da616230f71ce39b2edbb68a6f4f9e5ff0ac995979f284e1601ce5bc5a9c2becd616b27a39f91e629dc282671524c8f058d633dad1f1dc682a87afcd4862a2c6088c1c88b879d3181738767337c827d436f2bbbf131939e7b094bd3d4ebe7dbb1c141e500d01a38c67412fe8ec69b2ba23300c72fa8c96815dc1f2e0ad7d732cc27c9be81bcffb36bc0cc0108fdb789fc00f3af9081f078648998cc697465524456c34de50aec1cb60d7a16599a577505f5b61448e8d1a63c0d202ae0401a22c9728459b260c8d40de46c1a2c7aa270d7c41cf2152401075205428a2e699984ff7de10a332b666321fc67b80be7afa7ec56dfb53a8505d5d90625163f02fc09126c9148426e7a4baecefcc7a497cace9d99b6afaccde03d07aec6309a7a0086028ff77746d353e6a38029acd6e237fd050fdfe8199b68edacb85f4dedd3b9bcf4c99789a54d9738117ad999b4ebcd98a70def1006361aa03adcb39f6750eaa0b708f7ba39c918f4fcdd71227208de4d3f3ceed08ea04e13707477db96e2505da870dae506bd35672387650a2f505a7e18636aec6a9f87aaa12df59002e62feb562bc42a362a8a143436090745d8a70ad76dbd4e4af1ff59a4acd5ab31eafbdddd5c5caac88849cb9887ae105859b9d0ae25fc302878b23e3e3c7b4a8eaa65693c242a2d23dae96c000ab05620ecd17f2744cedfad9ac37dcfe4ea45c0d753eeeaa17f543fd3b02ead14d65c7ac85591af02d359c7f0e1cd8f29162b1ca03ad06072262b51e4bdb45ccc2e592e9d97d0870fd5a02c7414fbc838fbfb187922a9e76193aaf4dfe9ddf7c8e449259b5c43990570a5fb532b9cddbe2b1089285fd5881b952ad7855dba528d0269fa9137b3ee61e56827f4e516cbf2bbe97bd73708a13fe618374e1fd8957b71b78365c29fa11770bcd71df5b4b1461f411f6f6a15bc9c062892683828fa0e07c8a08357553c32327c1136c44b653715b517121dce169afa9ff6a155a4221156389b8a469d1b20b1ec3f25e8f0f44f319b60ef0ef6fd720ef4b240176641b90e270d936574b8fcf4f660ed2c67ed573cfab4899243e9990631665ae6732d35735c74d271d62e657d5a956b90f2204b5105514911642cb96d7ce097e3051da7bc8333a2cfec6eb273ca74c347d1e532130cf04e17db604624ec797a07bf4ceea16476d82d1e09457558878a975d75023ae8ceac8d0dbb90df558c0545a08f06b8e1eede80fd2fbc9e0d0b157bdf4403ab0e90426315d55030cb4ea6e1f14ed4de99a2bec83f39ceb0a8c0f6a5b43c53796948c1a3718af5ad6496ba10b2dd21ab7b7cd44850d8fe3de35800d6296d70952559c8a1b66e9916de2533fa8a85308676332142de2f2135fc267bd34159a329d1d8b851b1579b1dbe30fab4206627b079e93c2577ab1f0f0b7cdaf0d3e163819671cacc9ca135aba45e139eb6c94d35e25b648ade22201d2f33ae0ccc64bdba72dd1b1365b5592540aede8753a79e000e9d5172800f0e69ba849ee8dc1953c707d533d39bb7b31d7d852bd3d6991164b8166a2a98aeeaffae3a58bb7715111e4bcfb604b3928fd1a98707ea93a78b454b65ad2b5105f3ad8a1a8e32ae2dc8de6feb6320722745bc5c2ae00fd7b8a15b03e4cfb96614021c20c6e041ffff2c2f2009c90785a39632a76f161042110be5a55277c03edac7fd19c119ec486a0bf2d08240d890dfe31f19ec76b5577d50cb78ef78deeef5e7c877f1b9393c6c8826a5b00e9960a7f8b434f673c6cd93bc00dda6e00b325af17397177a4f929f1cf6a55da336a0116cbd52d450f35d05257c8d31debc02246db9a6f35514154b30e6d45f5644a052d3e109bfc613fa2e592a6459339b399d474484fa1a7288c3f5e2c758a6ceda3527a2d1de04139e632b9822001ee55e5a63c7be932656d8622be12722e480c47e9bee75ae313f44f56901a7e8086ab320861323d0ad2924aadc42d97962c1541d8fb286f1246f8287c9fb23d144e5ec007d3e9223cf9569799dd29109150376526cc3299564a94653baa14fb3aa1522d102be74ee62fe690141654ee203f84cbb7ad92e34b0666c86d554d5ff52299151eb57176a5e5ddb51a1d57e2f3ea26c540cc8910771a25b661982a549bb789cca18ae6f3a4ffd39a9d2feada5e5af8aceffc52be1fdb666ece1887ff189f507c4fe50801caf2e6ebbda54853575cce9ee013ab8616d0de88d9db3fcb9b4447523d80538cce559f0cce7d908b35d9240dd76d3a3151a4aec70e474dfba6c3fc130c1d785f32e103a0059de1c6053562a6a2f5ca25d96db1f1255216735d7653e956ee1b78ee356c2e7a5574ab46ec5920adb59e8a335b98bd1e36f94e172af5606ff5f0e37a33a0ba260281a6496f40bedf4d42918fb25dd9f0f397bddeec491d11ff04235f827fc1728dcab43e56199d64a3bcc29cccc4ec8af799430bc6de9feb9b7940e4f681f61133e043f9b91536dd3f4ee4283656f5f93c6911aee79eb1898281e359fb57af6b3bd0b943fb9ca4646dbb98dd20cdb294e310b590a25e2d7400157b4f1db9ed65fdb5fa991aeda114f0bf08df2aab84881032b32a2b7a59fe69e84d0054b95a38f0ee5531b762888f7a8ddffabeb2e77e0b7373d84dfb6bd8e35ddb9e1ac99fc6d90b063ce907607e0fff1d0aa8c6bc410e4982679e0f3c77a68bd3f53a1312fe1b82a274c625cfd5374cec827741aeaf256ba3719f778c72ca49a3a0d5da444eb9c1189e7140fab20eb3669cc57df1cc65412ea3cdf061dff74bcf5159ec250102e7063b25f3aac29fe74202fb958325777e4cf6061bd9f8ad86ba4f7248dd14579f353e37700e1f3b3869aae78a95344ec4dcc6a5a14ae9572bb6f60ad63b32d826e9881fbc0938a8a3fc9e967ddd6b3c7e1d4eea55dfa3b31cd4ec3155b5d7fc4821fa26e95d0e17fe3c2005f9f445b85870baf0534816704ffc790b6bc00a01f13ac62ca640615d0df15f5f60ba19c4d70ab0d313e443e34e2fac749d980cc9cdaf53b7ea1d26205bd422cfcb2caf7d7a7dc2cc1acdd1f34fb0756080ed1b46da7b9174e21ffa804446d03b0cb4795cc6d8dba35648be2790f284f5a7008a0b4c2cabd5975683701c077d1a90117e2224a75232b3111b9769c10d9fa1c3d74328c0d3b563ec3d41c13fa773811878de3ef9ab5a0eb5de55bc7325d2c9774c23e7da3b3e4e892203aec7600b42a8405edd9902ea0f959ccd12c230b92c790c166179273a30a905dc8d53bf9f7c1102ff368c93652d796e2487e504dcacdc3e20ca6295639a2fb424492397e80e840db57ed74b0471cab143a017405b358ba61de6d682f64dd34ec5909a872435b9652a993fb1e4a60fd3eaed015ade78a6e360fd1e773be767d9856dcca61110d39925ad8389fe0a8d2cec74d5cb2847b38ec997179cf631bd9e8cd5f5546e70e445d30199eef83fec059f1e6252160769396f3a9f7bd514277e9328896dca0de9403ed487bee20ae4b934cbd6b98e38bb4519116f82670d9262a9fcd567417dc83d05c630c55b223df33198a11130ba9e3aaef7b337e4225a60beb4ebe8681d490d53b9bf627e17fac1dd8efb854a6815fb943e17467ada730872f532e5c047ad3eea56c0e4bea84faed4d8e8f1c51f6edd2b68267a1df87d3b28e0b3553d86cc9d41b9531c795c0f977106bab2714eeb0712ff2763f906aee33051531731ed36921a50f7fdd03c6b7c94f2e719d338bdb29909388d498b11ad8bbc83e01eb011d99a24537b2fd8e6d7a934419d293737f570e94cc335c4ac86081af086cd73721860e41ca6fd3d6f5f9726b88e73becc10a84c7bdfaa557a8de1ef1598a032e2dce33d0ca9817aaff0dea4751bef124bb3fb00422c0c42e0ea61627430804a240f635caef3f37280c6841090a45208c33a7f48183816f7c86ada0f30d7dde9cc543739b91e1cb6180b5519669362f000c41be633ccf0786dca6148ecf985f93a832cf5877580a62fa6f51ebf00b6a24a590cf6aac4e6541e99a72ec9272dfa8dedf2ab69099c45addf0484794f417ca60b027fd8af836514683473d009568a79d90294273a7f382fb90b02b604a2517b85fe8e0521ae6f5cacc55641592008c790c366fd21dcb32d10c4c6ec1490987fb9da1143c120b4e85d4da7beb5418a3c2f79fe2ae7596930b31497b71d02f4906fb2fdc155e1631e10e134f4426eb17d2de2164546824c49164d1ac0b8918db6ed2ae66848753d999ef41e25dd45c76bf2b3c01e80a5c53ba8150840909a22748d67c698a0f026e4b53c6618c7e3438c5f1acf19da49ab719c8a00568d3aeaa2de1f876ac235e4faced3d68ccca0100eae6f3e9afc9ce4e2b8573e99423a6263d27241bf291f7836326c3716364a774411732e3fa14df6970e545bd697cfe7ff3f995dce8b1403d31909e9aa052c8e6afac6d22aeb8d7ce817af4ae72676470be9b447ac4bb4e4ffcb7953d9dcbf8c37409d24ca75a23406e40ba9a95f9a0c7eab986a7778f3cfa10bcc2eec2179dc47a3c1c03fae28d47e725002813e22082ad3f70b780cb050ca771b47dfa9043886f0fc2f71275f0919dc5e62f233e2f39c0dbb802138cbf7a7bf5a3849d94be5e1964cf9e37cf172843acdc364458aca9c38dfab3017151240784f25ccca7a000f92609e96fc3f185b402e7393181333e0210ff50d22e3bdedc727f236e76f1af70ecd97864a2e61459edda3821eb2f8ee1e6d34fe1087005b71b047f92b39f10925a4fc2470e3f6d52813c1d116305bc6df37c8743b5f16944bef9c4ee827f2e5c0d0b08867a2f01b44366d9712e09073841f13f788ef804c41e8fc9ba81129939bf44e44ac185559d5e4ff2c7f7bc3341aa746f2630e1989c3832d381edb55350fd1dd5a8ea2690071558adcc8e114b5c61aa22b104000a54b2a9849efa4259b6ea9f994e4386397a505112e2c016129ed811b1fce9d496cfea50e4e9515050fd70455faebe87c44d5b4583795bc645e7ce4a61ed2e6b93c59f72d2915589f59bc336deb7116489e893ae7aba26c350b654f9abfbb7a27f2087e803cb4949e8bb28fc3765f86833e6b77092120e94cabec2b2ea5b8983e5c785992611eca40014fb143d93e87f15cc52c80d4333fbce422f3ab85716ab93e8c881ba84a75f6913b7e25f8d90ec023d2bea91416bb4d9c14f47a2fe2f2102bf0fe89095013a553bef96f3d3445e49f8a6ba3c0d86faa3febcecac8155bdba53007fc4da304a8cb6ebd1c527be78d8a44b92e5fe698d9f7bd1dbc2fd98b7628306802aa885baf5c672424b9ff087f95424d48b837c6cf5cef1fc79947cf696835d494a222cf81e49599211ca967db6805408fce4afc22e4eca9ff6d1836041490cff5584dc4a54c222f8b817f90789f9a97e8446cf2940d64c6447a6db356f7caab2df77d90285952da251e85efe81bb924516de0e52088dd9ad9709a99eb1bb0e51324833984f259165d2e1a799213dfcea47bc5e02846aa1cb23bd1f12d9770fddb26d1885b43f994f05fa194b029d887ed3ea6065f5674e5607dc7975c8f94eb513bedd6e8682f8430b1b9b82ab1cfd950d47783c9346587f50f8f8cbd6910bc163c0809425eb61d7c1aec51c3149c87c53b5b4f6c3952dc46132f8da7fffc1811e7933238b5a24d6841e48acedf01cac58e08dec2743fcdffdc12a5f7f42e80a1ba5cc5267df0fc8fb9374ed3e47df5dc36592f5f3ee1690086dd8efd332de23c9deb2cbe158326ed0ca505d6b04835feb51f94880d5a84fd98f63e83d554a7114daa72cf9740b306a9c80092c2e32814b6a76d3004e87cfc2edf2f6becf79125684e83af10e2254794e034549ccc62116cd7528bbe402e9dd9793edbbb2f8a788c152fa15cd2ab14eabc14099103dc5ee350a986f25bb7c560ae61aafc368fa0ac472915e6c7e04ea79092989806fb16aeee41e86b573c68075ef51e8800d2e20f1360fee804e613626aa9424fdab1e9472c62bad2c390778b5484cb093eebe3312b0660a72ea1f79be827283e302db670f9786d558d9d8a242a89888a103732a4ba9f5bea81af7074e5855d2680fb3e8a370a399df71092f9f56dc870bdadf79b623f6b73c2ff5112d60c059ea1540260c1a19f8cf2753e0bc519ebf936c232d6744136896a9bb97bbbfa30e6f61bec408921ba1801cfef33382e29cff8f7c0c24461fe99a16345f81784b09d0a882f47b6ce795e81c59143294adf32b79053295a9519b9e525ad1251865fe472b2cdc7359575a8a342613cb135717237d90e6d19e26eb1b7c33d76d0517e00be9568f917ec135ad3f14ed28af6a5bf38649a05ea34efc30917d6177c0a9841639a882f089cc77a92af303f579454b36d60fa109c7e4dc8784e533be1663d0a660ca5197f935fec6bd57e2a2549227a20e4e2455290a97fbd7894cd8a0114d17c28812835f011ed31d647425236a7cb6a1b440583ad9dce610dee8428ea2397d123cd4883ef2f771246e195c2fb7eb0d933e4dddc9fd1ecfb6d217a1c0fc9e67503207e916481d9a4e8fda1c5ef0d988424d0247b443654b393d092d7e4eebd75e850f08da14ea0b12c2af524a3cf40042583b717a30ab38e6342e29f34cc4a064c7c12a0a0e6e1a78325925e8604204617176f7ce86db7c7664434e61ae8d26bbee5d9c0b7fbd88b4f6505bded2b57b2cecf6a18c32538df4541e80c7ac090c6a14a6538f2d6bc339a9f70644b47ac509c56d5fc53ac3add50aa671226b03f993f368c46f09570e8b1efb802580f972087d5a70c756fdbac2f818645c57b07d9f5b341b9fb3adeaba6f9387c41f589dc360a52328f8304500b71a49d87af53993ebd230ecb4a188c7e8c4bcfbd71fac9fa7261991e86fecc198ec94198361e36134f5cbb0bce1142d683b06e46cdcd49051d04aca55cf2d14aed5c16207b79d880b06c77fd199fbca137f02f7a397c95b81e3a631b47ca25427a63ae80e02bcb06240b484aecc3731efbcdded1bb58ad2dd471193eafa6576d2204571858906a112419875524a9ee238d07f59dce83b918859a667bb3ef6d71d0b9fe15c716b097e9ac417d5a0226ef70a5f18b37a50c3dfcc47d6d033f8133e755d3950faed6dfbca78a18360ee98c6c2becc6ebed215d39506ee90a4d90b61fc6ba6adc693ff58d7710707ec092873e344fd3924c95dd1a1e8b8388a979e626213889b2cb3304629b8ce4179ffc49c58790d27d284f5677bfb547b308b386794f22d1735c9f1ce018885c4c3a199373f9bf674f2ba9580a508189ad3f2d15b5927084a0fd9a6d6f9dc613bb0decd70e8c6f5fe339798a7560e4630d28114dd608343fb5844bc07b9c6795dadfc9bf4f7e18e483edbf03c6735c42b6f825a899de742a94e033dd401cb0967adec707b68cf2ffe1ffb5dc37b2193b3deb40d822e80e29f1c095a7e64f9b01036e1c85511cac2aa8be23e9d4e96e50eae49f8a700174de7a787c11783abc7ffa154b96253bb7d53f27d43713ed1a8abce13da1c49090b4f6e9278f2f5a5aff0eeb5f910a6b2e9cb3452c1e9c48f655b40f1394ff2dcdd3f6bc9e5ca2b5b3bec4e5f1b8683f25dffc38290c83d3c8c6e90c357918f1f1b261fa33da277507d23111a51d69ea206a144b3cb3d6a8476ef4d1e9527b8eea17c4781c9fd857c11fdcf95c2be048bd0ca7b8fb31f0fcaa62fdb19543fe26ceab0f6772caacefd2844d94838261b45777f19fa49096377d1850a89689f6654cbb8684c0291a65378366ef2298353ef65e6741c75fa80a488f0b63fd41ea4ee2c30b5786589cb19acfc1ae7d2d4bcad8b46e6384ffd1985d947ea474bbf75f153a55825d67c4d118ba1b2ab655f35ac43841f2e0a090f9e934eef9328812599b7095a55ab5229859ea00647d7e466bd0e38865428f9fd56185d7b2257dbc75d7e4ddbee52bc4cc5efd46e8000e731c034529d9a31e2859b52002b042d082c8913b684672c90e4a727eb019fcfdefb6091551ae99e1be93edb81d8dbac56bb6a59ad036afe696455b95793f4eb34b0877bd158412819b41dc93051628569f87fd6923c727d2ec36ed332e277aac29ac25ecd0fbf93d456de19a2e200cb35f155797466013d5e33268f4dfcc3791f9c42a10eabb0328dfb0e900866eff3ff54146038bb1ff360d661e215142504e21e2350479862390aed35b69b8040df24f25aae3f3fb4581e98c3ea048f5edffb4258a7c0b2d43d4176b1b1242306cbcafa74dacda993c95b218ad52ab69469408b0ab1f221691e94b668568d42098f51f501f57864cbbc37ed5840b5299c28af5f53981fc65ca2d76918d3d11032b92dbf5391c12231ef353d5489b026e179183ebdde85845cda9fc2364ba135b00c9840589454d5c50594c9da0f71d69201d5e74d17396b6a491891bfdefad795948f58fe01cff404b7caf574733874c296a66b812b5d9587d19601ea878e17315aeab803739ad29cf0abd2553ac126b28938564f4b5fe7caae78596dde399fce7cd30748ba59f5c2586747f93ce55371e3bb26fc10f94a4c27136f3b3a59b5d31a16ea51ea828dfcab40455a59dda9614499e2f1d0c79586c6ed5ac35c91c68880c6c6b3dabe5aa357954d900ffded6ce7a3bd835779dfec47442adb32eeefad45f52e3a77a3b7537167c86e6f318fe589b1308c1fefaf62791c5d897dd19d23b9169ecb67d589c2403cc2c2350170767017fe6d800f87a5c5c6672704111a51df546d697d836d2321000b778091ef313e51c9d9bbacc18fab4dc26a458f98db6a38f371335cb18eecb4359e10c557953a8fe8e0a2de471abb5ec0c3132c3aa1979511e58ed7dc3537fc8a7f3d14839f0901094942d66e32e2a8c831795f3f2a5adf809e5394da71a694f5370070c38153677957d49a425eb2d57d84a63660cbd4936d92da76005c9a2ddc453d2a2f2dd67736906560ebd171a97ac8b91aaa4264f60b91b55dbc8e39a1a67ae9f426a828797907a02f9b643790a2f927dce7392f53bf0b9a4ef56563c273a17312029be0d649c0bcaade44007a3cd2bf76cd86041c3e1305012422c4d6bb8b893b9f80e09361bee61d3a3c0f28c5ead799b37f927a948afa60f2c664f68d521f9a290511f9385614f7b5fac0c329a7bdf7f0af1d32c32bd090c3ab168453072d442082e673904ac47af57b25b02b81ac6a44f08b94dd7fa91df117626c147f6bcdeb941911e1a818c8535ff1dc42c35f78c000745c5525fe6f32aaef06b0e5fafe1f9877d08ab8a4c34238181fc66ed7b4a669af5848ea17fe78c649565a079600b8469ce71c7149bb18da787a1a10bebc9a6f60e77dc56d76d903b4eb87fee9e86877ac192cc23e25a7aacfbe4023b09c2645479dcb8151d98524beecd99bf7d5c43161294546007df492cdcfbf51f6ecde8b99531958a449a1b3690ba51f6e5f0e5ff70c8a6f133f360fc8da093f4f0c750e03887c383f8bfcdf1f864adfbc76960988111e387ec054ce81809e24c0796afd34471c83a96a76e45b7a33e72811eebdb4fab4ee49f8512959daaa062447969e46d4f94ff5af02e4fce7e6d305d423f9d10ab07c4a3e56192fa855beabe9eff87a858c9468a586de19ac231bf10fa34e90e0573997541a3656d2df51176e35710276e61507f93721c2dbc856b6da5924859ff7afdcd55d142eb371e0114cdf01b9f55c16838048d311613fe6afbadc42e41eb0bec727c388c0ac3293bed4b0c1e655edf6f5af1a10eceffc0928f318932fa95ffe8917d20e65c3e5b2c0c58dfdd7942d37472e89bfbe7dd46d1b733f6f5b08311538426d5244b19f8197036b6ca37594468db32801fb88a0e6719959f052be9ea5ac6f67cb51dc4ad73b7ffed64e11f479475fd7a6bba1cfb851d2e20292e2ecbf192b4b435cdbfa1f3e1eebd177837704270383bcd0f284c435b5f7cd93c80019ac56334dbaa74fb29e6981c94ec87cb232f68a203410c869def023196fcfe6c8fe9ff287930148e7ade233caf03659f9ee9f5f9573dd41e27d8b4e5bfa6daff229d3e3b51ba7a13ac5badd7763019ed7740a63cc98018d778f5dc9e8c49eb17958ecbc334b79238105ef35112d9e833f2d6ec164350cbe84875f01539672c342f0840b80ff3d1b3dc3992ba022dfe9c89bcfbdda9779e508db84db474c6c4d154b5ecd9435a33d12b910a0ab738761b9924dc03c8a7746f04f5544fdab86b5234b2803e1f36eddce12e3b619dbaacf80cad7bd8b3dc92e97352ed4864e620da7e08187034bd980d5309f8429a8ce5fc0c5b1b781f258ad2abdccadb69f1e2ca5d7bc1c81bd1bc378dde1c08d4e89e2730938347c1f62e71d99a9eb13765becaf4af33af3ec990118e7ca07a393e3ca546de8bab2bfbabdf651bc7c290512a9fd6ad3dd6f04043deab1f60c16f4579c241e89af8d3c9d64aae9d230caba4a1529d4a3dc7df9e4a494c01c3b26f947e89349fe72098331655d59a141a3fe60ed95cd9930e6797cfa0f2ba20316cbea3f71c0e81c8d528c5dbde60a40508c9b9dad6932131c0840031c40e30adccb5d64369aea74ca75b8a46433b4eaa4e2685120e30f616a3e596a4c7010cfdc05b83951e14afa130dace49898366102f70eebb1be534a5e68769542465dba8fd1e30df867f02bac8f86424135f125d1647780d099664b85f85eed68fbe2e42bc4c6d73c4e9c1c4e8c023253cab0436f420e54e2a6fc1fbcc63ac629108b1d3fc07a40d40b3ee17e3b8db69f348f99ec8e627c8b854c80c84ab306112178e4b12171eb1223f7bce1002538e2ce7404416b7c4217460f9a645cc73a24b249b93bb9fb6d1c5999dbf5dc6ae7f23554b42a620cee95a52a8307391f3663d52c09ed521715c93ce25dea3a917d0389cccd57c52ee10a4b8f1afc035d6b4f0b796fcfc4f43b6766549bc6871b5be4b3d2d8090c9919323903a65d01e4a1abdc2b1f1d2f6cdda390291664ee81c671336058544d734c6fa72b243553954bba9f106545ae0c4d89e84513abb46158e37a42850fff54627b9faa6cf059b431e39714eaea2dbed81cb9b8c47850c82f999d39105d912b30e886b7d7d3d30d840b7d46393af0c70e1ff837c9138fcd3611344688eee0a14afa8ac8e36f76c6fad35812a4c5ae83db4e8d463ecd3b3d7dc6df8537f4b79bfa446037c225a72132ba459999ec29381fa426888229a9ed13800258c3c0abbcd56df2bb0e4e7d10c9bfe60e580bde4388944cd80224fa3ecbe6d1b1717bea00b7b64bad7279cdd5e2d8b2b36788b5f0675f354c703b4001436f283feda3f05996410b124f90bad43b997b2ccc2e1b714dcb726637d5f32c6f5d57b1ce041cc831d56c2906ef3c450b890869db14904daef5b3bd296b5b1bf676323f987cc2180593c9c0db8d74127580c19e98c846e68052b816b8b30261dd37469eaeed08127276c6ea113f6ffa1f412604981438cd057086799bd8c6b97d493ab87b630d229c5d290a1a71362796627999c759518e0611506021c2b3d18c1d6ac82eb2940de05187284c616eaf301d26be54d5ad503de969a368b4b264c151ab98b03fad9b614316e17a558cd7957d23defa79a444721d3f506d2b571dda51d26c13b5b95d9733ba2bea2c40fdf5bf44d639c539d205b719b4a79ac1e59cfc4cba9cc8bd09f6c99e3aea85907eafd4108bf30beaef63c74badda95dfd004697ce1de3b6cdf0fe5baf31042df3d0a77428873d5b8899c9683d7b4c4762432991ba8147e5a54049f4362d348a4406b70f645b9a8dbaec844ddbdc2304be1dcfd5451451f451b631ef5d63bc5f5cfa48b828af6f6a4e4f24f38aa4b8607a1f0ba8acde62cf1d5791a015f73d4043f099c8bb85e895eaefcea55f766a6b773e256ba944394af49e61dabea549882c8fc3f5450a96a62728d35ad98cf99abaae24fc7f0ca50c2b7239fe0d1d105accf692fd3b8bde023ac58b440a4352eafb9f3b117abffe9080a23b196144eabda73ff8129557f646c688f82d9852328f3b337854a1b1b348b545bc2328639e866196376025245f95c83723e15aaf17ad25fc21be892e008bc4059b50b059f1fd19ab74dda0d762b147b409fe8bf9832ffa310275e8c303bbbcac922c863149c0c04b4a29bece5716aed7689a7379341ac8b184dbdb929852415f0d349361a286f028a881d2e25857ee4b3223a1dc91d6b8bef6b29a11363f57371dd79261dd96ad4840775293d8c7bb15695aecaf42257f296ba0089736f43594570d6c8f004ee0468e41b834ce4339ec530bb79c9240a13caf83399cc04e37017020d902635b114ecb5716635e49d916549c4dab923f279d4a2ebd0f3d45b80a8d2d82f19942ba118223930be2f66e9cd40e0404032ac545bc8f0e4422ce0b7316e0355a7bae01a1ed2e690ef0f3478ed9cb048c050655adb129bdae7295979c5251751d500f41be65257597e47531ea86a16685d5b52e50b48749fa9163905963ee1f2ddfab27ab4a052f7fccb10a199b48d662fbdaff06ae579b0b0e2713ec1ce6480c0377cac3da75b87feea2f469e7ad051b046c415d1c378122b7988f11221f31ac110c25146e490fedeb15a2727fefe649d4f753267be1b8eccef1ff07243e7de4062cd98089bc5f68e2a16096edfcd7d8b553f46dd4f44bb4e0aebb1d2a627e7e716633406f9be9d710ff8b06285b5d0a32a4772481086e14bad57018014d120fce31288199259cdb500665996138f71fe67f43db08eb99f214770a8963890d6551b25e77bf4f87f3213fb4a5cc5f43d05d8410a4e261a73ecd5076d4a67481e924e13721a4dd06b8858af7056d0ac0613c2a67883631c3579a27be93872e197acf6af4a14b5f93bf13e3dcc359716743db17b7bc2317b35e51d25ff7629900f8ebd93cfc222acf48ce834abcd46e7e5a04d29c60d317c0ad77fe6cd94b7f85065124839bdee932fe8656b9c53ed20a43f41591908767b76b878e1b2271ac953f0ddda5065ba40e24ce2d36f1499f6107847a49cbacb50aa68503985090a720c9bb16853550ad39589c5fa3763f567796e44028dc39a89383eb7259d37c30ad5d7b3526721576020cecf047a18a4c449f3722905fb9633a5ec0480028401405a38bd8bf9bb7216bee049403dcf6bbbf7f8bf3eec4f46ea64b98df999bd661a0b9e0b4255bd13b7a02a3922edf66a3b07df41f4757e8301c9d6daba1c319eb468bbf108af5140150a742d9b9c4575adccba3506ff589f65f62e9abd1ece88df253059a4eb65a39c43d735e2fa02d4fdbc1cb474835f2176469ccde5ee1775443f7f3356d810ec32d18467f9cf581b114e8ceb218b686de6c3dd47e58612684cb643bf11efee155a735c4da70354acfc782bca22eb1d6343b9cd7123da895cefbc3d627771a7903335eae35b07ce4e2075c9776eaa6d17deba9dee0dae5b1ab8cf42504abfe69c3e88c23720e6275ec79814dbaa2abc4c89af07cd31c2be966dbae1ac29671ce292cf6254441a42988fe07fe9127b15ac348c4443ba9a5a1340b512513efc79414ac1709af1af978971fc670997023e01000ffe005587211b95730c8d096c7c9bf706637b6df6fb6997f531e0d64b3123c51c3fe9b41e797364afe11bb8c71e9899003b1f084adf279f976d7248edae0d2da1534c5dbccf336951a3a4970c7c7f5a0cc216d17d62d288019a098928fe604414ed1df639888303ff982456e4ca2e759a464ff73f2fe6c18cc9bb9bff8aa734e848cec5080d3cf18041b12e1e8f9f8395534810cd00db9be2f191749da6df58031fd13503d9669ee0bfc685c6471a5eea4792f576dba0aab8b081b26c80375c38b49b4d1bb63c643d2f800fd7ca6e98a41e68c53a968f7c8bc1c55c6be46ab6872800fbbafd91479f4706d4311b856ceff0024493d6f9a1d2a5561d2e65effc1f5393495432b67bb58717ca297799175466c6e45c78e352e461378ba64c0be68c15c08eddfc430c748e39706b0ba7b57223819fb8a1987814d2ba9c8a8167bd03708ad985eef3b1be74271aa7558fa593c458eef07f705e5c16b81453eb6b99943bc8512af174f3c2177b001172c2c226d5ec4be3014563577a616b7684c7665d892efe355e6df64e8f0a49e981cb8b4a359a78a868401cfaebb0fbd0aaee68545452614449149d29aaf096751e162d219f3893f9770ae837869fbd37ffffdab58570d3a88247bc879b9e571afe37329bc0068659e9f1cbedc60459a58dfaa8dfb6113829b8948a0b7da4519eaf1742f1d97bc598ca0274d51fc8a01bdf7aaae90299bad48cbf47693ebe23de390e5605015e295e908c0df4cfd69eaf136b6475908165d89a804dde798ab6ada85959144fe34bd595fb5edd8e3780ffadff9195111d00e18cdc8f2a4fb42f416256c2bfbf106a599a18e7dc8c15a060c161de9954cf32c87c00788a2c49f5e813a7bad8785a7882626750ff97e5a2157b1f78622d31f9d30284c35492ce9494cdd40974194a62818d1b59346401cf52542f75c18405ad870fdc5d0e8e6053cf747a5d7d028a1e7263fc930675e26ed3622c6c631cebeb96976c2b314ad40174677756c0de5ba549ec9670064b96ecdd7c7c1cbd1f9fdf9febd0ff55fa7ecd0ede899bbd496a8dd8648ec3cf826fa54c6ae5af4c74fc77bd4405537c08c339bedd9c8113e6ade762d0b15c28566aa53371226900af5520249be1e2c619a861953c4b4703cb1ec7cfef8c5a583bd02e6616b9f354681566857cac94028c47fdba39cdbddffeee7c1cbf1f7e9240a3734133edbb6203776ecfc7fd9df309e95f4c69091f56b622d68416fcb55779313d1a0004454ce4f13042b919222e06e3eb41c45e58e50be001318860598b8789bb8741ac45","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
