<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4f2a0fa76a13606e1b37d3f1c4d526a53280c49002d80bb473d4a044dde1c7b7ee5f3a191b1fe70b3229d036a7a1af74519a6a9cfd3f00ab9605bba47b3b65c98d65d430eb83d0c6a29efe0fdc8c0b2261d02237327ff53795097904ecd2aa140d957dcc9f0f335dfe65b62245f985fc3a51bddad372be3d3c42534151bce204d3a3e163c659e99f82186b859341b6ae3baeeca0045b979a1e3872f21e166924669a259d27a725c77312fca45823535b6853ce101b861eddd85d5c74643f140ea344c6b14d7306077803134ed342609dee4a82eb69949d34bbca13907f44adeca24557533702e42ece4c77d560cdded2db3a697ea3bd27f24927bf43b8de0c0f06c8e88406880a8c0690a6822a36a071018f6f6c200ed23e883be104d0749e30dc080ad32aabdb483279e96289d1e8ef030a97ce690c78c90d0b87e8bedf401311573a63a1abdd1d7a267cc987da43c2e92d5a4c7c5be0fb46bc912a6f07abee4f3e22257bec331cef61668f5319602bcd515f983bae3c12b4d45f421068a46b5b54c807075e8eac3a8b2f70269543be6a145be152cbe80024cb7472f3ee33eb60eb8c2040f87dc02bd5f470b6ce8d0fba14779f979663214f7329ed91ac920b76899fedd31b0b3bddb89215c37f0b781d19ff148ac0b2890a28e933a33b7c29ffe66ed39637d4f2bb81ceeab9439813762fdf1613e7b5a0d50b97fe7fbab1320616e5b1e6f8d5805b5307b9c538ca6ec08c7e2697b915f32221299c813cb0b5f9b9a4877f701d2bf45d613a0eba778f507d0728540f818f0340a209cae9498880c6ae5ac2d5168495e1a6d063c20f5adc148e0cf43bda322256868bc37cb18e7a697013a08da00dd3d6de90ec92d6b619a6463a5bd527e16200090b82f2acb341154e98ccd3dbf26ace28f9cda9c273c702cbbc5572c57b7bfc9e2198519f57f53da4a7f99e2a2b8493aecd08e6180889b74fe3d6326586c475342c916aad697388f3dee6718eaa2159310b6bd7921b3f79ecbb0da3f53162a983166a048e2fddc76b9c76a9432f0505658e53fa3212eb90df7744c524b3ea3f46c451d58e7f428b76e6419f0925ce18eadd2f0bd74e328edc585929bf3df23a7ed513ec85475d8d5837b40127f9f82fe07fc56b3628a781a0e16ab505987cfa6a8e1cb7342cd81b1fc72a3a5e98ec327c986611863e97f68412a7b590f2079c71b76120456cfc3d9146083b13e0b1647e1e3a0566b1283b94b5f8897f6a05653bb4a8ed1bd3b26926ac2a67af59253df0eb2d828851980b63b87102dd46151ba2230f3901d53ba567f2f26f738b2954b1fdb7c3ad2e891aa72371d38987dcc32094155e5429f6a7834871c75b6a825aae7b2bbe111ea5deaff001c6bb0352678a91bd2424afc843848727193c9150cbc8990b6f5c55118e58971de285b8438a0db6ed670a84d16e63068fb19eb846768478a72f5701b1c26d27d540571c15f5ac51baa8bef9a82ccd7f6f6fcadf418dbeabf305e3b97d2647454744c139ea14431608bb6c90a47b64c058ccc8665ffa3d97c4e4f2fef9788d8c93d434929ea826b9d328ac8cb18e517e057d2e853cdce1e10809e4202759a12f71885d83cd5d24b23cf1edc93e98ec63491d316cc0f88be833225299a6d72867136aebe5fcc836581e740cb994d11db83eb4aeb4668c538b905bdff4e4ff68aea5b2453d6a4eb1cec04151ce928411e6d983c203684dc90454e7063b0d14a0c91a2bb76915f684615d6b70d210c22b35baa96574100ff07814ecb1c7b46259d902f591ece8eb99e851d004a24d07bdcc910870443cdc5328bb21e9c77922e61f21fb174c3191543185bcc93fc595da61c774048c264f08fd0bc3501852edbd4a270f8025f432cca0b400b8f1843b48fa664972117da47bcfd5c83eeb8a33d9a79e0243294d58a9184c2fce37accf7f0645b2c1d6445a75334bdc658591721a44b7a7684e7cd4850f0b7714167d534554b165ed779ab9abec26e06c3b47787ee7a58f6ee621bf75e1e98ae7350427141be1d9be6160ff460c7718e892f6d636ae52e407f6bea1c4f50716c33685476acd47d05b61536f29856da02f929e538e60824990de80e44ab6f34cd9a3905d8c8e672f04f243fad8d3c3c19b980ce358024d26ef8632fcd32fa45879726fce52bcbc931b465b66d62f31e5e5ad101fe02c25072e51ac2fd5407e975850d2116df33db3da0921acc04796605a84634e142bee577da0b4a0f9af94012b768b32379e789ccef952e65537f24569fbe82d391fa497a8824cb5046e9848eed7777908e39924d3381e895380c54e79ff2e366174f387f7485df2f8dff41ed8c58d0dd8ef41680a91e3c10b830fd8704c4f8cc749eace08325dd15f289d3c8f8582298dd8aaa9d4729109a7ed1304c3c553d118e44394db0729718b46a1f4269b9aff3f32c781f4029f2781204fa865c1ede88ee089c5b890db768d71faea9601d1d1d5bfae09463f29f5577828968b51701244860ce611ea4580c16152ab5e93c6a0e1d4a5fcbdf4a021fdd3ce96772d6620d344e43291629fe153fd5f8b2ad82b76b37a5ed0da3b7af5a2d89164877c24dfb40cc0051de6daa1e4b310a6746b43a284f8dbab019334a1d2dfc04977a483bc2a17c0466173ba47185bb390cd0ab4d87c98df3943056f1d26f7042bfe0535eaa2b62a30b7bffeeccca5b859acd6e5a47054fbc103d0d3cf99ea3ce3ada698afa90bd40c83ac6511022b8ea48d85635bc2ad04b64fda204ca862bf7501fc99e5d7be72230334940f292de3e9d891b0c17a5d7762b7779aa72c4600681e6b9c9381bc43de4f8dd20618bdcac47d69fbfc34c5caee65559aca462014718592af5485b59cfbdc147b8d9ef63f5effa76f7a35f95948b89a35b83a78e118c49c01efd707836916a49079b34863977ee00db26f164df407a64f363b3029f53f0b75bb039f7ba58c91ea4793c60344b794b3053dc92b21dabd9aebccdb3903a94ff9612f97202660e0883c9a0a1a3a51aec683a20961e0f9efda91631f0586f7d09ef3cd01b27a3ab54e2f70f71bf8801df59c49b13c88a0ea429751b27b9a29f1ceabc9b07956b6eef0920ca4a13419a6f270c830a3e1d0e166215f810c703b68e8a3f79d2fc5cc0dd950de22acfe67c98d223ae5ab3d0b91ed735c35d2e41d72856ad8375e3ade69401f85beb1343cc5216087fab30dea90f91327bf8bd15030c847c3334c34d6af8cac8da00c6a8520bd1c6e802d53a0472d65ce3eb5b878b5c34a2e2cda019660127bc34d37d5dd5cd9d206c88494accebd260b97a5b118dac999bc1910ec52fe8d3155de1816207b82997ae5452107407963b4eb4c1bc4fbd231b4b46cad12a5bcf9b20a94ee8d97d531b2ea14662a2550d9e807004e964d5a8b8724579e72252435558df5fcadda4f4ad46e104b8f5b9d67ae271da686c90881b7f0f2d6f041ebf302bc8335d500da877afb54a686b5346bfd7bcf70db61738ed88d41930d296b42be98873f9a228c91051fa18aac9c99b825856f4f455105b7c297d07026c430fa045c12b997c973bbf08c283a51328ebfe7e9ec3d02a7b64f938c9b750f365e1f65ef87cfed21ede0d02dbe687d58f77c2209cc0ffd505b8a55e1bdd494ee4bbd085af411b53da7b7e22524af16c5b7d754d6d31fbde0bea55431565d6f7a9a4f2977e970e9ceadb682d211c25464e9d2149af6b0d629da1a106ca3d6ea61d4ff80bf0fca26f57df89b8e8010bdd31f548b384680b48bb022686dbf4cd90157df0a53d6189f00a28ff418e539b206de058c4750b0ae07a5412dbb930b10385a79e7f9651fb1923af5115a3f97d3521ca431d92a50a2b6eae50dc26f77f9c719a690563c7074730d3359cd14b9576670e8b64b28c969e9c31f84aec82d65e4e713f098865671a9542b47a0b5854beffac836eb351de30ab9e97d8bf87434540054810cbfa02d28476610e10b1c2217b64b6761c4cecc8aaa610e22febca0a6cd34ef345fc2ea209bbeeb99958752652d1f7bd21bc9dd5f114ab694a7904836ea92248e4a9bb2f15292025138d86589cb3846033f16c88771d41f6b6516c87e906a6c7ca4200876061218216c6f841b500c00c9e8e8ae705b1d7f2271df726cec71db384855e73809252ce398a90787ee23e41b061bd4c857c764e22036a6324ea28183187acc42f32289ab78034d82780891595b9832ec693cf61f182fe9105dc43c82be56b449f1a8198523fed31b7e63301a6958b3dc829f931b11c43500eed55850e1a5a7b3c7215cdcb89a566841d795956ac37d306f4e39dd0810680127b5d96325d108369dafc332eb4a29806509d0db6443a1bce7475c843d1e5f09008af5fda3b82608aa1dd219255ca2f35e2fa600cef05fe8025ba2caab2588a7f9b2946564be6e419520dfaf83efa91394f808a667117c59f10090926de494693ec159ba5031187cb5548ac2de07fd994f90501f7f223485ec885110e4dfe82e995ac170b78c35614b7c4001b6cd744dfddb21343c68ac2e9419bb08c1bc8a96c6a5a9d4fda7998a9ee9d1f3b8a95b6c2e8ead966d934d312307789ae34380b4a014504939db85dba0cb5fe55e7cc3753ba049d64127092cec348da5679631314fc3edc1cc75587d715002adf81149c2539e3f13bf269cab206c0542808095c210e675c0afb6f1704457ae8c220a0f20e36e8729c1dbddcba28fedbb31b1f478d1dd86b60756038d32a56d50779d7d72b1068b995ab32b4c6bc8e5cb2b263e16ff45b3eb872fe7e3c892eb4514cceeece16def4ade99d98ad1ad8c58673b6f282f3b7e12df664a3cbef6aed7e8fa79bc66236caf4396c55e0af33dfce96ef4040da89c0633179911d4e3758a412417ca15db8daf01a112cb0a39cf8d0cfe9aaef4082ad96e80348d9a9dd7272e8136a6d45ef9c5a4257f6d65bdd64f9cec4ec02ce7addb223cbd8108b928ce5b070c65e85bf61c3ecb7c4688292d29c8782012b2480450ba08e7ede945e05a0d40e2b87ae78c0b5748d7d9d2bf43fdf41b6b62668d674d9d3e29917b3bb304e6ffa15d150344604dca495d9e264cf0599077449c4b0cf5cad507dde8022328d9f79b407f7b44c252018336c933b63e7336d39a12c34fc4fcf6e2bbb02b7fed201c68da758a61250a19102a8a9ab8977078fc24447f391d6302c158be5f0f07540f5fd05aa2b9c1c5f01111511af28a4741794432455a2d0f7f0d43cdccae66c721fbcbe9037579a426d7a2633144a5ba991b672dc010de7f5b9107b8a4070deab2db669cfc9a77a3e0becaffd032bdb1f299ee83bd815d8c36b117399ba41e61837072b44670b2f02b382f8ab16c5624d4b2303b67cb4c1ff6ca64023db6d992324e5c69258500ab908849e9f8759f184d787023a64c063e4d8de4177da820b2cf293f663467859b2c556ae0c9c9602474c0c1ce993e10818acdd47969d41ce494eeadf71cdd1560859c30e59649792d013a042346d189031c521571bd81d5b86f32ae60c6e145c5907ec50a07117d0af2d048917a30a2c460f0065ff8b3fed7dc533393ff0638d44a74e271354a0465025ad3f11bb68c3f901b1dd385a35d92a982464e1baf0d4a25abd7b96fa177a7fa6773c3318cdc5183404f33948ed2baba0dee8be32dd36de06460e3607a411724174a5f3d1f04f09d2c253c4d78bd87efc69e67247f2951bedbdaa16f1ae532609a775b5882211f0809a36c7fd923803c4f94cf8fab5584d76dd0ab2297e476afa102009ca138b68fddc50cdc2a5d56dd0ec7841e27ab0679ce8e1a5939e3bdefae2f005667aecf73251894f6e7f3e5b0ef1e72c38ab92049e1f2c249be817f224e64bbc3a809ec9e354026704c05d25ecb672087b7b26a76e1f1fec5ef8ecf09c4bdd751e146dfe9bee829ee2e84edcae6208e38131821b433d4bb09154707c881ed6ba8ca4d2bbb4544d1501f17c600a278afc120bcf59a98b160c952c715b0d418279d571f29905415b875622a6ed69f819ed0636ea6eea0d9dc355d13582edd32e28db7f49f7dd40e636c2ba0fbab6cc541280b1d2de5909843b6deee47e9d39b3bd01c8892d6f672837213a6ae32286422f137fdf79c585800a632a5eceba0eee58e75cc1a35e89bd98f11ae7b1e45e3512b795539095efe5a96a05dc5436bb20ce9acaaeacd5523a11f01e8c396529683662025a002d34ae305d383af9dd0120d7d00508bfad9ce8831a7ed2d77951c019cc543ec2cc98ed5a88e192f5bc2ff236fd96708ea81b810ff87870af8c4412d95a6f4fc50ce2250a9c15539a6ce8fcfbe9f38ea7b150d326c86799478ba6293d57641a9bf927a0edd00730bba7c27327cc7549ff186e38ef20327b40e7129f12407e20ed6024926a08fa9d3c8f02f0ba7ed2ad67e090176405c9a9c2b39bda35dce87d45e723bd6cf8e9f0ba6497198fd908eb45a23866da35f5784baabd263a758f98f135e8c21db61a4235f80f107cf6c53707ba2bd669067a1445b86e707bdab696b28f6e151599cbcd4844968c0d4e0b0c0d3b5373a1ccd9ef4fe6c3f385b60f31392d58ced3f40c0ab5ae338c3d0bb9c3ee196f05450c9e49bf872d45fe853822125c7ea23fd8c2a33271a221692d0bd1daf7a524f375e0eff2d302540c2847876f27780b6b44a701506cefdf0342da43a32374e578cdf9c057d5a9b635f7ec4aaeaf00719af3d02efbac6663ac790876593a7ebb482b9d4cbc645bf4bae1a46074f51403aa5311eaed74e71c7247bc393365a67e37d0f0deab90b97fb59a66e7e4cbb9361058052007025a71c685aa817eaf20f1322b1df517ebf0f05823feedd9117b6eb301887512c65fa1abd5ee983ff69cf1c98517d9a184fb5b2d1a592b68c381958d3778fb4f18445a673a39520fa659d34bf1ee7cc9f780aa425abbb1d65f8428b56207ebea19cb8b102a715401617e057296ea18391567692afe3caf6b994ad82bc3f5e86e3df89aff1d7967e319d786b92e9ddc045bac1812ec5c55e19b8d7bb7dd58c39117654138a8df62487c1ff1057ea3c4f8d4c33c370e20d3761531749bf66cf32b06e5e88807c108b115108ad981824a296758f654512365426afc9262a20c357c4fb112cbc2fb62672f2c0a9cf2e9b7b11c00faf1067f956843bed19d659d4aac1efabebad630e626f88c7b5e1232c08b86dd4966dec45ae93e70638f39a69133894480dce414316193a8d7fdef7ffa9601bd5ab533275827d8c23e4c4aae2496186f7e76332b10fd596f71bf4a47245a9c368255c2ed07fed32d979f7131cb6b90199e11208e0a3ad793f9b43c4d2059fbfc5444d45741a5da879c969cd73fe3a653367bdf6f77776fc836ab041905b12f4fab0db5c77fd7b3565f3621771a5570c75c0d8c2182dc6842e2551dc424b8992e19cd3bed472739aa61c25bd542c54518764bcf305cd192155193840f255af65e1edc028cfe1d4bb2f2c45f1c2fdf0bd4d98b06efe19d2400ed41e0dc23af4530b4a652162a9b779b382db36fa1316f22aadce6336952ab6e423205eaae68c7d7f3718c388a639d0944a9d858967158e215202d011ebf2e23850464a6d6cbbd60400cc7154ae3529b6a7906024b428c78a7396790ee9861bd48ff36d7cde87c925400ab44738909b1c48c49baf37cc3bbf064d2ae8360d6a13a75cf89f419f6a8f003271b5ae5b1aea033e8cd62cd0de8e557b71b7d7ddb6c982331f16e2b589459198b0c18c4267c9a0c5af36e13577f489be9aefa8cd29d02b01d5fcda97170690bf9a2381bacd3c5dc2dcc16111c5c0fd0ce2717861ef426914706a8f1aba349895d0b393f7835bee36b439c5c6a4582a5ba30b8519233672ff1de28ef5bfaa76fe2af438246668aa99d17f65943133d95a320b3f9d5eb944137fc502cdb948dbd7fe9b49d24973bac4c8b007e8742eb4443b51ddbf029b4e6db23a25441417eb3665e205a67e50df494e8bc25b00a524fee1a1de198a9848154499abe52db073cd6f468cccdd9305ab579cafe79233f7dfcaf91ccdb7e1cf7c3ca9b0b41a4042c3c3d1a267b95c10ea611c4a3651a28bf10644f72989fc74ab464d04532fbccc21a7f5de89cc5085e469ed8082dceb19c618860815304c4f246ce2723ffb487d3ca879977202f7a139a088eeef9066ffc16013b253d5aecd86f102d91cb0729272dc6a1cac6a0ef8a36d87bb8047224b8b2d54e7dffe8578b852bd0a72e5e9bcb107c4e5ddb0b0cd7221dfeb05042422e1ae11321412a88eea534de001d97b95590c87fdcc8153e7f1faa89b09a1659de7dd941156950ea635abfbfb9e0e52cc03d46e8d10bd66d6e95cc245182cf7d6930904ec11933c68dfb0e6e17236633c3a44a15224811893081ac0428b4e845876f9fdb94e28ab07e4fe0ab513b46491c6bbe53e8073a3a88fab3eedbf20e8270514c276b250b31204221a232f7aa43ec6f8a8993b9c1e468d6b9fae05fb7e549c178c4a28326c48ac6ce6c396e9082e6763ef706f6a0d934da7e96763a9e5ee7ba80de4a333f98378edc36c9157d9f43dc734d651743438335c6894a245e35ea15e255e48a1b5f248ebc25bb34bf89a976997b820d99cd7460f209a54afe0ea3c33a8b5c0a9b1b44da782b0a7b4a3d17ce47eabb1f0b4e89120b48b57fdac1f2311321bffc89f911a473095e2e4006a8b40248fb4fe502f02eb2a4fe15982c7057af1e62311a109a862ab8e45b2dabf29fa2ee999b395256eca19d48065000fd8e706529c3f0a904d94737a48b2ee6586a01a466098504c17b4d3082395a7e366595074448ced2ed0a576cb4cfe734efd1eff6a330f19bbe8c2e038f7a1c2236fa50b3f7d4a6b6c91dd8d51b072f84c83158bda79ff4983376c583b2e64b3a0f5865e1220039790b3c06345acb3f9730b70feb21e8d020ea520faf4bcfd349b1055927949d475e32b544f244bbd0bf24b63a00d405050e52a3343df9f253d4a37f97e79fa2954592dadc61ca884802809f7684030e207e71d8a45fde86598d1b39cbdd834c882092098690e832e710b4e87492bf17e31087a8b68ee0ca699b97bd51af1930cc59de6d986c8fedc6c7ab6e1bf4c6d81b46fec23c33bdf495a48a4c46258f9f27dacdce15aaa720ffbd7820dadea073e1558fd2f469a2c47471709488a4d28941e5ddda5f07ce0ca505c4e8287e8d42b5cb635747ac1b961769b9b7b0c90aa93a327734aaa78a380b18f879cb5a3f6cf6f2d9b80bce36a0c3a73894ad54f9c929b91dc7aac83d282f201b424baded71fcce25bb1d846db8406c041e5ff8f0d0afca7078d01c8eaf7dcc15310784dbff5e885219094520831b1766a564f43f1be2a1fac7212a3f5c396b78063e4b1fbf24cbfff5f888ab25c88e5b91e40ac6f64ffa0fd718e5fb05572a98432233610d9aff4b1cb2b79446aef95f55cc25eaf1d09097aa2c76efbb8902653c03f72587339993b0ec1824b34e623176ce45fb42c309aade6f85cdb4297dfff739faf5de604ecf529d854ad21c865770b45998b93a90730662cbdb2f4c9e5736a2fceae18098347effb70281f495d6ba5bd132da5e9bc83d929021d2ffe446d4762855d86ec180e1c07d6881f5ef2e3ae605b73022986193f643c4764267437a732b2077aab2321c5e2f209370b926fe3413f9977a7fa0b27f7372f5d64c5ed326e6be67d5fd76198e2ff64adb39d48ce225fdd880290b864d21adf6b5f41907891f1c60ebc22a8de3331e7189d810a6531b28cdc61b4602294baafb3fc20481e25d721fc1df013d4d68789a07e99815ca0935f590a80ae8db19d9f0745f1cf306103771200e94fd2c1b93fdd7aa09e592673e762dd9194f23e86f15751d46103cb9f09c8141081a61f25d3c9ba48a5706c6923d5fcccf6fc6199621e9f8b33b0a5f669d29156372777e3552c510daaa5d28b25bd8e796f0377e79698b206809d315719575a852a9c694c3905e18f9b53055788b15a91c2270c55dd657ecd494a3df2cc2cc8fef182b1db88c07f16788a0ac84f45c80f93f0effd792c1bb478897a649a79766d2da85bc19c7c7ef4ad55a6de6ced21e0622b0250907949e55952c353e681e0b4e6b3dd00a1a21a7241cb86ef85bfe4e5c80ead93201c17eda9388e16afb610b41a53b36b7eaee2b24afe382f97e62ae70db328f5836cee0e0ac5d8fc211c370527939a8d9453b88d2951c617258b9a2ebfac4dbf8ed93a98bcfd65121560390ebb21fbbac1e0c8f72da75af3c8e436b059c22d86812144d343cdeca3c2c465ce3549f0f41567704fbb75f9677d8e7380b4534ac75aa201949b0570d406c1194f756afdc925414bc6fc0bd762e11ac4dfb8fa987ec7786072bb330ac8dbd99a8a713e38fc46ca53ed693c1d79750f675f93ce8f9bf066c2c1366778914e1570b7a5f21916212931ce677ca086f2be40542204a1624bf45918c0093473c2d345198f37efd062df94654865c297880f5b9cfe111d8431c179f849e45420decbb016d4d7631b7e0b9ca559b385c702373059b76e1a6b2b9b4f8202502068dae58c2e6432a48e6a8542435fed9ebdea04ec532b5e7d759f67c0075246052dd0658edc68ac462d3b9b52d328c75b91c46a867181f0c225f58f9d200970261c2c03c36ce1884d3f4d0ad155d1db85654a9cb090e69899be564ba172ee515e706c4d9a101e8080183087b346bda29b8299026547c4f20023e716b6e8fcb2574411d844ad9c2deabd1be8636399375491c1e99d3a70d53818c3e9a6e385dff8c74a50ec4725196c5fe826a095752326d0d24252aa923f17b238290cd85b20d71f9154392107b9d3e76c1a27bf9c6bb57d1fabec82fa75ae2109cf26f48f0d23059c5d1d22c17129c3db34074831251dc12b2d41bc7fbf308bd2fee787560292ebb862a2627e6bdbdaeea3f9ece8cd990089215b41aeadb87fe50dc3120a8599e8eab751497ea7f42b481e35613c6e704f327b65605bd83f827d658784ec66b88cabfe382017aa391d30bc3531e701fe8ee15a2fd39645d1ca80158985f0fb246d64528f3ed08937a6ed0be09a7d169ce53d90ba5496657996626dfc0a37b86a3d1992272e78bd1d6bb20e0afc5b0b55de5bb4649b4c2acd33ca283168b93e98a6a36808e871c8afe8c129c1828eac65df5ce753852a33cd6be2d90d4ca862bafbbe4a8df6a6dac4677de92373275ccb501ca19700e1ec0e8e15da88f66e5f6cb92eb3f526d9d8083b5579a0076952a06e3f3c20d148d63fd098b864ec5641a1b28fe51d4725eeae98ba2ff8a3ee9829de9393e601085c08e3cdaa5d8eacb2bb05a1e0b3e8ae803cd464fbbaffa17018ee1dfca35c97c34d861c04001c93147c4f6bb41d08c6c8cf9c29a61185189d80a8862ee94991c3bb0a6777c4e219d6cd6459f0c59066153749604304b94138f6ffc431593303b09c6439a3603a1583c6d1c23c6cc1b8078ddb3451dafc7ee446495c1c3c1c6801d6c563a14da564edc456009eab07759a80881ea454f883fe5fa259c1da119a1d2a64f5cdd1e52a5d7139504f679ff4d83549c63d570919e32c8c14c5ee1c8cf1231a89d644f33cd24be8baeeb8f6763f1b8ac8a2e1025d499f67a9d06bbc5e169e382ae453cfbf31051d11d46a86f7d79dedc43354e635e35b0e3c9f9b304164ce0a8e6e567cdb93633a367374c08c63983052de459348a06645cceb150b298cd3bd320c090fdb9e3526077060dfc9847e4f72f4f4c430c2d476673d8e7d059fa4ac13e7e8509351570fdbfb9ba735b9cb559e58a9b146e87dec4c048280c2b4a54dc2b0c3c87ea978438f52cf9b23ed4777d905f9b4facdffead74d62d999ac1e2543e503b3711817de9d462872de02392d3acda0abbbf664a1538fff27bec15252a85de80628946d813749de981c5ed7df5c1f0c105546d9c3386505be480956efbcba9765bd32b1970cab284a30f2f5423179618717b9e2f0c5c0a31595aab1dd54042d22bae6ca6c85f23b749be8cd8cf6e509007c848ff1d2950b2aedd509c2fc58c67bea41417f25cb125dbec5a678275c76378199a83ef590d726705c20a29a63cf68f5fe639a88b743e873014d6a29c83772b1053607056d918c767ab236447edb24df678d4de63d0bab495181309a5f56f72ea98e1337b0d031594eac66015b54df7af5a586b07c574b25827d505146de03f22e466ef500b634885318ccbf23bec631f854ba418a4fa8a2f378bd19e7f551956f69dc56337614ad6d6974b35afa5a4318a00632755c469f5012142befff4aa7edc65cf13dda73dfd4a2116d62d6336471b5f8b834f54a6de8e5322b59ee4b52b3a8eab24d6464b94c18174d7f17506bda0abf04389ed4af05093113ba288166f8b119e60851916c2637cba971eaadba69f767fa466b38dd865b9f915fce11e9b4895f1b39a2ec4e6ab0673e7e763cbb844db960d4a7380aa4dafbe0fefd82798994af2ea310a0182d088218977edacdf6b2cf7ba62daa4ec7c763b0ec2b7e4f55aa8421451172db313ceeb8ba64c5a47733be6e343230c5d3a58a7c65dbb064ebe48172548a6add0e76574c0ac797246833acc51fc6a533a3e0e1b183b14babb8c61d495dd0adfc8e33123a1f8128fd1a3b7c50708d83424ca481d38b77c152a5df78decb380f628eae854897c0f1904f5e323febb2e345fb31cda02b6a76bc1abded43dd626a58cfd8f3c34c8b83f173578197447286d6c03825ccea4a439e9dc86f5debaa9e06ce455254fc9a639212085c3165affdabd3cf523034c7ffc04873587c7bc8804b2e6b063d236008b412ea70221048bc33a7f2e400f4dbbe5afd4d38b2be68f72be38085cf092ec1a71f90114b9cc368811c63711019a684d849525ea40defacdbd38fdb1d3e5e0dddbf5cf619a3526002a23a2b1267d57f54df9c6b1da50d6fc8193e21e0704c878a7bb13be72db1a5bcb8036f228ae4014bd5fd0fa6e79a0ec7c9fb8fecf492b4c0ab5140395066ce7816898c4a2a4846023891cb57d44d112e574549368594e8388e0c4a50a565850d523d55a947aef814016b1fb0995e697fa2385f62329fa96bedb25b9e361c060dbd6da7fdf11a42a3f3beb9f5f71e48cc134d6a6831fd35e6139fecd4b1a98e1c3b2e1547259bc4373d31d69884239454922c9c57289ddafc30324b9947565bd4b505c0c75bf0acb1d133641540be50e9835d44939594c884fa4653f73c6ed0d295e194c0931f48271ce516f9d778704de74b45c17c6ce659ce29c70b1829b136cd149a3caab27ff0205dd31d5b671361776b4f08396db5e35d610b8803fd3abbceb26182400004db216b02173791d6c01706e29813ac37e6b8feda3318879e8abd64f276df2964bca7d5ab49c983873e708366b3a1ad481ca1cd37a274a26d9f168bd6b4db1929f96c7afc1cfc2f37e7f10df899e42916a36679a30e4a5259b0509d741c27e04d9adf6ab350e9eb6f144d8fa8925f9a79977427591d9e02dfbc2fad6940789317b32e688d59d37bf170157016ebe7630aa058f664bee6c4006d997c4bc429aef0cce436248933d55e4f6a08a6dc4043055c71986f0717b79767c24de07478a9bbe61fa712104361fa2ef0558048e5a948177e918bc64a6dda948fb6cab019aa452fdc18bd851e20ea04941483400a1791b55ba8b5b6014fe103f837bef02e3e959fc9914693f630eeffd5d4f04c08d44e315fd5c06f085a656d49ba6fa7de0adb9f7c0bd51358bc4eeca4c45f520c3d8552dcedd0decd734100dde7fb1f83af05eca508820a31528f9f2ada0c391967a8da5233cdcbda99c5fcc8667d48976ea025e024087879a3f43f7350da9af4343331f5af35b97279f6fc54fdf7db4af4d05a8e320d5fbdfae990fabc1c3d9d563be7c646c7ecb9366d03b983bc3f8146fcc016dce4e6289544af957548740bd989ef39f0107372ed55eb73410d6639b642a72923c0027dfa4adca666cb3ea6243a7f0c0183e3da2f3cef2f1d43c7ec62f5e286b9eaaf0fa26e494a359242b1eaa4c32da5b1bdb47bf4035e62e362abef5d6ea6ae71e758521473d35ab826d0def38aca4664f76aa7af1f129754463d9cf4793b7600249b5b796a745eea4b167aff09d5f10d800bfa578c6f9414a41f2549312046bd8afaeea15c0e9870a4c1d1c4e81778da277561e241fe8a4b230dc30588473d5c509cb4bd9364b70991a6fad2eb0d08eabfa06d3f8f026d7f32ff44f10ef90de9e4d0d10b1ea43de3cfdf82ce797c098e0839eeaa7329e5af6906a17e4a5b135f8b032f780bfc1349e8f77d9dff96a854a9453d20db7ad7504be8b6fa5c5c14da6a8f4071e30b79adb980e4687642c774fcfd513bd1d1f8040aac9a99e0232047258f1a2e28b9bea27e0086c8dddcbc1bab454f3f5806860cb82f265bb596a3e8e56ba7f1861ec274c8de177b9e97c43f1aa263c53354f5f9f77aac9eedf86bae62d6a75fbf0c1fe4396a5da2ef2abe3101324fbf343031be1c162eb612967896763c9464556826966ce599689b467a2d9ad6889155486420bf611dad9a7b74a2f35eff21419c4c9f4c4738d4fd414ec3d3d797b1044768d8116d913f59048b32282780912b2d14e23cb4bf82a83d88a4ece3b66df9a42a04058ff75d5bd2ebb11d3ed3f85041e1674e51fc9e045c2238caf4595820eff5215c489ea730248aad8bf2a276f9d1f38624af8fbfe7c34176ad6d841974d5ecb472886f5e4946546300bda2640beb274b76c3856c21bf01f34782505fdb85fd5e77c25263939ee80888182105ef98eac78fe4468296a4de0d09d090ebe3f3ef368d4b89eac91a18ddb28d8a7ca2a71b4b0a1e215c421aeab9a7ffada4b24dc58c7f6a3fb780b38e1793d8243dcdf9565ea4af09392b6728098a7aae7c40091197fc0412b07284a5ecca81ba8856d7091f197c1afb27f0474d7eb30688b369030305f6f08847078575b5e812611a3688a0b133654c50db0c96a77fc1df25b8490c78c4a028df4f11342e12ff0c8f782ebf4702ae57ccd84c16a7c9227d3b40aac8cf734ff7b955e5af7d8b410b5de3687cdf1c95bf47d0875993173c752d0b8bb7c99ecd6dbca6f983b7f29da4ca1e2ddea56f4bcac2c3d9a116c2f685372cff369b8a5c694ed096f4d853009c218a5cae9b61f9afe41b96d5b6baba984f77c5a757cfb6079cbe1777397a493a404b3c932399d929cdac7c41d8fbdb6a1b645f5682eefd1e55b6184206ada9e8caa91c05b75961cfa0b503b75e9bd693ea611a4ac86644b5fa2630c700f6748873811eebfd3fb5c00c8f3393d38b9d5afbf94e936a216fdeb76b00cb5b807ee45fd7bade0b6aeca26e9a2b497e668964e90b7fb2f697bfba186802731e6ca3baaadfb7c6bf74e44d79e911b385f5b7ee2bed7a332f190462b87a18bfe9eb0a7924c52e5c1d59dbbda2978ecc0681af757573a0f2c281e46d15173346419914073b37c58077fa586d75a6a121cd401b5b225397797898cdaa588447b5171f4d4d26a7b71b127af26bf06b5a9234e2457e9193c324df7853e2a6e743b2f2aa2502cd18e7387112d45e99ac66ecd85539e8b5ba6dbb0954940786af15a0e5aea6024aea05e526e8b90e00b45489988a4f7a0b6a5443725d7e0ef04bfd3871da089434433a5318b226c141a6286f56c86a425a32445d8337635b6d79d4ca0201a2403a2d81a4d3863199a86697da7a7e4ccfd01af4444242d1409771b43b5cafcbd2afcf1d987fb5b4285ba1d98a53806ef25e2db0dbbab36b56d6facef3c34e044c883c0ae467bfca8f95347d2187df2a93d191b8bf1ad61ac16e0dbccf2d8f8940d53be8bd2802092534e7bf1204852902cd0a56a8887a166d1b3d1f8f1329efb76cc5571d9b008eba2cfc3090ee62d540eb307e676936c168e6cac25a02040c0e0759a20372d2d29e4ae7d83122eff642feed1ae0267064aa771fb99ea0b7477921ff938be94855235374fa5cf4fbca38dd1f5ff47ab5274c7a96339ad60fea986daa261fc7effc0f0ddc7422dc35602f35aa42dcfa7349c88b75f126402186facc10641fadf7978dcd25f68906b5f5aa380b90a12540ce4506d0ff829fd541b3d0a472e8d430385c49f23ee2a42e343c9008217e2d14a6b79cff20f390f5fa28802952d89dc34f311c648742336173f402fb40a38cd0efe3911df291443e1da96ba642ff9cc65a69d9deaa4add5853f93c844d86d4db26c5c987a46278707be40953772096065232bb6e3bb61d1e2099e75f5b315b2ed975ef7f09f1cf2d1e4eb8f1ea6eb6b40e597afe7f53326323b3f6194de4561fb88713015412986d748df2b65240488e4d3f18a9f2646d4022e9dbd6a73d72b3e30b8b26b31c8f3e2fdb05d982406835d09ac1fe4159684d70b6ce6edff6e11bdb3e0ae85112b34212fd911a6db5c91a8a0fd86ba6aa7fcf7d77656806bda913781d10aa008ce73465431e91d0e87445db96136732ef7a8f7fa335d6f4ac425c495eb8db50c521559506e8465c34e4d1f4760a9ac1e6f35202c8e6f7810436776b83e7ae5a6fb42b6ebe07fde6cd7266c4e4f51d2cb20345f4d2acfb435078039fa4056cd09b6248bcd0f8c65b47ed7d067c4bcbdc461ebdfe084b27f60364bcb33ed56db40db686aeab1431ae5726dad9a123565f3be9afdbd4dbfc59aa0be854f6dee6ede4a6377f50c3b15f1a236b5d8927a59e6f7e4749f0ad97bcaea065ce75a869ff0a1c267e61a7bec00da7b9fa00f0bcc9f5a037ca83b349444b6f9164f6a70e0cdb6d9814ea6fafa890eddcb671c007a6c27eb0cc95ac63410ed08a089d6f52838c6bfdf2e127afa16e9ba042b86060a1936756ac43a2d24e5cbc19cd0c977cea855f5ccd299968bcec4f62f290cbd9f71c1b2b78b224f4a02ee0cbb130402719dc731e4f63460fed7d77d551290a2756a7963f7887fae1c0c6fab88ae4cd66580fa2302be5c82d29f888746c7a8d41084226dac4bc31b0ef6b069609ef05daa6545bfd06f0045c3dd847f56f9caff97b88ad0b2b56ea82827da5bdffddc6da393607cabcec333b3b7c3439109f244dffd40d6689ae6eee050f9cbb52d437f2297e06c13b035e44debfc787a69b634ea98944e17d3fd2139c8f301848a5284057d2d61a461da9c88c1e4d8f89af77091eb71f8eb4dd2e350e704a69fe399bec46baa7de76f5eb65e9f571869399609e3f81df46061e581e1e00821d06996ede2454ed7edb876d1d65ec38f3e6487cc5e8292335ce85a2a454de225fc783162b1cecb2c3382abd4cfaaab7e69b5b55d866058ae810eb4dc1ba6c9e8d50b48cea59cf86f21ef8d1f353db81d4e81b673d9e57868ba6f08d8c9ad53d3c9fc59a7e88e09f2aeabdcc419aa186145a3544ab1b93efa9ce5c886d0be0cdcda8ee0a84ab6205e2d836f38e70005eaab082e8136b4413cbe790a2a96f7849a0687a5c313c0543414fffdbce407ea68aad5cdc372794c37a2bccbefc197a136337e5b46b9a42f3e930ecf36edc9c095656d429bb42543904b9deb4b609067e065326707851f424bdc4ab45de0ef0eb0c6425422e58d3cff16388bb9da29163b8a0fc6606272c22590c6f1051cc0704e08f6874faa748b17d89b2afe9c985f1e595c96fde2f7973d1427108c7e2194d058b59edfa6a084f79f3daa6d87c5239a9e63b8e8ecd2f7ece9ae7302af080066189817b34fd80923e674d1f5a30c35809b58603b798226ed3a6976d429db441cd4eac57d0fed37cd2645f90e9048731a9f781cc9c0708fe5f9e63d3ec4659099310bf8ec43119207d796fc7d6c4fad0d57a59fd42a3861ae9371dda49863f652f7e3e738895fa118c4950805699672bfb72e8417bd920f9420ccfd5b172f0be51604909d15f60980a217c03a371fcae50932bfd9f515e033bb84c54ffa1144ba77250aae383428d3d4490f7576b247d4be2b7bc5d657b9a8f772976421d906d49e6612c52fbbc6de88b0c61928bc602bd6507cfd59daa96829","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
