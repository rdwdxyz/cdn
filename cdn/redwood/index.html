<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a24b3216affededc9781e3546725aad9419f56b7324f468a74b007b6511653a2b7673023f53b299a267303e0bcad0fbb8c65e1faba99d0dc1120d0f32458f15af5fbdaf44c2757a3f67652d39217b728fe352a7ec94ff7b1e4dec5be193230ef3bec3dabe5528f2599be3abb1a9098bb1b0464880b3f55df5885334583415f4708e86018ee5b9d99f030638f88592e3ac9c2d5dd003837c3913cd59f79958ef18498461368eda2f592e342369f3c819dd7b9eae8915b505701ff42bb7a765acbdbf552b06dc4eca96df46140756279dd5d279cace1bc5c1c1081182cc5f4c973cfe8504e5750ddd3dcb3dc0e967670b26070603c1c2234be295d20773455039a60e0f3681e939f325ccdebacc9d64a5e4133876406dc5fdc25aaa61b34e0704887edd64e860103b275078597bb722badb66854074841bdb332830910d6cc840ca3215bd019b77da8315842a0a7f840f4f411544641f1f2b5378cc95fe211f6adda4bf0e1853a2d3b727c0d988783c4226864e7e65e45e9548a4d98c5718c01129e4afdc99efb3e0d5b8a7173b9fff0108bbc62a5eb7810965aa060d52d608975ff0bd7f632358c7d4be748a4ac250a0cb27e05f72dbc44f5e1f7e060ada70996008ea17c13ccfb20fb05b7f0830ef0bff6c5ff094cc5f3f7bc0b24e09cf25fd0dc33e426a58148a459ff1d0359d63252976be9918caf2758c0516065c193aa0ae90432aa341dcc7f8065d3b1db8159042464b6e88407e2f63cf986bc6a37ee60038bf5caa401477cebd0bb08d8337627321e974baaa35884d772994cf9f6197411d89ac419cde40a54c08a702df67f0b8a60d04688adbacebfe24d7a479357650befb89d8153aeec7436266d45dec7f886836fead1d26eb64cc444a063875385c610af519749464ac9e0d2053adfa2968db93af6a8123e22b0a411d9d1e074d82062c8748a4ec4a7fd46bae00856a5838c38ac94de9562672d6831e834acb99cdea51d970f2d48ec4501130db593e251778b1970fa9b0fc5dfdfee960f011b5b2394c99450d13d774aca0a80615894fbd079e9c66e925e60cc6e29286d063d22a00b58693e3623c58b5a8187e4c94fd2e569d69c4736e6a83d39addb3a9472192a7d0f5c5ea9792f043147f4c1220922edeaf83c74741e26140f574f5e7bc8498883c289f2e947ba2e719aad02b98002ce69830721e525b2e734e9c27875a6d976a8a165016e3d7c7a8234c959845b0776c58779e791a5a853b0c273905754dc754bf3c538a69f9c666cc9e9a281b39a96997e292a13f77adc1eda4ab0cac98f20c7f30956fd63d45cd08977c18f612d24a85faed762ad5cb9f138c959261322726202305cc990e35d6d44f9978c8d9e908e0006442cd2db05687ac8c06f3e995bf0a6ad4cbb120bf01eadfc9d12dfe960508a3f686433369913a0cd1039b484880e53cccd96fbf5707d3c27a56352c1352c1f9526db178c1a7e4cad5fad842542aef057798725c6a612e9b56ef2001ba06891e5fd482a0045df6a90ab41cb0d35d9232b4ff110c89d939412d646714a0aa3b97861caf0dcfccd1acd7e47af784041f911dc358b8c5ef791be4254a01aa9f49acbedadf17f68d3154a3e9c86831537b305eab5c8255c73ed2235091a647060ddcfe892c5ee14920b8f1ef8578a37c965ca2dedc93fc8ba3af86a1b5ac46bff09342058685591b84735eb6cd60232d3b0eb4299b8ae261a320a1bde3c640d729fb7904bc616fc34a87b7d92de49e7ebdc20e58acdebf41f06092fc58dd98913d1779713a2f2135f6b99dc114e1fef14b06eddeed7c3a4f149027b9514530d9e2fd07cc71dafdbf13516e7bc5113b470e37d9af913e033f4e38f892e32072aa6d75aea8c3489359679965028f11e1299f0d06167d55c9f0105ff0e729175819448500debe30f46e305c1c3e274010faeaef9f6eef2b778d1152df14fa73073c9d294dbe2e2a69c4df05df96ec5717e4a640d28b489d6b65709c7ba9c6d0a65dcbba0746b6bb17604271de9df0264f302ba3114fab608905bca167f78da8e35081014e5fc0ca444ffc00aee2cf9511bcda179b9f2e043e30cfedbe9800fe5ec38a8ff26a950d4a5e3e81e51b5fd4eb3f5f122ac3fbea25fc43341ab3aa58d5cda1d07d33f4695a6d2e8aa6ec877af0e60f7c3261e4ea7c3eb72b4af6238be05d56165d43c8ab74ddea024e7600437cba563fd36f34d3cd5d2665fea1af65c0ee521d365bfe6551cb853f0a093df610d2a6b67d92f513b030f1829f787a9b50a6cd37b8bc8dbdde76d5b6615cdce19afc848026bfce367cfa6ea0a31bf902e064fb7e13b1236b3665721d48a8299db9fde0cc363acec4d4c76fcc750030ca7490700fca99033e7cc0ba5ff0ba6d08bae0ac61e07981fbd19de326413cae915528a65077bedf7e5699eb06c4234365d22fc2a96c3a962e8401aeee59e5c985b3dc81959367bef7dbcb9f4bfd7b9445f2c3f6146f8a19c65278f8446f7efb43802ad4b0a4e33fc7062968589cf406a0f617e93f270e46050286af19977cfbc1552cadb1089cd282eb6126166c4108e4f89a25dd46a2d69036be71fa03d4dee7d432b9df61955a5a35ceb5b7c71acaad8472dc21339f7696c1172914c041c8098220fb7a7ee004cb22155bd8486bb982a297b24485bc67cf19dfce9d76175f8462de2832385133b9d07abfa4ae7af1a52db0bbf0fef1d0a196b7dbe801976e116f1c1ed4c5c514c0dc3e5d14dd6134c470fa7ae52a678be0e7e7f9bf770ea46878650d0dcec1566ae9bdc77cccefd727c534c782c04f6f6daaf18e5e895370c6f00c385679e6fd066af1c802ec7ef6ccbac6bb26610f93c82a3ccd51c89728af1d5fb03f0a8306fcc42c2b6b42938082605a403a31920832bb52de3814a9944862d4753eb9bd7e0d9b6b2ca1a4f55f14fe081317da60ed7ec21a6df13c3edc103fede751a81665b2427f854d07a2536be0d271db60138f34980f45a2a80e0ce941196332be2d59f0de70b9ff2528311aebca941345180a7832593b186f3f4a5adcae086a1039fb75f3e5eab365d1ada33938029ebedfa08c152a8fe005312225c92dce263e8d273e285cba1c179a34b46d4ee9bcb9d690d73a48c884029305cf9e23b289b7a5db079e844a470b8f84dddb015bb1d2a77ed188b4c9bcdfd980c6dfeb97e750a63efd480e19fd49461e4937d1ae21b4dc623bfc13c3917b09ecf400bc10006498698c7a4ffc2b7ba86410b8ba731971c9bb057d2386a76cef26007ce0fbe9f106ac9acad2a8edd69262ea7a4ac398c254970269d69dd64c106aff6ca430a031eaebdc2e11502d98473253ff172b2f3dafb3b4a40388587659aedb5d28a0ca9b4485a98836219c387890c856e1f0837d1e8e5da3a9fc256b684c892c5d1f25bfd521b196f6ab20d8bf9a95aa006cb5402d4f37a3aa7c6035b595ea415e8de050c28932eb70d5bfdae7afe169ba3b8304d32beb009cb50cbed836e2f5e54f73e7b0a815a4e8ad26b3b5d38614c7f99500963a9e3796082ecad5769f9bc0640ee5a50978ea8a38c0bde8674fce65f4342d30b98e99bbf74ff49b40ded66f9d524182c79434fc4434ae6700d8fc32caefb51f9acdff31b648b7d887587aa34b9ea86fbfcb4f55799f9d3ca703b953a3cba90a5b581738fbfe2bd59189edc940726b5771ceb0214a0239be2b5e4e115c26065c906786430fd6c3fafc72d269f79f0d35e36a9a95a2a40771e445487416569d13c0aac4b4c26531131a69fc77a0dbe13e596a0402650cbeb5da35c5bb751cbd3648c380e2bfa19b2d070ece7ab3c02dd7dcf3232b56d89011862fe2d2923af0f13a2d9c8ae9f40f24432e2c5b8820a154f4986fc47616eec1fa6b06bc576fd00a006f83628072e99f3aeae4714c8cdc3d87055ff5418a3dfd40b8121fbc20edb4f546313085f006ba87d114760459268434c50fb556eb86272cfe2f17a0ce780c2db01e17d3353a2b2181bdd58e14f08c003a87b9fe617bd6332308d8b0a35075724d36de1d69cc721b928ad9692cbf6559103b23219abb7d06948eec813bbdb32f610d76c4998284c54f23b2c925a35ba72b86b1aa0fcb7f5a6ea80cd745e42fd54662e8856535207fd11e3408b07b1efa887f6af0ae806f001a2e361b3be35354574c2c22df71c10c8a03569b789136ed26b1431c9e4c1465702322e6a42110e3f58ddc92a04263e8c68d87fd7100f18f00daf63b8b2461774ecba0502f70b97c063c184e23500dca5de003e02eda61af3a657737cba36db9826bd8cf8360683ab8579f4766410bd410c2679f7b5953c9762d7879d34c9ed06e85753e9ae7ca710a2bb8669425c6dd48f2a4b2128a1b21a65e6a9a9eaa6fc0d3f28baaccabd0dad86d0f436612ff0c0154f6e8459e5cde7d5828ba291ccfc5683e5adc7c96881e9263128c7126016dca7ea86c2e2448c68cd7a3567b5a2aef805dff386fd001eb505b2a23954b2ccc4675793b11a8ffeac13afaebd2ec955fefb3f24277d8000bf672fd16878bd1e0c7f9cc566e4c700ddfc3cf4cd60b08ad6de3865dcf890b87b1d882a81a1bbea5e21cadb676b05c4aca5a73530e2a0eb53fa882a69a30282701049fe2c55852ecb354ca9b73845ff7873b0880baf31986dde80c2225896a92f92fb9ca71ee815cc6450575ecb98170b3de92c1df7f5bb74b9c5a7aa560caa39b3ddb1c8da4189a27be90b84bfeef7117d7254d9ab108fcc77c48755a160cb453b71d24707cafc6725fe2336b86d58d2db0a473b731ae67b11e1d9ac2d2c996d3fdea9a671bc8724cf035ce858c7c0502ae9b66020a6072ae5f28b1369adf0b3892b5cdbbc4ed87834fe9a7f781be1b3231c4740eff814ee58b31dcdafe1225459f3302ed5e3bcfe87cf8ec22127ba72da5fabb2557eb60021a482985bed900575b922742ab4287afcab36338848fe7dad541f5f085126540a9b8bf51811728a3ae3de7bdb139c47d31a3b0fa12a5eb9c6c470c57808b4198ab3e574f2ba5707cb7df11200ae95add320ac6736f685c9be094e07aa2e767474bde446f0201164ba0576dfe39f7e3536ac9d293754b694b9aa335a037d840e0747165b4a3b522b58eb9458a2d7fa01edf0a3fc536096dfa2605946fbc5ee937fd507b49900e74e3c11e6f4c671ecd0192e95db81b7839333fecc549bf92673515f47941361ab7c86e19bc1a5ee1ebbb3d452943613444c4bda60af927459e35b96f80331cf895ef27554edab716e32a33ac0e611c7d394f4bcff237ae9bf3c2636874131186bdf7d58f82d5229ec8fedacad54e46619adc7cb32bbe5caf8fb648bd3cc85ade38a81dc5db0f74e8a6776ab6cb60d93e777e409c718c4a4e5581ae1fafbf7993b71952f10ffc61bccaa84451d5003a43537dcba34d33fad0b8e10eb45b49e31ca9415943172b997cbc367ae5938541e0c362a3fb7b0b73d7e7d6cfee1390e3605b40543775af01fa4061290e546e28aad22494d383cfede530641cd13c409290deff742f78d51e719a2fdc442aee6455d3201584ce188b6659ac94ae669222fe5d2cf1913ba9ffbac936e245aa3a01ebeacf23fc90e722c852a87a5075386e4d9fdd8bfda99c0efdcb695aee5c2b3ef1e81c40962d1b1b91e9994a5ee5f3001b98b183f3ea6947885b6afcaa5c0e6dd975d40a8627b6e95fa14b7ff35bccb7f4c443ae5c4e4d7829d6495a84aea4aa91938cef7c9af21233129ea4c9473d545daf7680cdb546e3b1c19f6f736c4988134dbd9141ee53210c6cae82216fa8600c122d0b5e324fedd0000c6388f9c66307dc4968d131033e3cac7a2c5669fb4ed0fc22457a215f0f48ed51211991ea4eed92f24489d36bf358b64064230b8fb35dc59510e0274d20dfc3cd1d7b9197be48305f450d203ecab7638f390441b1d669b3b5c70a0843789db133d351a0a2a72a87f5479f59964ac5decd476a53de1b583461decd1d4e13bf924ef5f4a15587aeca7207431f0f6741c60d7162560223fc38ef8e1824c4ebd59f9f8b64a2d1e98f7ffa067a1fff73d81c26f9faf41a7f3b5243abc50a6d701d09e74c34b42880437a1aac89554f72b83a1ee60f09c728d3899aa9ed1323161eda28b97113d7367912ddcd7c014686ad67010246a9d29d73c86c3bc4a89056812f4ea8d0a7689f59982df8334d878d4df26203e840795a12ad874f02c629d6af483ace481f7468f61eee35ce48068c775e8c2daf872d0e162901a9a3e1e60041bbfe58b43ee54c382cf58b675b1d984c9423242a5c3ad679803a67ef8754508ca2ce501319c4cd2495aa426e558acc47b0c353490bb5dfac0a8e2ab2651c3e85ca3a3d9975a580e4a9c48d233ab248bdcd30139cf3f9e48c8b138ba8c22ca14ab1b1f89f2cc57cc971724c41a125f0b2cb0e2b61d605fd8bbc5015c2ccf51d4a66b9699466a02ad43d8a10106c449c4c4f13504b4504c8deb53c6b107e97f02cb8b1dc12f567de95ac2ede2ffe5169aa639e79e44b355189f39d579c10353b1e196bb2e0fb8315daf3f78d28418a5b68dfaa749e6a8c6692bf1103e377989a765ce70da575f65d519e51f51d73b2edf70552066e8bfaf7fc4c101f0cdf4bb620bcb45710d3c9e32fa6353238301f33f3060ff5a71c01612563029cd12ad16c8cbbd04ff73d7d57db23de7323d5b46ce19480d9dfd4012adb68b8f84bdfd3278ee8f6750ed29c668e1f673a3d005f3fe8fc5d24a92d0fee95412be2e7437cc83798d8ef9d520fffef10e881b81180a2aa53654806711e05bae66b6aafdab7c6e27f7c24f09add61b88817e43baeae9235e4c65e90bf7deb7bc0185d39b967a09fe9f818bdc1974663b56639b2a64d23e3b60e19eb38105777ca46bf1ff704a1e671d4fcbbb9288badc18ca4a9e1caec0e13756b557207f19a7bae40f1470f8d9c4cf427854cc2b73f9da06561ff334580add891992308edfdc37e1581ecbdaf8e953c453f8422f0f332c8fa4edfb934df465de6982066640280ad6885d21d6d928060ac0c707dc53b3689b50e3a8b7d94e0bd452ecb75628ebb3783a4a0903aa5a3e3ac93b67a577216ad672c5a26f10ad15ad132842ca96947b3a535c025119fe34866fd1f8efa09580a005484b1e2aab4f85350135f90f54ed67b295c2ee84a8c6b71d946c9b3f66e17894ff69dac7fbb2092a49d95fc09bf1df40ab6918e1285141b26b843b86f616facd22ecf075c281b46d916c536a679572c6187450d168470c53ab6dd2228f91d40546d2586677a33150d671810ed8153ada9bf8dae279f80de02e3c3b4fadb101cb7f75ba77405d77c09ba457da2aceda8f24b0e285c286f7caa5648b5805c140cac4abfbce6159a1a9d688fa8c6332f089f7089d37d779e8f5f760355e725428fdf4dd3c142d999f4e85fd6f3f4527f1dcc53c252ec12077255c3c8ffd4cfd965e259e1f63cdaaeaf7e6c311e353e2904881180a3cdeb1da4fa19160a5c028dafc591534949c0987b62fe29d83b3aceb1ce30f31de78845bccd3fc5567b59b03ca67aa2f01bda05016992541c3c85c0c600ab3e5c637660e7622cfe3f3607f95d1ea19d4b551c3d27e2934bb72730a0a6e53a69f9c44b18e1ab3bbc30be24e17a3f14d85cb8398b4f6c7940b3ff18caaef04b0250bfa78041662ce745561e2ea3999678f58a99938b371ff34eaac9a9bb0a0d1f7b523909f9281a54b8aaee26445ab0659301a23f2d89a8ac8d273f7244be61119c5574239be2bfccb83fcb6a03fefbe64f4846453220760b39ee046adb48c20e992da80c98d92bb3c4b6fc95fa33060cf344d47704a7971dddb6f929cc0111bfbab9d1c2d9daacdfe9b83f02056b9f5324c7153cc23f8d84a9c858cc2a4314088c4d70e7e4e2620c3bfb7b304bf0f27739a03b2cc05abe1c8223175494ed9a7566d76372d978dc5d5f5dc2a1d85f8d1898ea726d0d26df30bec61079d0d6dea4d07db8725852d8350621e9aa193595d832e45dadf8b7acfac3a60aeabb474b25889c333d5d8b52d8c2053e0ad6fb162c76c7aa7c92e873895a2dce5dea209642c9442029700cb02788c77333678e176adb84e4a979aba3d6cb723dde622bec4b230129075145acab42add68cc398bd5ffcc22bd6f15d020297e2bddbf30433094a444a6941f4e22d57dd82db93ea751512119f0e4b1e1a43fca8e24c9afe9beeefb6dcf4d66c9ed974eff815e732139fb40fd0d93a77d11ddc9b9edb7164d82c3e8cb86a7f090f6f547f01491335a84cfc6282480efedaacda0937079a28ee1688c133dc1ccad794d6b4ea4f37c8d596049e6c37daa6d3f14de78b6a6cce51e4e158f77bb9a5a1b8920ef3d31a16c771212744ce0054d2b37de81cab595b7bc7e5d83960a50071b8b0ea512e43bea2e3f12c62fcd3ae3b08de7c8d97a01e7c93bf0431c216c5adb6e8e8e263e2be3fdcbf88b1115316dcc2a92f6c73808e0ff67316baf51931041b3a2ddff0b6dfa4ccc6621cb1f02d34acbe0fc6b8e54c80d7c536f29700565070464c9255227afb4f181cb655fc6dfedca3800f3d0915d3168ad43b9cea094278a322c4ddd3bed51e8678453dab188ba326f16ae5799eff5fe58a92cf38be4e214ca8155928ba641943e07881f789fd40e96d8df76cd46111efd9f486ab896d0f7f013538d85464f99cc187aaa4048b8c342b64533c20e87b42b2c8fcd043472d8db17731956b55a99f7ff44f237ee4156772cc40bb2995d450cd2e631c7dd6de74c0ab8933eaadd354f5edd8ae7730e32096d749f4c1468f622c321d8a2d7ca382a9c0c36d88113f1981650092cd231ffce87b1f4bdb5a9a7c62970d274dab227ea2463c89049fd7c149e74df355a9a9c04bb874d5ce84d5b39e795abd6d0ed55c874f4f96c0d8f4c6bb7ff960a4b4e955d6e82ea464970c6c5dd1af7e6b82672973ebf2b33c14dd7516f639e338be38fa567a04fadca6d36520809ff2a18abf614ccb9879a2754537205cd6bc91a3218d4ebf6359900799d95a5ab4c806ce0603cd50ca72028f7f218638dca2079437c978702f8e002345b2d55d8fc99c99ec807478e49460fea51dc3c382d718daaeea1fd084663936a67eee2f3777e1e4388fbc82907db6074fe93a14ad0ee23be79249e5ab6bb75652644df70b3c4ec5c428ec7ca66b11f93724bcacbf2f3b87bfd6cab7ec35170043dee5b3d64402f73b0c0abc76fc1881c229ec14dfb4812d118793343ec00a5d8392b9d6fe9311fa1b8b0b2a1c42dac4647df54f594d0bc96b661bbaa4abed5d6ffa79cd693ea14d69f7188ff2baf4ffc631fe809ea674bfbb5b3105d3538efba07085c69b967b76a37643a6de5c381556bd6b30a1ace9ecc2ec276f1fe8bbde3db53f8fc4ea6c62e7d0328a33c9d7733e9308e357a41fb386b9b81cc9348ae719d622dc6cda87147ec8ddd7f5c220b34f5ed9e19a6759ee965b8b126f6c67acaf91ae8725fc7147ccbb7b84eb91b11b70413de95ed787786d32d51ad634345a287c8760b0f1fb2b3da7ab1003b211451143cfcc108aa548f2880b99c9a9688d91185e543424a85e1737116a577010d0ada4798d49fdac6a9714d478f7e75509d43b4d07553dcefae8f1cd1039a403b429257e417405d5c5ed1660610c991344cc85dfb527fb6fc8aae268feeb67d6e0ba3d5f9cf30c1cd5f61eaa84979871d76ae4ada5d60ee33f8958f91296e3c54c2b28724e7c7108c23ab24e34c3b2e961a6a68fb11720de1ca6270046e79be84ca4563b44fb19c729fe6f341baa77b0b395ea00af9d37ff8b54b13f2a1e5e732b99ec6077391906e7113c706e27c6b505355cf4cba5c78bd2a51f4f1c3a02820b5de7cbe30d8b7b3a1bdcfa0b18a018e81ee7a6ffc81d52cd2d97f3cf80539c755e124e5da318c03e47b37cf8aea4336778bea80064c157d6359a18f1168c6171efe14497aafb4aa36e5cf9607ceabe7cbead5171587f5fa0a4294914a84e8c6e415a60787e06db79a77e54e90f685420a032170547c640908a6c9f326c289747af822ff0beb873ff15bffe08d546701b6f3f56bfa9296458209d08b36017b849521af066c4b592e39c5672bdd57aea9fa3e143936ebfedb361b3f84e0dbb6ee892fef080995bb460fc0a1afbe1881174c7440a7f8127969d1c6a8cca8dadabcb7fe8abd8a162c76d44094129cbccde9f5de5217f3ab3515296702f2702fd3865cf2dbaef8d31b767fe872b1c1aa60447f8944b8343c7d30caf859d2ff8731d8d9b3122370e14c2fa3536cd4a63cf8bf636fa9c2570cefb94e696c39a1faec4282f8694da0858edad1d0adb236cb9a0d47635df8876d15e9b291868fa483ecdad2520cc81468356d6bf48f07f79dd8a310c9c3a9a8c31a18d45b2a1014baa306a1b288887c2c428ec4822b07a76f5a9ed0a77b3d3e2676a93845320213ab9115a72534e37d9cdbe65696b812534865c45d0ed2b64235ccae93d798a3558cd44cbd36ca905f0c83505b098628024b65a89560df2199a5ecbafedc2a8027b64a3455185ee092a506641fa73b490a22c3cecb06488be2b50a292ed3854f9048f93d8fe27f060266a418a1c9bbf5f0e966740a48665c7f5fae1c304ffe9a73f4f4a6d41c0d2c2eafc632e758dcf550cb02db1fd9028ebb5fff43a4a3e3ea37ecc856583ab6e99305786fa22d97976fd281af50429e976986a3a86d8aaadb444a5306dfe6a0535030d9f393a955780ded256e0c5816692668c5e7d8a9efdfa5d136fd3cdddb33a4710846ec29118d7fa39413754166326b39acd8b3e49cd8c4c142651a045d338a8ce12bd4454d0aecd4c81904ffc72da9191d114d9efc199d4e6fec5f85515a9990d08092a16b1fa7e4936c0584b80c1e7d74e353f66d04fd6fedd2c0981d06c7fda1ccf7e608a9bf6252b5be1492cd80dba203ddd4b6e35c79919016dc3d62eb02df33a9d8ba485c416e26eefaa4a9126f38f061105c29b590bc8af15625910523acb026fb2d5e4f7efb5560213f62c053bc6edcc0a80805d8fe5d436c8f7148801991bdd04d8558c9efabd29cc9e9cae15b35f8b44482ef403b4692ad51a9a967fa091e0749068239a27ffd7be456c547adcb25d81627edfb9dfddd17e4d090aaaae6b889ca1584776677a292e27d78386c5fcc56ac241dc0579e1bd332f3c3bb91bd119e92fff8323cec1f5a90582190b2a8b796cf102c13e7fca7ce537d8ba28dabba5b8cb12077c2ad7e1fffa9f042eda4a830117ecfb9af59670ae699e33c8ed9af27de2d1d801d355ef1c03b40418290ec1ce00efa05bc6bf0d12ad80f8d881765768ca73866850c94e0d8b6933ef6faa17f54b8a930d5359f30074ff7acaf985e0d90f06a7661b1c00bc3cd24a46f2f17557d066e28531e390bcf1edf35d92048351d3aef5adc0ef27fe00f6d6bc147454af2dbce0f37705ff9940a8ffa4c6b976d479acdec519c887970d5be40b471f3c5bd35b730720696ebdd14bd7c5bc19411f6e8afac103c73701681949279ecb13aa3c402880977810a7234cf16485cc002d4d9ce19199b7f912b956f8548f9787363e82cecd79a2d0884dd30424e6c2c9475d8a87e0219b9a746b3bbd1e83f540cd1c4b3b29acada0c7583036fe59512b8650cd00374aed6968f18d1bf222c16f5309009aef885496c82124d78f08f77db4d5c9b7a4cad011cab4412ddb1f639623dd141ea8a4d56ff8ccdfd9e3bf12f719b329a86d9c49fa7d657378828b7ff3a24e324e09aa5904275611bfa6a8cb893fc9daa3a75f3016d566cc7da36ea1c7473e4ebd1bd89f7a3ecd213365534f1d9e08f482d9e7a2577fdda93660a4de5d5e762eb0521451f91e7d5af36e8040192ae625a092e49b1594e1032655d5bbfea5abe9d5aa3d0a8d8caf2cdb2c30f1806c91c2396fd51f6d89b992255bce2b33a31d6b2ec9a9e8fb194e8ae7b0a780fd429287cd94ec435b91fade79ce1cbe4d71cd1ad4c93039aa69ecd617bc1495cfcbee8d21f364142fea04b45b8d6418adb9ab2dcc25ecf3c93ce8b8842427f901c9e26dc63168abe9bfc36438cd6249762c90d92024dd2bc47f62ea2325134c74d2d539c7c1a76c85bfb3ba6e9018d85dea3808e077e87337c6eb84f8ecdc12ddab533d2129f826a21df8360805d1c6de217c213b3721d6b7d08a91cb9785f499b67864c2ff4574e9079fa2b34e79fca7f74ab0371159fd5e3d368a9df7e130d4b2164f1f6acbfbb434b1238003f9879c00490eea90f7c8c3c3babb432207cd2401487924cdeeb4a09efd9f7a88acaf386340e003d39e1b206308a42a5efa9abbab175bfd5668ff5eadd28122eb702463c6a79e559df3cba1bc69e02538e3d917ab5dc052d95dfd764abce15e1fb1262b537e378a2bf34ee326407f9a2dd07ba96193646c19bb89e903dbde466a62fc73c2d489519c807ced446b915ca7ea0c871d4f1f7403d849926c262bc3a5cd2bfe50e8f77009c7bf48a339c06be08e58c27f9f3864f920ac27055adc07889d00943930d429c4d6479a0ed07f8d8b3770ee22572737d6a526aa5b67a4e4ae4627ccd3251a7f5ecec9c7a6a1fb912ebe79f0ccd7b4aa660db809a043cac86f7ccde63c4a4406a8e927226c4e72f935370af13b41673393331c0f9d8ff70b9152aaaade9389a87697184decb9ec6b737a395e60777a228926ffe21b54e8e9fc49ff6f0494d8b2600a27cee5cfdda6984fdfcffff9c8270dcfa7bcd0c71c5a5195a3f11c6544f9887f8e3678526e338ff01b5e7084a5bb7a3c1b3b055c8a085147f3a7599d6cf54018033afc450a0a9f54c40adec75a2d6c0ff2b0c9ae6a82ee32312dc41554aa6d00bd8a5a41032c6c7c0282433565c62593c7f9949ab29aad091fc7a53d5b3efe0da0ab5e5fcf7c518b48a308c6a8233fc7c5ce7e4990e768f0a6e2fe2d837721c74d3ede0b7b4d48c6e9ded83743a3f039e55e1b2c1cfd003c5b03c906a94617e447cb38991772ae8416412c8a4dbac91690cd088c557fe11249c218cb7714db148e77742e7d30dc04d61cdb1dc88394fefcd184a4488067da2fb8b05195979f49a0328ca0190ffd9e75478cde5726b8128d5661f3e34523381ad50309f79c8c42c509869d802de0efbd595f5e080c8043ce7678ebd6747728c9a60bde4de5c2171964e6f9f840fec627410f536787900d56db1f791beb8909602af155b3875d32778bf4f09e61ba31c84d268a7d59f5a0803996059984a07d19d2bce02c7d615b518bf7deea7ce11186f29af1867fb84d396127224141a3e21976c59cef03f0c84ab81f6faf437daeb19fbbd98a403751c07603cea4ef6f4dc4a907458df6be50ebe672d7b5e1d8454e620f313d9c88925b94957724b9724bba55f2bf7d419521b2008c1b36b13cba46cb4aaae2bba16d22bea9f42a8a758faf84a822d29b4052661da7fb76eb3587c04884e0b5dd3ca2a01926a36c5752920cef86444372316a0a1ded46346150fd0d9d210f7fdeff9ab0b9ee2b775e9af6036684a4d4292bfe23f8729bb5af3f8f25e0cc54df9747617a04df888d8569a6bc07fc8577fa420eb2fd4f8ad7dd47f6eec4e965205677f790cd3d8eed95b6a27068a16061c9f3aebd8414c14925eeb620a5859b29de66741cbfe7d6c4a5a90cc9dfe9ab9328fe0edfa1ad7f02f23d798b56299ef5ab83d80ac4e27cf69e6c402360b4550186f5727011c5ed5785da92c8175c8aa7cd6ed7885761def490e1ed658711133c671ea65b38307b91981133e0c0bc29e1d8620e28ad8d5531146882adc2baff180ce90150625cc4bd528fc6a02b98c0188e43b57194bcec99b24a52caaa21946d0ca83d6d8aaedbc55c751c8a8496a2d80ad22981906a3ec34e2c222347398f475e039d478ba14fd2c514cc4324ca3612e5d210dfacb5ef130004637420869ea3c7bde0dcb511b5349477ba2a8fc09935bb1925511f6877b7b91a62d8fd3cf2ab6e7d55db860375e6a5e685dd46ef9700fa310f3d6b6ed1e0de15c9671cb22c577c181ce3ee9687cf1d3355796a4c5effe667b2c043de5ed39d06e55c37bd05ccdfce26fc7fe54508976dc56a96511f21955c4a4b817f46391149c8950c838acbc1a05b7132cb58c9d3ef4cbde8120c39ee23ca28fd5eedc2ca35f0c18005f31452899b4ce8c28c362d33ed391da476714d3ad4337f46c4738856a8bf1ec5ee945b9ad8d9a5830473175fe230249108b02bd30a285faa570a90baf7ad297eee520ee885ae98403ab707699b3300c7e0c4eba99ad305ccb85c40baadf78c33422b8ad0fd4d11563c4b5db1c4e7683d0cc0f30ebb38e165f44d76622a3064d7d544e123d25445e6351c4e234eaee168dbc73af26271df9902cb2caafd0a1f72d9348c9e35d3ef2f108963384793555249ac8989160416d385d3203b546518e29d6c978d9c3bef5878a488d4883695a51465200424d7df99ed445472dd4f81d544320a78735e0b283935e942b2f6d22872a680047da94427e6d2b58699f2c590746b9eb195f2316812348038153bb2ceae8707e9c8abb99565c213cedd2fefa65d9f0488a07d3a9f3790deba382a0ada679284aa7276c5f5f455dbb62e944a25e30afcf84dca828af6cae55989a875130fc1624e5ca5096ce84967d6282eba02898d435c3779b84d7de044d1261838c7567014050fa971a3452a521684c9cc93696482562e8422c1e534288cea0aba6bb5f88fed11828787272e3cdbd81c48e14a10dc8d068bd0dd1daf3d645c06eeb07664bc7e48732a49d9e00984deb1856f2c0f218afe0b5b3db4127085329a4a958a1cc448f656ad483afff8b7e9e705be2e971c6715c5bd94b493cc5abe5d15106f80c8e7a01b4a58b0a7b55f8af95d9b5fbc49bd126f44353157ce67f38c6761ab55444ed5a58e35bfd9ad8eec48d32fe721809b2d3afb5eec22a884cf426b7837bb9e03f6f0c2b6c2b27c080d3ad5bbaa5beeeb29f1a0982626d56c070ab954251121c6e4750d33604fa81bd9667e96f0e94f060eaedb7942e891806362c7d4f28211e15a64dfe2fba8e7d18881c2393758d69467995d2ec0f6ac7a8e97a263590c010dec60d75afa2afc14dd8c42c8cc675e574ef8e1ed0b730c32735a1ebe46440359b44c33a1ec3c40d9bb5240235047c1972f30f10d8a1eb6829cfefd7dad8d9666093202ea44a505c85addade2fa39e155d6d909906bdf8a6ec085b58f205c719e77280c745ac542a4d6365fb5f34eb40da5c8096d098d1eeae4649ce97b3814d12fbb3a72c17c5fec39178ee29d2f26ab21b847e1a6a347d43e5d1bcca3756c19243c1839463902fc094a48fa412a01e6ee7cd47d10af7e387d693d57df61b4a8669dc9ea00a19e34cbd7e2c7c97e15133248e0ead90176d398280f5d23a81811ceab900b6e5fda64ca0b10a657483a6d051632058590ce0c3aa7fa7ff79515d531e3ce6317e92d3bd0dee3b963231074c2306eca92b764370ebeed72f84cde3365e81c4235ad0abdc1b85612252f1810975320b0ff6313098d7ba0076db7374051afefbbeecb0056ad11bcbdf2b9bb2c37b15a345436b5bf24549b563782ae41a6b771f7b16565466f110515a683b2aa57d88e7f4361e8dfc6bf6e6ba43e9f4e0bde472d93ff4926f9db3be2fb500d1a5b8182665ff7fa4f9d6463e615721bb3623025e4281f19da628e441011412bd4f6c1fc27b3fe79fcc8811e0c1625f7395b3755b36a54502aec37f081158fca79d4ac02f175a3edad0a1bee25b91449dc49e570f576902acaf766697421e1cee85eccf875ab51fdb1316542daecf4b86321baa9a02e45a6a705b0ab487efd307edafde10d6ceb1ecc7db3920882de84276891ec129e86ac0c96f20d1ca9c748c285f508a17fec051e64b148ddfcf0c90ebfe5a89df1e7359fcc3fa7a2ed113a717519996f0f30b3f33cc7ab8297399a5bd4e7e4a85154206d69f47511c3561000d51b36feca85422638b3bbcbdce3afe0b42ea1a48e7abd3845141d5ada58e8b08f30025920749a1796bf3dd3dae7c391f01a6f9d1c4da121b4f32f6591f94647ddec4f2f9327768065466aff66899bb307749eee23d1efb612b420fe18535494177eb33fc8fd2a274aa609c566244bd31ec41d00722ee80903825ee7597fd5bd33422b1460610cfd6ade9b14a027363e57c9b1b77578fd160e0f2da863b95500d90a24971afe666d69492194fc0a90443e2232d105c6d663fbcfede51f99b000a17890a2015fe7a167a585d24f4d8426e88354e26c78afc22cf4fcd50fa89f47943111081c8bed1fafde1b63f53c0f3989e2f9713f64da1f1ace47b9ea5111f962d6935a7ed1e982b7e9a56428605eb95ab412b903eeb73db3ea01f423196100a6f41f6eb4b3195d426fc577b6ba1ac7d8dc67909136af52c395084711de45259e056cfa46dd0b0820dd8987e5199e7034ec0b0de3a9805c7affc918ab50fc838ae7dcaa601efd94f0e5e4d9ac8f9816ba8d1b785389cb3a40d873b9a5c97a4e66d43a8eb15a7657e5ca0fd40c98aea5324f525b3f5967a862872a7ba61b9564f42e774b76188f0e01ef4be68f9d9fa412edfd21ed08bc5313ea8e4dfbb735860a5cd1a6b31765ac1ad781dfe4743651d1aac8a7b0db3c9ae674528a0ee79b25e495e5b16e4082bfec0541b0e3f3e24f7949a05edbb74f570299ee4b1b9e6bcd0cf5bb3ee4b236998a8a2fad6a2ef980c0952ad0a48e7467ebcada4a5c7c2e2cfb4be72ad51b69ee18c0ba4ce97567ae9970e2df429fe87df32a2b4cf2ac968f56306589b680cd5ed8edf7709affa6061c7732dc2c7b64d0b91cdfa13df33fc06f7604f2b22f68e508d658f8f3fa9d1be8f134dab0dda5e83f73938902299b6f2a15803b854e1e3e78622be5a14625a80b53357ee8c86ce47ec50e13935df1731d9fe42709935cfcf0f592cbe5a589db1bcf5a1b7e5374151fc978583d7dd2073977785b1f8ba1dc4132277ea38639164d068b952e5576d98f618788129176860cf3ee44fe166ee9fc61fc1edc796267c6e7a3ccef329cfecc83d25b5471d11e73b9be9f5fab42f70c0d03dfb546b449b6a372d03edb07e8dbf93cb088cd317248de6f6acc0e5481f160c1af0021632d46c33b5a739b9625e8eb23b818e8cb95dddca12d2c9dff02216545c366f4733f6738722961e0dadf730b0bac048c8bebfbbb540d4ddcd4c32e2538e03b51688bf754170af3ad821812f4cfc90ed4d3a3fe8cbd6978f68334ed9d61831d6cb076b24dd4be8ec06b9ebc041fe82ce53fcdea96aaf403a84c70483df070c74fd94510cbc4bca79dcd932bf118a065fc9668acbfd1a03498e78b099d19b29a83631daed86d49e5f637e3cf82c4083be792f98dbd18b560b7d610ed85ba459cf5e88decfa673b8e7fae4511e3228721583061d26716a92ae8ed1c40bce6cf337e7dcf395ba5cec04cc3a073c04d0859405beb3aeb6292aff86d7c55a306b4edc937888b77b40dc809a46baf14afa6bad0cd82185b9e7b136999111dfe8dd6df6cc67eb00efbe5cf923ccda6789572ce4cad879244448c3b7c9177cce60273b62584996096e423fbe6a923ecf9c74456000f39df8338d8a291bac1734fb43324b5f19a7b2727bdff85049f5eaf0961cceeaf851af3e1c6ad97112c09e06cd78771ee40dad3f7fa89d699364814e76bc1a1ffe82023ff498da0f6f6499f8f109ae6e540911aa22e7e7bf4972746ad8e365b0a17486ea130939a58b379f3e4b384ff2897be27b6b9369fdd12707a8af50ee7b1b653085d9ea2396ae0f26d7453935c7193ee39f2fdd7283f795561de56c7b8013a489985ab8cd2f50a0e49ff7f0adc9cb7b4849ffc06fafacbf180fd0bb85b717a6043521317753b589702203882a2e356be11dc0a5df0aee118efc14994c0a5d954ad910bdd21fac8c20c4c0003239ce243687e86f6acdfb9614975c4c7ee9d9e2ed705aab35cb7d01d666189704e899703195953ed42c9d612a9e3b2b2af480ddc5f76d629d97b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
