<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ede9e877906085fd43ec07fde76692d503f483a0c4ab383eea744e2f2b65d558ecd732f9034aa2fa893127033db0f22489f9c52588b6cc7e11cc358dbf8e61e0b033c8498f63b5ce28ade8981a172de3728fb260a30031b279252cf652d1d10692266e4278f160190d6d1527a9d780d64ecc9955c8a287712fc6edeb1fbacb1e4313ffe7ad7d1450838691ba6813b854bb099f393ae20102da7af27f4cdce5a2e4dda928ed831984ca8ebd3884a4231f024100939811ab3961d315d207bc30f955a55ae6f2d46ad21cf3755d580a6088cc5e8a3901125e2e959fd244557d4b7ea921f9c8d3ae311eef74debcb4f857e97f646c87d08aa5f88ca50ec1c12a9506409f5e810e8078f93547d66d5a2e1f64972226b63a032cd94a5657068ebfa54f3cfccd151c305126da0a4b7657c1c308d3d97d23ff4690e5d748276412a830c605c68023ee3f23279e7542fc14db52d86165e9290e7521dcc41ca49d6be2667087092f3737ff7d8179c08b732d3d0a1bd5a66cc008a649630bb52461366f3a7e4f79c7c9b8a98e824239d9439dbdfa6bdf5ab8bdf58fc8c5dba3ae073c8c5056b8f103a364453ea8b618e94f8e540e8bfac5e98ec971fb5be2aea6dcbd3ba564c2e76a1467917bfb63746c244948690bb691fea406c1c925c8ebe0434bdb31929906844f2d2508f3a24f533df8a63eb3d0e0cc99c898495d967f3927c424c640bf4c31861abf0b45707758f67fff415a533e4f1e300bddf5a7781edb5645914864403f420e667934dbee9fabc6023d2866d5ee4a799fc410c9cb536f13ac7c3363cb97c41d0f3f5c7e3a0497222acd4dd96b9bde38668bd9995216c7f6f22a227c444eb10894ac2a1a7fd1738bde9cedb80f1a5136edc7d29fb047927cb4f7015e6d30f55732d13c1f82c0ce4da55e90eb792b9fca4c274ed35d2f4c46af980982fff253f07bc05423578c72d48fb3e4cd117a8f951d2ba16d081784d317ae77a0a110e7cd46a6037a2613406d8ec914c6cb2260eca6a17503b96443f149453de0443060f08fed7b1c73e9214c7f4980c67f5a9c5a42ae8d954db14fe5693f09c423d77e16b151234a6ca9a8dccb56a24cd1effd9bf69ddfba3b72470bb42c3f200a42e95625f6d1987c2175a271064a653e356c2fde7526afd25e5d7706a8370207c7f54b7619b2484daabc0dd93c594b78d37b60637336acb2a3de49bb8ee2b0f3456938ac97ca757ce2cdc10e47f307c5cc9d83850c119db8fcace880caf0b85b1ec32120cd2d4083786da5f7aa98e5d9b3b0012dfc2026dadce1dc2db2ef103df585cef9f5057d5db2c2cf9287ec99d193dbcc147420b5103c2bc3058dd79131beac64e245ac5722294e64b0933a84bae895a5334bd70c8c024f8df8645612b3886f55aab800e5381dc6b7cfa478aeda5f1c07e80d625f8669fffc13bc14964d0998df89101a476a103527b2a037182e7ef8ac6c028eb227ad4411b44ac718c815fd5b2325f205eb738b3ef180adbed4c9738ab9a55296a26bdc275de8997a1b301916b780b138131a6a677fb66b3deee72c11a33aa30f16f6a1b90d9e73dadb5473f5cac8aa6f77f2e9a6b33ffb4cd1e6cbc644105a3bf8bfda210027de7a4479c93b7f0cd8c60531973e384d57dbeb31294cbb74a45053493caf96c22f8fce0e8c7a9943998d43a4527c4b36b566f4fac97eb611654ada26bb05719dd7262557234e12431ed909a1198325e586665666560e302a38c2bac82d2960d3ee51ee7cce5c6359db53a8f8f5c0c167069289dc1575cb7f8d4536e3ae7ae6fd1702c6e17ca1876c227419f859ebff10b25a7d1927984d63b28869655a2e3bb0e62c47b0679d9ef4613e04565682b7107de9a2471166f477e8560ccd910866f5f5eb8fe4f3267ea2f21823866d55861b3330d8dbc6fad97ac0f1f4ea1524ad3bdaa203e3f39a6fb9e41f90f990b61410ef7afa9e1a7703fcd06e04995afce149567dcd832685f4f86c5fe2457db6288a22aa16aa60a76f2f0a0475722253f66cad82dd88f84d850f6ef06a6c583fdb6619ebdc257595d217b365d8dbd7bf7647183f2a2a75da5114053dac6ec994928c5b804a2692854002b918088662b266f5f1d83da938fc39773200e6faf9eb398969ad5f3d1c0398046e4226051bf40f216aeb6752cb3fba34a9d21001014a20d52febf4150b6e7add93ca43aad38da5ade2e409993f40e92822c7b03c674f1b4040a4b4e6013e596274beae776ed0237e106e6d8e3e88c94996723cff3a069cec57b76d9f56d12bdafe38bc08a6c4524954f182914217ab508d2969fb8843fe171c8950675c0b0dd8851e4fb7ff79367aa6da6d90b7e9c9b9a0e6101516845b48cdacc38c7c1aee45b27044e5f0c212a818c5f38befcea24cf3c2782cc7fba0d0e0db69489376912de8ed8e3754a53f1a4f1da6c989239d3ea7f5a2a9c8c4c496c0eecc31875db200c3f2ad266aecea9c93990ad10d8a60afb3735c7d8d8b56550b435d2345885f9835bf1df7c38fdb0c79485c24a5634bc22a95eb8d7ae59c980a3f8b68186c1cb85c0d3f26ac76fe6c4e2a751e54868c9015dabcb19eab8e94b4b1601f6eaacc92b797949b86c3d1e904aba9c56b33ed8b1ba100e16adf3f77af0b92943c45056d648ab0c9cd05351bff99cdcdfcf098af07068a41690733e58358ee135902bbb5051fa9c4aa90d21dfc57b291ccf8848c6b2bd9da0201d464291cc7eba54ea5722aabcbc268dfda26bd94b17a0fe1820a0cc9bc4008201ba4aaf56ab407ca994e39399df884eda6ff73cf7aea83c497c1eee32fb51e1746b13e20287dcf995c5be66a279226d654e183b24a092e7b6e41e742cc02f57243460de678e6ab8de1626dd48ce8082487f6b42ac09fef1b416d7f0ab572620d1a71a7dd97a9a8d3d258ea20030735d4e31bc21a10972c4c50b6aede4d4223995e2ea1027105cff0547a8103b816265dc09fb81ba2c7fb8e005fee2ca0b46697a7c274524bc986fc141e964a56f6c063a12c5950836277aad82fbea5f84e8f805b17c044450e1e22c0f67bbb7b925c4078f62660ef0caa00d28b6d03e419da70394c73b4d8b1fbed621821ec88f2ec52ad9b30558557a3f2133ee2dc8f28cd2f9324cd0c48e33edd559b755db37c1088d130698dccd807e81345889c78051bb18f11594ff46c1dffdb94320c032ae0186a888a7b2c46e6cf97a439ef9749e0a13cee3c104e2f923404dc66856920206ecf772e00ca4f69b8013852a3514cbc5e78f8d3ed069c5b44c9c48b0b6a1046d612255a4582234aa01511861896f0e1ff7ad0f2238668cc2a041d134c1b76e617a2e65def3537d8a4bb72ff9880a8812d5b9935758479d0e41f4928023303a59612551037b3b12f176beeb893df8295e6a579417fcc79baba5ee9789371de7169f1a01631b60ac30322ca6b8241c874e717f3139b2e0bc4797d92fcb149f30c4be2b592e3e971f91a602dd994fd99504653e75fb4562402fe411a972df7562f9f6a7dbf872ff1dd47b7c22e75af4df9520d021d8bcda3748a0a06ea6da12cb254c9bcd060ae53121cae99da20175e2eb07cdd742fd36b65cdcaae52d7124b5a63a45201c6caa58ff733dc4ba0261c986cadf3feae9d27fff396b6e3fa1dca61fa9bcbf4c84e09637b7d1f7c835e96d14b8bae0de14c49053aea711265839424b391170a9ba4bd0818c0f85c49fa4e4436bb8f9ef5f6e6de1187a0996f9d915140d13c7ad4b7658a2959196d8dec11ffab20d6dc34beaaf78ee875928b470b319505d744f9651328d7e72ab5839ec0f9732f9bd905abe6d7eba79c76add21997e80053174bdb5c8351f1c834c3436bf035e0b299f72b110cf6a1df651efa2ae748736ef90040bbeaa04afb912f24a1208a4b9e1b2d18ee966d744f2b00f9589ee0f4a9071188cab60ba255036cbd773a18e390256b2a14326e54ff787b905b4ac4ff6765609794cfbc4f4290d76ca07212a4eb6e03f7fae499826ff91245cbd713e7eb843b86a1a8bbf3e5826cf5611d79c185b289efb1fb84d7d39720fa7b4fe434105c5bc6798730fac879d319617eed7fd9da8ade82892a0636b766ccfd6c49582482f2e43f4e272f7eee5df469a066872a0579169c9a413fb1172b70446115e9f056c62d0c22c96b87286ac4f2f223aecea4a876abea4a0bef69a4ac871adeae24948423c50d57534d3d5f15a3fe0b76b73277e9c522698a4534dc1fb4f1c76337ffcd9f2b7c9308400a1e35682933a1c600b253f6d7df112be4b7e0804cf3e5359d77a9935634b4377f86a0c51232c3f47f87bba581e37b6053eb95c9fe60e5a578d31d5ed534cf3ca40baee71d213a3875f07a750dab34e79a7a4d4ab92317cfa6378f691f4143e191db459f807ef25b40462f1aae994b377103eccf0056e24ed155886db3084d9ca7adea3dfcdeb0208fb727680e07a7545ebe12fa9a85b2a965c3f4e920ad65f2c38abffd4689c53f6f4e26413b496d1ab7b290d1b27ae18d57654ea6962e80b89146ae0e8a8aa3ef4b0ca584531f3e9d2e7869e7d303d6270473c9e2c82d5f41ab59f88e1ae2c72d753d5209764421683c257c5d14437d7fd542867f78de0f4a75fc69f41349be4195e0c598810a4116421de9b66a4467f9a6be9d8982d168e9127b347fa716a4fb869d0c236cd192c3d445beb445fbba9a57aa80045b493dc3d59f13c1c0e5c1e4f0ce4d139d39b4162ee4d298fe0356414c4025ef3e02e3aa2f1a62aec32038f6d1cd7e953179b7a88a2c1bd156fad336dad005891db38f6a53e90de6702c8b493339a87391966f8161ceb979c475e89dfdaca4a5ebde9375294152c9cba50b3ab46a057c83bf75d51a203cae10370f97e4ab6b6d5816e85b1491c3d283879c5e5e530869a263a2ceab1ead03d53a200f683907d4b6b3c91a1f8550c1c28a64539a1663f1ec40e821ef36174d6c0e7f983c3d563629087c21536fdf1d8b121163f9f3b6f18b8a9fd469ca8c3141f81583f9ac23b85ef8227065d29d7bfa8df0d43016d6bd7bd86e57052c9eae817af385be0bb0fd5d1a862f174c7b8ffe913e14201e585df5ad3988d65f0ab40a8f9cf8b3397c1c7bd86fb2819b02f6ef8bb56e935e14f0040d29e452d3578d68bf80a4551be3a3e79a8285cc14d9f0209e6f5c9be02325446b61d482e8d2e35f046905f1e3a87232c38df63e1a6e58a48f50ad8d2eae92fb777f7c23ed862c5799d31b1f79d14ea22e9c7a80260a4c81bdb6effcd876ec2e7ea6b728c904635146fa26d44f8b6abb75f60706b82835b9fc49c52710646cb30d3b9fd1caa29b35995f09d933e2a795be2ab961d250b902e059fee54ae05d8f15945e2c9170bd17182befd26207a4bfc33deb4efcb40d0a675316f01be7adf8908056cdf4a06cd57ac132d93ab762c8b0d5fd3032051f5b0f754fd653c1db3fba95c519a951fa7003d709ef85a4924dec0347dbe6ff3c7a8dbe6fbe221ca19ad895269d43b0a2fb078597dd48082d203e9950c310d7043d2a87d9cbcf0e68ce656c571cbce3335e254ba312487593cd9796cb80a37b2080cb9957a17849c810a6add7f71f3c218671eaec8667aa22157761fe62bf848cc6da45c3d345fe025afc78756b9d8f897404839c4801f5cf23f4371cc49035b9e141f6e10bffe9033fa186c509d71463edb1bc1a71cd74c17b0efd93fc2197fccb9c1f96a6f8b1af62e6e8101698a15e9666eee9ccf5e51d6cf35c88da5b1980fb109b0f50ae9edf128f750e5397014b26f8b477d191e544b15fe66c273c5be8cc619144567818669e0b89a7cbe8db83c0089802794830cfead2a3dd119a274fd65b42f43bbd653edbc3abb8e2f3699b39bf485dc6fea6d505ed58793b8dfc6a92d22b4a5de4a30da47568ad5fc8a7ea43ede739588b50b5ce950be57916f3f8a62be77c5f334a2dad6590c44ad342ddf3034034f58d9f8db4479809128eeda9fc18200934ba3491f8fb1e749b6ee239294881e198c0bc9642583b8b7ec0049e7ce50006347ad6da366a223383707ec5c28d9d0957a4c95f7658c4fab1e2b514ebe4b61e6189c0c8716d0b0490c1c7324cc87d3af9680aeecabbd9dbe7b74a38d98c16427e493e6d7305b1e677058adc5c6800b15db193754707ab496213af96992ba6c1a63db0c6934a9395190b432541691ff4140da25bc53d9ab5d65609fd12d25b03816394ff2b28280c6d5f68135a2e96afcdfbfdc74460d45c40e176dfc4c35f996656d134f4e6743e6448bdeeb9913dbd61bb38b8a24770814d823713d93e8c04b4e767e191e181d67ba7512ca73f9943401bb78a2f5de5924e865ae7f697a974dba9a27d79c81e3e37ec76f04daa1344181894d97778ee431aae6a397c2707df003e19a2a70cf627cff66139208643ff2e545160ebf361dfac95a483127732f067aa83f6f9ff2cd61f6862ca8773ad104a53bf1522b6418ca8709381cb5e09d0ef89af8e6475f1699195c093e73da28925980e10e33660f0e191755aad41936486b07edca9be0ab250a8caaa0973eb105e9ee21abe478b052ac0be0cddc76c9f494ca28bb1e52486864e7cf3cd3d6d211815cef2175499777abb7468f27e70f5f13f2975f9a854dff5218697b31017ed4c9f67abe36adbbe5357956787c0c172494e040e7e2820c952fe2219f4781bef4ca1561e717a4b31a54db52ec2bb8e7d3de849375e8918005a4b4d58bd644edebefedebebfabe7624154f9e5fff8e0622da8220c160e0f110e6b8022cfeca54119c8bf092cc347185ab9d6f672bb52d66ee5f774cfd6628382b9c309baa6e2b54d15fae6523be34cfe561eba8b92e70cc4ce72af71d1765fe2c5218255a99667c5cdac7cc5a11245cd9d01c06e5fcbf4dc5ae0a8cff581988821e3714321c1bb02882215d71de8483fa5015ffb243b4a7db2d61a33c36231ce94d10411d0bf4e4182359024d2d308308a64cfcaa764405642efc944dc469fe662179c24985d490fdad62f6780aec7e7053ec1d20490ae42a49fd016d0265f99bb929b1025253e72f44eb90b585a93cfacaff607cafd22db71395df2e7535608931bcdbcb2cd42ccfa6a0215abc4252012407c26bee31686c972530d6bc341adf39ee5776423b0db3d1aaad42040a4494014880a099cda918c2cfd6ecfc7e1438d40f6aa198c86ab41c022aef24f7927717ab008e23adf6caff1c7f1d6ae2fb385b5c50c3fc791c4e082f6af824dbe825580aeeeccc5364e4086066cea898742dfb9f5de6e11076c7720c9aea12b88997309255cb4a78ef440bd6e03d7166ab48613f0fd6b78e9b7ec24a9464f40081d12318f2eef56f6bf273473b1ea0739deb0fb1fa72fdf050e1125efa5757ac52d90fbb35a8d66d326ced552d9f6fffed5600cf104b4eb7ce1f0c6e67397943b5c927e406fef616726255a7df35176596b7735346623792f8895e7bd437aa04d49bf533d3f92da04e54c61e1404bf0ff928870b1e073122f5f4f31a0568a6939c11b8d9c2ac637731429e11460b96ff5825574ed850821e616bbcee7282d33f57e1d6755e873f6ef6761395cc4c6646f1e53a69ecd9e9ded588821412a03736a771839bb14db9ca5dd34e82ebf13858c661257d686c5bf4074b7761d5c563b42728298b78dd2a3131e9e303aa0b11e0590d80fe96169f45030ad28c0670b7aa070ee9d0172a6c9a95b7285b6a787116443ad110e47c2d7becf29f920aceb2e6d1b7b1378bd48989a8394f78a138dfb5bd37a8ac95427524aa760f02f3b0da44f6eda6585d8519e31d38e7f669c8e7d0745c7438ba870e3737b60e1879b9cb6fa486e387288cba2b6f84a0eb10ceb23798580b60456211aa87efb330cc9d012f749c192178ce1fb35e15075f0896b0b4e51f7f8d25f0f7e406da28dc5ddc43aec07dbb6a551df149c1b6415f093eb82874e166fbd2b25a0773a766ac5188b69b39ecf54505425c710970fecadd5f13532680a92622d8024d0ab5cf1236549849d54576408f5aef48f4d2568d0116e0a53451d32a3f6e5138d85aa299fa324b6ef233a7ddf9b298074ca52cb2f3f37653e6007ee652a396450fb359507a9540e7e5a457b29fc70a63a6892e4a065561381582ce06e6b3ec18f44a163ff26d6bc3255a85fae26bfee8937af87dd13242dcd731cc561bfce837801240ff787d6ae52b13690cb3c67f830a66a9b975bd556053c073a521f86796f5179afb8d921eb124ff66bd84d3b159189a0f4521fc24fed718b042fba3b80f34a0d7d4d59b983f278b8c836f2087eac6443d88f7271db069ef730d5a0b3bda1d02f12b473aef01495ab2ca03931726825cef13e3a6627bc6e89bf8ae154e9f51caec892c1cd72f394f1ce439e18454773b3745664c255db3351bfd58a88bbea484f278403f38f0f752707d1c31726847a5ce2f63af56573b33b4ded0579a74c9c8acde0acabccd55b0daf9f25ac73028c3fc498cf758d192064688ce28f3103e06942013c536abf9bf61c853be53bea746e93a1b7f63e50850b3b7844b384385b0c6a96fc0c39f9fcb7fafa552680dd6d7fe9db6bd8afc16b392eb9fac09f5ecab45e44a62459ae9dd2eb7358c0f686c97b151b93db81e9245ff81041b3f6c1a86f8c769de9e6fb41d9a57fca22a6eb46cf33a5ebe704a50da7ef3f2b64a963f8b0cf63194225fbb30d97652fd277f52a3fef10e00562fe13ba9ccc704f6d45f2eb7524154dca46a4e753ff1a07fd35df9eba98a8e5ebdb6ca5d1a7945615324c4fc2a380c048ac39dcb611fbe34b18ad0045b98a3f90f08b19d2286c0e001965798e4266b527240fc4a8080fb2fefcd15f36ec3bd54bbcf947c436ea645f1cf3f7b39dc1d9ce14f406049725d23bbf569df8fd43647b9f85261262505112559ff02ff5a48a4f5450d1347ab0d2b8a6eeb166ba61032f5b2dd7546fb7a3f2c4b290df043a5bf564715de95354aaf3922c9bd0e1cbae07b01f7cdc247476ab24ecdbcd76f82b15b6cc63f3028bbd39f6e67645fd2192003691671b8756f87af2217345cbd5ff25335b66874b7cfdb93d338ab6e739838f42e5fd59c85b73fc8fbc95ea26c3592b6f57eabc8783777b6589440935abba30b642d20102538c8bad3f59a4a4118d3ad412999ae0f3e2ba1a0878503064c7197e738af56357c72d5d74c06a5a8766bdba37a5cc25c0314ae968b1124d3e0c03efc9c9862f24bb74574dc55b2ca76f1bef259be2b39f706f7cf711eb36d73136ce8d0571db34df95f6caceb70fdfc4a56dc9840c9ca3bab6c2b67880aa03e18a64f52688facee1747c7653b16b6af0d74f8c34d7a20071e1de2199d47e5da335296fb72c4bceb84ee838832639e1f229a320fdf8fe34da0e3ad3968c03c8f3058856b9acd2a05a5533c6bf5d9e9665082a5946aa901d339dc636c4f7d0346326e1b822279738443dd09ba084bc39455b95a41c6745d18ada177ee7c0a747b3a3cb05f86f8fe0af6ff673e779f51c5306623bf3bbf2a7c1862617524c4e71725056cfd05799327df867e694b648e7faaddc8d3af0180ffd1f66a17ac92f47fe49e50edc05c068083feb874fe5b84d79bbbbaed70ce9b803c0e1fc81d19e4583f58472a9155b416c0ed24fd3bbf0eeee534c2ecee40759a94f756f4a7d01d28ee093e4bee61b4c0551c190376a3826574949234a9be2b9ed2225af390a396795e3f9377f34d04ac06babf46ee2e446786940871d4e1dfc6ff92442dc25d9420dbe0c26ab2dbd7fa9ed5b082b2a5aca5067f640fb639da1fac580883e40019120544de3f6565ad13044db5044e159b3fd2b4ebe00481b38746b9ba156b87f9356ac61e457af609790621302f9b74a741fad526e8453b07cb3c362cfd679117d8b55804c6cf1de959256b3aa2904d14108afe18bc60e55a4f9910cca5cf958fdb77bfa329ec57265cbe6008edffe796ba39f53305585e52614adbd9ec2fa353c26428bbeef00320fd1f0f10a6a70adddeffbf64134dcdd82b3fe291f9c69a0fa9aa61ed2db4aad7936263c740a22d728f0275abfe471ff6cfe1f839b86b2ba02bbc11dd83f63276812ecf1382048d4ac32d948c51b7ae559a1b8d02e33121b9d00aa61723b9d03f58da27bba3c349edc57d71627dc3453dd68584a891bcf9a096fa4630dc0e86bf8fdb978bda7ed72d159fef2398b311bee289e56d8630fe45ee9b54bd95f2704604f4a024f961433613647f837f58219801f8cf3852a5409be3c32e78d029863b421e006b95348254d7548cbc0feb5fb91bdcbd97e9ea30041ac4c99ea7f9bc71526fd81cd743a2aaba05700646106e678ff6229e81d15a950782707ee15e80cf7efd47e85300c47e49fd799781182145cec5af01976743168f517b87f8dc628d5ab82a7bcd49ba0c8b865186c43f7eaf80f07d8a5e840dd0c1dd42e3a134407d2757dd100242190cca984b8934a881ecbdc1f9f9cd02bc2824284383957638a4d960a7e812838969b1bbdbd016fadf6f78d71a13d0241525be53f946ccca00b509505ea657e9b9b5f2969285bf9cf4d5ad11d29e3c00dfe090dcac3b3f88cee17badeb79f75bb739c78b699e089f12dd65eab57b7c53fe8466c7d10dcb5947632bffe6cc7e1977b772f8c81429f4d05f2c4b4c8411d19ef8179a22faa9a7e404bf47b23c2a7c193da6f47e1ce63e6689e7a3d5c4008e6cfc49eae2d39e765efbe6034c0441d5cd874862d4c0b9e96ad1210e23051f0fd51ed2c430e21ae83cdca38086998dba7710e631ecda79343675c2adf24390c6712d10a455e6b1edd5e187cfcf57ff321c4b410141c76885eb167f1d8a991a9467ac5d43579e27ec9a5d6f89997793ec306bcd84a6cc260e32f96191dfb68232618032a2f2c59d19180e0beb4a341a5eacc8b483de572dbded0f53720a42c7789bf694d3677651fc42814a401826495f07dcbe3ae47c84e443a21ca6937643c63e3d2f5346df08bc2df0bd01ce4ad2e75c5d3c9322f7c1cf53a8cf4979292aef04e44863dea6f476a42261ac13244b7c12ce0963a70ad3877c184ecde9a0ff14d36838b2b33f41b23d326afb986c31a4bd8a148aa19fc218507995906cab935619e9a0324795f85c2c94451461b85075d846137a817150a5be07923033847430e47e9df3f36860ae03b539605a5b60a3bc25e53bded9add99a59959da565960e78111dee816ece35b053504f45e75cbef8e2ccd23c36786f2a073a438ba68b71feaf78e2a588e79d89a86ade7d6380be276093a81eb148805fd345a3c8adc9c7e68b62b958e00702af0c48d3857adf36943208fa51677696058ff87177ba65548ebf74b85307db5fbdb6e45fc4127d219c98a3dceb30d396838a2510663d24f1a182616a394da3c1d7efab8150c7d157fc2d7beb375cadfd00a9ead29e6bba059eef1b86ab1b416f7a11e316c10339a9b0fb1b5c3846b500d336d60b16739910888f89214baba3159d04e4d54a8604e0549f3069b2195c676add843028cbfac7f2b074cb5fef24d4edb85059b198df5033d0f5bd5ad5b305bad9be969f159481dcbd64024278fa4061e8e6d847b6da62a84a47af592aaec3d962e17262521f154301530598edd310e35c20f8ddad77193944778b2b79b626434b4629c154c463b4563046d6dd213d628c19db94c3f92ac3c6c6d4e324d19462870fd6356ba1fe0138e6373706da11fa10adadd7866d82e0d9cabd9d46c8045ee2230c9b83f702c7b0a623749f90bba2fbe7179abc4d95a76368c022289c0f9dcbe59714a21d72447c57f5074e4dc479bf948150771457b5e461dce561f1a741c2d62aa49371ba8346d966b53fe25e3bed89cf0ffffdb4f14cfdaea6a57711ab657bf4d52d3d7954698275d0c640299be9efc4e910b22b89e2e7177ac7cf26737a21437135cc951a1a3100f7883c1682c483f1b980348c81d2c92606001aab0a03d200bd149ff898b7a519024a3bce6d2718ae0a816155a33f1b3898c5ee07c96d8699d03fd1c369f983e91088abca4607de2f26ce73328d8cd88db05e4b584bc3590c476c5787451f51b56ee40041f63998a4ec945a137001ddad5b63ea9b5f0046559cc1f2f67d3aabb942768e76b329b47b61c1386837fd99bb8287798fb44f4c7fbc3337381b870fdbe8c1d3b47d48768bca6bffda17084958c37c9d724f22fc8937426f35debd6f065209373aadff8a1fe64f6fe81ee5c9c40c0fe56b9bb9d58d75d12689f57465e59aa20ad8d3eb8c6066eba06c3606eef130e556e43fa00e72e12f511b2894981bb4d72a8e3dba457a90ef9935b19cc0fd39223d1646fdb2697b1f5691a7fe56b3530306addeeb376b68111615994d02fe153bfb528bbea021576d9e7a1958574785c7c7047b503249d42b831a5e7c7bd45feef367930b4362d8bbbc26ada98d4eaaaf4ac3bad2ede23b60a8fa79f7f140737854724a79aca1fd0c431182c83243c7ff8acba45a52891c43c20eddaea146b45edc6f7e049f700568429f27993cd3bc38df2b14787972e8ff01c0bc2a8f3c2a1eca2c0e00413388239282a83478441b3113b126b45e4cfa231ae4c3630db9e0014744e1014aca9121db2096c715fec504f82c09ac147c8b0a3e31c5f7edc3337b92a4c33f999478d5f698b49094ed8036def5c19af27279d6383dfe550ee5517ef0e1a083c3f558f5c48a5a0fd18e3debc2fe805b3f11e0543991cbfa13a6da914f9b729170879e9d07493126b0ae92e30070cba0f4199d5a3aedacfa5813f6462e58308185cbfab3b3def1548e3090da0e55dd09c6a6a54830d3f40aea87cd665e0aa0e26552dc93aa6df027d03eaf13e6536e6e1bb175b16314d98a379fd56b9c5253a3ae556aa26ef738c7393fb716a2e03de95165d0415c81cede9c8a3b6fb0599a035ac66bb9f13c26dd74e69682043d7a383c6316b4d0566ff109d7e8ee4230d0119544b05e41729399bc5f4c83db3ae6af8f69f465a336754dc434cf31f7246f84e69dc619f83173ce47f79358ecd1fd146dc3f5ab90e93dc0f1036e869886c069e5d4d64209a81f167d9537ac62221b0e4fc230192972ba38796e354af01be8384d16885b77cc00d8bfcbdd7ea7b98c17816a13e1ed9e5008c12413b8b9775fc0d722770998574c31eef511f4b9ad8053cb50ccd9445a9115682b549eecb7740d735fffab66f7becba6811625b7eb7535186110c689f1cdc0860172c9e13df424bc6e273db0e29e99ca4698018c0e5a15ef0a344c2358a0c704cf90fc165b6aebbde87132a921667f60ff400f7e55658b335108c3f82fbc2a542995c2e6b2d5274a0de978e1e100ac262927e05dec8d3ccb1c39fe3a967f2f2fef0d1c9fa27e6836584ba46f010f724baae2847a9eca558a8932f544ac9d8f9efdcd8b0a1df858613ace4dfd3a923fbf924893c6ada4dc996579f2b2e3f4146c38f9cf154e68f66483c8c3afdf6b43242a437e80e0b4f117a613fb19258b16f6dda3779dc6b1021304bcfbfe47ec96d397692edcad17c52da6fa9620c3ee47b925ee82785eae7fa6beaf8a5794c49c16183e919b4843d0b38f2a8049da10eb634f5914a13c58cb0346369de7e4567bdf7dd9c587f488dc4dd5bda401c568a72cda1ce6058cf31537439391c7102c34f39403cb03530b4669292a58a6f64c3dad55a05d936929bfdd38a8b3bd61ed6cfbb14551484dedb18c23a3185a6c24868e54009028ae5c51547dcfd6e58bc3f9b63139820383feeee8c540743634a031894d9914ef367bc05fc000ad66f868a83082fb21bbd6b7cf8c8a9526714daee04e5a67a98ee2bf2928cd98fcab09f13af737d2b20abe06b4dc5118896ed6cfab419da57367142c55d712e7373072f0b72b77410715eb5db909e8194175ce8da27aaab84de6029304b9e52e30afcb4230505af3121bad95523eb06c0efdd4ca55b5724b2ffaf34e0521337cd8e2179cf25016b3d8a964712806258b33da2e64e7ad81e3dc8e557628713ff9c0535af871634514a83ca0ef904af5ad67f2e49aeed9a6913c7fbb8c627ac7e971767938a1d964a217d52d2d0f7200e3d3c1bc43cba45c1840f190e141b66a62a190f97a8c7c95ec17e98a4996fd7bb1fa0fb9472aa8e5c3a36991ebd5a75ba5c22283f4756f4b33d5ecdea40bc0ee99cac90c60b3012388a83b15eba0d18c3bec1af889d127b2ce74fff69bd4b2ac2882e6341d88f8c0c9e57c4b41906df767630ac45f412a23fd9028b442a938bce9f6ed449b4fa0406beca5427e5aee2e488a447ba48578055d7a423f8ff7b7875416c74dd4ac3f60f827f0eb76fed713e8874f576c8c58bf55e9ca23a654a34ab913396ecb41b6a6d789c34451ec6c20a9fafaf03908cda84a749b6f4853f60d27dc701e8a84117deb625cc6010aaeea93c2725113b7f269aaa11b45be9b6f010d3f3d387ab4abe1ee0c69a3ab2e7355f5baf07c83d9bfc1299c9d2b56626aaf4d333db76b3f5c49130b76f6fa899183cbc1bf98233fa275b87a15ab22fbee4859f5a54d65a6bfe5991f5509f17168f2419b49f8d7419ea87277aa6b614f104f1b8518798b8afb63991f6fa29a04d9ef20c5a4edfdbd1dbda2b2035bad8697b168c0d16f740a166b1e37c8ae12b916c755777054bd8ea09331f8593b58554e9b1b4870040a6e91b3d979b4cc197deb0645e5add84f6495564db9b9f9e120e2431f2a6c21d63f9064f960d29b7ef37709f16b453c4853432d549d900bc72deba431576a2575563ad32698010d8dcc89d7b8dc73e2daef3be340cede9df9bb06b75f87e10f4b013bed33c7c26a0ad8233546c2351ff200cf4301e1be127f8743004e64f7bbd4e4ca9a981a01ca252bd5f12485414629f7c418bee170751931d3971c8d23417e5f43a6cc31e5b208ff0a6fea834200e23919a8b2caa0593e881a4a442594f6bf177d1df3fc7d9862b56d3fdae72b6034958952d774de64e60f3bf06501c56c555d022ececbae54d010a928d57ea8ce237e88b1c16449f865d1b2ee7477b047ad87b6dfad645c7cd7ccdf2b26a6523e11363c91f30ebb754f85658df73954aa31791725a2daa0aaaa0cdfb13b852e7ef68393ee2d28bb671354896b8ff2cda350969953571546bcc8bea97327968523b615f5a2864cc8af30368ad14e72a6d7ac9abf46d7eed7dd4d3d476fbdfb2e71a775b8aa9d23c1e1e31881dd00cfef94481b486405829ad4f16da50d21a0704afdc2f51dee4ef95460efd3fbbf3618e700074b5f6d53b58e8f241a4bee0c304ea8b29f264282ed6211283c1fda1823151e3a752507eadb4eb31c1fbd7e9b020bd5e2017c031005f0ba59065f3e0aaac82339a6bff25f12eafa55a2e57d2324000d275a2521fd8cd00e378d00ca461e137c4efd2af65749f45fbbd15a24de4f47de3dae26ea5f265c2ae8f1302c0982a0b127d0fdff6a3b8e3ad3c9083fb5ff9400e39a836a0662261020a79433fa9b4ba63d8eb76a0eaff2b7817d24a593ad3cde7bfe0956f541c022394312baa7cdb7e428ed9ccddff1897013d27947c1f33151aefebd490216885c3255d3cba21e194b0d22e9ed4f6fdfebfb9a6c3d46210d7c9a19097991227356a87c2f566616bf7ea19e1e719f5a8b4076ea4ab2596ee97d9586add0f6e068c2c1481b88687573441aeeff41195663d7c559ce92842ade334cd3cadc423416c8c8ccb5f88a5ffb36c5b966c3a13e7522be870344ea53c7d7d59511c3d0d8f3a4925697ed7a24cf1c828e874584f7a13693c82b738127c1844e9d89b470751379a934844fa3ba255008667fd3a7ff3d1645d85b60d23304d9b7f97a943f4ab9122079744eb580f9ffca8c1140cd6fa875bf96195a22b8f35b0b3f1a1be66036ee33d20e93479d74535ecc223fc57e9e4589ec8099d4d6259d612b78bc31f61ca74d2a5bc08326ad4f448efb0cd659c0d96bbd5767d614e8bfa747fcdaa82a74f9819ebb08961ee60425485ebc845394def893a5884923174641f67a63ac95456c8ec8bc557f0adf2392c6277e1eaf9ff247eebf06809e68ef639445fdcc1bc8ccee74c89caa133aa6c0b4f42781fc418dc3230eb9eb70052a69fe2a099183dfec1fb9f6c3bc15a5c6f183cc8e433a5af029f11e0a75ce44f5ca16f6b4bd540eee3b2c47f85d9b6c55eb4f62c4d771e1151f7539de8e8f197f29dacb95202354f556d3abc09be24a8558a929c6a71c2dc53eaf2c5d8ea2a28742c3d349fd160a8e3443bbbd810cb5c677f4741261302d08701853e4104fadb54380c86a3f7afc3c6932e300be756936a00b487f94c09a7dd402734f0fd285692446c92504c14fc75fc1bc013164a75f246f5b6cc3d7debea51f289673e76afc7021ac70cc0ae291ae2b06519411a52b07f9e1f2f82767595a13ee75c34b6823e3b84ffa3f3be66938647b41202adc7054f24158f67fdf43fd8c80d159fabb51d8b2f5503dcb50ad0289e9871fcec2f03a196fd5cf14aa505805432fdda55dfba88700e00b383206fe03d5f0e1bfd6119063430c9f30592eac7b6e1874e38457d7c5bf3b7ac270ba103becaf34df39c5b5a7f5b787595f56bc01ea75899c9febaa4b46760b4150fc0cbd5eddae4f2d091867e9cba7b9b95a9722eb61227e8b6b53e8ca634a797d35bd6d75f78e4a9a5f1e73fde62ae5ef33e44458e4da9a1d3e09d620687ab879db4f57ee4a4e0ea7865b4b4ae1957b929dbeafd3e992c00b9237efbfc38c792dbce9a2fd90a121c8b3da867c64c699889e9a75c777015fdd20c77ddd62ee3e684fc8f77623cba9cdf5abcd45639e81e305897c119f91d0e9bfd44323fd5c1174922add7133f3f9a51039e2d20590ef3afa0e08964a84f4f97972d6b11da6af4585ddf7c307378850b693dff3208b0c9bb018efbe97ee3cbd453591e6fb0f23f5ec2cabf740c19710c865400c8ce0fc81add73833182eb8bfe6f64a500b79bcc56c74caf977a37f0a4843ec1fda4923d48a3bfcc9af837e7bcae5a427ccf3e18f166e814045a076eaba44605abff1e8838f5e3e57e1d47b617815b3e396689443fddd29b6f8bcfc6e5b8b16fbc9d24f0c8dc640624f54e8789a224a289f1558852b2fd913ed24e7816aa877e44f7f2f7e9b71c5fb78440d3b9d522aa9014fcc090fc7df677bdd30a635404959c6415b32eb8920405ce8e2ecc6df63e619fa99065094b46c5b501c96bb036417c27937956509a32853e98530a423144f043cff9681b817ce70b553d98c0b2ff65eebcb891810a8e209bc146884fc6c880aaf47dad4b659a34a7ff57036a6ae31b97dd55f2789e1fe58bf01626a9428615d54114877237ab13583459722e86bdec31a04a1bf12fc92748bb094ea85239b6a046860168161e84dff9e2de498945ee108fa228394adce9d2b7b714a4c927229d903e6d8c4f74d870c182b22ae345458933102ff671885ec4330e2c629e5c7ac79e31e4c2b0274d8b1e90172d68e7463298712411ade0b5909180570264483cae47a5bc3558ac3bb04db6201158e2ffebf279ee5be1529ecae498fa3448f7a594d070db090d689b303b8ecb3942fcbab1b58a71fb9ef31b004803cd32ee74bf78b4f267c003ca6bd7a27d649a218cd6a2d02d48cc9b38abee57464ca3b5128ee32a3e3c1136625402dcf53c3b64ad31c763acdb2b2823c1a0789b09885230f213a4009f4b55be944bd4d5b8d658a57efb237cd4e8c874632e52ff82d706acca4060ad86c8bb4663a6b19d0dd730c09063e156bfd9666b54c6989c1128df33dac391c33ad89d8c2f7e7bd3efe9f91d7256411074d6032793edbffb14495f8d10393b9136dae28a25185ed1191dfe695f7e34181eec6602ae9589b127e8ec75f42d080a22e450ff46e6dff3a96487ff8ba6b260d7e366f431517b4cd24ef25de0ba2230f8ea7c8eb378c855cf7f2cb87e071acd09485b1cc2e73ab500e04d8e4f9647d18a45be9582a4305f147f7b8f0eff1e1ee917772d671420abcfac00fd64d98884d2fdfcb01fe10d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
