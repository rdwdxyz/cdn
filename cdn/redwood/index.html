<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c453a524e08a7310da8a4fe2791524ee55941f1345e3cf234daa75c5a514adc4a70345a62be3ddd485c96ca861908bf7cc258ed4eff79d671eebd38d9b1f13413717494b5244162133e4d92200462a0cc8ae78fe8d43d85b0c7df71938df68d8fa4e8a1b5f0e41842c02582f60183380a940bd0cbd9f60632835a44c6306713e0fb10ba3c14a0537730fa162c452dba5c63ce67feb409f7e43862b47551e578cd70b7fbab6d8cc1e79c0e31b41201ea14de921e4905054d2763d71bb6d85f3d14a1e2a84c1dae02064abe1b95a1d2fb4f16182608a153a824aaea98b0669eabecb8fe074e30d40daee6b1118340b3cbce50b57c650826825730ba6602373237cb0637098ebf4673881aaec96942e9814720bdd93380891f3b0149b5b38ecad280f46d78d721198edbd398a1846d6f42f3b0e73148b65c72c52ffaf6e746fe8fcb6db9dc8a7f40add4ca9f4ef05fdeb39529744ca6d421dbb5ebd9040323897efec14e938cd165bbcd24f1d19b00b5fd7a9a1c0e9bb0851c3b90edf569ec1c214484f00c03fa927b07a0c37d54ae2bbc067c179bb070923c81c3cd1eafc3f795ab33f248aa12c48f1d31c568bb0b96507b640660617a7dbb78f42a1931f75d8d1064620d4d829018a29419830d848117b1bedfc45b748e9ac492b0772179f1e8aa0dd3b2b6c8b00ac548c595b0dd130a9e1d441e368fb0b574de8584580de716f81a055468b89f95007902adb4182e9753e1ca34e369dfba6f3d63dd2ac986e2471034b12232873a145a22846cd4ddcfa99dfc5fd1edac12e1a067f08254b014b5d7929668b8ab1c30f474d4e8c80616c70fd70b3c1f6edfcb0fc2e4bebfa7326d93f82ac1300bbac6a40ddb67867ef539a7152f517cd7400a9d26623dee810f65fbb3614abf8535f5db1026772be9c0f2af8c4744c35ded86ed6fdd21560425ad7a6b4845d9207d7f2751e6d48a108efe8aceea06ff4a6f968fcbdd5358564996636f7fbf66fe0faab328650e1b211160c8682b5ec3d5f9549703da47469fa42c274730241ccfa3a8f683cc076449610a638c4b8ddb474e8f3e18b402d6f66426f14241e81e8ea5e10416e35287aa8867b69bf74c68cdd6c774e3dad7a454600b771c152086a6ac501d968d7822f7e99a03e9d800e77407d65dcd95aeab980788e8af6a86ecc26c3fb1cf966e2de99a856b91340ba6dab5c0eb2e066ee4e65961b7fd6569975ae7fb8d9913562ea9b1fdb7bc29ae53dc22cc29912f0bf1b45ca519d4642f9c11c17afed1825c727ddf7247d81d9b13e8b828753f397737ba26af5a3d102e8a05396027fc9dfd70142b0e95e88447faa1b8a4cd5bad33bab0aec7c7a003684a856185a2269e8ba82527f252fd3f18104db557874829cbe2d8e1a1144ca1a48d98f695e4673beab8e0c0e7002006b80b5a7b19e06751472fde8cc6bf9c9dfef01120d089bc3a7760024aed32ae1d0fb2cbdc9a9603f26579cc1155f4e5eac172db925d91983ef3d0bb9524d27abd573506110080ed7b6052514e8f5305a755d1bd0ff1d3676b084587d5b4d8f2af75b1e9744fdfbe06ef5f5b06c3a7d03eaa113b386fc0b362d9eba1f61dc637af4083c6faf52ec9a2108154337a250a06d1c6424e5bb3e8328e714b6ae5f18426061c00049f2ea9afeaee54f96669fdbd93cb0d53cbf5ed80f5277f278d0c281eea0c1a71cb9f8ba22a04aa0a670e6f7a8e4f5e5edd248a16217ee812968c8ca169319d5a1752ca321d689afda327b8114755b5e00a16de0c8954b0f9ef41ae6e2ddb1a85710bdbd8d04a25653405a7e344c1752139be964f61221736c05d1f553a3fb2188f849ecd2d402559458767b41b68dc797f35a30a988f3ed03a92c55f27414dad030c3be0f79157f8f07441185cbff7a8630b8431e87ba497d0c9abe17fd86d809115f23e3b44a638ad4107bf2d51847cf8274f8329e92af72668196cdfb265628f5c4ccfe56fa4ac50c2347a9d7b0f6c01da8da17a8247275e8ed84edee9ec496c02e8fb551e839bded1221628712e7117b3561032f0fc692b65b7106ccaaa4f16a539435ea183d101db28f6cb2efabab65e6bdf3dcf87d2be444660503db54fb28602e70436dbde562ed0409456bb09d5e06f058f773c666a468352c226579955be68800301c791b938143c600bb576c7478bb1a42526209a806ab4da953240fc1bc2a66c1ad00354875d552505dcb9ca474caa235669b0f6daadfe550de3651454d055b9d85a1d1dc7014b9ea118b9683f0c1e0eb98943cfc4a9c539ba30f982117f29ba3267685b84ecf614898eb72167a50062f60d6981a804e2f55fc9c845dc03dcc02d26262602f8bfcd3911028a6ba61e093f96d481d4ebc69a8be5c85428734e7729b79c2434ca66cc0cf40163cc5833c11214c8f48ef5e8c7193824b523a0c668e2e0f5642edd4633a75111a3c70f6fa2997c8484a6c28c57ee0438322943728ad3a5b1fa83a8bfce49f99be12dbdffeb0505f53579ee02a579b7f97a7a4db08d6ea64e782e8d491dfeac45f17ed082d4aecae826c11c3d7dd2105fc4ad146f99e27445658a936760c848d8fddac81f5118092cfdbbff1fc089486c9db9a028c28d6dd4379ae65d63b91bbacf35af02a6e73b95cdba526e08d045e9efc23e3eef27e288930387e69f24fdb4bb6585359b594a3cd1042846e176688abbd9b57e59ea6976064894d1062161b1af54e33de4f2a6e1159e26a50adbea62536c2dd7a1c288dc7384a05d675ed8f59a84caef44d73a48aa2d2523c96c4bc78c93dce6c517e574e73ddcd71296bb52eea20c1c53f060a2da340106bd4e57a88ee94cbf6e33e2e2c869b60bb7a817b7e663f2108d5c88cdbbbe99bb8170e7a5b2472eac84aefc6011e52961e73dfcea0e0c962fddca5e7de19dda50c5ae74bf9e940d6fe867bb71d7453872055ed9009c1a3f0d98dd11889e95ed5111d06ce140e1caafa803fc161b7cf1e66866bd2d2b3728d23ba8b49e0d5ede61ae44e3e609649611f1acfce0f32c07442308c2e2b8d8b6a5968485c94c1f027601cca8d68202b3f128ee82a6842593789a90f2b6ded9e9b87e84e47bc6b35b65c893c9e83c4e50680bfc7ce568aafd09f637b4e3dca9a27e10ddc5e9ea3dc36650c36379c091b658e85047406a23a27df7ede40851c4a2e05a52e38e43f5107da831a536ee935cbbb83f4bb3488e04fb0190340b74fe54ed9385f03b3b5ebc04ee0821eca6b42e30c1feb8409149545dd118ea7d9d754e2b05e859dc557635a59bb167176af1ca5bb5bda7b4f8750f46c7da2c19a9e2c081456f4077d3a536335b81883b9db5f130ddb4303b2fa78be7d6090c17dcb409a237209755fc284c38ec7be66af33258ce0b342732715557b43846d1c15c2104ecb947cf0f4965020d1f8d355bd5890e9947e41505c1193e06fb84246305a11c2588b9c717d0b1eb23ef68bdfc04f918ba26b287d5b88317aca1041f18d8c1d63436500acd337013d6535e4f4ef00d4a913eac77e4da5b5e084bc32d44acc21bd9082e305dcc29f4f1eeb2ede1570583918f5a25a53793c83f20d6085fbe612e011f8bc3481a1ff145918f699b7caf52b83a28cc09c5a8404d1e91e0e90bf114164ca60115e3eafb37a4007b5a6112202228d5daefd415c46669359a1a80d10646ea63b24f240bb70016a729647bbacdb15b7eeae0cabe0c13c9b2308025d0c6e0074d289af3fc1a0f4c6d2c2fbc9af4709fbbdd5191aff11df19d777ce5e428392103dd20147888d3728605a3236aaf0d3a0a80d1e5f362fda622fca222fb2fece61a53f345086aa6c994b94af8d49c7326d4d6620eaa6b753befcefc3ed18edef0141edc3a9d32e9f02292b264da2df2faa112f09c9661247af9457e4f7d25cdab4ba5b4f9547fccb52f5046a4f66548680ea98fb27b28b7ff606a160b27a0edc64c5e52ad20922a1d1e0dc3771e54f926d76082150df0404610a62309a0a5934562a6f0f5a56a467d554ecc01027faaa00c1652f866cd78a5001173ecd04d5d49a086f990b97a9df9f90207a7ec225d882084f9c5d6402f16d5fa85eda4bfa2bd8e0b4a7afff43eae0296a7dd6b45682971a2a29f22d8118473aabb3ac2aba0d90121d4d954adaef58e4ad6cf4b9466d60ee39e99180709395fd56b0679cc2607e3d125e2364edb269bdf6b09ce5f84c553144139d8a328142b0b63a8c9b17e6e9192f34492b44d2b9d7f0e3a0238d77de6cada808e3c304a3085f28028eba4c448bf36782c1fd94fd5c90943cdbed1ee966b24e354df30cb671682464dcded72cef99a8ed08ab9d9c80142d0474336a51ba72b39f06640108b3567d9516babcacf459db7d86f2097bd6494da754d2efe153547f42dd2893310b9ae5a6d6d0f2356ec6e41428ec4ddb433180ac06a46226ca724e7448cd54f5119d196782f3251fa1eb65b31db96d830c9b0ac7c2c47301d9e77bc5a1c5584f89d467d4bca178dafb770dfb03fd3c8899db34b4da6e9046b756cadab7aa99f0a22ef666aa615f79d32deeb76705ae7e2aa0ed14e82091a477dd544938bff2b1bf243d8fc1af0c13f68a01fccc9e7dc2c49b4b887960b16d886d753dd1ef006a130deb9622e3770ca42be6641851c973730442da560cb4ea00f96ef641785cfc4ecb7a67f21cb2a915eb86dfd1af2753dc3ecfdbd976d8ebc3243b60ac4d425162f52796d926e7665363bd82bbd5b686af66f671ff8bd9ceb6cca543001d3349852f206b8745d957c946ae2ee26221979f0d133e2a0c5eef033d89a146fa2dfbf7f95db560e4b8e1bf444b42933f20f44389194fb80b07234c4c7ac1bf1a868d167adc05f4408b9f5783de43debd1b5b4081d359888f05474c61bb29cd9556f2e207e803b561e91af1b398e490eafe1899948c2613c1d450582cebe89109d568403dc386443eaa769136f16d97816bfb3119c7fa9cbaf67e4749c2387cec36fad2880134c8bb9e37d17dfc7110a1bc70ce7af02231b17ddeee273b73be94b2e2e84c1c4eb7fd98ee69feb7c5aebd7c126c2270cc1629a8df59922c8692568d39dfec06f1bc9171c0bc8d57cb204acb9ad9aaedc4578083fde38a79375c6fc6b7998a2e33f3f7190d2bd989d62ae456d5c3efd6ff240b08968b84f30cb481cb7c3c3de27518fb8a14500b08d20e093774fa4f4c7c97adbfe8eb344bf066f9413d12241beb6d8c0682e199f0e8e25c39b77379c13a936faf798da603532cc002bdceb0c459e710bde717889a9ddab1e8d6ae93c33b281206ea983891c3c7477af7f956dedf24fc970dcdfc1c539dc0b8928a687b9a94b5132786cdd37040ec5f774c8c004b22d124f9323f94c2e31d1731c1c908c6f335572851156d319d9e0d450d0a32de679e5825a8d455b10c71f999c94e8167bc3307c21554b79a1300c41a6286ced569927010c4bb95d1ae65f179b1dbae7585e211a18a78a2f3547498df1ffa9502ebdd3e51b296cbbd61a2c32c1601db66fa9908c569786e7597aa15b182d5d0322b7e3a0c3e33bf4daef0fe31bf9fb162c40cf87147327eda422417be182150df5731bc0517ce6863f925ce05fa8b6936aa2cad9137ddacc623d0a0ae160833d85ea5ffa851cc72ea9260c0f14f75a98efbbc6da2f13fc43c2c85757f1e12083f12f40e76fdf89201cffed3b1fd6d98ffd579ce79d94bd16d5d2b8515036ee93097cb9fdafafd3b3cfb69677a96d441db48ecb1f9b86b9851774c4d67abf598f4ea824bdf5c3e4d63bb74599485059ef825d40908039368f312f58a102ec86ae72f2f5aed32e341b42cf3e8726029694006205cfb3ac9fc7286c3e78a4c57eb7cc2b5dc704c8bd367c5f7ad4f16d9058bf4b19f942554f8f8a36e9eff2abb99811963c4d6b9c4d0e3624d28e15dd72692c794205b1b1667197f4b97e0102912bf15f29de6250f8e176fe969cadf81e6bd104332f7b597161b05dbbbad58e5c950fd84ff8240bcbb67b5d89f43d9572965e61a97161d703f5a459ca109435bbc65d91b80e3f3dbfc1a8e60e5a26b61bdcecef8992c0baa038397753fa71cf173abcf79c5d248574357b11e5116b7e90126d6f3213ffca917446bb8d00a42d6466c767498197f0b84ca973c851266410e6db64faa6c0eeef9a1cdb2f1c490390a19f9abe87d981b8d7749b1200ae9353d353a4b172d950c1e772e67992b789cca4cc0dadf98b577cfb2e2d884037cc6404cea84209d67d0a10d8a0562ac77f3a56c5e3373823fd520465ac7220aeeb77354471218ce70af5daeb423a3fb38bb93c2461bee899d7eb17018f91121b3227a00b31c0fea333bf3b6c50a5039167d90d5a8828736e15074dd5a62f9dee2f3695cc95c8c582c7766fa5a7e2d501c6ba3187e4c513c5aa0f0a78113853db9b313babcc7a169acefa8fd090d343ea20fa0cea4aae2fcfcbb5e2a797134bdc38564d7ce7ae0331d1aefe43acbd6009447762d86e12f20141dda99437f73285768fe9fa2ee768c8bc5f985d86172a26279f84ce4ff18876ab67890056ff8b5198b554abb35c3c2318d68af28f7f5d1704f03cf5f703ded35c1673c02e7ee304b1424ce5b4586dc68d6d431fb90faafabbaf354f044b3fed4e9ec0603276e3866b1b40877d1f69aa50ac3e6533ef44f2ed0531c492d8a624a5be90f082cb6b8de24117639fa52e63fdb255d36dc446a7c4aa7c351b022b3ebdaa93b33082f01294ede173f96d111d363d58cdee503e27d6b4e677741d1b6fcdf4b8ca6f5eee564f3a0423ebb47d7a9c67b39455ef99aa857b5aab6eb3f029ea66b165f1b6eb5c2f89021f85b2d9579f3b07f67446745b86e62b922bc5548d385f7ff28d6300bdf28bb3afe9cad4b96dd2c4cb0ef475256d75ce4d658589899f7be6d104b6a66b5b78b67f0c7f505d2639c5f6287110eabf1f51f4138e733789c3e3f039fe23102dd34efbccb90617a2077c54005645d585ab949600ad72c04e9107b8fc7cae378cc8e3b53f61d8b340c2b1294759a6cda2cb555eb63d5e701ccc796c572059a1cd92d603fdf52299a2882468517e7d07f969d0ec05de0630b1c2a74d25fad13527ed2275dc934e2f617fe70d2a46f8007437c2583a1db14ebf8f857714d158e2c7b8e7b8a45bbbb8813761b6d3e64d05224d3e62db2bd9f1e39beb93fe8082f079860f88a99c6755c0a8a792b77ceaadac5dd281d87fc03d889e1cbeaa068b1c5b268c84c449d297c42d23b6fd3edd0a55f24e4fec41582290db9cfe6e12b2b25060d1058c6b976a442af6e347d82bed9743f07e2da501b155b815e1f61a5b4459f359968f4738641d199519324c7bc437ae56c75f5f2b1a6802a2856c15a950cb27ea6315a28f7a2b69d1fca64be451864b6f11fd2036bab4cdbe2d36fd28594151e353439e7a565522d94ef73e648293c94c1d0e59759e4cb398006d3671a01712a5479580c3d79a7688f3e5d19e460e95646b77541f04daddc159ffc6cfdf488566a17f08e1002fe594742b3e7a51183cb90ac4b0c9b94b9f6605b4d3b50f4e25a7f4cf32ea55b94a2926fcabf5184d2397b862101876f9c58e146d15f41692b291e47de8aea3f0e44b1c67069f4d708b7e98974f47c22b17b44631b0ed2f05e7152399f921e70c21abe26897fa1137a78907f6266be90902fc4162429089a6c3e0c2d61faee4a5695dbe64f933a7f5fe28d9a0f03df982cf49c3b7d1cfc02338324e162189cbfb86c606546e4c0712d6d9036f4078d5140a53fad44fc174af1139a804c7d0e443d7d629697c2b725f8913e8449a9f6e41c11a03b8f3e6dcc1b778c4d18cf7893499b32192326f8a370e2ff16cd7d15cfcc3b6ae0ff5948a959a0c0a747483e8cbb91d8d0612487f7c5dd27d5b8c64671149dd6e8edf2c782e53c0ae52e804f5f4c5bbda92a8be2a62a0011322d44a0fd92d005a8f5ca874f8819c3d7e0270cafdb6f0d326093d1b9f0cfd9bbf50fc090a3f4db16e9a4d30647f157901eb9fbf87d42308b322f4747496337fe88d3b626d311710d4699391e25574ed56f941faf26d86ea6578eb152f5a6e5d535f36aaed3e6103c0e824cc369f9784832c17fbbbd3362c122c9fe6c9eb53167ef5a33594f014d5e151c6a11e09fe50af71c8577433920a48055aa00b5aa5aa3500930adb5e9033795a8ce9f504928ecad5858c2a37f090f66572f9ee60ec2453265ad6dcfe8d3367dc36e830249ceeaee0fdb9c4fa769f7d0fce083307544dff50027a9ada3ed88ae7392ba9fd69786eea01c1939b6650feb12561c85582b9025324d9a79cd570eb73b90a999c7ff2b1da1666da3816d313411b395f904394aa723fbac37b5448e070e977e49cd4fa9e69de8a1649a9fb32fc5fc6a63f09a9a57425f34fef0222cd3414ca6da467585417ad4ab8e4809b19387bae75037ecf8385752f06787a3cc614e81ba175af9145d6ed46abf467f3fd72b666519b2528d4feb242904973024266283ea1c0ffe5b87af6782e6b83a9a13dcd5b6edcf4d1ee08a795824f92ac08f60a2d96e7504bfe23930e2d7c0e09e3c8c8b2fe3c9d72b98fc86c160768e8725366d47e6a1b48453ae6d359d2be6dbb8ce979e2c3f4b960b9e13df96d54259e772b9f76a0d30151ff28354339cf53463feae9694c4284e3b3d3515aec92636688fbdc6203de3fa7537d81439c7f4ad7b9bbaeb48fdf2300356a7534377e1b2362b481b9ffe17936e05851367e6e8389468e62e118eda8fd8040c54fc297a88ec67cf66af1aaf50f1a50eedfe17f50e59e3975bd2043bcba78c6fad8fc2a28992c5accdd87e1e9d05c7091291217a1e342c00955bfa4d5c90e06bb7dbacb0423bfc4d85cba1a24397df35fcea14969f1a3ee92732614399ad022eaeb1385773f52d5b96713ed9c6e15cad2bc67a1fe328a2c4db0a313f822d8c5d555a67c7bfbcacf574c79b6c8752752b59a94eebd837e2f90e821b1cbe5e5ca3d261a4a12441c478a713e271e7ebb671b395382f869f50d73100f9388913f0ff5d5a60ecb6fa677e285f07a61d44fa97a505fe8aa845e2c93399ecd83b00f7fb918c9fb6b1bcdf2abfab2ffd95787d9ae318d35492639c4e243916ff5d96ecf2beb30f711784f456f022f93ac13d055eddfb927f87d21ca1b41ce05f4a8f0b5407faae66651c48cf5c09c6197b91578227e4233f69cdbb94e19afdce70e6bcf1f994f8fbb5fee7cd33954392b27c6c8a5bf9503219de3015f0225a818e75e4c5da392c7a6cd08c9f8681476d13171dd0c14b1013c5bd52be9f13a0d6c5894494f2de2d8681417814579f16ce3267c838df0d2467cc5a07dc7c051e40ae54d6c519bf6c058838895e4e55b551b7255822b08fc1dbfbe4f9197003d3f3122e5ebb5dd40070fade4c385e3f9cf097958f25be1f030e9e670c43b9e191512d47c3c07cd95e670de5da0843f21e2194d88bb22a0c2ab698acf0b10850687c9948924af5dbf07351b77abbdbf13c43404dec12963f74dba337d46a770c319105d4600f7d0541bc240ec1c59c2770c46edea3199ddc2960ababd65ee868408f1b1311bec11a83ec76899d63bff78c11bf324eedc0ba117015ba629451de3dab380223aa26ea51bb4610767dba073a53f4a5eae3d60ebc8fa33539ba5091ff03d7f6b3955b17e27fe98576129b845e37dfe832933846d80db58bea4a41c8d9e64afe576a21247f18ae5467fbbb39d8dda94bbd8223056828b95d971de030b340eb0dd73863db29d177df71e53ae402e0056ec7d15bfd85a7f1cb95a0e5c7ebf4c0cbd501f20ab955f47bb17f7b31de37b738f682b87f3a660855110038446fd2bac7e0ee9b10e325b4a4f32a045ef7a75ec2bb74b736ddf54a542de92221df5354201adaba0a9bab59dcc1bba932d0b62ef1562c079404d7acfb90ca48fad1d849449fd9d918497b70aacaa7cea0177e1bf72f395d0dcb1c5345b69417908c3014523e23f10540b59d5333ec909e5da63b4e02bc2fe5a05ebf301c5cd4b97b55e42786ab3cd8bf187ae9bdfe159b3220ff73303b345a2fd8205281e1045dfdce969a72ed73dbe1d319a5d709d85115780a6469aab5da1590e0b1ec7de458c4c2cb992c345ec2d0af9fff58c4e82d3345a53b6d8cb3306e0f1cccdc2ec09bac42115a39df68fe99f8bf71222233b7734acca55b5610f7510c9084a525a39ad9d40f7226c4053ebfd8e8e6fcc8e066923d922d083afe9b6ddaab832f10b3e641783c1ab8b67d6557cf3d12dcfb63bd5e19f313255f30ec6504e65f166681923b1576000b4a633a2f9777227f8d375ea0805957c1cd5ce1263cc890563f7c0a01f143bf3a49e43bb64e474400d76a3ed1392827e6e5add00788ceb4c1300580be3f29850347c5af78bbf5719ed853c13d1a42b55bca6bfddbb207fe8524b98726d1d7565f3c197692703ed4c3c5039a7d586b58d1f2e84d0e92ce771f0e198fc718b46caf2e06a1e68f899c9682e08458476ef06ac634669deda638e6ac71d781ab19ec3c29726e3b4aa77bdf0a16f8977741c98ae40111f5d6a8dcd86d1145acb9bb25905c5d6e91b3bd8555f71bd3b10c14403a9f29b35e517cff61b1bd2144adb519f8710aecfd2e09b455da3deac8284e480d682e219212635fc1f388bd267e7458642913d09e79b94d7ac7d472579bb003ff026e7040bce0f416b93b6a63eca774c7c9fe01034e59d6ab798b42024c10ef615dd82cb1d7b6682ff1a5e27e46553834b7e2a58c35f1a8f00d76a8fc89ae542c45b07171e50d149b1cbb0d42944f3efe4533c03fdf243c632ba9fe571a632d13bb46d9ae4bbc895040177629215245238b8fb8148a94162758b9683ca8f0f995d37205d5b21123b51d54b9975cbd625af7a248d219d58439b033c22ea24a62194ba1f6d89afd9964e671f66fc13cc4fca38d66c5d4a1b8b095340a36c8544eb530aac4a227e0526899c61e1e6730cad9967fb29ab7122da17930b767c49f1651bfb8ff133c6018c7bda4750ce4c5ddc477d381a0ede28ae15ad03c0d4b2e03200dc91731745a5a674095a5f64b1de3a24a28d7711dc602b9de4935bb7ba52476a2b50da3d65b3bc2a968282de993dcf6b2320ec4c72a485e715b1e0611fa04b60808cd7923933e04e4456910cb39cc78c58561f0cd3419603a294ea52f83e52654534fdc498ca6e8082527c3f1c29f6de997a2fccc2baf58d2fd92930d34a65b76507d431dc8728f0202ec47186bb43e55450033cd692495f85240ea02b63807048e81ef12b5d94d380e1b951799af62f7b0400a9ffa3ed472dd1a086e2104290ac5ff535026e41fcb9bf135c268c8dd7198905fc5dc45dc7a42bf05e50a6c22b24124c9780aa2e1ce0dc58b0947e13a343b43311bd8ec9321b7e3134db62c2bde4dea980cd60f9acd05fac46e7176ef512cfa4e5a1e1b137960eebbd2f67b10cbfbdca565a0a2826262ae55abce9c8cdb4a66d2331c842b1aa5bc1448c8c9dfa64d9af78f39d16f346bb9941e145324abbfe351b481c56cbb5aced0afd53dbf0eb72f7308f7c29e3abd72d10625beb0e2b6d4d5206528b35f0c8f59c87d9e69f0357ce673b9baa2310fbea16242b81c52cdc3abc40e4834e826752b2b3aa94b3ca34edca65b0ceda190b6401df74155607a661d5aa142af65acb96e6794a745f83a3cf558dda91f06062f5505e788dc7f7a9979e72769617917fdc56118835d08daaf59c6042d8e5d3ac71bf7d039b444cc41367923ea8427bfe2b97d2a887d1bdd60804796b1de0272dde07cdfaeeb090534d726c9b1fc186fc3d2c5872a30cf14d17057e58237ba07c7ca0f319c2651fc5df48f112868b8b675450b4162e66cfb57bf9dc7ca69a576788a8fc45af980369fef39d0d4ec809454f5224a9832504c480e475092d4c629f1ac83b41b72bd859f54d512df2cb0ddb319b28dfe6368c5b1fa43f0a2acd27b9ee06356c5064bd4761c7fde454b1ff3bc21c275a0bfe91551e1b11df298dd2bd1afb438c8c1a75fb46a60789af7cd54f8fe49fbc4af2029decf01c59fefd6ebece79f1ccdf36200e6793604b1be9afc4a8d5b3d496998e498d70ff41ab2a8e0359d0fff18fcc6f16e1e4f4a857b20919e1391cb7acc17cc2bfcdbbf1551c4645091f50b1904edf7ef0f27c514d87000810ff7bae712b66a2f51b7453e53765bf895183b71c4ee6cd0610ef04348541d6815ec85005503d76c06823e3d2538b1c9e35f722094c9f4bb08654d7647733922b5015711e125bb8766121f05364a4c2341c078105213aaec0dc2912cda9640d9f35ba2002bff19a99583e1bd1b260236d1639db2a0de42f6144eb188279784b96aeab8e990cf2bf327133adc8cd70a797c6406acc3c896e7fd32c1f959d2a162dd1e30bf4c0bd1faa793076f3bc2c7d0c87fa181e53e70103d6197d092acb382a7ee4bf58d5ee309438452fc28ed84173506831403c242b719b2b9e673bbe57921820aeb98809f9569884f135462f2434abd2117200385291dd6975e1e3c171122c5d4c75878a871cb509b8a20f52b389623cea05a9b032d3835f67bf1f91d54144f587c47edcd04ddd5edf90978c2aed6079efdb6a4c254895153ca2706d9345b9cffed7ee87db63d68eca0443415f6ca832be4e147f52561cdf85161ca119b4c404f89e4474a9ae954951217296a57a5e3168fcd71323ada652987229435b82392d92bb9af7a12acc99c42bfb4d2dfd439505f1235b6da488df0b249d6f14e9d18d066e64d766c10d6e76c0775f726685d16bb7c74307ffeb5e048b9370e0d278a7e46333d31a03c55a74a4acf4376d42bbc3db48aadbddeb46da31386b9f031352817fce4a6d97d3cfaf6242afeab79f9263b85f149178357915d720cf76890a74e39902cf796902fc9d5f526659605b7d8957bf21ee297b958a5baa285590551bc759674ca1138f481d8143f0aa2586098af509ebd85a6380e78154385c13dfa621ca4893c88fbb7763e51e2042cdf0e254b8c6f4dada0c253d3259a7d5421c113666616f306503aa27dd634c262a0a41d5c233320aa490f46031a52d8edb1632e5e829b16a850bccef7b23359565c3f523aa1448472d3d45b165c07652d617ec3c659b34c5d83140826d3b5eca2499546a992d7942f17fdb65bfa60e8457955f513210c15bd05d182afa3312c4484052a79b38bde7bf5ecc1fac407eab332a27486fa91d62f13b905bb2a86f9c15a9eb45119194ce61afa70aeadafe5244e9f28198d296dccae35f75844b40095aeda5496174964e40d883e672f844b27f8b3997bde67f805e0346cb9f6f91c566e58bc9764ec8bea0396e7fb68bd7a0a5bf6ac484676207ecb5a0f127df2bc7bc34ab50fe556549c236a597809a204f24216a8ffa121dd8fc80ec834b8105b2eacce1aaf16a2b8f53e9d09e6d4b3e05b7f549508d3e028d3073dee23420568a42a077a132f7bd43898babb713de327d16b1e1d37173e0188dd0d6d6a2383e9094902e01ec5a9377485693b5631beb00b8cbefdecd0b8005d9b38270282a40a853503a40d9288447421927c1be70a10afe14dae8f47ab5fc8036603fc5059809c3875b33394a489d978bb85257164c5ff424848ddde86ac37c1ccda236dabfff98412ea95c3b4bd6c1192ae53809f1081be9ff2866f2770f63f26ea5b0136646ca0cc8f52a0373de6bbc92a2cecbb4bf975498d1f7d76a18de40af91b5f090af0498186d44b282af4b76fc0cb985ec2209b1a67050dae6361ac2cfc33e23f7ce74c80fdff2bb12b8abedf4df2d6327e11c1adf7fde345d41e5315e5b88bc24bb2ef9c882d73a2c8d5ec3a9bfae8e2069417e69c3b6e5444fe55a697f2fc6d4c15eb49b02f1ba6b6d9ce0d9ac677fe882fd366c66c29ad37508305e6a3b79d49e3e8a4b2f7a00e955c48bfdfb2b5cd21d781a7258b4a949df6129b96a20bb3affaaf7223c23334382f4caea488a5db529e4bb9557cbfb427fcbb50cac885f0702d4a49451088e34397839f45fde0b93e073165876bdab444dedd69140cec3a08c4b8e24c2f44fc3c1cd039fc5ce6b738a7869f9c1076168ef26fef3387d856754bfa520ada7e2a5a1e1f58574a956a7b9bb27d1f676e5dd8d415fb13908366a9b99ad7d233e5e040ba2be463e0861188b776cdcac3febbd9518da6f364d79253553f3494072964ed927e92f79b6aff93818ba367c56761efab7393bc4192c5269722a57bb25d77e2535bd9b0950f58e80c55adaf991d46fc558c9dafc5c972d5eeb70c9e5857735bb15abde390fca73cdd7b5f65f56990420d9a8414d81eedd2a72f0bfda34d354608b7b9fed2b9bbd8f2957307753f69a50d5d0b7b5e271fd1e5d5bab353b051195169df28f751ed22454f23f81028da22364cc2d8e8b822c6381da083a1c12b04c3669802ca6b95781f9b703e59694fbdfb745012cee04994558a84dbc4983add81355daed2a371b1bd15e5d58f501aace0b1756dcc421c8abe91e001d1527ed37f3deda4eff7dc7fd74636e8450773ebed22412944bbe834bed7343168ef9a43e62ff7eee290cf752fb50e728bc62b81ebc8cf45db2c9d48aa1e0249dceca0679fcb33d0ede17bf150c29ab63ce87fe601f7bdad841be3df21a871c5fe208da762da4e59ed6d54af11f177cac460ded9d8f2db7b322b7ccbd1dc4bb484ad94d82463a8eb48131d0caa4a8bdf657b7527a0f1cfef57a62b96899bb7324ee0e7d28a81c4ffd8924de07ac6461c8285c14ac2b93e5fa56fab6f95e146dffb5d7071fd34b96b4e9e4ed44336ac79972473bbd9bc3325fbff9a84cbd0025b6abafbfc9809345c6addb26fdbd49826178319e0b63a1c003329ea932472cf42eba9ac792cbf6b438c9f633602c4abbdf730e77fc773c14f9019ac66bfe8b1f7ff416ee870df1a328a7e98d50450341c259b700e706e3066dbf44394a334de4bf9517803d8127cf8652488dfe6972a78db7c743bdb80e09de093d03fd4ca7d1ed00b2d66b5b6f265ca2b894dff31cda0b164707b8886164837a386dd9dc12ff29a26a3932f6ca962f529f7089836bfe780cbfecb6adf682ee730c8a7c826d601f3b326a1a8dddba527a115a23ecb3ceaa4dd09621f614dec0828ec1d46003d5d0b86a579be11cc145f82c95ea6ef4b848325901daaed456bb5066c76a732de49047d4e5e8e4aa4d17a0f87b2057127775a126bc0aae9f25d614954327eddb085c0086154a42fcc89f01b31e1cc71572ea7c425c241280ad78814d597c4d0aae8a0b3610b360050215aad9c652b7c3d42737faff78292c7a51edc29f6afad301eed27fa73f41efc219c4cd048562e4aecf964716b57b83724e8bd092b7a034c7a49514ffbe0fe036065c3efeafd55b43495119547f031fdc60f2683d4f9fee68c6f95e07d44a1f55689affe0a07f0ba24d837fefbf4f5d22c44af052d308da8e14138904e30d0c093b637d07d27005fb12c801cd7be02479bd76b360b44a7e490cda5f718ed07cd5dfb4f9fc5e119d119b1e8b883ff3d5cba3ef77cf74d102a28570c95e35f7d7baf620d394f386434834f26ab828ecf1289b79b5a615615a2c036ecfb1c00d066ec6c41dd7e3c3760a84846da5e88c93f9fba7bb3f5ffcdcecc2949a60336f7ea138e9fce943c1b6d56e05cc64f1ea37c611203478e61775810b950e0dbbea2233dd2d2343d74e1b01a6682760faed0f40462dc65f012257e1fcfe1679b6864616d298c3a36edcdbf6ab94e9c92b687285b61421d18fdd94d16ed1a06e7bbf92c203258645aef9d911b2cb241b57c938e7890b0d31d84d41d67d5ba9df5fc8fa2803cd7d0395ea81e050de5184cb339ec5c18d2c022e313b7b3be927f1d1d0f5b00dcaab702d2c79a5395d59d32e598fa6174ef5106274afcf03f9e36100c1af0f44778c35a48b2acb5c95ddbe7d1edc5f33bbf00b63056bdb6ba07b1b8cc3742ed0100edadba7f55341f9a1d2c47423d3fd25c89e579101d89a7a283660c9e8884a34b9f7d7fa1670cc31284ce42f705135482e9cd832fb45d854d042e991cf743ecfca57f60057e8207ce08a80569ea199af7a1d7ddd5f15a9d4cf8b2b7b1e5310226653d2a91be07af840060b71e5fdb18398c983b439cf0cbe09a590de5f120649ccea162017483e3604e9798d6b3e29ab5ae3860ee23ca9ba833f66a952b06090e6ca3886fa26cb25d2589f010ec8099959a40aecef7208a2a99c2dcf1562ae9b8d1960c618d13780857986331cf01b73b552be5fe55069556673919403a86fda255bee6af19426648d66aacd4b3e916a3d8bc3a530f108c876c3d1c3a15c46c69667de254da55b1ba568a3c427b4d5d42b5c7bab1d9af82481d7550d8822a6860f61bb44d76e9331bd71882e4c6c87b625883ff447ceb4033a2648dc3e5cca61dd1a4ebddf3054bdae9ee4e65055129965e7db9256db852b9f4295399d94ef95adb8790e0c211c66f5191fdd0d6950f1a7c2ea0cb5b08772d39067ebf733bd17a34a569b3d31358d794387dddcc19505b5e01d609e4984898c22ddea03fd3461bbfaa05efe5bd99988fba9534decd3fdb7916e0f0e45a9684b3ec9c2a893f7c8df62d7b3667c30766b4ddc413b41b78f56f2bc182af3b959cc8aa116915c2a23464ffd7b4e38c691656a67b6742c93aa0b34bd6572529a8228b5a1fbe8bdd6da4b95905374c0ccc3773f150f8078ed81f663cbdf9e5aa30bf4a0ae7c8e9a5aebc5f5f2f6eb077e82412bf287600b9633b02f167392acb3ef9609d4d09310da776868899923f16453cac518b23285cbb38a377d9c7b2f20a894fb223ef838629740a1aa0335504d8cfd50722f5138959485d0a2b5c24c99a8d3e02dd83d0e4ccde49f71dbfa2a7fff5bc0d728ef395cdf709ebfeafaefce96d405f9a8831a0a4bd1ed04479d4fe350822478547265a5767a7d25072af705783d952e52322b8b95472871f5f726d5dde3134fe779ef59d5802b45410b8dfc8c61492d3084375669c31c542e59cbad5d8f85810a5ddb8a4a55dbbf2a627e5ef9348e953681bd839294958b0e09a78aa36bde8cf0212fdb4557330a2461fe85dd4f76a7dcb2395b62be3fe053e19f53573ee3cb38179c0f6a1a1fdea631ccc82a589adda345ee7a8fca63b02222dbcf8400eb8b24422cbb1b55f049837adb676f8f02e1895343c9cf03dd581ff5c3bd4fce37d21064370b001a7e1e3975b4562e4cc8a5651a6c8b67f1cf5602c8446907eddd168d1a46dbe7832379de90057aba8ecdf15785219fcf3ebd252a5d70eacd805cf1949095918c693fe8a0a5060563009795679b3864c06f8966386fed56d423d3c13fa5a435699e3601ca5825e018487ec9b84f68622a4d37f589dbf2b1db328972edaca094eb8314f22ca3231d179dbddc85641ae35b1ce6f549d597877c5747cd7d7e46e9cf6056cde9684ce1c57b174af3ddd7af90dc7bf0f087a4cc78dd2eb18faac5e700c34b55e0ba23acce8310b1c9fe9233fa126003deb4349cc4d7d87544b1a4bc69148aca46d18241f2bba2b1d16ac5c352f01ae3fcde661389f203f70cc655eea771a30812359cbe54b95f8db096e4773130ab482ccbb6213bd510a18548a9187012d9bcfef45d8247f2cf62a8bd0f5d1f256f5818c5d952f9161bf6b6e6211b9e9b3df8cfa50fb678decdd0e175e7bdcde9dbc698277f5453a7be236d2fed89aae2a9e44901f5f511bdc634377601f96b572c89537fa3678a59d2d785c1436d5d89b4aac32a6b02d3abe6a514e6fc00e8a44fbb559a961d050661d84bcdac7ca443f68701946de6e3c0724d22f04104b2e3659d1655625c867f2829b8f63c78b023b6c7d90e09acd4d7b26e6e76f5ee23b3204bab631e3d03bac106df7ef258e932e00f7d07bf8049c20b032819020c8fa287f84d760dab9f6bbaca8e012998639e390043be2808cd1eebbc97671f48f74156375b9348196a48268340dc09b4fc14d9eb604f76914a1d6cc5d4087127fa66380bb7623beac45aee2b196","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
