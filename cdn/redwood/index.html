<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c7a672f5b9437957e1624abfdbd112593a7eeb772372fad41e31f0c7d34f1beb6f3d4a3919852861bb7e68b686d6b80e27a0d6390611e49813c6ce687f498a277b7f95e82526935f0d16b22efe44f6445a8d3fca5317c78888ce73b1c6b6bbf63a40317e505820712724b0c9583df04cf0accb0ab38754943d01162618d7b74147a4324ca9f2a362d9f6ae263f2e58d60b45d965d6b1214096fd36f804674e587663dedbb1f1bbe605f0c80c203cc3cc1cf57f4798af6239c942282a186cef316c26b30f1205e21aaf6af428a12f1a6c86a1918a9e194a62ce298d7fdd59ae47a87518fa2f027bffc0f3a066e59a2d2f71a356e7a9743fdac5c99ade88582936a058c03688e406887ac2772ac60ab9002ef57e07c03e2cfbb0f5f69fc424340d428b4fde4effb2a5c96cf6250548bb70972e9abde23bc98bdc978716ff97b3aa9ed78e8ffdce5554ac2f7cd2dcd8cfe4743a9b656b2cb060c0ea1ea5d7659dde1f70e9661bd960bf88418348820987110e0a392e12a21685624a3f0e3738acf5b3a0bee7c74ad2dbb9ae07f534c1b8942c0647b762d009833f172b1dfe423aff268c323fb5b45edd10156521f458938cf325a42196b58cbd2865d864fbf24ac458818ea10e22e29a773a19ffb5fac4af8e0bda5bd32fdebd8f0a39d0c0e405ce29da6b01e0e93c92d44569332bf3281493c4546bedb780daaaa7357079fce58b79a4a1c4afbe1517386759d3b240fefeb683d6156488b2fc377c5a6ff248513b7fcf490d00b05458439eb5de54fef5cb397a7a3b61a3adc05e1fff021507df9b5486dc223ef9b1c8562174497317f30e21c21b06eb31b019caa822a7e7efe65faf03c78a7360e55b1b5f6b5986f8e8cf66db41656f1cfd702c718316dd56a5262bef3bc72354bd1027e87abfcf27e4e283c7f70ce8b000ae58820d4f58c703666bab147e291d1c01c0d81f073fe55af5c1676ff9c1080e8d256b73f9d5b9419700c424bd9e93ef7e175817b3b6aa08baf029fa5a94f91e26f5fc71af8043248a6f960ff5e5822d8add61051b95bc4cf94245d1c4350e07caf6f2cb4a4bad67a99a785ffa7107a3f7e05117eeca510fc763d8255912738b7dcfc5efbb4f8a358b95f51f09b411e079a56b0d1e2c416c864e793ba9f0258ffc53539915c9f0e0439bf44ee7b94d3886f9ef4272ef1fc16be4efdec6de6b441aa417dca0d9356c27bcc6a598ea48be1fc9b8b20cf32b81ebe7b24a6edd80ec96ef9010e80ae298637140d3a9402e23a1e7c0b336e632a5e7b3997d925dd81885112dd0afaa8a87ccdf16ee2f4d30c08481bec636c081080cfc5697a0e8d598c25745420ca13b0574883413c51a514d5c48c2b4e61e697ecd3da5d3c484a51e3aad3801b8f3d5657122e76eca590436b3641aeaff57c348845a854a521ad9817230641eaae853f94eedd5f137e290f61dd22ab929d4c6d63271c55d7c0de736768daab43423eff28206305f3872b7730f1e468c48b37b2cada077295b8b66980a566196a166c683d5b06570fdb46b61a477dd28b3701d632f6430704623a88e5edbe4c5c9123c1df83ab2112d7c8dfcf7beeb564762587c77f251e2fb4d885797bcebf525d441a991e26b613e67a23cc92b8748054df4ea3e3b60a011d83fd9bc47c62dea7ff594267df37539925b175afd32753b6e496ebc395132413cd37526c707d2d46bd5574a879a7d8b068d14cd26b08eea4ded083a3d6889e671c9a2cd5812c1ccfd4fe74c3fc62c02c8d0e9d658521ce3a159f22cbffce062a804a9022182ae44ce6f5908505012ab2916ac96c0a5cb5278aea5baab2c04bb513c172d21310a8fb1cff857af77eaebb45503c4e23cd0619863f32965239cdc17537a38224c35e34d9b909d5cff87c2fe4b80756090a95f17d7b4765ba05beb16894c5255405ba3dc8f7c7697df044818105ac88f149d36faa456c4abb2678d6d2ea6fdd59262cf5b113122821127ff4f260265d81e4580d00fe4beb609fab344b8d19ca6cbdb287309478c159637a3f8d50c9014562b3c2e539734c9d6bfaa80db9a1b5df6ed5ad91b9713ab06ce757d324cd195d5250c2c2fd6ad43bd0b171f1adfe77eadaa703a0081ce6ed53b22c0217c01d0bb563d586d82bb4bec9d87cae2a8fc1156be67eea7b76dff92586c04891b8a1666490d23d5e56dcec8ea3693a4c2038c2f36a6258df75d2d5c72e977910aff2c342999195724ef200a4887d31e32016f58407d27ec17ac7c7f28a9bd2dcbf501bb6e3f881aca4668c4ce68c2eed78b0b11a49376d3eea235d8970af0561bd1d54bf62a53aafa45251a39e7ba3f4a9c58a7ae6d92e20cd7b4ba7f0a3633d0fbc877f9985d94f0745aada06f7d7e7eb55c74823ddb9d017787a42a2b86bbbe65921423529a9efd18894b2cd314d8ca2659ac2a240ac0c5edc4425109325d831b2a26cd6ef584d5d35ddf8611882026b3337d20345daed7d3f9cbb2b81e5d39eac835d022b2c32dcc1ea0483a0b691193dcf0fe0f08306eab63880d7719a849d2799cea5729a9b1e26391fd8a96ffd5a323bd3f80b5c1c943b0cfe56efbcec80a1d57ed692527bcac8d4d8f51eb95b7f94e901445ec351c354df71ff2bb14079fbe3ae9fe31d63f87e378c066ab20762586223d04b9ebca0bdb9f8973d4c823b60c418efdac96db471914ccba4226a96ecf7e0d9f89e180a01681411d66099ef59bca78c7e1ae6922bdd33f8fffe571038051dda8380b15158a8dea6bee6350fd5046aea6d37f28aeef712e906fdfd9a62c8101bfb04429bfd8e172e5e04852dc1b323f8ea0667d600f75ea25b9e54084a7579901864d2a4eaeabdcf05e2de3e9ee59907c983b0acae6730049132fffb95cc32adb08d8bd8db0c3c3ae6a8efafcc483dc66ed70001685c3677c77681e8319bac1d571364a924bfe69625adc6a81fff357caa9dc1190f19e3f880098a64f717b65ca511872e7745e8b19645edd87d4e20c676b5527c13f3cd779850add1f3659590ff43bc13e531a326db302464305c923306e31625c6b18db4eb8a83fd08c46dc5dde3dc3be7ab402aa494695ccb7a7c2e1272980a89747ebcc3de7dcb45b49045a1bf42fe26f459bff461d32cbef1debdbb8aa604e162b5e98b5adad617c78ca19c9d8f9c0bbb468ce89cf1b31b2564e5c5d052031dabd77bca3cbfc4819806a6f640713023e8036556956db9f2a3407a020b874582cfd14d91b6a178dca96740ccc8c5535e81c8663130ce34c61b2bbb297c8991808732556615c17268a2c8c52c0a0f2bbc8c49a674ec5388f6f60fd0658371aaf3e0e97471dfce266855ba829371260fe17693323dbb7d7aa41155a8bfe9233bc014d6f60853aed906c2429fbb7b2256cca1fd896c56bdff1444e04177281e3a8fbe4dfd002dc8058e6661981f82f8d936844980123a251ed8bbf1fe41de0dbd8ba61ae097b0c1ab432c9bc3ba96bd4cdf7229988eb3af784b6e52de83b323e089f178cbb428ffff60804495cd40581f79293e5f58ecd1e7669b2e904d0f8228319f09fea471a83ab680cd4e3fe7b154df7a9967f38f43ac3c464e0be9065dc389ba1207749078f8eacbfaacbafc35ee8e3143c684cb18a115f683a65aa091eb7ede4af1cad0abc67c6902d2b34087c6e8be632775d2dece150d764357f5be071b2df5a9b7656d7a453d9b2da98d1ffdf846f15968733137618c0b0f3845b4cd0a1c9d01fa869a747eaa8b28f0bbb3d334bc573484591dd96643f8cd0c73393013869a95957546f9d445500081c4c74918e6e18fb2afbcdc0e158d31880bf1d921a595d99daddf4caf5b7520b7c8ee3d2e684ce632c575cbe05a5c78e861eff72ed7b64962ec9707fd26c94dfabbb2bec6f1c246f3ee83554a703c9d904cfc25dde540fb022a3a0808c0ad1c8b9516178b54efa9114caff1802542793150eb5c0ee2ad4b6771804ed1cfbd0a28f9d0c0168189a8b11f0ba5644ecb7ba5406ba8ca0075354c74889ed8f4247de5e0ff43c16fd2b3b229657b9144aca85c077bd1d22614d1b187dce7bd16dae808173aaf1e8eaf7acceb271c8f5d7f4633183d93cef38f38ed5863aabf6ac3eaf77c29ad8ca3ab67a1eb73250a288fc965cf4db39801a2b3174ac77cdc1d19de39f9564093db9d051bcfe6ecb9c4f2372d887f26fdac26f3ce607dc96c96272aae0874a0392c9a13bb0daf518c005896b2631c03d9037886c483de68e7619f0fc5a0bf6e6da48814dc0068dc620c4e8ca73b8522f7160b0e4cae7ce397e52c0fbdba599579b15dc00e78d2cec78feaab4e9b5b19b0297b7556609b8fa379467ad2fa3bdb9b46c5003f3de966d37d18582851b6fc56f989555ad0862f1bb533a31f30041596948998878db425b0129292c5b9b43d2a119560d56c0e106872f5d2fd0661d2cae2a420fc25a9391c4abdcafe00f9588d5b06bf33e7a7c62b0fc628371f43e8936bf0decdc090a930a9695fea7be386ef7788df33463c83a0db83c321c8f22ba9fa892120c8ebd94a4932a7456c5008407002d2ddfa3e791f3e0f16b93233058822447f55ba326f00c98a8a000123e69cd394955ae928ea2390e9e8e7039158448a8b4626f61425cf2e4f2a530675212da1b96154f6a523c672bace9ce2b5e15d96e816865efa5ed3cd62eca07fcb92bb9f4f06556c2be5f535eaa63042e33ad49f1893b749fac952cc340a7d5be2d98ac2f1f0d609c076d92ed1431dd1446b63799ee686f7e18235d12b4cb12380c14c7c46a5d4675052a849bc18888f0b796354d0c274b0b879ec87d5930b36b5e1a883918cdd8d653f7b8c76cb75cbf9d2c168d2c483da227ff2a305a87e7ada6f7351a1f367be2d2e0090d9a7c2fcb9972018edd2a685488a1c7c280edbb2be881b6a5968cf811f1b783a6de744fc75cc2fcf76346573a5131a27d37266b265962a35d91f1d52fc4eaa8f64c1996ec6aa5bfbff2fee4bccbd3def401a6fd85ba4b51b7c059b769e09c460d9de4612baa4cc40d522734ad3bf5b1dd3bf016f183ae684412c1b024adbaa413727f93d960f2f5de822c55c38df19a3895c7e2cb7c7599901936a7b3f6f6fa000a703337286dc93150fe8934ae64ec452b5d63a091ab81e4d75ce18b9029b0b92ce8dca543da9296fca1b68d9208112ef81b75684d5451bd2d1e4b1f1dd09a99b22d246eafb55b4c2a95e13c3cd5535ab91098a089b9cac9bde50c4d6af17f31b6b56264eb8c5b44913c87cc726f85e65a8a41feda92def020ea3c58f2cfc0db663b54a38d0101a7dadbc09a36e4a7c3a790191d4a53a062657c9cdf1a8f17b2e1992f1d55f9fc0826743a5712b4d8257b671c0a031c99bb2ddc9a29f17c1f05aa5d2749717cbc3ff4cd627ef423d67d9520cf23a2e38ed203320f1221547af78a723ecf3d86497d0edd33c4aac32f751d9609b4cd10da4c7784f627ea9702804f673d8ccf92dfe5c8eb275758da9e77b3d28b2fa6a8567a48ea399722ab96e9b48836d50241314de910f4009e26a103ac82062606dc52ff20bf5904b167563ceb352fdb5c661460f1440ae4d4f32d2ff392d3fdf4118cee7edbd8889b6d6eb77d9574528776c843ecc7c1e64aa29f09683f7e8ad2d16eebc30a00db6997a6fb4c0fc8dc85fabc5185f8ed43f19988582f09d93d803be57ddea887761cbd4b578bf3beedac2671e5729b51ef2ea652fa9e9e61316ff6cb9bf6269e3b964234d696d7e54b2e71e28c863ad1938ecb54b0182fd87626a4e69500a6424e0988ad5b581298ce82cb12868ea145dd08ca81bab7e1686fffeee78eef513406bb7f164bc2868e43a784001988b7a5509255bad201ff4428b959c2163879ec186128ecd9a33f5434a9004aefb5b71492b9c3efebeff0a8b13ff8dd38c64c0f399389fbb92c533a73d7bcbb1e3c50876c7e10918afd4f27feeca94ef2a41d907a31603b12a6b5228a8f272325bd97530035b882a9106241bba32afe5a44e39c7277fccf7a0de5ef935428eecaaa51fe4a53b0d3ae1ef96eab1e16e7bd7d04df0379b42fc43534fdd64ec1b125571bd085abc9e50a6302b0731891ba80d5b5941fd8d62a261395fd2f5d2fe110028295e029d7a127e1998b90c44d6d3b9d551dfbca00e44d3f6baee94a4527439cc549f50d058566d04fab5ffdfdcbf02b024999a9ea54424a58cc59ee3cba0272fa825d01090638ec078d4760cdf3f5ff353d4bc604a90c92e4e238fc37dc3cef3887750c673ecd1f30a3c0bf02c5c2f94b65bd908577ee1ad660590fd8cc4cac050d8cbe0dadb33f7d678c6cf2f1aad8518110e90cbbf2f98933e4e1b3e7343c0a4d02f6d3a8bab372b3559b8323d25ec929d0694fea6f5cd8ba8d6cdae5caaa2060ab8868d4a299d8f88ef481771912bbec993ebf2c176c607d389255e99505fff2db5ec51c732889b452bbea6bbf172557eee9fcebfbbb6e79b803fdbc4e50a855003e159177b13a35b44a642216332d7a63dc728354a9e559c8a78a39b6616504ccfeffdd3007d45c7085ec07179d0ab2497bdb27a3dffb51eaa15db42bdee18d11986bc65a6f09f8ecbeee11a1f42177f67803c32bda7338c07f7924e77c73170cc6020ca47543047dbf869517f57aa3c4fa6239776b32a978f159d91952b21921262b843382e9f5aee652b96c61419dbf98d4ac0479bb3d2f57df21aeff77ae57776a8958c532456eb0a5bd41015db8fc211c068ecbab8520831542a5194d0c5a91a8ec20b11ec3a909f4df1e3b84419b81877c677c3cdd4f6c11d600c9a1a0d865d5fa6f7a0ec23b014c148f848602cace3ac046c47748eee70b403a854160c35f672a89eff9e9e479913773f1a419836cac535489b7746ae0d975759fecd926a2f59f18f1a2486f5de966fa6ae301bd2d6e7cd1891205753a64b65e0d39c65cfbb8b4e64d8f199b58c59cfbb819db0d64a18bef03a057a42e851e05c8a17fb683aa67eb04fde419a7a28b26f58faaab6bd6e211071de7f0f466783558b310c425b29660c90f0b60e4634fd056cc803ec40db228e79d0efbc184a919948e6e61f1ee99245bdd9775be2b064756cc5477829a084b37b67fb4ced7acec42d738ffef0738161fd77b402265faf8a3c8c7a5c92834e9fe7918480480c9bdb58fbcce9b8c82dae7e83e69b8e8eba2773214e68025514b91cba0f74303e621e61df2d81aae4c347bd2fd44bc5a0a8ae65770af98ff6a56185dc6cda7c8cfe894a95c30efc89ff323857afcf364081f3a84129beaff7e4ae58f82702e187aa6377b6a3d42a7c5b35931816d970676302e1ae8430ed2aacb270d5e9966b0827f08a0a9c95ee99b1a157d63d4aeae11ddd3817dd70dd97f8d7429c35dacf462bc4796c0f8aae47a4273dcb462df58b1162a23e53fc33425e2a40949b5ab2874bbbea4c1b14420ec84407a80ce456f3f87a2ef0e7fa560b2096641295f95b67680d8a1697d827d67ccaf70b0729361c3d1dd8f48d3e84521271179ef476e5c46ced85afe19ba599a9411635e9f692d264bff7526b768a196416d2db21b03cc87274065f57c72c2ba4ccb3e04ee1770bd5efc51825b74d75fdef396fdb0e7f39ca74898f5ca9c14157d56f3ed10ad66e7aaaa68b129d20fb6f628c643dc57fad4ade7153ea62c135d4a7de8326139f47b9aee0146f066a35a61dbae62ba33b830f438ccbcf3390362b0ef9fde8a1c85619c955eaae96b5aa23ce1451ecaa7dd18e2807718b76aec40f90393da4cd1cba6bf5d91aaa1a512e564ba61c87d8d2907b4413ba080b18482103ea86863e8d3ff9aa5311a111e388d3223a64b71f5df188bba441396d608ec718d3805cff48079c056c51b7187be08c08c6adf24474af5c605f1b50353ee13493de22b6403cd89d8a7730e0020a5ee3050604e7ae02f12a909b5e1ac9c39792662dbb8ede06f66c6f74c9321d5d94d1ebfa6e151ddd5efb73dc5d28d0ddb4b72e69ac52b2e8561931ee47fd4297926da5fb215ba6a3e3164bd1cb9f058527b28d9b7c5f6c7f9337cdf2cd76e21a4bdb037de171881d2b540af41950f7772f59cae0ce3b424aeee46804f6828ca1102a9a96e2d6e005e5cb03cc0c10fa6e46cd5e433dc8bb4d96986cd5a9476c3eb9678e75b3c56eb7695dee763c35bc6300951df6796e7db84211b4899e9e7c7844fdee30de3641eec438551e00a5a5e870a91598fb1d2d93843fc044aee7fedac45b41febc4bb41b10413502372c079f7edc8f1804921e672ed26d9488c7d5c66a48da10ea6343fcee83a0fea1294942b6570dab81c4426d06fdc97df4c1591e9ea206d123e0fbf19dda0517531c71169bf34e913b03ce9bd28de69601bdd2a1e6d4063775db0171cca15ac544ded0d6be26edeb43a513aed5bc09daae1a063f0ac19d60c3e6086b17db30b49c09c683f114080c67f308eb4f9b9668ad33c25cc493351160d5c0fac5b089ecf5eb91f95daa29b2329395fd65273a7529d2142c5d00724e03776194b9e04e415bb03230fb9053869881f936585e7ef8efc7c52d88615ad841976335a9eddf21d86cf410ca99aad108821d28eb873006b4f8adde9700db31a71014d35e83fbaf78b0f3dbbaccd971d30c9954c81047fa3a73d463a5ce64ba9ef224f5305d79fd7bed2267394ab6bd87deeb2b23dceeff0760ac9320596f20a5be3ea1f9b7de8adc3bb04100f3ed1643fb8d31789c244480fb9018711aabf4e1fbb790ddcc9029ec678dcf7d63ce095721d7aa66cc1521535083973adc3bdf368846e0905c1714401772792f0a8109587307d5f07ba0dce68fd2ea90a3281c8999a6392eda2b5f39ca2caa79580e84b20d2a2a795f7cc1299c50e3e404dffae9dfcc8e9666706958f8209c1c3f9646404b9c0595dfb1f46a352d15fb8d3043ea75f40e2a14dc979b019b67bc40ae76e313f914affd18e3e5bf04f8f727214cefc8a665f3477de97669ac6bb53437ac447ca2d068a5b8df5d86ef1ed9d3519a3bf6f206bddc7e8037b2a2c927efe806fd884f343bb72788c7f642874e7e6b601cc1d9959b5a01b90e682fd310c401062f8c9c543bdf316ceeeb41cb468db53c09bf89436b6741fc632de5a2b1aa67b5cf7e992bca64cf8afd0a8000cf336c53d111e04a83bf25f5ba62566e5104ab21c08fb8f14bab49eedb23416cba6d638911272460ef2ae57a90afb3d1a617d5c5b74677112f92698c58b2238c6c931bfe31a0a61a55dc7cee7a51636cca7797ec0801b1844d1d49703400b1b1346aec1fd97e8b068df6bf13fb1f709a4e4c4982cb72d59248c962e9b4a8e2b61cfddb88495b70e8e69afc9485a118e5a02a9b81d6ecbccaf425758ffed582bd0f5408ee081567ba89091e50edeb36a539f7fdb6fe29dbb35ef7b37e4e3a645d73d1becd97f7abeac7d7f0ee89779f83c768642347031abb1d0d3d9c93a18c133fc81a46a08bbcf831132ff43430521e89540af98c449c910137e48110787fe2be214232931ddef6e80447bf7d18aac91cc578ef35eecbcbe608820d0e34c3ca9a605ea0ee9d19d47e1ae54da308213991ce3871dddaeea00228818de5339c9bcd8a8abc23617b70547ee93225446471098ac1c0169a2da58364ce157130f48558ccd94ff9b6fcef1bba9d521763991974033ae9be696aa7e4ac0d8786efc3fbe95b4c0bfe50c2099eaa553f6d4f89da4b733b463ffca892e6204da25084a91341bbc7d4c041a370d2ae7ebb2d08407ed3c47557d393e63f01407fe59d0b0d703cbd4d29bae98a525cfa95bb08048ce30d8fe4298d606e96bc1dd338fb0762b86604ce43ceaf1fe6e64e7fb40f0617dca2040aae326da1fdc57d69fcdadb746270f1e290a016b47e5d4936ab74e07c4d0ed0bd03678506b27c757cbef324aeafd4cd49a1568e913ab6aeaf61cdb9bde665830f643b5dd17e23acdecae0385025f9f8c584821e607f35ea2da4a5f7f0a09aa9355ef0b76cd04e72c0772a7699ac15a05bfaff8507bad0970e47f166834cbc751b02f7b3db4235f4e9270cd658498a14af20df9b056fa802f3c6a0d15ecaaa1748f709d8df3233a4f15e87ae4b3a3c7c26d76f48c1a3030ea1af48de0c292c01fd8413bce10e4054463642bbfb742d0842edf59716e5ebb35188c8080e9924abba9af69fb5526669d1630a51978d0d8c37afdd669c0572be2212587aabb7e8beac1fec01e7d127f10574bfbe76316f5726c899b675b3065e0c4649dbca4d62a2a45cd62de507e48f1cca80e71033f5588411e1f04f378033e0395cc082aa72ddd72902e95530cbe84bc4573c9fe55c679b817fa110dbb3fb1aa8cedffaafb0f20ff935123c817c0c065750b999f3ed507b00e39c5d608d1f6e896eea08efae2e88b1d4e857a7a8218de9dbd5f2f94ca363fab70203e7f96f97256d93a05fd3255bcabcf7e519b501a75d68bcea16898e44d774ce05f7fa4ec6c8f8c3c5f01b13462d49b3fbff7f3bcbeda36bec0ccc00c479579e8590298ed920b54fafc0edd3714bfb9118c4697ea4e38d35339bcf1b3ec116c6843dadc1c87a8f02ad2834313e3e267c570a23e60e042e76b96199643dcd94aa3231eb8fab94af02a4a036ce1845308a2d294f6780f9dcc5999812d0a7e539527ba0becff94265d2d047d56820b7194e5e4189940e30b8380f7fe1ac14363bd1abac2ded1597f25a0554c4b30cb9f73513b917492a1affade8b8b636163a09056476ec5e664a883a990d8abc4813c922f6d913c91a3708dab9b3ba1a6daf17013de02f89190970bb03f4b670d7f22f69cc5253a971ff060b61ba5be46e922e3fb930d7f9fc2903a0940a9793278b3f13f24e897b49d6a05d7636031ceeeb33a18fa0c070499728bcc2b6ed4142665407af3da6796edfa9563430a36dfa2cc49eda05e22fb1e91658e7f50d46de48048c1d5c4171b987364074c0d3cf955992604a6bbe13eaee752435ed9bb1834b34d6b5e3db475c3f382ac5f60e07457a858df07e10e5c3ad34efb720010fd9da9dffc71112abdd3b113cc657fd2ad745d1daefd68d73ea7146f20fab2c6363021ec450fdc93faff3f17809d05838f8a84f308946292b4b951ece05c0355058031d7bad7e1191d0357bf05ba8686a151305c128b03fbb85ed074879ca2fe8d4c3b5fd85f051d3be0c0ff0465f9d96101af60336f2781f8cacb6b98fe2965b2021a6bc3721d0fe1f888349b405d9c9dc4a0db1df2c0babdf2927962fb517c82c556a96496729588c36198b54e516304fbfddf3aeda2b3cb73f9da814391119bfee17428d9186f66d74b5f7e702501fc135b17ebdcf23ac06107c93294700368f57a40cd06c60fdeda9382149fdfe22f4755e0a5182642b6f8d4978ea0a95fc6d206970276db05a0f0c647d06aff59a05f0429f9bc9e1e21412a0db3735ae70070d2f4500226a134419ab3192b6caac7a9035522ac44bc1cceb44bd413dc010bcb10580fbf3e69ded5a62b264799a5027ca38b790dafb64316142b46cce4d93f7a55037c6e5d555fe9af1155aef95de2f81f08d348a4ee01181b5aabc6dba32e33a032312ee3607ba61fbe9aec70818ea38e578a83fee0a9a16cfabdc073b7960bd85cfa863717b4923199356f20a57eb599eeb466ec44693bdddb3df291b9135b44c39639d81a6e6f7f491aa46e82be7b7a4a3bebbc265bbfd1c258e13199d19dfeaebe68338bdde61b1ca8e4da377b359662941b48f9c9b260883545de15e5c42e15696345457ce5474d1b8c4046a428662007ef548f22288f1299ad6bc849960a383b34e881bdb8f6bae94fb825076e93ec4bf86cdcd729aa9d131fa438cd4c3a22f018e66132ad8cabb0e27da552454990bd5fcaf6c7fb7cdb78cf3ced89885dacd0693a8ab05adaaa5c8848f383ed10536760b206029e638fdc29eac3c1d3225161548aaa79fb2e6df836ac5a27c0e5e308bea46dad9cc79c1474612a496a1b06e411cad0e3e73817fa63969e20bb71643c3ff724e769f6b96968973d1177108003ad47b5d86fda290169d10379c91d4c4d4739b7079672c1d52280eafa4fd7aa6b9a189f66ccf32be1763f153b1b156cb5abdb876a96e004472c225297c2a3eb0ee4d3d0c22da22d1e8ad2bd2523e5dfe1bce5c10afc2ae4c002abb96a0b996775b6db0ec62a3988c90e2a64e8f83a590d8c74f2d7dbdcab15201b45a39971549188863fb4352dd0a909e1b547c0f2e6b52048e573e0bb3245e258380c4f1565e486b001b4c1fd8fde24707d926d7c737a633514180cf58cfed344610a6860573f04d0e3f0e1b5ab0704433e21fb738178d76843bfea9ce62765027a24ceab6b95b175bc3d6a8c5bfaf0ec7f31a5b44f45ed5a74efb69371e484d2e52bae85c604b0288b31b25dbcf07f863e990c0f86125ae42f92ceaaf5bfaed5a604b49ac83602da1a8867ef5684ecb890a2d9044b385816766fe18deadea3b2f12187c6d3ed9f3877963a4c6c3154d566ed7db28b0efc8491c80ef61bbd64d49039092bb554710afbbfb1198d3034c2ca3cf53218ba27b0780cfd4aecfdf643a1cfad5da5175343b860dfdbfc32d6c6bf6b3e960e142a43a901194e615817afde9b2334aaf6ea71efee54b8f176fc3b69076674417f9d27d2961ef95fcbf303b67513ef6dd21b6c79c057bf4f794485928a9fae47fc4118bb3a60e87bc77928c504b08375c89101ac81ccb02645812bc1f35d867fa982d03629aa4dbeeb8737d9da14fc435e940cf7df148a06c50c1cac37cb3d46512317f33cd2ec6ad5f6ef9b99928baa11cb7934966c8709415eb81cf52d40d6aa189d261e71c4d252631441a3c206854be238e7d05f9f7aec68ad2e79f75fe81005837fee18e280275a10fe6fc346c10f7e2bca808f6e4147da114aa846e732eec45edea5e4d107de9edfa098c81aa0de754ff7eba8ad85fa2f010f1adb12bbaf403b90ebf579c734f87c34e90e5d25135af8593cf6990969c671ce9d40457f8958839d7300c2b7e133c7c7295a1392bb47d701e81efb283a8792ce9ca1a9934f9ed4ba31a7703f2427e810474bdbeb95df34f0347ad8786b1f2946eabeca637e972cc0cbc0b0ca6e2d9a0b505661fe1a4f8261e19c46694aee969765eb108485566f18ce84425da580781085dd11a83312b0882e7656826cc1ac570b685080e59bca7d9cd715cd964aa811476a653f173a3357b55e8d83605a4daacffa424065f3bcc046b23eb16e7330e57a5076d55ce61d99da6717ece5c6f54409bf585766a59b65ea561415f3bb04f6fc7f23f7cd6450d7eec414ee3bc5c4ed363b47438ff3405d47ebcdbefacb0d8b761e9ca58a1b21aba657ef879064dc158eaeaa8485e5d6cb8c9c5e706b4cc8676aa7db7e3bda249d983f81859e60a9663a4162bc37220f9239459453f60a3168752353e7a6bb03f03f009e99cf1a89f3b3a82b1bfab7581c59593eb223378e53f748afd32943a9476783a0ed8edb61d0caae7457ff1e1c18c1fd668f56a832882d7f5affcf091ebc2a8b1e1ce06413444abe06af046292a18c64fa3ccc15db0fd32d51ecd8920834bd3c04cafb1e4720a39aaaaa4666cd0d181c305680ff170797b2f2cbb3fc4dfdf6a2dbf79f71cc3067380267d03fb5a20ff9efea719803b73781a3c7c98472fc3d5c0614cbbefce0395ea70bfa208596dc7bd2c3885a1b9e4169ce2ef566459740c2b1a2bb1feb3940c0e8f8eddbca3e40f6e3bd4ac1c03559467ea40a39618c75e51f218333da1ad650a10efec2911d34ceb4ae42671c5e584fef0e813deb1294a93b05499a4f6af98bc12029b874d34af23c22afb62aacf53a04305a06e1e288825169bc71780eb225dcf7363db28f80c76502d0700e274803eae56a709668889e5cd000a12500219a7a89cf9a7f66b69480ef2f1339e55a63098f6b44858725c9d20866d2964f3f89910b4fe7d3669ae15076517879c9892543baa52d5116ce12bb43438fb761772bd97e888aa8657d5edd2a868932eb74071c229566578983678a34f0e2f223c0814cbb43c8e5ca9bd7a99a0ecc5cf2dd5e36afda1992fe4603c206f3bf6220111abd62d89f9f6f84a5601e9975efd8f7a7bdb6c7c0dccd5ea59459edde65156f192e0a1d83a4f9d13ea195714682211f35172507751a3cd4f7729e31e03401fcfec8b5cd7eb2090e58336f99b833438514badee9e9e43de643e2659cd6cff53df95211ac548afbe57563d31a6af050423fab2841db197a9da47a71e5cd33fecad3a575f353d329a51b673cd677f2886d76ef2243a88a0936fe76e7544c0ef2e75a84d85d98dca2e5a01811dbc3d52ba56ed0197754ae0cc02b57e1ada2217785d37716dca4f62c8f2a7fd484897496548d826fd393025356534b0c1e69a1b5b1582832b45ebf8deea51e2a5f1438563cfdc95975e33fb2aa0bc3802e254cabde032f50f3243f71410bc90b0492780715b30c79a7fbbb302953b83edb5f0fe42be90e408d6e4f049df047670a6fc897fa138f7d9be47c03d89c6535fb72a2c34fa1f5b786b07d3ec437afcabb4bc73fe73e6ef220803f269b05583753d0b2383944f549814d5f3c32841fe5bae56c31dc79cbf1536dd72cde581e56989148d63eeaa338e3ae1c982f23c28d4c2b8e5564595e0d8233c9db5e6b5a0e9397e2c34665af6356aaf2201a37e7f46436fa577e83c0874b151f2f6b8ac9fc86feef897a4c08d545783ea74e2cb61cc8a7eca09e956e638b7f62dd10a22854f710733c219ef4f64af264288001d087881c21aa11123377c469ba7ea95cfc51284e61bd3d86d43e37e43804ecfecec0e75dc384f15840f305c32443bccc4ef551b65dec217f6b7af1cb33bc5bd026bc9417768d5ec5bade9a641ab63df57b3a19b0e0fe9ca5eaa40c172c5ee0fa9a18eec824f32cf906b784c24a82d493c0f01f45d1b52c1602a994b27d7e5ce5a23e69af2340ac095f8dec3a14147c9529e95654036d93911dc805c6944467de0c33a0f555809b27bc09ff41d28c9e7d2a25abcc3409d1a7fa8e798653a8a1aa66cb4bc886285836d7d8c42573bd799b3c7e7052c931d83e311cc942359d2b33984ef128c6b67ebaedbb5a1fc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
